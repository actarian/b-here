{"version":3,"sources":["../../../src/js/image/image.service.worker.js"],"names":["f","define","amd","ImageServiceWorkerEvent","controllers","resize","src","blob","size","self","createImageBitmap","OffscreenCanvas","sendMessage","then","img","width","height","canvas","ctx","getContext","drawImage","convertToBlob","resizedBlob","type","data","postMessage","addEventListener","event","id","controller","abort","options","mode","fetch","AbortController","signal","_ref","defaultSize","emitDelay","onProgress","onComplete","onError","response","Response","ReadableStream","body","headers","status","contentLength","get","progress","Progress","reader","getReader","stream","start","push","read","_ref2","done","value","close","next","enqueue","catch","err","fetchProgress","error","console","log","request","XMLHttpRequest","open","responseType","withCredentials","onload","this","onprogress","onerror","send","constructor","length","eventStart","loaded","parseInt","chunk","chunkLength","Date","now","total"],"mappings":"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","file":"docs/js/workers/image.service.worker.min.js","sourcesContent":["\nconst ImageServiceWorkerEvent = {\n\tProgress: 'progress',\n\tComplete: 'complete',\n};\n\nconst controllers = {};\n\nfunction resize(src, blob, size) {\n\tif (!self.createImageBitmap || !self.OffscreenCanvas) {\n\t\treturn sendMessage(ImageServiceWorkerEvent.Complete, src, blob);\n\t}\n\tself.createImageBitmap(blob).then(function(img) {\n\t\tconst MAX_WIDTH = 320;\n\t\tconst MAX_HEIGHT = 240;\n\t\tlet width = img.width;\n\t\tlet height = img.height;\n\t\tif (width > height) {\n\t\t\tif (width > MAX_WIDTH) {\n\t\t\t\theight *= MAX_WIDTH / width;\n\t\t\t\twidth = MAX_WIDTH;\n\t\t\t}\n\t\t} else {\n\t\t\tif (height > MAX_HEIGHT) {\n\t\t\t\twidth *= MAX_HEIGHT / height;\n\t\t\t\theight = MAX_HEIGHT;\n\t\t\t}\n\t\t}\n\t\tconst canvas = new OffscreenCanvas(width, height);\n\t\tconst ctx = canvas.getContext('2d');\n\t\tcanvas.width = width;\n\t\tcanvas.height = height;\n\t\tctx.drawImage(img, 0, 0, width, height);\n\t\t// const options = { type: 'image/jpeg', quality: 0.9 };\n\t\t// canvas.convertToBlob(options).then(function(resizedBlob) {\n\t\tcanvas.convertToBlob().then(function(resizedBlob) {\n\t\t\tsendMessage(ImageServiceWorkerEvent.Complete, src, resizedBlob);\n\t\t});\n\t});\n}\n\nfunction sendMessage(type, src, data) {\n\tself.postMessage({\n\t\ttype: type,\n\t\tsrc: src,\n\t\tdata: data\n\t});\n}\n\nself.addEventListener('message', function(event) {\n\tconst id = event.data.id;\n\tconst src = event.data.src;\n\tconst size = event.data.size;\n\tif (id && !src) {\n\t\tconst controller = controllers[id];\n\t\tif (controller) {\n\t\t\t// console.log('Aborting', id);\n\t\t\tcontroller.abort();\n\t\t}\n\t\treturn;\n\t}\n\tconst options = {\n\t\tmode: 'cors', // no-cors, *cors, same-origin\n\t};\n\tif (typeof fetch === 'function') {\n\t\tif (self.AbortController) {\n\t\t\tconst controller = new AbortController();\n\t\t\toptions.signal = controller.signal;\n\t\t\tcontrollers[id] = controller;\n\t\t\t// console.log('AbortController', id);\n\t\t}\n\t\tconst response = fetch(src, options)\n\t\t\t.then(fetchProgress({\n\t\t\t\t// implement onProgress method\n\t\t\t\tonProgress(event) {\n\t\t\t\t\t// console.log('ImageServiceWorker', event.loaded, event.total);\n\t\t\t\t\tsendMessage(ImageServiceWorkerEvent.Progress, src, event);\n\t\t\t\t},\n\t\t\t}))\n\t\t\t.then(function(response) {\n\t\t\t\treturn response.blob();\n\t\t\t}, function(error) {\n\t\t\t\tconsole.log('ImageServiceWorker.error', error);\n\t\t\t})\n\t\t\t.then(function(blob) {\n\t\t\t\tdelete controllers[id];\n\t\t\t\tif (typeof size === 'object') {\n\t\t\t\t\tresize(src, blob, size);\n\t\t\t\t} else {\n\t\t\t\t\tsendMessage(ImageServiceWorkerEvent.Complete, src, blob);\n\t\t\t\t}\n\t\t\t}, function(error) {\n\t\t\t\tconsole.log('ImageServiceWorker.error', error);\n\t\t\t});\n\t} else {\n\t\tconst request = new XMLHttpRequest();\n\t\trequest.open('GET', src, true);\n\t\trequest.responseType = 'blob';\n\t\trequest.withCredentials = true;\n\t\trequest.onload = function() {\n\t\t\tif (request.status < 300) {\n\t\t\t\tif (typeof size === 'object') {\n\t\t\t\t\tresize(src, this.response, size);\n\t\t\t\t} else {\n\t\t\t\t\tsendMessage(ImageServiceWorkerEvent.Complete, src, this.response);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// new Error('Image didn\\'t load successfully; error code:' + request.statusText);\n\t\t\t}\n\t\t};\n\t\trequest.onprogress = function(event) {\n\t\t\t// console.log('ImageServiceWorker', event.loaded, event.total);\n\t\t\tsendMessage(ImageServiceWorkerEvent.Progress, src, event);\n\t\t}\n\t\trequest.onerror = function() {\n\t\t\t// new Error('There was a network error.');\n\t\t};\n\t\trequest.send();\n\t}\n});\n\n/*\nself.addEventListener('message', function(event) {\n\t// console.log(event);\n\tconst src = event.data;\n\tconst response = fetch(src).then(function(response) {\n\t\treturn response.blob();\n\t}).then(function(blob) {\n\t\t// Send the image data to the UI thread!\n\t\tself.postMessage({\n\t\t\tsrc: src,\n\t\t\tblob: blob,\n\t\t});\n\t});\n});\n*/\n\nfunction isFetchProgressSupported() {\n\treturn (\n\t\ttypeof Response !== 'undefined' && typeof ReadableStream !== 'undefined'\n\t);\n}\n\nfunction fetchProgress({\n\tdefaultSize = 0,\n\temitDelay = 10,\n\tonProgress = () => null,\n\tonComplete = () => null,\n\tonError = () => null,\n}) {\n\treturn function FetchProgress(response) {\n\t\tif (!isFetchProgressSupported()) {\n\t\t\treturn response;\n\t\t}\n\t\tconst { body, headers, status } = response;\n\t\tconst contentLength = headers.get('content-length') || defaultSize;\n\t\tconst progress = new Progress(contentLength, emitDelay);\n\t\tconst reader = body.getReader();\n\t\tconst stream = new ReadableStream({\n\t\t\tstart(controller) {\n\t\t\t\tfunction push() {\n\t\t\t\t\treader\n\t\t\t\t\t\t.read()\n\t\t\t\t\t\t.then(({ done, value }) => {\n\t\t\t\t\t\t\tif (done) {\n\t\t\t\t\t\t\t\tonComplete({});\n\t\t\t\t\t\t\t\tcontroller.close();\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (value) {\n\t\t\t\t\t\t\t\tprogress.next(\n\t\t\t\t\t\t\t\t\tvalue,\n\t\t\t\t\t\t\t\t\tonProgress\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcontroller.enqueue(value);\n\t\t\t\t\t\t\tpush();\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.catch((err) => {\n\t\t\t\t\t\t\tonError(err);\n\t\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tpush();\n\t\t\t},\n\t\t});\n\t\treturn new Response(stream, { headers, status });\n\t};\n}\n\nclass Progress {\n\n\tconstructor(length, emitDelay = 1000) {\n\t\tthis.eventStart = 0;\n\t\tthis.loaded = 0;\n\t\tthis.length = parseInt(length, 10) || 0;\n\t\tthis.emitDelay = emitDelay;\n\t}\n\n\tnext(chunk, onProgress) {\n\t\tconst chunkLength = chunk.length;\n\t\tthis.loaded += chunkLength;\n\t\tthis.eventStart = this.eventStart || Date.now();\n\t\tif (this.length >= this.loaded || Date.now() - this.eventStart > this.emitDelay) {\n\t\t\tthis.eventStart = Date.now();\n\t\t\tconst progress = {\n\t\t\t\ttotal: this.length,\n\t\t\t\tloaded: this.loaded,\n\t\t\t};\n\t\t\tonProgress(progress);\n\t\t}\n\t}\n\n}\n\n/*\nfunction fetchProgress__(response, onProgress) {\n\tconst reader = response.body.getReader();\n\t// Step 2: get total length\n\tconst contentLength = +response.headers.get('Content-Length');\n\t// Step 3: read the data\n\tlet receivedLength = 0; // received that many bytes at the moment\n\tlet chunks = []; // array of received binary chunks (comprises the body)\n\twhile (true) {\n\t\tconst { done, value } = await reader.read();\n\t\tif (done) {\n\t\t\tbreak;\n\t\t}\n\t\tchunks.push(value);\n\t\treceivedLength += value.length;\n\t\tif (typeof onProgress === 'function') {\n\t\t\tonProgress(receivedLength, contentLength);\n\t\t}\n\t\t// console.log(`ImageServiceWorker.onProgress ${receivedLength} of ${contentLength}`)\n\t}\n\t// Step 4: concatenate chunks into single Uint8Array\n\tlet chunksAll = new Uint8Array(receivedLength); // (4.1)\n\tlet position = 0;\n\tfor (let chunk of chunks) {\n\t\tchunksAll.set(chunk, position); // (4.2)\n\t\tposition += chunk.length;\n\t}\n\t// Step 5: decode into a string\n\tlet result = new TextDecoder('utf-8').decode(chunksAll);\n\t// We're done!\n\tlet commits = JSON.parse(result);\n}\n*/\n"]}