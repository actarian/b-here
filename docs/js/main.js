/**
 * @license beta-bhere-development v1.0.30-canary.0
 * (c) 2023 Luca Zampetti <lzampetti@gmail.com>
 * License: MIT
 */

(function(g,f){typeof exports==='object'&&typeof module!=='undefined'?f(require('rxcomp'),require('rxcomp-form'),require('rxjs'),require('rxjs/operators'),require('three'),require('html2canvas')):typeof define==='function'&&define.amd?define(['rxcomp','rxcomp-form','rxjs','rxjs/operators','three','html2canvas'],f):(g=typeof globalThis!=='undefined'?globalThis:g||self,f(g.rxcomp,g.rxcomp.form,g.rxjs,g.rxjs.operators,g.THREE,g.html2canvas));})(this,(function(rxcomp,rxcompForm,rxjs,operators,three,html2canvas){'use strict';function _interopDefaultLegacy(e){return e&&typeof e==='object'&&'default'in e?e:{'default':e}}var html2canvas__default=/*#__PURE__*/_interopDefaultLegacy(html2canvas);const CHUNK_REMOTE = /* html */`
<!-- remote sidebar -->
<div class="group--remote" [class]="remoteClass" *if="state.live">
	<div class="agora-stream" (toggleControl)="onToggleControl($event)" (toggleSpy)="onToggleSpy($event)" agora-stream [stream]="remote" type="remote" *for="let remote of remotes">
		<div class="agora-stream__player"></div>
		<div class="agora-stream__info" [class]="{ spyed: state.spying == streamId, controlling: state.controlling == streamId }">
			<svg class="cam-muted" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#cam-muted"></use></svg>
			<svg class="mic-muted" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#mic-muted"></use></svg>
			<div class="id" [innerHTML]="stream.clientInfo.name || streamId" *if="stream.clientInfo"></div>
			<button type="button" class="btn--control" [title]="'title_control' | label" (click)="onToggleControl(streamId)" *if="state.role === 'publisher'">
				<svg class="control" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#control"></use></svg>
			</button>
			<button type="button" class="btn--spy" [title]="'title_spy' | label" (click)="onToggleSpy(streamId)" *if="state.role === 'publisher'">
				<svg class="spy" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#spy"></use></svg>
			</button>
		</div>
	</div>
	<div class="group--members" *if="state.mode == 'virtual-tour'">
		<div class="members" *if="state.role === 'publisher'">
			<svg class="spy" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#users"></use></svg>
			<span class="members__count" [innerHTML]="state.membersCount"></span>
		</div>
		<div class="credits">
			<a class="btn--credits" href="https://www.websolute.com/" target="_blank" rel="noopener">
				<svg viewBox="0 0 270 98"><use xlink:href="#b-here"></use></svg>
			</a>
		</div>
	</div>
</div>
<!-- remote screen -->
<div class="group--remote-screen" *if="remoteScreen">
	<div class="agora-stream" agora-stream [stream]="remoteScreen" type="remote">
		<div class="agora-stream__player"></div>
		<div class="agora-stream__info">
			<div class="id" [innerHTML]="stream.clientInfo.name || streamId" *if="stream.clientInfo"></div>
		</div>
	</div>
</div>
`;
const CHUNK_SERVICE = /* html */`
<!-- service -->
<div class="group--service">
	<button type="button" class="btn--back" [title]="'title_back' | label" (click)="onBack($event)" *if="isBackButtonVisible">
		<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#arrow-prev"></use></svg>
	</button>
	<button type="button" class="btn--view-mode" [title]="'title_view_mode' | label" (click)="toggleMode($event)" *if="state.mode != 'embed'">
		<svg width="24" height="24" viewBox="0 0 24 24" *if="state.mode == 'virtual-tour'"><use xlink:href="#live-meeting"></use></svg>
		<svg width="24" height="24" viewBox="0 0 24 24" *if="state.mode == 'live-meeting'"><use xlink:href="#virtual-tour"></use></svg>
	</button>
	<button type="button" class="btn--volume" [title]="'title_volume' | label" [class]="{ muted: state.volumeMuted }" (click)="toggleVolume($event)">
		<svg width="24" height="24" viewBox="0 0 24 24" *if="!state.volumeMuted"><use xlink:href="#volume-on"></use></svg>
		<svg width="24" height="24" viewBox="0 0 24 24" *if="state.volumeMuted"><use xlink:href="#volume-off"></use></svg>
	</button>
	<button type="button" class="btn--fullscreen" [title]="'title_fullscreen' | label" [class]="{ muted: state.fullScreen }" (click)="toggleFullScreen($event)">
		<svg width="24" height="24" viewBox="0 0 24 24" *if="!state.fullScreen"><use xlink:href="#fullscreen-on"></use></svg>
		<svg width="24" height="24" viewBox="0 0 24 24" *if="state.fullScreen"><use xlink:href="#fullscreen-off"></use></svg>
	</button>
	<button type="button" class="btn--navmap" [title]="'title_navmap' | label" [class]="{ active: state.showNavmap }" (click)="toggleNavmap($event)" *if="navmap && state.mode != 'live-meeting'">
		<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#navmap"></use></svg>
	</button>
</div>
`;
const CHUNK_LOCAL = /* html */`
<!-- local streams -->
<div class="group--local" [class]="{ publisher: state.role == 'publisher', viewer: state.role == 'viewer' }" *if="state.live">
	<button type="button" class="btn--silence" [title]="'title_silence' | label" [class]="{ active: state.silencing }" (click)="onToggleSilence()" *if="state.role === 'publisher'">
		<svg class="mic-muted" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#mic-muted"></use></svg>
	</button>
	<button type="button" class="btn--control" [title]="'title_control' | label" [class]="{ active: state.controlling == state.uid }" (click)="onToggleControl(state.uid)" *if="state.role == 'publisher'">
		<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#control"></use></svg>
	</button>
	<div class="agora-stream" *if="!local"></div>
	<div class="agora-stream" agora-stream [stream]="local" type="local" *if="local">
		<div class="agora-stream__player"></div>
		<div class="agora-stream__info">
			<svg class="cam-muted" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#cam-muted"></use></svg>
			<svg class="mic-muted" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#mic-muted"></use></svg>
		</div>
	</div>
	<div class="agora-stream agora-stream--screen" agora-stream [stream]="screen" type="local" *if="screen && hasScreenViewItem">
		<div class="agora-stream__player"></div>
	</div>
</div>
`;
const CHUNK_LOCAL_SMART_DEVICE = /* html */`
<!-- local streams -->
<div class="group--local" [class]="{ publisher: state.role == 'publisher', viewer: state.role == 'viewer' }" *if="state.live">
	<div class="agora-stream" agora-stream [stream]="local" type="local" *if="local">
		<div class="agora-stream__player"></div>
		<div class="agora-stream__info">
			<svg class="cam-muted" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#cam-muted"></use></svg>
			<svg class="mic-muted" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#mic-muted"></use></svg>
		</div>
	</div>
</div>
`;
const CHUNK_CONTROLS = /* html */`
<!-- controls -->
<div class="group--controls" *if="state.live">
	<div class="group--actions">
		<button type="button" class="btn--call" [title]="'title_disconnect' | label" (click)="disconnect()">
			<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#call"></use></svg>
		</button>
		<button type="button" class="btn--cam" [title]="'title_mute_camera' | label" [class]="{ muted: state.cameraMuted, disabled: !local }" (click)="toggleCamera()">
			<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#cam"></use></svg>
		</button>
		<button type="button" class="btn--mic" [title]="'title_mute_mic' | label" [class]="{ muted: state.audioMuted, disabled: !local || silenced }" (click)="toggleAudio()">
			<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#mic"></use></svg>
		</button>
		<button type="button" class="btn--screen" [title]="'title_share_screen' | label" [class]="{ active: screen }" (click)="toggleScreen()" *if="('screenShare' | flag) && (state.role == 'publisher' || state.role == 'attendee' || controlling)">
			<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#screen"></use></svg>
		</button>
		<button type="button" class="btn--chat" [title]="'title_chat' | label" [class]="{ active: state.chatDirty }" (click)="toggleChat()" *if="('chat' | flag)">
			<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#chat"></use></svg>
		</button>
		<button type="button" class="btn--navinfo" [title]="'title_navinfo' | label" [class]="{ active: state.showNavInfo }" (click)="toggleNavInfo()" *if="showNavInfoToggler">
			<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#navinfo"></use></svg>
		</button>
	</div>
</div>
`;
const CHUNK_CONTROLS_SMART_DEVICE = /* html */`
<!-- controls -->
<div class="group--controls" *if="state.live">
	<div class="group--actions">
		<button type="button" class="btn--call" [title]="'title_disconnect' | label" (click)="disconnect()">
			<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#call"></use></svg>
		</button>
		<button type="button" class="btn--cam" [title]="'title_mute_camera' | label" [class]="{ muted: state.cameraMuted, disabled: !local }" (click)="toggleCamera()">
			<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#cam"></use></svg>
		</button>
		<button type="button" class="btn--mic" [title]="'title_mute_mic' | label" [class]="{ muted: state.audioMuted, disabled: !local || silenced }" (click)="toggleAudio()">
			<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#mic"></use></svg>
		</button>
	</div>
</div>
`;
const CHUNK_MEMBERS = /* html */`
<!-- members -->
<div class="group--members" *if="state.mode == 'live-meeting'">
	<div class="members" *if="state.role === 'publisher'">
		<svg class="spy" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#users"></use></svg>
		<span class="members__count" [innerHTML]="state.membersCount"></span>
	</div>
	<div class="credits">
		<a class="btn--credits" href="https://www.websolute.com/" target="_blank" rel="noopener">
			<svg viewBox="0 0 270 98"><use xlink:href="#b-here"></use></svg>
		</a>
	</div>
</div>
`;
const CHUNK_MEMBERS_SMART_DEVICE = /* html */`
<!-- members -->
<div class="group--members">
	<div class="members" *if="state.role === 'publisher'">
		<svg class="spy" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#users"></use></svg>
		<span class="members__count" [innerHTML]="state.membersCount"></span>
	</div>
	<div class="credits">
		<a class="btn--credits" href="https://www.websolute.com/" target="_blank" rel="noopener">
			<svg viewBox="0 0 270 98"><use xlink:href="#b-here"></use></svg>
		</a>
	</div>
</div>
`;
const CHUNK_MEDIA = /* html */`
<!-- media -->
<div class="group--media" media-player>
	<button type="button" class="btn--play" [title]="'title_play' | label" (click)="onPlay()" *if="!playing">
		<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#play"></use></svg>
	</button>
	<button type="button" class="btn--pause" [title]="'title_pause' | label" (click)="onPause()" *if="playing">
		<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#pause"></use></svg>
	</button>
	<div class="track" (click)="onTrack($event)">
		<div class="track__progress" [style]="{ transform: 'scale(' + this.progress + ', 1)'}"></div>
	</div>
</div>
`;
const CHUNK_AR_VR = /* html */`
<!-- ar-vr -->
<div class="group--ar-vr">
	<button type="button" class="btn--ar" [title]="'title_ar' | label" [href]="view?.ar" (click)="tryInAr()" *if="view?.ar">
		<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#ar"></use></svg> <span>Try in AR</span>
	</button>
	<button type="button" class="btn--vr" [title]="'title_vr' | label" [class]="{ disabled: vrService.isDisabled() }" (click)="vrService.toggleVR()">
		<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#vr"></use></svg> <span [innerHTML]="vrService.getLabel()"></span>
	</button>
</div>
`;
const CHUNK_LIKE = /* html */`
<!-- like -->
<div class="group--heart" *if="view && ('like' | flag)">
	<svg class="love" [class]="{ active: view.showLove }" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#heart"></use></svg>
	<button type="button" class="btn--heart" [class]="{ active: view.showLove }" (click)="addLike($event)">
		<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#heart"></use></svg>
		<span class="badge" [innerHTML]="view.likes" *if="view.likes"></span>
	</button>
</div>
<div class="group--spacer" *if="!view || !('like' | flag)"></div>
`;
const CHUNK_CHAT = /* html */`
<!-- chat -->
<div class="group--chat" *if="state.chat" agora-chat (close)="onChatClose()"></div>
`;
const CHUNK_LOCK = /* html */`
<!-- lock -->
<div class="ui__lock" [class]="{ spying: spying }" *if="locked || controlling"></div>
`;
const CHUNK_NAVMAP = /* html */`
<!-- navmap -->
<div class="group--navmap" *if="navmap && state.showNavmap && state.mode != 'live-meeting'">
	<img draggable="false" [src]="navmap.asset | asset" *if="navmap.asset" />
	<div class="navmap__item" [style]="{ left: item.position[0] * 100 + '%', top: item.position[1] * 100 + '%' }" (click)="onNavmapItem(item)" *for="let item of navmap.items">
		<img draggable="false" [src]="'textures/ui/nav-point.png' | asset" />
		<div class="title" [innerHTML]="item.title" *if="item.title"></div>
	</div>
</div>
`;
const CHUNK_BACKGROUND = /* html */`
<!-- background -->
<div class="background" [class]="{ 'background--image': ('background.image' | env), 'background--video': ('background.video' | env) }" *if="state.status != 'connected'">
	<img [src]="'background.image' | env | asset" *if="'background.image' | env" />
	<video [src]="'background.video' | env | asset" *if="'background.video' | env" oncanplay="this.muted = true; this.classList.add('ready');" playsinline autoplay muted loop></video>
</div>
`;
const CHUNK_LOGO = /* html */`
<!-- logo -->
<a class="btn--logo" [routerLink]="':lang.access' | route" *if="state.status != 'connected'">
	<img [src]="'logo' | env" *if="'logo' | env" />
	<svg viewBox="0 0 270 98" *if="!('logo' | env)"><use xlink:href="#b-here"></use></svg>
</a>
`;
const CHUNK_CREDITS = /* html */`
<!-- credits -->
<a class="btn--credits" href="https://www.websolute.com/" target="_blank" rel="noopener" *if="state.status != 'connected'">
	<svg viewBox="0 0 270 98"><use xlink:href="#b-here"></use></svg>
</a>
`;
const CHUNK_COPYRIGHT = /* html */`
<!-- copyright -->
<span *if="'gdprRoutes' | flag"> <span [innerHTML]="'copyright' | label"></span> <span *if="'privacy_policy' | label">-</span> <a [routerLink]="':lang.privacy' | route" class="btn--colophon" [innerHTML]="'privacy_policy' | label"></a> <span *if="'terms_of_service' | label">-</span> <a [routerLink]="':lang.terms' | route" class="btn--colophon" [innerHTML]="'terms_of_service' | label"></a></span>
`;
const CHUNK_LANGUAGE = /* html */`
<!-- language -->
<div class="group--language" language *if="state.status != 'connected'"></div>
`;
const CHUNK_VIRTUAL_TOUR = /* html */`
<!-- Virtual Tour -->
<div class="ui virtual-tour" [class]="uiClass" *if="state.status == 'connected' && isVirtualTourUser">
	<!-- world -->
	<div class="ui__body">
		<div class="world" world [view]="view" [views]="pathViews" (navTo)="onNavTo($event)" (navLink)="onNavLink($event)"></div>
	</div>
	${CHUNK_REMOTE}
	<div class="group--header">
		${CHUNK_SERVICE}
		${CHUNK_LOCAL}
	</div>
	<div class="group--footer">
		${CHUNK_CONTROLS}
		${CHUNK_MEDIA}
		${CHUNK_AR_VR}
		${CHUNK_LIKE}
	</div>
	${CHUNK_MEMBERS}
	${CHUNK_CHAT}
	${CHUNK_LOCK}
	${CHUNK_NAVMAP}
</div>
`;
const CHUNK_SMART_DEVICE = /* html */`
<!-- Smart Device -->
<div class="ui remotes" [class]="uiClass" *if="state.status == 'connected' && state.role == 'smart-device'">
	<div class="ui__body"></div>
	<!-- remote sidebar -->
	<div class="group--remote" [class]="'group--remote--' + remotes.length" *if="state.live">
		<div class="agora-stream" (toggleSpy)="onToggleSpy($event)" agora-stream [stream]="remote" type="remote" *for="let remote of remotes">
			<div class="agora-stream__player"></div>
			<div class="agora-stream__info">
				<svg class="cam-muted" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#cam-muted"></use></svg>
				<svg class="mic-muted" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#mic-muted"></use></svg>
				<div class="id" [innerHTML]="stream.clientInfo.name || streamId" *if="stream.clientInfo"></div>
			</div>
		</div>
	</div>
	<!-- remote screen -->
	<div class="group--remote-screen" *if="remoteScreen && !hasScreenViewItem">
		<div class="agora-stream" agora-stream [stream]="remoteScreen" type="remote">
			<div class="agora-stream__player"></div>
			<div class="agora-stream__info">
				<div class="id" [innerHTML]="stream.clientInfo.name || streamId" *if="stream.clientInfo"></div>
			</div>
		</div>
	</div>
	<div class="group--header">
		${CHUNK_LOCAL_SMART_DEVICE}
	</div>
	<div class="group--footer">
		${CHUNK_CONTROLS_SMART_DEVICE}
	</div>
	${CHUNK_MEMBERS_SMART_DEVICE}
</div>
`;
const CHUNK_SELF_SERVICE_TOUR = /* html */`
<!-- Self Service Tour -->
<div class="ui" [class]="uiClass" *if="state.status == 'connected' && state.mode == 'self-service-tour'">
	<!-- world -->
	<div class="ui__body">
		<div class="world" world [view]="view" [views]="pathViews" (navTo)="onNavTo($event)" (navLink)="onNavLink($event)"></div>
	</div>
	<div class="group--header">
		${CHUNK_SERVICE}
	</div>
	<div class="group--footer">
		<div class="group--spacer"></div>
		${CHUNK_MEDIA}
		${CHUNK_AR_VR}
		${CHUNK_LIKE}
	</div>
	${CHUNK_NAVMAP}
</div>
`;
const CHUNK_EMBED = /* html */`
<!-- Embed -->
<div class="ui" [class]="uiClass" *if="state.status == 'connected' && state.mode == 'embed'">
	<!-- world -->
	<div class="ui__body">
		<div class="world" world [view]="view" [views]="pathViews" (navTo)="onNavTo($event)" (navLink)="onNavLink($event)"></div>
	</div>
	<div class="group--header">
		${CHUNK_SERVICE}
	</div>
	<div class="group--footer">
		<div class="group--spacer"></div>
		${CHUNK_MEDIA}
		${CHUNK_AR_VR}
		${CHUNK_LIKE}
	</div>
</div>
`;const environmentServed = {
  appKey: '8b0cae93d47a44e48e97e7fd0404be4e',
  channelName: 'BHere',
  flags: {
    production: true,
    useProxy: false,
    useToken: false,
    usePrefetch: true,
    useExtendedUserInfo: false,
    useEncryptedUrl: false,
    gdprRoutes: false,
    selfService: true,
    guidedTourRequest: true,
    guidedTourAccess: true,
    ssoLogin: false,
    ssoRegister: false,
    editor: false,
    editorAssetScreen: false,
    menu: true,
    menuEmbed: false,
    navmaps: false,
    screenShare: false,
    chat: false,
    ar: true,
    like: true,
    hideNavInfo: true,
    useIframe: true,
    attendee: true,
    streamer: true,
    viewer: true,
    smartDevice: true,
    selfServiceProposition: false,
    navInfoAnimated: false,
    navInfoImportantAnimated: false,
    navMoveAnimated: false,
    navMoveImportantAnimated: false,
    navPointAnimated: false,
    navPointImportantAnimated: false,
    navTitleAnimated: false,
    navTitleImportantAnimated: false,
    navTransparentAnimated: false,
    navTransparentImportantAnimated: false,
    useTextureEnvironment: true,
    usePaths: false,
    antialias: true,
    alpha: false,
    premultipliedAlpha: false
    // maxQuality: false,
  },

  navs: {
    iconMinScale: 1,
    iconMaxScale: 1.4
  },
  profiles: {
    // streamer: "480p_1", // 640 x 480 x 15
    streamer: '480p_2',
    // 640 x 480 x 30
    // streamer: "480p_3", // 480 x 480 x 15
    // streamer: "480p_4", // 640 x 480 x 30
    // streamer: "480p_6", // 480 x 480 x 30
    // streamer: "480p_8", // 848, 480 x 15
    // streamer: "480p_9", // 848, 480 x 30
    // streamer: "480p_10", // 640 x 480 x 10
    // streamer: "720p_1", // 1280 x 720 x 15
    // streamer: "720p_2", // 1280 x 720 x 30
    // streamer: "720p_3", // 1280 x 720 x 30
    // streamer: "720p_5", // 960 x 720 x 15
    // streamer: "720p_6", // 960 x 720 x 30
    // streamer: "1080p_1", // 1920 x 1080 x 15
    // streamer: "1080p_2", // 1920 x 1080 x 30
    // streamer: "1080p_3", // 1920 x 1080 x 30
    // streamer: "1080p_5", // 1920 x 1080 x 60

    // attendee: "720p_2", // 1920 x 1080 x 30
    attendee: '1080p_2',
    // 1920 x 1080 x 30

    // publisher: "720p_2", // 1920 x 1080 x 30
    publisher: '1080p_2',
    // 1920 x 1080 x 30

    // screen: "480p_1", // 640 × 480 x 5
    // screen: "480p_2", // 640 × 480 x 30
    // screen: "720p_1", // 1280 × 720 x 5
    screen: '720p_2' // 1280 × 720 x 30
    // screen: "1080p_1", // 1920 × 1080 x 5
    // screen: "1080p_2", // 1920 × 1080 30
  },

  logo: null,
  /*
  background: {
  	// image: 'img/background.jpg',
  	video: 'img/background.mp4',
  },
  */
  selfServiceAudio: null,
  // 'audio/self-service.mp3',
  colors: {
    menuBackground: '#000000',
    menuForeground: '#ffffff',
    menuOverBackground: '#0099ff',
    menuOverForeground: '#ffffff',
    menuBackBackground: '#0099ff',
    menuBackForeground: '#000000',
    menuBackOverBackground: '#0099ff',
    menuBackOverForeground: '#ffffff'
  },
  editor: {
    disabledViewTypes: ['waiting-room', 'room-3d', 'media'],
    disabledViewItemTypes: ['texture']
  },
  assets: '/Modules/B-Here/Client/docs/',
  dist: '/Modules/B-Here/Client/dist/',
  workers: {
    image: '/Modules/B-Here/Client/docs/js/workers/image.service.worker.js',
    prefetch: '/Modules/B-Here/Client/docs/js/workers/prefetch.service.worker.js'
  },
  textures: {
    envMap: 'textures/envMap/studio_small_03_2k.hdr',
    grid: 'textures/grid/grid.jpg'
  },
  toneMappingExposure: 1,
  githubDocs: 'https://raw.githubusercontent.com/actarian/b-here/beta-bhere-sso/docs/',
  template: {
    email: {
      supportRequest: '/template/modules/b-here/email/support-request.cshtml'
    }
  }
};const environmentStatic = {
  appKey: '8b0cae93d47a44e48e97e7fd0404be4e',
  channelName: 'BHere',
  flags: {
    production: false,
    useProxy: true,
    useToken: false,
    usePrefetch: true,
    useExtendedUserInfo: true,
    useEncryptedUrl: true,
    gdprRoutes: true,
    selfService: true,
    guidedTourRequest: true,
    guidedTourAccess: true,
    ssoLogin: false,
    ssoRegister: false,
    editor: true,
    editorAssetScreen: true,
    menu: true,
    menuEmbed: true,
    navmaps: true,
    screenShare: true,
    chat: true,
    ar: true,
    like: true,
    hideNavInfo: true,
    useIframe: true,
    attendee: true,
    streamer: true,
    viewer: true,
    smartDevice: true,
    selfServiceProposition: false,
    navInfoAnimated: false,
    navInfoImportantAnimated: false,
    navMoveAnimated: true,
    navMoveImportantAnimated: true,
    navPointAnimated: false,
    navPointImportantAnimated: false,
    navTitleAnimated: false,
    navTitleImportantAnimated: false,
    navTransparentAnimated: true,
    navTransparentImportantAnimated: true,
    useTextureEnvironment: true,
    usePaths: true,
    antialias: true,
    alpha: false,
    premultipliedAlpha: false
  },
  sso: {
    issuer: 'bhere-sso',
    origin: 'http://localhost:3010',
    loginUrl: 'http://localhost:3010/sso/login?redirectUrl={redirectUrl}',
    logoutUrl: 'http://localhost:3010/sso/logout?redirectUrl={redirectUrl}',
    registerUrl: 'http://localhost:3010/sso/register?redirectUrl={redirectUrl}',
    verifyTokenUrl: 'http://localhost:3010/sso/verifytoken?verifyToken={verifytoken}'
  },
  navs: {
    iconMinScale: 1,
    iconMaxScale: 1.4
  },
  profiles: {
    // streamer: "480p_1", // 640 x 480 x 15
    streamer: '480p_2',
    // 640 x 480 x 30
    // streamer: "480p_3", // 480 x 480 x 15
    // streamer: "480p_4", // 640 x 480 x 30
    // streamer: "480p_6", // 480 x 480 x 30
    // streamer: "480p_8", // 848, 480 x 15
    // streamer: "480p_9", // 848, 480 x 30
    // streamer: "480p_10", // 640 x 480 x 10
    // streamer: "720p_1", // 1280 x 720 x 15
    // streamer: "720p_2", // 1280 x 720 x 30
    // streamer: "720p_3", // 1280 x 720 x 30
    // streamer: "720p_5", // 960 x 720 x 15
    // streamer: "720p_6", // 960 x 720 x 30
    // streamer: "1080p_1", // 1920 x 1080 x 15
    // streamer: "1080p_2", // 1920 x 1080 x 30
    // streamer: "1080p_3", // 1920 x 1080 x 30
    // streamer: "1080p_5", // 1920 x 1080 x 60

    // attendee: "720p_2", // 1920 x 1080 x 30
    attendee: '1080p_2',
    // 1920 x 1080 x 30

    // publisher: "720p_2", // 1920 x 1080 x 30
    publisher: '1080p_2',
    // 1920 x 1080 x 30

    // screen: "480p_1", // 640 × 480 x 5
    // screen: "480p_2", // 640 × 480 x 30
    // screen: "720p_1", // 1280 × 720 x 5
    // screen: "720p_2", // 1280 × 720 x 30
    // screen: "1080p_1", // 1920 × 1080 x 5
    screen: '1080p_2' // 1920 × 1080 30
  },

  logo: null,
  /*
  background: {
  	// image: 'img/background.jpg',
  	video: 'img/background.mp4',
  },
  */
  selfServiceAudio: null,
  // 'audio/self-service.mp3',
  colors: {
    menuBackground: '#000000',
    menuForeground: '#ffffff',
    menuOverBackground: '#0099ff',
    menuOverForeground: '#ffffff',
    menuBackBackground: '#0099ff',
    menuBackForeground: '#000000',
    menuBackOverBackground: '#0099ff',
    menuBackOverForeground: '#ffffff'
  },
  editor: {
    disabledViewTypes: ['waiting-room'],
    disabledViewItemTypes: ['texture']
  },
  assets: '/docs/',
  dist: '/dist/',
  workers: {
    image: './js/workers/image.service.worker.js',
    prefetch: './js/workers/prefetch.service.worker.js'
  },
  textures: {
    envMap: 'textures/envMap/studio_small_03_2k.hdr',
    grid: 'textures/grid/grid.jpg'
  },
  toneMappingExposure: 1,
  githubDocs: 'https://raw.githubusercontent.com/actarian/b-here/beta-bhere-sso/docs/',
  template: {
    email: {
      supportRequest: '/email/support-request.html'
    }
  }
};class Utils {
  static merge(target, source) {
    // override null values
    if (source === null) {
      return source;
    }
    // assign new values
    if (!target) {
      if (source && typeof source === 'object') {
        return Object.assign({}, source);
      } else {
        return source;
      }
    }
    // merge objects
    if (source && typeof source === 'object') {
      Object.keys(source).forEach(key => {
        const value = source[key];
        if (typeof value === 'object' && !Array.isArray(value)) {
          target[key] = this.merge(target[key], value);
        } else {
          target[key] = value;
        }
      });
    }
    return target;
  }
}const NODE = typeof module !== 'undefined' && module.exports;
const PARAMS = NODE ? {
  get: () => {}
} : new URLSearchParams(window.location.search);
const DEBUG = PARAMS.get('debug') != null;
NODE ? null : document.querySelector('base').getAttribute('href');
const HEROKU = NODE ? false : window && window.location.host.indexOf('herokuapp') !== -1;
const VERCEL = NODE ? false : window && window.location.host.indexOf('vercel.app') !== -1;
const DEPLOYED = HEROKU || VERCEL;
const STATIC = NODE ? false : DEPLOYED || window && (window.location.port === '41789' || window.location.port === '5000' || window.location.port === '6443' || window.location.host === 'actarian.github.io');
const DEVELOPMENT = NODE ? false : window && ['localhost', '127.0.0.1', '0.0.0.0'].indexOf(window.location.host.split(':')[0]) !== -1;
const PRODUCTION = !DEVELOPMENT;
const ENV = {
  STATIC,
  DEVELOPMENT,
  PRODUCTION
};
class Environment {
  get STATIC() {
    return ENV.STATIC;
  }
  set STATIC(STATIC) {
    ENV.STATIC = STATIC === true || STATIC === 'true';
    console.log('Environment.STATIC.set', ENV.STATIC);
  }
  get href() {
    if (DEPLOYED) {
      return this.githubDocs;
    } else {
      return this.assets;
    }
  }
  getAbsoluteUrl(path, params) {
    let url = `${window.location.origin}${path}`;
    // let url = `${window.location.protocol}//${window.location.host}${path}`;
    Object.keys(params).forEach(key => {
      url = url.replace(`$${key}`, params[key]);
    });
    return url;
  }
  getPath(path) {
    return this.isLocal(path) ? this.href + path : path;
  }
  isLocal(path) {
    return path.indexOf('://') === -1;
  }
  merge(options) {
    if (options) {
      Utils.merge(this, options);
    }
  }
  constructor(options) {
    if (options) {
      Object.assign(this, options);
    }
  }
}
const defaultOptions$3 = {
  port: 5000,
  // fontFamily: 'GT Walsheim, sans-serif',
  fontFamily: 'Work Sans, sans-serif',
  colors: {
    menuBackground: '#000000',
    menuForeground: '#ffffff',
    menuOverBackground: '#0099ff',
    menuOverForeground: '#ffffff',
    menuBackBackground: '#0099ff',
    menuBackForeground: '#000000',
    menuBackOverBackground: '#0099ff',
    menuBackOverForeground: '#ffffff'
  },
  editor: {
    disabledViewTypes: ['waiting-room', 'room-3d', 'media'],
    disabledViewItemTypes: ['texture']
  },
  renderOrder: {
    panorama: 0,
    room: 10,
    plane: 20,
    tile: 30,
    model: 40,
    banner: 50,
    nav: 60,
    panel: 70,
    menu: 80,
    debug: 90,
    pointer: 100
  }
};
const defaultAppOptions = {
  channelName: 'BHere',
  flags: {
    heroku: HEROKU,
    vercel: VERCEL,
    deployed: DEPLOYED
  },
  navs: {
    iconMinScale: 1,
    iconMaxScale: 1.4
  },
  url: {},
  languages: ['it', 'en'],
  defaultLanguage: 'it',
  labels: {},
  data: {},
  fields: []
};
const environmentOptions = window.STATIC ? environmentStatic : environmentServed;
let options = Object.assign(defaultOptions$3, defaultAppOptions, environmentOptions);
options = Utils.merge(options, window.bhere);
const environment = new Environment(options);
console.log('environment', environment);/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

var __assign$3 = function() {
    __assign$3 = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign$3.apply(this, arguments);
};/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

var __assign$2 = function() {
    __assign$2 = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign$2.apply(this, arguments);
};var makeOptions = function makeOptions(opts) {
  if (opts === void 0) {
    opts = {};
  }

  return {
    arrayFormat: opts.arrayFormat || 'none',
    booleanFormat: opts.booleanFormat || 'none',
    nullFormat: opts.nullFormat || 'default'
  };
};

var encodeValue = function encodeValue(value) {
  return encodeURIComponent(value);
};

var decodeValue = function decodeValue(value) {
  return decodeURIComponent(value);
};

var encodeBoolean = function encodeBoolean(name, value, opts) {
  if (opts.booleanFormat === 'empty-true' && value) {
    return name;
  }

  var encodedValue;

  if (opts.booleanFormat === 'unicode') {
    encodedValue = value ? '✓' : '✗';
  } else {
    encodedValue = value.toString();
  }

  return name + "=" + encodedValue;
};

var encodeNull = function encodeNull(name, opts) {
  if (opts.nullFormat === 'hidden') {
    return '';
  }

  if (opts.nullFormat === 'string') {
    return name + "=null";
  }

  return name;
};

var getNameEncoder = function getNameEncoder(opts) {
  if (opts.arrayFormat === 'index') {
    return function (name, index) {
      return name + "[" + index + "]";
    };
  }

  if (opts.arrayFormat === 'brackets') {
    return function (name) {
      return name + "[]";
    };
  }

  return function (name) {
    return name;
  };
};

var encodeArray = function encodeArray(name, arr, opts) {
  var encodeName = getNameEncoder(opts);
  return arr.map(function (val, index) {
    return encodeName(name, index) + "=" + encodeValue(val);
  }).join('&');
};
var encode = function encode(name, value, opts) {
  if (value === null) {
    return encodeNull(name, opts);
  }

  if (typeof value === 'boolean') {
    return encodeBoolean(name, value, opts);
  }

  if (Array.isArray(value)) {
    return encodeArray(name, value, opts);
  }

  return name + "=" + encodeValue(value);
};
var decode = function decode(value, opts) {
  if (value === undefined) {
    return opts.booleanFormat === 'empty-true' ? true : null;
  }

  if (opts.booleanFormat === 'string') {
    if (value === 'true') {
      return true;
    }

    if (value === 'false') {
      return false;
    }
  }

  if (opts.booleanFormat === 'unicode') {
    if (decodeValue(value) === '✓') {
      return true;
    }

    if (decodeValue(value) === '✗') {
      return false;
    }
  }

  if (opts.nullFormat === 'string') {
    if (value === 'null') {
      return null;
    }
  }

  return decodeValue(value);
};

var getSearch$1 = function getSearch(path) {
  var pos = path.indexOf('?');

  if (pos === -1) {
    return path;
  }

  return path.slice(pos + 1);
};
var isSerialisable = function isSerialisable(val) {
  return val !== undefined;
};
var parseName = function parseName(name) {
  var bracketPosition = name.indexOf('[');
  var hasBrackets = bracketPosition !== -1;
  return {
    hasBrackets: hasBrackets,
    name: hasBrackets ? name.slice(0, bracketPosition) : name
  };
};

/**
 * Parse a querystring and return an object of parameters
 */

var parse = function parse(path, opts) {
  var options = makeOptions(opts);
  return getSearch$1(path).split('&').reduce(function (params, param) {
    var _a = param.split('='),
        rawName = _a[0],
        value = _a[1];

    var _b = parseName(rawName),
        hasBrackets = _b.hasBrackets,
        name = _b.name;

    var currentValue = params[name];
    var decodedValue = decode(value, options);

    if (currentValue === undefined) {
      params[name] = hasBrackets ? [decodedValue] : decodedValue;
    } else {
      params[name] = (Array.isArray(currentValue) ? currentValue : [currentValue]).concat(decodedValue);
    }

    return params;
  }, {});
};
/**
 * Build a querystring from an object of parameters
 */

var build = function build(params, opts) {
  var options = makeOptions(opts);
  return Object.keys(params).filter(function (paramName) {
    return isSerialisable(params[paramName]);
  }).map(function (paramName) {
    return encode(paramName, params[paramName], options);
  }).filter(Boolean).join('&');
};
/**
 * Remove a list of parameters from a querystring
 */

var omit = function omit(path, paramsToOmit, opts) {
  var options = makeOptions(opts);
  var searchPart = getSearch$1(path);

  if (searchPart === '') {
    return {
      querystring: '',
      removedParams: {}
    };
  }

  var _a = path.split('&').reduce(function (_a, chunk) {
    var left = _a[0],
        right = _a[1];
    var rawName = chunk.split('=')[0];
    var name = parseName(rawName).name;
    return paramsToOmit.indexOf(name) === -1 ? [left.concat(chunk), right] : [left, right.concat(chunk)];
  }, [[], []]),
      kept = _a[0],
      removed = _a[1];

  return {
    querystring: kept.join('&'),
    removedParams: parse(removed.join('&'), options)
  };
};/**
 * We encode using encodeURIComponent but we want to
 * preserver certain characters which are commonly used
 * (sub delimiters and ':')
 *
 * https://www.ietf.org/rfc/rfc3986.txt
 *
 * reserved    = gen-delims / sub-delims
 *
 * gen-delims  = ":" / "/" / "?" / "#" / "[" / "]" / "@"
 *
 * sub-delims  = "!" / "$" / "&" / "'" / "(" / ")"
              / "*" / "+" / "," / ";" / "="
 */
var excludeSubDelimiters = /[^!$'()*+,;|:]/g;
var encodeURIComponentExcludingSubDelims = function encodeURIComponentExcludingSubDelims(segment) {
  return segment.replace(excludeSubDelimiters, function (match) {
    return encodeURIComponent(match);
  });
};
var encodingMethods = {
  "default": encodeURIComponentExcludingSubDelims,
  uri: encodeURI,
  uriComponent: encodeURIComponent,
  none: function none(val) {
    return val;
  },
  legacy: encodeURI
};
var decodingMethods = {
  "default": decodeURIComponent,
  uri: decodeURI,
  uriComponent: decodeURIComponent,
  none: function none(val) {
    return val;
  },
  legacy: decodeURIComponent
};
var encodeParam = function encodeParam(param, encoding, isSpatParam) {
  var encoder = encodingMethods[encoding] || encodeURIComponentExcludingSubDelims;

  if (isSpatParam) {
    return String(param).split('/').map(encoder).join('/');
  }

  return encoder(String(param));
};
var decodeParam = function decodeParam(param, encoding) {
  return (decodingMethods[encoding] || decodeURIComponent)(param);
};

var defaultOrConstrained = function defaultOrConstrained(match) {
  return '(' + (match ? match.replace(/(^<|>$)/g, '') : "[a-zA-Z0-9-_.~%':|=+\\*@$]+") + ')';
};
var rules = [{
  name: 'url-parameter',
  pattern: /^:([a-zA-Z0-9-_]*[a-zA-Z0-9]{1})(<(.+?)>)?/,
  regex: function regex(match) {
    return new RegExp(defaultOrConstrained(match[2]));
  }
}, {
  name: 'url-parameter-splat',
  pattern: /^\*([a-zA-Z0-9-_]*[a-zA-Z0-9]{1})/,
  regex: /([^?]*)/
}, {
  name: 'url-parameter-matrix',
  pattern: /^;([a-zA-Z0-9-_]*[a-zA-Z0-9]{1})(<(.+?)>)?/,
  regex: function regex(match) {
    return new RegExp(';' + match[1] + '=' + defaultOrConstrained(match[2]));
  }
}, {
  name: 'query-parameter',
  pattern: /^(?:\?|&)(?::)?([a-zA-Z0-9-_]*[a-zA-Z0-9]{1})/
}, {
  name: 'delimiter',
  pattern: /^(\/|\?)/,
  regex: function regex(match) {
    return new RegExp('\\' + match[0]);
  }
}, {
  name: 'sub-delimiter',
  pattern: /^(!|&|-|_|\.|;)/,
  regex: function regex(match) {
    return new RegExp(match[0]);
  }
}, {
  name: 'fragment',
  pattern: /^([0-9a-zA-Z]+)/,
  regex: function regex(match) {
    return new RegExp(match[0]);
  }
}];

var tokenise = function tokenise(str, tokens) {
  if (tokens === void 0) {
    tokens = [];
  } // Look for a matching rule


  var matched = rules.some(function (rule) {
    var match = str.match(rule.pattern);

    if (!match) {
      return false;
    }

    tokens.push({
      type: rule.name,
      match: match[0],
      val: match.slice(1, 2),
      otherVal: match.slice(2),
      regex: rule.regex instanceof Function ? rule.regex(match) : rule.regex
    });

    if (match[0].length < str.length) {
      tokens = tokenise(str.substr(match[0].length), tokens);
    }

    return true;
  }); // If no rules matched, throw an error (possible malformed path)

  if (!matched) {
    throw new Error("Could not parse path '" + str + "'");
  }

  return tokens;
};

var exists$1 = function exists(val) {
  return val !== undefined && val !== null;
};

var optTrailingSlash = function optTrailingSlash(source, strictTrailingSlash) {
  if (strictTrailingSlash) {
    return source;
  }

  if (source === '\\/') {
    return source;
  }

  return source.replace(/\\\/$/, '') + '(?:\\/)?';
};

var upToDelimiter = function upToDelimiter(source, delimiter) {
  if (!delimiter) {
    return source;
  }

  return /(\/)$/.test(source) ? source : source + '(\\/|\\?|\\.|;|$)';
};

var appendQueryParam = function appendQueryParam(params, param, val) {
  if (val === void 0) {
    val = '';
  }

  var existingVal = params[param];

  if (existingVal === undefined) {
    params[param] = val;
  } else {
    params[param] = Array.isArray(existingVal) ? existingVal.concat(val) : [existingVal, val];
  }

  return params;
};

var defaultOptions$2 = {
  urlParamsEncoding: 'default'
};

var Path$1 =
/*#__PURE__*/

/** @class */
function () {
  function Path(path, options) {
    if (!path) {
      throw new Error('Missing path in Path constructor');
    }

    this.path = path;
    this.options = __assign$2(__assign$2({}, defaultOptions$2), options);
    this.tokens = tokenise(path);
    this.hasUrlParams = this.tokens.filter(function (t) {
      return /^url-parameter/.test(t.type);
    }).length > 0;
    this.hasSpatParam = this.tokens.filter(function (t) {
      return /splat$/.test(t.type);
    }).length > 0;
    this.hasMatrixParams = this.tokens.filter(function (t) {
      return /matrix$/.test(t.type);
    }).length > 0;
    this.hasQueryParams = this.tokens.filter(function (t) {
      return /^query-parameter/.test(t.type);
    }).length > 0; // Extract named parameters from tokens

    this.spatParams = this.getParams('url-parameter-splat');
    this.urlParams = this.getParams(/^url-parameter/); // Query params

    this.queryParams = this.getParams('query-parameter'); // All params

    this.params = this.urlParams.concat(this.queryParams); // Check if hasQueryParams
    // Regular expressions for url part only (full and partial match)

    this.source = this.tokens.filter(function (t) {
      return t.regex !== undefined;
    }).map(function (t) {
      return t.regex.source;
    }).join('');
  }

  Path.createPath = function (path, options) {
    return new Path(path, options);
  };

  Path.prototype.isQueryParam = function (name) {
    return this.queryParams.indexOf(name) !== -1;
  };

  Path.prototype.isSpatParam = function (name) {
    return this.spatParams.indexOf(name) !== -1;
  };

  Path.prototype.test = function (path, opts) {
    var _this = this;

    var options = __assign$2(__assign$2({
      caseSensitive: false,
      strictTrailingSlash: false
    }, this.options), opts); // trailingSlash: falsy => non optional, truthy => optional


    var source = optTrailingSlash(this.source, options.strictTrailingSlash); // Check if exact match

    var match = this.urlTest(path, source + (this.hasQueryParams ? '(\\?.*$|$)' : '$'), options.caseSensitive, options.urlParamsEncoding); // If no match, or no query params, no need to go further

    if (!match || !this.hasQueryParams) {
      return match;
    } // Extract query params


    var queryParams = parse(path, options.queryParams);
    var unexpectedQueryParams = Object.keys(queryParams).filter(function (p) {
      return !_this.isQueryParam(p);
    });

    if (unexpectedQueryParams.length === 0) {
      // Extend url match
      Object.keys(queryParams).forEach( // @ts-ignore
      function (p) {
        return match[p] = queryParams[p];
      });
      return match;
    }

    return null;
  };

  Path.prototype.partialTest = function (path, opts) {
    var _this = this;

    var options = __assign$2(__assign$2({
      caseSensitive: false,
      delimited: true
    }, this.options), opts); // Check if partial match (start of given path matches regex)
    // trailingSlash: falsy => non optional, truthy => optional


    var source = upToDelimiter(this.source, options.delimited);
    var match = this.urlTest(path, source, options.caseSensitive, options.urlParamsEncoding);

    if (!match) {
      return match;
    }

    if (!this.hasQueryParams) {
      return match;
    }

    var queryParams = parse(path, options.queryParams);
    Object.keys(queryParams).filter(function (p) {
      return _this.isQueryParam(p);
    }).forEach(function (p) {
      return appendQueryParam(match, p, queryParams[p]);
    });
    return match;
  };

  Path.prototype.build = function (params, opts) {
    var _this = this;

    if (params === void 0) {
      params = {};
    }

    var options = __assign$2(__assign$2({
      ignoreConstraints: false,
      ignoreSearch: false,
      queryParams: {}
    }, this.options), opts);

    var encodedUrlParams = Object.keys(params).filter(function (p) {
      return !_this.isQueryParam(p);
    }).reduce(function (acc, key) {
      if (!exists$1(params[key])) {
        return acc;
      }

      var val = params[key];

      var isSpatParam = _this.isSpatParam(key);

      if (typeof val === 'boolean') {
        acc[key] = val;
      } else if (Array.isArray(val)) {
        acc[key] = val.map(function (v) {
          return encodeParam(v, options.urlParamsEncoding, isSpatParam);
        });
      } else {
        acc[key] = encodeParam(val, options.urlParamsEncoding, isSpatParam);
      }

      return acc;
    }, {}); // Check all params are provided (not search parameters which are optional)

    if (this.urlParams.some(function (p) {
      return !exists$1(params[p]);
    })) {
      var missingParameters = this.urlParams.filter(function (p) {
        return !exists$1(params[p]);
      });
      throw new Error("Cannot build path: '" + this.path + "' requires missing parameters { " + missingParameters.join(', ') + ' }');
    } // Check constraints


    if (!options.ignoreConstraints) {
      var constraintsPassed = this.tokens.filter(function (t) {
        return /^url-parameter/.test(t.type) && !/-splat$/.test(t.type);
      }).every(function (t) {
        return new RegExp('^' + defaultOrConstrained(t.otherVal[0]) + '$').test(encodedUrlParams[t.val]);
      });

      if (!constraintsPassed) {
        throw new Error("Some parameters of '" + this.path + "' are of invalid format");
      }
    }

    var base = this.tokens.filter(function (t) {
      return /^query-parameter/.test(t.type) === false;
    }).map(function (t) {
      if (t.type === 'url-parameter-matrix') {
        return ";" + t.val + "=" + encodedUrlParams[t.val[0]];
      }

      return /^url-parameter/.test(t.type) ? encodedUrlParams[t.val[0]] : t.match;
    }).join('');

    if (options.ignoreSearch) {
      return base;
    }

    var searchParams = this.queryParams.filter(function (p) {
      return Object.keys(params).indexOf(p) !== -1;
    }).reduce(function (sparams, paramName) {
      sparams[paramName] = params[paramName];
      return sparams;
    }, {});
    var searchPart = build(searchParams, options.queryParams);
    return searchPart ? base + '?' + searchPart : base;
  };

  Path.prototype.getParams = function (type) {
    var predicate = type instanceof RegExp ? function (t) {
      return type.test(t.type);
    } : function (t) {
      return t.type === type;
    };
    return this.tokens.filter(predicate).map(function (t) {
      return t.val[0];
    });
  };

  Path.prototype.urlTest = function (path, source, caseSensitive, urlParamsEncoding) {
    var _this = this;

    var regex = new RegExp('^' + source, caseSensitive ? '' : 'i');
    var match = path.match(regex);

    if (!match) {
      return null;
    } else if (!this.urlParams.length) {
      return {};
    } // Reduce named params to key-value pairs


    return match.slice(1, this.urlParams.length + 1).reduce(function (params, m, i) {
      params[_this.urlParams[i]] = decodeParam(m, urlParamsEncoding);
      return params;
    }, {});
  };

  return Path;
}();var getMetaFromSegments = function getMetaFromSegments(segments) {
  var accName = '';
  return segments.reduce(function (meta, segment) {
    var _a, _b, _c, _d;

    var urlParams = (_b = (_a = segment.parser) === null || _a === void 0 ? void 0 : _a.urlParams.reduce(function (params, p) {
      params[p] = 'url';
      return params;
    }, {}), _b !== null && _b !== void 0 ? _b : {});
    var allParams = (_d = (_c = segment.parser) === null || _c === void 0 ? void 0 : _c.queryParams.reduce(function (params, p) {
      params[p] = 'query';
      return params;
    }, urlParams), _d !== null && _d !== void 0 ? _d : {});

    if (segment.name !== undefined) {
      accName = accName ? accName + '.' + segment.name : segment.name;
      meta[accName] = allParams;
    }

    return meta;
  }, {});
};
var buildStateFromMatch = function buildStateFromMatch(match) {
  if (!match || !match.segments || !match.segments.length) {
    return null;
  }

  var name = match.segments.map(function (segment) {
    return segment.name;
  }).filter(function (name) {
    return name;
  }).join('.');
  var params = match.params;
  return {
    name: name,
    params: params,
    meta: getMetaFromSegments(match.segments)
  };
};
var buildPathFromSegments = function buildPathFromSegments(segments, params, options) {
  if (params === void 0) {
    params = {};
  }

  if (options === void 0) {
    options = {};
  }

  var _a = options.queryParamsMode,
      queryParamsMode = _a === void 0 ? 'default' : _a,
      _b = options.trailingSlashMode,
      trailingSlashMode = _b === void 0 ? 'default' : _b;
  var searchParams = [];
  var nonSearchParams = [];

  for (var _i = 0, segments_1 = segments; _i < segments_1.length; _i++) {
    var segment = segments_1[_i];
    var parser = segment.parser;

    if (parser) {
      searchParams.push.apply(searchParams, parser.queryParams);
      nonSearchParams.push.apply(nonSearchParams, parser.urlParams);
      nonSearchParams.push.apply(nonSearchParams, parser.spatParams);
    }
  }

  if (queryParamsMode === 'loose') {
    var extraParams = Object.keys(params).reduce(function (acc, p) {
      return searchParams.indexOf(p) === -1 && nonSearchParams.indexOf(p) === -1 ? acc.concat(p) : acc;
    }, []);
    searchParams.push.apply(searchParams, extraParams);
  }

  var searchParamsObject = searchParams.reduce(function (acc, paramName) {
    if (Object.keys(params).indexOf(paramName) !== -1) {
      acc[paramName] = params[paramName];
    }

    return acc;
  }, {});
  var searchPart = build(searchParamsObject, options.queryParams);
  var path = segments.reduce(function (path, segment) {
    var _a, _b;

    var segmentPath = (_b = (_a = segment.parser) === null || _a === void 0 ? void 0 : _a.build(params, {
      ignoreSearch: true,
      queryParams: options.queryParams,
      urlParamsEncoding: options.urlParamsEncoding
    }), _b !== null && _b !== void 0 ? _b : '');
    return segment.absolute ? segmentPath : path + segmentPath;
  }, '') // remove repeated slashes
  .replace(/\/\/{1,}/g, '/');
  var finalPath = path;

  if (trailingSlashMode === 'always') {
    finalPath = /\/$/.test(path) ? path : path + "/";
  } else if (trailingSlashMode === 'never' && path !== '/') {
    finalPath = /\/$/.test(path) ? path.slice(0, -1) : path;
  }

  return finalPath + (searchPart ? '?' + searchPart : '');
};
var getPathFromSegments = function getPathFromSegments(segments) {
  return segments ? segments.map(function (segment) {
    return segment.path;
  }).join('') : null;
};

var getPath = function getPath(path) {
  return path.split('?')[0];
};

var getSearch = function getSearch(path) {
  return path.split('?')[1] || '';
};

var matchChildren = function matchChildren(nodes, pathSegment, currentMatch, options, consumedBefore) {
  if (options === void 0) {
    options = {};
  }

  var _a = options.queryParamsMode,
      queryParamsMode = _a === void 0 ? 'default' : _a,
      _b = options.strictTrailingSlash,
      strictTrailingSlash = _b === void 0 ? false : _b,
      _c = options.strongMatching,
      strongMatching = _c === void 0 ? true : _c,
      _d = options.caseSensitive,
      caseSensitive = _d === void 0 ? false : _d;
  var isRoot = nodes.length === 1 && nodes[0].name === '';

  var _loop_1 = function _loop_1(child) {
    // Partially match path
    var match = null;
    var remainingPath = void 0;
    var segment = pathSegment;

    if (consumedBefore === '/' && child.path === '/') {
      // when we encounter repeating slashes we add the slash
      // back to the URL to make it de facto pathless
      segment = '/' + pathSegment;
    }

    if (!child.children.length) {
      match = child.parser.test(segment, {
        caseSensitive: caseSensitive,
        strictTrailingSlash: strictTrailingSlash,
        queryParams: options.queryParams,
        urlParamsEncoding: options.urlParamsEncoding
      });
    }

    if (!match) {
      match = child.parser.partialTest(segment, {
        delimited: strongMatching,
        caseSensitive: caseSensitive,
        queryParams: options.queryParams,
        urlParamsEncoding: options.urlParamsEncoding
      });
    }

    if (match) {
      // Remove consumed segment from path
      var consumedPath = child.parser.build(match, {
        ignoreSearch: true,
        urlParamsEncoding: options.urlParamsEncoding
      });

      if (!strictTrailingSlash && !child.children.length) {
        consumedPath = consumedPath.replace(/\/$/, '');
      } // Can't create a regexp from the path because it might contain a
      // regexp character.


      if (segment.toLowerCase().indexOf(consumedPath.toLowerCase()) === 0) {
        remainingPath = segment.slice(consumedPath.length);
      } else {
        remainingPath = segment;
      }

      if (!strictTrailingSlash && !child.children.length) {
        remainingPath = remainingPath.replace(/^\/\?/, '?');
      }

      var querystring = omit(getSearch(segment.replace(consumedPath, '')), child.parser.queryParams, options.queryParams).querystring;
      remainingPath = getPath(remainingPath) + (querystring ? "?" + querystring : '');

      if (!strictTrailingSlash && !isRoot && remainingPath === '/' && !/\/$/.test(consumedPath)) {
        remainingPath = '';
      }

      currentMatch.segments.push(child);
      Object.keys(match).forEach(function (param) {
        return currentMatch.params[param] = match[param];
      });

      if (!isRoot && !remainingPath.length) {
        return {
          value: currentMatch
        };
      }

      if (!isRoot && queryParamsMode !== 'strict' && remainingPath.indexOf('?') === 0) {
        // unmatched queryParams in non strict mode
        var remainingQueryParams_1 = parse(remainingPath.slice(1), options.queryParams);
        Object.keys(remainingQueryParams_1).forEach(function (name) {
          return currentMatch.params[name] = remainingQueryParams_1[name];
        });
        return {
          value: currentMatch
        };
      } // Continue matching on non absolute children


      var children = child.getNonAbsoluteChildren(); // If no children to match against but unmatched path left

      if (!children.length) {
        return {
          value: null
        };
      }

      return {
        value: matchChildren(children, remainingPath, currentMatch, options, consumedPath)
      };
    }
  }; // for (child of node.children) {


  for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {
    var child = nodes_1[_i];

    var state_1 = _loop_1(child);

    if (typeof state_1 === "object") return state_1.value;
  }

  return null;
};

function sortChildren(children) {
  var originalChildren = children.slice(0);
  return children.sort(sortPredicate(originalChildren));
}

var sortPredicate = function sortPredicate(originalChildren) {
  return function (left, right) {
    var _a, _b, _c, _d, _e, _f;

    var leftPath = left.path.replace(/<.*?>/g, '').split('?')[0].replace(/(.+)\/$/, '$1');
    var rightPath = right.path.replace(/<.*?>/g, '').split('?')[0].replace(/(.+)\/$/, '$1'); // '/' last

    if (leftPath === '/') {
      return 1;
    }

    if (rightPath === '/') {
      return -1;
    } // Spat params last


    if ((_a = left.parser) === null || _a === void 0 ? void 0 : _a.hasSpatParam) {
      return 1;
    }

    if ((_b = right.parser) === null || _b === void 0 ? void 0 : _b.hasSpatParam) {
      return -1;
    } // No spat, number of segments (less segments last)


    var leftSegments = (leftPath.match(/\//g) || []).length;
    var rightSegments = (rightPath.match(/\//g) || []).length;

    if (leftSegments < rightSegments) {
      return 1;
    }

    if (leftSegments > rightSegments) {
      return -1;
    } // Same number of segments, number of URL params ascending


    var leftParamsCount = (_d = (_c = left.parser) === null || _c === void 0 ? void 0 : _c.urlParams.length, _d !== null && _d !== void 0 ? _d : 0);
    var rightParamsCount = (_f = (_e = right.parser) === null || _e === void 0 ? void 0 : _e.urlParams.length, _f !== null && _f !== void 0 ? _f : 0);

    if (leftParamsCount < rightParamsCount) {
      return -1;
    }

    if (leftParamsCount > rightParamsCount) {
      return 1;
    } // Same number of segments and params, last segment length descending


    var leftParamLength = (leftPath.split('/').slice(-1)[0] || '').length;
    var rightParamLength = (rightPath.split('/').slice(-1)[0] || '').length;

    if (leftParamLength < rightParamLength) {
      return 1;
    }

    if (leftParamLength > rightParamLength) {
      return -1;
    } // Same last segment length, preserve definition order. Note that we
    // cannot just return 0, as sort is not guaranteed to be a stable sort.


    return originalChildren.indexOf(left) - originalChildren.indexOf(right);
  };
};

var RouteNode =
/*#__PURE__*/

/** @class */
function () {
  function RouteNode(name, path, childRoutes, options) {
    if (name === void 0) {
      name = '';
    }

    if (path === void 0) {
      path = '';
    }

    if (childRoutes === void 0) {
      childRoutes = [];
    }

    if (options === void 0) {
      options = {};
    }

    this.name = name;
    this.absolute = /^~/.test(path);
    this.path = this.absolute ? path.slice(1) : path;
    this.parser = this.path ? new Path$1(this.path) : null;
    this.children = [];
    this.parent = options.parent;
    this.checkParents();
    this.add(childRoutes, options.onAdd, options.finalSort ? false : options.sort !== false);

    if (options.finalSort) {
      this.sortDescendants();
    }

    return this;
  }

  RouteNode.prototype.getParentSegments = function (segments) {
    if (segments === void 0) {
      segments = [];
    }

    return this.parent && this.parent.parser ? this.parent.getParentSegments(segments.concat(this.parent)) : segments.reverse();
  };

  RouteNode.prototype.setParent = function (parent) {
    this.parent = parent;
    this.checkParents();
  };

  RouteNode.prototype.setPath = function (path) {
    if (path === void 0) {
      path = '';
    }

    this.path = path;
    this.parser = path ? new Path$1(path) : null;
  };

  RouteNode.prototype.add = function (route, cb, sort) {
    var _this = this;

    if (sort === void 0) {
      sort = true;
    }

    if (route === undefined || route === null) {
      return this;
    }

    if (route instanceof Array) {
      route.forEach(function (r) {
        return _this.add(r, cb, sort);
      });
      return this;
    }

    if (!(route instanceof RouteNode) && !(route instanceof Object)) {
      throw new Error('RouteNode.add() expects routes to be an Object or an instance of RouteNode.');
    } else if (route instanceof RouteNode) {
      route.setParent(this);
      this.addRouteNode(route, sort);
    } else {
      if (!route.name || !route.path) {
        throw new Error('RouteNode.add() expects routes to have a name and a path defined.');
      }

      var routeNode = new RouteNode(route.name, route.path, route.children, {
        finalSort: false,
        onAdd: cb,
        parent: this,
        sort: sort
      });
      var fullName = routeNode.getParentSegments([routeNode]).map(function (_) {
        return _.name;
      }).join('.');

      if (cb) {
        cb(__assign$3(__assign$3({}, route), {
          name: fullName
        }));
      }

      this.addRouteNode(routeNode, sort);
    }

    return this;
  };

  RouteNode.prototype.addNode = function (name, path) {
    this.add(new RouteNode(name, path));
    return this;
  };

  RouteNode.prototype.getPath = function (routeName) {
    var segmentsByName = this.getSegmentsByName(routeName);
    return segmentsByName ? getPathFromSegments(segmentsByName) : null;
  };

  RouteNode.prototype.getNonAbsoluteChildren = function () {
    return this.children.filter(function (child) {
      return !child.absolute;
    });
  };

  RouteNode.prototype.sortChildren = function () {
    if (this.children.length) {
      sortChildren(this.children);
    }
  };

  RouteNode.prototype.sortDescendants = function () {
    this.sortChildren();
    this.children.forEach(function (child) {
      return child.sortDescendants();
    });
  };

  RouteNode.prototype.buildPath = function (routeName, params, options) {
    if (params === void 0) {
      params = {};
    }

    if (options === void 0) {
      options = {};
    }

    var segments = this.getSegmentsByName(routeName);

    if (!segments) {
      throw new Error("[route-node][buildPath] '{routeName}' is not defined");
    }

    return buildPathFromSegments(segments, params, options);
  };

  RouteNode.prototype.buildState = function (name, params) {
    if (params === void 0) {
      params = {};
    }

    var segments = this.getSegmentsByName(name);

    if (!segments || !segments.length) {
      return null;
    }

    return {
      name: name,
      params: params,
      meta: getMetaFromSegments(segments)
    };
  };

  RouteNode.prototype.matchPath = function (path, options) {
    if (options === void 0) {
      options = {};
    }

    if (path === '' && !options.strictTrailingSlash) {
      path = '/';
    }

    var match = this.getSegmentsMatchingPath(path, options);

    if (!match) {
      return null;
    }

    var matchedSegments = match.segments;

    if (matchedSegments[0].absolute) {
      var firstSegmentParams = matchedSegments[0].getParentSegments();
      matchedSegments.reverse();
      matchedSegments.push.apply(matchedSegments, firstSegmentParams);
      matchedSegments.reverse();
    }

    var lastSegment = matchedSegments[matchedSegments.length - 1];
    var lastSegmentSlashChild = lastSegment.findSlashChild();

    if (lastSegmentSlashChild) {
      matchedSegments.push(lastSegmentSlashChild);
    }

    return buildStateFromMatch(match);
  };

  RouteNode.prototype.addRouteNode = function (route, sort) {
    if (sort === void 0) {
      sort = true;
    }

    var names = route.name.split('.');

    if (names.length === 1) {
      // Check duplicated routes
      if (this.children.map(function (child) {
        return child.name;
      }).indexOf(route.name) !== -1) {
        throw new Error("Alias \"" + route.name + "\" is already defined in route node");
      } // Check duplicated paths


      if (this.children.map(function (child) {
        return child.path;
      }).indexOf(route.path) !== -1) {
        throw new Error("Path \"" + route.path + "\" is already defined in route node");
      }

      this.children.push(route);

      if (sort) {
        this.sortChildren();
      }
    } else {
      // Locate parent node
      var segments = this.getSegmentsByName(names.slice(0, -1).join('.'));

      if (segments) {
        route.name = names[names.length - 1];
        segments[segments.length - 1].add(route);
      } else {
        throw new Error("Could not add route named '" + route.name + "', parent is missing.");
      }
    }

    return this;
  };

  RouteNode.prototype.checkParents = function () {
    if (this.absolute && this.hasParentsParams()) {
      throw new Error('[RouteNode] A RouteNode with an abolute path cannot have parents with route parameters');
    }
  };

  RouteNode.prototype.hasParentsParams = function () {
    if (this.parent && this.parent.parser) {
      var parser = this.parent.parser;
      var hasParams = parser.hasUrlParams || parser.hasSpatParam || parser.hasMatrixParams || parser.hasQueryParams;
      return hasParams || this.parent.hasParentsParams();
    }

    return false;
  };

  RouteNode.prototype.findAbsoluteChildren = function () {
    return this.children.reduce(function (absoluteChildren, child) {
      return absoluteChildren.concat(child.absolute ? child : []).concat(child.findAbsoluteChildren());
    }, []);
  };

  RouteNode.prototype.findSlashChild = function () {
    var slashChildren = this.getNonAbsoluteChildren().filter(function (child) {
      return child.parser && /^\/(\?|$)/.test(child.parser.path);
    });
    return slashChildren[0];
  };

  RouteNode.prototype.getSegmentsByName = function (routeName) {
    var findSegmentByName = function findSegmentByName(name, routes) {
      var filteredRoutes = routes.filter(function (r) {
        return r.name === name;
      });
      return filteredRoutes.length ? filteredRoutes[0] : undefined;
    };

    var segments = [];
    var routes = this.parser ? [this] : this.children;
    var names = (this.parser ? [''] : []).concat(routeName.split('.'));
    var matched = names.every(function (name) {
      var segment = findSegmentByName(name, routes);

      if (segment) {
        routes = segment.children;
        segments.push(segment);
        return true;
      }

      return false;
    });
    return matched ? segments : null;
  };

  RouteNode.prototype.getSegmentsMatchingPath = function (path, options) {
    var topLevelNodes = this.parser ? [this] : this.children;
    var startingNodes = topLevelNodes.reduce(function (nodes, node) {
      return nodes.concat(node, node.findAbsoluteChildren());
    }, []);
    var currentMatch = {
      segments: [],
      params: {}
    };
    var finalMatch = matchChildren(startingNodes, path, currentMatch, options);

    if (finalMatch && finalMatch.segments.length === 1 && finalMatch.segments[0].name === '') {
      return null;
    }

    return finalMatch;
  };

  return RouteNode;
}();function symbolObservablePonyfill(root) {
	var result;
	var Symbol = root.Symbol;

	if (typeof Symbol === 'function') {
		if (Symbol.observable) {
			result = Symbol.observable;
		} else {
			result = Symbol('observable');
			Symbol.observable = result;
		}
	} else {
		result = '@@observable';
	}

	return result;
}/* global window */

var root;

if (typeof self !== 'undefined') {
  root = self;
} else if (typeof window !== 'undefined') {
  root = window;
} else if (typeof global !== 'undefined') {
  root = global;
} else if (typeof module !== 'undefined') {
  root = module;
} else {
  root = Function('return this')();
}

var result = symbolObservablePonyfill(root);var nameToIDs = function (name) {
    return name
        .split('.')
        .reduce(function (ids, name) {
        return ids.concat(ids.length ? ids[ids.length - 1] + '.' + name : name);
    }, []);
};
var exists = function (val) { return val !== undefined && val !== null; };
var hasMetaParams = function (state) { return state && state.meta && state.meta.params; };
var extractSegmentParams = function (name, state) {
    if (!hasMetaParams(state) || !exists(state.meta.params[name]))
        return {};
    return Object.keys(state.meta.params[name]).reduce(function (params, p) {
        params[p] = state.params[p];
        return params;
    }, {});
};
function transitionPath(toState, fromState) {
    var toStateOptions = (toState.meta && toState.meta && toState.meta.options) || {};
    var fromStateIds = fromState ? nameToIDs(fromState.name) : [];
    var toStateIds = nameToIDs(toState.name);
    var maxI = Math.min(fromStateIds.length, toStateIds.length);
    function pointOfDifference() {
        var i;
        var _loop_1 = function () {
            var left = fromStateIds[i];
            var right = toStateIds[i];
            if (left !== right)
                return { value: i };
            var leftParams = extractSegmentParams(left, toState);
            var rightParams = extractSegmentParams(right, fromState);
            if (Object.keys(leftParams).length !==
                Object.keys(rightParams).length)
                return { value: i };
            if (Object.keys(leftParams).length === 0)
                return "continue";
            var different = Object.keys(leftParams).some(function (p) { return rightParams[p] !== leftParams[p]; });
            if (different) {
                return { value: i };
            }
        };
        for (i = 0; i < maxI; i += 1) {
            var state_1 = _loop_1();
            if (typeof state_1 === "object")
                return state_1.value;
        }
        return i;
    }
    var i;
    if (!fromState || toStateOptions.reload) {
        i = 0;
    }
    else if (!hasMetaParams(fromState) && !hasMetaParams(toState)) {
        i = 0;
    }
    else {
        i = pointOfDifference();
    }
    var toDeactivate = fromStateIds.slice(i).reverse();
    var toActivate = toStateIds.slice(i);
    var intersection = fromState && i > 0 ? fromStateIds[i - 1] : '';
    return {
        intersection: intersection,
        toDeactivate: toDeactivate,
        toActivate: toActivate
    };
}/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

var __assign$1 = function() {
    __assign$1 = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign$1.apply(this, arguments);
};

var defaultOptions$1 = {
    trailingSlashMode: 'default',
    queryParamsMode: 'default',
    strictTrailingSlash: false,
    autoCleanUp: true,
    allowNotFound: false,
    strongMatching: true,
    rewritePathOnMatch: true,
    caseSensitive: false,
    urlParamsEncoding: 'default'
};
function withOptions(options) {
    return function (router) {
        var routerOptions = __assign$1(__assign$1({}, defaultOptions$1), options);
        router.getOptions = function () { return routerOptions; };
        router.setOption = function (option, value) {
            routerOptions[option] = value;
            return router;
        };
        return router;
    };
}

var errorCodes = {
    ROUTER_NOT_STARTED: 'NOT_STARTED',
    NO_START_PATH_OR_STATE: 'NO_START_PATH_OR_STATE',
    ROUTER_ALREADY_STARTED: 'ALREADY_STARTED',
    ROUTE_NOT_FOUND: 'ROUTE_NOT_FOUND',
    SAME_STATES: 'SAME_STATES',
    CANNOT_DEACTIVATE: 'CANNOT_DEACTIVATE',
    CANNOT_ACTIVATE: 'CANNOT_ACTIVATE',
    TRANSITION_ERR: 'TRANSITION_ERR',
    TRANSITION_CANCELLED: 'CANCELLED'
};
var constants = {
    UNKNOWN_ROUTE: '@@router5/UNKNOWN_ROUTE',
    ROUTER_START: '$start',
    ROUTER_STOP: '$stop',
    TRANSITION_START: '$$start',
    TRANSITION_CANCEL: '$$cancel',
    TRANSITION_SUCCESS: '$$success',
    TRANSITION_ERROR: '$$error'
};

function withRoutes(routes) {
    return function (router) {
        router.forward = function (fromRoute, toRoute) {
            router.config.forwardMap[fromRoute] = toRoute;
            return router;
        };
        var rootNode = routes instanceof RouteNode
            ? routes
            : new RouteNode('', '', routes, { onAdd: onRouteAdded });
        function onRouteAdded(route) {
            if (route.canActivate)
                router.canActivate(route.name, route.canActivate);
            if (route.forwardTo)
                router.forward(route.name, route.forwardTo);
            if (route.decodeParams)
                router.config.decoders[route.name] = route.decodeParams;
            if (route.encodeParams)
                router.config.encoders[route.name] = route.encodeParams;
            if (route.defaultParams)
                router.config.defaultParams[route.name] = route.defaultParams;
        }
        router.rootNode = rootNode;
        router.add = function (routes, finalSort) {
            rootNode.add(routes, onRouteAdded, !finalSort);
            if (finalSort) {
                rootNode.sortDescendants();
            }
            return router;
        };
        router.addNode = function (name, path, canActivateHandler) {
            rootNode.addNode(name, path);
            if (canActivateHandler)
                router.canActivate(name, canActivateHandler);
            return router;
        };
        router.isActive = function (name, params, strictEquality, ignoreQueryParams) {
            if (params === void 0) { params = {}; }
            if (strictEquality === void 0) { strictEquality = false; }
            if (ignoreQueryParams === void 0) { ignoreQueryParams = true; }
            var activeState = router.getState();
            if (!activeState)
                return false;
            if (strictEquality || activeState.name === name) {
                return router.areStatesEqual(router.makeState(name, params), activeState, ignoreQueryParams);
            }
            return router.areStatesDescendants(router.makeState(name, params), activeState);
        };
        router.buildPath = function (route, params) {
            if (route === constants.UNKNOWN_ROUTE) {
                return params.path;
            }
            var paramsWithDefault = __assign$1(__assign$1({}, router.config.defaultParams[route]), params);
            var _a = router.getOptions(), trailingSlashMode = _a.trailingSlashMode, queryParamsMode = _a.queryParamsMode, queryParams = _a.queryParams;
            var encodedParams = router.config.encoders[route]
                ? router.config.encoders[route](paramsWithDefault)
                : paramsWithDefault;
            return router.rootNode.buildPath(route, encodedParams, {
                trailingSlashMode: trailingSlashMode,
                queryParamsMode: queryParamsMode,
                queryParams: queryParams,
                urlParamsEncoding: router.getOptions().urlParamsEncoding
            });
        };
        router.matchPath = function (path, source) {
            var options = router.getOptions();
            var match = router.rootNode.matchPath(path, options);
            if (match) {
                var name_1 = match.name, params = match.params, meta = match.meta;
                var decodedParams = router.config.decoders[name_1]
                    ? router.config.decoders[name_1](params)
                    : params;
                var _a = router.forwardState(name_1, decodedParams), routeName = _a.name, routeParams = _a.params;
                var builtPath = options.rewritePathOnMatch === false
                    ? path
                    : router.buildPath(routeName, routeParams);
                return router.makeState(routeName, routeParams, builtPath, {
                    params: meta,
                    source: source
                });
            }
            return null;
        };
        router.setRootPath = function (rootPath) {
            router.rootNode.setPath(rootPath);
        };
        return router;
    };
}

function withDependencies(dependencies) {
    return function (router) {
        var routerDependencies = dependencies;
        router.setDependency = function (dependencyName, dependency) {
            routerDependencies[dependencyName] = dependency;
            return router;
        };
        router.setDependencies = function (deps) {
            Object.keys(deps).forEach(function (name) {
                return router.setDependency(name, deps[name]);
            });
            return router;
        };
        router.getDependencies = function () { return routerDependencies; };
        router.getInjectables = function () { return [router, router.getDependencies()]; };
        router.executeFactory = function (factoryFunction) {
            return factoryFunction.apply(void 0, router.getInjectables());
        };
        return router;
    };
}

function withState(router) {
    var stateId = 0;
    var routerState = null;
    router.getState = function () { return routerState; };
    router.setState = function (state) {
        routerState = state;
    };
    router.makeState = function (name, params, path, meta, forceId) { return ({
        name: name,
        params: __assign$1(__assign$1({}, router.config.defaultParams[name]), params),
        path: path,
        meta: meta
            ? __assign$1(__assign$1({}, meta), { id: forceId === undefined ? ++stateId : forceId }) : undefined
    }); };
    router.makeNotFoundState = function (path, options) {
        return router.makeState(constants.UNKNOWN_ROUTE, { path: path }, path, {
            options: options
        });
    };
    router.areStatesEqual = function (state1, state2, ignoreQueryParams) {
        if (ignoreQueryParams === void 0) { ignoreQueryParams = true; }
        if (state1.name !== state2.name)
            return false;
        var getUrlParams = function (name) {
            return router.rootNode
                //@ts-ignore
                .getSegmentsByName(name)
                .map(function (segment) { return segment.parser['urlParams']; })
                .reduce(function (params, p) { return params.concat(p); }, []);
        };
        var state1Params = ignoreQueryParams
            ? getUrlParams(state1.name)
            : Object.keys(state1.params);
        var state2Params = ignoreQueryParams
            ? getUrlParams(state2.name)
            : Object.keys(state2.params);
        return (state1Params.length === state2Params.length &&
            state1Params.every(function (p) { return state1.params[p] === state2.params[p]; }));
    };
    router.areStatesDescendants = function (parentState, childState) {
        var regex = new RegExp('^' + parentState.name + '\\.(.*)$');
        if (!regex.test(childState.name))
            return false;
        // If child state name extends parent state name, and all parent state params
        // are in child state params.
        return Object.keys(parentState.params).every(function (p) { return parentState.params[p] === childState.params[p]; });
    };
    router.forwardState = function (routeName, routeParams) {
        var name = router.config.forwardMap[routeName] || routeName;
        var params = __assign$1(__assign$1(__assign$1({}, router.config.defaultParams[routeName]), router.config.defaultParams[name]), routeParams);
        return {
            name: name,
            params: params
        };
    };
    router.buildState = function (routeName, routeParams) {
        var _a = router.forwardState(routeName, routeParams), name = _a.name, params = _a.params;
        return router.rootNode.buildState(name, params);
    };
    return router;
}

var eventsMap = {
    onStart: constants.ROUTER_START,
    onStop: constants.ROUTER_STOP,
    onTransitionSuccess: constants.TRANSITION_SUCCESS,
    onTransitionStart: constants.TRANSITION_START,
    onTransitionError: constants.TRANSITION_ERROR,
    onTransitionCancel: constants.TRANSITION_CANCEL
};
function withPlugins(router) {
    var routerPlugins = [];
    router.getPlugins = function () { return routerPlugins; };
    router.usePlugin = function () {
        var plugins = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            plugins[_i] = arguments[_i];
        }
        var removePluginFns = plugins.map(function (plugin) {
            routerPlugins.push(plugin);
            return startPlugin(plugin);
        });
        return function () {
            routerPlugins = routerPlugins.filter(function (plugin) { return plugins.indexOf(plugin) === -1; });
            removePluginFns.forEach(function (removePlugin) { return removePlugin(); });
        };
    };
    function startPlugin(plugin) {
        var appliedPlugin = router.executeFactory(plugin);
        var removeEventListeners = Object.keys(eventsMap)
            .map(function (methodName) {
            if (appliedPlugin[methodName]) {
                return router.addEventListener(eventsMap[methodName], appliedPlugin[methodName]);
            }
        })
            .filter(Boolean);
        return function () {
            removeEventListeners.forEach(function (removeListener) { return removeListener(); });
            if (appliedPlugin.teardown) {
                appliedPlugin.teardown();
            }
        };
    }
    return router;
}

function withMiddleware(router) {
    var middlewareFactories = [];
    var middlewareFunctions = [];
    router.useMiddleware = function () {
        var middlewares = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            middlewares[_i] = arguments[_i];
        }
        var removePluginFns = middlewares.map(function (middleware) {
            var middlewareFunction = router.executeFactory(middleware);
            middlewareFactories.push(middleware);
            middlewareFunctions.push(middlewareFunction);
            return function () {
                middlewareFactories = middlewareFactories.filter(function (m) { return m !== middleware; });
                middlewareFunctions = middlewareFunctions.filter(function (m) { return m !== middlewareFunction; });
            };
        });
        return function () { return removePluginFns.forEach(function (fn) { return fn(); }); };
    };
    router.clearMiddleware = function () {
        middlewareFactories = [];
        middlewareFunctions = [];
        return router;
    };
    router.getMiddlewareFactories = function () { return middlewareFactories; };
    router.getMiddlewareFunctions = function () { return middlewareFunctions; };
    return router;
}

function withObservability(router) {
    var callbacks = {};
    router.invokeEventListeners = function (eventName) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        (callbacks[eventName] || []).forEach(function (cb) { return cb.apply(void 0, args); });
    };
    router.removeEventListener = function (eventName, cb) {
        callbacks[eventName] = callbacks[eventName].filter(function (_cb) { return _cb !== cb; });
    };
    router.addEventListener = function (eventName, cb) {
        callbacks[eventName] = (callbacks[eventName] || []).concat(cb);
        return function () { return router.removeEventListener(eventName, cb); };
    };
    function subscribe(listener) {
        var isObject = typeof listener === 'object';
        var finalListener = isObject ? listener.next.bind(listener) : listener;
        var unsubscribeHandler = router.addEventListener(constants.TRANSITION_SUCCESS, function (toState, fromState) {
            finalListener({
                route: toState,
                previousRoute: fromState
            });
        });
        return isObject
            ? { unsubscribe: unsubscribeHandler }
            : unsubscribeHandler;
    }
    function observable() {
        var _a;
        return _a = {
                subscribe: function (observer) {
                    if (typeof observer !== 'object' || observer === null) {
                        throw new TypeError('Expected the observer to be an object.');
                    }
                    return subscribe(observer);
                }
            },
            _a[result] = function () {
                return this;
            },
            _a;
    }
    router.subscribe = subscribe;
    //@ts-ignore
    router[result] = observable;
    //@ts-ignore
    router['@@observable'] = observable;
    return router;
}

function resolve(functions, _a, callback) {
    var isCancelled = _a.isCancelled, toState = _a.toState, fromState = _a.fromState, _b = _a.errorKey, errorKey = _b === void 0 ? undefined : _b;
    var remainingFunctions = Array.isArray(functions)
        ? functions
        : Object.keys(functions);
    var isState = function (obj) {
        return typeof obj === 'object' &&
            obj.name !== undefined &&
            obj.params !== undefined &&
            obj.path !== undefined;
    };
    var hasStateChanged = function (toState, fromState) {
        return fromState.name !== toState.name ||
            fromState.params !== toState.params ||
            fromState.path !== toState.path;
    };
    var mergeStates = function (toState, fromState) { return (__assign$1(__assign$1(__assign$1({}, fromState), toState), { meta: __assign$1(__assign$1({}, fromState.meta), toState.meta) })); };
    var processFn = function (stepFn, errBase, state, _done) {
        var done = function (err, newState) {
            if (err) {
                _done(err);
            }
            else if (newState && newState !== state && isState(newState)) {
                if (hasStateChanged(newState, state)) {
                    console.error('[router5][transition] Warning: state values (name, params, path) were changed during transition process.');
                }
                _done(null, mergeStates(newState, state));
            }
            else {
                _done(null, state);
            }
        };
        var res = stepFn.call(null, state, fromState, done);
        if (isCancelled()) {
            done(null);
        }
        else if (typeof res === 'boolean') {
            done(res ? null : errBase);
        }
        else if (isState(res)) {
            done(null, res);
        }
        else if (res && typeof res.then === 'function') {
            res.then(function (resVal) {
                if (resVal instanceof Error)
                    done({ error: resVal }, null);
                else
                    done(null, resVal);
            }, function (err) {
                if (err instanceof Error) {
                    console.error(err.stack || err);
                    done(__assign$1(__assign$1({}, errBase), { promiseError: err }), null);
                }
                else {
                    done(typeof err === 'object'
                        ? __assign$1(__assign$1({}, errBase), err) : errBase, null);
                }
            });
        }
        // else: wait for done to be called
    };
    var next = function (err, state) {
        var _a;
        if (isCancelled()) {
            callback();
        }
        else if (err) {
            callback(err);
        }
        else {
            if (!remainingFunctions.length) {
                callback(null, state);
            }
            else {
                var isMapped = typeof remainingFunctions[0] === 'string';
                var errBase = errorKey && isMapped
                    ? (_a = {}, _a[errorKey] = remainingFunctions[0], _a) : {};
                var stepFn = isMapped
                    ? functions[remainingFunctions[0]]
                    : remainingFunctions[0];
                remainingFunctions = remainingFunctions.slice(1);
                processFn(stepFn, errBase, state, next);
            }
        }
    };
    next(null, toState);
}

function transition(router, toState, fromState, opts, callback) {
    var cancelled = false;
    var completed = false;
    var options = router.getOptions();
    var _a = router.getLifecycleFunctions(), canDeactivateFunctions = _a[0], canActivateFunctions = _a[1];
    var middlewareFunctions = router.getMiddlewareFunctions();
    var isCancelled = function () { return cancelled; };
    var cancel = function () {
        if (!cancelled && !completed) {
            cancelled = true;
            callback({ code: errorCodes.TRANSITION_CANCELLED }, null);
        }
    };
    var done = function (err, state) {
        completed = true;
        if (isCancelled()) {
            return;
        }
        if (!err && options.autoCleanUp) {
            var activeSegments_1 = nameToIDs(toState.name);
            Object.keys(canDeactivateFunctions).forEach(function (name) {
                if (activeSegments_1.indexOf(name) === -1)
                    router.clearCanDeactivate(name);
            });
        }
        callback(err, state || toState);
    };
    var makeError = function (base, err) { return (__assign$1(__assign$1({}, base), (err instanceof Object ? err : { error: err }))); };
    var isUnknownRoute = toState.name === constants.UNKNOWN_ROUTE;
    var asyncBase = { isCancelled: isCancelled, toState: toState, fromState: fromState };
    var _b = transitionPath(toState, fromState), toDeactivate = _b.toDeactivate, toActivate = _b.toActivate;
    var canDeactivate = !fromState || opts.forceDeactivate
        ? []
        : function (toState, fromState, cb) {
            var canDeactivateFunctionMap = toDeactivate
                .filter(function (name) { return canDeactivateFunctions[name]; })
                .reduce(function (fnMap, name) {
                var _a;
                return (__assign$1(__assign$1({}, fnMap), (_a = {}, _a[name] = canDeactivateFunctions[name], _a)));
            }, {});
            resolve(canDeactivateFunctionMap, __assign$1(__assign$1({}, asyncBase), { errorKey: 'segment' }), function (err) {
                return cb(err
                    ? makeError({ code: errorCodes.CANNOT_DEACTIVATE }, err)
                    : null);
            });
        };
    var canActivate = isUnknownRoute
        ? []
        : function (toState, fromState, cb) {
            var canActivateFunctionMap = toActivate
                .filter(function (name) { return canActivateFunctions[name]; })
                .reduce(function (fnMap, name) {
                var _a;
                return (__assign$1(__assign$1({}, fnMap), (_a = {}, _a[name] = canActivateFunctions[name], _a)));
            }, {});
            resolve(canActivateFunctionMap, __assign$1(__assign$1({}, asyncBase), { errorKey: 'segment' }), function (err) {
                return cb(err
                    ? makeError({ code: errorCodes.CANNOT_ACTIVATE }, err)
                    : null);
            });
        };
    var middleware = !middlewareFunctions.length
        ? []
        : function (toState, fromState, cb) {
            return resolve(middlewareFunctions, __assign$1({}, asyncBase), function (err, state) {
                return cb(err
                    ? makeError({ code: errorCodes.TRANSITION_ERR }, err)
                    : null, state || toState);
            });
        };
    var pipeline = []
        .concat(canDeactivate)
        .concat(canActivate)
        .concat(middleware);
    resolve(pipeline, asyncBase, done);
    return cancel;
}

var noop$1 = function () { };
function withNavigation(router) {
    var cancelCurrentTransition;
    router.navigate = navigate;
    router.navigate = navigate;
    router.navigateToDefault = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var opts = typeof args[0] === 'object' ? args[0] : {};
        var done = args.length === 2
            ? args[1]
            : typeof args[0] === 'function'
                ? args[0]
                : noop$1;
        var options = router.getOptions();
        if (options.defaultRoute) {
            return navigate(options.defaultRoute, options.defaultParams, opts, done);
        }
        return function () { };
    };
    router.cancel = function () {
        if (cancelCurrentTransition) {
            cancelCurrentTransition('navigate');
            cancelCurrentTransition = null;
        }
        return router;
    };
    function navigate() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var name = args[0];
        var lastArg = args[args.length - 1];
        var done = typeof lastArg === 'function' ? lastArg : noop$1;
        var params = typeof args[1] === 'object' ? args[1] : {};
        var opts = typeof args[2] === 'object' ? args[2] : {};
        if (!router.isStarted()) {
            done({ code: errorCodes.ROUTER_NOT_STARTED });
            return;
        }
        var route = router.buildState(name, params);
        if (!route) {
            var err = { code: errorCodes.ROUTE_NOT_FOUND };
            done(err);
            router.invokeEventListeners(constants.TRANSITION_ERROR, null, router.getState(), err);
            return;
        }
        var toState = router.makeState(route.name, route.params, router.buildPath(route.name, route.params), { params: route.meta, options: opts });
        var sameStates = router.getState()
            ? router.areStatesEqual(router.getState(), toState, false)
            : false;
        // Do not proceed further if states are the same and no reload
        // (no deactivation and no callbacks)
        if (sameStates && !opts.reload && !opts.force) {
            var err = { code: errorCodes.SAME_STATES };
            done(err);
            router.invokeEventListeners(constants.TRANSITION_ERROR, toState, router.getState(), err);
            return;
        }
        var fromState = router.getState();
        if (opts.skipTransition) {
            done(null, toState);
            return noop$1;
        }
        // Transition
        return router.transitionToState(toState, fromState, opts, function (err, state) {
            if (err) {
                if (err.redirect) {
                    var _a = err.redirect, name_1 = _a.name, params_1 = _a.params;
                    navigate(name_1, params_1, __assign$1(__assign$1({}, opts), { force: true, redirected: true }), done);
                }
                else {
                    done(err);
                }
            }
            else {
                router.invokeEventListeners(constants.TRANSITION_SUCCESS, state, fromState, opts);
                done(null, state);
            }
        });
    }
    router.transitionToState = function (toState, fromState, options, done) {
        if (options === void 0) { options = {}; }
        if (done === void 0) { done = noop$1; }
        router.cancel();
        router.invokeEventListeners(constants.TRANSITION_START, toState, fromState);
        cancelCurrentTransition = transition(router, toState, fromState, options, function (err, state) {
            cancelCurrentTransition = null;
            state = state || toState;
            if (err) {
                if (err.code === errorCodes.TRANSITION_CANCELLED) {
                    router.invokeEventListeners(constants.TRANSITION_CANCEL, toState, fromState);
                }
                else {
                    router.invokeEventListeners(constants.TRANSITION_ERROR, toState, fromState, err);
                }
                done(err);
            }
            else {
                router.setState(state);
                done(null, state);
            }
        });
        return cancelCurrentTransition;
    };
    return router;
}

var noop$1$1 = function () { };
function withRouterLifecycle(router) {
    var started = false;
    router.isStarted = function () { return started; };
    //@ts-ignore
    router.start = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var options = router.getOptions();
        var lastArg = args[args.length - 1];
        var done = typeof lastArg === 'function' ? lastArg : noop$1$1;
        var startPathOrState = typeof args[0] !== 'function' ? args[0] : undefined;
        if (started) {
            done({ code: errorCodes.ROUTER_ALREADY_STARTED });
            return router;
        }
        var startPath, startState;
        started = true;
        router.invokeEventListeners(constants.ROUTER_START);
        // callback
        var cb = function (err, state, invokeErrCb) {
            if (invokeErrCb === void 0) { invokeErrCb = true; }
            if (!err)
                router.invokeEventListeners(constants.TRANSITION_SUCCESS, state, null, { replace: true });
            if (err && invokeErrCb)
                router.invokeEventListeners(constants.TRANSITION_ERROR, state, null, err);
            done(err, state);
        };
        if (startPathOrState === undefined && !options.defaultRoute) {
            return cb({ code: errorCodes.NO_START_PATH_OR_STATE });
        }
        if (typeof startPathOrState === 'string') {
            startPath = startPathOrState;
        }
        else if (typeof startPathOrState === 'object') {
            startState = startPathOrState;
        }
        if (!startState) {
            // If no supplied start state, get start state
            startState =
                startPath === undefined ? null : router.matchPath(startPath);
            // Navigate to default function
            var navigateToDefault_1 = function () {
                return router.navigateToDefault({ replace: true }, done);
            };
            var redirect_1 = function (route) {
                return router.navigate(route.name, route.params, { replace: true, reload: true, redirected: true }, done);
            };
            var transitionToState = function (state) {
                router.transitionToState(state, router.getState(), {}, function (err, state) {
                    if (!err)
                        cb(null, state);
                    else if (err.redirect)
                        redirect_1(err.redirect);
                    else if (options.defaultRoute)
                        navigateToDefault_1();
                    else
                        cb(err, null, false);
                });
            };
            // If matched start path
            if (startState) {
                transitionToState(startState);
            }
            else if (options.defaultRoute) {
                // If default, navigate to default
                navigateToDefault_1();
            }
            else if (options.allowNotFound) {
                transitionToState(router.makeNotFoundState(startPath, { replace: true }));
            }
            else {
                // No start match, no default => do nothing
                cb({ code: errorCodes.ROUTE_NOT_FOUND, path: startPath }, null);
            }
        }
        else {
            // Initialise router with provided start state
            router.setState(startState);
            cb(null, startState);
        }
        return router;
    };
    router.stop = function () {
        if (started) {
            router.setState(null);
            started = false;
            router.invokeEventListeners(constants.ROUTER_STOP);
        }
        return router;
    };
    return router;
}

var toFunction = function (val) { return (typeof val === 'function' ? val : function () { return function () { return val; }; }); };
function withRouteLifecycle(router) {
    var canDeactivateFactories = {};
    var canActivateFactories = {};
    var canDeactivateFunctions = {};
    var canActivateFunctions = {};
    router.getLifecycleFactories = function () {
        return [canDeactivateFactories, canActivateFactories];
    };
    router.getLifecycleFunctions = function () {
        return [canDeactivateFunctions, canActivateFunctions];
    };
    router.canDeactivate = function (name, canDeactivateHandler) {
        var factory = toFunction(canDeactivateHandler);
        canDeactivateFactories[name] = factory;
        canDeactivateFunctions[name] = router.executeFactory(factory);
        return router;
    };
    router.clearCanDeactivate = function (name) {
        canDeactivateFactories[name] = undefined;
        canDeactivateFunctions[name] = undefined;
        return router;
    };
    router.canActivate = function (name, canActivateHandler) {
        var factory = toFunction(canActivateHandler);
        canActivateFactories[name] = factory;
        canActivateFunctions[name] = router.executeFactory(factory);
        return router;
    };
    return router;
}

var pipe = function () {
    var fns = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        fns[_i] = arguments[_i];
    }
    return function (arg) {
        return fns.reduce(function (prev, fn) { return fn(prev); }, arg);
    };
};
var createRouter = function (routes, options, dependencies) {
    if (routes === void 0) { routes = []; }
    if (options === void 0) { options = {}; }
    if (dependencies === void 0) { dependencies = {}; }
    var config = {
        decoders: {},
        encoders: {},
        defaultParams: {},
        forwardMap: {}
    };
    return pipe(withOptions(options), withDependencies(dependencies), withObservability, withState, withRouterLifecycle, withRouteLifecycle, withNavigation, withPlugins, withMiddleware, withRoutes(routes))({ config: config });
};

var createRouter$1 = createRouter;/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
}

var value = function (arg) { return function () { return arg; }; };
var noop = function () { };
var isBrowser = typeof window !== 'undefined' && window.history;
var getBase = function () { return window.location.pathname; };
var supportsPopStateOnHashChange = function () {
    return window.navigator.userAgent.indexOf('Trident') === -1;
};
var pushState = function (state, title, path) {
    return window.history.pushState(state, title, path);
};
var replaceState = function (state, title, path) {
    return window.history.replaceState(state, title, path);
};
var addPopstateListener = function (fn, opts) {
    var shouldAddHashChangeListener = opts.useHash && !supportsPopStateOnHashChange();
    window.addEventListener('popstate', fn);
    if (shouldAddHashChangeListener) {
        window.addEventListener('hashchange', fn);
    }
    return function () {
        window.removeEventListener('popstate', fn);
        if (shouldAddHashChangeListener) {
            window.removeEventListener('hashchange', fn);
        }
    };
};
var getLocation = function (opts) {
    var path = opts.useHash
        ? window.location.hash.replace(new RegExp('^#' + opts.hashPrefix), '')
        : window.location.pathname.replace(new RegExp('^' + opts.base), '');
    // Fix issue with browsers that don't URL encode characters (Edge)
    var correctedPath = safelyEncodePath(path);
    return (correctedPath || '/') + window.location.search;
};
var safelyEncodePath = function (path) {
    try {
        return encodeURI(decodeURI(path));
    }
    catch (_) {
        return path;
    }
};
var getState = function () { return window.history.state; };
var getHash = function () { return window.location.hash; };
var browser = {};
if (isBrowser) {
    browser = {
        getBase: getBase,
        pushState: pushState,
        replaceState: replaceState,
        addPopstateListener: addPopstateListener,
        getLocation: getLocation,
        getState: getState,
        getHash: getHash
    };
}
else {
    browser = {
        getBase: value(''),
        pushState: noop,
        replaceState: noop,
        addPopstateListener: noop,
        getLocation: value(''),
        getState: value(null),
        getHash: value('')
    };
}
var safeBrowser = browser;

var defaultOptions = {
    forceDeactivate: true,
    useHash: false,
    hashPrefix: '',
    base: '',
    mergeState: false,
    preserveHash: true
};
var source = 'popstate';
function browserPluginFactory(opts, browser) {
    if (browser === void 0) { browser = safeBrowser; }
    var options = __assign(__assign({}, defaultOptions), opts);
    var transitionOptions = {
        forceDeactivate: options.forceDeactivate,
        source: source
    };
    var removePopStateListener;
    return function browserPlugin(router) {
        var routerOptions = router.getOptions();
        var routerStart = router.start;
        router.buildUrl = function (route, params) {
            var base = options.base || '';
            var prefix = options.useHash ? "#" + options.hashPrefix : '';
            var path = router.buildPath(route, params);
            return base + prefix + path;
        };
        var urlToPath = function (url) {
            var match = url.match(/^(?:http|https):\/\/(?:[0-9a-z_\-.:]+?)(?=\/)(.*)$/);
            var path = match ? match[1] : url;
            var pathParts = path.match(/^(.+?)(#.+?)?(\?.+)?$/);
            if (!pathParts)
                throw new Error("[router5] Could not parse url " + url);
            var pathname = pathParts[1];
            var hash = pathParts[2] || '';
            var search = pathParts[3] || '';
            return ((options.useHash
                ? hash.replace(new RegExp('^#' + options.hashPrefix), '')
                : options.base
                    ? pathname.replace(new RegExp('^' + options.base), '')
                    : pathname) + search);
        };
        router.matchUrl = function (url) { return router.matchPath(urlToPath(url)); };
        router.start = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            if (args.length === 0 || typeof args[0] === 'function') {
                routerStart.apply(void 0, __spreadArrays([browser.getLocation(options)], args));
            }
            else {
                routerStart.apply(void 0, args);
            }
            return router;
        };
        router.replaceHistoryState = function (name, params, title) {
            if (params === void 0) { params = {}; }
            if (title === void 0) { title = ''; }
            var route = router.buildState(name, params);
            var state = router.makeState(route.name, route.params, router.buildPath(route.name, route.params), { params: route.meta });
            var url = router.buildUrl(name, params);
            router.lastKnownState = state;
            browser.replaceState(state, title, url);
        };
        function updateBrowserState(state, url, replace) {
            var trimmedState = state
                ? {
                    meta: state.meta,
                    name: state.name,
                    params: state.params,
                    path: state.path
                }
                : state;
            var finalState = options.mergeState === true
                ? __assign(__assign({}, browser.getState()), trimmedState) : trimmedState;
            if (replace)
                browser.replaceState(finalState, '', url);
            else
                browser.pushState(finalState, '', url);
        }
        function onPopState(evt) {
            var routerState = router.getState();
            // Do nothing if no state or if last know state is poped state (it should never happen)
            var newState = !evt.state || !evt.state.name;
            var state = newState
                ? router.matchPath(browser.getLocation(options), source)
                : router.makeState(evt.state.name, evt.state.params, evt.state.path, __assign(__assign({}, evt.state.meta), { source: source }), evt.state.meta.id);
            var defaultRoute = routerOptions.defaultRoute, defaultParams = routerOptions.defaultParams;
            if (!state) {
                // If current state is already the default route, we will have a double entry
                // Navigating back and forth will emit SAME_STATES error
                defaultRoute &&
                    router.navigateToDefault(__assign(__assign({}, transitionOptions), { reload: true, replace: true }));
                return;
            }
            if (routerState &&
                router.areStatesEqual(state, routerState, false)) {
                return;
            }
            router.transitionToState(state, routerState, transitionOptions, function (err, toState) {
                if (err) {
                    if (err.redirect) {
                        var _a = err.redirect, name_1 = _a.name, params = _a.params;
                        router.navigate(name_1, params, __assign(__assign({}, transitionOptions), { replace: true, force: true, redirected: true }));
                    }
                    else if (err.code === errorCodes.CANNOT_DEACTIVATE) {
                        var url = router.buildUrl(routerState.name, routerState.params);
                        if (!newState) {
                            // Keep history state unchanged but use current URL
                            updateBrowserState(state, url, true);
                        }
                        // else do nothing or history will be messed up
                        // TODO: history.back()?
                    }
                    else {
                        // Force navigation to default state
                        defaultRoute &&
                            router.navigate(defaultRoute, defaultParams, __assign(__assign({}, transitionOptions), { reload: true, replace: true }));
                    }
                }
                else {
                    router.invokeEventListeners(constants.TRANSITION_SUCCESS, toState, routerState, { replace: true });
                }
            });
        }
        function onStart() {
            if (options.useHash && !options.base) {
                // Guess base
                options.base = browser.getBase();
            }
            removePopStateListener = browser.addPopstateListener(onPopState, options);
        }
        function teardown() {
            if (removePopStateListener) {
                removePopStateListener();
                removePopStateListener = undefined;
            }
        }
        function onTransitionSuccess(toState, fromState, opts) {
            var historyState = browser.getState();
            var hasState = historyState &&
                historyState.meta &&
                historyState.name &&
                historyState.params;
            var statesAreEqual = fromState && router.areStatesEqual(fromState, toState, false);
            var replace = opts.replace || !hasState || statesAreEqual;
            var url = router.buildUrl(toState.name, toState.params);
            if (fromState === null &&
                options.useHash === false &&
                options.preserveHash === true) {
                url += browser.getHash();
            }
            updateBrowserState(toState, url, replace);
        }
        return {
            onStart: onStart,
            onStop: teardown,
            teardown: teardown,
            onTransitionSuccess: onTransitionSuccess,
            onPopState: onPopState
        };
    };
}class RouterService {
  static get router() {
    return this.router_;
  }
  static get route() {
    let route = null;
    const router = this.router_;
    if (router) {
      route = router.getState();
      // console.log('RouterService.get.route', route);
    }

    return route;
  }

  /*
  static event$_ = new Subject();
  static event$() {
  	const router = this.router_;
  	if (router) {
  		return from(router).pipe(
  			startWith({ route: router.getState(), previousRoute: null }),
  			tap(event => {
  				// console.log('RouterService.event$', event);
  				this.event$_.next(event);
  			}),
  		);
  	} else {
  		return EMPTY;
  	}
  }
  */

  static useBrowser(routes) {
    if (!(Array.isArray(routes) && routes.length)) {
      this.event$ = rxjs.EMPTY;
      return;
    }
    this.routes = routes;
    const router = createRouter$1(routes, {
      allowNotFound: false,
      autoCleanUp: true,
      defaultRoute: 'index',
      defaultParams: {},
      queryParams: {
        arrayFormat: 'default',
        nullFormat: 'default',
        booleanFormat: 'default'
      },
      queryParamsMode: 'default',
      trailingSlashMode: 'default',
      strictTrailingSlash: false,
      caseSensitive: false,
      urlParamsEncoding: 'default'
    });
    this.router_ = router;
    router.usePlugin(browserPluginFactory({
      useHash: false
    }));
    router.start();
    this.event$ = rxjs.from(router).pipe(operators.startWith({
      route: router.getState(),
      previousRoute: null
    })
    // tap(event => { console.log('RouterService.event$', event); }),
    );
  }

  static useBrowser$(routes) {
    this.useBrowser(routes);
    return this.event$;
  }
  static setRouterLink(routerLink, routeParams, options) {
    if (routerLink === void 0) {
      routerLink = 'it.access';
    }
    if (routeParams === void 0) {
      routeParams = null;
    }
    if (options === void 0) {
      options = {
        reload: true
      };
    }
    const router = this.router_;
    if (router) {
      // router.matchUrl(routerLink);
      try {
        router.navigate(routerLink, routeParams, options);
      } catch (error) {
        console.log('RouterService.setRouterLink.error', error);
      }
    }
    // console.log('RouterService.setRouterLink', router, routerLink, routeParams, options);
  }

  static replaceHistoryState(name, params) {
    const router = this.router_;
    if (router) {
      // router.matchUrl(routerLink);
      try {
        router.replaceHistoryState(name, params);
      } catch (error) {
        console.log('RouterService.replaceHistoryState.error', error);
      }
    }
  }
  static setCurrentParams(params) {
    const router = this.router_;
    if (router) {
      try {
        const route = this.route;
        if (route) {
          router.replaceHistoryState(route.name, params);
        }
      } catch (error) {
        console.log('RouterService.setCurrentParams.error', error);
      }
    }
  }
  static buildPath(route, params) {
    if (params === void 0) {
      params = null;
    }
    let path = null;
    const router = this.router_;
    if (router) {
      try {
        path = router.buildPath(route, params);
      } catch (error) {
        console.log('RouterService.buildPath.error', error);
      }
    }
    // console.log('RouterService.buildPath', path, route, params);
    // router.buildUrl(routeName, routeParams)
    return path;
  }
  static buildUrl(routeName, routeParams) {
    if (routeParams === void 0) {
      routeParams = null;
    }
    let url = null;
    const router = this.router_;
    if (router) {
      try {
        url = router.buildUrl(routeName, routeParams);
      } catch (error) {
        console.log('RouterService.buildUrl.error', error);
      }
    }
    // console.log('RouterService.buildUrl', url, routeName, routeParams);
    return url;
  }
  static isActive(name, params, strictEquality, ignoreQueryParams) {
    if (strictEquality === void 0) {
      strictEquality = false;
    }
    if (ignoreQueryParams === void 0) {
      ignoreQueryParams = true;
    }
    let active = false;
    const router = this.router_;
    if (router) {
      try {
        active = router.isActive(name, params, strictEquality, ignoreQueryParams);
      } catch (error) {
        console.log('RouterService.isActive.error', error);
      }
    }
    // console.log('RouterService.isActive', active, name, params, strictEquality, ignoreQueryParams);
    return active;
  }
}
RouterService.routes = [];
RouterService.router_ = null;class StateService {
  static set state(state) {
    this.state$.next(state);
  }
  static get state() {
    return this.state$.getValue();
  }
  static patchState(state) {
    state = Object.assign({}, this.state, state);
    this.state = state;
  }
}
StateService.state$ = new rxjs.BehaviorSubject({});const RoleType = {
  Publisher: 'publisher',
  Attendee: 'attendee',
  Streamer: 'streamer',
  Viewer: 'viewer',
  SmartDevice: 'smart-device',
  SelfService: 'self-service',
  Embed: 'embed'
};
class User {
  constructor(options) {
    if (options) {
      Object.assign(this, options);
    }
  }
}const MEETING_ID_VALIDATOR = /^\d{9}-\d{4}-\d{13}(-\d+)?$/;
class MeetingId {
  get roleIndex() {
    return MeetingId.getRoleIndex(this.role);
  }
  set roleIndex(roleIndex) {
    const roleIndex_ = MeetingId.getRoleIndex(this.role);
    if (roleIndex_ !== roleIndex) {
      const key = Object.keys(RoleType)[roleIndex];
      this.role = RoleType[key];
    }
  }
  constructor(options) {
    this.userId = StateService.state.user ? StateService.state.user.id : 0;
    this.role = StateService.state.role || RoleType.Viewer;
    this.timestamp = new Date().valueOf().toString();
    this.pathId = null;
    // this.timestamp = (performance.now() * 10000000000000).toString();
    if (typeof options === 'string') {
      if (options.match(MEETING_ID_VALIDATOR)) {
        options = MeetingId.decompose(options);
      } else {
        console.warn('MeetingId', 'invalid meetingId', options);
        return null;
      }
    }
    if (typeof options === 'object') {
      if (options.id) {
        this.id = options.id;
      }
      if (options.userId) {
        this.userId = options.userId;
      }
      if (options.role) {
        this.role = options.role;
      }
      if (options.roleIndex) {
        this.roleIndex = options.roleIndex;
      }
      if (options.timestamp) {
        this.timestamp = options.timestamp;
      }
      if (options.pathId) {
        this.pathId = options.pathId;
      }
    }
    // console.log('MeetingId', this);
  }

  toString() {
    return MeetingId.compose(this.userId, this.roleIndex, this.timestamp, this.pathId);
  }
  toRoles() {
    const userId = this.userId;
    const timestamp = this.timestamp;
    const pathId = this.pathId;
    return {
      id: MeetingId.compose(userId, MeetingId.getRoleIndex(RoleType.Publisher), timestamp, pathId),
      idAttendee: MeetingId.compose(userId, MeetingId.getRoleIndex(RoleType.Attendee), timestamp, pathId),
      idStreamer: MeetingId.compose(userId, MeetingId.getRoleIndex(RoleType.Streamer), timestamp, pathId),
      idViewer: MeetingId.compose(userId, MeetingId.getRoleIndex(RoleType.Viewer), timestamp, pathId),
      idSmartDevice: MeetingId.compose(userId, MeetingId.getRoleIndex(RoleType.SmartDevice), timestamp, pathId),
      idSelfService: MeetingId.compose(userId, MeetingId.getRoleIndex(RoleType.SelfService), timestamp, pathId)
    };
  }
  static compose(userId, roleIndex, timestamp, pathId) {
    return `${MeetingId.padded(userId, 9)}-${MeetingId.padded(roleIndex, 4)}-${timestamp}${pathId ? `-${pathId}` : ''}`;
  }
  static decompose(meetingId) {
    const components = meetingId.split('-');
    return {
      userId: parseInt(components[0]),
      roleIndex: parseInt(components[1]),
      timestamp: parseInt(components[2]),
      pathId: components[3] ? parseInt(components[3]) : null
    };
  }
  static generateMeetingId() {
    const meetingId = new MeetingId();
    return meetingId.toRoles();
  }
  static getRoleIndex(role) {
    return Object.keys(RoleType).reduce((p, c, i) => {
      return RoleType[c] === role ? i : p;
    }, -1);
  }
  static padded(num, size) {
    const s = '000000000' + num;
    return s.substr(s.length - size);
  }
}class MeetingUrl {
  get meetingId() {
    return this.link ? new MeetingId(this.link) : null;
  }
  constructor(options) {
    /*
    this.link = LocationService.get('link') || null;
    this.name = LocationService.get('name') || null;
    this.firstName = LocationService.get('firstName') || null;
    this.lastName = LocationService.get('lastName') || null;
    this.email = LocationService.get('email') || null;
    this.role = LocationService.get('role') || null;
    this.viewId = LocationService.has('viewId') ? parseInt(LocationService.get('viewId')) : null;
    this.pathId = LocationService.has('pathId') ? parseInt(LocationService.get('pathId')) : null;
    this.embedViewId = LocationService.has('embedViewId') ? parseInt(LocationService.get('embedViewId')) : null;
    this.support = LocationService.has('support') ? (LocationService.get('support') === 'true') : false;
    */
    options = options || window.location.href;
    if (typeof options === 'string') {
      options = MeetingUrl.decompose(options);
    }
    if (typeof options === 'object') {
      Object.assign(this, options);
      if (options.user) {
        const name = MeetingUrl.getName(options.user);
        if (name) {
          this.name = name;
        }
        if (environment.flags.useExtendedUserInfo) {
          const firstName = MeetingUrl.getFirstName(options.user);
          if (firstName) {
            this.firstName = firstName;
          }
          const lastName = MeetingUrl.getLastName(options.user);
          if (lastName) {
            this.lastName = lastName;
          }
          const email = MeetingUrl.getEmail(options.user);
          if (email) {
            this.email = email;
          }
        }
      }
      if (options.name) {
        this.name = options.name;
      }
      if (environment.flags.useExtendedUserInfo) {
        if (options.firstName) {
          this.firstName = options.firstName;
        }
        if (options.lastName) {
          this.lastName = options.lastName;
        }
        if (options.email) {
          this.email = options.email;
        }
      }
    }
    this.link = this.link || null;
    this.name = this.name || null;
    this.firstName = this.firstName || null;
    this.lastName = this.lastName || null;
    this.email = this.email || null;
    this.role = this.role || null;
    this.viewId = this.viewId || null;
    this.pathId = this.pathId || null;
    this.embedViewId = this.embedViewId || null;
    this.support = this.support || false;
    // console.log('MeetingUrl', this);
  }

  toParams(shareable) {
    if (shareable === void 0) {
      shareable = false;
    }
    let params = {};
    if (this.link) {
      params.link = this.link;
    }
    if (environment.flags.useExtendedUserInfo) {
      if (this.firstName) {
        params.firstName = this.firstName;
      }
      if (this.lastName) {
        params.lastName = this.lastName;
      }
      if (this.email) {
        params.email = this.email;
      }
    } else {
      if (this.name) {
        params.name = this.name;
      }
    }
    if (this.role && !shareable) {
      params.role = this.role;
    }
    if (this.viewId) {
      params.viewId = this.viewId;
    }
    if (this.pathId) {
      params.pathId = this.pathId;
    }
    if (this.support) {
      params.support = this.support;
    }
    if (environment.flags.useEncryptedUrl) {
      params = {
        p: MeetingUrl.encrypt(params)
      };
    }
    return params;
  }
  toString(shareable) {
    if (shareable === void 0) {
      shareable = false;
    }
    let components;
    if (environment.flags.useExtendedUserInfo) {
      components = {
        link: this.link,
        firstName: this.firstName,
        lastName: this.lastName,
        email: this.email,
        role: shareable ? null : this.role,
        viewId: this.viewId,
        pathId: this.pathId,
        support: this.support
      };
    } else {
      components = {
        link: this.link,
        name: this.name,
        role: shareable ? null : this.role,
        viewId: this.viewId,
        pathId: this.pathId,
        support: this.support
      };
    }
    return MeetingUrl.compose(components);
  }
  toUrl() {
    const params = this.toParams();
    return MeetingUrl.getCurrentUrl(params);
  }
  toAccessCodeUrl() {
    const params = this.toParams();
    return MeetingUrl.getAccessCodeUrl(params);
  }
  toGuidedTourUrl() {
    const params = this.toParams();
    return MeetingUrl.getGuidedTourUrl(params);
  }
  copyToClipBoard(asAccessCode) {
    if (asAccessCode === void 0) {
      asAccessCode = false;
    }
    const input = document.createElement('input');
    input.style.position = 'absolute';
    input.style.top = '1000vh';
    // input.style.visibility = 'hidden';
    document.querySelector('body').appendChild(input);
    const params = this.toParams(true);
    input.value = window.location.origin + (asAccessCode ? MeetingUrl.getAccessCodeUrl(params) : MeetingUrl.getGuidedTourUrl(params));
    input.focus();
    input.select();
    input.setSelectionRange(0, 99999);
    document.execCommand('copy');
    input.parentNode.removeChild(input);
    alert(`link copiato!\n ${input.value}`);
  }
  replaceUrl() {
    RouterService.setCurrentParams(this.toParams());
  }
  static replaceWithOptions(options) {
    const currentOptions = MeetingUrl.decompose(window.location.href);
    const meetingUrl = new MeetingUrl(Object.assign(currentOptions, options));
    meetingUrl.replaceUrl();
    return meetingUrl;
  }
  static replaceWithUser(user) {
    return this.replaceWithOptions({
      user
    });
  }
  static replaceWithName(name) {
    return this.replaceWithOptions({
      name
    });
  }
  static replaceWithLink(link) {
    return this.replaceWithOptions({
      link
    });
  }
  static getCurrentUrl(params) {
    if (params === void 0) {
      params = null;
    }
    const route = RouterService.route;
    if (route) {
      const routeName = route.name;
      // console.log('MeetingUrl.getCurrentUrl', routeName);
      return RouterService.buildUrl(routeName, params);
    }
  }
  static getAccessCodeUrl(params) {
    if (params === void 0) {
      params = null;
    }
    const route = RouterService.route;
    if (route) {
      const routeName = `${route.params.lang}.accessCode`;
      // console.log('MeetingUrl.getAccessCodeUrl', routeName);
      return RouterService.buildUrl(routeName, params);
    }
  }
  static getGuidedTourUrl(params) {
    if (params === void 0) {
      params = null;
    }
    const route = RouterService.route;
    if (route) {
      const routeName = `${route.params.lang}.guidedTour`;
      // console.log('MeetingUrl.getGuidedTourUrl', routeName);
      return RouterService.buildUrl(routeName, params);
    }
  }
  static getName(user) {
    return user && user.firstName && user.lastName ? `${user.firstName} ${user.lastName}` : null;
  }
  static getFirstName(user) {
    return user && user.firstName ? user.firstName : null;
  }
  static getLastName(user) {
    return user && user.lastName ? user.lastName : null;
  }
  static getEmail(user) {
    return user && user.email ? user.email : null;
  }
  static compose(components) {
    if (environment.flags.useEncryptedUrl) {
      const p = MeetingUrl.encrypt(components);
      return `?p=${p}`;
    } else {
      components = Object.keys(components).map(key => {
        return {
          key,
          value: components[key]
        };
      }).filter(x => x.value != null && x.value !== false).map(x => `${x.key}=${x.value}`);
      return `?${components.join('&')}`;
    }
  }
  static decompose(url) {
    let components = {};
    if (environment.flags.useEncryptedUrl) {
      const params = new URLSearchParams(url.split('?')[1]);
      if (params.has('p')) {
        components = MeetingUrl.decrypt(params.get('p'));
      }
    } else if (url.indexOf('?') > -1) {
      const params = new URLSearchParams(url.split('?')[1]);
      params.forEach((value, key) => {
        switch (key) {
          case 'viewId':
          case 'pathId':
          case 'embedViewId':
            value = value ? parseInt(value) : null;
            break;
          case 'support':
            value = value ? value === 'true' : false;
            break;
        }
        components[key] = value;
      });
    }
    return components;
  }
  static decrypt(p) {
    return JSON.parse(window.atob(p));
  }
  static encrypt(params) {
    return window.btoa(JSON.stringify(params));
  }
  static validateParams(components) {
    if (environment.flags.useEncryptedUrl) {
      const p = MeetingUrl.encrypt(components);
      return {
        p
      };
    } else {
      return components;
    }
  }
}class RouterOutletStructure extends rxcomp.Structure {
  // host;
  // outlet;
  // element;
  // instance;
  // route$_ = new ReplaySubject(1);

  getFactory(route) {
    let factory = null;
    const routes = RouterService.routes;
    const originalRoute = routes.find(x => x.name === route.name);
    if (originalRoute) {
      factory = originalRoute.factory;
    }
    // console.log('RouterOutletStructure.getFactory', originalRoute, routes, route);
    return factory;
  }
  onInit() {
    this.route$().pipe(operators.switchMap(route => this.factory$(route)), operators.takeUntil(this.unsubscribe$)).subscribe(event => {
      // console.log('RouterOutletStructure.route$', event);
    });
    /*
    this.route$().pipe(
    	switchMap(snapshot => this.factory$(snapshot)),
    	takeUntil(this.unsubscribe$)
    ).subscribe(() => {
    	// console.log(`RouterOutletStructure ActivatedRoutes: ["${RouterService.flatRoutes.filter(x => x.snapshot).map(x => x.snapshot?.extractedUrl).join('", "')}"]`);
    });
    if (this.host) {
    	this.route$_.next(this.host.route.childRoute);
    }
    */
  }

  route$() {
    return RouterService.event$.pipe(operators.map(event => {
      const route = event.route;
      this.route = route;
      // console.log('RouterOutletStructure.route', route);
      return route;
    }));
    /*
    const routes = this.routes;
    // console.log('RouterOutletStructure.route$', routes);
    if (routes) {
    	return RouterService.useBrowser$(routes).pipe(
    		map(event => {
    			// console.log('RouterOutletStructure.route$', event);
    			return event.route;
    		}),
    	);
    } else {
    	return EMPTY;
    }
    */
  }

  factory$(route) {
    const factory = this.getFactory(route);
    // console.log('RouterOutletStructure.factory$', route, factory);
    const {
      module,
      node
    } = rxcomp.getContext(this);
    {
      this.factory_ = factory;
      return rxjs.of(factory).pipe(operators.tap(() => {
        if (this.element) {
          this.element.parentNode.removeChild(this.element);
          module.remove(this.element, this);
          this.element = undefined;
          this.instance = undefined;
        }
      }), operators.map(() => {
        if (factory && factory.meta.template) {
          let element = document.createElement('div');
          element.innerHTML = factory.meta.template;
          if (element.children.length === 1) {
            element = element.firstElementChild;
          }
          node.appendChild(element);
          const instance = module.makeInstance(element, factory, factory.meta.selector, this, undefined, {
            route
          });
          module.compile(element, instance);
          this.instance = instance;
          this.element = element;
          return {
            element,
            instance
          };
        }
      }));
    }
  }
  onChanges() {
    /*
    if (this.host) {
    	this.route$_.next(this.host.route.childRoute);
    }
    */
  }

  /*
  route$() {
  	const source = this.host ? this.route$_ : RouterService.route$;
  	return source.pipe(
  		filter((snapshot) => {
  			this.route_ = snapshot; // !!!
  			if (this.snapshot_ && snapshot && this.snapshot_.component === snapshot.component) {
  				this.snapshot_.next(snapshot);
  				return false;
  			} else {
  				this.snapshot_ = snapshot;
  				return true;
  			}
  		}),
  	);
  }
  */

  /*
  factory$(snapshot) {
  	const { module, node } = getContext(this);
  	const factory = snapshot.component;
  	if (this.factory_ !== factory) {
  		this.factory_ = factory;
  		return this.onLeave$_(snapshot, this.element, this.instance).pipe(
  			tap(() => {
  				if (this.element) {
  					this.element.parentNode.removeChild(this.element);
  					module.remove(this.element, this);
  					this.element = undefined;
  					this.instance = undefined;
  				}
  			}),
  			switchMap(() => {
  				if (snapshot && factory && factory.meta.template) {
  					let element = document.createElement('div');
  					element.innerHTML = factory.meta.template;
  					if (element.children.length === 1) {
  						element = element.firstElementChild;
  					}
  					node.appendChild(element);
  					const instance = module.makeInstance(element, factory, factory.meta.selector, this, undefined, { route: snapshot });
  					module.compile(element, instance);
  					this.instance = instance;
  					this.element = element;
  					snapshot.element = element;
  					return this.onOnce$_(snapshot, element, instance).pipe(
  						switchMap(() => {
  							return this.onEnter$_(snapshot, element, instance);
  						})
  					);
  				} else {
  					return of(void 0);
  				}
  			})
  		);
  	} else {
  		return of(void 0);
  	}
  }
  */

  /*
  onOnce$_(snapshot, element, instance) {
  	if (!transitionOnced() && instance instanceof View && element) {
  		transitionOnce();
  		const factory = instance.constructor;
  		const transition = factory.transitions.find((x) => x instanceof OnceTransition && x.matcher(snapshot.previousRoute?.path));
  		return transition ? asObservable([element, snapshot.previousRoute], transition.callback.bind(instance)) : of(void 0);
  	} else {
  		return of(void 0);
  	}
  }
  
  onEnter$_(snapshot, element, instance) {
  	if (instance instanceof View && element) {
  		const factory = instance.constructor;
  		const transition = factory.transitions.find((x) => x instanceof EnterTransition && x.matcher(snapshot.previousRoute?.path));
  		return transition ? asObservable([element, snapshot.previousRoute], transition.callback.bind(instance)) : of(void 0);
  	} else {
  		return of(void 0);
  	}
  }
  
  onLeave$_(snapshot, element, instance) {
  	if (instance instanceof View && element) {
  		const factory = instance.constructor;
  		const transition = factory.transitions.find((x) => x instanceof LeaveTransition && x.matcher(snapshot?.path));
  		return transition ? asObservable([element, snapshot], transition.callback.bind(instance)) : of(void 0);
  	} else {
  		return of(void 0);
  	}
  }
  */
}
RouterOutletStructure.meta = {
  selector: 'router-outlet,[router-outlet]',
  hosts: {
    host: RouterOutletStructure
  }
};// import { RouterService } from '../router/router.service';

class AccessCodeComponent extends rxcomp.Component {
  onInit() {
    this.state = {};
    const meetingUrl = new MeetingUrl();
    if (!meetingUrl.link) {
      // !!!
      // RouterService.setRouterLink(MeetingUrl.getGuidedTourUrl());
      window.location.href = window.location.origin + MeetingUrl.getGuidedTourUrl();
    } else {
      const url = meetingUrl.toGuidedTourUrl();
      const {
        node
      } = rxcomp.getContext(this);
      new QRious({
        element: node.querySelector('.qrcode'),
        value: url,
        size: 256
      });
    }
  }
}
AccessCodeComponent.meta = {
  selector: '[access-code-component]',
  hosts: {
    host: RouterOutletStructure
  },
  template: /* html */`
		<div class="page page--access-code">
			${CHUNK_BACKGROUND}
			<!-- access-code -->
			<div class="ui ui--info ui--info-centered">
				<div class="group--info">
					<div class="group--info__content stagger--childs">
						<div class="title" [innerHTML]="'access_code_title' | label"></div>
						<div class="picture">
							<canvas class="qrcode"></canvas>
						</div>
					</div>
				</div>
			</div>
			${CHUNK_LOGO}
			${CHUNK_CREDITS}
			${CHUNK_LANGUAGE}
		</div>
	`
};function ownKeys(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function (r) {
      return Object.getOwnPropertyDescriptor(e, r).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread2(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {
      _defineProperty(e, r, t[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
    });
  }
  return e;
}
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPrimitive(input, hint) {
  if (typeof input !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}class ControlsComponent extends rxcomp.Component {
  get group() {
    if (this.formGroup) {
      return this.formGroup;
    } else {
      if (!this.host) {
        throw 'missing form collection';
      }
      return this.host.control;
    }
  }
  getControl(name) {
    return this.group.get(name);
  }
}
ControlsComponent.meta = {
  selector: '[controls]',
  inputs: ['formGroup', 'fields'],
  hosts: {
    host: rxcompForm.FormAbstractCollectionDirective
  },
  template: /* html */`
		<div *for="let field of fields">
			<div *if="['text', 'email', 'url'].indexOf(field.type) !== -1" control-text [control]="getControl(field.name)" [label]="field.label | label"></div>
			<div *if="field.type == 'select'" control-select [control]="getControl(field.name)" [label]="field.label | label"></div>
			<div *if="field.type == 'custom-select'" control-custom-select [control]="getControl(field.name)" [label]="field.label | label"></div>
			<div *if="field.type == 'textarea'" control-textarea [control]="getControl(field.name)" [label]="field.label | label"></div>
			<div *if="field.type == 'checkbox'" control-checkbox [control]="getControl(field.name)" [label]="field.label | label"></div>
			<input *if="field.type == 'hidden'" [name]="field.name" [formControl]="getControl(field.name)" value="" type="text" style="display:none !important;" />
		</div>
	`
};
function fieldsToFormControls(fields) {
  const controls = fields.reduce((p, c, i) => {
    const validators = [];
    if (c.required) {
      validators.push(c.type === 'checkbox' ? rxcompForm.Validators.RequiredTrueValidator() : rxcompForm.Validators.RequiredValidator());
    }
    if (c.type === 'email') {
      validators.push(rxcompForm.Validators.EmailValidator());
    }
    if (c.type === 'url') {
      // eslint-disable-next-line no-useless-escape
      validators.push(rxcompForm.Validators.PatternValidator('(https?:\/\/(?:www\.|(?!www))[a-zA-Z0-9][a-zA-Z0-9-]+[a-zA-Z0-9]\.[^\s]{2,}|www\.[a-zA-Z0-9][a-zA-Z0-9-]+[a-zA-Z0-9]\.[^\s]{2,}|https?:\/\/(?:www\.|(?!www))[a-zA-Z0-9]+\.[^\s]{2,}|www\.[a-zA-Z0-9]+\.[^\s]{2,})'));
    }
    if (c.pattern != null) {
      validators.push(rxcompForm.Validators.PatternValidator(c.pattern));
    }
    p[c.name] = new rxcompForm.FormControl(c.value != null ? c.value : null, validators);
    if (c.type === 'select' || c.type === 'custom-select') {
      const options = (c.options || []).slice();
      options.unshift({
        id: null,
        name: 'select'
      }); // LabelPipe.transform('select')
      p[c.name].options = options;
    }
    return p;
  }, {});
  return controls;
}
function fieldsToFormGroup(fields) {
  return new rxcompForm.FormGroup(fieldsToFormControls(fields));
}
function patchFields(fields, form) {
  const testValues = fields.reduce((p, c, i) => {
    if (c.test) {
      p[c.name] = c.test;
    }
    return p;
  }, {});
  form.patch(testValues);
}class LabelPipe extends rxcomp.Pipe {
  static get labels() {
    return environment.labels;
  }
  static transform(key) {
    switch (key) {
      case '@copy':
        return this.getCopy();
    }
    const labels = LabelPipe.labels;
    let label = labels[key] != null ? labels[key] : key; // `#${key}#`;
    if (typeof label === 'string' && label.indexOf('@copy') !== -1) {
      label = label.replace('@copy', this.getCopy());
    }
    return label;
  }
  static getKeys() {
    for (var _len = arguments.length, keys = new Array(_len), _key = 0; _key < _len; _key++) {
      keys[_key] = arguments[_key];
    }
    return LabelPipe.transform(keys.map(x => x.replace('-', '_')).join('_'));
  }
  static getCopy() {
    return `©${new Date().getFullYear()}`;
  }
}
LabelPipe.meta = {
  name: 'label'
};class LocationService {
  static has(key) {
    const params = new URLSearchParams(window.location.search);
    // console.log('LocationService.has', params);
    return params.has(key);
  }
  static get(key) {
    const params = new URLSearchParams(window.location.search);
    // console.log('LocationService.get', params);
    return params.get(key);
  }
  static set(keyOrValue, value) {
    const params = new URLSearchParams(window.location.search);
    if (typeof keyOrValue === 'string') {
      params.set(keyOrValue, value);
    } else {
      params.set(keyOrValue, '');
    }
    this.pushParams(params);
    // console.log('LocationService.set', params, keyOrValue, value);
  }

  static delete(key) {
    const params = new URLSearchParams(window.location.search);
    // console.log('LocationService.has', params);
    if (params.has(key)) {
      params.delete(key);
      this.pushParams(params);
    }
  }
  static pushParams(params) {
    if (window.history && window.history.pushState) {
      const title = document.title;
      const url = `${window.location.href.split('?')[0]}?${params.toString()}`;
      window.history.pushState(params.toString(), title, url);
    }
  }
  static replace(from, to) {
    const history = window.history;
    if (history && history.replaceState) {
      const location = window.location;
      const title = document.title;
      if (location.pathname === '/') {
        const url = location.origin + to + location.search;
        history.replaceState(history.state, title, url);
      } else if (location.href.indexOf(from) !== -1) {
        const url = location.href.replace(from, to);
        history.replaceState(history.state, title, url);
      }
    }
  }
  static deserialize(key) {
    const encoded = this.get('params');
    return this.decode(key, encoded);
  }
  static serialize(keyOrValue, value) {
    const params = this.deserialize();
    const encoded = this.encode(keyOrValue, value, params);
    this.set('params', encoded);
  }
  static decode(key, encoded) {
    let decoded = null;
    if (encoded) {
      const json = window.atob(encoded);
      decoded = JSON.parse(json);
    }
    if (key && decoded) {
      decoded = decoded[key];
    }
    return decoded || null;
  }
  static encode(keyOrValue, value, params) {
    params = params || {};
    let encoded = null;
    if (typeof keyOrValue === 'string') {
      params[keyOrValue] = value;
    } else {
      params = keyOrValue;
    }
    const json = JSON.stringify(params);
    encoded = window.btoa(json);
    return encoded;
  }
}class LanguageService {
  static get lang() {
    return this.lang$.getValue();
  }
  static set lang(lang) {
    if (this.lang !== lang) {
      this.lang$.next(lang);
    }
  }
  static setAlternates(language, alternates) {
    this.languages = alternates;
    this.lang = language;
    // console.log('LanguageService.setAlternates', language, alternates);
  }

  static setRoute(route, routes) {
    const language = route.params.lang;
    // console.log('LanguageService.setRoute', route, route.path, language);
    const alternates = environment.languages.map(lang => {
      const title = lang === 'it' ? 'Italiano' : 'English';
      // eslint-disable-next-line no-useless-escape
      const alternateName = route.name.replace(new RegExp(`(^${language}$)|(^${language}\.)`), (match, g1, g2, offset) => {
        // console.log('LanguageService.match', match, g1, g2, offset);
        return g1 ? lang : `${lang}.`;
      });
      const alternate = routes.find(x => x.name === alternateName);
      // console.log('LanguageService.alternate', lang, alternateName, alternate);
      if (alternate) {
        return {
          name: alternate.name,
          params: route.params,
          href: alternate.path,
          lang: alternate.defaultParams.lang,
          title
        };
      } else {
        return null;
      }
    }).filter(x => x !== null);
    this.setAlternates(language, alternates);
  }
  static get hasLanguages() {
    return this.languages.length > 1;
  }
  static get activeLanguage() {
    return this.languages.find(language => language.lang === this.lang);
  }
  static getDefaultLanguages() {
    return environment.alternates || [];
  }
  static getDefaultLanguage() {
    return environment.defaultLanguage || (this.languages ? this.languages[0].lang : null);
  }
  static setLanguage(language) {
    this.lang = language.lang;
  }
  static setLanguage$(language) {
    if (typeof language === 'string') {
      language = this.languages.find(x => x.lang === language);
    }
    if (!language) {
      return;
    }
    const url = environment.flags.production ? `/api/${language.lang}/labels/` : `./api/${language.lang}/labels.json`;
    return rxjs.from(fetch(url).then(response => {
      return response.json();
    })).pipe(operators.tap(labels => {
      environment.labels = labels;
      RouterService.replaceHistoryState(language.name, language.params);
      const from = this.activeLanguage.href.split('?')[0];
      const to = language.href.split('?')[0];
      LocationService.replace(from, to);
      this.lang = language.lang;
    }));
    /*
    return of(language).pipe(
    	tap(language => {
    		// LabelPipe.setLabels();
    		LocationService.replace(this.activeLanguage.href, language.href);
    		this.lang = language.lang;
    	}),
    );
    */
  }

  static setLanguage$_(language) {
    return rxjs.from(fetch(language.href).then(response => {
      return response.text();
    })).pipe(operators.tap(html => {
      // console.log('html', html);
      const labelsMatch = /(window\.labels\s*=\s*\n*\s*\{((\{.+?\})|.)+?\})/gms.exec(html);
      if (labelsMatch) {
        // console.log('labels', labelsMatch[0]);
        new Function(labelsMatch[0]).call(window);
        LabelPipe.setLabels();
      }
      const bhereMatch = /(window\.bhere\s*=\s*\n*\s*\{((\{.+?\})|.)+?\})/gms.exec(html);
      if (bhereMatch) {
        // console.log('bhere', bhereMatch[0]);
        const data = {};
        new Function(bhereMatch[0].replace('window', 'this')).call(data);
        if (data.bhere) {
          Utils.merge(environment, data.bhere);
        }
      }
      LocationService.replace(this.activeLanguage.href, language.href);
      // console.log(environment.labels);
      this.lang = language.lang;
    }));
  }
  static toggleLanguages() {
    this.showLanguages = !this.showLanguages;
    this.pushChanges();
  }
}
LanguageService.languages = LanguageService.getDefaultLanguages();
LanguageService.lang$ = new rxjs.BehaviorSubject(LanguageService.getDefaultLanguage());class RoutePipe extends rxcomp.Pipe {
  static transform(key) {
    return key.replace(':lang', LanguageService.lang);
  }
}
RoutePipe.meta = {
  name: 'route'
};const USE_AUTODETECT = false;
const USE_VOLUME_INDICATOR = false;
const USE_RTM = true;
const VIDEO_PROFILES = [
/*
['120p_1', 160, 120, 15, 65, false]],
['120p_3', 120, 120, 15, 50, false]],
['180p_1', 320, 180, 15, 140, false]],
['180p_3', 180, 180, 15, 100, false]],
['180p_4', 240, 180, 15, 120, false]],
['240p_1', 320, 240, 15, 200, false]],
['240p_3', 240, 240, 15, 140, false]],
['240p_4', 424, 240, 15, 220, false]],
['360p_1', 640, 360, 15, 400, false]],
['360p_3', 360, 360, 15, 260, false]],
['360p_4', 640, 360, 30, 600, false]],
['360p_6', 360, 360, 30, 400, false]],
['360p_7', 480, 360, 15, 320, false]],
['360p_8', 480, 360, 30, 490, false]],
['360p_9', 640, 360, 15, 800, false]],
['360p_10', 640, 360, 24, 800, false]],
['360p_11', 640, 360, 24, 1000, false]],
*/
['480p_1', 640, 480, 15, 500, true], ['480p_2', 640, 480, 30, 1000, true], ['480p_3', 480, 480, 15, 400, true], ['480p_4', 640, 480, 30, 750, true], ['480p_6', 480, 480, 30, 600, true], ['480p_8', 848, 480, 15, 610, true], ['480p_9', 848, 480, 30, 930, true], ['480p_10', 640, 480, 10, 400, true], ['720p_1', 1280, 720, 15, 1130, true], ['720p_2', 1280, 720, 30, 2000, true], ['720p_3', 1280, 720, 30, 1710, true], ['720p_5', 960, 720, 15, 910, true], ['720p_6', 960, 720, 30, 1380, true], ['1080p_1', 1920, 1080, 15, 2080, false], ['1080p_2', 1920, 1080, 30, 3000, false], ['1080p_3', 1920, 1080, 30, 3150, false], ['1080p_5', 1920, 1080, 60, 4780, false]];
const StreamQualities = VIDEO_PROFILES.map(a => {
  return {
    profile: a[0],
    resolution: {
      width: a[1],
      height: a[2]
    },
    frameRate: {
      min: a[3],
      max: a[3]
    },
    bitrate: {
      min: a[4],
      max: a[4]
    },
    compatible: a[5]
  };
});

/*
export const StreamQualities = [{
	// id: 1,
	// name: '4K 2160p 3840x2160',
	profile: '4K',
	resolution: {
		width: 3840,
		height: 2160
	},
	frameRate: {
		min: 15,
		max: 30
	},
	bitrate: {
		min: 8910,
		max: 13500
	}
}, {
	// id: 2,
	// name: 'HD 1440p 2560×1440',
	profile: '1440p',
	resolution: {
		width: 2560,
		height: 1440
	},
	frameRate: {
		min: 15,
		max: 30
	},
	bitrate: {
		min: 4850,
		max: 7350
	}
}, {
	// id: 3,
	// name: 'HD 1080p 1920x1080',
	profile: '1080p',
	resolution: {
		width: 1920,
		height: 1080
	},
	frameRate: {
		min: 15,
		max: 30
	},
	bitrate: {
		min: 2080,
		max: 4780
	}
}, {
	// id: 4,
	// name: 'LOW 720p 1280x720',
	profile: '720p_3',
	resolution: {
		width: 1280,
		height: 720
	},
	frameRate: {
		min: 15,
		max: 30
	},
	bitrate: {
		min: 1130,
		max: 1710
	}
}, {
	// id: 5,
	// name: 'LOWEST 240p 320x240',
	profile: '240p_1',
	resolution: {
		width: 320,
		height: 240
	},
	frameRate: {
		min: 15,
		max: 15
	},
	bitrate: {
		min: 140,
		max: 200
	}
}];
*/

function getStreamQuality(state) {
  let profile = environment.profiles.streamer;
  switch (state.role) {
    case RoleType.Publisher:
    case RoleType.SmartDevice:
      profile = environment.profiles.publisher || environment.profiles.streamer;
      break;
    case RoleType.Attendee:
      profile = environment.profiles.attendee || environment.profiles.streamer;
      break;
  }
  return StreamQualities.find(x => x.profile === profile);
}

/*
export function getStreamQuality(state) {
	const lowestQuality = StreamQualities[StreamQualities.length - 1];
	const highestQuality = environment.flags.maxQuality ? StreamQualities[0] : StreamQualities[StreamQualities.length - 2];
	return (state.role === RoleType.Publisher || state.role === RoleType.SmartDevice) ? highestQuality : lowestQuality;
}
*/

const AgoraStatus = {
  Idle: 'idle',
  Checklist: 'checklist',
  Link: 'link',
  Login: 'login',
  Name: 'name',
  Device: 'device',
  ShouldConnect: 'should-connect',
  Connecting: 'connecting',
  Connected: 'connected',
  Disconnected: 'disconnected'
};
const MessageType = {
  AddLike: 'addLike',
  AgoraEvent: 'agoraEvent',
  ChannelMembers: 'channelMembers',
  ChatMessage: 'chatMessage',
  ChatTypingBegin: 'chatTypingBegin',
  ChatTypingEnd: 'chatTypingEnd',
  ControlInfo: 'controlInfo',
  CurrentTimeMedia: 'currentTimeMedia',
  MenuToggle: 'menuToggle',
  Mode: 'mode',
  NavInfo: 'navInfo',
  NavLink: 'navLink',
  NavLinkClose: 'navLinkClose',
  NavToGrid: 'navToGrid',
  NavToView: 'navToView',
  Ping: 'ping',
  PlayMedia: 'playMedia',
  PlayModel: 'playModel',
  RemoteSilencing: 'remoteSilencing',
  RequestControl: 'requestControl',
  RequestControlDismiss: 'requestControlDismiss',
  RequestSpy: 'requestSpy',
  RequestSpyDismiss: 'requestSpyDismiss',
  SelectItem: 'selectItem',
  SetSnapshot: 'setSnapshot',
  ShowPanel: 'showPanel',
  SlideChange: 'slideChange',
  SupportRequest: 'supportRequest',
  SupportRequestAccepted: 'supportRequestAccepted',
  SupportRequestRejected: 'supportRequestRejected',
  VREnded: 'vrEnded',
  VRStarted: 'vrStarted',
  VRState: 'vrState',
  ZoomMedia: 'zoomMedia'
};
const UIMode = {
  VirtualTour: 'virtual-tour',
  LiveMeeting: 'live-meeting',
  SelfServiceTour: 'self-service-tour',
  Embed: 'embed',
  None: 'none'
};
class AgoraEvent {
  constructor(options) {
    Object.assign(this, options);
  }
}
class AgoraPeerEvent extends AgoraEvent {}
class AgoraRemoteEvent extends AgoraEvent {}
class AgoraUserInfoUpdateEvent extends AgoraEvent {}
class AgoraMuteVideoEvent extends AgoraEvent {}
class AgoraUnmuteVideoEvent extends AgoraEvent {}
class AgoraMuteAudioEvent extends AgoraEvent {}
class AgoraUnmuteAudioEvent extends AgoraEvent {}
class AgoraVolumeLevelsEvent extends AgoraEvent {}class HttpService {
  static http$(method, url, data, format) {
    const methods = ['POST', 'PUT', 'PATCH'];
    let response_ = null;
    // url = this.getUrl(url, format);
    return rxjs.from(fetch(url, {
      method: method,
      headers: {
        'Accept': 'application/json',
        'Content-Type': 'application/json'
      },
      body: methods.indexOf(method) !== -1 ? JSON.stringify(data) : undefined
    }).then(response => {
      response_ = response;
      // console.log(response);
      try {
        const contentType = response.headers.get('content-type');
        let typedResponse;
        if (contentType && contentType.indexOf('application/json') !== -1) {
          typedResponse = response.json();
        } else {
          typedResponse = response.text();
        }
        if (response.ok) {
          return typedResponse;
        } else {
          return typedResponse.then(data => {
            return Promise.reject(data);
          });
        }
      } catch (error) {
        if (response.ok) {
          console.warn('HttpService.http$', 'Cannot parse response');
          return Promise.resolve();
        } else {
          return Promise.reject(error);
        }
      }
    })).pipe(operators.catchError(error => {
      return rxjs.throwError(this.getError(error, response_));
    }));
  }

  /*
  // !!! todo mapping response.data
  static http$(method, url, data, format = 'json') {
  	const methods = ['POST', 'PUT', 'PATCH'];
  	const body = (data && methods.indexOf(method) !== -1) ? JSON.stringify(data) : undefined;
  	const queryString = (data && methods.indexOf(method) !== -1) ? Object.keys(data).map(function(key) {
  		return key + '=' + encodeURI(data[key]);
  	}).join('&') : undefined;
  	if (queryString) {
  		url = `${url}?${queryString}`;
  	}
  	let response_ = null;
  	return from(fetch(url, {
  		method: method,
  		headers: {
  			'Accept': 'application/json',
  			'Content-Type': 'application/json',
  		},
  		body: body,
  	}).then((response) => {
  		response_ = new HttpResponse(response);
  		try {
  			const contentType = response.headers.get('content-type');
  			let typedResponse;
  			if (contentType && format === 'json' && contentType.indexOf('application/json') !== -1) {
  				typedResponse = response.json();
  			} else if (format === 'blob') {
  				typedResponse = response.blob();
  			} else {
  				typedResponse = response.text();
  			}
  			return typedResponse.then(data => {
  				response_.data = data;
  				if (response.ok) {
  					return Promise.resolve(response_);
  				} else {
  					return Promise.reject(response_);
  				}
  			});
  		} catch(error) {
  			if (response.ok) {
  				console.warn('HttpService.http$', 'Cannot parse response');
  				return Promise.resolve(response_);
  			} else {
  				return Promise.reject(this.getError(error, response_));
  			}
  		}
  	})).pipe(
  		catchError(error => {
  			return throwError(this.getError(error, response_));
  		}),
  	);
  }
  */

  static get$(url, data, format) {
    const query = this.query(data);
    return this.http$('GET', `${url}${query}`, undefined, format);
  }
  static delete$(url) {
    return this.http$('DELETE', url);
  }
  static post$(url, data) {
    return this.http$('POST', url, data);
  }
  static put$(url, data) {
    return this.http$('PUT', url, data);
  }
  static patch$(url, data) {
    return this.http$('PATCH', url, data);
  }
  static query(data) {
    return ''; // todo
  }

  static getError(object, response) {
    let error = typeof object === 'object' ? object : {};
    if (!error.status) {
      error.status = response ? response.status : 0;
    }
    if (!error.statusCode) {
      error.statusCode = response ? response.status : 0;
    }
    if (!error.statusMessage) {
      error.statusMessage = response ? response.statusText : object;
    }
    // console.log('HttpService.getError', error, object);
    return error;
  }
}class UserService {
  static setUser(user) {
    this.user$.next(user);
  }
  static me$() {
    return HttpService.get$('/api/user/me').pipe(operators.map(user => this.mapUser(user)), operators.catchError(error => {
      // console.log('UserService.me$.error', error);
      if (error.status === 404 || error.statusCode === 404) {
        return rxjs.of(null);
      } else {
        throw error;
      }
    }), operators.switchMap(user => {
      this.setUser(user);
      return this.user$;
    }));
  }
  static login$(payload) {
    return HttpService.post$('/api/user/login', payload).pipe(operators.map(user => this.mapUser(user)), operators.tap(user => this.setUser(user)));
  }
  static logout$() {
    return HttpService.get$('/api/user/logout').pipe(operators.map(user => this.mapUser(user)), operators.tap(user => this.setUser(null)));
  }
  static guidedTour$(payload) {
    return HttpService.post$('/api/user/guided-tour', payload).pipe(operators.map(user => this.mapUser(user)), operators.tap(user => this.setUser(user)));
  }
  static selfServiceTour$(payload) {
    return HttpService.post$('/api/user/self-service-tour', payload).pipe(operators.map(user => this.mapUser(user)), operators.tap(user => this.setUser(user)));
  }
  static selfServiceSupportRequest$(user, meetingId, link) {
    const payload = {
      user,
      meetingId,
      link
    };
    return HttpService.post$('/api/user/self-service-support-request', payload).pipe(operators.tap(_ => {
      if (!environment.flags.production) {
        fetch(environment.template.email.supportRequest).then(response => response.text()).then(html => {
          html = html.replace('{{username}}', MeetingUrl.getName(user));
          html = html.replace('{{href}}', link);
          const parser = new DOMParser();
          const newDocument = parser.parseFromString(html, 'text/html');
          setTimeout(() => {
            // const newWindow = window.open(window.location.origin + environment.template.email.supportRequest, '_blank');
            const newWindow = window.open();
            newWindow.document.head.innerHTML = newDocument.querySelector('head').innerHTML;
            newWindow.document.body.innerHTML = newDocument.querySelector('body').innerHTML;
          }, 3000);
        });
      }
    }));
  }
  static resolve$(payload, status) {
    if (status === 'login') {
      return this.login$(payload);
    }
    if (status === 'guided-tour') {
      return this.guidedTour$(payload);
    }
    if (status === 'self-service-tour') {
      return this.selfServiceTour$(payload);
    }
  }
  static log$(payload) {
    return HttpService.post$('/api/user/log', payload);
  }
  static temporaryUser$(roleType) {
    if (roleType === void 0) {
      roleType = RoleType.Embed;
    }
    return rxjs.of({
      id: this.uuid(),
      type: roleType,
      username: roleType
      // firstName: 'Jhon',
      // lastName: 'Appleseed',
    }).pipe(operators.map(user => this.mapUser(user)), operators.switchMap(user => {
      // console.log('UserService.temporaryUser$', user);
      this.setUser(user);
      return this.user$;
    }));
  }
  static overrideUser$(roleType) {
    if (roleType === void 0) {
      roleType = RoleType.Embed;
    }
    return this.me$().pipe(operators.switchMap(user => {
      if (user) {
        user.type = roleType;
        user.username = roleType;
        return this.user$;
      }
      return this.temporaryUser$(roleType);
    }));
  }
  static uuid() {
    return new Date().getTime();
    // return parseInt(process.hrtime.bigint().toString());
  }

  /*
  static retrieve$(payload) {
  	return HttpService.post$('/api/user/retrievepassword', payload).pipe(
  		map((user) => this.mapUser(user)),
  	);
  }
  
  static register$(payload) {
  	return HttpService.post$('/api/user/register', payload).pipe(
  		map((user) => this.mapUser(user)),
  	);
  }
  
  static update(payload) {
  	return HttpService.post$('/api/user/updateprofile', payload).pipe(
  		map((user) => this.mapUser(user)),
  	);
  }
  */

  static mapUser(user) {
    return new User(user);
  }
  static getMode(role) {
    let mode;
    switch (role) {
      case RoleType.Attendee:
      case RoleType.Streamer:
      case RoleType.Viewer:
      case RoleType.Publisher:
        mode = UIMode.VirtualTour;
        break;
      case RoleType.SelfService:
        mode = UIMode.SelfServiceTour;
        break;
      case RoleType.SmartDevice:
        mode = UIMode.LiveMeeting;
        break;
      case RoleType.Embed:
        mode = UIMode.Embed;
        break;
      default:
        mode = UIMode.None;
    }
    // console.log('UserService.getMode', role, mode);
    return mode;
  }
}
UserService.user$ = new rxjs.BehaviorSubject(null);let UID$2 = 0;
class WebhookEvent {
  constructor(options) {
    if (options) {
      Object.assign(this, options);
    }
  }
  toJson() {
    return JSON.stringify(this);
  }
  static newEvent(action, data, extra) {
    console.log('WebhookEvent.newEvent', action, data, extra);
    const event = new WebhookEvent();
    const timestamp = new Date().getTime();
    event.timestamp = timestamp;
    event.id = `${timestamp}-${++UID$2}`;
    event.action = action;
    event.data = data;
    if (extra) {
      event.extra = typeof extra === 'string' ? JSON.parse(extra) : extra;
    }
    if (StateService.state.link) {
      // ( meetingId, userSessionId, userRole, fullName, itemId, skuId, action:InfoPoint  )
      event.meetingId = StateService.state.link;
      event.userSessionId = StateService.state.uid;
      event.userRole = StateService.state.role;
      event.fullName = StateService.state.name;
    }
    return event;
  }
  static parseEvent(event) {
    if (event && 'data' in event) {
      const message = typeof event.data === 'string' ? JSON.parse(event.data) : event.data;
      if ('action' in message) {
        return new WebhookEvent(message);
      } else {
        return null;
      }
    } else {
      return null;
    }
  }
}
class WebhookService {
  static internal$_(event) {
    return rxjs.of(event).pipe(operators.tap(event => {
      console.log('WebhookService.internal$_.postMessage', event);
      if (window.parent) {
        window.parent.postMessage(event.action, event.toJson());
      }
    }), operators.switchMap(event => {
      return this.event$_.pipe(operators.filter(event => event.id === event.id), operators.first());
    }), operators.map(response => {
      console.log('WebhookService.internal$_.handleResponse_', event, response);
      return this.handleResponse_(event, response);
    }), operators.catchError(error => {
      return this.handleError_(event, error);
    }));
  }
  static send$_(uri, event) {
    return HttpService.post$(uri, event).pipe(operators.map(response => {
      return this.handleResponse_(event, response);
    }), operators.catchError(error => {
      return this.handleError_(event, error);
    }));
  }
  static send$(action, payload, extra) {
    console.log('WebhookService.send$', action, payload, extra);
    if (this.enabled) {
      const event = WebhookEvent.newEvent(action, payload, extra);
      const uris = environment.webhook.uris;
      const observables = uris.map(x => x === 'internal' ? this.internal$_(event) : this.send$_(x, event));
      return rxjs.forkJoin(observables);
      /*
      return combineLatest(observables).pipe(
      	map(results => {
      		const result = results.find((x, i) => uris[i] !== 'internal');
      		return result;
      	}),
      );
      return merge(observables);
      */
    } else {
      return rxjs.of(null);
    }
  }
  static handleResponse_(event, remoteResponse) {
    console.log('WebhookService.handleResponse_', remoteResponse);
    const response = Object.assign({}, event);
    response.remoteStatus = 1;
    response.remoteResponse = remoteResponse;
    return response;
  }
  static handleError_(event, error) {
    const response = Object.assign({}, event);
    response.remoteStatus = 0;
    response.remoteError = error;
    return rxjs.of(response);
  }
  static get enabled() {
    const webhook = environment.webhook;
    const enabled = webhook && webhook.uris && webhook.uris.length > 0;
    if (enabled) {
      webhook.methods = webhook.methods || {};
      webhook.methods.nav = webhook.methods.nav || [];
    }
    return enabled;
  }
}
WebhookService.event$_ = rxjs.fromEvent(window, 'message').pipe(operators.map(event => {
  const parsedEvent = WebhookEvent.parseEvent(event);
  return parsedEvent;
}), operators.filter(x => x !== null), operators.shareReplay(1));class AccessComponent extends rxcomp.Component {
  onInit() {
    // console.log('AccessComponent.onInit');
    this.state = {
      status: 'access'
    };
    window.onSSOPopupClose = status => {
      if (status === 'success') {
        alert('Login Successful');
        UserService.me$().pipe(operators.first()).subscribe(user => {
          // console.log('AccessComponent.onInit.onSSOPopupClose', user);
          const routeUrl = RoutePipe.transform(':lang.selfServiceTour');
          const pathId = environment.pathMapper && environment.pathMapper.ssoLogin ? environment.pathMapper.ssoLogin(user) : null;
          if (pathId) {
            RouterService.setRouterLink(routeUrl, MeetingUrl.validateParams({
              pathId
            }));
          } else {
            RouterService.setRouterLink(routeUrl);
          }
        });
      } else {
        alert('Login Failed');
      }
    };
  }
  onSelfServiceTourRequest() {
    this.initRequestForm();
    this.state.status = 'self-service-tour';
    this.pushChanges();
    if (STATIC && window.navigator.userAgent.indexOf('OculusBrowser') !== -1) {
      this.test();
      this.onSubmit();
    }
  }
  onGuidedTourRequest() {
    this.initRequestForm();
    this.state.status = 'guided-tour';
    this.pushChanges();
  }
  onSSOLogin(event) {
    const loginUrl = `${location.protocol}//${location.host}/sso/login`;
    window.open(loginUrl, 'BHere | SSO Login', 'left=20,top=20,width=600,height=600,toolbar=1,resizable=0');
    event.preventDefault();
    return false;
  }
  onSSORegister(event) {
    const loginUrl = `${location.protocol}//${location.host}/sso/register`;
    window.open(loginUrl, 'BHere | SSO Register', 'left=20,top=20,width=600,height=600,toolbar=1,resizable=0');
    event.preventDefault();
    return false;
  }
  onGuidedTourAccess() {
    UserService.logout$().pipe(operators.first()).subscribe(() => {
      RouterService.setRouterLink(RoutePipe.transform(':lang.guidedTour'));
    });
  }
  onLogin() {
    this.initLoginForm();
    this.state.status = 'login';
    this.pushChanges();
  }
  initRequestForm() {
    if (this.formSubscription) {
      this.formSubscription.unsubscribe();
    }
    const data = this.data = environment.data || {
      roles: [{
        id: 1,
        name: 'Show room'
      }, {
        id: 2,
        name: 'Architetto'
      }, {
        id: 3,
        name: 'Interior designer'
      }, {
        id: 4,
        name: 'Privato'
      }, {
        id: 5,
        name: 'Altro'
      }]
    };
    const fields = this.fields = environment.fields || [{
      type: 'text',
      name: 'firstName',
      label: 'access_first_name',
      required: true,
      test: 'Jhon'
    }, {
      type: 'text',
      name: 'lastName',
      label: 'access_last_name',
      required: true,
      test: 'Appleseed'
    }, {
      type: 'email',
      name: 'email',
      label: 'access_email',
      required: true,
      test: 'jhonappleseed@gmail.com'
    }, {
      type: 'custom-select',
      name: 'role',
      label: 'access_role',
      required: true,
      options: data.roles,
      test: data.roles[0].id
    }, {
      type: 'checkbox',
      name: 'privacy',
      label: 'access_privacy_disclaimer',
      required: true,
      test: true
    }];
    fields.push({
      type: 'hidden',
      name: 'checkField',
      value: '',
      test: ''
    });
    if (environment.antiforgery) {
      fields.push({
        type: 'none',
        name: 'checkRequest',
        value: environment.antiforgery,
        test: environment.antiforgery
      });
    }
    const form = this.form = fieldsToFormGroup(fields);
    this.controls = form.controls;
    this.formSubscription = form.changes$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(changes => {
      this.pushChanges();
    });
    this.error = null;
  }
  initLoginForm() {
    if (this.formSubscription) {
      this.formSubscription.unsubscribe();
    }
    const form = this.form = new rxcompForm.FormGroup({
      username: new rxcompForm.FormControl(null, rxcompForm.Validators.RequiredValidator()),
      password: new rxcompForm.FormControl(null, rxcompForm.Validators.RequiredValidator()),
      checkRequest: window.antiforgery || '',
      checkField: ''
    });
    this.controls = form.controls;
    this.formSubscription = form.changes$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(changes => {
      this.pushChanges();
    });
    this.error = null;
  }
  test() {
    if (this.state.status === 'login') {
      this.form.patch({
        username: 'publisher',
        password: 'publisher',
        checkRequest: window.antiforgery || '',
        checkField: ''
      });
    } else {
      patchFields(this.fields, this.form);
    }
  }
  reset() {
    this.form.reset();
  }
  onBack() {
    this.state.status = 'access';
    this.pushChanges();
  }
  onSubmit() {
    if (this.form.valid) {
      this.form.submitted = true;
      const payload = this.form.value;
      const webhookPayload = _objectSpread2({}, payload);
      const controls = this.controls;
      Object.keys(webhookPayload).forEach(key => {
        if (controls[key].options) {
          const options = controls[key].options;
          webhookPayload[key] = options.find(option => option.id === webhookPayload[key]).name;
        }
      });
      const status = this.state.status;
      UserService.resolve$(payload, status).pipe(operators.first()).subscribe(user => {
        console.log('!!!');
        console.log('AccessComponent.onSubmit', user);
        switch (status) {
          case 'guided-tour':
            this.onHandleHook('GuidedTour', webhookPayload).pipe(operators.first()).subscribe(response => {
              this.state.status = 'guided-tour-success';
              this.pushChanges();
            });
            break;
          case 'self-service-tour':
            this.onHandleHook('SelfServiceTour', webhookPayload).pipe(operators.first()).subscribe(response => {
              const routeUrl = RoutePipe.transform(':lang.selfServiceTour');
              const pathId = environment.pathMapper && environment.pathMapper.selfService ? environment.pathMapper.selfService(user) : null;
              if (pathId) {
                RouterService.setRouterLink(routeUrl, MeetingUrl.validateParams({
                  pathId
                }));
              } else {
                RouterService.setRouterLink(routeUrl);
              }
            });
            break;
          case 'login':
            RouterService.setRouterLink(RoutePipe.transform(':lang.guidedTour'));
            break;
        }
        this.form.reset();
      }, error => {
        console.log('AccessComponent.error', error);
        this.error = error;
        this.pushChanges();
      });
    } else {
      this.form.touched = true;
    }
  }
  isValid() {
    const isValid = this.form.valid;
    return isValid;
  }
  onHandleHook(action, values) {
    const payload = values;
    const extra = null;
    return WebhookService.send$(action, payload, extra);
  }
}
AccessComponent.meta = {
  selector: '[access-component]',
  hosts: {
    host: RouterOutletStructure
  },
  template: /*html*/`
		<div class="page page--access">
			<!-- background -->
			<div class="background" [class]="{ 'background--image': ('background.image' | env), 'background--video': ('background.video' | env) }" *if="state.status != 'connected'">
				<img [src]="'background.image' | env | asset" *if="'background.image' | env" />
				<video [src]="'background.video' | env | asset" *if="'background.video' | env" oncanplay="this.muted = true; this.classList.add('ready');" playsinline autoplay muted loop></video>
			</div>
			<!-- access -->
			<div class="ui ui--info ui--info-centered" *if="state.status == 'access'">
				<div class="group--info">
					<div class="group--info__content stagger--childs">
						<div class="title" [innerHTML]="'access_title' | label"></div>
						<div *if="'selfService' | flag">
							<button type="button" class="btn--next" (click)="onSelfServiceTourRequest($event)">
								<span [innerHTML]="'access_tour' | label"></span>
							</button>
						</div>
						<div *if="'guidedTourRequest' | flag">
							<div class="info" [innerHTML]="'access_or' | label"></div>
							<button type="button" class="btn--next" (click)="onGuidedTourRequest($event)">
								<span [innerHTML]="'access_guided_tour' | label"></span>
							</button>
						</div>
						<div *if="'guidedTourAccess' | flag">
							<div class="info" [innerHTML]="'access_has_meeting_id' | label"></div>
							<button type="button" class="btn--next" (click)="onGuidedTourAccess($event)">
								<span [innerHTML]="'access_guided_tour_cta' | label"></span>
							</button>
						</div>
						<div *if="'ssoLogin' | flag">
							<div class="info" [innerHTML]="'access_sso_login_info' | label"></div>
							<button type="button" class="btn--next" (click)="onSSOLogin($event)">
								<span [innerHTML]="'access_sso_login_cta' | label"></span>
							</button>
						</div>
						<div *if="'ssoRegister' | flag">
							<div class="info" [innerHTML]="'access_sso_register_info' | label"></div>
							<button type="button" class="btn--next" (click)="onSSORegister($event)">
								<span [innerHTML]="'access_sso_register_cta' | label"></span>
							</button>
						</div>
					</div>
				</div>
			</div>
			<!-- guided-tour -->
			<div class="ui ui--info" *if="state.status == 'self-service-tour' || state.status == 'guided-tour'">
				<div class="group--info">
					<form class="form" [formGroup]="form" (submit)="isValid() && onSubmit()" name="form" role="form" novalidate autocomplete="off">
						<div class="group--info__content stagger--childs">
							<div class="title" *if="state.status == 'self-service-tour'" [innerHTML]="'access_fill_fields' | label"></div>
							<div class="title" *if="state.status == 'guided-tour'" [innerHTML]="'access_guided_tour_request' | label"></div>
							<!-- controls -->
							<div controls [formGroup]="form" [fields]="fields"></div>
							<div class="group--error" *if="error">
								<span class="status-code" [innerHTML]="error.statusCode"></span>
								<span class="status-message" [innerHTML]="error.statusMessage"></span>
								<span class="friendly-message" [innerHTML]="error.friendlyMessage"></span>
							</div>
							<!-- <div class="info" *if="isValid()" [innerHTML]="'access_take_part' | label"></div> -->
							<button type="submit" class="btn--next" [class]="{ disabled: !isValid() }">
								<span *if="!form.submitted" [innerHTML]="'access_send' | label"></span>
								<span *if="form.submitted" [innerHTML]="'access_sent' | label"></span>
							</button>
							<button type="button" class="btn--mode" (click)="onBack($event)">
								<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#arrow-prev"></use></svg>
								<span [innerHTML]="'access_back' | label"></span>
							</button>
							<test-component [form]="form" (test)="test($event)" (reset)="reset($event)"></test-component>
						</div>
					</form>
				</div>
			</div>
			<!-- guided-tour success -->
			<div class="ui ui--info ui--info-centered" *if="state.status == 'guided-tour-success'">
				<div class="group--info">
					<div class="group--info__content stagger--childs">
						<div class="title" [innerHTML]="'access_request_sent' | label"></div>
						<div class="info" [innerHTML]="'access_info_request' | label"></div>
						<button type="button" class="btn--mode" (click)="onBack($event)">
							<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#arrow-prev"></use></svg>
							<span [innerHTML]="'access_back' | label"></span>
						</button>
					</div>
				</div>
			</div>
			<!-- login -->
			<div class="ui ui--info ui--info-centered" *if="state.status == 'login'">
				<div class="group--info">
					<form class="form" [formGroup]="form" (submit)="isValid() && onSubmit()" name="form" role="form" novalidate autocomplete="off">
						<div class="group--info__content stagger--childs">
							<div class="title" [innerHTML]="'access_login' | label"></div>
							<input name="checkField" [formControl]="controls.checkField" value="" type="text" style="display:none !important;" />
							<div control-text [control]="controls.username" [label]="'access_username' | label"></div>
							<div control-password [control]="controls.password" [label]="'access_password' | label"></div>
							<div class="group--error" *if="error">
								<span class="status-code" [innerHTML]="error.statusCode"></span>
								<span class="status-message" [innerHTML]="error.statusMessage"></span>
								<span class="friendly-message" [innerHTML]="error.friendlyMessage"></span>
							</div>
							<div class="info" *if="isValid()" [innerHTML]="'access_cta' | label"></div>
							<button type="submit" class="btn--next" [class]="{ disabled: !isValid() }">
								<span [innerHTML]="'access_cta' | label"></span>
							</button>
							<button type="button" class="btn--mode" (click)="onBack($event)">
								<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#arrow-prev"></use></svg>
								<span [innerHTML]="'access_back' | label"></span>
							</button>
							<test-component [form]="form" (test)="test($event)" (reset)="reset($event)"></test-component>
						</div>
					</form>
				</div>
			</div>
			<header>
				<!-- logo -->
				<div class="btn--logo" (click)="onBack($event)">
					<img [src]="'logo' | env" *if="'logo' | env" />
					<svg viewBox="0 0 270 98" *if="!('logo' | env)"><use xlink:href="#b-here"></use></svg>
				</div>
				${CHUNK_LANGUAGE}
			</header>
			<footer>
				<span class="group--colophon" *if="state.status != 'connected'">
					${CHUNK_CREDITS}
					${CHUNK_COPYRIGHT}
				</span>
				<!-- login -->
				<button type="button" class="btn--absolute" (click)="onLogin($event)" *if="state.status == 'access'">
					<span [innerHTML]="'access_cta' | label"></span> <svg class="lock" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#lock"></use></svg>
				</button>
			</footer>
		</div>
	`
};class EmojiService {
  static emoji$() {
    if (EmojiService.items_ != null) {
      return rxjs.of(EmojiService.items_);
    }
    return HttpService.get$(`${environment.assets}api/emoji/emoji.json`).pipe(operators.map(items => {
      // items = items.slice(0, Math.min(80, items.length));
      EmojiService.items_ = items;
      return items;
    }));
  }
}class AgoraChatEmojiComponent extends rxcomp.Component {
  onInit() {
    this.items = [];
    EmojiService.emoji$().pipe(operators.first()).subscribe(items => {
      setTimeout(() => {
        this.items = items;
        this.pushChanges();
      }, 1);
    });
  }
  onSelect(item) {
    this.emoji.next(item);
  }
  onClose(_) {
    this.close.next();
  }
}
AgoraChatEmojiComponent.meta = {
  selector: '[agora-chat-emoji]',
  outputs: ['emoji', 'close']
};class MessageService {
  static message(message) {
    this.message$.next(message);
  }
  static in(message) {
    // console.log('MessageService.in', message);
    this.in$.next(message);
  }
  static sendBack(message) {
    message = Object.assign({}, message, {
      remoteId: message.clientId
    });
    // console.log('MessageService.sendBack', message);
    this.in$.next(message);
  }
  static out(message) {
    this.out$.next(message);
  }
}
MessageService.message$ = new rxjs.ReplaySubject(1);
MessageService.in$ = new rxjs.ReplaySubject(1);
MessageService.send = MessageService.in;
MessageService.out$ = new rxjs.ReplaySubject(1);var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}var AgoraRTC_NProduction = {exports: {}};/**
 * AgoraWebSDK_N-v4.18.2-0-g8d83af1d-dirty Copyright AgoraInc.
 */

(function (module, exports) {
!function(e,t){module.exports=t();}(commonjsGlobal,(function(){function e(e,t){return t.forEach((function(t){t&&"string"!=typeof t&&!Array.isArray(t)&&Object.keys(t).forEach((function(i){if("default"!==i&&!(i in e)){var n=Object.getOwnPropertyDescriptor(t,i);Object.defineProperty(e,i,n.get?n:{enumerable:!0,get:function(){return t[i]}});}}));})),Object.freeze(e)}var t="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof commonjsGlobal?commonjsGlobal:"undefined"!=typeof self?self:{},i=function(e){try{return !!e()}catch(e){return !0}},n=!i((function(){var e=function(){}.bind();return "function"!=typeof e||e.hasOwnProperty("prototype")})),r=n,o=Function.prototype,s=o.bind,a=o.call,c=r&&s.bind(a,a),d=r?function(e){return e&&c(e)}:function(e){return e&&function(){return a.apply(e,arguments)}},u=d({}.isPrototypeOf),l=function(e){return e&&e.Math==Math&&e},h=l("object"==typeof globalThis&&globalThis)||l("object"==typeof window&&window)||l("object"==typeof self&&self)||l("object"==typeof t&&t)||function(){return this}()||Function("return this")(),p=n,_=Function.prototype,E=_.apply,m=_.call,f="object"==typeof Reflect&&Reflect.apply||(p?m.bind(E):function(){return m.apply(E,arguments)}),S=function(e){return "function"==typeof e},T={},g=!i((function(){return 7!=Object.defineProperty({},1,{get:function(){return 7}})[1]})),R=n,I=Function.prototype.call,C=R?I.bind(I):function(){return I.apply(I,arguments)},v={},y={}.propertyIsEnumerable,A=Object.getOwnPropertyDescriptor,O=A&&!y.call({1:2},1);v.f=O?function(e){var t=A(this,e);return !!t&&t.enumerable}:y;var N,b,w=function(e,t){return {enumerable:!(1&e),configurable:!(2&e),writable:!(4&e),value:t}},D=d,P=D({}.toString),L=D("".slice),k=function(e){return L(P(e),8,-1)},M=d,U=i,x=k,V=h.Object,j=M("".split),F=U((function(){return !V("z").propertyIsEnumerable(0)}))?function(e){return "String"==x(e)?j(e,""):V(e)}:V,B=h.TypeError,G=function(e){if(null==e)throw B("Can't call method on "+e);return e},W=F,H=G,K=function(e){return W(H(e))},Y=S,q=function(e){return "object"==typeof e?null!==e:Y(e)},J={},X=J,z=h,Q=S,Z=function(e){return Q(e)?e:void 0},$=function(e,t){return arguments.length<2?Z(X[e])||Z(z[e]):X[e]&&X[e][t]||z[e]&&z[e][t]},ee=$("navigator","userAgent")||"",te=h,ie=ee,ne=te.process,re=te.Deno,oe=ne&&ne.versions||re&&re.version,se=oe&&oe.v8;se&&(b=(N=se.split("."))[0]>0&&N[0]<4?1:+(N[0]+N[1])),!b&&ie&&(!(N=ie.match(/Edge\/(\d+)/))||N[1]>=74)&&(N=ie.match(/Chrome\/(\d+)/))&&(b=+N[1]);var ae=b,ce=ae,de=i,ue=!!Object.getOwnPropertySymbols&&!de((function(){var e=Symbol();return !String(e)||!(Object(e)instanceof Symbol)||!Symbol.sham&&ce&&ce<41})),le=ue&&!Symbol.sham&&"symbol"==typeof Symbol.iterator,he=$,pe=S,_e=u,Ee=le,me=h.Object,fe=Ee?function(e){return "symbol"==typeof e}:function(e){var t=he("Symbol");return pe(t)&&_e(t.prototype,me(e))},Se=h.String,Te=function(e){try{return Se(e)}catch(e){return "Object"}},ge=S,Re=Te,Ie=h.TypeError,Ce=function(e){if(ge(e))return e;throw Ie(Re(e)+" is not a function")},ve=Ce,ye=function(e,t){var i=e[t];return null==i?void 0:ve(i)},Ae=C,Oe=S,Ne=q,be=h.TypeError,we={exports:{}},De=h,Pe=Object.defineProperty,Le=function(e,t){try{Pe(De,e,{value:t,configurable:!0,writable:!0});}catch(i){De[e]=t;}return t},ke="__core-js_shared__",Me=h[ke]||Le(ke,{}),Ue=Me;(we.exports=function(e,t){return Ue[e]||(Ue[e]=void 0!==t?t:{})})("versions",[]).push({version:"3.20.3",mode:"pure",copyright:"© 2014-2022 Denis Pushkarev (zloirock.ru)",license:"https://github.com/zloirock/core-js/blob/v3.20.3/LICENSE",source:"https://github.com/zloirock/core-js"});var xe=G,Ve=h.Object,je=function(e){return Ve(xe(e))},Fe=je,Be=d({}.hasOwnProperty),Ge=Object.hasOwn||function(e,t){return Be(Fe(e),t)},We=d,He=0,Ke=Math.random(),Ye=We(1..toString),qe=function(e){return "Symbol("+(void 0===e?"":e)+")_"+Ye(++He+Ke,36)},Je=h,Xe=we.exports,ze=Ge,Qe=qe,Ze=ue,$e=le,et=Xe("wks"),tt=Je.Symbol,it=tt&&tt.for,nt=$e?tt:tt&&tt.withoutSetter||Qe,rt=function(e){if(!ze(et,e)||!Ze&&"string"!=typeof et[e]){var t="Symbol."+e;Ze&&ze(tt,e)?et[e]=tt[e]:et[e]=$e&&it?it(t):nt(t);}return et[e]},ot=C,st=q,at=fe,ct=ye,dt=function(e,t){var i,n;if("string"===t&&Oe(i=e.toString)&&!Ne(n=Ae(i,e)))return n;if(Oe(i=e.valueOf)&&!Ne(n=Ae(i,e)))return n;if("string"!==t&&Oe(i=e.toString)&&!Ne(n=Ae(i,e)))return n;throw be("Can't convert object to primitive value")},ut=rt,lt=h.TypeError,ht=ut("toPrimitive"),pt=function(e,t){if(!st(e)||at(e))return e;var i,n=ct(e,ht);if(n){if(void 0===t&&(t="default"),i=ot(n,e,t),!st(i)||at(i))return i;throw lt("Can't convert object to primitive value")}return void 0===t&&(t="number"),dt(e,t)},_t=fe,Et=function(e){var t=pt(e,"string");return _t(t)?t:t+""},mt=q,ft=h.document,St=mt(ft)&&mt(ft.createElement),Tt=function(e){return St?ft.createElement(e):{}},gt=Tt,Rt=!g&&!i((function(){return 7!=Object.defineProperty(gt("div"),"a",{get:function(){return 7}}).a})),It=g,Ct=C,vt=v,yt=w,At=K,Ot=Et,Nt=Ge,bt=Rt,wt=Object.getOwnPropertyDescriptor;T.f=It?wt:function(e,t){if(e=At(e),t=Ot(t),bt)try{return wt(e,t)}catch(e){}if(Nt(e,t))return yt(!Ct(vt.f,e,t),e[t])};var Dt=i,Pt=S,Lt=/#|\.prototype\./,kt=function(e,t){var i=Ut[Mt(e)];return i==Vt||i!=xt&&(Pt(t)?Dt(t):!!t)},Mt=kt.normalize=function(e){return String(e).replace(Lt,".").toLowerCase()},Ut=kt.data={},xt=kt.NATIVE="N",Vt=kt.POLYFILL="P",jt=kt,Ft=Ce,Bt=n,Gt=d(d.bind),Wt=function(e,t){return Ft(e),void 0===t?e:Bt?Gt(e,t):function(){return e.apply(t,arguments)}},Ht={},Kt=g&&i((function(){return 42!=Object.defineProperty((function(){}),"prototype",{value:42,writable:!1}).prototype})),Yt=h,qt=q,Jt=Yt.String,Xt=Yt.TypeError,zt=function(e){if(qt(e))return e;throw Xt(Jt(e)+" is not an object")},Qt=g,Zt=Rt,$t=Kt,ei=zt,ti=Et,ii=h.TypeError,ni=Object.defineProperty,ri=Object.getOwnPropertyDescriptor,oi="enumerable",si="configurable",ai="writable";Ht.f=Qt?$t?function(e,t,i){if(ei(e),t=ti(t),ei(i),"function"==typeof e&&"prototype"===t&&"value"in i&&ai in i&&!i.writable){var n=ri(e,t);n&&n.writable&&(e[t]=i.value,i={configurable:si in i?i.configurable:n.configurable,enumerable:oi in i?i.enumerable:n.enumerable,writable:!1});}return ni(e,t,i)}:ni:function(e,t,i){if(ei(e),t=ti(t),ei(i),Zt)try{return ni(e,t,i)}catch(e){}if("get"in i||"set"in i)throw ii("Accessors not supported");return "value"in i&&(e[t]=i.value),e};var ci=Ht,di=w,ui=g?function(e,t,i){return ci.f(e,t,di(1,i))}:function(e,t,i){return e[t]=i,e},li=h,hi=f,pi=d,_i=S,Ei=T.f,mi=jt,fi=J,Si=Wt,Ti=ui,gi=Ge,Ri=function(e){var t=function(i,n,r){if(this instanceof t){switch(arguments.length){case 0:return new e;case 1:return new e(i);case 2:return new e(i,n)}return new e(i,n,r)}return hi(e,this,arguments)};return t.prototype=e.prototype,t},Ii=function(e,t){var i,n,r,o,s,a,c,d,u=e.target,l=e.global,h=e.stat,p=e.proto,_=l?li:h?li[u]:(li[u]||{}).prototype,E=l?fi:fi[u]||Ti(fi,u,{})[u],m=E.prototype;for(r in t)i=!mi(l?r:u+(h?".":"#")+r,e.forced)&&_&&gi(_,r),s=E[r],i&&(a=e.noTargetGet?(d=Ei(_,r))&&d.value:_[r]),o=i&&a?a:t[r],i&&typeof s==typeof o||(c=e.bind&&i?Si(o,li):e.wrap&&i?Ri(o):p&&_i(o)?pi(o):o,(e.sham||o&&o.sham||s&&s.sham)&&Ti(c,"sham",!0),Ti(E,r,c),p&&(gi(fi,n=u+"Prototype")||Ti(fi,n,{}),Ti(fi[n],r,o),e.real&&m&&!m[r]&&Ti(m,r,o)));},Ci=Math.ceil,vi=Math.floor,yi=function(e){var t=+e;return t!=t||0===t?0:(t>0?vi:Ci)(t)},Ai=yi,Oi=Math.min,Ni=function(e){return e>0?Oi(Ai(e),9007199254740991):0},bi=function(e){return Ni(e.length)},wi=Ce,Di=je,Pi=F,Li=bi,ki=h.TypeError,Mi=function(e){return function(t,i,n,r){wi(i);var o=Di(t),s=Pi(o),a=Li(o),c=e?a-1:0,d=e?-1:1;if(n<2)for(;;){if(c in s){r=s[c],c+=d;break}if(c+=d,e?c<0:a<=c)throw ki("Reduce of empty array with no initial value")}for(;e?c>=0:a>c;c+=d)c in s&&(r=i(r,s[c],c,o));return r}},Ui={left:Mi(!1),right:Mi(!0)},xi=i,Vi=function(e,t){var i=[][e];return !!i&&xi((function(){i.call(null,t||function(){throw 1},1);}))},ji="process"==k(h.process),Fi=Ui.left,Bi=ae,Gi=ji;Ii({target:"Array",proto:!0,forced:!Vi("reduce")||!Gi&&Bi>79&&Bi<83},{reduce:function(e){var t=arguments.length;return Fi(this,e,t,t>1?arguments[1]:void 0)}});var Wi=J,Hi=function(e){return Wi[e+"Prototype"]},Ki=Hi("Array").reduce,Yi=u,qi=Ki,Ji=Array.prototype,Xi=function(e){var t=e.reduce;return e===Ji||Yi(Ji,e)&&t===Ji.reduce?qi:t},zi=Xi;let Qi=!0,Zi=!0;function $i(e,t,i){const n=e.match(t);return n&&n.length>=i&&parseInt(n[i],10)}function en(e,t,i){if(!e.RTCPeerConnection)return;const n=e.RTCPeerConnection.prototype,r=n.addEventListener;n.addEventListener=function(e,n){if(e!==t)return r.apply(this,arguments);const o=e=>{const t=i(e);t&&(n.handleEvent?n.handleEvent(t):n(t));};return this._eventMap=this._eventMap||{},this._eventMap[t]||(this._eventMap[t]=new Map),this._eventMap[t].set(n,o),r.apply(this,[e,o])};const o=n.removeEventListener;n.removeEventListener=function(e,i){if(e!==t||!this._eventMap||!this._eventMap[t])return o.apply(this,arguments);if(!this._eventMap[t].has(i))return o.apply(this,arguments);const n=this._eventMap[t].get(i);return this._eventMap[t].delete(i),0===this._eventMap[t].size&&delete this._eventMap[t],0===Object.keys(this._eventMap).length&&delete this._eventMap,o.apply(this,[e,n])},Object.defineProperty(n,"on"+t,{get(){return this["_on"+t]},set(e){this["_on"+t]&&(this.removeEventListener(t,this["_on"+t]),delete this["_on"+t]),e&&this.addEventListener(t,this["_on"+t]=e);},enumerable:!0,configurable:!0});}function tn(e){return "boolean"!=typeof e?new Error("Argument type: "+typeof e+". Please use a boolean."):(Qi=e,e?"adapter.js logging disabled":"adapter.js logging enabled")}function nn(e){return "boolean"!=typeof e?new Error("Argument type: "+typeof e+". Please use a boolean."):(Zi=!e,"adapter.js deprecation warnings "+(e?"disabled":"enabled"))}function rn(){if("object"==typeof window){if(Qi)return;"undefined"!=typeof console&&"function"==typeof console.log&&console.log.apply(console,arguments);}}function on(e,t){Zi&&console.warn(e+" is deprecated, please use "+t+" instead.");}function sn(e){const t={browser:null,version:null};if(void 0===e||!e.navigator)return t.browser="Not a browser.",t;const{navigator:i}=e;if(i.mozGetUserMedia)t.browser="firefox",t.version=$i(i.userAgent,/Firefox\/(\d+)\./,1);else if(i.webkitGetUserMedia||!1===e.isSecureContext&&e.webkitRTCPeerConnection)t.browser="chrome",t.version=$i(i.userAgent,/Chrom(e|ium)\/(\d+)\./,2);else {if(!e.RTCPeerConnection||!i.userAgent.match(/AppleWebKit\/(\d+)\./))return t.browser="Not a supported browser.",t;t.browser="safari",t.version=$i(i.userAgent,/AppleWebKit\/(\d+)\./,1),t.supportsUnifiedPlan=e.RTCRtpTransceiver&&"currentDirection"in e.RTCRtpTransceiver.prototype;}return t}function an(e){return "[object Object]"===Object.prototype.toString.call(e)}function cn(e){var t;return an(e)?zi(t=Object.keys(e)).call(t,(function(t,i){const n=an(e[i]),r=n?cn(e[i]):e[i],o=n&&!Object.keys(r).length;return void 0===r||o?t:Object.assign(t,{[i]:r})}),{}):e}function dn(e,t,i){const n=i?"outbound-rtp":"inbound-rtp",r=new Map;if(null===t)return r;const o=[];return e.forEach(e=>{"track"===e.type&&e.trackIdentifier===t.id&&o.push(e);}),o.forEach(t=>{e.forEach(i=>{i.type===n&&i.trackId===t.id&&function e(t,i,n){i&&!n.has(i.id)&&(n.set(i.id,i),Object.keys(i).forEach(r=>{r.endsWith("Id")?e(t,t.get(i[r]),n):r.endsWith("Ids")&&i[r].forEach(i=>{e(t,t.get(i),n);});}));}(e,i,r);});}),r}var un=we.exports,ln=qe,hn=un("keys"),pn=function(e){return hn[e]||(hn[e]=ln(e))},_n=!i((function(){function e(){}return e.prototype.constructor=null,Object.getPrototypeOf(new e)!==e.prototype})),En=h,mn=Ge,fn=S,Sn=je,Tn=_n,gn=pn("IE_PROTO"),Rn=En.Object,In=Rn.prototype,Cn=Tn?Rn.getPrototypeOf:function(e){var t=Sn(e);if(mn(t,gn))return t[gn];var i=t.constructor;return fn(i)&&t instanceof i?i.prototype:t instanceof Rn?In:null},vn=h,yn=S,An=vn.String,On=vn.TypeError,Nn=d,bn=zt,wn=function(e){if("object"==typeof e||yn(e))return e;throw On("Can't set "+An(e)+" as a prototype")},Dn=Object.setPrototypeOf||("__proto__"in{}?function(){var e,t=!1,i={};try{(e=Nn(Object.getOwnPropertyDescriptor(Object.prototype,"__proto__").set))(i,[]),t=i instanceof Array;}catch(e){}return function(i,n){return bn(i),wn(n),t?e(i,n):i.__proto__=n,i}}():void 0),Pn={},Ln=yi,kn=Math.max,Mn=Math.min,Un=function(e,t){var i=Ln(e);return i<0?kn(i+t,0):Mn(i,t)},xn=K,Vn=Un,jn=bi,Fn=function(e){return function(t,i,n){var r,o=xn(t),s=jn(o),a=Vn(n,s);if(e&&i!=i){for(;s>a;)if((r=o[a++])!=r)return !0}else for(;s>a;a++)if((e||a in o)&&o[a]===i)return e||a||0;return !e&&-1}},Bn={includes:Fn(!0),indexOf:Fn(!1)},Gn={},Wn=Ge,Hn=K,Kn=Bn.indexOf,Yn=Gn,qn=d([].push),Jn=function(e,t){var i,n=Hn(e),r=0,o=[];for(i in n)!Wn(Yn,i)&&Wn(n,i)&&qn(o,i);for(;t.length>r;)Wn(n,i=t[r++])&&(~Kn(o,i)||qn(o,i));return o},Xn=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"],zn=Jn,Qn=Xn.concat("length","prototype");Pn.f=Object.getOwnPropertyNames||function(e){return zn(e,Qn)};var Zn={};Zn.f=Object.getOwnPropertySymbols;var $n=$,er=Pn,tr=Zn,ir=zt,nr=d([].concat),rr=$n("Reflect","ownKeys")||function(e){var t=er.f(ir(e)),i=tr.f;return i?nr(t,i(e)):t},or=Ge,sr=rr,ar=T,cr=Ht,dr={},ur=Jn,lr=Xn,hr=Object.keys||function(e){return ur(e,lr)},pr=g,_r=Kt,Er=Ht,mr=zt,fr=K,Sr=hr;dr.f=pr&&!_r?Object.defineProperties:function(e,t){mr(e);for(var i,n=fr(t),r=Sr(t),o=r.length,s=0;o>s;)Er.f(e,i=r[s++],n[i]);return e};var Tr,gr=$("document","documentElement"),Rr=zt,Ir=dr,Cr=Xn,vr=Gn,yr=gr,Ar=Tt,Or=pn("IE_PROTO"),Nr=function(){},br=function(e){return "<script>"+e+"</"+"script>"},wr=function(e){e.write(br("")),e.close();var t=e.parentWindow.Object;return e=null,t},Dr=function(){try{Tr=new ActiveXObject("htmlfile");}catch(e){}var e,t;Dr="undefined"!=typeof document?document.domain&&Tr?wr(Tr):((t=Ar("iframe")).style.display="none",yr.appendChild(t),t.src=String("javascript:"),(e=t.contentWindow.document).open(),e.write(br("document.F=Object")),e.close(),e.F):wr(Tr);for(var i=Cr.length;i--;)delete Dr.prototype[Cr[i]];return Dr()};vr[Or]=!0;var Pr=Object.create||function(e,t){var i;return null!==e?(Nr.prototype=Rr(e),i=new Nr,Nr.prototype=null,i[Or]=e):i=Dr(),void 0===t?i:Ir.f(i,t)},Lr=d("".replace),kr=String(Error("zxcasd").stack),Mr=/\n\s*at [^:]*:[^\n]*/,Ur=Mr.test(kr),xr=q,Vr=ui,jr={},Fr=jr,Br=rt("iterator"),Gr=Array.prototype,Wr={};Wr[rt("toStringTag")]="z";var Hr="[object z]"===String(Wr),Kr=h,Yr=Hr,qr=S,Jr=k,Xr=rt("toStringTag"),zr=Kr.Object,Qr="Arguments"==Jr(function(){return arguments}()),Zr=Yr?Jr:function(e){var t,i,n;return void 0===e?"Undefined":null===e?"Null":"string"==typeof(i=function(e,t){try{return e[t]}catch(e){}}(t=zr(e),Xr))?i:Qr?Jr(t):"Object"==(n=Jr(t))&&qr(t.callee)?"Arguments":n},$r=Zr,eo=ye,to=jr,io=rt("iterator"),no=function(e){if(null!=e)return eo(e,io)||eo(e,"@@iterator")||to[$r(e)]},ro=C,oo=Ce,so=zt,ao=Te,co=no,uo=h.TypeError,lo=C,ho=zt,po=ye,_o=Wt,Eo=C,mo=zt,fo=Te,So=function(e){return void 0!==e&&(Fr.Array===e||Gr[Br]===e)},To=bi,go=u,Ro=function(e,t){var i=arguments.length<2?co(e):t;if(oo(i))return so(ro(i,e));throw uo(ao(e)+" is not iterable")},Io=no,Co=function(e,t,i){var n,r;ho(e);try{if(!(n=po(e,"return"))){if("throw"===t)throw i;return i}n=lo(n,e);}catch(e){r=!0,n=e;}if("throw"===t)throw i;if(r)throw n;return ho(n),i},vo=h.TypeError,yo=function(e,t){this.stopped=e,this.result=t;},Ao=yo.prototype,Oo=function(e,t,i){var n,r,o,s,a,c,d,u=i&&i.that,l=!(!i||!i.AS_ENTRIES),h=!(!i||!i.IS_ITERATOR),p=!(!i||!i.INTERRUPTED),_=_o(t,u),E=function(e){return n&&Co(n,"normal",e),new yo(!0,e)},m=function(e){return l?(mo(e),p?_(e[0],e[1],E):_(e[0],e[1])):p?_(e,E):_(e)};if(h)n=e;else {if(!(r=Io(e)))throw vo(fo(e)+" is not iterable");if(So(r)){for(o=0,s=To(e);s>o;o++)if((a=m(e[o]))&&go(Ao,a))return a;return new yo(!1)}n=Ro(e,r);}for(c=n.next;!(d=Eo(c,n)).done;){try{a=m(d.value);}catch(e){Co(n,"throw",e);}if("object"==typeof a&&a&&go(Ao,a))return a}return new yo(!1)},No=Zr,bo=h.String,wo=function(e){if("Symbol"===No(e))throw TypeError("Cannot convert a Symbol value to a string");return bo(e)},Do=wo,Po=w,Lo=!i((function(){var e=Error("a");return !("stack"in e)||(Object.defineProperty(e,"stack",Po(1,7)),7!==e.stack)})),ko=Ii,Mo=h,Uo=u,xo=Cn,Vo=Dn,jo=function(e,t,i){for(var n=sr(t),r=cr.f,o=ar.f,s=0;s<n.length;s++){var a=n[s];or(e,a)||i&&or(i,a)||r(e,a,o(t,a));}},Fo=Pr,Bo=ui,Go=w,Wo=function(e,t){if(Ur&&"string"==typeof e)for(;t--;)e=Lr(e,Mr,"");return e},Ho=function(e,t){xr(t)&&"cause"in t&&Vr(e,"cause",t.cause);},Ko=Oo,Yo=function(e,t){return void 0===e?arguments.length<2?"":t:Do(e)},qo=Lo,Jo=rt("toStringTag"),Xo=Mo.Error,zo=[].push,Qo=function(e,t){var i,n=arguments.length>2?arguments[2]:void 0,r=Uo(Zo,this);Vo?i=Vo(new Xo,r?xo(this):Zo):(i=r?this:Fo(Zo),Bo(i,Jo,"Error")),void 0!==t&&Bo(i,"message",Yo(t)),qo&&Bo(i,"stack",Wo(i.stack,1)),Ho(i,n);var o=[];return Ko(e,zo,{that:o}),Bo(i,"errors",o),i};Vo?Vo(Qo,Xo):jo(Qo,Xo,{name:!0});var Zo=Qo.prototype=Fo(Xo.prototype,{constructor:Go(1,Qo),message:Go(1,""),name:Go(1,"AggregateError")});ko({global:!0},{AggregateError:Qo});var $o=S,es=Me,ts=d(Function.toString);$o(es.inspectSource)||(es.inspectSource=function(e){return ts(e)});var is,ns,rs,os=es.inspectSource,ss=S,as=os,cs=h.WeakMap,ds=ss(cs)&&/native code/.test(as(cs)),us=h,ls=d,hs=q,ps=ui,_s=Ge,Es=Me,ms=pn,fs=Gn,Ss="Object already initialized",Ts=us.TypeError,gs=us.WeakMap;if(ds||Es.state){var Rs=Es.state||(Es.state=new gs),Is=ls(Rs.get),Cs=ls(Rs.has),vs=ls(Rs.set);is=function(e,t){if(Cs(Rs,e))throw new Ts(Ss);return t.facade=e,vs(Rs,e,t),t},ns=function(e){return Is(Rs,e)||{}},rs=function(e){return Cs(Rs,e)};}else {var ys=ms("state");fs[ys]=!0,is=function(e,t){if(_s(e,ys))throw new Ts(Ss);return t.facade=e,ps(e,ys,t),t},ns=function(e){return _s(e,ys)?e[ys]:{}},rs=function(e){return _s(e,ys)};}var As,Os,Ns,bs={set:is,get:ns,has:rs,enforce:function(e){return rs(e)?ns(e):is(e,{})},getterFor:function(e){return function(t){var i;if(!hs(t)||(i=ns(t)).type!==e)throw Ts("Incompatible receiver, "+e+" required");return i}}},ws=g,Ds=Ge,Ps=Function.prototype,Ls=ws&&Object.getOwnPropertyDescriptor,ks=Ds(Ps,"name"),Ms={EXISTS:ks,PROPER:ks&&"something"===function(){}.name,CONFIGURABLE:ks&&(!ws||ws&&Ls(Ps,"name").configurable)},Us=ui,xs=function(e,t,i,n){n&&n.enumerable?e[t]=i:Us(e,t,i);},Vs=i,js=S,Fs=Pr,Bs=Cn,Gs=xs,Ws=rt("iterator"),Hs=!1;[].keys&&("next"in(Ns=[].keys())?(Os=Bs(Bs(Ns)))!==Object.prototype&&(As=Os):Hs=!0);var Ks=null==As||Vs((function(){var e={};return As[Ws].call(e)!==e}));js((As=Ks?{}:Fs(As))[Ws])||Gs(As,Ws,(function(){return this}));var Ys={IteratorPrototype:As,BUGGY_SAFARI_ITERATORS:Hs},qs=Zr,Js=Hr?{}.toString:function(){return "[object "+qs(this)+"]"},Xs=Hr,zs=Ht.f,Qs=ui,Zs=Ge,$s=Js,ea=rt("toStringTag"),ta=function(e,t,i,n){if(e){var r=i?e:e.prototype;Zs(r,ea)||zs(r,ea,{configurable:!0,value:t}),n&&!Xs&&Qs(r,"toString",$s);}},ia=Ys.IteratorPrototype,na=Pr,ra=w,oa=ta,sa=jr,aa=function(){return this},ca=Ii,da=C,ua=function(e,t,i,n){var r=t+" Iterator";return e.prototype=na(ia,{next:ra(+!n,i)}),oa(e,r,!1,!0),sa[r]=aa,e},la=Cn,ha=ta,pa=xs,_a=jr,Ea=Ms.PROPER,ma=Ys.BUGGY_SAFARI_ITERATORS,fa=rt("iterator"),Sa="keys",Ta="values",ga="entries",Ra=function(){return this},Ia=function(e,t,i,n,r,o,s){ua(i,t,n);var a,c,d,u=function(e){if(e===r&&E)return E;if(!ma&&e in p)return p[e];switch(e){case Sa:case Ta:case ga:return function(){return new i(this,e)}}return function(){return new i(this)}},l=t+" Iterator",h=!1,p=e.prototype,_=p[fa]||p["@@iterator"]||r&&p[r],E=!ma&&_||u(r),m="Array"==t&&p.entries||_;if(m&&(a=la(m.call(new e)))!==Object.prototype&&a.next&&(ha(a,l,!0,!0),_a[l]=Ra),Ea&&r==Ta&&_&&_.name!==Ta&&(h=!0,E=function(){return da(_,this)}),r)if(c={values:u(Ta),keys:o?E:u(Sa),entries:u(ga)},s)for(d in c)(ma||h||!(d in p))&&pa(p,d,c[d]);else ca({target:t,proto:!0,forced:ma||h},c);return s&&p[fa]!==E&&pa(p,fa,E,{name:r}),_a[t]=E,c},Ca=K,va=jr,ya=bs;Ht.f;var Aa=Ia,Oa="Array Iterator",Na=ya.set,ba=ya.getterFor(Oa);Aa(Array,"Array",(function(e,t){Na(this,{type:Oa,target:Ca(e),index:0,kind:t});}),(function(){var e=ba(this),t=e.target,i=e.kind,n=e.index++;return !t||n>=t.length?(e.target=void 0,{value:void 0,done:!0}):"keys"==i?{value:n,done:!1}:"values"==i?{value:t[n],done:!1}:{value:[n,t[n]],done:!1}}),"values"),va.Arguments=va.Array;var wa=h.Promise,Da=xs,Pa=$,La=Ht,ka=g,Ma=rt("species"),Ua=u,xa=h.TypeError,Va=rt("iterator"),ja=!1;try{var Fa=0,Ba={next:function(){return {done:!!Fa++}},return:function(){ja=!0;}};Ba[Va]=function(){return this},Array.from(Ba,(function(){throw 2}));}catch(e){}var Ga=d,Wa=i,Ha=S,Ka=Zr,Ya=os,qa=function(){},Ja=[],Xa=$("Reflect","construct"),za=/^\s*(?:class|function)\b/,Qa=Ga(za.exec),Za=!za.exec(qa),$a=function(e){if(!Ha(e))return !1;try{return Xa(qa,Ja,e),!0}catch(e){return !1}},ec=function(e){if(!Ha(e))return !1;switch(Ka(e)){case"AsyncFunction":case"GeneratorFunction":case"AsyncGeneratorFunction":return !1}try{return Za||!!Qa(za,Ya(e))}catch(e){return !0}};ec.sham=!0;var tc,ic,nc,rc,oc=!Xa||Wa((function(){var e;return $a($a.call)||!$a(Object)||!$a((function(){e=!0;}))||e}))?ec:$a,sc=oc,ac=Te,cc=h.TypeError,dc=zt,uc=function(e){if(sc(e))return e;throw cc(ac(e)+" is not a constructor")},lc=rt("species"),hc=function(e,t){var i,n=dc(e).constructor;return void 0===n||null==(i=dc(n)[lc])?t:uc(i)},pc=d([].slice),_c=/(?:ipad|iphone|ipod).*applewebkit/i.test(ee),Ec=h,mc=f,fc=Wt,Sc=S,Tc=Ge,gc=i,Rc=gr,Ic=pc,Cc=Tt,vc=_c,yc=ji,Ac=Ec.setImmediate,Oc=Ec.clearImmediate,Nc=Ec.process,bc=Ec.Dispatch,wc=Ec.Function,Dc=Ec.MessageChannel,Pc=Ec.String,Lc=0,kc={},Mc="onreadystatechange";try{tc=Ec.location;}catch(e){}var Uc=function(e){if(Tc(kc,e)){var t=kc[e];delete kc[e],t();}},xc=function(e){return function(){Uc(e);}},Vc=function(e){Uc(e.data);},jc=function(e){Ec.postMessage(Pc(e),tc.protocol+"//"+tc.host);};Ac&&Oc||(Ac=function(e){var t=Ic(arguments,1);return kc[++Lc]=function(){mc(Sc(e)?e:wc(e),void 0,t);},ic(Lc),Lc},Oc=function(e){delete kc[e];},yc?ic=function(e){Nc.nextTick(xc(e));}:bc&&bc.now?ic=function(e){bc.now(xc(e));}:Dc&&!vc?(rc=(nc=new Dc).port2,nc.port1.onmessage=Vc,ic=fc(rc.postMessage,rc)):Ec.addEventListener&&Sc(Ec.postMessage)&&!Ec.importScripts&&tc&&"file:"!==tc.protocol&&!gc(jc)?(ic=jc,Ec.addEventListener("message",Vc,!1)):ic=Mc in Cc("script")?function(e){Rc.appendChild(Cc("script")).onreadystatechange=function(){Rc.removeChild(this),Uc(e);};}:function(e){setTimeout(xc(e),0);});var Fc,Bc,Gc,Wc,Hc,Kc,Yc,qc,Jc={set:Ac,clear:Oc},Xc=h,zc=/ipad|iphone|ipod/i.test(ee)&&void 0!==Xc.Pebble,Qc=/web0s(?!.*chrome)/i.test(ee),Zc=h,$c=Wt,ed=T.f,td=Jc.set,id=_c,nd=zc,rd=Qc,od=ji,sd=Zc.MutationObserver||Zc.WebKitMutationObserver,ad=Zc.document,cd=Zc.process,dd=Zc.Promise,ud=ed(Zc,"queueMicrotask"),ld=ud&&ud.value;ld||(Fc=function(){var e,t;for(od&&(e=cd.domain)&&e.exit();Bc;){t=Bc.fn,Bc=Bc.next;try{t();}catch(e){throw Bc?Wc():Gc=void 0,e}}Gc=void 0,e&&e.enter();},id||od||rd||!sd||!ad?!nd&&dd&&dd.resolve?((Yc=dd.resolve(void 0)).constructor=dd,qc=$c(Yc.then,Yc),Wc=function(){qc(Fc);}):od?Wc=function(){cd.nextTick(Fc);}:(td=$c(td,Zc),Wc=function(){td(Fc);}):(Hc=!0,Kc=ad.createTextNode(""),new sd(Fc).observe(Kc,{characterData:!0}),Wc=function(){Kc.data=Hc=!Hc;}));var hd=ld||function(e){var t={fn:e,next:void 0};Gc&&(Gc.next=t),Bc||(Bc=t,Wc()),Gc=t;},pd={},_d=Ce,Ed=function(e){var t,i;this.promise=new e((function(e,n){if(void 0!==t||void 0!==i)throw TypeError("Bad Promise constructor");t=e,i=n;})),this.resolve=_d(t),this.reject=_d(i);};pd.f=function(e){return new Ed(e)};var md=zt,fd=q,Sd=pd,Td=function(e,t){if(md(e),fd(t)&&t.constructor===e)return t;var i=Sd.f(e);return (0, i.resolve)(t),i.promise},gd=h,Rd=function(e){try{return {error:!1,value:e()}}catch(e){return {error:!0,value:e}}},Id=function(){this.head=null,this.tail=null;};Id.prototype={add:function(e){var t={item:e,next:null};this.head?this.tail.next=t:this.head=t,this.tail=t;},get:function(){var e=this.head;if(e)return this.head=e.next,this.tail===e&&(this.tail=null),e.item}};var Cd,vd,yd,Ad="object"==typeof window,Od=Ii,Nd=h,bd=$,wd=C,Dd=wa,Pd=function(e,t,i){for(var n in t)i&&i.unsafe&&e[n]?e[n]=t[n]:Da(e,n,t[n],i);return e},Ld=ta,kd=function(e){var t=Pa(e),i=La.f;ka&&t&&!t[Ma]&&i(t,Ma,{configurable:!0,get:function(){return this}});},Md=Ce,Ud=S,xd=q,Vd=function(e,t){if(Ua(t,e))return e;throw xa("Incorrect invocation")},jd=os,Fd=Oo,Bd=function(e,t){if(!t&&!ja)return !1;var i=!1;try{var n={};n[Va]=function(){return {next:function(){return {done:i=!0}}}},e(n);}catch(e){}return i},Gd=hc,Wd=Jc.set,Hd=hd,Kd=Td,Yd=function(e,t){var i=gd.console;i&&i.error&&(1==arguments.length?i.error(e):i.error(e,t));},qd=pd,Jd=Rd,Xd=Id,zd=bs,Qd=jt,Zd=Ad,$d=ji,eu=ae,tu=rt("species"),iu="Promise",nu=zd.getterFor(iu),ru=zd.set,ou=zd.getterFor(iu),su=Dd&&Dd.prototype,au=Dd,cu=su,du=Nd.TypeError,uu=Nd.document,lu=Nd.process,hu=qd.f,pu=hu,_u=!!(uu&&uu.createEvent&&Nd.dispatchEvent),Eu=Ud(Nd.PromiseRejectionEvent),mu="unhandledrejection",fu=Qd(iu,(function(){var e=jd(au),t=e!==String(au);if(!t&&66===eu)return !0;if(!cu.finally)return !0;if(eu>=51&&/native code/.test(e))return !1;var i=new au((function(e){e(1);})),n=function(e){e((function(){}),(function(){}));};return (i.constructor={})[tu]=n,!(i.then((function(){}))instanceof n)||!t&&Zd&&!Eu})),Su=fu||!Bd((function(e){au.all(e).catch((function(){}));})),Tu=function(e){var t;return !(!xd(e)||!Ud(t=e.then))&&t},gu=function(e,t){var i,n,r,o=t.value,s=1==t.state,a=s?e.ok:e.fail,c=e.resolve,d=e.reject,u=e.domain;try{a?(s||(2===t.rejection&&yu(t),t.rejection=1),!0===a?i=o:(u&&u.enter(),i=a(o),u&&(u.exit(),r=!0)),i===e.promise?d(du("Promise-chain cycle")):(n=Tu(i))?wd(n,i,c,d):c(i)):d(o);}catch(e){u&&!r&&u.exit(),d(e);}},Ru=function(e,t){e.notified||(e.notified=!0,Hd((function(){for(var i,n=e.reactions;i=n.get();)gu(i,e);e.notified=!1,t&&!e.rejection&&Cu(e);})));},Iu=function(e,t,i){var n,r;_u?((n=uu.createEvent("Event")).promise=t,n.reason=i,n.initEvent(e,!1,!0),Nd.dispatchEvent(n)):n={promise:t,reason:i},!Eu&&(r=Nd["on"+e])?r(n):e===mu&&Yd("Unhandled promise rejection",i);},Cu=function(e){wd(Wd,Nd,(function(){var t,i=e.facade,n=e.value;if(vu(e)&&(t=Jd((function(){$d?lu.emit("unhandledRejection",n,i):Iu(mu,i,n);})),e.rejection=$d||vu(e)?2:1,t.error))throw t.value}));},vu=function(e){return 1!==e.rejection&&!e.parent},yu=function(e){wd(Wd,Nd,(function(){var t=e.facade;$d?lu.emit("rejectionHandled",t):Iu("rejectionhandled",t,e.value);}));},Au=function(e,t,i){return function(n){e(t,n,i);}},Ou=function(e,t,i){e.done||(e.done=!0,i&&(e=i),e.value=t,e.state=2,Ru(e,!0));},Nu=function(e,t,i){if(!e.done){e.done=!0,i&&(e=i);try{if(e.facade===t)throw du("Promise can't be resolved itself");var n=Tu(t);n?Hd((function(){var i={done:!1};try{wd(n,t,Au(Nu,i,e),Au(Ou,i,e));}catch(t){Ou(i,t,e);}})):(e.value=t,e.state=1,Ru(e,!1));}catch(t){Ou({done:!1},t,e);}}};fu&&(cu=(au=function(e){Vd(this,cu),Md(e),wd(Cd,this);var t=nu(this);try{e(Au(Nu,t),Au(Ou,t));}catch(e){Ou(t,e);}}).prototype,(Cd=function(e){ru(this,{type:iu,done:!1,notified:!1,parent:!1,reactions:new Xd,rejection:!1,state:0,value:void 0});}).prototype=Pd(cu,{then:function(e,t){var i=ou(this),n=hu(Gd(this,au));return i.parent=!0,n.ok=!Ud(e)||e,n.fail=Ud(t)&&t,n.domain=$d?lu.domain:void 0,0==i.state?i.reactions.add(n):Hd((function(){gu(n,i);})),n.promise},catch:function(e){return this.then(void 0,e)}}),vd=function(){var e=new Cd,t=nu(e);this.promise=e,this.resolve=Au(Nu,t),this.reject=Au(Ou,t);},qd.f=hu=function(e){return e===au||e===yd?new vd(e):pu(e)}),Od({global:!0,wrap:!0,forced:fu},{Promise:au}),Ld(au,iu,!1,!0),kd(iu),yd=bd(iu),Od({target:iu,stat:!0,forced:fu},{reject:function(e){var t=hu(this);return wd(t.reject,void 0,e),t.promise}}),Od({target:iu,stat:!0,forced:true},{resolve:function(e){return Kd(this===yd?au:this,e)}}),Od({target:iu,stat:!0,forced:Su},{all:function(e){var t=this,i=hu(t),n=i.resolve,r=i.reject,o=Jd((function(){var i=Md(t.resolve),o=[],s=0,a=1;Fd(e,(function(e){var c=s++,d=!1;a++,wd(i,t,e).then((function(e){d||(d=!0,o[c]=e,--a||n(o));}),r);})),--a||n(o);}));return o.error&&r(o.value),i.promise},race:function(e){var t=this,i=hu(t),n=i.reject,r=Jd((function(){var r=Md(t.resolve);Fd(e,(function(e){wd(r,t,e).then(i.resolve,n);}));}));return r.error&&n(r.value),i.promise}});var bu=C,wu=Ce,Du=pd,Pu=Rd,Lu=Oo;Ii({target:"Promise",stat:!0},{allSettled:function(e){var t=this,i=Du.f(t),n=i.resolve,r=i.reject,o=Pu((function(){var i=wu(t.resolve),r=[],o=0,s=1;Lu(e,(function(e){var a=o++,c=!1;s++,bu(i,t,e).then((function(e){c||(c=!0,r[a]={status:"fulfilled",value:e},--s||n(r));}),(function(e){c||(c=!0,r[a]={status:"rejected",reason:e},--s||n(r));}));})),--s||n(r);}));return o.error&&r(o.value),i.promise}});var ku=Ce,Mu=$,Uu=C,xu=pd,Vu=Rd,ju=Oo,Fu="No one promise resolved";Ii({target:"Promise",stat:!0},{any:function(e){var t=this,i=Mu("AggregateError"),n=xu.f(t),r=n.resolve,o=n.reject,s=Vu((function(){var n=ku(t.resolve),s=[],a=0,c=1,d=!1;ju(e,(function(e){var u=a++,l=!1;c++,Uu(n,t,e).then((function(e){l||d||(d=!0,r(e));}),(function(e){l||d||(l=!0,s[u]=e,--c||o(new i(s,Fu)));}));})),--c||o(new i(s,Fu));}));return s.error&&o(s.value),n.promise}});var Bu=wa,Gu=$,Wu=S,Hu=hc,Ku=Td;Ii({target:"Promise",proto:!0,real:!0,forced:!!Bu&&i((function(){Bu.prototype.finally.call({then:function(){}},(function(){}));}))},{finally:function(e){var t=Hu(this,Gu("Promise")),i=Wu(e);return this.then(i?function(i){return Ku(t,e()).then((function(){return i}))}:e,i?function(i){return Ku(t,e()).then((function(){throw i}))}:e)}});var Yu=d,qu=yi,Ju=wo,Xu=G,zu=Yu("".charAt),Qu=Yu("".charCodeAt),Zu=Yu("".slice),$u=function(e){return function(t,i){var n,r,o=Ju(Xu(t)),s=qu(i),a=o.length;return s<0||s>=a?e?"":void 0:(n=Qu(o,s))<55296||n>56319||s+1===a||(r=Qu(o,s+1))<56320||r>57343?e?zu(o,s):n:e?Zu(o,s,s+2):r-56320+(n-55296<<10)+65536}},el={codeAt:$u(!1),charAt:$u(!0)}.charAt,tl=wo,il=bs,nl=Ia,rl="String Iterator",ol=il.set,sl=il.getterFor(rl);nl(String,"String",(function(e){ol(this,{type:rl,string:tl(e),index:0});}),(function(){var e,t=sl(this),i=t.string,n=t.index;return n>=i.length?{value:void 0,done:!0}:(e=el(i,n),t.index+=e.length,{value:e,done:!1})}));var al=J.Promise,cl={CSSRuleList:0,CSSStyleDeclaration:0,CSSValueList:0,ClientRectList:0,DOMRectList:0,DOMStringList:0,DOMTokenList:1,DataTransferItemList:0,FileList:0,HTMLAllCollection:0,HTMLCollection:0,HTMLFormElement:0,HTMLSelectElement:0,MediaList:0,MimeTypeArray:0,NamedNodeMap:0,NodeList:1,PaintRequestList:0,Plugin:0,PluginArray:0,SVGLengthList:0,SVGNumberList:0,SVGPathSegList:0,SVGPointList:0,SVGStringList:0,SVGTransformList:0,SourceBufferList:0,StyleSheetList:0,TextTrackCueList:0,TextTrackList:0,TouchList:0},dl=h,ul=Zr,ll=ui,hl=jr,pl=rt("toStringTag");for(var _l in cl){var El=dl[_l],ml=El&&El.prototype;ml&&ul(ml)!==pl&&ll(ml,pl,_l),hl[_l]=hl.Array;}var fl=al,Sl=fl;const Tl=rn;function gl(e,t){const i=e&&e.navigator;if(!i.mediaDevices)return;const n=function(e){if("object"!=typeof e||e.mandatory||e.optional)return e;const t={};return Object.keys(e).forEach(i=>{if("require"===i||"advanced"===i||"mediaSource"===i)return;const n="object"==typeof e[i]?e[i]:{ideal:e[i]};void 0!==n.exact&&"number"==typeof n.exact&&(n.min=n.max=n.exact);const r=function(e,t){return e?e+t.charAt(0).toUpperCase()+t.slice(1):"deviceId"===t?"sourceId":t};if(void 0!==n.ideal){t.optional=t.optional||[];let e={};"number"==typeof n.ideal?(e[r("min",i)]=n.ideal,t.optional.push(e),e={},e[r("max",i)]=n.ideal,t.optional.push(e)):(e[r("",i)]=n.ideal,t.optional.push(e));}void 0!==n.exact&&"number"!=typeof n.exact?(t.mandatory=t.mandatory||{},t.mandatory[r("",i)]=n.exact):["min","max"].forEach(e=>{void 0!==n[e]&&(t.mandatory=t.mandatory||{},t.mandatory[r(e,i)]=n[e]);});}),e.advanced&&(t.optional=(t.optional||[]).concat(e.advanced)),t},r=function(e,r){if(t.version>=61)return r(e);if((e=JSON.parse(JSON.stringify(e)))&&"object"==typeof e.audio){const t=function(e,t,i){t in e&&!(i in e)&&(e[i]=e[t],delete e[t]);};t((e=JSON.parse(JSON.stringify(e))).audio,"autoGainControl","googAutoGainControl"),t(e.audio,"noiseSuppression","googNoiseSuppression"),e.audio=n(e.audio);}if(e&&"object"==typeof e.video){let o=e.video.facingMode;o=o&&("object"==typeof o?o:{ideal:o});const s=t.version<66;if(o&&("user"===o.exact||"environment"===o.exact||"user"===o.ideal||"environment"===o.ideal)&&(!i.mediaDevices.getSupportedConstraints||!i.mediaDevices.getSupportedConstraints().facingMode||s)){let t;if(delete e.video.facingMode,"environment"===o.exact||"environment"===o.ideal?t=["back","rear"]:"user"!==o.exact&&"user"!==o.ideal||(t=["front"]),t)return i.mediaDevices.enumerateDevices().then(i=>{let s=(i=i.filter(e=>"videoinput"===e.kind)).find(e=>t.some(t=>e.label.toLowerCase().includes(t)));return !s&&i.length&&t.includes("back")&&(s=i[i.length-1]),s&&(e.video.deviceId=o.exact?{exact:s.deviceId}:{ideal:s.deviceId}),e.video=n(e.video),Tl("chrome: "+JSON.stringify(e)),r(e)})}e.video=n(e.video);}return Tl("chrome: "+JSON.stringify(e)),r(e)},o=function(e){return t.version>=64?e:{name:{PermissionDeniedError:"NotAllowedError",PermissionDismissedError:"NotAllowedError",InvalidStateError:"NotAllowedError",DevicesNotFoundError:"NotFoundError",ConstraintNotSatisfiedError:"OverconstrainedError",TrackStartError:"NotReadableError",MediaDeviceFailedDueToShutdown:"NotAllowedError",MediaDeviceKillSwitchOn:"NotAllowedError",TabCaptureError:"AbortError",ScreenCaptureError:"AbortError",DeviceCaptureError:"AbortError"}[e.name]||e.name,message:e.message,constraint:e.constraint||e.constraintName,toString(){return this.name+(this.message&&": ")+this.message}}};if(i.getUserMedia=function(e,t,n){r(e,e=>{i.webkitGetUserMedia(e,t,e=>{n&&n(o(e));});});}.bind(i),i.mediaDevices.getUserMedia){const e=i.mediaDevices.getUserMedia.bind(i.mediaDevices);i.mediaDevices.getUserMedia=function(t){return r(t,t=>e(t).then(e=>{if(t.audio&&!e.getAudioTracks().length||t.video&&!e.getVideoTracks().length)throw e.getTracks().forEach(e=>{e.stop();}),new DOMException("","NotFoundError");return e},e=>Sl.reject(o(e))))};}}function Rl(e){e.MediaStream=e.MediaStream||e.webkitMediaStream;}function Il(e){if("object"==typeof e&&e.RTCPeerConnection&&!("ontrack"in e.RTCPeerConnection.prototype)){Object.defineProperty(e.RTCPeerConnection.prototype,"ontrack",{get(){return this._ontrack},set(e){this._ontrack&&this.removeEventListener("track",this._ontrack),this.addEventListener("track",this._ontrack=e);},enumerable:!0,configurable:!0});const t=e.RTCPeerConnection.prototype.setRemoteDescription;e.RTCPeerConnection.prototype.setRemoteDescription=function(){return this._ontrackpoly||(this._ontrackpoly=t=>{t.stream.addEventListener("addtrack",i=>{let n;n=e.RTCPeerConnection.prototype.getReceivers?this.getReceivers().find(e=>e.track&&e.track.id===i.track.id):{track:i.track};const r=new Event("track");r.track=i.track,r.receiver=n,r.transceiver={receiver:n},r.streams=[t.stream],this.dispatchEvent(r);}),t.stream.getTracks().forEach(i=>{let n;n=e.RTCPeerConnection.prototype.getReceivers?this.getReceivers().find(e=>e.track&&e.track.id===i.id):{track:i};const r=new Event("track");r.track=i,r.receiver=n,r.transceiver={receiver:n},r.streams=[t.stream],this.dispatchEvent(r);});},this.addEventListener("addstream",this._ontrackpoly)),t.apply(this,arguments)};}else en(e,"track",e=>(e.transceiver||Object.defineProperty(e,"transceiver",{value:{receiver:e.receiver}}),e));}function Cl(e){if("object"==typeof e&&e.RTCPeerConnection&&!("getSenders"in e.RTCPeerConnection.prototype)&&"createDTMFSender"in e.RTCPeerConnection.prototype){const t=function(e,t){return {track:t,get dtmf(){return void 0===this._dtmf&&("audio"===t.kind?this._dtmf=e.createDTMFSender(t):this._dtmf=null),this._dtmf},_pc:e}};if(!e.RTCPeerConnection.prototype.getSenders){e.RTCPeerConnection.prototype.getSenders=function(){return this._senders=this._senders||[],this._senders.slice()};const i=e.RTCPeerConnection.prototype.addTrack;e.RTCPeerConnection.prototype.addTrack=function(e,n){let r=i.apply(this,arguments);return r||(r=t(this,e),this._senders.push(r)),r};const n=e.RTCPeerConnection.prototype.removeTrack;e.RTCPeerConnection.prototype.removeTrack=function(e){n.apply(this,arguments);const t=this._senders.indexOf(e);-1!==t&&this._senders.splice(t,1);};}const i=e.RTCPeerConnection.prototype.addStream;e.RTCPeerConnection.prototype.addStream=function(e){this._senders=this._senders||[],i.apply(this,[e]),e.getTracks().forEach(e=>{this._senders.push(t(this,e));});};const n=e.RTCPeerConnection.prototype.removeStream;e.RTCPeerConnection.prototype.removeStream=function(e){this._senders=this._senders||[],n.apply(this,[e]),e.getTracks().forEach(e=>{const t=this._senders.find(t=>t.track===e);t&&this._senders.splice(this._senders.indexOf(t),1);});};}else if("object"==typeof e&&e.RTCPeerConnection&&"getSenders"in e.RTCPeerConnection.prototype&&"createDTMFSender"in e.RTCPeerConnection.prototype&&e.RTCRtpSender&&!("dtmf"in e.RTCRtpSender.prototype)){const t=e.RTCPeerConnection.prototype.getSenders;e.RTCPeerConnection.prototype.getSenders=function(){const e=t.apply(this,[]);return e.forEach(e=>e._pc=this),e},Object.defineProperty(e.RTCRtpSender.prototype,"dtmf",{get(){return void 0===this._dtmf&&("audio"===this.track.kind?this._dtmf=this._pc.createDTMFSender(this.track):this._dtmf=null),this._dtmf}});}}function vl(e){if(!e.RTCPeerConnection)return;const t=e.RTCPeerConnection.prototype.getStats;e.RTCPeerConnection.prototype.getStats=function(){const[e,i,n]=arguments;if(arguments.length>0&&"function"==typeof e)return t.apply(this,arguments);if(0===t.length&&(0===arguments.length||"function"!=typeof e))return t.apply(this,[]);const r=function(e){const t={};return e.result().forEach(e=>{const i={id:e.id,timestamp:e.timestamp,type:{localcandidate:"local-candidate",remotecandidate:"remote-candidate"}[e.type]||e.type};e.names().forEach(t=>{i[t]=e.stat(t);}),t[i.id]=i;}),t},o=function(e){return new Map(Object.keys(e).map(t=>[t,e[t]]))};if(arguments.length>=2){const n=function(e){i(o(r(e)));};return t.apply(this,[n,e])}return new Sl((e,i)=>{t.apply(this,[function(t){e(o(r(t)));},i]);}).then(i,n)};}function yl(e){if(!("object"==typeof e&&e.RTCPeerConnection&&e.RTCRtpSender&&e.RTCRtpReceiver))return;if(!("getStats"in e.RTCRtpSender.prototype)){const t=e.RTCPeerConnection.prototype.getSenders;t&&(e.RTCPeerConnection.prototype.getSenders=function(){const e=t.apply(this,[]);return e.forEach(e=>e._pc=this),e});const i=e.RTCPeerConnection.prototype.addTrack;i&&(e.RTCPeerConnection.prototype.addTrack=function(){const e=i.apply(this,arguments);return e._pc=this,e}),e.RTCRtpSender.prototype.getStats=function(){const e=this;return this._pc.getStats().then(t=>dn(t,e.track,!0))};}if(!("getStats"in e.RTCRtpReceiver.prototype)){const t=e.RTCPeerConnection.prototype.getReceivers;t&&(e.RTCPeerConnection.prototype.getReceivers=function(){const e=t.apply(this,[]);return e.forEach(e=>e._pc=this),e}),en(e,"track",e=>(e.receiver._pc=e.srcElement,e)),e.RTCRtpReceiver.prototype.getStats=function(){const e=this;return this._pc.getStats().then(t=>dn(t,e.track,!1))};}if(!("getStats"in e.RTCRtpSender.prototype)||!("getStats"in e.RTCRtpReceiver.prototype))return;const t=e.RTCPeerConnection.prototype.getStats;e.RTCPeerConnection.prototype.getStats=function(){if(arguments.length>0&&arguments[0]instanceof e.MediaStreamTrack){const e=arguments[0];let t,i,n;return this.getSenders().forEach(i=>{i.track===e&&(t?n=!0:t=i);}),this.getReceivers().forEach(t=>(t.track===e&&(i?n=!0:i=t),t.track===e)),n||t&&i?Sl.reject(new DOMException("There are more than one sender or receiver for the track.","InvalidAccessError")):t?t.getStats():i?i.getStats():Sl.reject(new DOMException("There is no sender or receiver for the track.","InvalidAccessError"))}return t.apply(this,arguments)};}function Al(e){e.RTCPeerConnection.prototype.getLocalStreams=function(){return this._shimmedLocalStreams=this._shimmedLocalStreams||{},Object.keys(this._shimmedLocalStreams).map(e=>this._shimmedLocalStreams[e][0])};const t=e.RTCPeerConnection.prototype.addTrack;e.RTCPeerConnection.prototype.addTrack=function(e,i){if(!i)return t.apply(this,arguments);this._shimmedLocalStreams=this._shimmedLocalStreams||{};const n=t.apply(this,arguments);return this._shimmedLocalStreams[i.id]?-1===this._shimmedLocalStreams[i.id].indexOf(n)&&this._shimmedLocalStreams[i.id].push(n):this._shimmedLocalStreams[i.id]=[i,n],n};const i=e.RTCPeerConnection.prototype.addStream;e.RTCPeerConnection.prototype.addStream=function(e){this._shimmedLocalStreams=this._shimmedLocalStreams||{},e.getTracks().forEach(e=>{if(this.getSenders().find(t=>t.track===e))throw new DOMException("Track already exists.","InvalidAccessError")});const t=this.getSenders();i.apply(this,arguments);const n=this.getSenders().filter(e=>-1===t.indexOf(e));this._shimmedLocalStreams[e.id]=[e].concat(n);};const n=e.RTCPeerConnection.prototype.removeStream;e.RTCPeerConnection.prototype.removeStream=function(e){return this._shimmedLocalStreams=this._shimmedLocalStreams||{},delete this._shimmedLocalStreams[e.id],n.apply(this,arguments)};const r=e.RTCPeerConnection.prototype.removeTrack;e.RTCPeerConnection.prototype.removeTrack=function(e){return this._shimmedLocalStreams=this._shimmedLocalStreams||{},e&&Object.keys(this._shimmedLocalStreams).forEach(t=>{const i=this._shimmedLocalStreams[t].indexOf(e);-1!==i&&this._shimmedLocalStreams[t].splice(i,1),1===this._shimmedLocalStreams[t].length&&delete this._shimmedLocalStreams[t];}),r.apply(this,arguments)};}function Ol(e,t){if(!e.RTCPeerConnection)return;if(e.RTCPeerConnection.prototype.addTrack&&t.version>=65)return Al(e);const i=e.RTCPeerConnection.prototype.getLocalStreams;e.RTCPeerConnection.prototype.getLocalStreams=function(){const e=i.apply(this);return this._reverseStreams=this._reverseStreams||{},e.map(e=>this._reverseStreams[e.id])};const n=e.RTCPeerConnection.prototype.addStream;e.RTCPeerConnection.prototype.addStream=function(t){if(this._streams=this._streams||{},this._reverseStreams=this._reverseStreams||{},t.getTracks().forEach(e=>{if(this.getSenders().find(t=>t.track===e))throw new DOMException("Track already exists.","InvalidAccessError")}),!this._reverseStreams[t.id]){const i=new e.MediaStream(t.getTracks());this._streams[t.id]=i,this._reverseStreams[i.id]=t,t=i;}n.apply(this,[t]);};const r=e.RTCPeerConnection.prototype.removeStream;function o(e,t){let i=t.sdp;return Object.keys(e._reverseStreams||[]).forEach(t=>{const n=e._reverseStreams[t],r=e._streams[n.id];i=i.replace(new RegExp(r.id,"g"),n.id);}),new RTCSessionDescription({type:t.type,sdp:i})}function s(e,t){let i=t.sdp;return Object.keys(e._reverseStreams||[]).forEach(t=>{const n=e._reverseStreams[t],r=e._streams[n.id];i=i.replace(new RegExp(n.id,"g"),r.id);}),new RTCSessionDescription({type:t.type,sdp:i})}e.RTCPeerConnection.prototype.removeStream=function(e){this._streams=this._streams||{},this._reverseStreams=this._reverseStreams||{},r.apply(this,[this._streams[e.id]||e]),delete this._reverseStreams[this._streams[e.id]?this._streams[e.id].id:e.id],delete this._streams[e.id];},e.RTCPeerConnection.prototype.addTrack=function(t,i){if("closed"===this.signalingState)throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.","InvalidStateError");const n=[].slice.call(arguments,1);if(1!==n.length||!n[0].getTracks().find(e=>e===t))throw new DOMException("The adapter.js addTrack polyfill only supports a single  stream which is associated with the specified track.","NotSupportedError");const r=this.getSenders().find(e=>e.track===t);if(r)throw new DOMException("Track already exists.","InvalidAccessError");this._streams=this._streams||{},this._reverseStreams=this._reverseStreams||{};const o=this._streams[i.id];if(o)o.addTrack(t),Sl.resolve().then(()=>{this.dispatchEvent(new Event("negotiationneeded"));});else {const n=new e.MediaStream([t]);this._streams[i.id]=n,this._reverseStreams[n.id]=i,this.addStream(n);}return this.getSenders().find(e=>e.track===t)},["createOffer","createAnswer"].forEach((function(t){const i=e.RTCPeerConnection.prototype[t],n={[t](){const e=arguments;return arguments.length&&"function"==typeof arguments[0]?i.apply(this,[t=>{const i=o(this,t);e[0].apply(null,[i]);},t=>{e[1]&&e[1].apply(null,t);},arguments[2]]):i.apply(this,arguments).then(e=>o(this,e))}};e.RTCPeerConnection.prototype[t]=n[t];}));const a=e.RTCPeerConnection.prototype.setLocalDescription;e.RTCPeerConnection.prototype.setLocalDescription=function(){return arguments.length&&arguments[0].type?(arguments[0]=s(this,arguments[0]),a.apply(this,arguments)):a.apply(this,arguments)};const c=Object.getOwnPropertyDescriptor(e.RTCPeerConnection.prototype,"localDescription");Object.defineProperty(e.RTCPeerConnection.prototype,"localDescription",{get(){const e=c.get.apply(this);return ""===e.type?e:o(this,e)}}),e.RTCPeerConnection.prototype.removeTrack=function(e){if("closed"===this.signalingState)throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.","InvalidStateError");if(!e._pc)throw new DOMException("Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender.","TypeError");if(!(e._pc===this))throw new DOMException("Sender was not created by this connection.","InvalidAccessError");let t;this._streams=this._streams||{},Object.keys(this._streams).forEach(i=>{this._streams[i].getTracks().find(t=>e.track===t)&&(t=this._streams[i]);}),t&&(1===t.getTracks().length?this.removeStream(this._reverseStreams[t.id]):t.removeTrack(e.track),this.dispatchEvent(new Event("negotiationneeded")));};}function Nl(e,t){!e.RTCPeerConnection&&e.webkitRTCPeerConnection&&(e.RTCPeerConnection=e.webkitRTCPeerConnection),e.RTCPeerConnection&&t.version<53&&["setLocalDescription","setRemoteDescription","addIceCandidate"].forEach((function(t){const i=e.RTCPeerConnection.prototype[t],n={[t](){return arguments[0]=new("addIceCandidate"===t?e.RTCIceCandidate:e.RTCSessionDescription)(arguments[0]),i.apply(this,arguments)}};e.RTCPeerConnection.prototype[t]=n[t];}));}function bl(e,t){en(e,"negotiationneeded",e=>{const i=e.target;if(!(t.version<72||i.getConfiguration&&"plan-b"===i.getConfiguration().sdpSemantics)||"stable"===i.signalingState)return e});}var wl=Object.freeze({__proto__:null,shimMediaStream:Rl,shimOnTrack:Il,shimGetSendersWithDtmf:Cl,shimGetStats:vl,shimSenderReceiverGetStats:yl,shimAddTrackRemoveTrackWithNative:Al,shimAddTrackRemoveTrack:Ol,shimPeerConnection:Nl,fixNegotiationNeeded:bl,shimGetUserMedia:gl,shimGetDisplayMedia:function(e,t){e.navigator.mediaDevices&&"getDisplayMedia"in e.navigator.mediaDevices||e.navigator.mediaDevices&&("function"==typeof t?e.navigator.mediaDevices.getDisplayMedia=function(i){return t(i).then(t=>{const n=i.video&&i.video.width,r=i.video&&i.video.height,o=i.video&&i.video.frameRate;return i.video={mandatory:{chromeMediaSource:"desktop",chromeMediaSourceId:t,maxFrameRate:o||3}},n&&(i.video.mandatory.maxWidth=n),r&&(i.video.mandatory.maxHeight=r),e.navigator.mediaDevices.getUserMedia(i)})}:console.error("shimGetDisplayMedia: getSourceId argument is not a function"));}});function Dl(e,t){const i=e&&e.navigator,n=e&&e.MediaStreamTrack;if(i.getUserMedia=function(e,t,n){on("navigator.getUserMedia","navigator.mediaDevices.getUserMedia"),i.mediaDevices.getUserMedia(e).then(t,n);},!(t.version>55&&"autoGainControl"in i.mediaDevices.getSupportedConstraints())){const e=function(e,t,i){t in e&&!(i in e)&&(e[i]=e[t],delete e[t]);},t=i.mediaDevices.getUserMedia.bind(i.mediaDevices);if(i.mediaDevices.getUserMedia=function(i){return "object"==typeof i&&"object"==typeof i.audio&&(i=JSON.parse(JSON.stringify(i)),e(i.audio,"autoGainControl","mozAutoGainControl"),e(i.audio,"noiseSuppression","mozNoiseSuppression")),t(i)},n&&n.prototype.getSettings){const t=n.prototype.getSettings;n.prototype.getSettings=function(){const i=t.apply(this,arguments);return e(i,"mozAutoGainControl","autoGainControl"),e(i,"mozNoiseSuppression","noiseSuppression"),i};}if(n&&n.prototype.applyConstraints){const t=n.prototype.applyConstraints;n.prototype.applyConstraints=function(i){return "audio"===this.kind&&"object"==typeof i&&(i=JSON.parse(JSON.stringify(i)),e(i,"autoGainControl","mozAutoGainControl"),e(i,"noiseSuppression","mozNoiseSuppression")),t.apply(this,[i])};}}}function Pl(e){"object"==typeof e&&e.RTCTrackEvent&&"receiver"in e.RTCTrackEvent.prototype&&!("transceiver"in e.RTCTrackEvent.prototype)&&Object.defineProperty(e.RTCTrackEvent.prototype,"transceiver",{get(){return {receiver:this.receiver}}});}function Ll(e,t){if("object"!=typeof e||!e.RTCPeerConnection&&!e.mozRTCPeerConnection)return;!e.RTCPeerConnection&&e.mozRTCPeerConnection&&(e.RTCPeerConnection=e.mozRTCPeerConnection),t.version<53&&["setLocalDescription","setRemoteDescription","addIceCandidate"].forEach((function(t){const i=e.RTCPeerConnection.prototype[t],n={[t](){return arguments[0]=new("addIceCandidate"===t?e.RTCIceCandidate:e.RTCSessionDescription)(arguments[0]),i.apply(this,arguments)}};e.RTCPeerConnection.prototype[t]=n[t];}));const i={inboundrtp:"inbound-rtp",outboundrtp:"outbound-rtp",candidatepair:"candidate-pair",localcandidate:"local-candidate",remotecandidate:"remote-candidate"},n=e.RTCPeerConnection.prototype.getStats;e.RTCPeerConnection.prototype.getStats=function(){const[e,r,o]=arguments;return n.apply(this,[e||null]).then(e=>{if(t.version<53&&!r)try{e.forEach(e=>{e.type=i[e.type]||e.type;});}catch(t){if("TypeError"!==t.name)throw t;e.forEach((t,n)=>{e.set(n,Object.assign({},t,{type:i[t.type]||t.type}));});}return e}).then(r,o)};}function kl(e){if("object"!=typeof e||!e.RTCPeerConnection||!e.RTCRtpSender)return;if(e.RTCRtpSender&&"getStats"in e.RTCRtpSender.prototype)return;const t=e.RTCPeerConnection.prototype.getSenders;t&&(e.RTCPeerConnection.prototype.getSenders=function(){const e=t.apply(this,[]);return e.forEach(e=>e._pc=this),e});const i=e.RTCPeerConnection.prototype.addTrack;i&&(e.RTCPeerConnection.prototype.addTrack=function(){const e=i.apply(this,arguments);return e._pc=this,e}),e.RTCRtpSender.prototype.getStats=function(){return this.track?this._pc.getStats(this.track):Sl.resolve(new Map)};}function Ml(e){if("object"!=typeof e||!e.RTCPeerConnection||!e.RTCRtpSender)return;if(e.RTCRtpSender&&"getStats"in e.RTCRtpReceiver.prototype)return;const t=e.RTCPeerConnection.prototype.getReceivers;t&&(e.RTCPeerConnection.prototype.getReceivers=function(){const e=t.apply(this,[]);return e.forEach(e=>e._pc=this),e}),en(e,"track",e=>(e.receiver._pc=e.srcElement,e)),e.RTCRtpReceiver.prototype.getStats=function(){return this._pc.getStats(this.track)};}function Ul(e){e.RTCPeerConnection&&!("removeStream"in e.RTCPeerConnection.prototype)&&(e.RTCPeerConnection.prototype.removeStream=function(e){on("removeStream","removeTrack"),this.getSenders().forEach(t=>{t.track&&e.getTracks().includes(t.track)&&this.removeTrack(t);});});}function xl(e){e.DataChannel&&!e.RTCDataChannel&&(e.RTCDataChannel=e.DataChannel);}function Vl(e){if("object"!=typeof e||!e.RTCPeerConnection)return;const t=e.RTCPeerConnection.prototype.addTransceiver;t&&(e.RTCPeerConnection.prototype.addTransceiver=function(){this.setParametersPromises=[];let e=arguments[1]&&arguments[1].sendEncodings;void 0===e&&(e=[]),e=[...e];const i=e.length>0;i&&e.forEach(e=>{if("rid"in e){if(!/^[a-z0-9]{0,16}$/i.test(e.rid))throw new TypeError("Invalid RID value provided.")}if("scaleResolutionDownBy"in e&&!(parseFloat(e.scaleResolutionDownBy)>=1))throw new RangeError("scale_resolution_down_by must be >= 1.0");if("maxFramerate"in e&&!(parseFloat(e.maxFramerate)>=0))throw new RangeError("max_framerate must be >= 0.0")});const n=t.apply(this,arguments);if(i){const{sender:t}=n,i=t.getParameters();(!("encodings"in i)||1===i.encodings.length&&0===Object.keys(i.encodings[0]).length)&&(i.encodings=e,t.sendEncodings=e,this.setParametersPromises.push(t.setParameters(i).then(()=>{delete t.sendEncodings;}).catch(()=>{delete t.sendEncodings;})));}return n});}function jl(e){if("object"!=typeof e||!e.RTCRtpSender)return;const t=e.RTCRtpSender.prototype.getParameters;t&&(e.RTCRtpSender.prototype.getParameters=function(){const e=t.apply(this,arguments);return "encodings"in e||(e.encodings=[].concat(this.sendEncodings||[{}])),e});}function Fl(e){if("object"!=typeof e||!e.RTCPeerConnection)return;const t=e.RTCPeerConnection.prototype.createOffer;e.RTCPeerConnection.prototype.createOffer=function(){return this.setParametersPromises&&this.setParametersPromises.length?Sl.all(this.setParametersPromises).then(()=>t.apply(this,arguments)).finally(()=>{this.setParametersPromises=[];}):t.apply(this,arguments)};}function Bl(e){if("object"!=typeof e||!e.RTCPeerConnection)return;const t=e.RTCPeerConnection.prototype.createAnswer;e.RTCPeerConnection.prototype.createAnswer=function(){return this.setParametersPromises&&this.setParametersPromises.length?Sl.all(this.setParametersPromises).then(()=>t.apply(this,arguments)).finally(()=>{this.setParametersPromises=[];}):t.apply(this,arguments)};}var Gl=Object.freeze({__proto__:null,shimOnTrack:Pl,shimPeerConnection:Ll,shimSenderGetStats:kl,shimReceiverGetStats:Ml,shimRemoveStream:Ul,shimRTCDataChannel:xl,shimAddTransceiver:Vl,shimGetParameters:jl,shimCreateOffer:Fl,shimCreateAnswer:Bl,shimGetUserMedia:Dl,shimGetDisplayMedia:function(e,t){e.navigator.mediaDevices&&"getDisplayMedia"in e.navigator.mediaDevices||e.navigator.mediaDevices&&(e.navigator.mediaDevices.getDisplayMedia=function(i){if(!i||!i.video){const e=new DOMException("getDisplayMedia without video constraints is undefined");return e.name="NotFoundError",e.code=8,Sl.reject(e)}return !0===i.video?i.video={mediaSource:t}:i.video.mediaSource=t,e.navigator.mediaDevices.getUserMedia(i)});}});function Wl(e){if("object"==typeof e&&e.RTCPeerConnection){if("getLocalStreams"in e.RTCPeerConnection.prototype||(e.RTCPeerConnection.prototype.getLocalStreams=function(){return this._localStreams||(this._localStreams=[]),this._localStreams}),!("addStream"in e.RTCPeerConnection.prototype)){const t=e.RTCPeerConnection.prototype.addTrack;e.RTCPeerConnection.prototype.addStream=function(e){this._localStreams||(this._localStreams=[]),this._localStreams.includes(e)||this._localStreams.push(e),e.getAudioTracks().forEach(i=>t.call(this,i,e)),e.getVideoTracks().forEach(i=>t.call(this,i,e));},e.RTCPeerConnection.prototype.addTrack=function(e){for(var i=arguments.length,n=new Array(i>1?i-1:0),r=1;r<i;r++)n[r-1]=arguments[r];return n&&n.forEach(e=>{this._localStreams?this._localStreams.includes(e)||this._localStreams.push(e):this._localStreams=[e];}),t.apply(this,arguments)};}"removeStream"in e.RTCPeerConnection.prototype||(e.RTCPeerConnection.prototype.removeStream=function(e){this._localStreams||(this._localStreams=[]);const t=this._localStreams.indexOf(e);if(-1===t)return;this._localStreams.splice(t,1);const i=e.getTracks();this.getSenders().forEach(e=>{i.includes(e.track)&&this.removeTrack(e);});});}}function Hl(e){if("object"==typeof e&&e.RTCPeerConnection&&("getRemoteStreams"in e.RTCPeerConnection.prototype||(e.RTCPeerConnection.prototype.getRemoteStreams=function(){return this._remoteStreams?this._remoteStreams:[]}),!("onaddstream"in e.RTCPeerConnection.prototype))){Object.defineProperty(e.RTCPeerConnection.prototype,"onaddstream",{get(){return this._onaddstream},set(e){this._onaddstream&&(this.removeEventListener("addstream",this._onaddstream),this.removeEventListener("track",this._onaddstreampoly)),this.addEventListener("addstream",this._onaddstream=e),this.addEventListener("track",this._onaddstreampoly=e=>{e.streams.forEach(e=>{if(this._remoteStreams||(this._remoteStreams=[]),this._remoteStreams.includes(e))return;this._remoteStreams.push(e);const t=new Event("addstream");t.stream=e,this.dispatchEvent(t);});});}});const t=e.RTCPeerConnection.prototype.setRemoteDescription;e.RTCPeerConnection.prototype.setRemoteDescription=function(){const e=this;return this._onaddstreampoly||this.addEventListener("track",this._onaddstreampoly=function(t){t.streams.forEach(t=>{if(e._remoteStreams||(e._remoteStreams=[]),e._remoteStreams.indexOf(t)>=0)return;e._remoteStreams.push(t);const i=new Event("addstream");i.stream=t,e.dispatchEvent(i);});}),t.apply(e,arguments)};}}function Kl(e){if("object"!=typeof e||!e.RTCPeerConnection)return;const t=e.RTCPeerConnection.prototype,i=t.createOffer,n=t.createAnswer,r=t.setLocalDescription,o=t.setRemoteDescription,s=t.addIceCandidate;t.createOffer=function(e,t){const n=arguments.length>=2?arguments[2]:arguments[0],r=i.apply(this,[n]);return t?(r.then(e,t),Sl.resolve()):r},t.createAnswer=function(e,t){const i=arguments.length>=2?arguments[2]:arguments[0],r=n.apply(this,[i]);return t?(r.then(e,t),Sl.resolve()):r};let a=function(e,t,i){const n=r.apply(this,[e]);return i?(n.then(t,i),Sl.resolve()):n};t.setLocalDescription=a,a=function(e,t,i){const n=o.apply(this,[e]);return i?(n.then(t,i),Sl.resolve()):n},t.setRemoteDescription=a,a=function(e,t,i){const n=s.apply(this,[e]);return i?(n.then(t,i),Sl.resolve()):n},t.addIceCandidate=a;}function Yl(e){const t=e&&e.navigator;if(t.mediaDevices&&t.mediaDevices.getUserMedia){const e=t.mediaDevices,i=e.getUserMedia.bind(e);t.mediaDevices.getUserMedia=e=>i(ql(e));}!t.getUserMedia&&t.mediaDevices&&t.mediaDevices.getUserMedia&&(t.getUserMedia=function(e,i,n){t.mediaDevices.getUserMedia(e).then(i,n);}.bind(t));}function ql(e){return e&&void 0!==e.video?Object.assign({},e,{video:cn(e.video)}):e}function Jl(e){if(!e.RTCPeerConnection)return;const t=e.RTCPeerConnection;e.RTCPeerConnection=function(e,i){if(e&&e.iceServers){const t=[];for(let i=0;i<e.iceServers.length;i++){let n=e.iceServers[i];!n.hasOwnProperty("urls")&&n.hasOwnProperty("url")?(on("RTCIceServer.url","RTCIceServer.urls"),n=JSON.parse(JSON.stringify(n)),n.urls=n.url,delete n.url,t.push(n)):t.push(e.iceServers[i]);}e.iceServers=t;}return new t(e,i)},e.RTCPeerConnection.prototype=t.prototype,"generateCertificate"in t&&Object.defineProperty(e.RTCPeerConnection,"generateCertificate",{get:()=>t.generateCertificate});}function Xl(e){"object"==typeof e&&e.RTCTrackEvent&&"receiver"in e.RTCTrackEvent.prototype&&!("transceiver"in e.RTCTrackEvent.prototype)&&Object.defineProperty(e.RTCTrackEvent.prototype,"transceiver",{get(){return {receiver:this.receiver}}});}function zl(e){const t=e.RTCPeerConnection.prototype.createOffer;e.RTCPeerConnection.prototype.createOffer=function(e){if(e){void 0!==e.offerToReceiveAudio&&(e.offerToReceiveAudio=!!e.offerToReceiveAudio);const t=this.getTransceivers().find(e=>"audio"===e.receiver.track.kind);!1===e.offerToReceiveAudio&&t?"sendrecv"===t.direction?t.setDirection?t.setDirection("sendonly"):t.direction="sendonly":"recvonly"===t.direction&&(t.setDirection?t.setDirection("inactive"):t.direction="inactive"):!0!==e.offerToReceiveAudio||t||this.addTransceiver("audio",{direction:"recvonly"}),void 0!==e.offerToReceiveVideo&&(e.offerToReceiveVideo=!!e.offerToReceiveVideo);const i=this.getTransceivers().find(e=>"video"===e.receiver.track.kind);!1===e.offerToReceiveVideo&&i?"sendrecv"===i.direction?i.setDirection?i.setDirection("sendonly"):i.direction="sendonly":"recvonly"===i.direction&&(i.setDirection?i.setDirection("inactive"):i.direction="inactive"):!0!==e.offerToReceiveVideo||i||this.addTransceiver("video",{direction:"recvonly"});}return t.apply(this,arguments)};}function Ql(e){"object"!=typeof e||e.AudioContext||(e.AudioContext=e.webkitAudioContext);}var Zl=Object.freeze({__proto__:null,shimLocalStreamsAPI:Wl,shimRemoteStreamsAPI:Hl,shimCallbacksAPI:Kl,shimGetUserMedia:Yl,shimConstraints:ql,shimRTCIceServerUrls:Jl,shimTrackEventTransceiver:Xl,shimCreateOfferLegacy:zl,shimAudioContext:Ql}),$l="\t\n\v\f\r                　\u2028\u2029\ufeff",eh=G,th=wo,ih=d("".replace),nh="[\t\n\v\f\r                　\u2028\u2029\ufeff]",rh=RegExp("^"+nh+nh+"*"),oh=RegExp(nh+nh+"*$"),sh=function(e){return function(t){var i=th(eh(t));return 1&e&&(i=ih(i,rh,"")),2&e&&(i=ih(i,oh,"")),i}},ah={start:sh(1),end:sh(2),trim:sh(3)},ch=Ms.PROPER,dh=i,uh=$l,lh=ah.trim;Ii({target:"String",proto:!0,forced:function(e){return dh((function(){return !!uh[e]()||"​᠎"!=="​᠎"[e]()||ch&&uh[e].name!==e}))}("trim")},{trim:function(){return lh(this)}});var hh=Hi("String").trim,ph=u,_h=hh,Eh=String.prototype,mh=function(e){var t=e.trim;return "string"==typeof e||e===Eh||ph(Eh,e)&&t===Eh.trim?_h:t},fh={exports:{}};!function(e){const t={generateIdentifier:function(){return Math.random().toString(36).substr(2,10)}};t.localCName=t.generateIdentifier(),t.splitLines=function(e){return mh(e).call(e).split("\n").map(e=>mh(e).call(e))},t.splitSections=function(e){return e.split("\nm=").map((e,t)=>{var i;return mh(i=t>0?"m="+e:e).call(i)+"\r\n"})},t.getDescription=function(e){const i=t.splitSections(e);return i&&i[0]},t.getMediaSections=function(e){const i=t.splitSections(e);return i.shift(),i},t.matchPrefix=function(e,i){return t.splitLines(e).filter(e=>0===e.indexOf(i))},t.parseCandidate=function(e){let t;t=0===e.indexOf("a=candidate:")?e.substring(12).split(" "):e.substring(10).split(" ");const i={foundation:t[0],component:{1:"rtp",2:"rtcp"}[t[1]]||t[1],protocol:t[2].toLowerCase(),priority:parseInt(t[3],10),ip:t[4],address:t[4],port:parseInt(t[5],10),type:t[7]};for(let e=8;e<t.length;e+=2)switch(t[e]){case"raddr":i.relatedAddress=t[e+1];break;case"rport":i.relatedPort=parseInt(t[e+1],10);break;case"tcptype":i.tcpType=t[e+1];break;case"ufrag":i.ufrag=t[e+1],i.usernameFragment=t[e+1];break;default:void 0===i[t[e]]&&(i[t[e]]=t[e+1]);}return i},t.writeCandidate=function(e){const t=[];t.push(e.foundation);const i=e.component;"rtp"===i?t.push(1):"rtcp"===i?t.push(2):t.push(i),t.push(e.protocol.toUpperCase()),t.push(e.priority),t.push(e.address||e.ip),t.push(e.port);const n=e.type;return t.push("typ"),t.push(n),"host"!==n&&e.relatedAddress&&e.relatedPort&&(t.push("raddr"),t.push(e.relatedAddress),t.push("rport"),t.push(e.relatedPort)),e.tcpType&&"tcp"===e.protocol.toLowerCase()&&(t.push("tcptype"),t.push(e.tcpType)),(e.usernameFragment||e.ufrag)&&(t.push("ufrag"),t.push(e.usernameFragment||e.ufrag)),"candidate:"+t.join(" ")},t.parseIceOptions=function(e){return e.substr(14).split(" ")},t.parseRtpMap=function(e){let t=e.substr(9).split(" ");const i={payloadType:parseInt(t.shift(),10)};return t=t[0].split("/"),i.name=t[0],i.clockRate=parseInt(t[1],10),i.channels=3===t.length?parseInt(t[2],10):1,i.numChannels=i.channels,i},t.writeRtpMap=function(e){let t=e.payloadType;void 0!==e.preferredPayloadType&&(t=e.preferredPayloadType);const i=e.channels||e.numChannels||1;return "a=rtpmap:"+t+" "+e.name+"/"+e.clockRate+(1!==i?"/"+i:"")+"\r\n"},t.parseExtmap=function(e){const t=e.substr(9).split(" ");return {id:parseInt(t[0],10),direction:t[0].indexOf("/")>0?t[0].split("/")[1]:"sendrecv",uri:t[1]}},t.writeExtmap=function(e){return "a=extmap:"+(e.id||e.preferredId)+(e.direction&&"sendrecv"!==e.direction?"/"+e.direction:"")+" "+e.uri+"\r\n"},t.parseFmtp=function(e){const t={};let i;const n=e.substr(e.indexOf(" ")+1).split(";");for(let e=0;e<n.length;e++){var r,o;i=mh(r=n[e]).call(r).split("="),t[mh(o=i[0]).call(o)]=i[1];}return t},t.writeFmtp=function(e){let t="",i=e.payloadType;if(void 0!==e.preferredPayloadType&&(i=e.preferredPayloadType),e.parameters&&Object.keys(e.parameters).length){const n=[];Object.keys(e.parameters).forEach(t=>{void 0!==e.parameters[t]?n.push(t+"="+e.parameters[t]):n.push(t);}),t+="a=fmtp:"+i+" "+n.join(";")+"\r\n";}return t},t.parseRtcpFb=function(e){const t=e.substr(e.indexOf(" ")+1).split(" ");return {type:t.shift(),parameter:t.join(" ")}},t.writeRtcpFb=function(e){let t="",i=e.payloadType;return void 0!==e.preferredPayloadType&&(i=e.preferredPayloadType),e.rtcpFeedback&&e.rtcpFeedback.length&&e.rtcpFeedback.forEach(e=>{t+="a=rtcp-fb:"+i+" "+e.type+(e.parameter&&e.parameter.length?" "+e.parameter:"")+"\r\n";}),t},t.parseSsrcMedia=function(e){const t=e.indexOf(" "),i={ssrc:parseInt(e.substr(7,t-7),10)},n=e.indexOf(":",t);return n>-1?(i.attribute=e.substr(t+1,n-t-1),i.value=e.substr(n+1)):i.attribute=e.substr(t+1),i},t.parseSsrcGroup=function(e){const t=e.substr(13).split(" ");return {semantics:t.shift(),ssrcs:t.map(e=>parseInt(e,10))}},t.getMid=function(e){const i=t.matchPrefix(e,"a=mid:")[0];if(i)return i.substr(6)},t.parseFingerprint=function(e){const t=e.substr(14).split(" ");return {algorithm:t[0].toLowerCase(),value:t[1].toUpperCase()}},t.getDtlsParameters=function(e,i){return {role:"auto",fingerprints:t.matchPrefix(e+i,"a=fingerprint:").map(t.parseFingerprint)}},t.writeDtlsParameters=function(e,t){let i="a=setup:"+t+"\r\n";return e.fingerprints.forEach(e=>{i+="a=fingerprint:"+e.algorithm+" "+e.value+"\r\n";}),i},t.parseCryptoLine=function(e){const t=e.substr(9).split(" ");return {tag:parseInt(t[0],10),cryptoSuite:t[1],keyParams:t[2],sessionParams:t.slice(3)}},t.writeCryptoLine=function(e){return "a=crypto:"+e.tag+" "+e.cryptoSuite+" "+("object"==typeof e.keyParams?t.writeCryptoKeyParams(e.keyParams):e.keyParams)+(e.sessionParams?" "+e.sessionParams.join(" "):"")+"\r\n"},t.parseCryptoKeyParams=function(e){if(0!==e.indexOf("inline:"))return null;const t=e.substr(7).split("|");return {keyMethod:"inline",keySalt:t[0],lifeTime:t[1],mkiValue:t[2]?t[2].split(":")[0]:void 0,mkiLength:t[2]?t[2].split(":")[1]:void 0}},t.writeCryptoKeyParams=function(e){return e.keyMethod+":"+e.keySalt+(e.lifeTime?"|"+e.lifeTime:"")+(e.mkiValue&&e.mkiLength?"|"+e.mkiValue+":"+e.mkiLength:"")},t.getCryptoParameters=function(e,i){return t.matchPrefix(e+i,"a=crypto:").map(t.parseCryptoLine)},t.getIceParameters=function(e,i){const n=t.matchPrefix(e+i,"a=ice-ufrag:")[0],r=t.matchPrefix(e+i,"a=ice-pwd:")[0];return n&&r?{usernameFragment:n.substr(12),password:r.substr(10)}:null},t.writeIceParameters=function(e){let t="a=ice-ufrag:"+e.usernameFragment+"\r\na=ice-pwd:"+e.password+"\r\n";return e.iceLite&&(t+="a=ice-lite\r\n"),t},t.parseRtpParameters=function(e){const i={codecs:[],headerExtensions:[],fecMechanisms:[],rtcp:[]},n=t.splitLines(e)[0].split(" ");for(let r=3;r<n.length;r++){const o=n[r],s=t.matchPrefix(e,"a=rtpmap:"+o+" ")[0];if(s){const n=t.parseRtpMap(s),r=t.matchPrefix(e,"a=fmtp:"+o+" ");switch(n.parameters=r.length?t.parseFmtp(r[0]):{},n.rtcpFeedback=t.matchPrefix(e,"a=rtcp-fb:"+o+" ").map(t.parseRtcpFb),i.codecs.push(n),n.name.toUpperCase()){case"RED":case"ULPFEC":i.fecMechanisms.push(n.name.toUpperCase());}}}return t.matchPrefix(e,"a=extmap:").forEach(e=>{i.headerExtensions.push(t.parseExtmap(e));}),i},t.writeRtpDescription=function(e,i){let n="";n+="m="+e+" ",n+=i.codecs.length>0?"9":"0",n+=" UDP/TLS/RTP/SAVPF ",n+=i.codecs.map(e=>void 0!==e.preferredPayloadType?e.preferredPayloadType:e.payloadType).join(" ")+"\r\n",n+="c=IN IP4 0.0.0.0\r\n",n+="a=rtcp:9 IN IP4 0.0.0.0\r\n",i.codecs.forEach(e=>{n+=t.writeRtpMap(e),n+=t.writeFmtp(e),n+=t.writeRtcpFb(e);});let r=0;return i.codecs.forEach(e=>{e.maxptime>r&&(r=e.maxptime);}),r>0&&(n+="a=maxptime:"+r+"\r\n"),i.headerExtensions&&i.headerExtensions.forEach(e=>{n+=t.writeExtmap(e);}),n},t.parseRtpEncodingParameters=function(e){const i=[],n=t.parseRtpParameters(e),r=-1!==n.fecMechanisms.indexOf("RED"),o=-1!==n.fecMechanisms.indexOf("ULPFEC"),s=t.matchPrefix(e,"a=ssrc:").map(e=>t.parseSsrcMedia(e)).filter(e=>"cname"===e.attribute),a=s.length>0&&s[0].ssrc;let c;const d=t.matchPrefix(e,"a=ssrc-group:FID").map(e=>e.substr(17).split(" ").map(e=>parseInt(e,10)));d.length>0&&d[0].length>1&&d[0][0]===a&&(c=d[0][1]),n.codecs.forEach(e=>{if("RTX"===e.name.toUpperCase()&&e.parameters.apt){let t={ssrc:a,codecPayloadType:parseInt(e.parameters.apt,10)};a&&c&&(t.rtx={ssrc:c}),i.push(t),r&&(t=JSON.parse(JSON.stringify(t)),t.fec={ssrc:a,mechanism:o?"red+ulpfec":"red"},i.push(t));}}),0===i.length&&a&&i.push({ssrc:a});let u=t.matchPrefix(e,"b=");return u.length&&(u=0===u[0].indexOf("b=TIAS:")?parseInt(u[0].substr(7),10):0===u[0].indexOf("b=AS:")?1e3*parseInt(u[0].substr(5),10)*.95-16e3:void 0,i.forEach(e=>{e.maxBitrate=u;})),i},t.parseRtcpParameters=function(e){const i={},n=t.matchPrefix(e,"a=ssrc:").map(e=>t.parseSsrcMedia(e)).filter(e=>"cname"===e.attribute)[0];n&&(i.cname=n.value,i.ssrc=n.ssrc);const r=t.matchPrefix(e,"a=rtcp-rsize");i.reducedSize=r.length>0,i.compound=0===r.length;const o=t.matchPrefix(e,"a=rtcp-mux");return i.mux=o.length>0,i},t.writeRtcpParameters=function(e){let t="";return e.reducedSize&&(t+="a=rtcp-rsize\r\n"),e.mux&&(t+="a=rtcp-mux\r\n"),void 0!==e.ssrc&&e.cname&&(t+="a=ssrc:"+e.ssrc+" cname:"+e.cname+"\r\n"),t},t.parseMsid=function(e){let i;const n=t.matchPrefix(e,"a=msid:");if(1===n.length)return i=n[0].substr(7).split(" "),{stream:i[0],track:i[1]};const r=t.matchPrefix(e,"a=ssrc:").map(e=>t.parseSsrcMedia(e)).filter(e=>"msid"===e.attribute);return r.length>0?(i=r[0].value.split(" "),{stream:i[0],track:i[1]}):void 0},t.parseSctpDescription=function(e){const i=t.parseMLine(e),n=t.matchPrefix(e,"a=max-message-size:");let r;n.length>0&&(r=parseInt(n[0].substr(19),10)),isNaN(r)&&(r=65536);const o=t.matchPrefix(e,"a=sctp-port:");if(o.length>0)return {port:parseInt(o[0].substr(12),10),protocol:i.fmt,maxMessageSize:r};const s=t.matchPrefix(e,"a=sctpmap:");if(s.length>0){const e=s[0].substr(10).split(" ");return {port:parseInt(e[0],10),protocol:e[1],maxMessageSize:r}}},t.writeSctpDescription=function(e,t){let i=[];return i="DTLS/SCTP"!==e.protocol?["m="+e.kind+" 9 "+e.protocol+" "+t.protocol+"\r\n","c=IN IP4 0.0.0.0\r\n","a=sctp-port:"+t.port+"\r\n"]:["m="+e.kind+" 9 "+e.protocol+" "+t.port+"\r\n","c=IN IP4 0.0.0.0\r\n","a=sctpmap:"+t.port+" "+t.protocol+" 65535\r\n"],void 0!==t.maxMessageSize&&i.push("a=max-message-size:"+t.maxMessageSize+"\r\n"),i.join("")},t.generateSessionId=function(){return Math.random().toString().substr(2,21)},t.writeSessionBoilerplate=function(e,i,n){let r;const o=void 0!==i?i:2;r=e||t.generateSessionId();return "v=0\r\no="+(n||"thisisadapterortc")+" "+r+" "+o+" IN IP4 127.0.0.1\r\ns=-\r\nt=0 0\r\n"},t.getDirection=function(e,i){const n=t.splitLines(e);for(let e=0;e<n.length;e++)switch(n[e]){case"a=sendrecv":case"a=sendonly":case"a=recvonly":case"a=inactive":return n[e].substr(2)}return i?t.getDirection(i):"sendrecv"},t.getKind=function(e){return t.splitLines(e)[0].split(" ")[0].substr(2)},t.isRejected=function(e){return "0"===e.split(" ",2)[1]},t.parseMLine=function(e){const i=t.splitLines(e)[0].substr(2).split(" ");return {kind:i[0],port:parseInt(i[1],10),protocol:i[2],fmt:i.slice(3).join(" ")}},t.parseOLine=function(e){const i=t.matchPrefix(e,"o=")[0].substr(2).split(" ");return {username:i[0],sessionId:i[1],sessionVersion:parseInt(i[2],10),netType:i[3],addressType:i[4],address:i[5]}},t.isValidSDP=function(e){if("string"!=typeof e||0===e.length)return !1;const i=t.splitLines(e);for(let e=0;e<i.length;e++)if(i[e].length<2||"="!==i[e].charAt(1))return !1;return !0},e.exports=t;}(fh);var Sh=fh.exports,Th=Object.freeze(e({__proto__:null,default:Sh},[fh.exports]));function gh(e){if(!e.RTCIceCandidate||e.RTCIceCandidate&&"foundation"in e.RTCIceCandidate.prototype)return;const t=e.RTCIceCandidate;e.RTCIceCandidate=function(e){if("object"==typeof e&&e.candidate&&0===e.candidate.indexOf("a=")&&((e=JSON.parse(JSON.stringify(e))).candidate=e.candidate.substr(2)),e.candidate&&e.candidate.length){const i=new t(e),n=Sh.parseCandidate(e.candidate),r=Object.assign(i,n);return r.toJSON=function(){return {candidate:r.candidate,sdpMid:r.sdpMid,sdpMLineIndex:r.sdpMLineIndex,usernameFragment:r.usernameFragment}},r}return new t(e)},e.RTCIceCandidate.prototype=t.prototype,en(e,"icecandidate",t=>(t.candidate&&Object.defineProperty(t,"candidate",{value:new e.RTCIceCandidate(t.candidate),writable:"false"}),t));}function Rh(e){!e.RTCIceCandidate||e.RTCIceCandidate&&"relayProtocol"in e.RTCIceCandidate.prototype||en(e,"icecandidate",e=>{if(e.candidate){const t=Sh.parseCandidate(e.candidate.candidate);"relay"===t.type&&(e.candidate.relayProtocol={0:"tls",1:"tcp",2:"udp"}[t.priority>>24]);}return e});}function Ih(e,t){if(!e.RTCPeerConnection)return;"sctp"in e.RTCPeerConnection.prototype||Object.defineProperty(e.RTCPeerConnection.prototype,"sctp",{get(){return void 0===this._sctp?null:this._sctp}});const i=function(e){if(!e||!e.sdp)return !1;const t=Sh.splitSections(e.sdp);return t.shift(),t.some(e=>{const t=Sh.parseMLine(e);return t&&"application"===t.kind&&-1!==t.protocol.indexOf("SCTP")})},n=function(e){const t=e.sdp.match(/mozilla...THIS_IS_SDPARTA-(\d+)/);if(null===t||t.length<2)return -1;const i=parseInt(t[1],10);return i!=i?-1:i},r=function(e){let i=65536;return "firefox"===t.browser&&(i=t.version<57?-1===e?16384:2147483637:t.version<60?57===t.version?65535:65536:2147483637),i},o=function(e,i){let n=65536;"firefox"===t.browser&&57===t.version&&(n=65535);const r=Sh.matchPrefix(e.sdp,"a=max-message-size:");return r.length>0?n=parseInt(r[0].substr(19),10):"firefox"===t.browser&&-1!==i&&(n=2147483637),n},s=e.RTCPeerConnection.prototype.setRemoteDescription;e.RTCPeerConnection.prototype.setRemoteDescription=function(){if(this._sctp=null,"chrome"===t.browser&&t.version>=76){const{sdpSemantics:e}=this.getConfiguration();"plan-b"===e&&Object.defineProperty(this,"sctp",{get(){return void 0===this._sctp?null:this._sctp},enumerable:!0,configurable:!0});}if(i(arguments[0])){const e=n(arguments[0]),t=r(e),i=o(arguments[0],e);let s;s=0===t&&0===i?Number.POSITIVE_INFINITY:0===t||0===i?Math.max(t,i):Math.min(t,i);const a={};Object.defineProperty(a,"maxMessageSize",{get:()=>s}),this._sctp=a;}return s.apply(this,arguments)};}function Ch(e){if(!e.RTCPeerConnection||!("createDataChannel"in e.RTCPeerConnection.prototype))return;function t(e,t){const i=e.send;e.send=function(){const n=arguments[0],r=n.length||n.size||n.byteLength;if("open"===e.readyState&&t.sctp&&r>t.sctp.maxMessageSize)throw new TypeError("Message too large (can send a maximum of "+t.sctp.maxMessageSize+" bytes)");return i.apply(e,arguments)};}const i=e.RTCPeerConnection.prototype.createDataChannel;e.RTCPeerConnection.prototype.createDataChannel=function(){const e=i.apply(this,arguments);return t(e,this),e},en(e,"datachannel",e=>(t(e.channel,e.target),e));}function vh(e){if(!e.RTCPeerConnection||"connectionState"in e.RTCPeerConnection.prototype)return;const t=e.RTCPeerConnection.prototype;Object.defineProperty(t,"connectionState",{get(){return {completed:"connected",checking:"connecting"}[this.iceConnectionState]||this.iceConnectionState},enumerable:!0,configurable:!0}),Object.defineProperty(t,"onconnectionstatechange",{get(){return this._onconnectionstatechange||null},set(e){this._onconnectionstatechange&&(this.removeEventListener("connectionstatechange",this._onconnectionstatechange),delete this._onconnectionstatechange),e&&this.addEventListener("connectionstatechange",this._onconnectionstatechange=e);},enumerable:!0,configurable:!0}),["setLocalDescription","setRemoteDescription"].forEach(e=>{const i=t[e];t[e]=function(){return this._connectionstatechangepoly||(this._connectionstatechangepoly=e=>{const t=e.target;if(t._lastConnectionState!==t.connectionState){t._lastConnectionState=t.connectionState;const i=new Event("connectionstatechange",e);t.dispatchEvent(i);}return e},this.addEventListener("iceconnectionstatechange",this._connectionstatechangepoly)),i.apply(this,arguments)};});}function yh(e,t){if(!e.RTCPeerConnection)return;if("chrome"===t.browser&&t.version>=71)return;if("safari"===t.browser&&t.version>=605)return;const i=e.RTCPeerConnection.prototype.setRemoteDescription;e.RTCPeerConnection.prototype.setRemoteDescription=function(t){if(t&&t.sdp&&-1!==t.sdp.indexOf("\na=extmap-allow-mixed")){const i=t.sdp.split("\n").filter(e=>"a=extmap-allow-mixed"!==mh(e).call(e)).join("\n");e.RTCSessionDescription&&t instanceof e.RTCSessionDescription?arguments[0]=new e.RTCSessionDescription({type:t.type,sdp:i}):t.sdp=i;}return i.apply(this,arguments)};}function Ah(e,t){if(!e.RTCPeerConnection||!e.RTCPeerConnection.prototype)return;const i=e.RTCPeerConnection.prototype.addIceCandidate;i&&0!==i.length&&(e.RTCPeerConnection.prototype.addIceCandidate=function(){return arguments[0]?("chrome"===t.browser&&t.version<78||"firefox"===t.browser&&t.version<68||"safari"===t.browser)&&arguments[0]&&""===arguments[0].candidate?Sl.resolve():i.apply(this,arguments):(arguments[1]&&arguments[1].apply(null),Sl.resolve())});}function Oh(e,t){if(!e.RTCPeerConnection||!e.RTCPeerConnection.prototype)return;const i=e.RTCPeerConnection.prototype.setLocalDescription;i&&0!==i.length&&(e.RTCPeerConnection.prototype.setLocalDescription=function(){let e=arguments[0]||{};if("object"!=typeof e||e.type&&e.sdp)return i.apply(this,arguments);if(e={type:e.type,sdp:e.sdp},!e.type)switch(this.signalingState){case"stable":case"have-local-offer":case"have-remote-pranswer":e.type="offer";break;default:e.type="answer";}if(e.sdp||"offer"!==e.type&&"answer"!==e.type)return i.apply(this,[e]);const t="offer"===e.type?this.createOffer:this.createAnswer;return t.apply(this).then(e=>i.apply(this,[e]))});}var Nh=Object.freeze({__proto__:null,shimRTCIceCandidate:gh,shimRTCIceCandidateRelayProtocol:Rh,shimMaxMessageSize:Ih,shimSendThrowTypeError:Ch,shimConnectionState:vh,removeExtmapAllowMixed:yh,shimAddIceCandidateNullOrEmpty:Ah,shimParameterlessSetLocalDescription:Oh});let bh,wh;!function(){let{window:e}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{shimChrome:!0,shimFirefox:!0,shimSafari:!0};const i=rn,n=sn(e),r={browserDetails:n,commonShim:Nh,extractVersion:$i,disableLog:tn,disableWarnings:nn,sdp:Th};switch(n.browser){case"chrome":if(!wl||!Nl||!t.shimChrome)return i("Chrome shim is not included in this adapter release."),r;if(null===n.version)return i("Chrome shim can not determine version, not shimming."),r;i("adapter.js shimming chrome."),r.browserShim=wl,Ah(e,n),Oh(e),gl(e,n),Rl(e),Nl(e,n),Il(e),Ol(e,n),Cl(e),vl(e),yl(e),bl(e,n),gh(e),Rh(e),vh(e),Ih(e,n),Ch(e),yh(e,n);break;case"firefox":if(!Gl||!Ll||!t.shimFirefox)return i("Firefox shim is not included in this adapter release."),r;i("adapter.js shimming firefox."),r.browserShim=Gl,Ah(e,n),Oh(e),Dl(e,n),Ll(e,n),Pl(e),Ul(e),kl(e),Ml(e),xl(e),Vl(e),jl(e),Fl(e),Bl(e),gh(e),vh(e),Ih(e,n),Ch(e);break;case"safari":if(!Zl||!t.shimSafari)return i("Safari shim is not included in this adapter release."),r;i("adapter.js shimming safari."),r.browserShim=Zl,Ah(e,n),Oh(e),Jl(e),zl(e),Kl(e),Wl(e),Hl(e),Xl(e),Yl(e),Ql(e),gh(e),Rh(e),Ih(e,n),Ch(e),yh(e,n);break;default:i("Unsupported browser!");}}({window:"undefined"==typeof window?void 0:window}),function(e){e.WIN_10="Windows 10",e.WIN_81="Windows 8.1",e.WIN_8="Windows 8",e.WIN_7="Windows 7",e.WIN_VISTA="Windows Vista",e.WIN_SERVER_2003="Windows Server 2003",e.WIN_XP="Windows XP",e.WIN_2000="Windows 2000",e.ANDROID="Android",e.HARMONY_OS="HarmonyOS",e.OPEN_BSD="Open BSD",e.SUN_OS="Sun OS",e.LINUX="Linux",e.IOS="iOS",e.MAC_OS="Mac OS",e.QNX="QNX",e.UNIX="UNIX",e.BEOS="BeOS",e.OS_2="OS/2",e.SEARCH_BOT="Search Bot";}(bh||(bh={})),function(e){e.CHROME="Chrome",e.SAFARI="Safari",e.EDGE="Edge",e.FIREFOX="Firefox",e.OPERA="OPR",e.QQ="QQBrowser",e.WECHAT="MicroMessenger";}(wh||(wh={}));var Dh={exports:{}};!function(e,i){!function(t,n){var r="function",o="undefined",s="object",a="string",c="major",d="model",u="name",l="type",h="vendor",p="version",_="architecture",E="console",m="mobile",f="tablet",S="smarttv",T="wearable",g="embedded",R="Amazon",I="Apple",C="ASUS",v="BlackBerry",y="Firefox",A="Google",O="Huawei",N="LG",b="Microsoft",w="Motorola",D="Opera",P="Samsung",L="Sharp",k="Sony",M="Xiaomi",U="Zebra",x="Facebook",V="Chromium OS",j="Mac OS",F=function(e){for(var t={},i=0;i<e.length;i++)t[e[i].toUpperCase()]=e[i];return t},B=function(e,t){return typeof e===a&&-1!==G(t).indexOf(G(e))},G=function(e){return e.toLowerCase()},W=function(e,t){if(typeof e===a)return e=e.replace(/^\s\s*/,""),typeof t===o?e:e.substring(0,350)},H=function(e,t){for(var i,o,a,c,d,u,l=0;l<t.length&&!d;){var h=t[l],p=t[l+1];for(i=o=0;i<h.length&&!d&&h[i];)if(d=h[i++].exec(e))for(a=0;a<p.length;a++)u=d[++o],typeof(c=p[a])===s&&c.length>0?2===c.length?typeof c[1]==r?this[c[0]]=c[1].call(this,u):this[c[0]]=c[1]:3===c.length?typeof c[1]!==r||c[1].exec&&c[1].test?this[c[0]]=u?u.replace(c[1],c[2]):n:this[c[0]]=u?c[1].call(this,u,c[2]):n:4===c.length&&(this[c[0]]=u?c[3].call(this,u.replace(c[1],c[2])):n):this[c]=u||n;l+=2;}},K=function(e,t){for(var i in t)if(typeof t[i]===s&&t[i].length>0){for(var r=0;r<t[i].length;r++)if(B(t[i][r],e))return "?"===i?n:i}else if(B(t[i],e))return "?"===i?n:i;return e},Y={ME:"4.90","NT 3.11":"NT3.51","NT 4.0":"NT4.0",2e3:"NT 5.0",XP:["NT 5.1","NT 5.2"],Vista:"NT 6.0",7:"NT 6.1",8:"NT 6.2",8.1:"NT 6.3",10:["NT 6.4","NT 10.0"],RT:"ARM"},q={browser:[[/\b(?:crmo|crios)\/([\w\.]+)/i],[p,[u,"Chrome"]],[/edg(?:e|ios|a)?\/([\w\.]+)/i],[p,[u,"Edge"]],[/(opera mini)\/([-\w\.]+)/i,/(opera [mobiletab]{3,6})\b.+version\/([-\w\.]+)/i,/(opera)(?:.+version\/|[\/ ]+)([\w\.]+)/i],[u,p],[/opios[\/ ]+([\w\.]+)/i],[p,[u,"Opera Mini"]],[/\bopr\/([\w\.]+)/i],[p,[u,D]],[/(kindle)\/([\w\.]+)/i,/(lunascape|maxthon|netfront|jasmine|blazer)[\/ ]?([\w\.]*)/i,/(avant |iemobile|slim)(?:browser)?[\/ ]?([\w\.]*)/i,/(ba?idubrowser)[\/ ]?([\w\.]+)/i,/(?:ms|\()(ie) ([\w\.]+)/i,/(flock|rockmelt|midori|epiphany|silk|skyfire|ovibrowser|bolt|iron|vivaldi|iridium|phantomjs|bowser|quark|qupzilla|falkon|rekonq|puffin|brave|whale(?!.+naver)|qqbrowserlite|qq|duckduckgo)\/([-\w\.]+)/i,/(weibo)__([\d\.]+)/i],[u,p],[/(?:\buc? ?browser|(?:juc.+)ucweb)[\/ ]?([\w\.]+)/i],[p,[u,"UCBrowser"]],[/microm.+\bqbcore\/([\w\.]+)/i,/\bqbcore\/([\w\.]+).+microm/i],[p,[u,"WeChat(Win) Desktop"]],[/micromessenger\/([\w\.]+)/i],[p,[u,"WeChat"]],[/konqueror\/([\w\.]+)/i],[p,[u,"Konqueror"]],[/trident.+rv[: ]([\w\.]{1,9})\b.+like gecko/i],[p,[u,"IE"]],[/yabrowser\/([\w\.]+)/i],[p,[u,"Yandex"]],[/(avast|avg)\/([\w\.]+)/i],[[u,/(.+)/,"$1 Secure Browser"],p],[/\bfocus\/([\w\.]+)/i],[p,[u,"Firefox Focus"]],[/\bopt\/([\w\.]+)/i],[p,[u,"Opera Touch"]],[/coc_coc\w+\/([\w\.]+)/i],[p,[u,"Coc Coc"]],[/dolfin\/([\w\.]+)/i],[p,[u,"Dolphin"]],[/coast\/([\w\.]+)/i],[p,[u,"Opera Coast"]],[/miuibrowser\/([\w\.]+)/i],[p,[u,"MIUI Browser"]],[/fxios\/([-\w\.]+)/i],[p,[u,y]],[/\bqihu|(qi?ho?o?|360)browser/i],[[u,"360 Browser"]],[/(oculus|samsung|sailfish|huawei)browser\/([\w\.]+)/i],[[u,/(.+)/,"$1 Browser"],p],[/(comodo_dragon)\/([\w\.]+)/i],[[u,/_/g," "],p],[/(electron)\/([\w\.]+) safari/i,/(tesla)(?: qtcarbrowser|\/(20\d\d\.[-\w\.]+))/i,/m?(qqbrowser|baiduboxapp|2345Explorer)[\/ ]?([\w\.]+)/i],[u,p],[/(metasr)[\/ ]?([\w\.]+)/i,/(lbbrowser)/i,/\[(linkedin)app\]/i],[u],[/((?:fban\/fbios|fb_iab\/fb4a)(?!.+fbav)|;fbav\/([\w\.]+);)/i],[[u,x],p],[/(kakao(?:talk|story))[\/ ]([\w\.]+)/i,/(naver)\(.*?(\d+\.[\w\.]+).*\)/i,/safari (line)\/([\w\.]+)/i,/\b(line)\/([\w\.]+)\/iab/i,/(chromium|instagram)[\/ ]([-\w\.]+)/i],[u,p],[/\bgsa\/([\w\.]+) .*safari\//i],[p,[u,"GSA"]],[/headlesschrome(?:\/([\w\.]+)| )/i],[p,[u,"Chrome Headless"]],[/ wv\).+(chrome)\/([\w\.]+)/i],[[u,"Chrome WebView"],p],[/droid.+ version\/([\w\.]+)\b.+(?:mobile safari|safari)/i],[p,[u,"Android Browser"]],[/(chrome|omniweb|arora|[tizenoka]{5} ?browser)\/v?([\w\.]+)/i],[u,p],[/version\/([\w\.\,]+) .*mobile\/\w+ (safari)/i],[p,[u,"Mobile Safari"]],[/version\/([\w(\.|\,)]+) .*(mobile ?safari|safari)/i],[p,u],[/webkit.+?(mobile ?safari|safari)(\/[\w\.]+)/i],[u,[p,K,{"1.0":"/8",1.2:"/1",1.3:"/3","2.0":"/412","2.0.2":"/416","2.0.3":"/417","2.0.4":"/419","?":"/"}]],[/(webkit|khtml)\/([\w\.]+)/i],[u,p],[/(navigator|netscape\d?)\/([-\w\.]+)/i],[[u,"Netscape"],p],[/mobile vr; rv:([\w\.]+)\).+firefox/i],[p,[u,"Firefox Reality"]],[/ekiohf.+(flow)\/([\w\.]+)/i,/(swiftfox)/i,/(icedragon|iceweasel|camino|chimera|fennec|maemo browser|minimo|conkeror|klar)[\/ ]?([\w\.\+]+)/i,/(seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\/([-\w\.]+)$/i,/(firefox)\/([\w\.]+)/i,/(mozilla)\/([\w\.]+) .+rv\:.+gecko\/\d+/i,/(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|sleipnir|obigo|mosaic|(?:go|ice|up)[\. ]?browser)[-\/ ]?v?([\w\.]+)/i,/(links) \(([\w\.]+)/i,/panasonic;(viera)/i],[u,p],[/(cobalt)\/([\w\.]+)/i],[u,[p,/master.|lts./,""]]],cpu:[[/(?:(amd|x(?:(?:86|64)[-_])?|wow|win)64)[;\)]/i],[[_,"amd64"]],[/(ia32(?=;))/i],[[_,G]],[/((?:i[346]|x)86)[;\)]/i],[[_,"ia32"]],[/\b(aarch64|arm(v?8e?l?|_?64))\b/i],[[_,"arm64"]],[/\b(arm(?:v[67])?ht?n?[fl]p?)\b/i],[[_,"armhf"]],[/windows (ce|mobile); ppc;/i],[[_,"arm"]],[/((?:ppc|powerpc)(?:64)?)(?: mac|;|\))/i],[[_,/ower/,"",G]],[/(sun4\w)[;\)]/i],[[_,"sparc"]],[/((?:avr32|ia64(?=;))|68k(?=\))|\barm(?=v(?:[1-7]|[5-7]1)l?|;|eabi)|(?=atmel )avr|(?:irix|mips|sparc)(?:64)?\b|pa-risc)/i],[[_,G]]],device:[[/\b(sch-i[89]0\d|shw-m380s|sm-[ptx]\w{2,4}|gt-[pn]\d{2,4}|sgh-t8[56]9|nexus 10)/i],[d,[h,P],[l,f]],[/\b((?:s[cgp]h|gt|sm)-\w+|sc[g-]?[\d]+a?|galaxy nexus)/i,/samsung[- ]([-\w]+)/i,/sec-(sgh\w+)/i],[d,[h,P],[l,m]],[/\((ip(?:hone|od)[\w ]*);/i],[d,[h,I],[l,m]],[/\((ipad);[-\w\),; ]+apple/i,/applecoremedia\/[\w\.]+ \((ipad)/i,/\b(ipad)\d\d?,\d\d?[;\]].+ios/i],[d,[h,I],[l,f]],[/(macintosh);/i],[d,[h,I]],[/\b(sh-?[altvz]?\d\d[a-ekm]?)/i],[d,[h,L],[l,m]],[/\b((?:ag[rs][23]?|bah2?|sht?|btv)-a?[lw]\d{2})\b(?!.+d\/s)/i],[d,[h,O],[l,f]],[/(?:huawei|honor)([-\w ]+)[;\)]/i,/\b(nexus 6p|\w{2,4}e?-[atu]?[ln][\dx][012359c][adn]?)\b(?!.+d\/s)/i],[d,[h,O],[l,m]],[/\b(poco[\w ]+)(?: bui|\))/i,/\b; (\w+) build\/hm\1/i,/\b(hm[-_ ]?note?[_ ]?(?:\d\w)?) bui/i,/\b(redmi[\-_ ]?(?:note|k)?[\w_ ]+)(?: bui|\))/i,/\b(mi[-_ ]?(?:a\d|one|one[_ ]plus|note lte|max|cc)?[_ ]?(?:\d?\w?)[_ ]?(?:plus|se|lite)?)(?: bui|\))/i],[[d,/_/g," "],[h,M],[l,m]],[/\b(mi[-_ ]?(?:pad)(?:[\w_ ]+))(?: bui|\))/i],[[d,/_/g," "],[h,M],[l,f]],[/; (\w+) bui.+ oppo/i,/\b(cph[12]\d{3}|p(?:af|c[al]|d\w|e[ar])[mt]\d0|x9007|a101op)\b/i],[d,[h,"OPPO"],[l,m]],[/vivo (\w+)(?: bui|\))/i,/\b(v[12]\d{3}\w?[at])(?: bui|;)/i],[d,[h,"Vivo"],[l,m]],[/\b(rmx[12]\d{3})(?: bui|;|\))/i],[d,[h,"Realme"],[l,m]],[/\b(milestone|droid(?:[2-4x]| (?:bionic|x2|pro|razr))?:?( 4g)?)\b[\w ]+build\//i,/\bmot(?:orola)?[- ](\w*)/i,/((?:moto[\w\(\) ]+|xt\d{3,4}|nexus 6)(?= bui|\)))/i],[d,[h,w],[l,m]],[/\b(mz60\d|xoom[2 ]{0,2}) build\//i],[d,[h,w],[l,f]],[/((?=lg)?[vl]k\-?\d{3}) bui| 3\.[-\w; ]{10}lg?-([06cv9]{3,4})/i],[d,[h,N],[l,f]],[/(lm(?:-?f100[nv]?|-[\w\.]+)(?= bui|\))|nexus [45])/i,/\blg[-e;\/ ]+((?!browser|netcast|android tv)\w+)/i,/\blg-?([\d\w]+) bui/i],[d,[h,N],[l,m]],[/(ideatab[-\w ]+)/i,/lenovo ?(s[56]000[-\w]+|tab(?:[\w ]+)|yt[-\d\w]{6}|tb[-\d\w]{6})/i],[d,[h,"Lenovo"],[l,f]],[/(?:maemo|nokia).*(n900|lumia \d+)/i,/nokia[-_ ]?([-\w\.]*)/i],[[d,/_/g," "],[h,"Nokia"],[l,m]],[/(pixel c)\b/i],[d,[h,A],[l,f]],[/droid.+; (pixel[\daxl ]{0,6})(?: bui|\))/i],[d,[h,A],[l,m]],[/droid.+ (a?\d[0-2]{2}so|[c-g]\d{4}|so[-gl]\w+|xq-a\w[4-7][12])(?= bui|\).+chrome\/(?![1-6]{0,1}\d\.))/i],[d,[h,k],[l,m]],[/sony tablet [ps]/i,/\b(?:sony)?sgp\w+(?: bui|\))/i],[[d,"Xperia Tablet"],[h,k],[l,f]],[/ (kb2005|in20[12]5|be20[12][59])\b/i,/(?:one)?(?:plus)? (a\d0\d\d)(?: b|\))/i],[d,[h,"OnePlus"],[l,m]],[/(alexa)webm/i,/(kf[a-z]{2}wi)( bui|\))/i,/(kf[a-z]+)( bui|\)).+silk\//i],[d,[h,R],[l,f]],[/((?:sd|kf)[0349hijorstuw]+)( bui|\)).+silk\//i],[[d,/(.+)/g,"Fire Phone $1"],[h,R],[l,m]],[/(playbook);[-\w\),; ]+(rim)/i],[d,h,[l,f]],[/\b((?:bb[a-f]|st[hv])100-\d)/i,/\(bb10; (\w+)/i],[d,[h,v],[l,m]],[/(?:\b|asus_)(transfo[prime ]{4,10} \w+|eeepc|slider \w+|nexus 7|padfone|p00[cj])/i],[d,[h,C],[l,f]],[/ (z[bes]6[027][012][km][ls]|zenfone \d\w?)\b/i],[d,[h,C],[l,m]],[/(nexus 9)/i],[d,[h,"HTC"],[l,f]],[/(htc)[-;_ ]{1,2}([\w ]+(?=\)| bui)|\w+)/i,/(zte)[- ]([\w ]+?)(?: bui|\/|\))/i,/(alcatel|geeksphone|nexian|panasonic(?!(?:;|\.))|sony(?!-bra))[-_ ]?([-\w]*)/i],[h,[d,/_/g," "],[l,m]],[/droid.+; ([ab][1-7]-?[0178a]\d\d?)/i],[d,[h,"Acer"],[l,f]],[/droid.+; (m[1-5] note) bui/i,/\bmz-([-\w]{2,})/i],[d,[h,"Meizu"],[l,m]],[/(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus|dell|meizu|motorola|polytron)[-_ ]?([-\w]*)/i,/(hp) ([\w ]+\w)/i,/(asus)-?(\w+)/i,/(microsoft); (lumia[\w ]+)/i,/(lenovo)[-_ ]?([-\w]+)/i,/(jolla)/i,/(oppo) ?([\w ]+) bui/i],[h,d,[l,m]],[/(kobo)\s(ereader|touch)/i,/(archos) (gamepad2?)/i,/(hp).+(touchpad(?!.+tablet)|tablet)/i,/(kindle)\/([\w\.]+)/i,/(nook)[\w ]+build\/(\w+)/i,/(dell) (strea[kpr\d ]*[\dko])/i,/(le[- ]+pan)[- ]+(\w{1,9}) bui/i,/(trinity)[- ]*(t\d{3}) bui/i,/(gigaset)[- ]+(q\w{1,9}) bui/i,/(vodafone) ([\w ]+)(?:\)| bui)/i],[h,d,[l,f]],[/(surface duo)/i],[d,[h,b],[l,f]],[/droid [\d\.]+; (fp\du?)(?: b|\))/i],[d,[h,"Fairphone"],[l,m]],[/(u304aa)/i],[d,[h,"AT&T"],[l,m]],[/\bsie-(\w*)/i],[d,[h,"Siemens"],[l,m]],[/\b(rct\w+) b/i],[d,[h,"RCA"],[l,f]],[/\b(venue[\d ]{2,7}) b/i],[d,[h,"Dell"],[l,f]],[/\b(q(?:mv|ta)\w+) b/i],[d,[h,"Verizon"],[l,f]],[/\b(?:barnes[& ]+noble |bn[rt])([\w\+ ]*) b/i],[d,[h,"Barnes & Noble"],[l,f]],[/\b(tm\d{3}\w+) b/i],[d,[h,"NuVision"],[l,f]],[/\b(k88) b/i],[d,[h,"ZTE"],[l,f]],[/\b(nx\d{3}j) b/i],[d,[h,"ZTE"],[l,m]],[/\b(gen\d{3}) b.+49h/i],[d,[h,"Swiss"],[l,m]],[/\b(zur\d{3}) b/i],[d,[h,"Swiss"],[l,f]],[/\b((zeki)?tb.*\b) b/i],[d,[h,"Zeki"],[l,f]],[/\b([yr]\d{2}) b/i,/\b(dragon[- ]+touch |dt)(\w{5}) b/i],[[h,"Dragon Touch"],d,[l,f]],[/\b(ns-?\w{0,9}) b/i],[d,[h,"Insignia"],[l,f]],[/\b((nxa|next)-?\w{0,9}) b/i],[d,[h,"NextBook"],[l,f]],[/\b(xtreme\_)?(v(1[045]|2[015]|[3469]0|7[05])) b/i],[[h,"Voice"],d,[l,m]],[/\b(lvtel\-)?(v1[12]) b/i],[[h,"LvTel"],d,[l,m]],[/\b(ph-1) /i],[d,[h,"Essential"],[l,m]],[/\b(v(100md|700na|7011|917g).*\b) b/i],[d,[h,"Envizen"],[l,f]],[/\b(trio[-\w\. ]+) b/i],[d,[h,"MachSpeed"],[l,f]],[/\btu_(1491) b/i],[d,[h,"Rotor"],[l,f]],[/(shield[\w ]+) b/i],[d,[h,"Nvidia"],[l,f]],[/(sprint) (\w+)/i],[h,d,[l,m]],[/(kin\.[onetw]{3})/i],[[d,/\./g," "],[h,b],[l,m]],[/droid.+; (cc6666?|et5[16]|mc[239][23]x?|vc8[03]x?)\)/i],[d,[h,U],[l,f]],[/droid.+; (ec30|ps20|tc[2-8]\d[kx])\)/i],[d,[h,U],[l,m]],[/smart-tv.+(samsung)/i],[h,[l,S]],[/hbbtv.+maple;(\d+)/i],[[d,/^/,"SmartTV"],[h,P],[l,S]],[/(nux; netcast.+smarttv|lg (netcast\.tv-201\d|android tv))/i],[[h,N],[l,S]],[/(apple) ?tv/i],[h,[d,"Apple TV"],[l,S]],[/crkey/i],[[d,"Chromecast"],[h,A],[l,S]],[/droid.+aft(\w)( bui|\))/i],[d,[h,R],[l,S]],[/\(dtv[\);].+(aquos)/i,/(aquos-tv[\w ]+)\)/i],[d,[h,L],[l,S]],[/(bravia[\w ]+)( bui|\))/i],[d,[h,k],[l,S]],[/(mitv-\w{5}) bui/i],[d,[h,M],[l,S]],[/Hbbtv.*(technisat) (.*);/i],[h,d,[l,S]],[/\b(roku)[\dx]*[\)\/]((?:dvp-)?[\d\.]*)/i,/hbbtv\/\d+\.\d+\.\d+ +\([\w\+ ]*; *([\w\d][^;]*);([^;]*)/i],[[h,W],[d,W],[l,S]],[/\b(android tv|smart[- ]?tv|opera tv|tv; rv:)\b/i],[[l,S]],[/(ouya)/i,/(nintendo) ([wids3utch]+)/i],[h,d,[l,E]],[/droid.+; (shield) bui/i],[d,[h,"Nvidia"],[l,E]],[/(playstation [345portablevi]+)/i],[d,[h,k],[l,E]],[/\b(xbox(?: one)?(?!; xbox))[\); ]/i],[d,[h,b],[l,E]],[/((pebble))app/i],[h,d,[l,T]],[/(watch)(?: ?os[,\/]|\d,\d\/)[\d\.]+/i],[d,[h,I],[l,T]],[/droid.+; (glass) \d/i],[d,[h,A],[l,T]],[/droid.+; (wt63?0{2,3})\)/i],[d,[h,U],[l,T]],[/(quest( 2| pro)?)/i],[d,[h,x],[l,T]],[/(tesla)(?: qtcarbrowser|\/[-\w\.]+)/i],[h,[l,g]],[/droid .+?; ([^;]+?)(?: bui|\) applew).+? mobile safari/i],[d,[l,m]],[/droid .+?; ([^;]+?)(?: bui|\) applew).+?(?! mobile) safari/i],[d,[l,f]],[/\b((tablet|tab)[;\/]|focus\/\d(?!.+mobile))/i],[[l,f]],[/(phone|mobile(?:[;\/]| [ \w\/\.]*safari)|pda(?=.+windows ce))/i],[[l,m]],[/(android[-\w\. ]{0,9});.+buil/i],[d,[h,"Generic"]]],engine:[[/windows.+ edge\/([\w\.]+)/i],[p,[u,"EdgeHTML"]],[/webkit\/537\.36.+chrome\/(?!27)([\w\.]+)/i],[p,[u,"Blink"]],[/(presto)\/([\w\.]+)/i,/(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna)\/([\w\.]+)/i,/ekioh(flow)\/([\w\.]+)/i,/(khtml|tasman|links)[\/ ]\(?([\w\.]+)/i,/(icab)[\/ ]([23]\.[\d\.]+)/i],[u,p],[/rv\:([\w\.]{1,9})\b.+(gecko)/i],[p,u]],os:[[/microsoft (windows) (vista|xp)/i],[u,p],[/(windows) nt 6\.2; (arm)/i,/(windows (?:phone(?: os)?|mobile))[\/ ]?([\d\.\w ]*)/i,/(windows)[\/ ]?([ntce\d\. ]+\w)(?!.+xbox)/i],[u,[p,K,Y]],[/(win(?=3|9|n)|win 9x )([nt\d\.]+)/i],[[u,"Windows"],[p,K,Y]],[/ip[honead]{2,4}\b(?:.*os ([\w]+) like mac|; opera)/i,/cfnetwork\/.+darwin/i],[[p,/_/g,"."],[u,"iOS"]],[/(mac os x) ?([\w\. ]*)/i,/(macintosh|mac_powerpc\b)(?!.+haiku)/i],[[u,j],[p,/_/g,"."]],[/droid ([\w\.]+)\b.+(android[- ]x86|harmonyos)/i],[p,u],[/(android|webos|qnx|bada|rim tablet os|maemo|meego|sailfish)[-\/ ]?([\w\.]*)/i,/(blackberry)\w*\/([\w\.]*)/i,/(tizen|kaios)[\/ ]([\w\.]+)/i,/\((series40);/i],[u,p],[/\(bb(10);/i],[p,[u,v]],[/(?:symbian ?os|symbos|s60(?=;)|series60)[-\/ ]?([\w\.]*)/i],[p,[u,"Symbian"]],[/mozilla\/[\d\.]+ \((?:mobile|tablet|tv|mobile; [\w ]+); rv:.+ gecko\/([\w\.]+)/i],[p,[u,"Firefox OS"]],[/web0s;.+rt(tv)/i,/\b(?:hp)?wos(?:browser)?\/([\w\.]+)/i],[p,[u,"webOS"]],[/watch(?: ?os[,\/]|\d,\d\/)([\d\.]+)/i],[p,[u,"watchOS"]],[/crkey\/([\d\.]+)/i],[p,[u,"Chromecast"]],[/(cros) [\w]+(?:\)| ([\w\.]+)\b)/i],[[u,V],p],[/panasonic;(viera)/i,/(netrange)mmh/i,/(nettv)\/(\d+\.[\w\.]+)/i,/(nintendo|playstation) ([wids345portablevuch]+)/i,/(xbox); +xbox ([^\);]+)/i,/\b(joli|palm)\b ?(?:os)?\/?([\w\.]*)/i,/(mint)[\/\(\) ]?(\w*)/i,/(mageia|vectorlinux)[; ]/i,/([kxln]?ubuntu|debian|suse|opensuse|gentoo|arch(?= linux)|slackware|fedora|mandriva|centos|pclinuxos|red ?hat|zenwalk|linpus|raspbian|plan 9|minix|risc os|contiki|deepin|manjaro|elementary os|sabayon|linspire)(?: gnu\/linux)?(?: enterprise)?(?:[- ]linux)?(?:-gnu)?[-\/ ]?(?!chrom|package)([-\w\.]*)/i,/(hurd|linux) ?([\w\.]*)/i,/(gnu) ?([\w\.]*)/i,/\b([-frentopcghs]{0,5}bsd|dragonfly)[\/ ]?(?!amd|[ix346]{1,2}86)([\w\.]*)/i,/(haiku) (\w+)/i],[u,p],[/(sunos) ?([\w\.\d]*)/i],[[u,"Solaris"],p],[/((?:open)?solaris)[-\/ ]?([\w\.]*)/i,/(aix) ((\d)(?=\.|\)| )[\w\.])*/i,/\b(beos|os\/2|amigaos|morphos|openvms|fuchsia|hp-ux)/i,/(unix) ?([\w\.]*)/i],[u,p]]},J=function(e,i){if(typeof e===s&&(i=e,e=n),!(this instanceof J))return new J(e,i).getResult();var c=typeof t!==o&&t.navigator?t.navigator:n,d=e||(c&&c.userAgent?c.userAgent:""),u=c&&c.userAgentData?c.userAgentData:n,l=i?function(e,t){var i={};for(var n in e)t[n]&&t[n].length%2==0?i[n]=t[n].concat(e[n]):i[n]=e[n];return i}(q,i):q;return this.getBrowser=function(){var e={};return e.name=n,e.version=n,H.call(e,d,l.browser),e.major=function(e){return typeof e===a?e.replace(/[^\d\.]/g,"").split(".")[0]:n}(e.version),c&&c.brave&&typeof c.brave.isBrave==r&&(e.name="Brave"),e},this.getCPU=function(){var e={};return e.architecture=n,H.call(e,d,l.cpu),e},this.getDevice=function(){var e={};return e.vendor=n,e.model=n,e.type=n,H.call(e,d,l.device),!e.type&&u&&u.mobile&&(e.type=m),"Macintosh"==e.model&&c&&typeof c.standalone!==o&&c.maxTouchPoints&&c.maxTouchPoints>2&&(e.model="iPad",e.type=f),e},this.getEngine=function(){var e={};return e.name=n,e.version=n,H.call(e,d,l.engine),e},this.getOS=function(){var e={};return e.name=n,e.version=n,H.call(e,d,l.os),!e.name&&u&&"Unknown"!=u.platform&&(e.name=u.platform.replace(/chrome os/i,V).replace(/macos/i,j)),e},this.getResult=function(){return {ua:this.getUA(),browser:this.getBrowser(),engine:this.getEngine(),os:this.getOS(),device:this.getDevice(),cpu:this.getCPU()}},this.getUA=function(){return d},this.setUA=function(e){return d=typeof e===a&&e.length>350?W(e,350):e,this},this.setUA(d),this};J.VERSION="0.7.34",J.BROWSER=F([u,p,c]),J.CPU=F([_]),J.DEVICE=F([d,h,l,E,m,S,f,T,g]),J.ENGINE=J.OS=F([u,p]),e.exports&&(i=e.exports=J),i.UAParser=J;var X=typeof t!==o&&(t.jQuery||t.Zepto);if(X&&!X.ua){var z=new J;X.ua=z.getResult(),X.ua.get=function(){return z.getUA()},X.ua.set=function(e){z.setUA(e);var t=z.getResult();for(var i in t)X.ua[i]=t[i];};}}("object"==typeof window?window:t);}(Dh,Dh.exports);const Ph=new(Dh.exports);let Lh,kh,Mh=Ph.getResult(),Uh=null;function xh(e){if(!Uh){e&&Ph.setUA(e),Mh=Ph.getResult();const t=function(e){if("Blink"===e.engine.name&&"WeChat"!==e.browser.name)return wh.CHROME;switch(e.browser.name){case"Chrome Headless":case"Chrome":case"Chromium":return wh.CHROME;case"Safari":case"Mobile Safari":return wh.SAFARI;case"Edge":return wh.EDGE;case"Firefox":return wh.FIREFOX;case"QQBrowser":return wh.QQ;case"Opera":return wh.OPERA;case"WeChat":return wh.WECHAT;default:return e.browser.name||""}}(Mh),i=function(e){let t;t="Blink"===e.engine.name?e.engine.version||"":e.browser.version||"";return t.split(".")[0]}(Mh),n=function(e){switch(e.os.name){case"Windows":return e.os.version?e.os.name+" "+e.os.version:e.os.name;default:return e.os.name||""}}(Mh),r=Mh.os.version;if(!(t&&i&&n&&r))return {name:t,version:i,os:n,osVersion:r};Uh={name:t,version:i,os:n,osVersion:r};}return Uh}function Vh(){return xh().os}function jh(){const e=xh();return "".concat(e.os," ").concat(e.osVersion)}function Fh(){const e=xh();return !!("WebKit"===Mh.engine.name&&e.os===bh.MAC_OS&&navigator.maxTouchPoints&&navigator.maxTouchPoints>0&&e.name!==wh.SAFARI||Yh()&&e.name!==wh.SAFARI)}function Bh(){const e=xh();if(Fh()){if(e.os===bh.MAC_OS)return !0;if(e.os===bh.IOS){const e=Mh.os.version&&Mh.os.version.split(".");if(e&&14===Number(e[0])&&e[1]&&Number(e[1])>=3)return !0;if(e&&Number(e[0])>14)return !0}}return !1}function Gh(){return "WebKit"===Mh.engine.name}function Wh(){return xh().name===wh.CHROME}function Hh(){return xh().name===wh.SAFARI}function Kh(){return xh().name===wh.FIREFOX}function Yh(){return xh().os===bh.IOS}function qh(e){const t=xh();return !(t.name!==wh.CHROME||!t.osVersion)&&Number(t.version)>=e}function Jh(e){const t=xh();return !(t.name!==wh.EDGE||!t.osVersion)&&Number(t.version)>=e}function Xh(e){const t=xh();return !(t.name!==wh.OPERA||!t.osVersion)&&Number(t.version)>=e}function zh(){const e=xh();return !(e.name!==wh.CHROME||!e.osVersion)&&Number(e.version)<=90}function Qh(){const e=xh();if(e.os!==bh.IOS||!e.osVersion)return !1;const t=e.osVersion.split(".");return Number(t[0])<14||14===Number(t[0])&&Number(t[1])<=6}function Zh(){const e=xh();if(e.os!==bh.IOS||!e.osVersion)return !1;const t=e.osVersion.split(".");return 15===Number(t[0])}function $h(){const e=xh();if(e.os!==bh.IOS||!e.osVersion)return !1;const t=e.osVersion.split(".");return 16===Number(t[0])}function ep(){const e=xh();if(e.os!==bh.IOS||!e.osVersion)return !1;const t=e.osVersion.split(".");return 15===Number(t[0])&&Number(t[1])>=1}function tp(){return Hh()&&navigator.maxTouchPoints>0}function ip(){return xh().name===wh.WECHAT}function np(){return window.navigator.appVersion&&null!==window.navigator.appVersion.match(/Chrome\/([\w\W]*?)\./)&&window.navigator.appVersion.match(/Chrome\/([\w\W]*?)\./)[1]<=35}function rp(){const e=xh();if(e.name===wh.EDGE||e.name===wh.SAFARI)return !1;return !!navigator.userAgent.toLocaleLowerCase().match(/chrome\/[\d]./i)}function op(){return Vh()===bh.ANDROID}function sp(){const e=xh();return op()&&(e.name===wh.CHROME||e.name===wh.WECHAT||/chrome|chromium/i.test(navigator.userAgent))}!function(e){e.L1T1="L1T1",e.L1T2="L1T2",e.L1T3="L1T3",e.L2T1_KEY="L2T1_KEY",e.L2T2_KEY="L2T2_KEY",e.L2T3_KEY="L2T3_KEY",e.L3T1_KEY="L3T1_KEY",e.L3T2_KEY="L3T2_KEY",e.L3T3_KEY="L3T3_KEY";}(Lh||(Lh={})),function(e){e.CERTIFICATE="certificate",e.CODEC="codec",e.CANDIDATE_PAIR="candidate-pair",e.LOCAL_CANDIDATE="local-candidate",e.REMOTE_CANDIDATE="remote-candidate",e.INBOUND="inbound-rtp",e.TRACK="track",e.OUTBOUND="outbound-rtp",e.PC="peer-connection",e.REMOTE_INBOUND="remote-inbound-rtp",e.REMOTE_OUTBOUND="remote-outbound-rtp",e.TRANSPORT="transport",e.CSRC="csrc",e.DATA_CHANNEL="data-channel",e.STREAM="stream",e.SENDER="sender",e.RECEIVER="receiver";}(kh||(kh={}));var ap={exports:{}},cp=Ii,dp=g,up=Ht.f;cp({target:"Object",stat:!0,forced:Object.defineProperty!==up,sham:!dp},{defineProperty:up});var lp=J.Object,hp=ap.exports=function(e,t,i){return lp.defineProperty(e,t,i)};lp.defineProperty.sham&&(hp.sham=!0);var pp=ap.exports;function _p(e,t,i){return t in e?pp(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}var Ep,mp={exports:{}},fp=function(e,t){return function(){for(var i=new Array(arguments.length),n=0;n<i.length;n++)i[n]=arguments[n];return e.apply(t,i)}},Sp=fp,Tp=Object.prototype.toString,gp=(Ep=Object.create(null),function(e){var t=Tp.call(e);return Ep[t]||(Ep[t]=t.slice(8,-1).toLowerCase())});function Rp(e){return e=e.toLowerCase(),function(t){return gp(t)===e}}function Ip(e){return Array.isArray(e)}function Cp(e){return void 0===e}var vp=Rp("ArrayBuffer");function yp(e){return null!==e&&"object"==typeof e}function Ap(e){if("object"!==gp(e))return !1;var t=Object.getPrototypeOf(e);return null===t||t===Object.prototype}var Op=Rp("Date"),Np=Rp("File"),bp=Rp("Blob"),wp=Rp("FileList");function Dp(e){return "[object Function]"===Tp.call(e)}var Pp=Rp("URLSearchParams");function Lp(e,t){if(null!=e)if("object"!=typeof e&&(e=[e]),Ip(e))for(var i=0,n=e.length;i<n;i++)t.call(null,e[i],i,e);else for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&t.call(null,e[r],r,e);}var kp,Mp=(kp="undefined"!=typeof Uint8Array&&Object.getPrototypeOf(Uint8Array),function(e){return kp&&e instanceof kp}),Up={isArray:Ip,isArrayBuffer:vp,isBuffer:function(e){return null!==e&&!Cp(e)&&null!==e.constructor&&!Cp(e.constructor)&&"function"==typeof e.constructor.isBuffer&&e.constructor.isBuffer(e)},isFormData:function(e){var t="[object FormData]";return e&&("function"==typeof FormData&&e instanceof FormData||Tp.call(e)===t||Dp(e.toString)&&e.toString()===t)},isArrayBufferView:function(e){return "undefined"!=typeof ArrayBuffer&&ArrayBuffer.isView?ArrayBuffer.isView(e):e&&e.buffer&&vp(e.buffer)},isString:function(e){return "string"==typeof e},isNumber:function(e){return "number"==typeof e},isObject:yp,isPlainObject:Ap,isUndefined:Cp,isDate:Op,isFile:Np,isBlob:bp,isFunction:Dp,isStream:function(e){return yp(e)&&Dp(e.pipe)},isURLSearchParams:Pp,isStandardBrowserEnv:function(){return ("undefined"==typeof navigator||"ReactNative"!==navigator.product&&"NativeScript"!==navigator.product&&"NS"!==navigator.product)&&("undefined"!=typeof window&&"undefined"!=typeof document)},forEach:Lp,merge:function e(){var t={};function i(i,n){Ap(t[n])&&Ap(i)?t[n]=e(t[n],i):Ap(i)?t[n]=e({},i):Ip(i)?t[n]=i.slice():t[n]=i;}for(var n=0,r=arguments.length;n<r;n++)Lp(arguments[n],i);return t},extend:function(e,t,i){return Lp(t,(function(t,n){e[n]=i&&"function"==typeof t?Sp(t,i):t;})),e},trim:function(e){return e.trim?e.trim():e.replace(/^\s+|\s+$/g,"")},stripBOM:function(e){return 65279===e.charCodeAt(0)&&(e=e.slice(1)),e},inherits:function(e,t,i,n){e.prototype=Object.create(t.prototype,n),e.prototype.constructor=e,i&&Object.assign(e.prototype,i);},toFlatObject:function(e,t,i){var n,r,o,s={};t=t||{};do{for(r=(n=Object.getOwnPropertyNames(e)).length;r-- >0;)s[o=n[r]]||(t[o]=e[o],s[o]=!0);e=Object.getPrototypeOf(e);}while(e&&(!i||i(e,t))&&e!==Object.prototype);return t},kindOf:gp,kindOfTest:Rp,endsWith:function(e,t,i){e=String(e),(void 0===i||i>e.length)&&(i=e.length),i-=t.length;var n=e.indexOf(t,i);return -1!==n&&n===i},toArray:function(e){if(!e)return null;var t=e.length;if(Cp(t))return null;for(var i=new Array(t);t-- >0;)i[t]=e[t];return i},isTypedArray:Mp,isFileList:wp},xp=Up;function Vp(e){return encodeURIComponent(e).replace(/%3A/gi,":").replace(/%24/g,"$").replace(/%2C/gi,",").replace(/%20/g,"+").replace(/%5B/gi,"[").replace(/%5D/gi,"]")}var jp=function(e,t,i){if(!t)return e;var n;if(i)n=i(t);else if(xp.isURLSearchParams(t))n=t.toString();else {var r=[];xp.forEach(t,(function(e,t){null!=e&&(xp.isArray(e)?t+="[]":e=[e],xp.forEach(e,(function(e){xp.isDate(e)?e=e.toISOString():xp.isObject(e)&&(e=JSON.stringify(e)),r.push(Vp(t)+"="+Vp(e));})));})),n=r.join("&");}if(n){var o=e.indexOf("#");-1!==o&&(e=e.slice(0,o)),e+=(-1===e.indexOf("?")?"?":"&")+n;}return e},Fp=Up;function Bp(){this.handlers=[];}Bp.prototype.use=function(e,t,i){return this.handlers.push({fulfilled:e,rejected:t,synchronous:!!i&&i.synchronous,runWhen:i?i.runWhen:null}),this.handlers.length-1},Bp.prototype.eject=function(e){this.handlers[e]&&(this.handlers[e]=null);},Bp.prototype.forEach=function(e){Fp.forEach(this.handlers,(function(t){null!==t&&e(t);}));};var Gp=Bp,Wp=Up,Hp=Up;function Kp(e,t,i,n,r){Error.call(this),this.message=e,this.name="AxiosError",t&&(this.code=t),i&&(this.config=i),n&&(this.request=n),r&&(this.response=r);}Hp.inherits(Kp,Error,{toJSON:function(){return {message:this.message,name:this.name,description:this.description,number:this.number,fileName:this.fileName,lineNumber:this.lineNumber,columnNumber:this.columnNumber,stack:this.stack,config:this.config,code:this.code,status:this.response&&this.response.status?this.response.status:null}}});var Yp=Kp.prototype,qp={};["ERR_BAD_OPTION_VALUE","ERR_BAD_OPTION","ECONNABORTED","ETIMEDOUT","ERR_NETWORK","ERR_FR_TOO_MANY_REDIRECTS","ERR_DEPRECATED","ERR_BAD_RESPONSE","ERR_BAD_REQUEST","ERR_CANCELED"].forEach((function(e){qp[e]={value:e};})),Object.defineProperties(Kp,qp),Object.defineProperty(Yp,"isAxiosError",{value:!0}),Kp.from=function(e,t,i,n,r,o){var s=Object.create(Yp);return Hp.toFlatObject(e,s,(function(e){return e!==Error.prototype})),Kp.call(s,e.message,t,i,n,r),s.name=e.name,o&&Object.assign(s,o),s};var Jp=Kp,Xp={silentJSONParsing:!0,forcedJSONParsing:!0,clarifyTimeoutError:!1},zp=Up;var Qp=function(e,t){t=t||new FormData;var i=[];function n(e){return null===e?"":zp.isDate(e)?e.toISOString():zp.isArrayBuffer(e)||zp.isTypedArray(e)?"function"==typeof Blob?new Blob([e]):Buffer.from(e):e}return function e(r,o){if(zp.isPlainObject(r)||zp.isArray(r)){if(-1!==i.indexOf(r))throw Error("Circular reference detected in "+o);i.push(r),zp.forEach(r,(function(i,r){if(!zp.isUndefined(i)){var s,a=o?o+"."+r:r;if(i&&!o&&"object"==typeof i)if(zp.endsWith(r,"{}"))i=JSON.stringify(i);else if(zp.endsWith(r,"[]")&&(s=zp.toArray(i)))return void s.forEach((function(e){!zp.isUndefined(e)&&t.append(a,n(e));}));e(i,a);}})),i.pop();}else t.append(o,n(r));}(e),t},Zp=Jp,$p=Up,e_=$p.isStandardBrowserEnv()?{write:function(e,t,i,n,r,o){var s=[];s.push(e+"="+encodeURIComponent(t)),$p.isNumber(i)&&s.push("expires="+new Date(i).toGMTString()),$p.isString(n)&&s.push("path="+n),$p.isString(r)&&s.push("domain="+r),!0===o&&s.push("secure"),document.cookie=s.join("; ");},read:function(e){var t=document.cookie.match(new RegExp("(^|;\\s*)("+e+")=([^;]*)"));return t?decodeURIComponent(t[3]):null},remove:function(e){this.write(e,"",Date.now()-864e5);}}:{write:function(){},read:function(){return null},remove:function(){}},t_=function(e){return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(e)},i_=function(e,t){return t?e.replace(/\/+$/,"")+"/"+t.replace(/^\/+/,""):e},n_=function(e,t){return e&&!t_(t)?i_(e,t):t},r_=Up,o_=["age","authorization","content-length","content-type","etag","expires","from","host","if-modified-since","if-unmodified-since","last-modified","location","max-forwards","proxy-authorization","referer","retry-after","user-agent"],s_=Up,a_=s_.isStandardBrowserEnv()?function(){var e,t=/(msie|trident)/i.test(navigator.userAgent),i=document.createElement("a");function n(e){var n=e;return t&&(i.setAttribute("href",n),n=i.href),i.setAttribute("href",n),{href:i.href,protocol:i.protocol?i.protocol.replace(/:$/,""):"",host:i.host,search:i.search?i.search.replace(/^\?/,""):"",hash:i.hash?i.hash.replace(/^#/,""):"",hostname:i.hostname,port:i.port,pathname:"/"===i.pathname.charAt(0)?i.pathname:"/"+i.pathname}}return e=n(window.location.href),function(t){var i=s_.isString(t)?n(t):t;return i.protocol===e.protocol&&i.host===e.host}}():function(){return !0},c_=Jp;function d_(e){c_.call(this,null==e?"canceled":e,c_.ERR_CANCELED),this.name="CanceledError";}Up.inherits(d_,c_,{__CANCEL__:!0});var u_=d_,l_=Up,h_=function(e,t,i){var n=i.config.validateStatus;i.status&&n&&!n(i.status)?t(new Zp("Request failed with status code "+i.status,[Zp.ERR_BAD_REQUEST,Zp.ERR_BAD_RESPONSE][Math.floor(i.status/100)-4],i.config,i.request,i)):e(i);},p_=e_,__=jp,E_=n_,m_=function(e){var t,i,n,r={};return e?(r_.forEach(e.split("\n"),(function(e){if(n=e.indexOf(":"),t=r_.trim(e.substr(0,n)).toLowerCase(),i=r_.trim(e.substr(n+1)),t){if(r[t]&&o_.indexOf(t)>=0)return;r[t]="set-cookie"===t?(r[t]?r[t]:[]).concat([i]):r[t]?r[t]+", "+i:i;}})),r):r},f_=a_,S_=Xp,T_=Jp,g_=u_,R_=function(e){var t=/^([-+\w]{1,25})(:?\/\/|:)/.exec(e);return t&&t[1]||""},I_=function(e){return new Promise((function(t,i){var n,r=e.data,o=e.headers,s=e.responseType;function a(){e.cancelToken&&e.cancelToken.unsubscribe(n),e.signal&&e.signal.removeEventListener("abort",n);}l_.isFormData(r)&&l_.isStandardBrowserEnv()&&delete o["Content-Type"];var c=new XMLHttpRequest;if(e.auth){var d=e.auth.username||"",u=e.auth.password?unescape(encodeURIComponent(e.auth.password)):"";o.Authorization="Basic "+btoa(d+":"+u);}var l=E_(e.baseURL,e.url);function h(){if(c){var n="getAllResponseHeaders"in c?m_(c.getAllResponseHeaders()):null,r={data:s&&"text"!==s&&"json"!==s?c.response:c.responseText,status:c.status,statusText:c.statusText,headers:n,config:e,request:c};h_((function(e){t(e),a();}),(function(e){i(e),a();}),r),c=null;}}if(c.open(e.method.toUpperCase(),__(l,e.params,e.paramsSerializer),!0),c.timeout=e.timeout,"onloadend"in c?c.onloadend=h:c.onreadystatechange=function(){c&&4===c.readyState&&(0!==c.status||c.responseURL&&0===c.responseURL.indexOf("file:"))&&setTimeout(h);},c.onabort=function(){c&&(i(new T_("Request aborted",T_.ECONNABORTED,e,c)),c=null);},c.onerror=function(){i(new T_("Network Error",T_.ERR_NETWORK,e,c,c)),c=null;},c.ontimeout=function(){var t=e.timeout?"timeout of "+e.timeout+"ms exceeded":"timeout exceeded",n=e.transitional||S_;e.timeoutErrorMessage&&(t=e.timeoutErrorMessage),i(new T_(t,n.clarifyTimeoutError?T_.ETIMEDOUT:T_.ECONNABORTED,e,c)),c=null;},l_.isStandardBrowserEnv()){var p=(e.withCredentials||f_(l))&&e.xsrfCookieName?p_.read(e.xsrfCookieName):void 0;p&&(o[e.xsrfHeaderName]=p);}"setRequestHeader"in c&&l_.forEach(o,(function(e,t){void 0===r&&"content-type"===t.toLowerCase()?delete o[t]:c.setRequestHeader(t,e);})),l_.isUndefined(e.withCredentials)||(c.withCredentials=!!e.withCredentials),s&&"json"!==s&&(c.responseType=e.responseType),"function"==typeof e.onDownloadProgress&&c.addEventListener("progress",e.onDownloadProgress),"function"==typeof e.onUploadProgress&&c.upload&&c.upload.addEventListener("progress",e.onUploadProgress),(e.cancelToken||e.signal)&&(n=function(e){c&&(i(!e||e&&e.type?new g_:e),c.abort(),c=null);},e.cancelToken&&e.cancelToken.subscribe(n),e.signal&&(e.signal.aborted?n():e.signal.addEventListener("abort",n))),r||(r=null);var _=R_(l);_&&-1===["http","https","file"].indexOf(_)?i(new T_("Unsupported protocol "+_+":",T_.ERR_BAD_REQUEST,e)):c.send(r);}))},C_=Up,v_=function(e,t){Wp.forEach(e,(function(i,n){n!==t&&n.toUpperCase()===t.toUpperCase()&&(e[t]=i,delete e[n]);}));},y_=Jp,A_=Qp,O_={"Content-Type":"application/x-www-form-urlencoded"};function N_(e,t){!C_.isUndefined(e)&&C_.isUndefined(e["Content-Type"])&&(e["Content-Type"]=t);}var b_,w_={transitional:Xp,adapter:(("undefined"!=typeof XMLHttpRequest||"undefined"!=typeof process&&"[object process]"===Object.prototype.toString.call(process))&&(b_=I_),b_),transformRequest:[function(e,t){if(v_(t,"Accept"),v_(t,"Content-Type"),C_.isFormData(e)||C_.isArrayBuffer(e)||C_.isBuffer(e)||C_.isStream(e)||C_.isFile(e)||C_.isBlob(e))return e;if(C_.isArrayBufferView(e))return e.buffer;if(C_.isURLSearchParams(e))return N_(t,"application/x-www-form-urlencoded;charset=utf-8"),e.toString();var i,n=C_.isObject(e),r=t&&t["Content-Type"];if((i=C_.isFileList(e))||n&&"multipart/form-data"===r){var o=this.env&&this.env.FormData;return A_(i?{"files[]":e}:e,o&&new o)}return n||"application/json"===r?(N_(t,"application/json"),function(e,t,i){if(C_.isString(e))try{return (t||JSON.parse)(e),C_.trim(e)}catch(e){if("SyntaxError"!==e.name)throw e}return (i||JSON.stringify)(e)}(e)):e}],transformResponse:[function(e){var t=this.transitional||w_.transitional,i=t&&t.silentJSONParsing,n=t&&t.forcedJSONParsing,r=!i&&"json"===this.responseType;if(r||n&&C_.isString(e)&&e.length)try{return JSON.parse(e)}catch(e){if(r){if("SyntaxError"===e.name)throw y_.from(e,y_.ERR_BAD_RESPONSE,this,null,this.response);throw e}}return e}],timeout:0,xsrfCookieName:"XSRF-TOKEN",xsrfHeaderName:"X-XSRF-TOKEN",maxContentLength:-1,maxBodyLength:-1,env:{FormData:null},validateStatus:function(e){return e>=200&&e<300},headers:{common:{Accept:"application/json, text/plain, */*"}}};C_.forEach(["delete","get","head"],(function(e){w_.headers[e]={};})),C_.forEach(["post","put","patch"],(function(e){w_.headers[e]=C_.merge(O_);}));var D_=w_,P_=Up,L_=D_,k_=function(e){return !(!e||!e.__CANCEL__)},M_=Up,U_=function(e,t,i){var n=this||L_;return P_.forEach(i,(function(i){e=i.call(n,e,t);})),e},x_=k_,V_=D_,j_=u_;function F_(e){if(e.cancelToken&&e.cancelToken.throwIfRequested(),e.signal&&e.signal.aborted)throw new j_}var B_=Up,G_=function(e,t){t=t||{};var i={};function n(e,t){return B_.isPlainObject(e)&&B_.isPlainObject(t)?B_.merge(e,t):B_.isPlainObject(t)?B_.merge({},t):B_.isArray(t)?t.slice():t}function r(i){return B_.isUndefined(t[i])?B_.isUndefined(e[i])?void 0:n(void 0,e[i]):n(e[i],t[i])}function o(e){if(!B_.isUndefined(t[e]))return n(void 0,t[e])}function s(i){return B_.isUndefined(t[i])?B_.isUndefined(e[i])?void 0:n(void 0,e[i]):n(void 0,t[i])}function a(i){return i in t?n(e[i],t[i]):i in e?n(void 0,e[i]):void 0}var c={url:o,method:o,data:o,baseURL:s,transformRequest:s,transformResponse:s,paramsSerializer:s,timeout:s,timeoutMessage:s,withCredentials:s,adapter:s,responseType:s,xsrfCookieName:s,xsrfHeaderName:s,onUploadProgress:s,onDownloadProgress:s,decompress:s,maxContentLength:s,maxBodyLength:s,beforeRedirect:s,transport:s,httpAgent:s,httpsAgent:s,cancelToken:s,socketPath:s,responseEncoding:s,validateStatus:a};return B_.forEach(Object.keys(e).concat(Object.keys(t)),(function(e){var t=c[e]||r,n=t(e);B_.isUndefined(n)&&t!==a||(i[e]=n);})),i},W_="0.27.2",H_=W_,K_=Jp,Y_={};["object","boolean","number","function","string","symbol"].forEach((function(e,t){Y_[e]=function(i){return typeof i===e||"a"+(t<1?"n ":" ")+e};}));var q_={};Y_.transitional=function(e,t,i){function n(e,t){return "[Axios v"+H_+"] Transitional option '"+e+"'"+t+(i?". "+i:"")}return function(i,r,o){if(!1===e)throw new K_(n(r," has been removed"+(t?" in "+t:"")),K_.ERR_DEPRECATED);return t&&!q_[r]&&(q_[r]=!0,console.warn(n(r," has been deprecated since v"+t+" and will be removed in the near future"))),!e||e(i,r,o)}};var J_=Up,X_=jp,z_=Gp,Q_=function(e){return F_(e),e.headers=e.headers||{},e.data=U_.call(e,e.data,e.headers,e.transformRequest),e.headers=M_.merge(e.headers.common||{},e.headers[e.method]||{},e.headers),M_.forEach(["delete","get","head","post","put","patch","common"],(function(t){delete e.headers[t];})),(e.adapter||V_.adapter)(e).then((function(t){return F_(e),t.data=U_.call(e,t.data,t.headers,e.transformResponse),t}),(function(t){return x_(t)||(F_(e),t&&t.response&&(t.response.data=U_.call(e,t.response.data,t.response.headers,e.transformResponse))),Promise.reject(t)}))},Z_=G_,$_=n_,eE={assertOptions:function(e,t,i){if("object"!=typeof e)throw new K_("options must be an object",K_.ERR_BAD_OPTION_VALUE);for(var n=Object.keys(e),r=n.length;r-- >0;){var o=n[r],s=t[o];if(s){var a=e[o],c=void 0===a||s(a,o,e);if(!0!==c)throw new K_("option "+o+" must be "+c,K_.ERR_BAD_OPTION_VALUE)}else if(!0!==i)throw new K_("Unknown option "+o,K_.ERR_BAD_OPTION)}},validators:Y_},tE=eE.validators;function iE(e){this.defaults=e,this.interceptors={request:new z_,response:new z_};}iE.prototype.request=function(e,t){"string"==typeof e?(t=t||{}).url=e:t=e||{},(t=Z_(this.defaults,t)).method?t.method=t.method.toLowerCase():this.defaults.method?t.method=this.defaults.method.toLowerCase():t.method="get";var i=t.transitional;void 0!==i&&eE.assertOptions(i,{silentJSONParsing:tE.transitional(tE.boolean),forcedJSONParsing:tE.transitional(tE.boolean),clarifyTimeoutError:tE.transitional(tE.boolean)},!1);var n=[],r=!0;this.interceptors.request.forEach((function(e){"function"==typeof e.runWhen&&!1===e.runWhen(t)||(r=r&&e.synchronous,n.unshift(e.fulfilled,e.rejected));}));var o,s=[];if(this.interceptors.response.forEach((function(e){s.push(e.fulfilled,e.rejected);})),!r){var a=[Q_,void 0];for(Array.prototype.unshift.apply(a,n),a=a.concat(s),o=Promise.resolve(t);a.length;)o=o.then(a.shift(),a.shift());return o}for(var c=t;n.length;){var d=n.shift(),u=n.shift();try{c=d(c);}catch(e){u(e);break}}try{o=Q_(c);}catch(e){return Promise.reject(e)}for(;s.length;)o=o.then(s.shift(),s.shift());return o},iE.prototype.getUri=function(e){e=Z_(this.defaults,e);var t=$_(e.baseURL,e.url);return X_(t,e.params,e.paramsSerializer)},J_.forEach(["delete","get","head","options"],(function(e){iE.prototype[e]=function(t,i){return this.request(Z_(i||{},{method:e,url:t,data:(i||{}).data}))};})),J_.forEach(["post","put","patch"],(function(e){function t(t){return function(i,n,r){return this.request(Z_(r||{},{method:e,headers:t?{"Content-Type":"multipart/form-data"}:{},url:i,data:n}))}}iE.prototype[e]=t(),iE.prototype[e+"Form"]=t(!0);}));var nE=iE,rE=u_;function oE(e){if("function"!=typeof e)throw new TypeError("executor must be a function.");var t;this.promise=new Promise((function(e){t=e;}));var i=this;this.promise.then((function(e){if(i._listeners){var t,n=i._listeners.length;for(t=0;t<n;t++)i._listeners[t](e);i._listeners=null;}})),this.promise.then=function(e){var t,n=new Promise((function(e){i.subscribe(e),t=e;})).then(e);return n.cancel=function(){i.unsubscribe(t);},n},e((function(e){i.reason||(i.reason=new rE(e),t(i.reason));}));}oE.prototype.throwIfRequested=function(){if(this.reason)throw this.reason},oE.prototype.subscribe=function(e){this.reason?e(this.reason):this._listeners?this._listeners.push(e):this._listeners=[e];},oE.prototype.unsubscribe=function(e){if(this._listeners){var t=this._listeners.indexOf(e);-1!==t&&this._listeners.splice(t,1);}},oE.source=function(){var e;return {token:new oE((function(t){e=t;})),cancel:e}};var sE=oE,aE=Up,cE=Up,dE=fp,uE=nE,lE=G_;var hE=function e(t){var i=new uE(t),n=dE(uE.prototype.request,i);return cE.extend(n,uE.prototype,i),cE.extend(n,i),n.create=function(i){return e(lE(t,i))},n}(D_);hE.Axios=uE,hE.CanceledError=u_,hE.CancelToken=sE,hE.isCancel=k_,hE.VERSION=W_,hE.toFormData=Qp,hE.AxiosError=Jp,hE.Cancel=hE.CanceledError,hE.all=function(e){return Promise.all(e)},hE.spread=function(e){return function(t){return e.apply(null,t)}},hE.isAxiosError=function(e){return aE.isObject(e)&&!0===e.isAxiosError},mp.exports=hE,mp.exports.default=hE;var pE=mp.exports;class _E{constructor(e){_p(this,"logger",void 0),_p(this,"prefixLists",[]),this.logger=e;}debug(){for(var e=arguments.length,t=new Array(e),i=0;i<e;i++)t[i]=arguments[i];this.logger.debug(...this.prefixLists,...t);}info(){for(var e=arguments.length,t=new Array(e),i=0;i<e;i++)t[i]=arguments[i];this.logger.info(...this.prefixLists,...t);}warning(){for(var e=arguments.length,t=new Array(e),i=0;i<e;i++)t[i]=arguments[i];this.logger.warning(...this.prefixLists,...t);}error(){for(var e=arguments.length,t=new Array(e),i=0;i<e;i++)t[i]=arguments[i];this.logger.error(...this.prefixLists,...t);}prefix(e){return this.prefixLists.push(e),this}popPrefix(){return this.prefixLists.pop(),this}}class EE{constructor(){_p(this,"_events",{}),_p(this,"addListener",this.on);}getListeners(e){return this._events[e]?this._events[e].map(e=>e.listener):[]}on(e,t){this._events[e]||(this._events[e]=[]);const i=this._events[e];-1===this._indexOfListener(i,t)&&i.push({listener:t,once:!1});}once(e,t){this._events[e]||(this._events[e]=[]);const i=this._events[e];-1===this._indexOfListener(i,t)&&i.push({listener:t,once:!0});}off(e,t){if(!this._events[e])return;const i=this._events[e],n=this._indexOfListener(i,t);-1!==n&&i.splice(n,1),0===this._events[e].length&&delete this._events[e];}removeAllListeners(e){e?delete this._events[e]:this._events={};}emit(e){this._events[e]||(this._events[e]=[]);const t=this._events[e].map(e=>e);for(var i=arguments.length,n=new Array(i>1?i-1:0),r=1;r<i;r++)n[r-1]=arguments[r];for(let i=0;i<t.length;i+=1){const r=t[i];r.once&&this.off(e,r.listener),r.listener.apply(this,n||[]);}}safeEmit(e){for(var t=arguments.length,i=new Array(t>1?t-1:0),n=1;n<t;n++)i[n-1]=arguments[n];[...this._events[e]||[]].forEach(t=>{t.once&&this.off(e,t.listener);try{t.listener.apply(this,i);}catch(t){OE.error("safeEmit event:".concat(e," error ").concat(null==t?void 0:t.toString()));}});}_indexOfListener(e,t){let i=e.length;for(;i--;)if(e[i].listener===t)return i;return -1}}const mE=new class extends EE{reportLogUploadError(e){this.emit("REPORT_LOG_UPLOAD",e);}};let fE;!function(e){e.UNEXPECTED_ERROR="UNEXPECTED_ERROR",e.UNEXPECTED_RESPONSE="UNEXPECTED_RESPONSE",e.TIMEOUT="TIMEOUT",e.INVALID_PARAMS="INVALID_PARAMS",e.NOT_READABLE="NOT_READABLE",e.NOT_SUPPORTED="NOT_SUPPORTED",e.INVALID_OPERATION="INVALID_OPERATION",e.OPERATION_ABORTED="OPERATION_ABORTED",e.WEB_SECURITY_RESTRICT="WEB_SECURITY_RESTRICT",e.EXCHANGE_SDP_FAILED="EXCHANGE_SDP_FAILED",e.NETWORK_ERROR="NETWORK_ERROR",e.NETWORK_TIMEOUT="NETWORK_TIMEOUT",e.NETWORK_RESPONSE_ERROR="NETWORK_RESPONSE_ERROR",e.API_INVOKE_TIMEOUT="API_INVOKE_TIMEOUT",e.ENUMERATE_DEVICES_FAILED="ENUMERATE_DEVICES_FAILED",e.DEVICE_NOT_FOUND="DEVICE_NOT_FOUND",e.ELECTRON_IS_NULL="ELECTRON_IS_NULL",e.ELECTRON_DESKTOP_CAPTURER_GET_SOURCES_ERROR="ELECTRON_DESKTOP_CAPTURER_GET_SOURCES_ERROR",e.CHROME_PLUGIN_NO_RESPONSE="CHROME_PLUGIN_NO_RESPONSE",e.CHROME_PLUGIN_NOT_INSTALL="CHROME_PLUGIN_NOT_INSTALL",e.MEDIA_OPTION_INVALID="MEDIA_OPTION_INVALID",e.PERMISSION_DENIED="PERMISSION_DENIED",e.CONSTRAINT_NOT_SATISFIED="CONSTRAINT_NOT_SATISFIED",e.TRACK_IS_DISABLED="TRACK_IS_DISABLED",e.GET_VIDEO_ELEMENT_VISIBLE_ERROR="GET_VIDEO_ELEMENT_VISIBLE_ERROR",e.SHARE_AUDIO_NOT_ALLOWED="SHARE_AUDIO_NOT_ALLOWED",e.LOW_STREAM_ENCODING_ERROR="LOW_STREAM_ENCODING_ERROR",e.SET_ENCODING_PARAMETER_ERROR="SET_ENCODING_PARAMETER_ERROR",e.TRACK_STATE_UNREACHABLE="TRACK_STATE_UNREACHABLE",e.INVALID_UINT_UID_FROM_STRING_UID="INVALID_UINT_UID_FROM_STRING_UID",e.CAN_NOT_GET_PROXY_SERVER="CAN_NOT_GET_PROXY_SERVER",e.CAN_NOT_GET_GATEWAY_SERVER="CAN_NOT_GET_GATEWAY_SERVER",e.VOID_GATEWAY_ADDRESS="VOID_GATEWAY_ADDRESS",e.UID_CONFLICT="UID_CONFLICT",e.MULTI_UNILBS_RESPONSE_ERROR="MULTI_UNILBS_RESPONSE_ERROR",e.UPDATE_TICKET_FAILED="UPDATE_TICKET_FAILED",e.INVALID_LOCAL_TRACK="INVALID_LOCAL_TRACK",e.INVALID_TRACK="INVALID_TRACK",e.SENDER_NOT_FOUND="SENDER_NOT_FOUND",e.CREATE_OFFER_FAILED="CREATE_OFFER_FAILED",e.SET_ANSWER_FAILED="SET_ANSWER_FAILED",e.ICE_FAILED="ICE_FAILED",e.PC_CLOSED="PC_CLOSED",e.SENDER_REPLACE_FAILED="SENDER_REPLACE_FAILED",e.GET_LOCAL_CAPABILITIES_FAILED="GET_LOCAL_CAPABILITIES_FAILED",e.GET_LOCAL_CONNECTION_PARAMS_FAILED="GET_LOCAL_CONNECTION_PARAMS_FAILED",e.SUBSCRIBE_FAILED="SUBSCRIBE_FAILED",e.UNSUBSCRIBE_FAILED="UNSUBSCRIBE_FAILED",e.GATEWAY_P2P_LOST="GATEWAY_P2P_LOST",e.NO_ICE_CANDIDATE="NO_ICE_CANDIDATE",e.CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS="CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS",e.EXIST_DISABLED_VIDEO_TRACK="EXIST_DISABLED_VIDEO_TRACK",e.INVALID_REMOTE_USER="INVALID_REMOTE_USER",e.REMOTE_USER_IS_NOT_PUBLISHED="REMOTE_USER_IS_NOT_PUBLISHED",e.CUSTOM_REPORT_SEND_FAILED="CUSTOM_REPORT_SEND_FAILED",e.CUSTOM_REPORT_FREQUENCY_TOO_HIGH="CUSTOM_REPORT_FREQUENCY_TOO_HIGH",e.FETCH_AUDIO_FILE_FAILED="FETCH_AUDIO_FILE_FAILED",e.READ_LOCAL_AUDIO_FILE_ERROR="READ_LOCAL_AUDIO_FILE_ERROR",e.DECODE_AUDIO_FILE_FAILED="DECODE_AUDIO_FILE_FAILED",e.WS_ABORT="WS_ABORT",e.WS_DISCONNECT="WS_DISCONNECT",e.WS_ERR="WS_ERR",e.LIVE_STREAMING_TASK_CONFLICT="LIVE_STREAMING_TASK_CONFLICT",e.LIVE_STREAMING_INVALID_ARGUMENT="LIVE_STREAMING_INVALID_ARGUMENT",e.LIVE_STREAMING_INTERNAL_SERVER_ERROR="LIVE_STREAMING_INTERNAL_SERVER_ERROR",e.LIVE_STREAMING_PUBLISH_STREAM_NOT_AUTHORIZED="LIVE_STREAMING_PUBLISH_STREAM_NOT_AUTHORIZED",e.LIVE_STREAMING_TRANSCODING_NOT_SUPPORTED="LIVE_STREAMING_TRANSCODING_NOT_SUPPORTED",e.LIVE_STREAMING_CDN_ERROR="LIVE_STREAMING_CDN_ERROR",e.LIVE_STREAMING_INVALID_RAW_STREAM="LIVE_STREAMING_INVALID_RAW_STREAM",e.LIVE_STREAMING_WARN_STREAM_NUM_REACH_LIMIT="LIVE_STREAMING_WARN_STREAM_NUM_REACH_LIMIT",e.LIVE_STREAMING_WARN_FAILED_LOAD_IMAGE="LIVE_STREAMING_WARN_FAILED_LOAD_IMAGE",e.LIVE_STREAMING_WARN_FREQUENT_REQUEST="LIVE_STREAMING_WARN_FREQUENT_REQUEST",e.WEBGL_INTERNAL_ERROR="WEBGL_INTERNAL_ERROR",e.BEAUTY_PROCESSOR_INTERNAL_ERROR="BEAUTY_PROCESSOR_INTERNAL_ERROR",e.CROSS_CHANNEL_WAIT_STATUS_ERROR="CROSS_CHANNEL_WAIT_STATUS_ERROR",e.CROSS_CHANNEL_FAILED_JOIN_SRC="CROSS_CHANNEL_FAILED_JOIN_SEC",e.CROSS_CHANNEL_FAILED_JOIN_DEST="CROSS_CHANNEL_FAILED_JOIN_DEST",e.CROSS_CHANNEL_FAILED_PACKET_SENT_TO_DEST="CROSS_CHANNEL_FAILED_PACKET_SENT_TO_DEST",e.CROSS_CHANNEL_SERVER_ERROR_RESPONSE="CROSS_CHANNEL_SERVER_ERROR_RESPONSE",e.METADATA_OUT_OF_RANGE="METADATA_OUT_OF_RANGE",e.LOCAL_AEC_ERROR="LOCAL_AEC_ERROR",e.INVALID_PLUGIN="INVALID_PLUGIN",e.DISCONNECT_P2P="DISCONNECT_P2P",e.INIT_WEBSOCKET_TIMEOUT="INIT_WEBSOCKET_TIMEOUT",e.CONVERTING_IMAGEDATA_TO_BLOB_FAILED="CONVERTING_IMAGEDATA_TO_BLOB_FAILED",e.CONVERTING_VIDEO_FRAME_TO_BLOB_FAILED="CONVERTING_VIDEO_FRAME_TO_BLOB_FAILED",e.INIT_DATACHANNEL_TIMEOUT="INIT_DATACHANNEL_TIMEOUT",e.DATACHANNEL_CONNECTION_TIMEOUT="DATACHANNEL_CONNECTION_TIMEOUT",e.PROHIBITED_OPERATION="PROHIBITED_OPERATION",e.IMAGE_MODERATION_UPLOAD_FAILED="IMAGE_MODERATION_UPLOAD_FAILED";}(fE||(fE={}));class SE extends Error{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"",i=arguments.length>2?arguments[2]:void 0;super(t),_p(this,"code",void 0),_p(this,"message",void 0),_p(this,"data",void 0),_p(this,"name","AgoraRTCException"),this.code=e,this.message="AgoraRTCError ".concat(this.code,": ").concat(t),this.data=i;}toString(){return this.data?"data: ".concat(JSON.stringify(this.data),"\n").concat(this.stack):"".concat(this.stack)}print(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"error";return "error"===e&&OE.error(this.toString()),"warning"===e&&OE.warning(this.toString()),this}throw(){throw this.print(),this}}const TE={timeout:500,timeoutFactor:1.5,maxRetryCount:1/0,maxRetryTimeout:1e4};function gE(e,t){const i=Math.floor(t.timeout*Math.pow(t.timeoutFactor,e));return Math.min(t.maxRetryTimeout,i)}function RE(e,t,i,n){const r=Object.assign({},TE,n);let o=r.timeout;const s=async()=>{await function(e){return new Sl(t=>{window.setTimeout(t,e);})}(o),o*=r.timeoutFactor,o=Math.min(r.maxRetryTimeout,o);};let a=!1;const c=new Sl(async(n,o)=>{t=t||(()=>!1),i=i||(()=>!0);for(let c=0;c<r.maxRetryCount;c+=1){if(a)return o(new SE(fE.OPERATION_ABORTED));try{const i=await e();if(!t(i,c))return n(i);if(c+1===r.maxRetryCount)return n(i);await s();}catch(e){if(!i(e,c))return o(e);if(c+1===r.maxRetryCount)return o(e);await s();}}});return c.cancel=()=>a=!0,c}function IE(){const e=new Date;return e.toTimeString().split(" ")[0]+":"+e.getMilliseconds()}function CE(){const e=new Date,t=/((\d+:){2}\d+)/.exec((new Date).toUTCString());return t?(null==t?void 0:t[0])+":"+e.getUTCMilliseconds():e.toTimeString().split(" ")[0]+":"+e.getMilliseconds()}const vE={DEBUG:0,INFO:1,WARNING:2,ERROR:3,NONE:4},yE=Date.now(),AE=e=>{for(const t in vE)if(Object.prototype.hasOwnProperty.call(vE,t)&&vE[t]===e)return t;return "DEFAULT"};const OE=new class{constructor(){_p(this,"proxyServerURL",void 0),_p(this,"logLevel",vE.DEBUG),_p(this,"uploadState","collecting"),_p(this,"uploadLogWaitingList",[]),_p(this,"uploadLogUploadingList",[]),_p(this,"uploadErrorCount",0),_p(this,"currentLogID",0),_p(this,"url",void 0),_p(this,"extLog",(e,t)=>{this.appendLogToWaitingList(e,...t);});}debug(){for(var e=arguments.length,t=new Array(e),i=0;i<e;i++)t[i]=arguments[i];const n=[vE.DEBUG].concat(t);this.log.apply(this,n);}info(){for(var e=arguments.length,t=new Array(e),i=0;i<e;i++)t[i]=arguments[i];const n=[vE.INFO].concat(t);this.log.apply(this,n);}warning(){for(var e=arguments.length,t=new Array(e),i=0;i<e;i++)t[i]=arguments[i];const n=[vE.WARNING].concat(t);this.log.apply(this,n);}error(){for(var e=arguments.length,t=new Array(e),i=0;i<e;i++)t[i]=arguments[i];const n=[vE.ERROR].concat(t);this.log.apply(this,n);}upload(){for(var e=arguments.length,t=new Array(e),i=0;i<e;i++)t[i]=arguments[i];const n=[vE.DEBUG].concat(t);this.uploadLog.apply(this,n);}setLogLevel(e){e=Math.min(Math.max(0,e),4),this.logLevel=e;}enableLogUpload(){BE("UPLOAD_LOG",!0);}disableLogUpload(){BE("UPLOAD_LOG",!1),this.uploadLogUploadingList=[],this.uploadLogWaitingList=[];}setProxyServer(e){this.proxyServerURL=e;}prefix(e){return new _E(this).prefix(e)}log(){for(var e=arguments.length,t=new Array(e),i=0;i<e;i++)t[i]=arguments[i];if(Date.now()-yE<100)return void setTimeout(()=>{this.log(...t);},Date.now()-yE);const n=Math.max(0,Math.min(4,t[0]));if(t[0]=IE()+" Agora-SDK [".concat(AE(n),"]:"),this.appendLogToWaitingList(n,...t),n<this.logLevel)return;const r=IE()+" %cAgora-SDK [".concat(AE(n),"]:");let o=[];if(!GE("USE_NEW_LOG"))switch(n){case vE.DEBUG:o=[r,"color: #64B5F6;"].concat(t.slice(1)),console.log.apply(console,o);break;case vE.INFO:o=[r,"color: #1E88E5; font-weight: bold;"].concat(t.slice(1)),console.log.apply(console,o);break;case vE.WARNING:o=[r,"color: #FB8C00; font-weight: bold;"].concat(t.slice(1)),console.warn.apply(console,o);break;case vE.ERROR:o=[r,"color: #B00020; font-weight: bold;"].concat(t.slice(1)),console.error.apply(console,o);}}uploadLog(){for(var e=arguments.length,t=new Array(e),i=0;i<e;i++)t[i]=arguments[i];if(Date.now()-yE<100)return void setTimeout(()=>{this.uploadLog(...t);},Date.now()-yE);const n=Math.max(0,Math.min(4,t[0]));t[0]=IE()+" Agora-SDK [".concat(AE(n),"]:"),this.appendLogToWaitingList(n,...t);}appendLogToWaitingList(e){if(!GE("UPLOAD_LOG"))return;for(var t=arguments.length,i=new Array(t>1?t-1:0),n=1;n<t;n++)i[n-1]=arguments[n];Array.isArray(i[0])?i[0][0]=CE()+" Agora-SDK [".concat(AE(e),"]:"):i[0]=CE()+" Agora-SDK [".concat(AE(e),"]:");let r="";i.forEach(e=>{"object"==typeof e&&(e=JSON.stringify(e)),r+="".concat(e," ");}),this.uploadLogWaitingList.push({payload_str:r,log_level:e,log_item_id:this.currentLogID++}),"uploading"===this.uploadState&&0===this.uploadLogUploadingList.length&&this.uploadLogInterval();}startUpload(){this.uploadState="uploading",0===this.uploadLogUploadingList.length&&this.uploadLogInterval();}async uploadLogs(){const e=this.uploadLogUploadingList,t={sdk_version:bE,process_id:GE("PROCESS_ID"),payload:JSON.stringify(e)};return RE(async()=>{const e=await pE.post(this.url||(this.proxyServerURL?"https://".concat(this.proxyServerURL,"/ls/?h=").concat(GE("LOG_UPLOAD_SERVER"),"&p=443&d=upload/v1"):"https://".concat(GE("LOG_UPLOAD_SERVER"),"/upload/v1")),t,{responseType:"text"});if("OK"!==e.data){const t=new Error("unexpected upload log response");throw t.response=e,t}},()=>(this.uploadLogUploadingList=[],!1),e=>(e.response?mE.reportLogUploadError({status:e.response.status,data:e.response.data,headers:e.response.headers,message:e.message}):e.request?mE.reportLogUploadError({status:e.request.status,message:e.message}):mE.reportLogUploadError({status:-1,message:e.message}),!0),{timeout:GE("UPLOAD_LOG_REQUEST_RETRY_INTERVAL"),maxRetryTimeout:GE("UPLOAD_LOG_REQUEST_MAX_RETRY_INTERVAL")})}uploadLogInterval(){0===this.uploadLogUploadingList.length&&0===this.uploadLogWaitingList.length||(0===this.uploadLogUploadingList.length&&(this.uploadLogUploadingList=this.uploadLogWaitingList.splice(0,GE("UPLOAD_LOG_LENGTH_EACH_TIME"))),this.uploadLogs().then(()=>{this.uploadErrorCount=0,this.uploadLogWaitingList.length>0&&window.setTimeout(()=>this.uploadLogInterval(),GE("UPLOAD_LOG_INTERVAL"));}).catch(e=>{this.uploadErrorCount+=1,this.uploadErrorCount<2?window.setTimeout(()=>this.uploadLogInterval(),GE("UPLOAD_LOG_TWICE_RETRY_INTERVAL_V1")):window.setTimeout(()=>this.uploadLogInterval(),GE("UPLOAD_LOG_RETRY_INTERVAL_V1"));}));}},NE="v4.18.2-0-g8d83af1d-dirty(7/11/2023, 7:07:15 PM)",bE=function(e){if(e.match(/[0-9]+\.[0-9]+\.[0-9]+$/))return e;const t=e.match(/([0-9]+\.[0-9]+\.[0-9]+)\-alpha\.([0-9]+)/);if(t&&t[1]&&t[2]){const e=t[1],i=t[2];return "".concat(e,".").concat(i)}const i=e.match(/([0-9]+\.[0-9]+\.[0-9]+)\-special\.([0-9]+)/);if(i&&i[1]&&i[2]){const e=i[1],t=i[2];return "".concat(e,".").concat(100*(Number(t)+1))}return "4.0.0.999"}("4.18.2"),wE=function(){try{return !0===JSON.parse("true")}catch(e){return !0}}(),DE=["CHINA","GLOBAL"],PE=function(){const e="us".concat("erna","me"),t="pa".concat("sswo","rd"),i=["t","s","t"];i.splice(1,0,"e");const n=i.join(""),r=[];for(let e=0;e<6;e++)r.push("1");const o=r.join(""),s={};return s[e]=n,s[t]=o,Object.assign(s,{turnServerURL:"",tcpport:3433,udpport:3478,forceturn:!1})}();window.DEFAULT_TURN_CONFIG=PE;const LE={"90p":YE(160,90),"90p_1":YE(160,90),"120p":YE(160,120,15,30,65),"120p_1":YE(160,120,15,30,65),"120p_3":YE(120,120,15,30,50),"120p_4":YE(212,120),"180p":YE(320,180,15,30,140),"180p_1":YE(320,180,15,30,140),"180p_3":YE(180,180,15,30,100),"180p_4":YE(240,180,15,30,120),"240p":YE(320,240,15,40,200),"240p_1":YE(320,240,15,40,200),"240p_3":YE(240,240,15,40,140),"240p_4":YE(424,240,15,40,220),"360p":YE(640,360,15,80,400),"360p_1":YE(640,360,15,80,400),"360p_3":YE(360,360,15,80,260),"360p_4":YE(640,360,30,80,600),"360p_6":YE(360,360,30,80,400),"360p_7":YE(480,360,15,80,320),"360p_8":YE(480,360,30,80,490),"360p_9":YE(640,360,15,80,800),"360p_10":YE(640,360,24,80,800),"360p_11":YE(640,360,24,80,1e3),"480p":YE(640,480,15,100,500),"480p_1":YE(640,480,15,100,500),"480p_2":YE(640,480,30,100,1e3),"480p_3":YE(480,480,15,100,400),"480p_4":YE(640,480,30,100,750),"480p_6":YE(480,480,30,100,600),"480p_8":YE(848,480,15,100,610),"480p_9":YE(848,480,30,100,930),"480p_10":YE(640,480,10,100,400),"720p":YE(1280,720,15,120,1130),"720p_1":YE(1280,720,15,120,1130),"720p_2":YE(1280,720,30,120,2e3),"720p_3":YE(1280,720,30,120,1710),"720p_5":YE(960,720,15,120,910),"720p_6":YE(960,720,30,120,1380),"1080p":YE(1920,1080,15,120,2080),"1080p_1":YE(1920,1080,15,120,2080),"1080p_2":YE(1920,1080,30,120,3e3),"1080p_3":YE(1920,1080,30,120,3150),"1080p_5":YE(1920,1080,60,120,4780),"1440p":YE(2560,1440,30,120,4850),"1440p_1":YE(2560,1440,30,120,4850),"1440p_2":YE(2560,1440,60,120,7350),"4k":YE(3840,2160,30,120,8910),"4k_1":YE(3840,2160,30,120,8910),"4k_3":YE(3840,2160,60,120,13500)},kE={"480p":qE(640,480,5),"480p_1":qE(640,480,5),"480p_2":qE(640,480,30),"480p_3":qE(640,480,15),"720p":qE(1280,720,5),"720p_1":qE(1280,720,5),"720p_2":qE(1280,720,30),"720p_3":qE(1280,720,15),"1080p":qE(1920,1080,5),"1080p_1":qE(1920,1080,5),"1080p_2":qE(1920,1080,30),"1080p_3":qE(1920,1080,15)},ME={"1SL1TL":JE(1,1),"3SL3TL":JE(3,3),"2SL3TL":JE(2,3)};function UE(e){return e||(e="480p_1"),"string"==typeof e?Object.assign({},LE[e]):e}function xE(e){return "string"==typeof e?Object.assign({},kE[e]):e}function VE(e){return "string"==typeof e?Object.assign({},ME[e]):e}const jE={speech_low_quality:KE(16e3,!1),speech_standard:KE(32e3,!1,18),music_standard:KE(48e3,!1),standard_stereo:KE(48e3,!0,56),high_quality:KE(48e3,!1,128),high_quality_stereo:KE(48e3,!0,192)};function FE(e){return "string"==typeof e?Object.assign({},jE[e]):e}function BE(e,t,i){Object.keys(WE).includes(e)&&(!i&&Object.keys(HE).includes(e)||(WE[e]=t));}function GE(e){return WE[e]}const WE={PROCESS_ID:"",ENCRYPT_AES:!0,AREAS:DE,WEBCS_DOMAIN:["webrtc2-ap-web-1.agora.io","webrtc2-2.ap.sd-rtn.com"],WEBCS_DOMAIN_BACKUP_LIST:["webrtc2-ap-web-3.agora.io","webrtc2-4.ap.sd-rtn.com"],PROXY_CS:["ap-proxy-1.agora.io","ap-proxy-2.agora.io"],CDS_AP:["cds-ap-web-1.agora.io","cds-web-2.ap.sd-rtn.com","cds-ap-web-3.agora.io","cds-web-4.ap.sd-rtn.com"],ACCOUNT_REGISTER:["sua-ap-web-1.agora.io","sua-web-2.ap.sd-rtn.com","sua-ap-web-3.agora.io","sua-web-4.ap.sd-rtn.com"],UAP_AP:["uap-ap-web-1.agora.io","uap-web-2.ap.sd-rtn.com","uap-ap-web-3.agora.io","uap-web-4.ap.sd-rtn.com"],LOG_UPLOAD_SERVER:"logservice.agora.io",EVENT_REPORT_DOMAIN:"statscollector-1.agora.io",EVENT_REPORT_BACKUP_DOMAIN:"web-2.statscollector.sd-rtn.com",ENABLE_EVENT_REPORT:!0,GATEWAY_ADDRESS:[],GATEWAY_WSS_ADDRESS:"",LIVE_STREAMING_ADDRESS:"",HTTP_CONNECT_TIMEOUT:5e3,SIGNAL_REQUEST_TIMEOUT:1e4,REPORT_STATS:!0,UPLOAD_LOG:!1,NOT_REPORT_EVENT:[],SUBSCRIBE_TWCC:!1,PUBLISH_TWCC:!1,PING_PONG_TIME_OUT:10,WEBSOCKET_TIMEOUT_MIN:1e4,EVENT_REPORT_SEND_INTERVAL:3e3,CONFIG_DISTRIBUTE_INTERVAL:3e5,ENABLE_CONFIG_DISTRIBUTE:!0,CANDIDATE_TIMEOUT:5e3,SHOW_REPORT_INVOKER_LOG:!1,JOIN_EXTEND:"",PUB_EXTEND:"",SUB_EXTEND:"",FORCE_TURN:!1,TURN_ENABLE_TCP:!0,TURN_ENABLE_UDP:!0,MAX_UPLOAD_CACHE:50,UPLOAD_CACHE_INTERVAL:2e3,AJAX_REQUEST_CONCURRENT:3,REPORT_APP_SCENARIO:void 0,GATEWAY_DOMAINS:["edge.agora.io","edge.sd-rtn.com"],WORKER_DOMAIN:"edge.agora.io",TURN_DOMAIN:"edge.agora.io",EVENT_REPORT_RETRY:!0,CHROME_FORCE_PLAN_B:!1,AUDIO_SOURCE_VOLUME_UPDATE_INTERVAL:400,AUDIO_SOURCE_AVG_VOLUME_DURATION:3e3,AUDIO_VOLUME_INDICATION_INTERVAL:2e3,VOLUME_VOICE_WEIGHT:10,GET_VOLUME_OF_MUTED_AUDIO_TRACK:!1,STATS_UPDATE_INTERVAL:250,NORMAL_EVENT_QUEUE_CAPACITY:100,CUSTOM_REPORT:!0,CUSTOM_REPORT_LIMIT:20,PROXY_SERVER_TYPE2:"webnginx-proxy.agora.io",PROXY_SERVER_TYPE3:["webrtc-cloud-proxy.sd-rtn.com","webrtc-cloud-proxy.agora.io"],CUSTOM_PUB_ANSWER_MODIFIER:null,CUSTOM_SUB_ANSWER_MODIFIER:null,CUSTOM_PUB_OFFER_MODIFIER:null,CUSTOM_SUB_OFFER_MODIFIER:null,DSCP_TYPE:"high",REMOVE_NEW_CODECS:!0,FRAGEMENT_LENGTH:3,WEBSOCKET_COMPRESS:!1,SIMULCAST:!1,PRELOAD_MEDIA_COUNT:0,USE_PUB_RTX:!1,USE_SUB_RTX:!1,CHECK_VIDEO_VISIBLE_INTERVAL:3e4,ENUMERATE_DEVICES_INTERVAL:!1,ENUMERATE_DEVICES_INTERVAL_TIME:1e4,USE_NEW_TOKEN:!1,CLOSE_AFB_FOR_LOCAL_AP:!0,JOIN_WITH_FALLBACK_SIGNAL_PROXY:!0,JOIN_WITH_FALLBACK_MEDIA_PROXY:!0,JOIN_WITH_FALLBACK_MEDIA_PROXY_FORCE:!1,JOIN_WITH_FALLBACK_PROXY_PENDING_DURATION:2e3,USE_TURN_SERVER_OF_GATEWAY:!1,H264_PROFILE_LEVEL_ID:"",USE_NEW_LOG:!1,LOG_VERSION:3,MEDIA_DEVICE_CONSTRAINTS:null,ENCRYPT_PROXY_USERNAME_AND_PSW:!0,SDP_LOGGING:!1,CSP_DETECTED_HOSTNAME_LIST:["agora.io","sd-rtn.com"],REMOTE_AUDIO_TRACK_USES_WEB_AUDIO:!1,LOCAL_AUDIO_TRACK_USES_WEB_AUDIO:!0,BITRATE_ADAPTER_TYPE:"STANDARD_BITRATE",AI_DENOISER_PARAMETERS:{},ADJUST_3A_FROM_PLUGINS:!0,RAISE_H264_BASELINE_PRIORITY:!0,FILTER_SEND_H264_BASELINE:!1,ENABLE_PUBLISHED_USER_LIST:!0,MAX_SUBSCRIPTION:50,X_GOOGLE_START_BITRATE:void 0,NEW_REPORT_SERVER:!1,NEW_REPORT_SERVER_DOMAINS:["data-reporting.agora.io","data-reporting.agora.io"],VIDEO_INSPECT_WORKER_MESSAGE_LENGTH_LIMIT:3e5,VIDEO_INSPECT_INTERVAL_MINIMUM:1e3,VIDEO_INSPECT_QUALITY_RATIO:.9,VIDEO_INSPECT_WORKER_MANAGER_HOST:"edge.agora.io",VIDEO_INSPECT_WORKER_MANAGER_PORT:"",VIDEO_INSPECT_WORKER_PORT:"",SHOW_VIDEO_INSPECT_WORKER_MESSAGE:!1,STATS_COLLECTOR_PORT:443,FORCE_TURN_TCP:!1,SUBSCRIBE_AUDIO_FILTER_TOPN:void 0,ENABLE_PUBLISH_AUDIO_FILTER:void 0,WEBAUDIO_INIT_OPTIONS:void 0,FILTER_VIDEO_FEC:!0,FILTER_AUDIO_FEC:!1,CHROME_DUAL_STREAM_USE_ENCODING:!0,EXTENSION_USAGE_UPLOAD_INTERVAL:1e4,ICE_RESTART:!0,ICE_RESTART_INTERVAL:1e4,NEW_ICE_RESTART:!1,ENABLE_USER_LICENSE_CHECK:!0,SIGNAL_CHANNEL:0,TRANSMITTER_INITIAL_RTT:30,TRANSMITTER_INITIAL_RTO:30,TRANSMITTER_MAX_BATCH_ACK_COUNT:2,TRANSMITTER_MAX_RTO:500,DATACHANNEL_COMPRESS:!1,FINGERPRINT:null,DC_JOIN_WITH_FAILBACK:5e3,ENABLE_VIDEO_FRAME_CALLBACK:!0,VIDEO_FREEZE_DURATION:500,SPATIALIZER_PARAMETERS:{},UPLOAD_LOG_INTERVAL:3e3,UPLOAD_LOG_REQUEST_RETRY_INTERVAL:2e3,UPLOAD_LOG_REQUEST_MAX_RETRY_INTERVAL:2e4,UPLOAD_LOG_TRY_INTERVAL_WHILE_OFF:5e3,UPLOAD_LOG_RETRY_INTERVAL_V1:1e4,UPLOAD_LOG_TWICE_RETRY_INTERVAL_V1:200,UPLOAD_LOG_LENGTH_EACH_TIME:10,APP_TYPE:0,DISABLE_WEBAUDIO:!1,CHANNEL_MEDIA_RELAY_SERVERS:void 0,KEEP_LAST_FRAME:!0,FORWARD_P2P_CREATION:!0,SYNC_GROUP:!0,BLOCK_LOCAL_CLIENT:!1,AP_AREA:!0,SVC:[],ENABLE_ENCODED_TRANSFORM:!1,IMAGE_MODERATION_WORKER_HOST:"edge.agora.io",IMAGE_MODERATION_WORKER_MESSAGE_LENGTH_LIMIT:3e5,IMAGE_MODERATION_INTERVAL_MINIMUM:1e3,SHOW_IMAGE_MODERATION_WORKER_MESSAGE:!1,IMAGE_MODERATION_QUALITY_RATIO:.9,IMAGE_MODERATION_UPLOAD_REPORT_INTERVAL:5e3,ACCOUNT_REGISTER_RETRY_TIMEOUT:1,ACCOUNT_REGISTER_RETRY_RATIO:2,ACCOUNT_REGISTER_RETRY_TIMEOUT_MAX:6e4,ACCOUNT_REGISTER_RETRY_COUNT_MAX:1e5,AUDIO_CONTEXT:null,WEBCS_BACKUP_CONNECT_TIMEOUT:6e3,PLAYER_STATE_DEFER:2e3,SIGNAL_REQUEST_WATCH_INTERVAL:1e3,FILEPATH_LENMAX:255,DUALSTREAM_OPERATION_CHECK:!0,MEDIA_ELEMENT_EXISTS_DEPTH:3,SHIM_CANDIDATE:!1,LEAVE_MSG_TIMEOUT:2e3,STATS_FILTER:{transportId:!0,googTrackId:!0}},HE={};function KE(e,t,i){return {sampleRate:e,stereo:t,bitrate:i}}function YE(e,t,i,n,r){return {width:e,height:t,frameRate:i,bitrateMin:n,bitrateMax:r}}function qE(e,t,i,n,r){return {width:{max:e},height:{max:t},frameRate:i,bitrateMin:n,bitrateMax:r}}function JE(e,t){return {numSpatialLayers:e,numTemporalLayers:t}}wE||(WE.WEBCS_DOMAIN=["ap-web-1-oversea.agora.io","ap-web-1-north-america.agora.io"],WE.WEBCS_DOMAIN_BACKUP_LIST=["ap-web-2-oversea.agora.io","ap-web-2-north-america.agora.io"],WE.PROXY_CS=["proxy-ap-web-oversea.agora.io","proxy-ap-web-america.agora.io"],WE.CDS_AP=["cds-ap-web-oversea.agora.io","cds-ap-web-america.agora.io","cds-ap-web-america2.agora.io"],WE.ACCOUNT_REGISTER=["sua-ap-web-oversea.agora.io","sua-ap-web-america.agora.io","sua-ap-web-america2.agora.io"],WE.UAP_AP=["uap-ap-web-oversea.agora.io","uap-ap-web-america.agora.io","uap-ap-web-america2.agora.io"],WE.LOG_UPLOAD_SERVER="logservice-oversea.agora.io",WE.EVENT_REPORT_DOMAIN="statscollector-1-oversea.agora.io",WE.EVENT_REPORT_BACKUP_DOMAIN="statscollector-2-oversea.agora.io",WE.PROXY_SERVER_TYPE3="webrtc-cloud-proxy.agora.io",WE.AREAS=["NORTH_AMERICA","OVERSEA"]);const XE=[[0,1,2,3,4,5,5],[0,2,2,3,4,5,5],[0,3,3,3,4,5,5],[0,4,4,4,4,5,5],[0,5,5,5,5,5,5]],zE=[],QE=[];function ZE(e,t){return !!t&&zE.some(i=>i.uid===e&&i.channelName===t)}var $E=Et,em=Ht,tm=w,im=function(e,t,i){var n=$E(t);n in e?em.f(e,n,tm(0,i)):e[n]=i;},nm=Un,rm=bi,om=im,sm=h.Array,am=Math.max,cm=function(e,t,i){for(var n=rm(e),r=nm(t,n),o=nm(void 0===i?n:i,n),s=sm(am(o-r,0)),a=0;r<o;r++,a++)om(s,a,e[r]);return s.length=a,s},dm=cm,um=Math.floor,lm=function(e,t){var i=e.length,n=um(i/2);return i<8?hm(e,t):pm(e,lm(dm(e,0,n),t),lm(dm(e,n),t),t)},hm=function(e,t){for(var i,n,r=e.length,o=1;o<r;){for(n=o,i=e[o];n&&t(e[n-1],i)>0;)e[n]=e[--n];n!==o++&&(e[n]=i);}return e},pm=function(e,t,i,n){for(var r=t.length,o=i.length,s=0,a=0;s<r||a<o;)e[s+a]=s<r&&a<o?n(t[s],i[a])<=0?t[s++]:i[a++]:s<r?t[s++]:i[a++];return e},_m=lm,Em=ee.match(/firefox\/(\d+)/i),mm=!!Em&&+Em[1],fm=/MSIE|Trident/.test(ee),Sm=ee.match(/AppleWebKit\/(\d+)\./),Tm=!!Sm&&+Sm[1],gm=Ii,Rm=d,Im=Ce,Cm=je,vm=bi,ym=wo,Am=i,Om=_m,Nm=Vi,bm=mm,wm=fm,Dm=ae,Pm=Tm,Lm=[],km=Rm(Lm.sort),Mm=Rm(Lm.push),Um=Am((function(){Lm.sort(void 0);})),xm=Am((function(){Lm.sort(null);})),Vm=Nm("sort"),jm=!Am((function(){if(Dm)return Dm<70;if(!(bm&&bm>3)){if(wm)return !0;if(Pm)return Pm<603;var e,t,i,n,r="";for(e=65;e<76;e++){switch(t=String.fromCharCode(e),e){case 66:case 69:case 70:case 72:i=3;break;case 68:case 71:i=4;break;default:i=2;}for(n=0;n<47;n++)Lm.push({k:t+n,v:i});}for(Lm.sort((function(e,t){return t.v-e.v})),n=0;n<Lm.length;n++)t=Lm[n].k.charAt(0),r.charAt(r.length-1)!==t&&(r+=t);return "DGBEFHACIJK"!==r}}));gm({target:"Array",proto:!0,forced:Um||!xm||!Vm||!jm},{sort:function(e){void 0!==e&&Im(e);var t=Cm(this);if(jm)return void 0===e?km(t):km(t,e);var i,n,r=[],o=vm(t);for(n=0;n<o;n++)n in t&&Mm(r,t[n]);for(Om(r,function(e){return function(t,i){return void 0===i?-1:void 0===t?1:void 0!==e?+e(t,i)||0:ym(t)>ym(i)?1:-1}}(e)),i=r.length,n=0;n<i;)t[n]=r[n++];for(;n<o;)delete t[n++];return t}});var Fm=Hi("Array").sort,Bm=u,Gm=Fm,Wm=Array.prototype,Hm=function(e){var t=e.sort;return e===Wm||Bm(Wm,e)&&t===Wm.sort?Gm:t};function Km(e,t){if("boolean"!=typeof e)throw new SE(fE.INVALID_PARAMS,"Invalid ".concat(t,": The value is of the boolean type."))}function Ym(e,t,i){if(i.includes(e))return;throw new SE(fE.INVALID_PARAMS,"".concat(t," can only be set as ").concat(JSON.stringify(i)))}function qm(e,t){let i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1e4,r=!(arguments.length>4&&void 0!==arguments[4])||arguments[4];if(e<i||e>n||r&&!tf(e)){throw new SE(fE.INVALID_PARAMS,"invalid ".concat(t,": the value range is [").concat(i,", ").concat(n,"]. integer only"))}}function Jm(e,t){if("number"!=typeof e){if(!(e.min||e.max||e.ideal||e.exact)){throw new SE(fE.INVALID_PARAMS,"".concat(t," is not a valid ConstrainLong"))}void 0!==e.min&&qm(e.min,"".concat(t,".min"),0,1/0),void 0!==e.max&&qm(e.max,"".concat(t,".max"),1,1/0),void 0!==e.exact&&qm(e.exact,"".concat(t,".exact"),1,1/0),void 0!==e.ideal&&qm(e.ideal,"".concat(t,".ideal"),1,1/0);}else qm(e,t,1,1/0);}function Xm(e,t){let i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:255,r=!(arguments.length>4&&void 0!==arguments[4])||arguments[4];if(null==e)throw new SE(fE.INVALID_PARAMS,"".concat(t||"param"," cannot be empty"));if(!ef(e,i,n,r))throw new SE(fE.INVALID_PARAMS,"Invalid ".concat(t||"string param",": Length of the string: [").concat(i,",").concat(n,"].").concat(r?" ASCII characters only.":""))}function zm(e,t){if(!Array.isArray(e))throw new SE(fE.INVALID_PARAMS,"".concat(t," should be an array"))}function Qm(e){if("string"!=typeof e||!/^[a-zA-Z0-9 \!\#\$\%\&\(\)\+\-\:\;\<\=\.\>\?\@\[\]\^\_\{\}\|\~\,]{1,64}$/.test(e))throw OE.error("Invalid Channel Name ".concat(e)),new SE(fE.INVALID_PARAMS,"The length must be within 64 bytes. The supported characters: a-z,A-Z,0-9,space,!, #, $, %, &, (, ), +, -, :, ;, <, =, ., >, ?, @, [, ], ^, _,  {, }, |, ~, ,")}function Zm(e){if(!(t=e,"number"==typeof t&&Math.floor(t)===t&&0<=t&&t<=4294967295||ef(e,1,255)))throw OE.error("Invalid UID ".concat(e," ").concat(typeof e)),new SE(fE.INVALID_PARAMS,"[String uid] Length of the string: [1,255]. ASCII characters only. [Number uid] The value range is [0,10000]");var t;"string"==typeof e&&OE.warning("You input a string as the user ID, to ensure better end-user experience, Agora highly suggests not using a string as the user ID.");}function $m(e){return null==e}function ef(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:255,n=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];return "string"==typeof e&&e.length<=i&&e.length>=t&&(!n||nf(e))}function tf(e){return "number"==typeof e&&e%1==0}function nf(e){if("string"!=typeof e)return !1;for(let t=0;t<e.length;t+=1){const i=e.charCodeAt(t);if(i<0||i>255)return !1}return !0}let rf,of,sf;!function(e){e.FREE="free",e.UPLOADING="uploading";}(rf||(rf={})),function(e){e[e.MISC=0]="MISC",e[e.INTERNAL_EVENT=1]="INTERNAL_EVENT",e[e.PUBLIC_EVENT=2]="PUBLIC_EVENT",e[e.WEB_EVENT=3]="WEB_EVENT",e[e.INTERNAL_API=4]="INTERNAL_API",e[e.WEB_API=5]="WEB_API",e[e.PUBLIC_API=6]="PUBLIC_API";}(of||(of={})),function(e){e.NONE="none",e.INIT="init",e.CANPLAY="canplay",e.PLAYING="playing",e.PAUSED="paused",e.SUSPEND="suspend",e.STALLED="stalled",e.WAITING="waiting",e.ERROR="error",e.DESTROYED="destroyed",e.ABORT="abort",e.ENDED="ended",e.EMPTIED="emptied",e.LOADEDDATA="loadeddata";}(sf||(sf={}));const af={uninit:100,none:110,init:120,loadeddata:130,canplay:200,playing:210,paused:220,suspend:300,stalled:310,waiting:320,error:330,destroyed:340,abort:350,ended:360,emptied:370};function cf(e){return Xm(e.reportId,"params.reportId",0,100,!1),Xm(e.category,"params.category",0,100,!1),Xm(e.event,"params.event",0,100,!1),Xm(e.label,"params.label",0,100,!1),qm(e.value,"params.value",Number.MIN_SAFE_INTEGER,Number.MAX_SAFE_INTEGER,!1),!0}const df={sid:"",lts:0,success:null,cname:null,uid:null,peer:null,cid:null,elapse:null,extend:null,vid:0};let uf,lf,hf,pf,_f,Ef,mf,ff,Sf,Tf,gf,Rf,If,Cf,vf,yf,Af,Of,Nf,bf,wf,Df,Pf,Lf;function kf(e){return qm(e.timeout,"config.timeout",0,1e5),qm(e.timeoutFactor,"config.timeoutFactor",0,100,!1),qm(e.maxRetryCount,"config.maxRetryConfig",0,1/0),qm(e.maxRetryTimeout,"config.maxRetryTimeout",0,1/0),!0}function Mf(e){return Ym(e.codec,"config.codec",["vp8","vp9","av1","h264","h265"]),Ym(e.mode,"config.mode",["rtc","live"]),void 0!==e.audioCodec&&Ym(e.audioCodec,"config.audioCodec",["opus","pcmu","pcma","g722"]),void 0!==e.proxyServer&&Xm(e.proxyServer,"config.proxyServer",1,1e4),void 0!==e.turnServer&&xf(e.turnServer),void 0!==e.httpRetryConfig&&kf(e.httpRetryConfig),void 0!==e.websocketRetryConfig&&kf(e.websocketRetryConfig),!0}function Uf(e){if(!Array.isArray(e)||e.length<1)return !1;try{e.forEach(e=>{if(!e.urls)throw Error()});}catch(e){return !1}return !0}function xf(e){return Xm(e.turnServerURL,"turnServerURL"),Xm(e.username,"username"),Xm(e.password,"password"),e.udpport&&qm(e.udpport,"udpport",1,99999,!0),e.forceturn&&Km(e.forceturn,"forceturn"),e.security&&Km(e.security,"security"),e.tcpport&&qm(e.tcpport,"tcpport",1,99999,!0),!0}function Vf(e){return void 0!==e.level&&Ym(e.level,"level",[1,2,3]),!0}!function(e){e.PUBLISH="publish",e.SUBSCRIBE="subscribe",e.WS_COMPRESSOR_INIT="ws_compressor_init",e.SESSION_INIT="session_init",e.JOIN_CHOOSE_SERVER="join_choose_server",e.REQ_USER_ACCOUNT="req_user_account",e.JOIN_GATEWAY="join_gateway",e.REJOIN_GATEWAY="rejoin_gateway",e.STREAM_SWITCH="stream_switch",e.REQUEST_PROXY_WORKER_MANAGER="request_proxy_worker_manager",e.REQUEST_PROXY_APPCENTER="request_proxy_appcenter",e.FIRST_VIDEO_RECEIVED="first_video_received",e.FIRST_AUDIO_RECEIVED="first_audio_received",e.FIRST_VIDEO_DECODE="first_video_decode",e.FIRST_AUDIO_DECODE="first_audio_decode",e.ON_ADD_AUDIO_STREAM="on_add_audio_stream",e.ON_ADD_VIDEO_STREAM="on_add_video_stream",e.ON_UPDATE_STREAM="on_update_stream",e.ON_REMOVE_STREAM="on_remove_stream",e.USER_ANALYTICS="req_user_analytics",e.PC_STATS="pc_stats";}(uf||(uf={})),function(e){e.SESSION="io.agora.pb.Wrtc.Session",e.JOIN_CHOOSE_SERVER="io.agora.pb.Wrtc.JoinChooseServer",e.REQ_USER_ACCOUNT="io.agora.pb.Wrtc.ReqUserAccount",e.JOIN_GATEWAY="io.agora.pb.Wrtc.JoinGateway",e.RE_JOIN_GATEWAY="io.agora.pb.Wrtc.ReJoinGateway",e.PUBLISH="io.agora.pb.Wrtc.Publish",e.SUBSCRIBE="io.agora.pb.Wrtc.Subscribe",e.WS_COMPRESSOR_INIT="io.agora.pb.Wrtc.WsCompressorInit",e.STREAM_SWITCH="io.agora.pb.Wrtc.StreamSwitch",e.AUDIO_SENDING_STOPPED="io.agora.pb.Wrtc.AudioSendingStopped",e.VIDEO_SENDING_STOPPED="io.agora.pb.Wrtc.VideoSendingStopped",e.REQUEST_PROXY_APPCENTER="io.agora.pb.Wrtc.RequestProxyAppCenter",e.REQUEST_PROXY_WORKER_MANAGER="io.agora.pb.Wrtc.RequestProxyWorkerManager",e.API_INVOKE="io.agora.pb.Wrtc.ApiInvoke",e.FIRST_VIDEO_RECEIVED="io.agora.pb.Wrtc.FirstVideoReceived",e.FIRST_AUDIO_RECEIVED="io.agora.pb.Wrtc.FirstAudioReceived",e.FIRST_VIDEO_DECODE="io.agora.pb.Wrtc.FirstVideoDecode",e.FIRST_AUDIO_DECODE="io.agora.pb.Wrtc.FirstAudioDecode",e.ON_ADD_AUDIO_STREAM="io.agora.pb.Wrtc.OnAddAudioStream",e.ON_ADD_VIDEO_STREAM="io.agora.pb.Wrtc.OnAddVideoStream",e.ON_UPDATE_STREAM="io.agora.pb.Wrtc.OnUpdateStream",e.ON_REMOVE_STREAM="io.agora.pb.Wrtc.OnRemoveStream",e.JOIN_CHANNEL_TIMEOUT="io.agora.pb.Wrtc.JoinChannelTimeout",e.PEER_PUBLISH_STATUS="io.agora.pb.Wrtc.PeerPublishStatus",e.WORKER_EVENT="io.agora.pb.Wrtc.WorkerEvent",e.AP_WORKER_EVENT="io.agora.pb.Wrtc.APWorkerEvent",e.JOIN_WEB_PROXY_AP="io.agora.pb.Wrtc.JoinWebProxyAP",e.WEBSOCKET_QUIT="io.agora.pb.Wrtc.WebSocketQuit",e.USER_ANALYTICS="io.agora.pb.Wrtc.UserAnalytics",e.AUTOPLAY_FAILED="io.agora.pb.Wrtc.AutoplayFailed",e.PC_STATS="io.agora.pb.Wrtc.PCStats";}(lf||(lf={})),function(e){e[e.WORKER_EVENT=156]="WORKER_EVENT",e[e.AP_WORKER_EVENT=160]="AP_WORKER_EVENT";}(hf||(hf={})),function(e){e[e.SESSION=26]="SESSION",e[e.JOIN_CHOOSE_SERVER=27]="JOIN_CHOOSE_SERVER",e[e.REQ_USER_ACCOUNT=196]="REQ_USER_ACCOUNT",e[e.JOIN_GATEWAY=28]="JOIN_GATEWAY",e[e.PUBLISH=30]="PUBLISH",e[e.SUBSCRIBE=29]="SUBSCRIBE",e[e.WS_COMPRESSOR_INIT=9430]="WS_COMPRESSOR_INIT",e[e.STREAM_SWITCH=32]="STREAM_SWITCH",e[e.AUDIO_SENDING_STOPPED=33]="AUDIO_SENDING_STOPPED",e[e.VIDEO_SENDING_STOPPED=34]="VIDEO_SENDING_STOPPED",e[e.REQUEST_PROXY_APPCENTER=35]="REQUEST_PROXY_APPCENTER",e[e.REQUEST_PROXY_WORKER_MANAGER=36]="REQUEST_PROXY_WORKER_MANAGER",e[e.API_INVOKE=41]="API_INVOKE",e[e.FIRST_VIDEO_RECEIVED=348]="FIRST_VIDEO_RECEIVED",e[e.FIRST_AUDIO_RECEIVED=349]="FIRST_AUDIO_RECEIVED",e[e.FIRST_VIDEO_DECODE=350]="FIRST_VIDEO_DECODE",e[e.FIRST_AUDIO_DECODE=351]="FIRST_AUDIO_DECODE",e[e.ON_ADD_AUDIO_STREAM=352]="ON_ADD_AUDIO_STREAM",e[e.ON_ADD_VIDEO_STREAM=353]="ON_ADD_VIDEO_STREAM",e[e.ON_UPDATE_STREAM=356]="ON_UPDATE_STREAM",e[e.ON_REMOVE_STREAM=355]="ON_REMOVE_STREAM",e[e.JOIN_CHANNEL_TIMEOUT=407]="JOIN_CHANNEL_TIMEOUT",e[e.PEER_PUBLISH_STATUS=408]="PEER_PUBLISH_STATUS",e[e.WORKER_EVENT=156]="WORKER_EVENT",e[e.AP_WORKER_EVENT=160]="AP_WORKER_EVENT",e[e.JOIN_WEB_PROXY_AP=700]="JOIN_WEB_PROXY_AP",e[e.WEBSOCKET_QUIT=671]="WEBSOCKET_QUIT",e[e.USER_ANALYTICS=1e4]="USER_ANALYTICS",e[e.AUTOPLAY_FAILED=9178]="AUTOPLAY_FAILED";}(pf||(pf={})),function(e){e.CREATE_CLIENT="createClient",e.CHECK_SYSTEM_REQUIREMENTS="checkSystemRequirements",e.SET_AREA="setArea",e.CHECK_VIDEO_TRACK_IS_ACTIVE="checkVideoTrackIsActive",e.CHECK_AUDIO_TRACK_IS_ACTIVE="checkAudioTrackIsActive",e.CREATE_MIC_AUDIO_TRACK="createMicrophoneAudioTrack",e.CREATE_CUSTOM_AUDIO_TRACK="createCustomAudioTrack",e.CREATE_BUFFER_AUDIO_TRACK="createBufferSourceAudioTrack",e.CREATE_CAM_VIDEO_TRACK="createCameraVideoTrack",e.CREATE_CUSTOM_VIDEO_TRACK="createCustomVideoTrack",e.CREATE_MIC_AND_CAM_TRACKS="createMicrophoneAndCameraTracks",e.CREATE_SCREEN_VIDEO_TRACK="createScreenVideoTrack",e.SET_ENCRYPTION_CONFIG="Client.setEncryptionConfig",e.START_PROXY_SERVER="Client.startProxyServer",e.STOP_PROXY_SERVER="Client.stopProxyServer",e.SET_PROXY_SERVER="Client.setProxyServer",e.SET_TURN_SERVER="Client.setTurnServer",e.SET_CLIENT_ROLE="Client.setClientRole",e.SET_LOW_STREAM_PARAMETER="Client.setLowStreamParameter",e.ENABLE_DUAL_STREAM="Client.enableDualStream",e.DISABLE_DUAL_STREAM="Client.disableDualStream",e.JOIN="Client.join",e.LEAVE="Client.leave",e.PUBLISH="Client.publish",e.UNPUBLISH="Client.unpublish",e.SUBSCRIBE="Client.subscribe",e.MASS_SUBSCRIBE="Client.massSubscribe",e.MASS_UNSUBSCRIBE="Client.massUnsubscribe",e.UNSUBSCRIBE="Client.unsubscribe",e.RENEW_TOKEN="Client.renewToken",e.SET_REMOTE_VIDEO_STREAM_TYPE="Client.setRemoteVideoStreamType",e.SET_STREAM_FALLBACK_OPTION="Client.setStreamFallbackOption",e.ENABLE_AUDIO_VOLUME_INDICATOR="Client.enableAudioVolumeIndicator",e.SEND_CUSTOM_REPORT_MESSAGE="Client.sendCustomReportMessage",e.INSPECT_VIDEO_CONTENT="Client.inspectVideoContent",e.STOP_INSPECT_VIDEO_CONTENT="Client.stopInspectVideoContent",e.JOIN_FALLBACK_TO_PROXY="Client._joinFallbackToProxy",e.DATACHANNEL_FAILBACK="Client._datachannelFailback",e.ON_LIVE_STREAM_WARNING="Client.onLiveStreamWarning",e.ON_LIVE_STREAM_ERROR="Client.onLiveStreamingError",e.START_LIVE_STREAMING="Client.startLiveStreaming",e.SET_LIVE_TRANSCODING="Client.setLiveTranscoding",e.STOP_LIVE_STREAMING="Client.stopLiveStreaming",e.ADD_INJECT_STREAM_URL="Client.addInjectStreamUrl",e.REMOVE_INJECT_STREAM_URL="Client.removeInjectStreamUrl",e.START_CHANNEL_MEDIA_RELAY="Client.startChannelMediaRelay",e.UPDATE_CHANNEL_MEDIA_RELAY="Client.updateChannelMediaRelay",e.STOP_CHANNEL_MEDIA_RELAY="Client.stopChannelMediaRelay",e.REQUEST_CONFIG_DISTRIBUTE="_config-distribute-request",e.SET_CONFIG_DISTRIBUTE="_configDistribute",e.LOCAL_TRACK_SET_MUTED="LocalTrack.setMute",e.LOCAL_AUDIO_TRACK_PLAY="LocalAudioTrack.play",e.LOCAL_AUDIO_TRACK_PLAY_IN_ELEMENT="LocalAudioTrack.playInElement",e.LOCAL_AUDIO_TRACK_STOP="LocalAudioTrack.stop",e.LOCAL_AUDIO_TRACK_SET_VOLUME="LocalAudioTrack.setVolume",e.MIC_AUDIO_TRACK_SET_DEVICE="MicrophoneAudioTrack.setDevice",e.BUFFER_AUDIO_TRACK_START="BufferSourceAudioTrack.startProcessAudioBuffer",e.BUFFER_AUDIO_TRACK_STOP="BufferSourceAudioTrack.stopProcessAudioBuffer",e.BUFFER_AUDIO_TRACK_PAUSE="BufferSourceAudioTrack.pauseProcessAudioBuffer",e.BUFFER_AUDIO_TRACK_RESUME="BufferSourceAudioTrack.resumeProcessAudioBuffer",e.BUFFER_AUDIO_TRACK_SEEK="BufferSourceAudioTrack.seekAudioBuffer",e.LOCAL_VIDEO_TRACK_PLAY="LocalVideoTrack.play",e.LOCAL_VIDEO_TRACK_STOP="LocalVideoTrack.stop",e.LOCAL_VIDEO_TRACK_GET_VIDEO_VISIBLE="LocalVideoTrack.getVideoElementVisibleStatus",e.LOCAL_VIDEO_TRACK_BEAUTY="LocalVideoTrack.setBeautyEffect",e.CAM_VIDEO_TRACK_SET_DEVICE="CameraVideoTrack.setDevice",e.CAM_VIDEO_TRACK_SET_ENCODER_CONFIG="CameraVideoTrack.setEncoderConfiguration",e.REMOTE_VIDEO_TRACK_PLAY="RemoteVideoTrack.play",e.REMOTE_VIDEO_TRACK_STOP="RemoteVideoTrack.stop",e.REMOTE_VIDEO_TRACK_GET_VIDEO_VISIBLE="RemoteVideoTrack.getVideoElementVisibleStatus",e.REMOTE_AUDIO_TRACK_PLAY="RemoteAudioTrack.play",e.REMOTE_AUDIO_TRACK_STOP="RemoteAudioTrack.stop",e.REMOTE_AUDIO_SET_VOLUME="RemoteAudioTrack.setVolume",e.REMOTE_AUDIO_SET_OUTPUT_DEVICE="RemoteAudioTrack.setOutputDevice",e.GET_MEDIA_STREAM_TRACK="Track.getMediaStreamTrack",e.STREAM_TYPE_CHANGE="streamTypeChange",e.CONNECTION_STATE_CHANGE="connectionStateChange",e.LOAD_CONFIG_FROM_LOCALSTORAGE="loadConfigFromLocalStorage",e.IMAGE_MODERATION_UPLOAD="imageModerationUpload";}(_f||(_f={})),function(e){e.TRACER="tracer";}(Ef||(Ef={})),function(e){e.IDLE="IDLE",e.INITING="INITING",e.INITEND="INITEND";}(mf||(mf={})),function(e){e.STATE_CHANGE="state_change",e.RECORDING_DEVICE_CHANGED="recordingDeviceChanged",e.PLAYOUT_DEVICE_CHANGED="playoutDeviceChanged",e.CAMERA_DEVICE_CHANGED="cameraDeviceChanged";}(ff||(ff={})),function(e){e[e.ACCESS_POINT=101]="ACCESS_POINT",e[e.UNILBS=201]="UNILBS",e[e.STRING_UID_ALLOCATOR=901]="STRING_UID_ALLOCATOR";}(Sf||(Sf={})),function(e){e[e.IIIEGAL_APPID=1]="IIIEGAL_APPID",e[e.IIIEGAL_UID=2]="IIIEGAL_UID",e[e.INTERNAL_ERROR=3]="INTERNAL_ERROR";}(Tf||(Tf={})),function(e){e[e.INVALID_VENDOR_KEY=5]="INVALID_VENDOR_KEY",e[e.INVALID_CHANNEL_NAME=7]="INVALID_CHANNEL_NAME",e[e.INTERNAL_ERROR=8]="INTERNAL_ERROR",e[e.NO_AUTHORIZED=9]="NO_AUTHORIZED",e[e.DYNAMIC_KEY_TIMEOUT=10]="DYNAMIC_KEY_TIMEOUT",e[e.NO_ACTIVE_STATUS=11]="NO_ACTIVE_STATUS",e[e.DYNAMIC_KEY_EXPIRED=13]="DYNAMIC_KEY_EXPIRED",e[e.STATIC_USE_DYNAMIC_KEY=14]="STATIC_USE_DYNAMIC_KEY",e[e.DYNAMIC_USE_STATIC_KEY=15]="DYNAMIC_USE_STATIC_KEY",e[e.USER_OVERLOAD=16]="USER_OVERLOAD",e[e.FORBIDDEN_REGION=18]="FORBIDDEN_REGION",e[e.CANNOT_MEET_AREA_DEMAND=19]="CANNOT_MEET_AREA_DEMAND";}(gf||(gf={})),function(e){e[e.NO_FLAG_SET=100]="NO_FLAG_SET",e[e.FLAG_SET_BUT_EMPTY=101]="FLAG_SET_BUT_EMPTY",e[e.INVALID_FALG_SET=102]="INVALID_FALG_SET",e[e.FLAG_SET_BUT_NO_RE=103]="FLAG_SET_BUT_NO_RE",e[e.INVALID_SERVICE_ID=104]="INVALID_SERVICE_ID",e[e.NO_SERVICE_AVAILABLE=200]="NO_SERVICE_AVAILABLE",e[e.NO_SERVICE_AVAILABLE_P2P=201]="NO_SERVICE_AVAILABLE_P2P",e[e.NO_SERVICE_AVAILABLE_VOICE=202]="NO_SERVICE_AVAILABLE_VOICE",e[e.NO_SERVICE_AVAILABLE_WEBRTC=203]="NO_SERVICE_AVAILABLE_WEBRTC",e[e.NO_SERVICE_AVAILABLE_CDS=204]="NO_SERVICE_AVAILABLE_CDS",e[e.NO_SERVICE_AVAILABLE_CDN=205]="NO_SERVICE_AVAILABLE_CDN",e[e.NO_SERVICE_AVAILABLE_TDS=206]="NO_SERVICE_AVAILABLE_TDS",e[e.NO_SERVICE_AVAILABLE_REPORT=207]="NO_SERVICE_AVAILABLE_REPORT",e[e.NO_SERVICE_AVAILABLE_APP_CENTER=208]="NO_SERVICE_AVAILABLE_APP_CENTER",e[e.NO_SERVICE_AVAILABLE_ENV0=209]="NO_SERVICE_AVAILABLE_ENV0",e[e.NO_SERVICE_AVAILABLE_VOET=210]="NO_SERVICE_AVAILABLE_VOET",e[e.NO_SERVICE_AVAILABLE_STRING_UID=211]="NO_SERVICE_AVAILABLE_STRING_UID",e[e.NO_SERVICE_AVAILABLE_WEBRTC_UNILBS=212]="NO_SERVICE_AVAILABLE_WEBRTC_UNILBS",e[e.NO_SERVICE_AVAILABLE_UNILBS_FLV=213]="NO_SERVICE_AVAILABLE_UNILBS_FLV";}(Rf||(Rf={})),function(e){e[e.K_TIMESTAMP_EXPIRED=2]="K_TIMESTAMP_EXPIRED",e[e.K_CHANNEL_PERMISSION_INVALID=3]="K_CHANNEL_PERMISSION_INVALID",e[e.K_CERTIFICATE_INVALID=4]="K_CERTIFICATE_INVALID",e[e.K_CHANNEL_NAME_EMPTY=5]="K_CHANNEL_NAME_EMPTY",e[e.K_CHANNEL_NOT_FOUND=6]="K_CHANNEL_NOT_FOUND",e[e.K_TICKET_INVALID=7]="K_TICKET_INVALID",e[e.K_CHANNEL_CONFLICTED=8]="K_CHANNEL_CONFLICTED",e[e.K_SERVICE_NOT_READY=9]="K_SERVICE_NOT_READY",e[e.K_SERVICE_TOO_HEAVY=10]="K_SERVICE_TOO_HEAVY",e[e.K_UID_BANNED=14]="K_UID_BANNED",e[e.K_IP_BANNED=15]="K_IP_BANNED",e[e.K_CHANNEL_BANNED=16]="K_CHANNEL_BANNED",e[e.WARN_NO_AVAILABLE_CHANNEL=103]="WARN_NO_AVAILABLE_CHANNEL",e[e.WARN_LOOKUP_CHANNEL_TIMEOUT=104]="WARN_LOOKUP_CHANNEL_TIMEOUT",e[e.WARN_LOOKUP_CHANNEL_REJECTED=105]="WARN_LOOKUP_CHANNEL_REJECTED",e[e.WARN_OPEN_CHANNEL_TIMEOUT=106]="WARN_OPEN_CHANNEL_TIMEOUT",e[e.WARN_OPEN_CHANNEL_REJECTED=107]="WARN_OPEN_CHANNEL_REJECTED",e[e.WARN_REQUEST_DEFERRED=108]="WARN_REQUEST_DEFERRED",e[e.ERR_DYNAMIC_KEY_TIMEOUT=109]="ERR_DYNAMIC_KEY_TIMEOUT",e[e.ERR_NO_AUTHORIZED=110]="ERR_NO_AUTHORIZED",e[e.ERR_VOM_SERVICE_UNAVAILABLE=111]="ERR_VOM_SERVICE_UNAVAILABLE",e[e.ERR_NO_CHANNEL_AVAILABLE_CODE=112]="ERR_NO_CHANNEL_AVAILABLE_CODE",e[e.ERR_MASTER_VOCS_UNAVAILABLE=114]="ERR_MASTER_VOCS_UNAVAILABLE",e[e.ERR_INTERNAL_ERROR=115]="ERR_INTERNAL_ERROR",e[e.ERR_NO_ACTIVE_STATUS=116]="ERR_NO_ACTIVE_STATUS",e[e.ERR_INVALID_UID=117]="ERR_INVALID_UID",e[e.ERR_DYNAMIC_KEY_EXPIRED=118]="ERR_DYNAMIC_KEY_EXPIRED",e[e.ERR_STATIC_USE_DYANMIC_KE=119]="ERR_STATIC_USE_DYANMIC_KE",e[e.ERR_DYNAMIC_USE_STATIC_KE=120]="ERR_DYNAMIC_USE_STATIC_KE",e[e.ERR_NO_VOCS_AVAILABLE=2e3]="ERR_NO_VOCS_AVAILABLE",e[e.ERR_NO_VOS_AVAILABLE=2001]="ERR_NO_VOS_AVAILABLE",e[e.ERR_JOIN_CHANNEL_TIMEOUT=2002]="ERR_JOIN_CHANNEL_TIMEOUT",e[e.ERR_REPEAT_JOIN_CHANNEL=2003]="ERR_REPEAT_JOIN_CHANNEL",e[e.ERR_JOIN_BY_MULTI_IP=2004]="ERR_JOIN_BY_MULTI_IP",e[e.ERR_NOT_JOINED=2011]="ERR_NOT_JOINED",e[e.ERR_REPEAT_JOIN_REQUEST=2012]="ERR_REPEAT_JOIN_REQUEST",e[e.ERR_INVALID_VENDOR_KEY=2013]="ERR_INVALID_VENDOR_KEY",e[e.ERR_INVALID_CHANNEL_NAME=2014]="ERR_INVALID_CHANNEL_NAME",e[e.ERR_INVALID_STRINGUID=2015]="ERR_INVALID_STRINGUID",e[e.ERR_TOO_MANY_USERS=2016]="ERR_TOO_MANY_USERS",e[e.ERR_SET_CLIENT_ROLE_TIMEOUT=2017]="ERR_SET_CLIENT_ROLE_TIMEOUT",e[e.ERR_SET_CLIENT_ROLE_NO_PERMISSION=2018]="ERR_SET_CLIENT_ROLE_NO_PERMISSION",e[e.ERR_SET_CLIENT_ROLE_ALREADY_IN_USE=2019]="ERR_SET_CLIENT_ROLE_ALREADY_IN_USE",e[e.ERR_PUBLISH_REQUEST_INVALID=2020]="ERR_PUBLISH_REQUEST_INVALID",e[e.ERR_SUBSCRIBE_REQUEST_INVALID=2021]="ERR_SUBSCRIBE_REQUEST_INVALID",e[e.ERR_NOT_SUPPORTED_MESSAGE=2022]="ERR_NOT_SUPPORTED_MESSAGE",e[e.ERR_ILLEAGAL_PLUGIN=2023]="ERR_ILLEAGAL_PLUGIN",e[e.ERR_REJOIN_TOKEN_INVALID=2024]="ERR_REJOIN_TOKEN_INVALID",e[e.ERR_REJOIN_USER_NOT_JOINED=2025]="ERR_REJOIN_USER_NOT_JOINED",e[e.ERR_INVALID_OPTIONAL_INFO=2027]="ERR_INVALID_OPTIONAL_INFO",e[e.ILLEGAL_AES_PASSWORD=2028]="ILLEGAL_AES_PASSWORD",e[e.ILLEGAL_CLIENT_ROLE_LEVEL=2029]="ILLEGAL_CLIENT_ROLE_LEVEL",e[e.ERR_TOO_MANY_BROADCASTERS=2031]="ERR_TOO_MANY_BROADCASTERS",e[e.ERR_TOO_MANY_SUBSCRIBERS=2032]="ERR_TOO_MANY_SUBSCRIBERS",e[e.ERR_LICENSE_MISSING=32769]="ERR_LICENSE_MISSING",e[e.ERR_LICENSE_EXPIRED=32771]="ERR_LICENSE_EXPIRED",e[e.ERR_LICENSE_MINUTES_EXCEEDED=32773]="ERR_LICENSE_MINUTES_EXCEEDED",e[e.ERR_LICENSE_PERIOD_INVALID=32774]="ERR_LICENSE_PERIOD_INVALID",e[e.ERR_LICENSE_MULTIPLE_SDK_SERVICE=32778]="ERR_LICENSE_MULTIPLE_SDK_SERVICE",e[e.ERR_LICENSE_ILLEGAL=32783]="ERR_LICENSE_ILLEGAL",e[e.ERR_TEST_RECOVER=9e3]="ERR_TEST_RECOVER",e[e.ERR_TEST_TRYNEXT=9001]="ERR_TEST_TRYNEXT",e[e.ERR_TEST_RETRY=9002]="ERR_TEST_RETRY";}(If||(If={})),function(e){e[e.AUDIENCE_LEVEL_LOW_LATENCY=1]="AUDIENCE_LEVEL_LOW_LATENCY",e[e.AUDIENCE_LEVEL_ULTRA_LOW_LATENCY=2]="AUDIENCE_LEVEL_ULTRA_LOW_LATENCY",e[e.AUDIENCE_LEVEL_SYNC_LATENCY=3]="AUDIENCE_LEVEL_SYNC_LATENCY";}(Cf||(Cf={})),function(e){e.LEAVE="LEAVE",e.NETWORK_ERROR="NETWORK_ERROR",e.SERVER_ERROR="SERVER_ERROR",e.UID_BANNED="UID_BANNED",e.IP_BANNED="IP_BANNED",e.CHANNEL_BANNED="CHANNEL_BANNED",e.FALLBACK="FALLBACK",e.LICENSE_MISSING="LICENSE_MISSING",e.LICENSE_EXPIRED="LICENSE_EXPIRED",e.LICENSE_MINUTES_EXCEEDED="LICENSE_MINUTES_EXCEEDED",e.LICENSE_PERIOD_INVALID="LICENSE_PERIOD_INVALID",e.LICENSE_MULTIPLE_SDK_SERVICE="LICENSE_MULTIPLE_SDK_SERVICE",e.LICENSE_ILLEGAL="LICENSE_ILLEGAL";}(vf||(vf={})),function(e){e.CONNECTION_STATE_CHANGE="connection-state-change",e.MEDIA_RECONNECT_START="media-reconnect-start",e.MEDIA_RECONNECT_END="media-reconnect-end",e.IS_USING_CLOUD_PROXY="is-using-cloud-proxy",e.USER_JOINED="user-joined",e.USER_LEAVED="user-left",e.USER_PUBLISHED="user-published",e.USER_UNPUBLISHED="user-unpublished",e.USER_INFO_UPDATED="user-info-updated",e.CLIENT_BANNED="client-banned",e.CHANNEL_MEDIA_RELAY_STATE="channel-media-relay-state",e.CHANNEL_MEDIA_RELAY_EVENT="channel-media-relay-event",e.VOLUME_INDICATOR="volume-indicator",e.CRYPT_ERROR="crypt-error",e.ON_TOKEN_PRIVILEGE_WILL_EXPIRE="token-privilege-will-expire",e.ON_TOKEN_PRIVILEGE_DID_EXPIRE="token-privilege-did-expire",e.NETWORK_QUALITY="network-quality",e.STREAM_TYPE_CHANGED="stream-type-changed",e.STREAM_FALLBACK="stream-fallback",e.RECEIVE_METADATA="receive-metadata",e.STREAM_MESSAGE="stream-message",e.LIVE_STREAMING_ERROR="live-streaming-error",e.LIVE_STREAMING_WARNING="live-streaming-warning",e.INJECT_STREAM_STATUS="stream-inject-status",e.EXCEPTION="exception",e.ERROR="error",e.P2P_LOST="p2p_lost",e.JOIN_FALLBACK_TO_PROXY="join-fallback-to-proxy",e.CHANNEL_FALLBACK_TO_WEBSOCKET="channel-fallback-to-websocket",e.MEDIA_CONNECTION_TYPE_CHANGE="media-connection-type-change",e.PUBLISHED_USER_LIST="published-user-list",e.CONTENT_INSPECT_CONNECTION_STATE_CHANGE="content-inspect-connection-state-change",e.CONTENT_INSPECT_ERROR="content-inspect-error",e.CONTENT_INSPECT_RESULT="content-inspect-result",e.IMAGE_MODERATION_CONNECTION_STATE_CHANGE="image-moderation-connection-state-change";}(yf||(yf={})),function(e){e.NETWORK_ERROR="NETWORK_ERROR",e.SERVER_ERROR="SERVER_ERROR",e.MULTI_IP="MULTI_IP",e.TIMEOUT="TIMEOUT",e.OFFLINE="OFFLINE",e.LEAVE="LEAVE",e.P2P_FAILED="P2P_FAILED",e.FALLBACK="FALLBACK";}(Af||(Af={})),function(e){e.CONNECTING="connecting",e.CONNECTED="connected",e.RECONNECTING="reconnecting",e.CLOSED="closed";}(Of||(Of={})),function(e){e.WS_CONNECTED="ws_connected",e.WS_RECONNECTING="ws_reconnecting",e.WS_CLOSED="ws_closed",e.WS_RECONNECT_WAITTING_FINISH="ws_reconnect_waitting_finish",e.WS_RECONNECT_CREATE_CONNECTION="ws_reconnect_create_connection",e.ON_BINARY_DATA="on_binary_data",e.REQUEST_RECOVER="request_recover",e.REQUEST_JOIN_INFO="request_join_info",e.REQUEST_REJOIN_INFO="req_rejoin_info",e.IS_P2P_DISCONNECTED="is_p2p_dis",e.DISCONNECT_P2P="dis_p2p",e.ABORT_P2P_EXECUTION="abort_p2p_execution",e.NEED_RENEW_SESSION="need-sid",e.REPORT_JOIN_GATEWAY="report_join_gateway",e.REQUEST_TIMEOUT="request_timeout",e.REQUEST_SUCCESS="request_success",e.JOIN_RESPONSE="join_response",e.DATACHANNEL_PRECONNECT="datachannel_preconnect",e.DATACHANNEL_CONNECTING="datachannel_connecting",e.DATACHANNEL_FAILBACK="datachannel_failback";}(Nf||(Nf={})),function(e){e.PING="ping",e.PING_BACK="ping_back",e.JOIN="join_v3",e.REJOIN="rejoin_v3",e.LEAVE="leave",e.SET_CLIENT_ROLE="set_client_role",e.PUBLISH="publish",e.UNPUBLISH="unpublish",e.SUBSCRIBE="subscribe",e.SUBSCRIBE_STREAMS="subscribe_streams",e.UNSUBSCRIBE="unsubscribe",e.UNSUBSCRIBE_STREAMS="unsubscribe_streams",e.SUBSCRIBE_CHANGE="subscribe_change",e.TRAFFIC_STATS="traffic_stats",e.RENEW_TOKEN="renew_token",e.SWITCH_VIDEO_STREAM="switch_video_stream",e.DEFAULT_VIDEO_STREAM="default_video_stream",e.SET_FALLBACK_OPTION="set_fallback_option",e.GATEWAY_INFO="gateway_info",e.CONTROL="control",e.SEND_METADATA="send_metadata",e.DATA_STREAM="data_stream",e.PICK_SVC_LAYER="pick_svc_layer",e.RESTART_ICE="restart_ice",e.CONNECT_PC="connect_pc",e.SET_VIDEO_PROFILE="set_video_profile",e.SET_PARAMETER="set_parameter";}(bf||(bf={})),function(e){e.PUBLISH_STATS="publish_stats",e.PUBLISH_RELATED_STATS="publish_related_stats",e.SUBSCRIBE_STATS="subscribe_stats",e.SUBSCRIBE_RELATED_STATS="subscribe_related_stats",e.WS_INFLATE_DATA_LENGTH="ws_inflate_data_length",e.DENOISER_STATS="denoiser_stats",e.TRANSPORT_STATS="transport_stats",e.EXTENSION_USAGE_STATS="extension_usage_stats";}(wf||(wf={})),function(e){e.ON_USER_ONLINE="on_user_online",e.ON_USER_OFFLINE="on_user_offline",e.ON_STREAM_FALLBACK_UPDATE="on_stream_fallback_update",e.ON_PUBLISH_STREAM="on_publish_stream",e.ON_UPLINK_STATS="on_uplink_stats",e.ON_P2P_LOST="on_p2p_lost",e.ON_REMOVE_STREAM="on_remove_stream",e.ON_ADD_AUDIO_STREAM="on_add_audio_stream",e.ON_ADD_VIDEO_STREAM="on_add_video_stream",e.ON_TOKEN_PRIVILEGE_WILL_EXPIRE="on_token_privilege_will_expire",e.ON_TOKEN_PRIVILEGE_DID_EXPIRE="on_token_privilege_did_expire",e.ON_USER_BANNED="on_user_banned",e.ON_USER_LICENSE_BANNED="on_user_license_banned",e.ON_NOTIFICATION="on_notification",e.ON_CRYPT_ERROR="on_crypt_error",e.MUTE_AUDIO="mute_audio",e.MUTE_VIDEO="mute_video",e.UNMUTE_AUDIO="unmute_audio",e.UNMUTE_VIDEO="unmute_video",e.ON_P2P_OK="on_p2p_ok",e.RECEIVE_METADATA="receive_metadata",e.ON_DATA_STREAM="on_data_stream",e.ENABLE_LOCAL_VIDEO="enable_local_video",e.DISABLE_LOCAL_VIDEO="disable_local_video",e.ENABLE_LOCAL_AUDIO="enable_local_audio",e.DISABLE_LOCAL_AUDIO="disable_local_audio",e.ON_PUBLISHED_USER_LIST="on_published_user_list";}(Df||(Df={})),function(e){e.CONNECTION_STATE_CHANGE="CONNECTION_STATE_CHANGE",e.NEED_ANSWER="NEED_ANSWER",e.NEED_RENEGOTIATE="NEED_RENEGOTIATE",e.P2P_LOST="P2P_LOST",e.GATEWAY_P2P_LOST="GATEWAY_P2P_LOST",e.NEED_UNPUB="NEED_UNPUB",e.NEED_UNSUB="NEED_UNSUB",e.NEED_UPLOAD="NEED_UPLOAD",e.NEED_CONTROL="NEED_CONTROL",e.START_RECONNECT="START_RECONNECT",e.END_RECONNECT="END_RECONNECT",e.NEED_SIGNAL_RTT="NEED_SIGNAL_RTT";}(Pf||(Pf={})),function(e){e.AUDIO_SOURCE_STATE_CHANGE="audio_source_state_change",e.RECEIVE_TRACK_BUFFER="receive_track_buffer",e.ON_AUDIO_BUFFER="on_audio_buffer",e.UPDATE_SOURCE="update_source";}(Lf||(Lf={}));const jf={sendVolumeLevel:0,sendBitrate:0,sendBytes:0,sendPackets:0,sendPacketsLost:0,currentPacketLossRate:0},Ff={sendBytes:0,sendBitrate:0,sendPackets:0,sendPacketsLost:0,sendResolutionHeight:0,sendResolutionWidth:0,captureResolutionHeight:0,captureResolutionWidth:0,targetSendBitrate:0,totalDuration:0,totalFreezeTime:0,currentPacketLossRate:0},Bf={transportDelay:0,end2EndDelay:0,receiveBitrate:0,receiveLevel:0,receiveBytes:0,receiveDelay:0,receivePackets:0,receivePacketsLost:0,totalDuration:0,totalFreezeTime:0,freezeRate:0,packetLossRate:0,currentPacketLossRate:0,publishDuration:-1},Gf={uplinkNetworkQuality:0,downlinkNetworkQuality:0},Wf={transportDelay:0,end2EndDelay:0,receiveBitrate:0,receiveBytes:0,receiveDelay:0,receivePackets:0,receivePacketsLost:0,receiveResolutionHeight:0,receiveResolutionWidth:0,totalDuration:0,totalFreezeTime:0,freezeRate:0,packetLossRate:0,currentPacketLossRate:0,publishDuration:-1};let Hf,Kf,Yf;!function(e){e.CONNECTED="websocket:connected",e.RECONNECTING="websocket:reconnecting",e.WILL_RECONNECT="websocket:will_reconnect",e.CLOSED="websocket:closed",e.FAILED="websocket:failed",e.ON_MESSAGE="websocket:on_message",e.REQUEST_NEW_URLS="websocket:request_new_urls",e.RECONNECT_WAITTING_FINISH="websocket:reconnect_waitting_finish",e.RECONNECT_CREATE_CONNECTION="websocket:reconnect_create_connection",e.ON_TOKEN_PRIVILEGE_DID_EXPIRE="websocket:on_token_privilege_did_expire";}(Hf||(Hf={})),function(e){e.TRANSCODE="mix_streaming",e.RAW="raw_streaming",e.INJECT="inject_streaming";}(Kf||(Kf={})),function(e){e[e.INJECT_STREAM_STATUS_START_SUCCESS=0]="INJECT_STREAM_STATUS_START_SUCCESS",e[e.INJECT_STREAM_STATUS_START_ALREADY_EXISTS=1]="INJECT_STREAM_STATUS_START_ALREADY_EXISTS",e[e.INJECT_STREAM_STATUS_START_UNAUTHORIZED=2]="INJECT_STREAM_STATUS_START_UNAUTHORIZED",e[e.INJECT_STREAM_STATUS_START_TIMEOUT=3]="INJECT_STREAM_STATUS_START_TIMEOUT",e[e.INJECT_STREAM_STATUS_START_FAILED=4]="INJECT_STREAM_STATUS_START_FAILED",e[e.INJECT_STREAM_STATUS_STOP_SUCCESS=5]="INJECT_STREAM_STATUS_STOP_SUCCESS",e[e.INJECT_STREAM_STATUS_STOP_NOT_FOUND=6]="INJECT_STREAM_STATUS_STOP_NOT_FOUND",e[e.INJECT_STREAM_STATUS_STOP_UNAUTHORIZED=7]="INJECT_STREAM_STATUS_STOP_UNAUTHORIZED",e[e.INJECT_STREAM_STATUS_STOP_TIMEOUT=8]="INJECT_STREAM_STATUS_STOP_TIMEOUT",e[e.INJECT_STREAM_STATUS_STOP_FAILED=9]="INJECT_STREAM_STATUS_STOP_FAILED",e[e.INJECT_STREAM_STATUS_BROKEN=10]="INJECT_STREAM_STATUS_BROKEN";}(Yf||(Yf={}));const qf={alpha:1,height:640,width:360,x:0,y:0,zOrder:0,audioChannel:0},Jf={x:0,y:0,width:160,height:160,zOrder:255,alpha:1};function Xf(e,t){Xm(e.url,"".concat(t,".url"),1,1e3,!1),$m(e.x)||qm(e.x,"".concat(t,".x"),0,1e4),$m(e.y)||qm(e.y,"".concat(t,".y"),0,1e4),$m(e.width)||qm(e.width,"".concat(t,".width"),0,1e4),$m(e.height)||qm(e.height,"".concat(t,".height"),0,1e4),$m(e.zOrder)||qm(e.zOrder,"".concat(t,".zOrder"),0,255),$m(e.alpha)||qm(e.alpha,"".concat(t,".alpha"),0,1,!1);}const zf={audioBitrate:48,audioChannels:1,audioSampleRate:48e3,backgroundColor:0,height:360,lowLatency:!1,videoBitrate:400,videoCodecProfile:100,videoCodecType:1,videoFrameRate:15,videoGop:30,width:640,images:[],userConfigs:[],userConfigExtraInfo:""},Qf={audioBitrate:48,audioChannels:2,audioVolume:100,audioSampleRate:48e3,height:0,width:0,videoBitrate:400,videoFramerate:15,videoGop:30};let Zf,$f,eS,tS,iS,nS,rS,oS,sS,aS,cS,dS,uS,lS,hS,pS,_S,ES,mS,fS,SS;function TS(e){if(!e.channelName)throw new SE(fE.INVALID_PARAMS,"invalid channelName in info");if("number"!=typeof e.uid)throw new SE(fE.INVALID_PARAMS,"invalid uid in info, uid must be a number");return e.token&&Xm(e.token,"info.token",1,2047),Zm(e.uid),Qm(e.channelName),!0}function gS(e){return Ym(e,"mediaSource",["screen","window","application"]),!0}!function(e){e.WARNING="@live_uap-warning",e.ERROR="@line_uap-error",e.PUBLISH_STREAM_STATUS="@live_uap-publish-status",e.INJECT_STREAM_STATUS="@live_uap-inject-status",e.WORKER_STATUS="@live_uap-worker-status",e.REQUEST_NEW_ADDRESS="@live_uap-request-address";}(Zf||(Zf={})),function(e){e.REQUEST_WORKER_MANAGER_LIST="@live_req_worker_manager";}($f||($f={})),function(e){e[e.LIVE_STREAM_RESPONSE_SUCCEED=200]="LIVE_STREAM_RESPONSE_SUCCEED",e[e.LIVE_STREAM_RESPONSE_ALREADY_EXISTS_STREAM=454]="LIVE_STREAM_RESPONSE_ALREADY_EXISTS_STREAM",e[e.LIVE_STREAM_RESPONSE_TRANSCODING_PARAMETER_ERROR=450]="LIVE_STREAM_RESPONSE_TRANSCODING_PARAMETER_ERROR",e[e.LIVE_STREAM_RESPONSE_BAD_STREAM=451]="LIVE_STREAM_RESPONSE_BAD_STREAM",e[e.LIVE_STREAM_RESPONSE_WM_PARAMETER_ERROR=400]="LIVE_STREAM_RESPONSE_WM_PARAMETER_ERROR",e[e.LIVE_STREAM_RESPONSE_WM_WORKER_NOT_EXIST=404]="LIVE_STREAM_RESPONSE_WM_WORKER_NOT_EXIST",e[e.LIVE_STREAM_RESPONSE_NOT_AUTHORIZED=456]="LIVE_STREAM_RESPONSE_NOT_AUTHORIZED",e[e.LIVE_STREAM_RESPONSE_FAILED_LOAD_IMAGE=457]="LIVE_STREAM_RESPONSE_FAILED_LOAD_IMAGE",e[e.LIVE_STREAM_RESPONSE_REQUEST_TOO_OFTEN=429]="LIVE_STREAM_RESPONSE_REQUEST_TOO_OFTEN",e[e.LIVE_STREAM_RESPONSE_NOT_FOUND_PUBLISH=452]="LIVE_STREAM_RESPONSE_NOT_FOUND_PUBLISH",e[e.LIVE_STREAM_RESPONSE_NOT_SUPPORTED=453]="LIVE_STREAM_RESPONSE_NOT_SUPPORTED",e[e.LIVE_STREAM_RESPONSE_MAX_STREAM_NUM=455]="LIVE_STREAM_RESPONSE_MAX_STREAM_NUM",e[e.LIVE_STREAM_RESPONSE_INTERNAL_SERVER_ERROR=500]="LIVE_STREAM_RESPONSE_INTERNAL_SERVER_ERROR",e[e.LIVE_STREAM_RESPONSE_WORKER_LOST=501]="LIVE_STREAM_RESPONSE_WORKER_LOST",e[e.LIVE_STREAM_RESPONSE_RESOURCE_LIMIT=502]="LIVE_STREAM_RESPONSE_RESOURCE_LIMIT",e[e.LIVE_STREAM_RESPONSE_WORKER_QUIT=503]="LIVE_STREAM_RESPONSE_WORKER_QUIT",e[e.ERROR_FAIL_SEND_MESSAGE=504]="ERROR_FAIL_SEND_MESSAGE",e[e.PUBLISH_STREAM_STATUS_ERROR_RTMP_HANDSHAKE=30]="PUBLISH_STREAM_STATUS_ERROR_RTMP_HANDSHAKE",e[e.PUBLISH_STREAM_STATUS_ERROR_RTMP_CONNECT=31]="PUBLISH_STREAM_STATUS_ERROR_RTMP_CONNECT",e[e.PUBLISH_STREAM_STATUS_ERROR_RTMP_PUBLISH=32]="PUBLISH_STREAM_STATUS_ERROR_RTMP_PUBLISH",e[e.PUBLISH_STREAM_STATUS_ERROR_PUBLISH_BROKEN=33]="PUBLISH_STREAM_STATUS_ERROR_PUBLISH_BROKEN";}(eS||(eS={})),function(e){e.CONNECT_FAILED="connect failed",e.CONNECT_TIMEOUT="connect timeout",e.WS_DISCONNECTED="websocket disconnected",e.REQUEST_TIMEOUT="request timeout",e.REQUEST_FAILED="request failed",e.WAIT_STATUS_TIMEOUT="wait status timeout",e.WAIT_STATUS_ERROR="wait status error",e.BAD_STATE="bad state",e.WS_ABORT="ws abort",e.AP_REQUEST_TIMEOUT="AP request timeout",e.AP_JSON_PARSE_ERROR="AP json parse error",e.AP_REQUEST_ERROR="AP request error",e.AP_REQUEST_ABORT="AP request abort";}(tS||(tS={})),function(e){e[e.SetSdkProfile=0]="SetSdkProfile",e[e.SetSourceChannel=1]="SetSourceChannel",e[e.SetSourceUserId=2]="SetSourceUserId",e[e.SetDestChannel=3]="SetDestChannel",e[e.StartPacketTransfer=4]="StartPacketTransfer",e[e.StopPacketTransfer=5]="StopPacketTransfer",e[e.UpdateDestChannel=6]="UpdateDestChannel",e[e.Reconnect=7]="Reconnect",e[e.SetVideoProfile=8]="SetVideoProfile";}(iS||(iS={})),function(e){e.NETWORK_DISCONNECTED="NETWORK_DISCONNECTED",e.NETWORK_CONNECTED="NETWORK_CONNECTED",e.PACKET_JOINED_SRC_CHANNEL="PACKET_JOINED_SRC_CHANNEL",e.PACKET_JOINED_DEST_CHANNEL="PACKET_JOINED_DEST_CHANNEL",e.PACKET_SENT_TO_DEST_CHANNEL="PACKET_SENT_TO_DEST_CHANNEL",e.PACKET_RECEIVED_VIDEO_FROM_SRC="PACKET_RECEIVED_VIDEO_FROM_SRC",e.PACKET_RECEIVED_AUDIO_FROM_SRC="PACKET_RECEIVED_AUDIO_FROM_SRC",e.PACKET_UPDATE_DEST_CHANNEL="PACKET_UPDATE_DEST_CHANNEL",e.PACKET_UPDATE_DEST_CHANNEL_REFUSED="PACKET_UPDATE_DEST_CHANNEL_REFUSED",e.PACKET_UPDATE_DEST_CHANNEL_NOT_CHANGE="PACKET_UPDATE_DEST_CHANNEL_NOT_CHANGE";}(nS||(nS={})),function(e){e.RELAY_STATE_IDLE="RELAY_STATE_IDLE",e.RELAY_STATE_CONNECTING="RELAY_STATE_CONNECTING",e.RELAY_STATE_RUNNING="RELAY_STATE_RUNNING",e.RELAY_STATE_FAILURE="RELAY_STATE_FAILURE";}(rS||(rS={})),function(e){e.RELAY_OK="RELAY_OK",e.SERVER_CONNECTION_LOST="SERVER_CONNECTION_LOST",e.SRC_TOKEN_EXPIRED="SRC_TOKEN_EXPIRED",e.DEST_TOKEN_EXPIRED="DEST_TOKEN_EXPIRED";}(oS||(oS={})),function(e){e.High="high",e.Low="low",e.Audio="audio",e.Screen="screen",e.ScreenLow="screen_low";}(sS||(sS={})),function(e){e.DISCONNECT="disconnect",e.CONNECTION_STATE_CHANGE="connection-state-change",e.NETWORK_QUALITY="network-quality",e.STREAM_TYPE_CHANGE="stream-type-change",e.IS_P2P_DISCONNECTED="is-p2p-dis",e.DISCONNECT_P2P="dis-p2p",e.REQUEST_NEW_GATEWAY_LIST="req-gate-url",e.NEED_RENEW_SESSION="need-sid",e.REQUEST_P2P_CONNECTION_PARAMS="request-p2p-connection-params",e.JOIN_RESPONSE="join-response",e.REQUEST_DC_CONNECTION_PARAMS="request-dc-connection-params",e.RESET_CONNECTION_EVENTS="reset-connection-events",e.DATACHANNEL_PRECONNECT="datachannel_preconnect",e.DATACHANNEL_FAILBACK="datachannel_failback",e.RESET_SIGNAL="reset-signal";}(aS||(aS={})),function(e){e[e.Nothing=0]="Nothing",e[e.Audio=1]="Audio",e[e.LwoVideo=2]="LwoVideo",e[e.Video=4]="Video",e[e.Data=8]="Data";}(cS||(cS={})),function(e){e[e.websocket=0]="websocket",e[e.datachannel=1]="datachannel";}(dS||(dS={})),function(e){e.NEED_RENEGOTIATE="@need_renegotiate",e.NEED_REPLACE_TRACK="@need_replace_track",e.NEED_CLOSE="@need_close",e.NEED_ENABLE_TRACK="@need_enable_track",e.NEED_DISABLE_TRACK="@need_disable_track",e.NEED_SESSION_ID="@need_sid",e.SET_OPTIMIZATION_MODE="@set_optimization_mode",e.GET_STATS="@get_stats",e.GET_LOW_VIDEO_TRACK="@get_low_video_track",e.NEED_RESET_REMOTE_SDP="@need_reset_remote_sdp",e.NEED_UPDATE_VIDEO_ENCODER="@need_update_video_encoder",e.NEED_MUTE_TRACK="@need_mute_track",e.NEED_UNMUTE_TRACK="@need_unmute_track";}(uS||(uS={})),function(e){e.SCREEN_TRACK="screen_track",e.CUSTOM_TRACK="custome_track",e.LOW_STREAM="low_stream";}(lS||(lS={})),function(e){e[e.HIGH_STREAM=0]="HIGH_STREAM",e[e.LOW_STREAM=1]="LOW_STREAM";}(hS||(hS={})),function(e){e[e.HIGH_STREAM=0]="HIGH_STREAM",e[e.LOW_STREAM=1]="LOW_STREAM";}(pS||(pS={})),function(e){e[e.DISABLE=0]="DISABLE",e[e.LOW_STREAM=1]="LOW_STREAM",e[e.AUDIO_ONLY=2]="AUDIO_ONLY";}(_S||(_S={})),function(e){e.TRANSCEIVER_UPDATED="transceiver-updated";}(ES||(ES={})),function(e){e.SOURCE_STATE_CHANGE="source-state-change",e.TRACK_ENDED="track-ended",e.BEAUTY_EFFECT_OVERLOAD="beauty-effect-overload",e.VIDEO_ELEMENT_VISIBLE_STATUS="video-element-visible-status",e.CLOSED="closed";}(mS||(mS={})),function(e){e.FIRST_FRAME_DECODED="first-frame-decoded",e.VIDEO_ELEMENT_VISIBLE_STATUS="video-element-visible-status";}(fS||(fS={})),function(e){e.CHINA="CHINA",e.ASIA="ASIA",e.NORTH_AMERICA="NORTH_AMERICA",e.EUROPE="EUROPE",e.JAPAN="JAPAN",e.INDIA="INDIA",e.KOREA="KOREA",e.HKMC="HKMC",e.US="US",e.OCEANIA="OCEANIA",e.SOUTH_AMERICA="SOUTH_AMERICA",e.AFRICA="AFRICA",e.OVERSEA="OVERSEA",e.GLOBAL="GLOBAL",e.EXTENSIONS="EXTENSIONS";}(SS||(SS={}));const RS=[SS.AFRICA,SS.ASIA,SS.CHINA,SS.EUROPE,SS.GLOBAL,SS.INDIA,SS.JAPAN,SS.NORTH_AMERICA,SS.OCEANIA,SS.OVERSEA,SS.SOUTH_AMERICA];let IS;!function(e){e.CHINA="CN",e.ASIA="AS",e.NORTH_AMERICA="NA",e.EUROPE="EU",e.JAPAN="JP",e.INDIA="IN",e.KOREA="KR",e.HKMC="HK",e.US="US",e.OCEANIA="OC",e.SOUTH_AMERICA="SA",e.AFRICA="AF",e.OVERSEA="OVERSEA",e.GLOBAL="GLOBAL",e.EXTENSIONS="GLOBAL";}(IS||(IS={}));const CS={CHINA:{},ASIA:{CODE:IS.ASIA,WEBCS_DOMAIN:["ap-web-1-asia.agora.io"],WEBCS_DOMAIN_BACKUP_LIST:["ap-web-2-asia.agora.io"],PROXY_CS:["proxy-ap-web-asia.agora.io"],CDS_AP:["cds-ap-web-asia.agora.io","cds-ap-web-asia2.agora.io"],ACCOUNT_REGISTER:["sua-ap-web-asia.agora.io","sua-ap-web-asia2.agora.io"],UAP_AP:["uap-ap-web-asia.agora.io","uap-ap-web-asia2.agora.io"],EVENT_REPORT_DOMAIN:["statscollector-1-asia.agora.io"],EVENT_REPORT_BACKUP_DOMAIN:["statscollector-2-asia.agora.io"],LOG_UPLOAD_SERVER:["logservice-asia.agora.io"],PROXY_SERVER_TYPE3:["southeast-asia.webrtc-cloud-proxy.sd-rtn.com"]},NORTH_AMERICA:{CODE:IS.NORTH_AMERICA,WEBCS_DOMAIN:["ap-web-1-north-america.agora.io"],WEBCS_DOMAIN_BACKUP_LIST:["ap-web-2-north-america.agora.io"],PROXY_CS:["proxy-ap-web-america.agora.io"],CDS_AP:["cds-ap-web-america.agora.io","cds-ap-web-america2.agora.io"],ACCOUNT_REGISTER:["sua-ap-web-america.agora.io","sua-ap-web-america2.agora.io"],UAP_AP:["uap-ap-web-america.agora.io","uap-ap-web-america2.agora.io"],EVENT_REPORT_DOMAIN:["statscollector-1-north-america.agora.io"],EVENT_REPORT_BACKUP_DOMAIN:["statscollector-2-north-america.agora.io"],LOG_UPLOAD_SERVER:["logservice-north-america.agora.io"],PROXY_SERVER_TYPE3:["east-usa.webrtc-cloud-proxy.sd-rtn.com"]},EUROPE:{CODE:IS.EUROPE,WEBCS_DOMAIN:["ap-web-1-europe.agora.io"],WEBCS_DOMAIN_BACKUP_LIST:["ap-web-2-europe.agora.io"],PROXY_CS:["proxy-ap-web-europe.agora.io"],CDS_AP:["cds-ap-web-europe.agora.io","cds-ap-web-europe2.agora.io"],ACCOUNT_REGISTER:["sua-ap-web-europe.agora.io","sua-ap-web-europe.agora.io"],UAP_AP:["uap-ap-web-europe.agora.io","uap-ap-web-europe2.agora.io"],EVENT_REPORT_DOMAIN:["statscollector-1-europe.agora.io"],EVENT_REPORT_BACKUP_DOMAIN:["statscollector-2-europe.agora.io"],LOG_UPLOAD_SERVER:["logservice-europe.agora.io"],PROXY_SERVER_TYPE3:["europe.webrtc-cloud-proxy.sd-rtn.com"]},JAPAN:{CODE:IS.JAPAN,WEBCS_DOMAIN:["ap-web-1-japan.agora.io"],WEBCS_DOMAIN_BACKUP_LIST:["ap-web-2-japan.agora.io"],PROXY_CS:["proxy-ap-web-japan.agora.io"],CDS_AP:["cds-ap-web-japan.agora.io","cds-ap-web-japan2.agora.io"],ACCOUNT_REGISTER:["sua-ap-web-japan.agora.io","sua-ap-web-japan2.agora.io"],UAP_AP:["uap-ap-web-japan.agora.io","\tuap-ap-web-japan2.agora.io"],EVENT_REPORT_DOMAIN:["statscollector-1-japan.agora.io"],EVENT_REPORT_BACKUP_DOMAIN:["statscollector-2-japan.agora.io"],LOG_UPLOAD_SERVER:["logservice-japan.agora.io"],PROXY_SERVER_TYPE3:["japan.webrtc-cloud-proxy.sd-rtn.com"]},INDIA:{CODE:IS.INDIA,WEBCS_DOMAIN:["ap-web-1-india.agora.io"],WEBCS_DOMAIN_BACKUP_LIST:["ap-web-2-india.agora.io"],PROXY_CS:["proxy-ap-web-india.agora.io"],CDS_AP:["cds-ap-web-india.agora.io","cds-ap-web-india2.agora.io"],ACCOUNT_REGISTER:["sua-ap-web-india.agora.io","sua-ap-web-india2.agora.io"],UAP_AP:["uap-ap-web-india.agora.io","uap-ap-web-india2.agora.io"],EVENT_REPORT_DOMAIN:["statscollector-1-india.agora.io"],EVENT_REPORT_BACKUP_DOMAIN:["statscollector-2-india.agora.io"],LOG_UPLOAD_SERVER:["logservice-india.agora.io"],PROXY_SERVER_TYPE3:["india.webrtc-cloud-proxy.sd-rtn.com"]},KOREA:{CODE:IS.KOREA,WEBCS_DOMAIN:["ap-web-1-korea.agora.io"],WEBCS_DOMAIN_BACKUP_LIST:["ap-web-2-korea.agora.io"],PROXY_CS:["proxy-ap-web-korea.agora.io"],CDS_AP:["cds-ap-web-korea.agora.io","cds-ap-web-korea2.agora.io"],ACCOUNT_REGISTER:["sua-ap-web-korea.agora.io","sua-ap-web-korea2.agora.io"],UAP_AP:["uap-ap-web-korea.agora.io","uap-ap-web-korea2.agora.io"],EVENT_REPORT_DOMAIN:["statscollector-1-korea.agora.io"],EVENT_REPORT_BACKUP_DOMAIN:["statscollector-2-korea.agora.io"],LOG_UPLOAD_SERVER:["logservice-korea.agora.io"],PROXY_SERVER_TYPE3:["korea.webrtc-cloud-proxy.sd-rtn.com"]},HKMC:{CODE:IS.HKMC,WEBCS_DOMAIN:["ap-web-1-hkmc.agora.io"],WEBCS_DOMAIN_BACKUP_LIST:["ap-web-2-hkmc.agora.io"],PROXY_CS:["proxy-ap-web-hkmc.agora.io"],CDS_AP:["cds-ap-web-hkmc.agora.io","cds-ap-web-hkmc2.agora.io"],ACCOUNT_REGISTER:["sua-ap-web-hkmc.agora.io","sua-ap-web-hkmc2.agora.io"],UAP_AP:["uap-ap-web-hkmc.agora.io","uap-ap-web-hkmc2.agora.io"],EVENT_REPORT_DOMAIN:["statscollector-1-hkmc.agora.io"],EVENT_REPORT_BACKUP_DOMAIN:["statscollector-2-hkmc.agora.io"],LOG_UPLOAD_SERVER:["logservice-hkmc.agora.io"],PROXY_SERVER_TYPE3:["hkmc.webrtc-cloud-proxy.sd-rtn.com"]},US:{CODE:IS.US,WEBCS_DOMAIN:["ap-web-1-us.agora.io"],WEBCS_DOMAIN_BACKUP_LIST:["ap-web-2-us.agora.io"],PROXY_CS:["proxy-ap-web-us.agora.io"],CDS_AP:["cds-ap-web-us.agora.io","cds-ap-web-us2.agora.io"],ACCOUNT_REGISTER:["sua-ap-web-us.agora.io","sua-ap-web-us2.agora.io"],UAP_AP:["uap-ap-web-us.agora.io","uap-ap-web-us2.agora.io"],EVENT_REPORT_DOMAIN:["statscollector-1-us.agora.io"],EVENT_REPORT_BACKUP_DOMAIN:["statscollector-2-us.agora.io"],LOG_UPLOAD_SERVER:["logservice-us.agora.io"],PROXY_SERVER_TYPE3:["us.webrtc-cloud-proxy.sd-rtn.com"]},OVERSEA:{CODE:IS.OVERSEA,WEBCS_DOMAIN:["ap-web-1-oversea.agora.io"],WEBCS_DOMAIN_BACKUP_LIST:["ap-web-2-oversea.agora.io"],PROXY_CS:["proxy-ap-web-oversea.agora.io"],CDS_AP:["cds-ap-web-oversea.agora.io"],ACCOUNT_REGISTER:["sua-ap-web-oversea.agora.io"],UAP_AP:["uap-ap-web-oversea.agora.io"],EVENT_REPORT_DOMAIN:["statscollector-1-oversea.agora.io"],EVENT_REPORT_BACKUP_DOMAIN:["statscollector-2-oversea.agora.io"],LOG_UPLOAD_SERVER:["logservice-oversea.agora.io"],PROXY_SERVER_TYPE3:["webrtc-cloud-proxy.agora.io"]},GLOBAL:{CODE:IS.GLOBAL,WEBCS_DOMAIN:["webrtc2-ap-web-1.agora.io"],WEBCS_DOMAIN_BACKUP_LIST:["webrtc2-ap-web-3.agora.io"],PROXY_CS:["ap-proxy-1.agora.io","ap-proxy-2.agora.io"],CDS_AP:["cds-ap-web-1.agora.io","cds-ap-web-3.agora.io"],ACCOUNT_REGISTER:["sua-ap-web-1.agora.io","sua-ap-web-3.agora.io"],UAP_AP:["uap-ap-web-1.agora.io","uap-ap-web-3.agora.io"],EVENT_REPORT_DOMAIN:["statscollector-1.agora.io"],EVENT_REPORT_BACKUP_DOMAIN:["statscollector-2.agora.io"],LOG_UPLOAD_SERVER:["logservice.agora.io"],PROXY_SERVER_TYPE3:["webrtc-cloud-proxy.sd-rtn.com"]},OCEANIA:{CODE:IS.OCEANIA,WEBCS_DOMAIN:["ap-web-1-oceania.agora.io"],WEBCS_DOMAIN_BACKUP_LIST:["ap-web-2-oceania.agora.io"],PROXY_CS:["proxy-ap-web-oceania.agora.io"],CDS_AP:["cds-ap-web-oceania.agora.io","cds-ap-web-oceania2.agora.io"],ACCOUNT_REGISTER:["sua-ap-web-oceania.agora.io","sua-ap-web-oceania2.agora.io"],UAP_AP:["uap-ap-web-oceania.agora.io","uap-ap-web-oceania2.agora.io"],EVENT_REPORT_DOMAIN:["statscollector-1-oceania.agora.io"],EVENT_REPORT_BACKUP_DOMAIN:["statscollector-2-oceania.agora.io"],LOG_UPLOAD_SERVER:["logservice-oceania.agora.io"],PROXY_SERVER_TYPE3:["oceania.webrtc-cloud-proxy.sd-rtn.com"]},SOUTH_AMERICA:{CODE:IS.SOUTH_AMERICA,WEBCS_DOMAIN:["ap-web-1-south-america.agora.io"],WEBCS_DOMAIN_BACKUP_LIST:["ap-web-2-south-america.agora.io"],PROXY_CS:["proxy-ap-web-south-america.agora.io"],CDS_AP:["cds-ap-web-south-america.agora.io","cds-ap-web-south-america2.agora.io"],ACCOUNT_REGISTER:["sua-ap-web-south-america.agora.io","sua-ap-web-south-america2.agora.io"],UAP_AP:["uap-ap-web-south-america.agora.io","uap-ap-web-south-america2.agora.io"],EVENT_REPORT_DOMAIN:["statscollector-1-south-america.agora.io"],EVENT_REPORT_BACKUP_DOMAIN:["statscollector-2-south-america.agora.io"],LOG_UPLOAD_SERVER:["logservice-south-america.agora.io"],PROXY_SERVER_TYPE3:["south-america.webrtc-cloud-proxy.sd-rtn.com"]},AFRICA:{CODE:IS.AFRICA,WEBCS_DOMAIN:["ap-web-1-africa.agora.io"],WEBCS_DOMAIN_BACKUP_LIST:["ap-web-2-africa.agora.io"],PROXY_CS:["proxy-ap-web-africa.agora.io"],CDS_AP:["cds-ap-web-africa.agora.io","cds-ap-web-africa2.agora.io"],ACCOUNT_REGISTER:["sua-ap-web-africa.agora.io","sua-ap-web-africa2.agora.io"],UAP_AP:["uap-ap-web-africa.agora.io","uap-ap-web-africa2.agora.io"],EVENT_REPORT_DOMAIN:["statscollector-1-africa.agora.io"],EVENT_REPORT_BACKUP_DOMAIN:["statscollector-2-africa.agora.io"],LOG_UPLOAD_SERVER:["logservice-south-africa.agora.io"],PROXY_SERVER_TYPE3:["africa.webrtc-cloud-proxy.sd-rtn.com"]},EXTENSIONS:{}};let vS,yS,AS,OS,NS,bS,wS,DS,PS,LS,kS,MS,US,xS,VS,jS,FS,BS,GS,WS,HS,KS;wE&&(CS.CHINA={CODE:IS.CHINA,WEBCS_DOMAIN:["webrtc2-2.ap.sd-rtn.com"],WEBCS_DOMAIN_BACKUP_LIST:["webrtc2-4.ap.sd-rtn.com"],PROXY_CS:["proxy-web.ap.sd-rtn.com"],CDS_AP:["cds-web-2.ap.sd-rtn.com","cds-web-4.ap.sd-rtn.com"],ACCOUNT_REGISTER:["sua-web-2.ap.sd-rtn.com","sua-web-4.ap.sd-rtn.com"],UAP_AP:["uap-web-2.ap.sd-rtn.com","uap-web-4.ap.sd-rtn.com"],EVENT_REPORT_DOMAIN:["web-3.statscollector.sd-rtn.com"],EVENT_REPORT_BACKUP_DOMAIN:["web-4.statscollector.sd-rtn.com"],LOG_UPLOAD_SERVER:["logservice-china.agora.io"],PROXY_SERVER_TYPE3:["east-cn.webrtc-cloud-proxy.sd-rtn.com"]}),function(e){e.UPDATE_BITRATE_LIMIT="update_bitrate_limit";}(vS||(vS={}));class YS extends EE{constructor(e,t){super(),_p(this,"onICEConnectionStateChange",void 0),_p(this,"onConnectionStateChange",void 0),_p(this,"onDTLSTransportStateChange",void 0),_p(this,"onDTLSTransportError",void 0),_p(this,"onICETransportStateChange",void 0),_p(this,"onFirstAudioReceived",void 0),_p(this,"onFirstVideoReceived",void 0),_p(this,"onFirstAudioDecoded",void 0),_p(this,"onFirstVideoDecoded",void 0),_p(this,"onFirstVideoDecodedTimeout",void 0),_p(this,"onSelectedLocalCandidateChanged",void 0),_p(this,"onSelectedRemoteCandidateChanged",void 0),_p(this,"establishPromise",void 0);}}!function(e){e.SEND="sendonly",e.RECV="recvonly",e.SENDRECV="sendrecv",e.INACTIVE="inactive";}(yS||(yS={})),function(e){e.VIDEO="video",e.AUDIO="audio";}(AS||(AS={})),function(e){e[e.UDP=0]="UDP",e[e.TCP=1]="TCP",e[e.RELAY=2]="RELAY";}(OS||(OS={})),function(e){e[e.FIRST_CONNECTION=0]="FIRST_CONNECTION",e[e.TCP_RESTART=1]="TCP_RESTART",e[e.RELAY_RESTART=2]="RELAY_RESTART",e[e.OLD_FIRST_CONNECTION=10]="OLD_FIRST_CONNECTION",e[e.OLD_RESTART=11]="OLD_RESTART",e[e.DISCONNECTED_OR_FAILED=20]="DISCONNECTED_OR_FAILED";}(NS||(NS={})),function(e){e.LocalVideoTrack="videoTrack",e.LocalAudioTrack="audioTrack",e.LocalVideoLowTrack="videoLowTrack";}(bS||(bS={})),function(e){e.New="new",e.Connected="connected",e.Reconnecting="reconnecting",e.Disconnected="disconnected";}(wS||(wS={})),function(e){e.StateChange="stateChange",e.IceConnectionStateChange="iceConnectionStateChange",e.RequestMuteLocal="requestMuteLocal",e.RequestUnmuteLocal="requestUnmuteLocal",e.RequestRePublish="requestRePublish",e.RequestReSubscribe="requestReSubscribe",e.RequestUploadStats="requestUploadStats",e.MediaReconnectStart="MediaReconnectStart",e.MediaReconnectEnd="MediaReconnectEnd",e.NeedSignalRTT="NeedSignalRTT",e.RequestRestartICE="RequestRestartIce",e.PeerConnectionStateChange="PeerConnectionStateChange",e.RequestReconnect="RequestReconnect",e.RequestReconnectPC="RequestReconnectPC",e.RequestUnpublishForReconnectPC="RequestUnpublishForReconnectPC",e.P2PLost="P2PLost",e.UpdateVideoEncoder="UpdateVideoEncoder",e.ConnectionTypeChange="ConnectionTypeChange",e.RequestLowStreamParameter="RequestLowStreamParameter",e.QueryClientConnectionState="QueryClientConnectionState";}(DS||(DS={})),function(e){e.ONLINE="ONLINE",e.OFFLINE="OFFLINE";}(PS||(PS={})),function(e){e.NETWORK_STATE_CHANGE="NETWORK_STATE_CHANGE",e.ONLINE="ONLINE",e.OFFLINE="OFFLINE";}(LS||(LS={})),function(e){e.ON_TRACK="on_track",e.ON_NODE="on_node";}(kS||(kS={})),function(e){e.REQUEST_UPDATE_CONSTRAINTS="request_update_constraints",e.REQUEST_CONSTRAINTS="request_constraints";}(MS||(MS={})),function(e){e.CONNECTING="CONNECTING",e.RECONNECTING="RECONNECTING",e.CONNECTED="CONNECTED",e.CLOSED="CLOSED";}(US||(US={})),function(e){e[e.CONNECT_AP=0]="CONNECT_AP",e[e.AP_CONNECTED=1]="AP_CONNECTED",e[e.CONNECT_WORKER_MANAGER=2]="CONNECT_WORKER_MANAGER",e[e.WORKER_MANAGER_CONNECTED=3]="WORKER_MANAGER_CONNECTED",e[e.GET_WORKER_MANAGER_RESPONSE=4]="GET_WORKER_MANAGER_RESPONSE",e[e.CONNECT_WORKER=5]="CONNECT_WORKER",e[e.WORKER_CONNECTED=6]="WORKER_CONNECTED",e[e.CLOSED=7]="CLOSED";}(xS||(xS={})),function(e){e.CONNECTION_STATE_CHANGE="connection-state-change",e.STATE_CHANGE="state-change",e.INSPECT_RESULT="inspect-result",e.CLIENT_LOCAL_VIDEO_TRACK="client-local-video-track",e.REQUEST_NEW_WORKER_URL="request-new-worker-url";}(VS||(VS={})),function(e){e.NETWORK_ERROR="NETWORK_ERROR",e.SERVER_ERROR="SERVER_ERROR",e.MULTI_IP="MULTI_IP",e.TIMEOUT="TIMEOUT",e.OFFLINE="OFFLINE",e.LEAVE="LEAVE",e.P2P_FAILED="P2P_FAILED",e.FALLBACK="FALLBACK";}(jS||(jS={})),function(e){e.CONNECTED="transmitter:connected",e.RECONNECTING="transmitter:reconnecting",e.WILL_RECONNECT="transmitter:will_reconnect",e.CLOSED="transmitter:closed",e.FAILED="transmitter:failed",e.ON_MESSAGE="transmitter:on_message",e.REQUEST_NEW_URLS="transmitter:request_new_urls",e.RECONNECT_WAITTING_FINISH="transmitter:reconnect_waitting_finish",e.RECONNECT_CREATE_CONNECTION="transmitter:reconnect_create_connection",e.ON_TOKEN_PRIVILEGE_DID_EXPIRE="transmitter:on_token_privilege_did_expire",e.TO_CONNECT_DATACHANNEL="transmitter:to_connect_datachannel",e.FAILBACK="transmitter:failback";}(FS||(FS={})),function(e){e.CAMERA_CHANGED="camera-changed",e.MICROPHONE_CHANGED="microphone-changed",e.PLAYBACK_DEVICE_CHANGED="playback-device-changed",e.AUDIO_AUTOPLAY_FAILED="audio-autoplay-failed",e.AUTOPLAY_FAILED="autoplay-failed",e.SECURITY_POLICY_VIOLATION="security-policy-violation";}(BS||(BS={})),function(e){e[e.APP_TYPE_INVALID_VALUE=-1]="APP_TYPE_INVALID_VALUE",e[e.APP_TYPE_NATIVE=0]="APP_TYPE_NATIVE",e[e.APP_TYPE_NATIVE_COCOS=1]="APP_TYPE_NATIVE_COCOS",e[e.APP_TYPE_NATIVE_UNITY=2]="APP_TYPE_NATIVE_UNITY",e[e.APP_TYPE_NATIVE_ELECTRON=3]="APP_TYPE_NATIVE_ELECTRON",e[e.APP_TYPE_NATIVE_FLUTTER=4]="APP_TYPE_NATIVE_FLUTTER",e[e.APP_TYPE_NATIVE_UNREAL=5]="APP_TYPE_NATIVE_UNREAL",e[e.APP_TYPE_NATIVE_XAMARIN=6]="APP_TYPE_NATIVE_XAMARIN",e[e.APP_TYPE_NATIVE_API_CLOUD=7]="APP_TYPE_NATIVE_API_CLOUD",e[e.APP_TYPE_NATIVE_REACT_NATIVE=8]="APP_TYPE_NATIVE_REACT_NATIVE",e[e.APP_TYPE_NATIVE_PYTHON=9]="APP_TYPE_NATIVE_PYTHON",e[e.APP_TYPE_NATIVE_COCOS_CREATOR=10]="APP_TYPE_NATIVE_COCOS_CREATOR",e[e.APP_TYPE_NATIVE_RUST=11]="APP_TYPE_NATIVE_RUST",e[e.APP_TYPE_NATIVE_C_SHARP=12]="APP_TYPE_NATIVE_C_SHARP",e[e.APP_TYPE_NATIVE_CEF=13]="APP_TYPE_NATIVE_CEF",e[e.APP_TYPE_NATIVE_UNI_APP=14]="APP_TYPE_NATIVE_UNI_APP",e[e.APP_TYPE_WEBRTC=1e3]="APP_TYPE_WEBRTC",e[e.APP_TYPE_WEBRTC_REACT=1001]="APP_TYPE_WEBRTC_REACT",e[e.APP_TYPE_WEBRTC_VUE=1002]="APP_TYPE_WEBRTC_VUE",e[e.APP_TYPE_WEBRTC_ANGULAR=1003]="APP_TYPE_WEBRTC_ANGULAR";}(GS||(GS={})),function(e){e.CONNECTING="CONNECTING",e.RECONNECTING="RECONNECTING",e.CONNECTED="CONNECTED",e.CLOSED="CLOSED";}(WS||(WS={})),function(e){e.CONNECTION_STATE_CHANGE="connection-state-change",e.STATE_CHANGE="state-change",e.INSPECT_RESULT="inspect-result",e.CLIENT_LOCAL_VIDEO_TRACK="client-local-video-track",e.REQUEST_NEW_WORKER_URL="request-new-worker-url";}(HS||(HS={})),function(e){e[e.CONNECT_AP=0]="CONNECT_AP",e[e.AP_CONNECTED=1]="AP_CONNECTED",e[e.CONNECT_WORKER_MANAGER=2]="CONNECT_WORKER_MANAGER",e[e.WORKER_MANAGER_CONNECTED=3]="WORKER_MANAGER_CONNECTED",e[e.GET_WORKER_MANAGER_RESPONSE=4]="GET_WORKER_MANAGER_RESPONSE",e[e.CONNECT_WORKER=5]="CONNECT_WORKER",e[e.WORKER_CONNECTED=6]="WORKER_CONNECTED",e[e.CLOSED=7]="CLOSED";}(KS||(KS={}));const qS={getDisplayMedia:!1,getStreamFromExtension:!1,supportUnifiedPlan:!1,supportMinBitrate:!1,supportSetRtpSenderParameters:!1,supportDualStream:!0,webAudioMediaStreamDest:!1,supportReplaceTrack:!1,supportWebGL:!1,webAudioWithAEC:!1,supportRequestFrame:!1,supportShareAudio:!1,supportDualStreamEncoding:!1,supportDataChannel:!1,supportPCSetConfiguration:!1,supportWebRTCEncodedTransform:!1};function JS(){return qS}let XS;!function(e){e[e.CHOOSE_SERVER=11]="CHOOSE_SERVER",e[e.CLOUD_PROXY=18]="CLOUD_PROXY",e[e.CLOUD_PROXY_5=20]="CLOUD_PROXY_5",e[e.CLOUD_PROXY_FALLBACK=26]="CLOUD_PROXY_FALLBACK";}(XS||(XS={}));var zS=k,QS=Array.isArray||function(e){return "Array"==zS(e)},ZS=h,$S=QS,eT=oc,tT=q,iT=rt("species"),nT=ZS.Array,rT=function(e){var t;return $S(e)&&(t=e.constructor,(eT(t)&&(t===nT||$S(t.prototype))||tT(t)&&null===(t=t[iT]))&&(t=void 0)),void 0===t?nT:t},oT=function(e,t){return new(rT(e))(0===t?0:t)},sT=Wt,aT=F,cT=je,dT=bi,uT=oT,lT=d([].push),hT=function(e){var t=1==e,i=2==e,n=3==e,r=4==e,o=6==e,s=7==e,a=5==e||o;return function(c,d,u,l){for(var h,p,_=cT(c),E=aT(_),m=sT(d,u),f=dT(E),S=0,T=l||uT,g=t?T(c,f):i||s?T(c,0):void 0;f>S;S++)if((a||S in E)&&(p=m(h=E[S],S,_),e))if(t)g[S]=p;else if(p)switch(e){case 3:return !0;case 5:return h;case 6:return S;case 2:lT(g,h);}else switch(e){case 4:return !1;case 7:lT(g,h);}return o?-1:n||r?r:g}},pT={forEach:hT(0),map:hT(1),filter:hT(2),some:hT(3),every:hT(4),find:hT(5),findIndex:hT(6),filterReject:hT(7)},_T=pT.forEach,ET=Vi("forEach")?[].forEach:function(e){return _T(this,e,arguments.length>1?arguments[1]:void 0)};Ii({target:"Array",proto:!0,forced:[].forEach!=ET},{forEach:ET});var mT=Hi("Array").forEach,fT=Zr,ST=Ge,TT=u,gT=mT,RT=Array.prototype,IT={DOMTokenList:!0,NodeList:!0},CT=function(e){var t=e.forEach;return e===RT||TT(RT,e)&&t===RT.forEach||ST(IT,fT(e))?gT:t},vT=je,yT=hr;Ii({target:"Object",stat:!0,forced:i((function(){yT(1);}))},{keys:function(e){return yT(vT(e))}});var AT=J.Object.keys,OT=Xi,NT=Ii,bT=QS,wT=d([].reverse),DT=[1,2];NT({target:"Array",proto:!0,forced:String(DT)===String(DT.reverse())},{reverse:function(){return bT(this)&&(this.length=this.length),wT(this)}});var PT=Hi("Array").reverse,LT=u,kT=PT,MT=Array.prototype,UT=function(e){var t=e.reverse;return e===MT||LT(MT,e)&&t===MT.reverse?kT:t},xT=i,VT=ae,jT=rt("species"),FT=function(e){return VT>=51||!xT((function(){var t=[];return (t.constructor={})[jT]=function(){return {foo:1}},1!==t[e](Boolean).foo}))},BT=Ii,GT=h,WT=QS,HT=oc,KT=q,YT=Un,qT=bi,JT=K,XT=im,zT=rt,QT=pc,ZT=FT("slice"),$T=zT("species"),eg=GT.Array,tg=Math.max;BT({target:"Array",proto:!0,forced:!ZT},{slice:function(e,t){var i,n,r,o=JT(this),s=qT(o),a=YT(e,s),c=YT(void 0===t?s:t,s);if(WT(o)&&(i=o.constructor,(HT(i)&&(i===eg||WT(i.prototype))||KT(i)&&null===(i=i[$T]))&&(i=void 0),i===eg||void 0===i))return QT(o,a,c);for(n=new(void 0===i?eg:i)(tg(c-a,0)),r=0;a<c;a++,r++)a in o&&XT(n,r,o[a]);return n.length=r,n}});var ig=Hi("Array").slice,ng=u,rg=ig,og=Array.prototype,sg=function(e){var t=e.slice;return e===og||ng(og,e)&&t===og.slice?rg:t};function ag(e,t,i,n,r){var o,s,a,c={};return CT(o=AT(n)).call(o,(function(e){c[e]=n[e];})),c.enumerable=!!c.enumerable,c.configurable=!!c.configurable,("value"in c||c.initializer)&&(c.writable=!0),c=OT(s=UT(a=sg(i).call(i)).call(a)).call(s,(function(i,n){return n(e,t,i)||i}),c),r&&void 0!==c.initializer&&(c.value=c.initializer?c.initializer.call(r):void 0,c.initializer=void 0),void 0===c.initializer&&(pp(e,t,c),c=null),c}var cg=Hi("Array").keys,dg=Zr,ug=Ge,lg=u,hg=cg,pg=Array.prototype,_g={DOMTokenList:!0,NodeList:!0},Eg=function(e){var t=e.keys;return e===pg||lg(pg,e)&&t===pg.keys||ug(_g,dg(e))?hg:t};function mg(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n);}return i}function fg(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?mg(Object(i),!0).forEach((function(t){_p(e,t,i[t]);})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):mg(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t));}));}return e}let Sg=0,Tg=0;function gg(e,t,i,n){return new Sl((r,o)=>{t.timeout=t.timeout||GE("HTTP_CONNECT_TIMEOUT"),t.responseType=t.responseType||"json",t.data&&!i?(t.data=JSON.stringify(t.data),Sg+=XI(t.data)):i&&(t.data.size?Sg+=t.data.size:t.data instanceof FormData?Sg+=function(e){let t=0;/DingTalk/i.test(navigator.userAgent)&&e.realFormData&&(e=e.realFormData);return e.forEach(e=>{t+="string"==typeof e?XI(e):e.size;}),t+138}(t.data):Sg+=XI(JSON.stringify(t.data))),t.headers=t.headers||{},t.headers["Content-Type"]=t.headers["Content-Type"]||"application/json",t.method="POST",t.url=e,pE.request(t).then(e=>{"string"==typeof e.data?Tg+=XI(e.data):e.data instanceof ArrayBuffer||e.data instanceof Uint8Array?Tg+=e.data.byteLength:Tg+=XI(JSON.stringify(e.data)),n&&r({data:e.data,headers:e.headers}),r(e.data);}).catch(e=>{pE.isCancel(e)?o(new SE(fE.OPERATION_ABORTED,"cancel token canceled")):"ECONNABORTED"===e.code?o(new SE(fE.NETWORK_TIMEOUT,e.message)):e.response?o(new SE(fE.NETWORK_RESPONSE_ERROR,e.response.status)):o(new SE(fE.NETWORK_ERROR,e.message));});})}async function Rg(e,t){const i=new Blob([t.data],{type:"buffer"});return await gg(e,fg(fg({},t),{},{data:i,headers:{"Content-Type":"application/octet-stream"}}),!0)}const Ig=new class extends EE{set networkState(e){OE.info("[".concat(this._moduleName,"]")+"network state changed, "+this._networkState+" -> "+e),this.emit(LS.NETWORK_STATE_CHANGE,e,this._networkState),e===PS.ONLINE?this.emit(LS.ONLINE):e===PS.OFFLINE&&(this.onlineWaiter=new Sl(e=>{this.once(LS.ONLINE,()=>{this.onlineWaiter=void 0,e(PS.ONLINE);});}),this.emit(LS.OFFLINE)),this._networkState=e;}get networkState(){return this._networkState}constructor(){super(),_p(this,"_moduleName","network-indicator"),_p(this,"_networkState",PS.ONLINE),_p(this,"onlineWaiter",void 0),window.addEventListener("online",()=>{this.networkState=PS.ONLINE;}),window.addEventListener("offline",()=>{this.networkState=PS.OFFLINE;});}};let Cg=!1;const vg=new class extends EE{constructor(){super(...arguments),_p(this,"onAutoplayFailed",void 0),_p(this,"onAudioAutoplayFailed",void 0);}};function yg(){if(xh(),!Cg){const e=t=>{t.preventDefault(),Cg=!1,sp()?document.body.removeEventListener("click",e,!0):(document.body.removeEventListener("touchstart",e,!0),document.body.removeEventListener("mousedown",e,!0));};Cg=!0,sp()?document.body.addEventListener("click",e,!0):(document.body.addEventListener("touchstart",e,!0),document.body.addEventListener("mousedown",e,!0)),OE.info("detect media autoplay failed, document: https://docs.agora.io/cn/Voice/autoplay_policy_web_ng?platform=Web"),vg.onAutoplayFailed?vg.onAutoplayFailed():vg.onAudioAutoplayFailed?OE.warning("AgoraRTC.onAudioAutoplayFailed has been deprecated in favor of AgoraRTC.onAutoplayFailed.\n\n  Please refer to the Agora document to migrate the newer API, https://docs.agora.io/en/Voice/autoplay_policy_web_ng?platform=Web ."):OE.warning("We have detected a media autoplay failed event, and found out that you haven't implemented AgoraRTC.onAutoplayFailed callback yet.\n\n  It will cause audio/video element not playing automatically on some browsers without user interaction, possibly hurting user experiences.\n\n  Please refer to the Agora document to properly handle autoplay failed event, https://docs.agora.io/en/Voice/autoplay_policy_web_ng?platform=Web ."),vg.emit("autoplay-failed");}}function Ag(e){return (new TextEncoder).encode(e)}const Og=function(e,t){const i=new Uint8Array(e.byteLength+t.byteLength);return i.set(new Uint8Array(e),0),i.set(new Uint8Array(t),e.byteLength),i};const Ng=async e=>function(e,t){let i="";return new Uint8Array(e).forEach(e=>{i+=e.toString(t).padStart(2,"0");}),i}(await crypto.subtle.digest("SHA-256",Ag(e)),16);function bg(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n);}return i}function wg(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?bg(Object(i),!0).forEach((function(t){_p(e,t,i[t]);})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):bg(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t));}));}return e}function Dg(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return function(t,i,n){const r=n.value;if("function"==typeof r){const o=e.className||t.__className__||("AgoraRTCClient"===t.constructor.name?"Client":t.constructor.name);n.value=function(){for(var t=arguments.length,n=new Array(t),s=0;s<t;s++)n[s]=arguments[s];let a=n;if(e.argsMap)try{a=e.argsMap(this,...n);}catch(e){OE.warning(e),a=[];}try{JSON.stringify(a);}catch(e){OE.warning("arguments for method ".concat(o,".").concat(String(i)," not serializable for apiInvoke.")),a=[];}const c=(e.report||Pg).reportApiInvoke(this._sessionId||null,{name:"".concat(o,".").concat(String(i)),options:a,tag:Ef.TRACER,reportResult:e.reportResult},e.throttleTime);try{const t=r.apply(this,n);return t instanceof Sl?t.then(t=>(c.onSuccess(e.reportResult&&t),t)).catch(e=>{throw c.onError(e),e}):(c.onSuccess(e.reportResult&&t),t)}catch(e){throw c.onError(e),e}};}return n}}const Pg=new class{constructor(){_p(this,"baseInfoMap",new Map),_p(this,"proxyServer",void 0),_p(this,"clientList",zE),_p(this,"eventUploadTimer",void 0),_p(this,"setSessionIdTimer",void 0),_p(this,"url",void 0),_p(this,"backupUrl",void 0),_p(this,"_appId",void 0),_p(this,"keyEventUploadPendingItems",[]),_p(this,"normalEventUploadPendingItems",[]),_p(this,"apiInvokeUploadPendingItems",[]),_p(this,"apiInvokeCount",0),_p(this,"ltsList",[]),_p(this,"lastSendNormalEventTime",Date.now()),_p(this,"customReportCounterTimer",void 0),_p(this,"customReportCount",0),_p(this,"extApiInvoke",async e=>{for(const t of e){const e=wg(wg({},t),{},{sid:null,invokeId:++this.apiInvokeCount,tag:Ef.TRACER});this.sendApiInvoke(e);}}),this.eventUploadTimer=window.setInterval(this.doSend.bind(this),GE("EVENT_REPORT_SEND_INTERVAL")),this.setSessionIdTimer=window.setInterval(this.appendSessionId.bind(this),GE("EVENT_REPORT_SEND_INTERVAL"));}adjustSessionStartTime(e){if(!this.baseInfoMap.has(e)&&!this.baseInfoMap.get(e))return void OE.error("adjust session ".concat(e," start time, sid is not exist or info is undefined"));const t=this.baseInfoMap.get(e),i=Date.now(),n=t.startTime;t.startTime=i,OE.debug("rewrite session ".concat(e," startTime: ").concat(i," , ").concat(i-n,"ms")),this.baseInfoMap.set(e,t);}setAppId(e){this._appId=e;}reportApiInvoke(e,t,i){t.timeout=t.timeout||6e4,t.reportResult=void 0===t.reportResult||t.reportResult;const n=Date.now();this.apiInvokeCount+=1;const r=this.apiInvokeCount,o=()=>({tag:t.tag,invokeId:r,sid:e,name:t.name,apiInvokeTime:n,options:t.options,states:t.states||null}),s=!!GE("SHOW_REPORT_INVOKER_LOG");s&&OE.info("".concat(t.name," start"),t.options);let a=!1;zI(t.timeout).then(()=>{a||(this.sendApiInvoke(wg(wg({},o()),{},{error:fE.API_INVOKE_TIMEOUT,success:!1})),OE.debug("".concat(t.name," timeout")));});const c=new SE(fE.UNEXPECTED_ERROR,"".concat(t.name,": this api invoke is end"));return {onSuccess:e=>{const n=()=>{if(a)throw c;return a=!0,this.sendApiInvoke(wg(wg({},o()),{},{success:!0},t.reportResult&&{result:e})),s&&OE.info("".concat(t.name," onSuccess")),e};return i?mC(n,t.name+"Success",i,()=>a=!0):n()},onError:e=>{const n=()=>{if(a)throw e;a=!0,this.sendApiInvoke(wg(wg({},o()),{},{success:!1,error:e})),s&&OE.info("".concat(t.name," onFailure"),e.toString());};return i?mC(n,t.name+"Error",i,()=>a=!0):n()}}}sessionInit(e,t){if(this.baseInfoMap.has(e))return;const i=Date.now(),n=this.createBaseInfo(e,i);n.cname=t.cname;const r=Object.assign({},{willUploadConsoleLog:GE("UPLOAD_LOG"),maxTouchPoints:navigator.maxTouchPoints,areaVersion:wE?"global":"oversea",areas:GE("AREAS")&&GE("AREAS").join(",")},t.extend),o=Date.now(),s=wg(wg({},n),{},{eventType:uf.SESSION_INIT,appid:t.appid,browser:navigator.userAgent,build:NE,lts:o,elapse:o-i,extend:JSON.stringify(r),mode:t.mode,process:GE("PROCESS_ID"),appType:GE("APP_TYPE"),success:!0,version:bE});this.send({type:lf.SESSION,data:s},!0);}joinChooseServer(e,t){const i=this.baseInfoMap.get(e);if(!i)return;const n=i.info,r=Date.now(),o=wg(wg({},n),{},{eventType:uf.JOIN_CHOOSE_SERVER,lts:r,eventElapse:r-t.lts,chooseServerAddr:t.csAddr,errorCode:t.ec,elapse:r-i.startTime,success:t.succ,chooseServerAddrList:JSON.stringify(t.serverList),uid:t.uid?parseInt(t.uid):null,cid:t.cid?parseInt(t.cid):null,chooseServerIp:t.csIp||"",opid:t.opid,unilbsServerIds:t.unilbsServerIds,extend:t.extend||void 0,isHttp3:t.isHttp3});this.send({type:lf.JOIN_CHOOSE_SERVER,data:o},!0);}reqUserAccount(e,t){const i=this.baseInfoMap.get(e);if(!i)return;const n=i.info,r=Date.now(),o=wg(wg({},n),{},{eventType:uf.REQ_USER_ACCOUNT,lts:r,success:t.success,serverAddress:t.serverAddr,stringUid:t.stringUid,uid:t.uid,errorCode:t.errorCode,elapse:r-i.startTime,eventElapse:r-t.lts,extend:JSON.stringify(t.extend)});this.send({type:lf.REQ_USER_ACCOUNT,data:o},!0);}joinGateway(e,t){const i=this.baseInfoMap.get(e);if(!i)return;const n=i.info;t.vid&&(n.vid=t.vid),n.uid=t.uid,n.cid=t.cid;const r=Date.now(),{firstSuccess:o,avoidJoinStartTime:s,isProxy:a,addr:c}=t,d=r-(o&&s?s:i.startTime),u=wg(wg({},n),{},{eventType:uf.JOIN_GATEWAY,lts:r,gatewayAddr:t.addr,success:t.succ,errorCode:t.ec,elapse:d,eventElapse:r-t.lts,firstSuccess:o,signalChannel:t.signalChannel}),l=u.success?1:0;if(t.succ&&(i.lastJoinSuccessTime=r),o)this.send({type:lf.JOIN_GATEWAY,data:u},!0);else {let e;if(c)if(a){const t=c.match(/h=(\d{1,3}-){3}\d{1,3}/g),i=c.match(/p=[0-9]{1,6}/g);e={isSuccess:l,gatewayIp:t&&t.length?t[0].split("=")[1].replace(/-/g,"."):"",port:i&&i.length?i[0].split("=")[1]:"",isProxy:a?1:0};}else {const t=c.match(/wss:\/\/(\d{1,3}-){3}\d{1,3}/g),i=c.match(/:[0-9]{1,6}/g);e={isSuccess:l,gatewayIp:t&&t.length?t[0].split("//")[1].replace(/-/g,"."):"",port:i&&i.length?i[0].split(":")[1]:"",isProxy:a?1:0};}else e={isSuccess:l,gatewayIp:"",port:"",isProxy:a?1:0};delete u.success,delete u.eventType,delete u.firstSuccess,u.vid=Number(u.vid);const t=Object.assign({},u,e,{eventType:uf.REJOIN_GATEWAY});this.send({type:lf.RE_JOIN_GATEWAY,data:t},!0);}}joinChannelTimeout(e,t){const i=this.baseInfoMap.get(e);if(!i)return;const n=Date.now(),r=wg(wg({},i.info),{},{lts:n,timeout:t,elapse:n-i.startTime});this.send({type:lf.JOIN_CHANNEL_TIMEOUT,data:r},!0);}publish(e,t){const i=this.baseInfoMap.get(e);if(!i)return;const n=i.info,r=Date.now(),o=wg(wg({},n),{},{eventType:uf.PUBLISH,lts:r,eventElapse:t.eventElapse,elapse:r-i.startTime,success:t.succ,errorCode:t.ec,videoName:t.videoName,audioName:t.audioName,screenName:t.screenName,screenshare:t.screenshare,audio:t.audio,video:t.video,p2pid:t.p2pid,publishRequestid:t.publishRequestid});this.send({type:lf.PUBLISH,data:o},!0);}subscribe(e,t,i){const n=this.baseInfoMap.get(e);if(!n)return;const r=n.info,o=Date.now(),s=wg(wg({},r),{},{eventType:uf.SUBSCRIBE,lts:o,eventElapse:t.eventElapse,elapse:o-n.startTime,success:t.succ,errorCode:t.ec,video:t.video,audio:t.audio,subscribeRequestid:t.subscribeRequestid,p2pid:t.p2pid},i&&{extend:JSON.stringify({isMassSubscribe:!0})});"string"==typeof t.peerid?s.peerSuid=t.peerid:s.peer=t.peerid,this.send({type:lf.SUBSCRIBE,data:s},!0);}wsCompressorInit(e){var t;const i=[...Eg(t=this.baseInfoMap).call(t)],n=i.length?i[0]:"UnableToGetSid",r=this.baseInfoMap.get(n);if(!r)return;const o=r.info,s=Date.now(),a=wg(wg({},o),{},{eventType:uf.WS_COMPRESSOR_INIT,lts:s,eventElapse:e.eventElapse,elapse:s-r.startTime,status:e.status?1:2});this.send({type:lf.WS_COMPRESSOR_INIT,data:a},!0);}firstRemoteVideoDecode(e,t,i,n){const r=this.baseInfoMap.get(e);if(!r)return;const o=r.info,s=Date.now(),a=wg(wg(wg({},o),n),{},{elapse:s-r.startTime,eventType:t,lts:s,firstDecodeFrame:Math.max(s-r.startTime,0),apEnd:Math.max(n.apEnd-r.startTime,0),apStart:Math.max(n.apStart-r.startTime,0),joinGwEnd:Math.max(n.joinGwEnd-r.startTime,0),joinGwStart:Math.max(n.joinGwStart-r.startTime,0),pcEnd:Math.max(n.pcEnd-r.startTime,0),pcStart:Math.max(n.pcStart-r.startTime,0),subscriberEnd:Math.max(n.subscriberEnd-r.startTime,0),subscriberStart:Math.max(n.subscriberStart-r.startTime,0),videoAddNotify:Math.max(n.videoAddNotify-r.startTime,0)});this.send({type:i,data:a},!0);}firstRemoteFrame(e,t,i,n){const r=this.baseInfoMap.get(e);if(!r)return;const o=r.info,s=Date.now(),a=wg(wg(wg({},o),n),{},{elapse:s-r.startTime,eventType:t,lts:s});this.send({type:i,data:a},!0);}pcStats(e,t){const i=this.baseInfoMap.get(e);if(!i)return;const n=i.info,r=Date.now(),o=wg(wg(wg({},n),t),{},{vid:void 0===n.vid?0:Number(n.vid),elapse:r-i.startTime,eventType:uf.PC_STATS,lts:r});this.send({type:lf.PC_STATS,data:o},!0);}onGatewayStream(e,t,i,n){const r=this.baseInfoMap.get(e);if(!r)return;const o=r.info,s=Date.now(),a=wg(wg(wg({},o),n),{},{eventType:t,lts:s});this.send({type:i,data:a},!0);}streamSwitch(e,t){const i=this.baseInfoMap.get(e);if(!i)return;const n=i.info,r=Date.now(),o=wg(wg({},n),{},{eventType:uf.STREAM_SWITCH,lts:r,isDual:t.isdual,elapse:r-i.startTime,success:t.succ});this.send({type:lf.STREAM_SWITCH,data:o},!0);}requestProxyAppCenter(e,t){const i=this.baseInfoMap.get(e);if(!i)return;const n=i.info,r=Date.now(),o=wg(wg({},n),{},{eventType:uf.REQUEST_PROXY_APPCENTER,lts:r,eventElapse:r-t.lts,elapse:r-i.startTime,APAddr:t.APAddr,workerManagerList:t.workerManagerList,response:t.response,errorCode:t.ec,success:t.succ});this.send({type:lf.REQUEST_PROXY_APPCENTER,data:o},!0);}requestProxyWorkerManager(e,t){const i=this.baseInfoMap.get(e);if(!i)return;const n=i.info,r=Date.now(),o=wg(wg({},n),{},{eventType:uf.REQUEST_PROXY_WORKER_MANAGER,lts:r,eventElapse:r-t.lts,elapse:r-i.startTime,workerManagerAddr:t.workerManagerAddr,response:t.response,errorCode:t.ec,success:t.succ});this.send({type:lf.REQUEST_PROXY_WORKER_MANAGER,data:o},!0);}setProxyServer(e){this.proxyServer=e,e?OE.debug("reportProxyServerurl: ".concat(e)):OE.debug("disable reportProxyServerurl: ".concat(e));}peerPublishStatus(e,t){const i=this.baseInfoMap.get(e);if(!i)return;const n=i.info,r=Date.now(),o=wg(wg({},n),{},{subscribeElapse:t.subscribeElapse,peer:t.peer,peerPublishDuration:Math.max(t.audioPublishDuration,t.videoPublishDuration),audiotag:t.audioPublishDuration>0?1:-1,videotag:t.videoPublishDuration>0?1:-1,lts:r,elapse:r-i.startTime,joinChannelSuccessElapse:r-(i.lastJoinSuccessTime||r),peerPublishDurationVideo:t.videoPublishDuration,peerPublishDurationAudio:t.audioPublishDuration});this.send({type:lf.PEER_PUBLISH_STATUS,data:o},!0);}workerEvent(e,t){const i=this.baseInfoMap.get(e);if(!i)return;const n=i.info,r=Date.now();(function(e,t,i){const n=e[t];if(!n||"string"!=typeof n)return [e];e[t]="";const r=XI(JSON.stringify(e));let o=0;const s=[];let a=0;for(let c=0;c<n.length;c++)a+=n.charCodeAt(c)<=127?1:3,a<=i-r||(s[s.length]=JI(JI({},e),{},{[t]:n.substring(o,c)}),o=c,a=n.charCodeAt(c)<=127?1:3);o!==n.length-1&&(s[s.length]=JI(JI({},e),{},{[t]:n.substring(o)}));return s})(wg(wg(wg({},n),t),{},{elapse:r-i.startTime,lts:r,productType:"WebRTC"}),"payload",1300).forEach(e=>this.send({type:lf.WORKER_EVENT,data:e},!0));}apworkerEvent(e,t){const i=this.baseInfoMap.get(e);if(!i)return;const n=i.info,r=Date.now(),o=wg(wg(wg({},n),t),{},{elapse:r-i.startTime,lts:r});this.send({type:lf.AP_WORKER_EVENT,data:o},!0);}joinWebProxyAP(e,t){const i=this.baseInfoMap.get(e);if(!i)return;const n=i.info,r=Date.now(),o=wg(wg(wg({},n),t),{},{elapse:r-i.startTime,lts:r,extend:t.extend||void 0});this.send({type:lf.JOIN_WEB_PROXY_AP,data:o},!0);}WebSocketQuit(e,t){const i=this.baseInfoMap.get(e);if(!i)return;const n=i.info,r=Date.now(),o=wg(wg(wg({},n),t),{},{elapse:r-i.startTime,lts:r});this.send({type:lf.WEBSOCKET_QUIT,data:o},!0);}async sendCustomReportMessage(e,t){if(this.customReportCount+=t.length,this.customReportCount>GE("CUSTOM_REPORT_LIMIT"))throw new SE(fE.CUSTOM_REPORT_FREQUENCY_TOO_HIGH);this.customReportCounterTimer||(this.customReportCounterTimer=window.setInterval(()=>{this.customReportCount=0;},5e3));const i=Date.now(),n=t.map(t=>({type:lf.USER_ANALYTICS,data:wg(wg({sid:e},t),{},{lts:i})}));try{GE("NEW_REPORT_SERVER")?await this.postDataToStatsCollector2(n):await this.postDataToStatsCollector(n);}catch(e){throw OE.error("send custom report message failed",e.toString()),new SE(fE.CUSTOM_REPORT_SEND_FAILED,e.message)}}autoplayFailed(e,t,i,n){if(!e)return;const r=this.baseInfoMap.get(e);if(!r)return;const o=r.info,s=Date.now(),a=wg(wg({},o),{},{vid:void 0===o.vid?0:Number(o.vid),lts:s,elapse:s-r.startTime,cbRegistered:vg.onAutoplayFailed||vg.onAudioAutoplayFailed?1:-1,errorMsg:i,mediaType:t,trackId:n,extend:void 0});this.send({type:lf.AUTOPLAY_FAILED,data:a},!0);}sendApiInvoke(e){const t=GE("NOT_REPORT_EVENT");if(e.tag&&t.includes&&t.includes(e.tag))return !1;if(null===e.sid)return this.apiInvokeUploadPendingItems.push(e),!1;const i=this.baseInfoMap.get(e.sid);if(!i)return this.apiInvokeUploadPendingItems.push(e),!1;const{cname:n,uid:r,cid:o}=i.info;e.lts=e.lts||Date.now();let s=void 0;if(e.error)if(e.error instanceof SE){const{code:t,message:i}=e.error;s=t||(i||e.error.toString());}else s=e.error.toString();const a={invokeId:e.invokeId,sid:e.sid,cname:n,cid:o,uid:r,lts:e.lts,success:e.success,elapse:e.lts-i.startTime,execElapse:e.lts-e.apiInvokeTime,apiName:e.name,options:e.options?JSON.stringify(e.options):void 0,execStates:e.states?JSON.stringify(e.states):void 0,execResult:e.result?JSON.stringify(e.result):void 0,errorCode:e.error?s:void 0,errorMsg:e.error?JSON.stringify(e.error):void 0};return this.send({type:lf.API_INVOKE,data:a},!1),!0}appendSessionId(){this.clientList.forEach(e=>{if(e._sessionId){const t=this.apiInvokeUploadPendingItems.length;for(let i=0;i<t;i++){const t=this.apiInvokeUploadPendingItems.shift();t&&(t.sid=e._sessionId,this.sendApiInvoke(Object.assign({},t)));}}});}send(e,t){if(t)return this.keyEventUploadPendingItems.push(e),void this.sendItems(this.keyEventUploadPendingItems,!0);this.normalEventUploadPendingItems.push(e),this.normalEventUploadPendingItems.length>GE("NORMAL_EVENT_QUEUE_CAPACITY")&&this.normalEventUploadPendingItems.splice(0,1),this.normalEventUploadPendingItems.length>=10&&this.sendItems(this.normalEventUploadPendingItems,!1);}doSend(){this.keyEventUploadPendingItems.length>0&&this.sendItems(this.keyEventUploadPendingItems,!0),this.normalEventUploadPendingItems.length>0&&Date.now()-this.lastSendNormalEventTime>=5e3&&this.sendItems(this.normalEventUploadPendingItems,!1);}sendItems(e,t){const i=[],n=[];for(;e.length;){const t=e.shift();i.length<20?i.push(t):n.push(t);}e.push(...n);for(const e of [...i]){var r;if(-1!==this.ltsList.indexOf(e.data.lts))e.data.lts=this.ltsList[this.ltsList.length-1]+1,this.ltsList.push(e.data.lts);else this.ltsList.push(e.data.lts),Hm(r=this.ltsList).call(r,(e,t)=>e-t);}t||(this.lastSendNormalEventTime=Date.now());return GE("ENABLE_EVENT_REPORT")?(i.length&&(GE("NEW_REPORT_SERVER")?this.postDataToStatsCollector2(i):this.postDataToStatsCollector(i)).catch((e=>i=>{GE("EVENT_REPORT_RETRY")&&(t?this.keyEventUploadPendingItems=this.keyEventUploadPendingItems.concat(e):(this.normalEventUploadPendingItems=this.normalEventUploadPendingItems.concat(e),this.normalEventUploadPendingItems.length>GE("NORMAL_EVENT_QUEUE_CAPACITY")&&(this.normalEventUploadPendingItems.splice(0,this.normalEventUploadPendingItems.length-GE("NORMAL_EVENT_QUEUE_CAPACITY")),OE.warning("report: drop normal events"))));})(i)),e):e}async postDataToStatsCollector2(e){Ig.networkState===PS.OFFLINE&&await Sl.race([Ig.onlineWaiter,zI(2*TE.maxRetryTimeout)]);const t=e=>{let t=new Uint8Array;return e.forEach(e=>{const i=Ag(JSON.stringify(e.data)),n=new ArrayBuffer(5),r=(e=>{let t=0;return Object.entries(lf).forEach(i=>{let[n,r]=i;r===e.type&&(t=pf[n]);}),t})(e),o=new DataView(n);o.setUint16(0,i.byteLength,!0),o.setUint8(2,255&r),o.setUint8(3,r>>>8&255),o.setUint8(4,r>>>16&255),t=Og(t,new Uint8Array(n)),t=Og(t,i);}),t},i="event";let n=this.proxyServer?"https://".concat(this.proxyServer,"/rs/?h=").concat(GE("NEW_REPORT_SERVER_DOMAINS")[0],"&p=443&d=").concat(i):"https://".concat(GE("NEW_REPORT_SERVER_DOMAINS")[0],"/").concat(i);for(let r=0;r<2;r+=1){1===r&&(n=this.proxyServer?"https://".concat(this.proxyServer,"/rs/?h=").concat(GE("NEW_REPORT_SERVER_DOMAINS")[1],"&p=443&d=").concat(i):"https://".concat(GE("NEW_REPORT_SERVER_DOMAINS")[1],"/").concat(i));try{await gg(n,{timeout:1e4,data:t(e),headers:wg(wg({biz:"webrtc",sendts:Math.round(Date.now()/1e3),debug:"false"},this._appId&&{appid:this._appId}),{},{"Content-Type":"application/octet-stream"})},!0);}catch(e){if(1===r)throw e;continue}return}}async postDataToStatsCollector(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const i={msgType:"EventMessages",sentTs:Math.round(Date.now()/1e3),payloads:e.map(e=>JSON.stringify(e)),vid:(e=>{const t=e&&e.data.sid&&this.baseInfoMap.get(e.data.sid);return t&&t.info.vid&&+t.info.vid||0})(e[0])};Ig.networkState===PS.OFFLINE&&await Sl.race([Ig.onlineWaiter,zI(2*TE.maxRetryTimeout)]);const n=t?"/events/proto-raws":"/events/messages";let r=this.url||(this.proxyServer?"https://".concat(this.proxyServer,"/rs/?h=").concat(GE("EVENT_REPORT_DOMAIN"),"&p=").concat(GE("STATS_COLLECTOR_PORT"),"&d=").concat(n):"https://".concat(GE("EVENT_REPORT_DOMAIN"),":").concat(GE("STATS_COLLECTOR_PORT")).concat(n));for(let e=0;e<2;e+=1){1===e&&(r=this.backupUrl||(this.proxyServer?"https://".concat(this.proxyServer,"/rs/?h=").concat(GE("EVENT_REPORT_BACKUP_DOMAIN"),"&p=").concat(GE("STATS_COLLECTOR_PORT"),"&d=").concat(n):"https://".concat(GE("EVENT_REPORT_BACKUP_DOMAIN"),":").concat(GE("STATS_COLLECTOR_PORT")).concat(n)));try{t?await Rg(r,{timeout:1e4,data:i}):await gg(r,{timeout:1e4,data:i});}catch(t){if(1===e)throw t;continue}return}}createBaseInfo(e,t){const i=Object.assign({},df);return i.sid=e,this.baseInfoMap.set(e,{info:i,startTime:t}),i}reportResourceTiming(e,t){const i=performance.getEntriesByName(e),n=i[i.length-1];n&&this.reportApiInvoke(t,{name:"Client.resourceTiming",options:n,tag:Ef.TRACER}).onSuccess();}};mE.on("REPORT_LOG_UPLOAD",e=>{e.networkState=Ig.networkState,Pg.reportApiInvoke(null,{name:"logUploadError",options:e,tag:Ef.TRACER});});class Lg extends EE{constructor(e,t){super(),_p(this,"trackMediaType",void 0),_p(this,"_ID",void 0),_p(this,"_rtpTransceiver",void 0),_p(this,"_lowRtpTransceiver",void 0),_p(this,"_hints",[]),_p(this,"_isClosed",!1),_p(this,"_originMediaStreamTrack",void 0),_p(this,"_mediaStreamTrack",void 0),_p(this,"_external",{}),this._ID=t||ZI(8,"track-"),this._originMediaStreamTrack=e,this._mediaStreamTrack=e,function(e){QE.includes(e)||QE.push(e);}(this);}toString(){return this._ID}getTrackId(){return this._ID}getMediaStreamTrack(e){if(!e){const e=Pg.reportApiInvoke(null,{name:_f.GET_MEDIA_STREAM_TRACK,options:[],tag:Ef.TRACER});this._mediaStreamTrack&&"string"==typeof this._mediaStreamTrack.label?e.onSuccess(this._mediaStreamTrack.label):e.onSuccess("");}return this._mediaStreamTrack}getRTCRtpTransceiver(e){return e===hS.LOW_STREAM?this._lowRtpTransceiver:this._rtpTransceiver}getMediaStreamTrackSettings(){return this.getMediaStreamTrack(!0).getSettings()}close(){this._isClosed=!0,this._lowRtpTransceiver=void 0,this._rtpTransceiver=void 0,function(e){const t=QE.indexOf(e);-1!==t&&QE.splice(t,1);}(this),this.emit(mS.CLOSED);}_updateRtpTransceiver(e,t){if(t===hS.LOW_STREAM){if(this._lowRtpTransceiver===e)return;this._lowRtpTransceiver=e;}else {if(this._rtpTransceiver===e)return;this._rtpTransceiver=e;}this.emit(ES.TRANSCEIVER_UPDATED,e,t);}}let kg,Mg=1;class Ug{constructor(e){_p(this,"lockingPromise",Sl.resolve()),_p(this,"locks",0),_p(this,"name",""),_p(this,"lockId",void 0),this.lockId=Mg++,e&&(this.name=e),OE.debug("[lock-".concat(this.name,"-").concat(this.lockId,"] is created."));}get isLocked(){return this.locks>0}lock(e){let t;this.locks+=1,OE.debug("[lock-".concat(this.name,"-").concat(this.lockId,"] is locked, current queue ").concat(this.locks,". ").concat("string"==typeof e?e:""));const i=new Sl(i=>{t=()=>{this.locks-=1,OE.debug("[lock-".concat(this.name,"-").concat(this.lockId,"] is not locked, current queue ").concat(this.locks,". ").concat("string"==typeof e?e:"")),i();};}),n=this.lockingPromise.then(()=>t);return this.lockingPromise=this.lockingPromise.then(()=>i),n}}function xg(e,t){return function(i,n,r){const o=r.value;if("function"!=typeof o)throw new Error("Cannot use mutex on object property.");return r.value=async function(){const i=this[t];if(!i)throw new Error("mutex property key ".concat(t," doesn't exist on ").concat(e));const r=await i.lock("From ".concat(e,".").concat(n));try{for(var s=arguments.length,a=new Array(s),c=0;c<s;c++)a[c]=arguments[c];return await o.apply(this,a)}finally{r();}},r}}class Vg extends Lg{get isExternalTrack(){return this._isExternalTrack}get muted(){return this._muted}get enabled(){return this._enabled}get processorContext(){return this._processorContext}set processorContext(e){this._processorContext=e;}constructor(e,t){super(e,t),_p(this,"_enabled",!0),_p(this,"_muted",!1),_p(this,"_isExternalTrack",!1),_p(this,"_isClosed",!1),_p(this,"_enabledMutex",void 0),_p(this,"processor",void 0),_p(this,"_processorContext",void 0),_p(this,"_handleTrackEnded",()=>{this.onTrackEnded();}),this._enabledMutex=new Ug("".concat(this.getTrackId())),e.addEventListener("ended",this._handleTrackEnded);}getTrackLabel(){var e,t;return null!==(e=null===(t=this._originMediaStreamTrack)||void 0===t?void 0:t.label)&&void 0!==e?e:""}close(){this._isClosed||(this.stop(),this._originMediaStreamTrack.stop(),this._mediaStreamTrack!==this._originMediaStreamTrack&&(this._mediaStreamTrack.stop(),this._mediaStreamTrack=null),this._originMediaStreamTrack=null,this._enabledMutex=null,OE.debug("[".concat(this.getTrackId(),"] close")),this.emit(uS.NEED_CLOSE),super.close());}async _updateOriginMediaStreamTrack(e,t){let i=arguments.length>2&&void 0!==arguments[2]&&arguments[2];this._isExternalTrack=i,e!==this._originMediaStreamTrack&&(this._originMediaStreamTrack.removeEventListener("ended",this._handleTrackEnded),t&&this._originMediaStreamTrack.stop(),e.addEventListener("ended",this._handleTrackEnded),this._originMediaStreamTrack=e,this._muted&&(this._originMediaStreamTrack.enabled=!1),this._mediaStreamTrack=this._originMediaStreamTrack,this._updatePlayerSource(),await rC(this,uS.NEED_REPLACE_TRACK,this),this.processor&&this.processor.updateInput({track:this._originMediaStreamTrack,context:this.processorContext}));}_getDefaultPlayerConfig(){return {}}onTrackEnded(){OE.debug("[".concat(this.getTrackId(),"] track ended")),this.safeEmit(mS.TRACK_ENDED);}stateCheck(e,t){if(OE.debug("check track state, [muted: ".concat(this._muted,", enabled: ").concat(this._enabled,"] to [").concat(e,": ").concat(t,"]")),Km(t,e),this._enabled&&this._muted&&"enabled"===e&&!1===t)throw new SE(fE.TRACK_STATE_UNREACHABLE,"cannot set enabled while the track is muted").print();if(!this._enabled&&!this._muted&&"muted"===e&&!0===t)throw new SE(fE.TRACK_STATE_UNREACHABLE,"cannot set muted while the track is disabled").print()}getProcessorStats(){return this.processorContext.gatherStats()}getProcessorUsage(){return this.processorContext.gatherUsage()}}function jg(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n);}return i}!function(e){e.IOS_15_16_INTERRUPTION_START="ios15_16-interruption-start",e.IOS_15_16_INTERRUPTION_END="ios15_16-interruption-end",e.IOS_INTERRUPTION_START="ios-interruption-start",e.IOS_INTERRUPTION_END="ios-interruption-end",e.STATE_CHANGE="state-change";}(kg||(kg={}));const Fg=window.AudioContext||window.webkitAudioContext;let Bg=null;const Gg=new class extends EE{constructor(){super(...arguments),_p(this,"prevState",void 0),_p(this,"curState",void 0),_p(this,"currentTime",void 0),_p(this,"currentTimeStuckAt",void 0),_p(this,"interruptDetectorTrack",void 0),_p(this,"onLocalAudioTrackMute",()=>{OE.info("ios15-interruption-start"),this.emit(kg.IOS_15_16_INTERRUPTION_START);}),_p(this,"onLocalAudioTrackUnmute",async()=>{OE.info("ios15-interruption-end"),"running"!==this.curState||this.duringInterruption?OE.info("ios15-interruption-end-canceled"):(Bg&&await Bg.suspend(),this.emit(kg.IOS_15_16_INTERRUPTION_END));});}get duringInterruption(){return "running"===this.prevState&&"interrupted"===this.curState}bindInterruptDetectorTrack(e){OE.debug("webaudio bindInterruptDetectorTrack ".concat(e.getTrackId())),this.interruptDetectorTrack||(this.interruptDetectorTrack=e,this.interruptDetectorTrack._mediaStreamTrack.onmute=this.onLocalAudioTrackMute,this.interruptDetectorTrack._mediaStreamTrack.onunmute=this.onLocalAudioTrackUnmute);}unbindInterruptDetectorTrack(e){OE.debug("webaudio unbindInterruptDetectorTrack ".concat(e.getTrackId())),this.interruptDetectorTrack&&this.interruptDetectorTrack===e&&(this.interruptDetectorTrack._mediaStreamTrack&&(this.interruptDetectorTrack._mediaStreamTrack.onmute=null,this.interruptDetectorTrack._mediaStreamTrack.onunmute=null),this.interruptDetectorTrack=void 0);}};function Wg(){if(!Fg)return void OE.error("your browser is not support web audio");OE.info("create audio context");const e=function(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?jg(Object(i),!0).forEach((function(t){_p(e,t,i[t]);})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):jg(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t));}));}return e}({},GE("WEBAUDIO_INIT_OPTIONS"));OE.debug("audio context init option:",JSON.stringify(e)),Bg=new Fg(e),Gg.curState=Bg.state,Bg.onstatechange=()=>{Gg.prevState=Gg.curState,Gg.curState=Bg?Bg.state:void 0;const{prevState:e,curState:t}=Gg,i="running"===t,n="interrupted"===t,r="running"===e,o="suspended"===e,s="interrupted"===e,a=xh().osVersion;(Yh()||tp())&&r&&n&&(OE.info("ios".concat(a,"-interruption-start")),Gg.emit(kg.IOS_INTERRUPTION_START)),(Yh()||tp())&&(o||s)&&i&&(OE.info("ios".concat(a,"-interruption-end")),Gg.emit(kg.IOS_INTERRUPTION_END)),e!==t&&(OE.debug("AudioContext State Change","".concat(e,"=>").concat(t)),Gg.emit(kg.STATE_CHANGE));},setInterval(()=>{var e;const t=null===(e=Bg)||void 0===e?void 0:e.currentTime;if(Gg.currentTime!==t)Gg.currentTimeStuckAt&&(OE.debug("AudioContext current time resume at ".concat(t)),Gg.currentTimeStuckAt=void 0),Gg.currentTime=t;else {if(t!==Gg.currentTimeStuckAt){Pg.reportApiInvoke(null,{name:"WEB_AUDIO_CURRENT_TIME_STUCK",options:{currentTime:t},tag:Ef.TRACER}).onSuccess(),OE.warning("AudioContext current time stuck at ".concat(t));}Gg.currentTimeStuckAt=t;}},5e3),async function(e){const t=["click","contextmenu","auxclick","dblclick","mousedown","mouseup","touchend","keydown","keyup"];let i,n=!1,r=!1,o=!1;function s(t){"running"===e.state?a(!1):Yh()||tp()?"suspended"===e.state&&(a(!0),t&&e.resume().then(d,d)):"closed"!==e.state&&(a(!0),t&&e.resume().then(d,d));}function a(e){if(n!==e){n=e;for(let i=0,n=t;i<n.length;i+=1){const t=n[i];e?window.addEventListener(t,u,{capture:!0,passive:!0}):window.removeEventListener(t,u,{capture:!0,passive:!0});}}}function c(){s(!0);}function d(){s(!1);}function u(){s(!0);}function l(e){if(!o)if(i.paused)if(e){h(!1),o=!0;let e=void 0;try{e=i.play(),e?e.then(p,p):(i.addEventListener("playing",p),i.addEventListener("abort",p),i.addEventListener("error",p));}catch(e){p();}}else h(!0);else h(!1);}function h(e){if(r!==e){r=e;for(let i=0,n=t;i<n.length;i++){const t=n[i];e?window.addEventListener(t,_,{capture:!0,passive:!0}):window.removeEventListener(t,_,{capture:!0,passive:!0});}}}function p(){i.removeEventListener("playing",p),i.removeEventListener("abort",p),i.removeEventListener("error",p),o=!1,l(!1);}function _(){l(!0);}if(Yh()){const t=e.createMediaStreamDestination(),n=document.createElement("div");n.innerHTML="<audio x-webkit-airplay='deny'></audio>",i=n.children.item(0),i.controls=!1,i.disableRemotePlayback=!0,i.preload="auto",i.srcObject=t.stream,l(!0);}Gg.on(kg.STATE_CHANGE,c),s(!1);}(Bg);}function Hg(){if(!Bg){if(Wg(),!Bg)throw new SE(fE.NOT_SUPPORTED,"can not create audio context");return Bg}return Bg}function Kg(){return !!Bg}function Yg(e){if(function(){if(null!==qg)return qg;const e=Hg(),t=e.createBufferSource(),i=e.createGain(),n=e.createGain();t.connect(i),t.connect(n),t.disconnect(i);let r=!1;try{t.disconnect(i);}catch(e){r=!0;}return t.disconnect(),qg=r,r}())return;const t=e.connect,i=e.disconnect;e.connect=(i,n,r)=>(e._inputNodes||(e._inputNodes=[]),e._inputNodes.includes(i)||(i instanceof AudioNode?(e._inputNodes.push(i),t.call(e,i,n,r)):t.call(e,i,n)),e),e.disconnect=(n,r,o)=>{i.call(e),n?aC(e._inputNodes,n):e._inputNodes=[];for(const i of e._inputNodes)t.call(e,i);};}let qg=null;function Jg(e,t){let i=!1;const n=1/t;if(GE("DISABLE_WEBAUDIO")){const t=window.setInterval(()=>{i?window.clearInterval(t):e(performance.now()/1e3);},1e3*n);}else {const t=Hg();let r=t.createGain();r.gain.value=0,r.connect(t.destination);const o=()=>{if(i)return void(r=null);const s=t.createOscillator();s.onended=o,s.connect(r),s.start(0),s.stop(t.currentTime+n),e(t.currentTime);};o();}return ()=>{i=!0;}}class Xg{constructor(){_p(this,"context",void 0),_p(this,"analyserNode",void 0),_p(this,"sourceNode",void 0),this.context=Hg(),this.analyserNode=this.context.createAnalyser(),this.analyserNode.fftSize=2048,this.analyserNode.smoothingTimeConstant=.4;}updateSource(e){if(e!==this.sourceNode){if(this.sourceNode)try{this.sourceNode.disconnect(this.analyserNode);}catch(e){}this.sourceNode=e,null==e||e.connect(this.analyserNode);}}getVolumeLevel(){if(!this.sourceNode)return 0;if(!this.context||Yh()||tp()||"running"!==this.context.state&&this.context.resume(),!this.analyserNode)return 0;const e=new Float32Array(this.analyserNode.fftSize);if(this.analyserNode.getFloatTimeDomainData)this.analyserNode.getFloatTimeDomainData(e);else {const t=new Uint8Array(this.analyserNode.fftSize);this.analyserNode.getByteTimeDomainData(t);for(let i=0;i<e.length;++i)e[i]=t[i]/128-1;}const t=zi(e).call(e,(e,t)=>e+t*t,0)/e.length;return Math.max(10*Math.log10(t)+100,0)/100}getAnalyserNode(){return this.analyserNode}rebuildAnalyser(){try{var e,t;null===(e=this.sourceNode)||void 0===e||e.disconnect(this.analyserNode),this.analyserNode=this.context.createAnalyser(),this.analyserNode.fftSize=2048,this.analyserNode.smoothingTimeConstant=.4,null===(t=this.sourceNode)||void 0===t||t.connect(this.analyserNode);}catch(e){OE.warning("rebuild analyser node failed.");}}destroy(){this.updateSource(void 0);}}class zg extends EE{get processSourceNode(){return this.sourceNode}set processedNode(e){var t;if(!this.isDestroyed&&this._processedNode!==e){try{var i;null===(i=this.sourceNode)||void 0===i||i.disconnect(this.outputNode);}catch(e){}null===(t=this._processedNode)||void 0===t||t.disconnect(),this._processedNode=e,this.connect();}}get processedNode(){return this._processedNode}constructor(){super(),_p(this,"outputNode",void 0),_p(this,"outputTrack",void 0),_p(this,"isPlayed",!1),_p(this,"sourceNode",void 0),_p(this,"context",void 0),_p(this,"audioBufferNode",void 0),_p(this,"destNode",void 0),_p(this,"audioOutputLevel",0),_p(this,"volumeLevelAnalyser",void 0),_p(this,"_processedNode",void 0),_p(this,"playNode",void 0),_p(this,"isDestroyed",!1),_p(this,"onNoAudioInput",void 0),_p(this,"isNoAudioInput",!1),_p(this,"_noAudioInputCount",0),this.context=Hg(),this.playNode=this.context.destination,this.outputNode=this.context.createGain(),Yg(this.outputNode),this.volumeLevelAnalyser=new Xg;}startGetAudioBuffer(e){this.audioBufferNode||(this.audioBufferNode=this.context.createScriptProcessor(e),this.outputNode.connect(this.audioBufferNode),this.audioBufferNode.connect(this.context.destination),this.audioBufferNode.onaudioprocess=e=>{this.emit(Lf.ON_AUDIO_BUFFER,function(e){for(let t=0;t<e.outputBuffer.numberOfChannels;t+=1){const i=e.outputBuffer.getChannelData(t);for(let e=0;e<i.length;e+=1)i[e]=0;}return e.inputBuffer}(e));});}stopGetAudioBuffer(){this.audioBufferNode&&(this.audioBufferNode.onaudioprocess=null,this.outputNode.disconnect(this.audioBufferNode),this.audioBufferNode=void 0);}createOutputTrack(){if(!JS().webAudioMediaStreamDest)throw new SE(fE.NOT_SUPPORTED,"your browser is not support audio processor");return this.destNode&&this.outputTrack||(this.destNode=this.context.createMediaStreamDestination(),this.outputNode.connect(this.destNode),this.outputTrack=this.destNode.stream.getAudioTracks()[0]),this.outputTrack}play(e){"running"!==this.context.state&&dC(()=>{Gg.emit("autoplay-failed");}),this.isPlayed=!0,this.playNode=e||this.context.destination,this.outputNode.connect(this.playNode);}stop(){if(this.isPlayed)try{this.outputNode.disconnect(this.playNode);}catch(e){}this.isPlayed=!1;}getAccurateVolumeLevel(){return this.volumeLevelAnalyser.getVolumeLevel()}async checkHasAudioInput(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;if(e>5)return this.isNoAudioInput=!0,this.onNoAudioInput&&this.onNoAudioInput(),!1;Yh()||tp()?"suspended"===this.context.state&&this.context.resume():"running"!==this.context.state&&this.context.resume();const t=this.volumeLevelAnalyser.getAnalyserNode();let i;t.getFloatTimeDomainData?(i=new Float32Array(t.fftSize),t.getFloatTimeDomainData(i)):(i=new Uint8Array(t.fftSize),t.getByteTimeDomainData(i));let n=!1;for(let e=0;e<i.length;e++)0!==i[e]&&(n=!0);return n?(this.isNoAudioInput=!1,!0):(await zI(200),await this.checkHasAudioInput(e?e+1:1)&&n)}getAudioVolume(){return this.outputNode.gain.value}setVolume(e){this.outputNode.gain.setValueAtTime(e,this.context.currentTime);}destroy(){this.disconnect(),this.stop(),this.isDestroyed=!0,this.onNoAudioInput=void 0;}disconnect(){var e,t;null===(e=this.processedNode)||void 0===e||e.disconnect(),null===(t=this.sourceNode)||void 0===t||t.disconnect(),this.outputNode&&this.outputNode.disconnect();}connect(){var e;this.processedNode?null===(e=this.processedNode)||void 0===e||e.connect(this.outputNode):this.sourceNode&&this.sourceNode.connect(this.outputNode);this.volumeLevelAnalyser.updateSource(this.outputNode);}}class Qg extends zg{get isFreeze(){return !1}constructor(e,t,i){var n;if(super(),_p(this,"sourceNode",void 0),_p(this,"track",void 0),_p(this,"clonedTrack",void 0),_p(this,"audioElement",void 0),_p(this,"isCurrentTrackCloned",!1),_p(this,"isRemoteTrack",!1),_p(this,"originVolumeLevelAnalyser",void 0),_p(this,"rebuildWebAudio",async()=>{if(OE.debug("ready to rebuild web audio, state:",this.context.state),this.isNoAudioInput&&await this.checkHasAudioInput(),!this.isNoAudioInput||this.isDestroyed)return document.body.removeEventListener("click",this.rebuildWebAudio,!0),void OE.debug("rebuild web audio success, current volume status",this.getAccurateVolumeLevel());this.context.resume().then(()=>OE.info("resume success")),OE.debug("rebuild web audio because of ios 12 bugs"),this.disconnect();const e=this.track;this.track=this.track.clone(),this.isCurrentTrackCloned?e.stop():this.isCurrentTrackCloned=!0;const t=new MediaStream([this.track]);this.sourceNode=this.context.createMediaStreamSource(t),Yg(this.sourceNode),this.volumeLevelAnalyser.rebuildAnalyser();const i=this.outputNode.gain.value;this.outputNode=this.context.createGain(),this.outputNode.gain.setValueAtTime(i,this.context.currentTime),Yg(this.outputNode),this.emit(Lf.UPDATE_SOURCE),this.connect(),this.audioElement.srcObject=t,this.isPlayed&&this.play(this.playNode),this.checkHasAudioInput();}),"audio"!==e.kind)throw new SE(fE.UNEXPECTED_ERROR);this.track=e;const r=new MediaStream([this.track]);if(this.isRemoteTrack=!!t,this.sourceNode=this.context.createMediaStreamSource(r),Yg(this.sourceNode),i){const e=i.clone();e.enabled=!0,this.clonedTrack=e,OE.debug("create an unmuted track ".concat(e.id," from the original track ").concat(i.id," to get the volume"));const t=this.context.createMediaStreamSource(new MediaStream([e]));Yg(t),this.originVolumeLevelAnalyser=new Xg,this.originVolumeLevelAnalyser.updateSource(t);}this.connect(),this.audioElement=document.createElement("audio"),this.audioElement.srcObject=r;const o=xh();t&&o.os===bh.IOS&&Number(null===(n=o.osVersion)||void 0===n?void 0:n.split(".")[0])<15&&(Gg.on(kg.STATE_CHANGE,()=>{"suspended"===this.context.state?document.body.addEventListener("click",this.rebuildWebAudio,!0):"running"===this.context.state&&this.rebuildWebAudio();}),this.checkHasAudioInput().then(e=>{e||document.body.addEventListener("click",this.rebuildWebAudio,!0);}));}updateTrack(e){this.sourceNode.disconnect(),this.track=e,this.isCurrentTrackCloned=!1;const t=new MediaStream([e]);this.sourceNode=this.context.createMediaStreamSource(t),Yg(this.sourceNode),this.processedNode||this.sourceNode.connect(this.outputNode),this.emit(Lf.UPDATE_SOURCE),this.audioElement.srcObject=t;}destroy(){var e;this.audioElement.srcObject=null,this.audioElement.remove(),Gg.off("state-change",this.rebuildWebAudio),null===(e=this.originVolumeLevelAnalyser)||void 0===e||e.destroy(),this.clonedTrack=void 0,super.destroy();}createMediaStreamSourceNode(e){return this.context.createMediaStreamSource(new MediaStream([e]))}updateOriginTrack(e){const t=e.clone();t.enabled=!0,this.clonedTrack&&(this.clonedTrack.stop(),this.clonedTrack=t),OE.debug("create an unmuted track ".concat(t.id," from the original track ").concat(e.id," to get the volume"));const i=this.context.createMediaStreamSource(new MediaStream([t]));Yg(i),this.originVolumeLevelAnalyser&&this.originVolumeLevelAnalyser.updateSource(i);}getOriginVolumeLevel(){return this.originVolumeLevelAnalyser?this.originVolumeLevelAnalyser.getVolumeLevel():this.getAccurateVolumeLevel()}}async function Zg(e,t){const i=(e,t)=>e?"number"!=typeof e?e.max||e.exact||e.ideal||e.min||t:e:t,n={audio:!1,video:{mandatory:{chromeMediaSource:"desktop",chromeMediaSourceId:e,maxHeight:i(t.height,1080),maxWidth:i(t.width,1920)}}};return t.frameRate&&"number"!=typeof t.frameRate?(n.video.mandatory.maxFrameRate=t.frameRate.max,n.video.mandatory.minFrameRate=t.frameRate.min):"number"==typeof t.frameRate&&(n.video.mandatory.maxFrameRate=t.frameRate),await navigator.mediaDevices.getUserMedia(n)}async function $g(e){const t=await eR(e.mediaSource),i=await function(e){return new Sl((t,i)=>{const n=document.createElement("div");n.innerText="share screen",n.setAttribute("style","text-align: center; height: 25px; line-height: 25px; border-radius: 4px 4px 0 0; background: #D4D2D4; border-bottom:  solid 1px #B9B8B9;");const r=document.createElement("div");r.setAttribute("style","width: 100%; height: 500px; padding: 15px 25px ; box-sizing: border-box;");const o=document.createElement("div");o.innerText="Agora Web Screensharing wants to share the contents of your screen with webdemo.agorabeckon.com. Choose what you'd like to share.",o.setAttribute("style","height: 12%;");const s=document.createElement("div");s.setAttribute("style","width: 100%; height: 80%; background: #FFF; border:  solid 1px #CBCBCB; display: flex; flex-wrap: wrap; justify-content: space-around; overflow-y: scroll; padding: 0 15px; box-sizing: border-box;");const a=document.createElement("div");a.setAttribute("style","text-align: right; padding: 16px 0;");const c=document.createElement("button");c.innerHTML="cancel",c.setAttribute("style","width: 85px;"),c.onclick=()=>{document.body.removeChild(d);const e=new Error("NotAllowedError");e.name="NotAllowedError",i(e);},a.appendChild(c),r.appendChild(o),r.appendChild(s),r.appendChild(a);const d=document.createElement("div");d.setAttribute("style","position: fixed; z-index: 99999999; top: 50%; left: 50%; width: 620px; height: 525px; background: #ECECEC; border-radius: 4px; -webkit-transform: translate(-50%,-50%); transform: translate(-50%,-50%);"),d.appendChild(n),d.appendChild(r),document.body.appendChild(d),e.map(e=>{if(e.id){const i=document.createElement("div");i.setAttribute("style","width: 30%; height: 160px; padding: 20px 0; text-align: center;box-sizing: content-box;");let n=e.thumbnail;const{width:r}=n.getSize();r>1920&&(n=n.resize({width:1920})),i.innerHTML='<div style="height: 120px; display: table-cell; vertical-align: middle;"><img style="width: 100%; background: #333333; box-shadow: 1px 1px 1px 1px rgba(0, 0, 0, 0.2);" src='+n.toDataURL()+' /></div><span style="\theight: 40px; line-height: 40px; display: inline-block; width: 70%; word-break: keep-all; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">'+(e.name.replace(/[\u00A0-\u9999<>\&]/g,(function(e){return "&#"+e.charCodeAt(0)+";"}))+"</span>"),i.onclick=()=>{document.body.removeChild(d),t(e.id);},s.appendChild(i);}});})}(t);return await Zg(i,e)}async function eR(e){let t=["window","screen"];"application"!==e&&"window"!==e||(t=["window"]),"screen"===e&&(t=["screen"]);const i=iR();if(!i)throw new SE(fE.ELECTRON_IS_NULL);let n=null;try{var r;n=(null===(r=i.desktopCapturer)||void 0===r?void 0:r.getSources({types:t}))||i.ipcRenderer.invoke("DESKTOP_CAPTURER_GET_SOURCES",{types:t});}catch(e){n=null;}n&&n.then||(n=new Sl((e,n)=>{i.desktopCapturer.getSources({types:t},(t,i)=>{t?n(t):e(i);});}));try{return await n}catch(e){throw new SE(fE.ELECTRON_DESKTOP_CAPTURER_GET_SOURCES_ERROR,e.toString())}}let tR=null;function iR(){if(tR)return tR;try{return tR=window.require("electron"),tR}catch(e){return null}}function nR(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n);}return i}const rR=new Ug("safari");let oR=!1,sR=!1;async function aR(e,t){let i=0,n=null;for(;i<2;)try{n=await cR(e,t,i>0);break}catch(e){if(e instanceof SE)throw OE.error("[".concat(t,"] ").concat(e.toString())),e;const n=dR(e.name||e.code||e,e.message);if(n.code===fE.MEDIA_OPTION_INVALID){OE.debug("[".concat(t,"] detect media option invalid, retry")),i+=1,await zI(500);continue}throw OE.error("[".concat(t,"] ").concat(n.toString())),n}if(!n)throw new SE(fE.UNEXPECTED_ERROR,"can not find stream after getUserMedia");return n}async function cR(e,t,i){if(!navigator.mediaDevices||!navigator.mediaDevices.getUserMedia)throw new SE(fE.NOT_SUPPORTED,"can not find getUserMedia");i&&(e.video&&(delete e.video.width,delete e.video.height),e.screen&&(delete e.screen.width,delete e.screen.height));const n=JS(),r=new MediaStream;if(e.audioSource&&r.addTrack(e.audioSource),e.videoSource&&r.addTrack(e.videoSource),!e.audio&&!e.video&&!e.screen)return OE.debug("Using Video Source/ Audio Source"),r;if(e.screen)if(iR())if(e.screen.sourceId){uR(r,await Zg(e.screen.sourceId,e.screen));}else {uR(r,await $g(e.screen));}else if(Wh()&&e.screen.extensionId&&e.screen.mandatory){if(!n.getStreamFromExtension)throw new SE(fE.NOT_SUPPORTED,"This browser does not support screen sharing");OE.debug("[".concat(t,'] Screen access on chrome stable, looking for extension"'));const i=await(s=e.screen.extensionId,a=t,new Sl((e,t)=>{try{chrome.runtime.sendMessage(s,{getStream:!0},i=>{if(!i||!i.streamId)return OE.error("[".concat(a,"] No response from Chrome Plugin. Plugin not installed properly"),i),void t(new SE(fE.CHROME_PLUGIN_NO_RESPONSE,"No response from Chrome Plugin. Plugin not installed properly"));e(i.streamId);});}catch(e){OE.error("[".concat(a,"] AgoraRTC screensharing plugin is not accessible(").concat(s,")"),e.toString()),t(new SE(fE.CHROME_PLUGIN_NOT_INSTALL));}}));e.screen.mandatory.chromeMediaSourceId=i;uR(r,await navigator.mediaDevices.getUserMedia({video:{mandatory:e.screen.mandatory}}));}else if(n.getDisplayMedia){var o;e.screen.mediaSource&&gS(e.screen.mediaSource);const i={width:e.screen.width,height:e.screen.height,frameRate:e.screen.frameRate,displaySurface:null!==(o=e.screen.displaySurface)&&void 0!==o?o:"screen"===e.screen.mediaSource?"monitor":e.screen.mediaSource},{selfBrowserSurface:n,surfaceSwitching:s,systemAudio:a}=e.screen,c={selfBrowserSurface:n,surfaceSwitching:s,systemAudio:a};!n&&delete c.selfBrowserSurface,!s&&delete c.surfaceSwitching,!a&&delete c.systemAudio,OE.debug("[".concat(t,"] getDisplayMedia:"),JSON.stringify({video:i,audio:!!e.screenAudio,controls:c}));uR(r,await navigator.mediaDevices.getDisplayMedia(function(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?nR(Object(i),!0).forEach((function(t){_p(e,t,i[t]);})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):nR(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t));}));}return e}({video:i,audio:!!e.screenAudio},c)));}else {if(!Kh())throw OE.error("[".concat(t,"] This browser does not support screenSharing")),new SE(fE.NOT_SUPPORTED,"This browser does not support screen sharing");{e.screen.mediaSource&&gS(e.screen.mediaSource);const i={video:{mediaSource:e.screen.mediaSource,width:e.screen.width,height:e.screen.height,frameRate:e.screen.frameRate}};OE.debug("[".concat(t,"] getUserMedia: ").concat(JSON.stringify(i)));uR(r,await navigator.mediaDevices.getUserMedia(i));}}var s,a;if(!e.video&&!e.audio)return r;let c={video:e.video,audio:e.audio},d=GE("MEDIA_DEVICE_CONSTRAINTS");if(d)try{"string"==typeof d&&(d=JSON.parse(d)),c=function e(t,i){if(!SC(t)||!SC(i))return i;if(Array.isArray(t)&&!Array.isArray(i)||!Array.isArray(t)&&Array.isArray(i))return i;if(Array.isArray(i)&&Array.isArray(t)){const n=[...t];for(let r=0;r<i.length;r++)n[r]=e(t[r],i[r]);return n}{const n=JI({},t);for(const r in i)Object.prototype.hasOwnProperty.call(i,r)&&(Object.prototype.hasOwnProperty.call(t,r)?n[r]=e(t[r],i[r]):n[r]=i[r]);return n}}(c,d);}catch(e){}OE.debug("[".concat(t,"] GetUserMedia"),JSON.stringify(c)),xh();let u,l=null;(Hh()||Yh()||Fh())&&(l=await rR.lock());try{u=await navigator.mediaDevices.getUserMedia(c);}catch(e){throw l&&l(),e}return c.audio&&(oR=!0),c.video&&(sR=!0),uR(r,u),l&&l(),r}function dR(e,t){switch(e){case"Starting video failed":case"OverconstrainedError":case"TrackStartError":return new SE(fE.MEDIA_OPTION_INVALID,"".concat(e,": ").concat(t));case"NotFoundError":case"DevicesNotFoundError":return new SE(fE.DEVICE_NOT_FOUND,"".concat(e,": ").concat(t));case"NotSupportedError":return new SE(fE.NOT_SUPPORTED,"".concat(e,": ").concat(t));case"NotReadableError":return new SE(fE.NOT_READABLE,"".concat(e,": ").concat(t));case"InvalidStateError":case"NotAllowedError":case"PERMISSION_DENIED":case"PermissionDeniedError":return new SE(fE.PERMISSION_DENIED,"".concat(e,": ").concat(t));case"ConstraintNotSatisfiedError":return new SE(fE.CONSTRAINT_NOT_SATISFIED,"".concat(e,": ").concat(t));default:return OE.error("getUserMedia unexpected error",e),new SE(fE.UNEXPECTED_ERROR,"".concat(e,": ").concat(t))}}function uR(e,t){const i=e.getVideoTracks()[0],n=e.getAudioTracks()[0],r=t.getVideoTracks()[0],o=t.getAudioTracks()[0];o&&(n&&e.removeTrack(n),e.addTrack(o)),r&&(i&&e.removeTrack(i),e.addTrack(r));}const lR=new class extends EE{get state(){return this._state}set state(e){e!==this._state&&(this.emit(ff.STATE_CHANGE,e),this._state=e);}constructor(){super(),_p(this,"_state",mf.IDLE),_p(this,"isAccessMicrophonePermission",!1),_p(this,"isAccessCameraPermission",!1),_p(this,"lastAccessMicrophonePermission",!1),_p(this,"lastAccessCameraPermission",!1),_p(this,"checkdeviceMatched",!1),_p(this,"deviceInfoMap",new Map),this.init().then(()=>{navigator.mediaDevices.addEventListener&&navigator.mediaDevices.addEventListener("devicechange",this.updateDevicesInfo.bind(this)),window.setInterval(()=>{(GE("ENUMERATE_DEVICES_INTERVAL")||(op()||Vh()===bh.HARMONY_OS)&&rp())&&this.updateDevicesInfo();},GE("ENUMERATE_DEVICES_INTERVAL_TIME"));}).catch(e=>OE.error(e.toString()));}async enumerateDevices(e,t){let i=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(!navigator.mediaDevices||!navigator.mediaDevices.enumerateDevices){return new SE(fE.NOT_SUPPORTED,"enumerateDevices() not supported.").throw()}const n=await navigator.mediaDevices.enumerateDevices(),r=this.checkMediaDeviceInfoIsOk(n);let o=!this.isAccessMicrophonePermission&&e,s=!this.isAccessCameraPermission&&t;r.audio&&(o=!1),r.video&&(s=!1);let a=null,c=null,d=null;if(!i&&(o||s)){if(rR.isLocked){OE.debug("[device manager] wait GUM lock");(await rR.lock())(),OE.debug("[device manager] GUM unlock");}if(oR&&(o=!1,this.isAccessMicrophonePermission=!0),sR&&(s=!1,this.isAccessCameraPermission=!0),OE.debug("[device manager] check media device permissions",e,t,o,s),o&&s){try{d=await navigator.mediaDevices.getUserMedia({audio:!0,video:!0});}catch(e){const t=dR(e.name||e.code||e,e.message);if(t.code===fE.PERMISSION_DENIED)throw t;OE.warning("getUserMedia failed in getDevices",t);}this.isAccessCameraPermission=!0,this.isAccessMicrophonePermission=!0;}else if(o){try{a=await navigator.mediaDevices.getUserMedia({audio:e});}catch(e){const t=dR(e.name||e.code||e,e.message);if(t.code===fE.PERMISSION_DENIED)throw t;OE.warning("getUserMedia failed in getDevices",t);}this.isAccessMicrophonePermission=!0;}else if(s){try{c=await navigator.mediaDevices.getUserMedia({video:t});}catch(e){const t=dR(e.name||e.code||e,e.message);if(t.code===fE.PERMISSION_DENIED)throw t;OE.warning("getUserMedia failed in getDevices",t);}this.isAccessCameraPermission=!0;}OE.debug("[device manager] mic permission",e,"cam permission",t);}try{const e=await navigator.mediaDevices.enumerateDevices();return a&&a.getTracks().forEach(e=>e.stop()),c&&c.getTracks().forEach(e=>e.stop()),d&&d.getTracks().forEach(e=>e.stop()),a=null,c=null,d=null,e}catch(e){a&&a.getTracks().forEach(e=>e.stop()),c&&c.getTracks().forEach(e=>e.stop()),d&&d.getTracks().forEach(e=>e.stop()),a=null,c=null,d=null;return new SE(fE.ENUMERATE_DEVICES_FAILED,e.toString()).throw()}}async getRecordingDevices(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];return (await this.enumerateDevices(!0,!1,e)).filter(e=>"audioinput"===e.kind)}async getCamerasDevices(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];return (await this.enumerateDevices(!1,!0,e)).filter(e=>"videoinput"===e.kind)}async getSpeakers(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];return (await this.enumerateDevices(!0,!1,e)).filter(e=>"audiooutput"===e.kind)}searchDeviceIdByName(e){let t=null;return this.deviceInfoMap.forEach(i=>{i.device.label===e&&(t=i.device.deviceId);}),t}async getDeviceById(e){const t=(await this.enumerateDevices(!0,!0,!0)).find(t=>t.deviceId===e);if(!t)throw new SE(fE.DEVICE_NOT_FOUND,"deviceId: ".concat(e));return t}async init(){this.state=mf.INITING;try{await this.updateDevicesInfo(),this.state=mf.INITEND;}catch(e){if(OE.warning("Device Detection functionality cannot start properly.",e.toString()),this.state=mf.IDLE,!function(){if("boolean"==typeof isSecureContext)return isSecureContext;return "https:"===location.protocol||"file:"===location.protocol||"localhost"===location.hostname||"127.0.0.1"===location.hostname||"::1"===location.hostname}()){new SE(fE.WEB_SECURITY_RESTRICT,"Your context is limited by web security, please try using https protocol or localhost.").throw();}throw e}}async updateDevicesInfo(){const e=await this.enumerateDevices(!0,!0,!0),t=Date.now(),i=[];if(e[0]&&e[0].label&&!1===this.checkdeviceMatched){this.checkdeviceMatched=!0;const t=e.find(e=>"audioinput"===e.kind&&"default"===e.deviceId),i=e.find(e=>"audiooutput"===e.kind&&"default"===e.deviceId);t&&i?i.groupId===t.groupId?OE.debug("[device-check] default input ".concat(t.label," and output ").concat(i.label," is the same group")):OE.warning("[device-check] default input ".concat(t.label," and output ").concat(i.label," is not the same group")):OE.debug("[device-check] default input or output not found");}const n=this.checkMediaDeviceInfoIsOk(e);if(e.forEach(e=>{if(!e.deviceId)return;const n=this.deviceInfoMap.get("".concat(e.kind,"_").concat(e.deviceId));if("ACTIVE"!==(n?n.state:"INACTIVE")){const n={initAt:t,updateAt:t,device:e,state:"ACTIVE"};this.deviceInfoMap.set("".concat(e.kind,"_").concat(e.deviceId),n),i.push(n);}n&&(n.updateAt=t);}),this.deviceInfoMap.forEach((e,n)=>{"ACTIVE"===e.state&&e.updateAt!==t&&(e.state="INACTIVE",i.push(e));}),this.state!==mf.INITEND)return n.audio&&(this.lastAccessMicrophonePermission=!0,this.isAccessMicrophonePermission=!0),void(n.video&&(this.lastAccessCameraPermission=!0,this.isAccessCameraPermission=!0));i.forEach(e=>{switch(e.device.kind){case"audioinput":this.lastAccessMicrophonePermission&&this.isAccessMicrophonePermission&&this.emit(ff.RECORDING_DEVICE_CHANGED,e);break;case"videoinput":this.lastAccessCameraPermission&&this.isAccessCameraPermission&&this.emit(ff.CAMERA_DEVICE_CHANGED,e);break;case"audiooutput":this.lastAccessMicrophonePermission&&this.isAccessMicrophonePermission&&this.emit(ff.PLAYOUT_DEVICE_CHANGED,e);}}),n.audio&&(this.lastAccessMicrophonePermission=!0,this.isAccessMicrophonePermission=!0),n.video&&(this.lastAccessCameraPermission=!0,this.isAccessCameraPermission=!0);}checkMediaDeviceInfoIsOk(e){const t=e.filter(e=>"audioinput"===e.kind),i=e.filter(e=>"videoinput"===e.kind),n={audio:!1,video:!1};for(const e of t)if(e.label&&e.deviceId){n.audio=!0;break}for(const e of i)if(e.label&&e.deviceId){n.video=!0;break}return n}};const hR=["play","playing","loadeddata","canplay","pause","stalled","suspend","waiting","abort","emptied","ended","error"],pR=new class{constructor(){_p(this,"onAutoplayFailed",void 0),_p(this,"elementMap",new Map),_p(this,"elementStateMap",new Map),_p(this,"elementsNeedToResume",[]),_p(this,"sinkIdMap",new Map),_p(this,"autoResumeAfterInterruption",()=>{Array.from(this.elementMap.entries()).forEach(e=>{let[t,i]=e;const n=this.elementStateMap.get(t),r=i.srcObject.getAudioTracks()[0];Zh()?r&&"live"===r.readyState&&"running"===Gg.curState&&(OE.debug("auto resume after interruption for iOS 15"),i.pause(),i.play()):n&&"paused"===n&&r&&"live"===r.readyState&&"running"===Gg.curState&&(OE.debug("auto resume after interruption for iOS"),i.play());});}),_p(this,"autoResumeAfterInterruptionOnIOS15_16",()=>{Array.from(this.elementMap.entries()).forEach(e=>{let[t,i]=e;const n=i.srcObject.getAudioTracks()[0];n&&"live"===n.readyState&&(OE.debug("auto resume after interruption inside autoResumeAfterInterruptionOnIOS15"),i.pause(),i.play());});}),this.autoResumeAudioElement(),Gg.on(kg.IOS_INTERRUPTION_END,this.autoResumeAfterInterruption),Gg.on(kg.IOS_15_16_INTERRUPTION_END,this.autoResumeAfterInterruptionOnIOS15_16),Gg.on(kg.STATE_CHANGE,()=>{Yh()&&"suspended"===Gg.prevState&&"running"===Gg.curState&&this.autoResumeAfterInterruption();});}async setSinkID(e,t){const i=this.elementMap.get(e);if(this.sinkIdMap.set(e,t),i)try{await i.setSinkId(t);}catch(e){throw new SE(fE.PERMISSION_DENIED,"can not set sink id: "+e.toString())}}play(e,t,i,n){if(this.elementMap.has(t))return;const r=document.createElement("audio");r.autoplay=!0,r.srcObject=new MediaStream([e]),this.bindAudioElementEvents(t,r),this.elementMap.set(t,r),this.elementStateMap.set(t,sf.INIT),this.setVolume(t,i);const o=this.sinkIdMap.get(t);if(o)try{r.setSinkId(o).catch(e=>{OE.warning("[".concat(t,"] set sink id failed"),e.toString());});}catch(e){OE.warning("[".concat(t,"] set sink id failed"),e.toString());}const s=r.play();s&&s.then&&s.catch(e=>{n&&Pg.autoplayFailed(n,"audio",e.message,t),OE.warning("audio element play warning",e.toString()),this.elementMap.has(t)&&"NotAllowedError"===e.name&&(OE.warning("detected audio element autoplay failed"),this.elementsNeedToResume.push(r),dC(()=>{this.onAutoplayFailed&&this.onAutoplayFailed(),yg();}));});}updateTrack(e,t){const i=this.elementMap.get(e);i&&(i.srcObject=new MediaStream([t]));}isPlaying(e){return this.elementMap.has(e)&&"playing"===this.elementStateMap.get(e)}setVolume(e,t){const i=this.elementMap.get(e);i&&(t=Math.max(0,Math.min(100,t)),i.volume=t/100);}stop(e){const t=this.elementMap.get(e);if(this.sinkIdMap.delete(e),!t)return;const i=this.elementsNeedToResume.indexOf(t);this.elementsNeedToResume.splice(i,1),t.srcObject=null,t.remove(),this.elementMap.delete(e),this.elementStateMap.delete(e);}bindAudioElementEvents(e,t){hR.forEach(i=>{t.addEventListener(i,i=>{const n=this.elementStateMap.get(e),r="pause"===i.type?"paused":i.type;if(OE.debug("[".concat(e,"] audio-element-status change ").concat(n," => ").concat(r)),"error"===i.type){const i=null==t?void 0:t.error;i&&OE.error("[".concat(e,"] media error, code: ").concat(i.code,", message: ").concat(i.message));}this.elementStateMap.set(e,r);});});}getPlayerState(e){return this.elementStateMap.get(e)||"uninit"}autoResumeAudioElement(){const e=()=>{this.elementsNeedToResume.forEach(e=>{e.play().then(e=>{OE.debug("Auto resume audio element success");}).catch(e=>{OE.warning("Auto resume audio element failed!",e);});}),this.elementsNeedToResume=[];};new Sl(e=>{document.body?e():window.addEventListener("load",()=>e());}).then(()=>{sp()?document.body.addEventListener("click",e,!0):(document.body.addEventListener("touchstart",e,!0),document.body.addEventListener("mousedown",e,!0));});}};function _R(){return function(e,t,i){const n=i.value;return "function"==typeof n&&(i.value=function(){this._isClosed&&new SE(fE.INVALID_OPERATION,"[".concat(this.getTrackId(),"] cannot operate a closed track")).print("warning");for(var e=arguments.length,t=new Array(e),i=0;i<e;i++)t[i]=arguments[i];const r=n.apply(this,t);return r instanceof Sl?new Sl((e,t)=>{r.then(e).catch(t);}):r}),i}}var ER=Hi("Array").values,mR=Zr,fR=Ge,SR=u,TR=ER,gR=Array.prototype,RR={DOMTokenList:!0,NodeList:!0},IR=function(e){var t=e.values;return e===gR||SR(gR,e)&&t===gR.values||fR(RR,mR(e))?TR:t};function CR(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n);}return i}function vR(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?CR(Object(i),!0).forEach((function(t){_p(e,t,i[t]);})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):CR(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t));}));}return e}class yR extends EE{constructor(e){super(),_p(this,"name","VideoProcessorDestination"),_p(this,"ID","0"),_p(this,"_source",void 0),_p(this,"videoContext",void 0),_p(this,"inputTrack",void 0),this.videoContext=e;}get kind(){return "video"}get enabled(){return !0}pipe(){throw new SE(fE.NOT_SUPPORTED,"VideoProcessor cannot pipe to any other Processor")}unpipe(){throw new SE(fE.NOT_SUPPORTED,"VideoProcessor cannot unpipe to any other Processor")}enable(){}disable(){}updateInput(e){if(e.context!==this.videoContext)throw new Error("ProcessorContext passed to VideoTrack.processorDestination doesn't match it's belonging VideoTrack's context.\nProbably you are making pipeline like this:\nvideoTrack1.pipe(processor).pipe(videoTrack2.processorDestination).");e.track&&e.track!==this.inputTrack&&(this.videoContext.chained=!0,this.inputTrack=e.track,this.emit(kS.ON_TRACK,e.track));}reset(){this.inputTrack=void 0,this.videoContext.chained=!1,this.emit(kS.ON_TRACK,void 0);}}class AR extends EE{set chained(e){this._chained=e;}get chained(){return this._chained}constructor(e,t){super(),_p(this,"constraintsMap",new Map),_p(this,"statsRegistry",[]),_p(this,"usageRegistry",[]),_p(this,"trackId",void 0),_p(this,"direction",void 0),_p(this,"_chained",!1),this.trackId=e,this.direction=t;}async getConstraints(){return await nC(this,MS.REQUEST_CONSTRAINTS)}async requestApplyConstraints(e,t){var i;return OE.info("processor ".concat(t.name," requestApplyConstraints for ").concat(this.trackId)),e&&this.constraintsMap.set(t,e),rC(this,MS.REQUEST_UPDATE_CONSTRAINTS,Array.from(IR(i=this.constraintsMap).call(i)))}async requestRevertConstraints(e){var t;if(this.constraintsMap.has(e))return OE.info("processor ".concat(e.name," requestRevertConstraints for ").concat(this.trackId)),this.constraintsMap.delete(e),rC(this,MS.REQUEST_UPDATE_CONSTRAINTS,Array.from(IR(t=this.constraintsMap).call(t)))}registerStats(e,t,i){this.statsRegistry.find(i=>i.processorID===e.ID&&i.processorName===e.name&&i.type===t)||this.statsRegistry.push({processorName:e.name,processorID:e.ID,type:t,cb:i});}unregisterStats(e,t){const i=this.statsRegistry.findIndex(i=>i.processorID===e.ID&&i.processorName===e.name&&i.type===t);-1!==i&&this.statsRegistry.splice(i,1);}gatherStats(){const e=[];for(const{processorID:t,processorName:i,type:n,cb:r}of this.statsRegistry)try{const o=r();e.push({processorID:t,processorName:i,type:n,stats:o});}catch(e){OE.error(new SE(fE.UNEXPECTED_ERROR,e.message));}return e}registerUsage(e,t){this.usageRegistry.find(t=>t.processorID===e.ID&&t.processorName===e.name)||this.usageRegistry.push({processorID:e.ID,processorName:e.name,cb:t});}unregisterUsage(e){const t=this.usageRegistry.findIndex(t=>t.processorID===e.ID&&t.processorName===e.name);-1!==t&&this.usageRegistry.splice(t,1);}async gatherUsage(){const e=[];if(!this.chained)return [];for(const{cb:t}of this.usageRegistry)try{let i=t();i instanceof Sl&&(i=await i),e.push(vR(vR({},i),{},{direction:this.direction}));}catch(e){OE.error("gather extension usage error",e);}return e}getDirection(){return this.direction}}class OR extends EE{constructor(e){super(),_p(this,"name","AudioProcessorDestination"),_p(this,"ID","0"),_p(this,"inputTrack",void 0),_p(this,"inputNode",void 0),_p(this,"audioProcessorContext",void 0),_p(this,"_source",void 0),this.audioProcessorContext=e;}get kind(){return "audio"}get enabled(){return !0}pipe(){throw new SE(fE.NOT_SUPPORTED,"AudioProcessorDestination cannot pipe to any other Processor")}unpipe(){throw new SE(fE.NOT_SUPPORTED,"AudioProcessor cannot unpipe to any other Processor")}enable(){}disable(){}reset(){this.inputTrack=void 0,this.inputNode=void 0,this.audioProcessorContext.chained=!1,this.emit(kS.ON_TRACK,void 0),this.emit(kS.ON_NODE,void 0);}updateInput(e){if(e.context!==this.audioProcessorContext)throw new Error("ProcessorContext passed to AudioTrack.processorDestination doesn't match it's belonging AudioTrack's context.\n        Probably you are making pipeline like this: audioTrack1.pipe(processor).pipe(audioTrack2.processorDestination).");e.track&&this.inputTrack!==e.track&&(this.audioProcessorContext.chained=!0,this.inputTrack=e.track,this.emit(kS.ON_TRACK,this.inputTrack)),e.node&&this.inputNode!==e.node&&(this.audioProcessorContext.chained=!0,this.inputNode=e.node,this.emit(kS.ON_NODE,this.inputNode));}}class NR extends EE{set chained(e){this._chained=e;}get chained(){return this._chained}constructor(e,t,i){super(),_p(this,"constraintsMap",new Map),_p(this,"statsRegistry",[]),_p(this,"audioContext",void 0),_p(this,"trackId",void 0),_p(this,"direction",void 0),_p(this,"usageRegistry",[]),_p(this,"_chained",!1),this.audioContext=e,this.trackId=t,this.direction=i;}async getConstraints(){return nC(this,MS.REQUEST_CONSTRAINTS)}getAudioContext(){return this.audioContext}async requestApplyConstraints(e,t){var i;return OE.info("processor ".concat(t.name," requestApplyConstraints for ").concat(this.trackId)),e&&this.constraintsMap.set(t,e),rC(this,MS.REQUEST_UPDATE_CONSTRAINTS,Array.from(IR(i=this.constraintsMap).call(i)))}async requestRevertConstraints(e){var t;if(this.constraintsMap.has(e))return this.constraintsMap.delete(e),rC(this,MS.REQUEST_UPDATE_CONSTRAINTS,Array.from(IR(t=this.constraintsMap).call(t)))}registerStats(e,t,i){this.statsRegistry.find(i=>i.processorID===e.ID&&i.processorName===e.name&&i.type===t)||this.statsRegistry.push({processorName:e.name,processorID:e.ID,type:t,cb:i});}unregisterStats(e,t){const i=this.statsRegistry.findIndex(i=>i.processorID===e.ID&&i.processorName===e.name&&i.type===t);-1!==i&&this.statsRegistry.splice(i,1);}gatherStats(){const e=[];for(const{processorID:t,processorName:i,type:n,cb:r}of this.statsRegistry)try{const o=r();e.push({processorID:t,processorName:i,type:n,stats:o});}catch(e){OE.error(new SE(fE.UNEXPECTED_ERROR,e.message));}return e}registerUsage(e,t){this.usageRegistry.find(t=>t.processorID===e.ID&&t.processorName===e.name)||this.usageRegistry.push({processorID:e.ID,processorName:e.name,cb:t});}unregisterUsage(e){const t=this.usageRegistry.findIndex(t=>t.processorID===e.ID&&t.processorName===e.name);-1!==t&&this.usageRegistry.splice(t,1);}async gatherUsage(){const e=[];if(!this.chained)return [];for(const{cb:t}of this.usageRegistry)try{let i=t();i instanceof Sl&&(i=await i),e.push(vR(vR({},i),{},{direction:this.direction}));}catch(e){OE.error("gather extension usage error",e);}return e}getDirection(){return this.direction}}class bR extends EE{get isPlayed(){return !0}get isFreeze(){return !1}constructor(){super(),_p(this,"context",void 0),_p(this,"processSourceNode",void 0),_p(this,"outputTrack",void 0),_p(this,"processedNode",void 0),_p(this,"clonedTrack",void 0),_p(this,"outputNode",void 0),this.outputNode=new wR;}setVolume(){}createOutputTrack(){throw new SE(fE.NOT_SUPPORTED,"can not create output MediaStreamTrack when WebAudio disabled")}getOriginVolumeLevel(){return 0}getAccurateVolumeLevel(){return 0}stopGetAudioBuffer(){}startGetAudioBuffer(){}play(){}stop(){}destroy(){}updateTrack(){}updateOriginTrack(){}createMediaStreamSourceNode(){}}class wR{disconnect(){}connect(){}}let DR,PR=null;class LR{constructor(){_p(this,"state","open"),_p(this,"trigger",void 0),_p(this,"tasks",[]),OE.debug("[macro-task-queue] is created."),this.trigger=setTimeout(()=>{this.state="closed",OE.debug("[macro-task-queue] will be closed, all remaining tasks will execute. [".concat(this.tasks.map(e=>e.key),"]")),this.trigger=void 0,this.tasks.forEach(e=>{let{func:t}=e;return t()}),this.tasks.length=0,OE.debug("[macro-task-queue] is closed.");});}enqueue(e,t){"closed"!==this.state&&(this.tasks.push({key:e,func:t}),OE.debug("[macro-task-queue] is queued, current queue ".concat(this.tasks.length,". ").concat("string"==typeof e?e:"")));}runTask(e){if("closed"===this.state)return;const t=this.tasks.findIndex(t=>t.key===e);if(-1!==t){const i=this.tasks.splice(t,1);OE.debug("[macro-task-queue] is unqueued, current queue ".concat(this.tasks.length,". ").concat("string"==typeof e?e:"")),i[0].func();}}release(){this.trigger&&(this.state="closed",clearTimeout(this.trigger),this.trigger=void 0,this.tasks.length=0,OE.debug("[macro-task-queue] is closed."));}}function kR(e){return function(t,i,n){var r;const o=null!==(r=n.value)&&void 0!==r?r:n.get,s=function(){PR&&"open"===PR.state&&PR.runTask(e);for(var t=arguments.length,i=new Array(t),n=0;n<t;n++)i[n]=arguments[n];return null==o?void 0:o.apply(this,...i)};return n.value?n.value=s:n.get=s,n}}var MR,UR,xR,VR,jR,FR,BR,GR,WR,HR,KR,YR,qR,JR,XR,zR,QR,ZR,$R,eI,tI,iI,nI,rI,oI,sI,aI,cI,dI,uI,lI,hI,pI,_I,EI,mI,fI,SI,TI,gI,RI,II;function CI(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n);}return i}function vI(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?CI(Object(i),!0).forEach((function(t){_p(e,t,i[t]);})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):CI(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t));}));}return e}!function(e){e.UPDATE_TRACK_SOURCE="update-track-source";}(DR||(DR={}));let yI=(MR=kR("INIT_WEBAUDIO"),UR=kR("INIT_WEBAUDIO"),xR=kR("INIT_WEBAUDIO"),VR=Dg({argsMap:(e,t)=>[e.getTrackId(),t],throttleTime:300}),jR=Dg({argsMap:(e,t)=>[e.getTrackId(),t]}),FR=_R(),BR=xg("LocalAudioTrack","_enabledMutex"),GR=Dg({argsMap:(e,t)=>[e.getTrackId(),t]}),WR=_R(),HR=xg("LocalAudioTrack","_enabledMutex"),KR=Dg({argsMap:(e,t)=>[e.getTrackId(),t]}),YR=_R(),qR=_R(),JR=_R(),XR=Dg({argsMap:e=>[e.getTrackId()]}),zR=_R(),QR=Dg({argsMap:e=>[e.getTrackId()]}),ZR=_R(),$R=Dg({argsMap:e=>[e.getTrackId()]}),eI=Dg({argsMap:(e,t)=>[e.getTrackId(),t.name]}),tI=Dg({argsMap:e=>[e.getTrackId()]}),ag((iI=class extends Vg{get _source(){return this._trackSource}set _source(e){this._trackSource=e;}get processorContext(){return this._processorContext}set processorContext(e){this._processorContext=e;}get processorDestination(){return this._processorDestination}set processorDestination(e){this._processorDestination=e;}get isPlaying(){return this._useAudioElement?pR.isPlaying(this.getTrackId()):this._source.isPlayed}get __className__(){return "LocalAudioTrack"}constructor(e,t,i,n,r){super(e,i),_p(this,"trackMediaType","audio"),_p(this,"_encoderConfig",void 0),_p(this,"_trackSource",void 0),_p(this,"_enabled",!0),_p(this,"_volume",100),_p(this,"_useAudioElement",!1),_p(this,"_bypassWebAudio",!1),_p(this,"processor",void 0),_p(this,"_processorContext",void 0),_p(this,"_processorDestination",void 0),_p(this,"_getOriginVolumeLevel",void 0),this._encoderConfig=t,this._getOriginVolumeLevel=!!n;const o=()=>{this.processorContext=new NR(this._source.context,this.getTrackId(),"local"),this.processorDestination=new OR(this.processorContext),this.bindProcessorDestinationEvents(),this._source.on(Lf.UPDATE_SOURCE,()=>{this.processor&&this.processor.updateInput({node:this._source.processSourceNode,context:this.processorContext});});},s=r&&Hh()&&!Kg();if(GE("DISABLE_WEBAUDIO")?(this._source=new bR,this._useAudioElement=!0,this._bypassWebAudio=!0):s?this._source=new bR:(this._source=new Qg(e,!1,this._getOriginVolumeLevel?e:void 0),GE("LOCAL_AUDIO_TRACK_USES_WEB_AUDIO")||(this._useAudioElement=!0)),o(),!GE("DISABLE_WEBAUDIO")&&s){(PR||(PR=new LR),PR).enqueue("INIT_WEBAUDIO",()=>{this._source=new Qg(e,!1,this._getOriginVolumeLevel?e:void 0),GE("LOCAL_AUDIO_TRACK_USES_WEB_AUDIO")||(this._useAudioElement=!0),o(),this.emit(DR.UPDATE_TRACK_SOURCE);});}}setVolume(e){qm(e,"volume",0,1e3),this._volume=e,this._source.setVolume(e/100),this._useAudioElement&&pR.setVolume(this.getTrackId(),e);try{if(this._bypassWebAudio)return void OE.debug("[".concat(this.getTrackId(),"] setVolume returned because no pass through WebAudio."));const e=this._source.createOutputTrack();this._mediaStreamTrack!==e&&(this._mediaStreamTrack=e,rC(this,uS.NEED_REPLACE_TRACK,this).then(()=>{OE.debug("[".concat(this.getTrackId(),"] replace web audio track success"));}).catch(e=>{OE.warning("[".concat(this.getTrackId(),"] replace web audio track failed"),e);}));}catch(e){}}getVolumeLevel(){return this._muted&&this.enabled&&this._getOriginVolumeLevel?this._source.getOriginVolumeLevel():this._source.getAccurateVolumeLevel()}async setPlaybackDevice(e){if(!this._useAudioElement)throw new SE(fE.NOT_SUPPORTED,"your browser does not support setting the audio output device");await pR.setSinkID(this.getTrackId(),e);}async setEnabled(e,t,i){return this._setEnabled(e,t,i)}async _setEnabled(e,t,i){if(!i){if(e===this._enabled)return;this.stateCheck("enabled",e);}if(OE.info("[".concat(this.getTrackId(),"] start setEnabled"),e),e){this._originMediaStreamTrack.enabled=!0;try{i||(this._enabled=!0),await rC(this,uS.NEED_ENABLE_TRACK,this),OE.info("[".concat(this.getTrackId(),"] setEnabled to ").concat(e," success"));}catch(e){throw i||(this._enabled=!1),OE.error("[".concat(this.getTrackId(),"] setEnabled to true error"),e.toString()),e}}else {this._originMediaStreamTrack.enabled=!1,i||(this._enabled=!1);try{await rC(this,uS.NEED_DISABLE_TRACK,this);}catch(e){throw i||(this._enabled=!0),OE.error("[".concat(this.getTrackId(),"] setEnabled to false error"),e.toString()),e}}}async setMuted(e){e!==this._muted&&(this.stateCheck("muted",e),this._muted=e,this._originMediaStreamTrack.enabled=!e,OE.debug("[".concat(this.getTrackId(),"] start set muted: ").concat(e)),e?await rC(this,uS.NEED_MUTE_TRACK,this):await rC(this,uS.NEED_UNMUTE_TRACK,this));}getStats(){hC(()=>{OE.warning("[deprecated] LocalAudioTrack.getStats will be removed in the future, use AgoraRTCClient.getLocalAudioStats instead");},"localAudioTrackGetStatsWarning");const e=oC(this,uS.GET_STATS);return e||vI({},jf)}setAudioFrameCallback(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:4096;if(!e)return this._source.removeAllListeners(Lf.ON_AUDIO_BUFFER),void this._source.stopGetAudioBuffer();this._source.startGetAudioBuffer(t),this._source.removeAllListeners(Lf.ON_AUDIO_BUFFER),this._source.on(Lf.ON_AUDIO_BUFFER,t=>e(t));}play(){OE.debug("[".concat(this.getTrackId(),"] start audio playback")),this._useAudioElement?(OE.debug("[".concat(this.getTrackId(),"] start audio playback in element")),pR.play(this._mediaStreamTrack,this.getTrackId(),this._volume)):this._source.play();}stop(){OE.debug("[".concat(this.getTrackId(),"] stop audio playback")),this._useAudioElement?pR.stop(this.getTrackId()):this._source.stop();}close(){super.close(),this.unbindProcessorDestinationEvents(),this.unbindProcessorContextEvents(),this.unpipe(),this.processorDestination._source&&this.processorDestination._source.unpipe(),this._source.destroy();}_updatePlayerSource(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];OE.debug("[".concat(this.getTrackId(),"] update player source track")),e&&this._source.updateTrack(this._mediaStreamTrack),this._useAudioElement&&pR.updateTrack(this.getTrackId(),this._mediaStreamTrack);}async _updateOriginMediaStreamTrack(e,t){this._originMediaStreamTrack!==e&&(this._originMediaStreamTrack.removeEventListener("ended",this._handleTrackEnded),e.addEventListener("ended",this._handleTrackEnded),t&&this._originMediaStreamTrack.stop(),this._originMediaStreamTrack=e,this._muted&&(this._originMediaStreamTrack.enabled=!1),this.processor&&this.processor.updateInput({track:e,context:this.processorContext}),this._mediaStreamTrack!==this._source.outputTrack?(this._mediaStreamTrack=this._originMediaStreamTrack,this._updatePlayerSource(),await rC(this,uS.NEED_REPLACE_TRACK,this)):this._source.updateTrack(this._originMediaStreamTrack),this._getOriginVolumeLevel&&this._source.updateOriginTrack(e));}renewMediaStreamTrack(e){return Sl.resolve(void 0)}pipe(e){if(this._bypassWebAudio)throw new SE(fE.INVALID_OPERATION,"Can not process AudioTrack when bypassWebAudio set to true.");if(this.processor===e)return e;if(e._source)throw new SE(fE.INVALID_OPERATION,"Processor ".concat(e.name," already piped, please call unpipe beforehand."));return this.unpipe(),this.processor=e,this.processor._source=this,e.updateInput({track:this._originMediaStreamTrack,node:this._source.processSourceNode,context:this.processorContext}),e}unpipe(){var e;if(!this.processor)return;const t=this.processor;null===(e=this._source.processSourceNode)||void 0===e||e.disconnect(),this.processor._source=!1,this.processor=void 0,t.reset();}bindProcessorDestinationEvents(){this.processorDestination.on(kS.ON_TRACK,async e=>{e?e!==this._mediaStreamTrack&&(this._mediaStreamTrack=e,this._updatePlayerSource(!1),this._source.processedNode=this._source.createMediaStreamSourceNode(e),await rC(this,uS.NEED_REPLACE_TRACK,this)):this._mediaStreamTrack!==this._originMediaStreamTrack&&(this._mediaStreamTrack=this._originMediaStreamTrack,this._updatePlayerSource(),await rC(this,uS.NEED_REPLACE_TRACK,this));}),this.processorDestination.on(kS.ON_NODE,e=>{this._source.processedNode=e;});}unbindProcessorDestinationEvents(){this.processorDestination.removeAllListeners(kS.ON_TRACK),this.processorDestination.removeAllListeners(kS.ON_NODE);}unbindProcessorContextEvents(){this.processorContext.removeAllListeners(MS.REQUEST_UPDATE_CONSTRAINTS),this.processorContext.removeAllListeners(MS.REQUEST_CONSTRAINTS);}}).prototype,"_source",[MR],Object.getOwnPropertyDescriptor(iI.prototype,"_source"),iI.prototype),ag(iI.prototype,"processorContext",[UR],Object.getOwnPropertyDescriptor(iI.prototype,"processorContext"),iI.prototype),ag(iI.prototype,"processorDestination",[xR],Object.getOwnPropertyDescriptor(iI.prototype,"processorDestination"),iI.prototype),ag(iI.prototype,"setVolume",[VR],Object.getOwnPropertyDescriptor(iI.prototype,"setVolume"),iI.prototype),ag(iI.prototype,"setPlaybackDevice",[jR,FR],Object.getOwnPropertyDescriptor(iI.prototype,"setPlaybackDevice"),iI.prototype),ag(iI.prototype,"setEnabled",[BR,GR,WR],Object.getOwnPropertyDescriptor(iI.prototype,"setEnabled"),iI.prototype),ag(iI.prototype,"setMuted",[HR,KR,YR],Object.getOwnPropertyDescriptor(iI.prototype,"setMuted"),iI.prototype),ag(iI.prototype,"getStats",[qR],Object.getOwnPropertyDescriptor(iI.prototype,"getStats"),iI.prototype),ag(iI.prototype,"setAudioFrameCallback",[JR],Object.getOwnPropertyDescriptor(iI.prototype,"setAudioFrameCallback"),iI.prototype),ag(iI.prototype,"play",[XR,zR],Object.getOwnPropertyDescriptor(iI.prototype,"play"),iI.prototype),ag(iI.prototype,"stop",[QR,ZR],Object.getOwnPropertyDescriptor(iI.prototype,"stop"),iI.prototype),ag(iI.prototype,"close",[$R],Object.getOwnPropertyDescriptor(iI.prototype,"close"),iI.prototype),ag(iI.prototype,"pipe",[eI],Object.getOwnPropertyDescriptor(iI.prototype,"pipe"),iI.prototype),ag(iI.prototype,"unpipe",[tI],Object.getOwnPropertyDescriptor(iI.prototype,"unpipe"),iI.prototype),iI),AI=(nI=Dg({argsMap:(e,t)=>[e.getTrackId(),t]}),rI=_R(),oI=xg("MicrophoneAudioTrack","_enabledMutex"),sI=Dg({argsMap:(e,t,i)=>[e.getTrackId(),t,i]}),aI=_R(),cI=Dg({argsMap:e=>[e.getTrackId()]}),ag((dI=class extends yI{get __className__(){return "MicrophoneAudioTrack"}constructor(e,t,i,n){super(e,t.encoderConfig?FE(t.encoderConfig):{},n,GE("GET_VOLUME_OF_MUTED_AUDIO_TRACK"),!0),_p(this,"_config",void 0),_p(this,"_deviceName","default"),_p(this,"_constraints",void 0),_p(this,"_originalConstraints",void 0),_p(this,"_enabled",!0),this._config=t,this._constraints=i,this._originalConstraints=i,this._deviceName=e.label,"boolean"==typeof t.bypassWebAudio&&(this._bypassWebAudio=t.bypassWebAudio),(Zh()||$h())&&Gg.bindInterruptDetectorTrack(this),this.on(DR.UPDATE_TRACK_SOURCE,()=>{this.bindProcessorContextEvents();}),Kg()&&this.bindProcessorContextEvents();}async setDevice(e){if(OE.info("[".concat(this.getTrackId(),"] start set device to ").concat(e)),this._enabled)try{const t=await lR.getDeviceById(e),i={};i.audio=vI({},this._constraints),i.audio.deviceId={exact:e},this._originMediaStreamTrack.stop();let n=null;try{n=await aR(i,this.getTrackId());}catch(e){throw OE.error("[".concat(this.getTrackId(),"] setDevice failed"),e.toString()),n=await aR({audio:this._constraints},this.getTrackId()),await this._updateOriginMediaStreamTrack(n.getAudioTracks()[0],!1),e}await this._updateOriginMediaStreamTrack(n.getAudioTracks()[0],!1),this._deviceName=t.label,this._config.microphoneId=e,this._constraints.deviceId={exact:e};}catch(e){throw OE.error("[".concat(this.getTrackId(),"] setDevice error"),e.toString()),e}else try{const t=await lR.getDeviceById(e);this._deviceName=t.label,this._config.microphoneId=e,this._constraints.deviceId={exact:e};}catch(e){throw OE.error("[".concat(this.getTrackId(),"] setDevice error"),e.toString()),e}OE.info("[".concat(this.getTrackId(),"] set device to ").concat(e," success"));}async setEnabled(e,t,i){if(t)return OE.debug("[".concat(this.getTrackId(),"] setEnabled false (do not close microphone)")),await super._setEnabled(e);if(!i){if(e===this._enabled)return;this.stateCheck("enabled",e);}if(OE.info("[".concat(this.getTrackId(),"] start setEnabled"),e),!e){var n;this._originMediaStreamTrack.onended=null,this._originMediaStreamTrack.stop(),null===(n=this._source.clonedTrack)||void 0===n||n.stop(),i||(this._enabled=!1);try{await rC(this,uS.NEED_DISABLE_TRACK,this);}catch(e){throw OE.error("[".concat(this.getTrackId(),"] setEnabled false failed"),e.toString()),e}return}const r=vI({},this._constraints),o=lR.searchDeviceIdByName(this._deviceName);o&&!r.deviceId&&(r.deviceId=o);try{i||(this._enabled=!0);const e=await aR({audio:this._constraints},this.getTrackId());await this._updateOriginMediaStreamTrack(e.getAudioTracks()[0],!1),await rC(this,uS.NEED_ENABLE_TRACK,this);}catch(e){throw i||(this._enabled=!1),OE.error("[".concat(this.getTrackId(),"] setEnabled true failed"),e.toString()),e}OE.info("[".concat(this.getTrackId(),"] setEnabled success"));}close(){super.close(),(Zh()||$h())&&Gg.unbindInterruptDetectorTrack(this);}onTrackEnded(){if((Yh()||tp())&&this._enabled&&!this._isClosed&&Gg.duringInterruption){const e=async()=>{Gg.off(kg.IOS_INTERRUPTION_END,e),this._enabled&&!this._isClosed&&(OE.debug("[".concat(this.getTrackId(),"] try capture microphone media device for interrupted iOS device.")),await this.setEnabled(!1),await this.setEnabled(!0));};Gg.on(kg.IOS_INTERRUPTION_END,e);}else OE.debug("[".concat(this.getTrackId(),"] track ended")),this.safeEmit(mS.TRACK_ENDED);}async renewMediaStreamTrack(e){const t=e||this._constraints,i=lR.searchDeviceIdByName(this._deviceName);if(i&&!t.deviceId&&(t.deviceId=i),this._constraints=t,this._enabled){this._originMediaStreamTrack.stop();const e=await aR({audio:this._constraints},this.getTrackId());await this._updateOriginMediaStreamTrack(e.getAudioTracks()[0],!0);}}bindProcessorContextEvents(){this.processorContext.on(MS.REQUEST_UPDATE_CONSTRAINTS,async(e,t,i)=>{try{const i=Object.assign({},this._originalConstraints,...e);await this.renewMediaStreamTrack(i),t();}catch(e){i(e);}}),this.processorContext.on(MS.REQUEST_CONSTRAINTS,async e=>{e(this._originMediaStreamTrack.getSettings());});}}).prototype,"setDevice",[nI,rI],Object.getOwnPropertyDescriptor(dI.prototype,"setDevice"),dI.prototype),ag(dI.prototype,"setEnabled",[oI,sI,aI],Object.getOwnPropertyDescriptor(dI.prototype,"setEnabled"),dI.prototype),ag(dI.prototype,"close",[cI],Object.getOwnPropertyDescriptor(dI.prototype,"close"),dI.prototype),dI),OI=(uI=Dg({argsMap:(e,t)=>[e.getTrackId(),t,e.duration]}),lI=_R(),hI=Dg({argsMap:e=>[e.getTrackId()]}),pI=_R(),_I=Dg({argsMap:e=>[e.getTrackId()]}),EI=_R(),mI=Dg({argsMap:e=>[e.getTrackId()]}),fI=_R(),SI=Dg({argsMap:e=>[e.getTrackId()]}),TI=_R(),gI=Dg({argsMap:e=>[e.getTrackId()]}),RI=_R(),ag((II=class extends yI{get __className__(){return "BufferSourceAudioTrack"}constructor(e,t,i,n){super(t.createOutputTrack(),i,n),_p(this,"source",void 0),_p(this,"_bufferSource",void 0),this.source=e,this._bufferSource=t,this._bufferSource.on(Lf.AUDIO_SOURCE_STATE_CHANGE,e=>{this.safeEmit(mS.SOURCE_STATE_CHANGE,e);});try{this._mediaStreamTrack=this._source.createOutputTrack();}catch(e){}}get currentState(){return this._bufferSource.currentState}get duration(){return this._bufferSource.duration}get playbackSpeed(){return this._bufferSource.playbackSpeed}getCurrentTime(){return this._bufferSource.currentTime}startProcessAudioBuffer(e){e&&this._bufferSource.updateOptions(e),this._bufferSource.startProcessAudioBuffer();}pauseProcessAudioBuffer(){this._bufferSource.pauseProcessAudioBuffer();}seekAudioBuffer(e){this._bufferSource.seekAudioBuffer(e);}resumeProcessAudioBuffer(){this._bufferSource.resumeProcessAudioBuffer();}stopProcessAudioBuffer(){this._bufferSource.stopProcessAudioBuffer();}setAudioBufferPlaybackSpeed(e){qm(e,"speed",0),this._bufferSource.setAudioBufferPlaybackSpeed(e);}}).prototype,"startProcessAudioBuffer",[uI,lI],Object.getOwnPropertyDescriptor(II.prototype,"startProcessAudioBuffer"),II.prototype),ag(II.prototype,"pauseProcessAudioBuffer",[hI,pI],Object.getOwnPropertyDescriptor(II.prototype,"pauseProcessAudioBuffer"),II.prototype),ag(II.prototype,"seekAudioBuffer",[_I,EI],Object.getOwnPropertyDescriptor(II.prototype,"seekAudioBuffer"),II.prototype),ag(II.prototype,"resumeProcessAudioBuffer",[mI,fI],Object.getOwnPropertyDescriptor(II.prototype,"resumeProcessAudioBuffer"),II.prototype),ag(II.prototype,"stopProcessAudioBuffer",[SI,TI],Object.getOwnPropertyDescriptor(II.prototype,"stopProcessAudioBuffer"),II.prototype),ag(II.prototype,"setAudioBufferPlaybackSpeed",[gI,RI],Object.getOwnPropertyDescriptor(II.prototype,"setAudioBufferPlaybackSpeed"),II.prototype),II);class NI extends yI{get __className__(){return "MixingAudioTrack"}get isActive(){for(const e of this.trackList)if(e._enabled&&!e._isClosed&&!e.muted)return !0;return !1}constructor(){const e=Hg().createMediaStreamDestination();super(e.stream.getAudioTracks()[0],void 0,ZI(8,"track-mix-")),_p(this,"trackList",void 0),_p(this,"destNode",void 0);try{this._mediaStreamTrack=this._source.createOutputTrack();}catch(e){}this.destNode=e,this.trackList=[];}hasAudioTrack(e){return -1!==this.trackList.indexOf(e)}addAudioTrack(e){-1===this.trackList.indexOf(e)?(OE.debug("add ".concat(e.getTrackId()," to mixing track")),e._source.outputNode.connect(this.destNode),this.trackList.push(e),this.updateEncoderConfig()):OE.debug("track ".concat(e.getTrackId()," is already added"));}removeAudioTrack(e){if(-1!==this.trackList.indexOf(e)){OE.debug("remove ".concat(e.getTrackId()," from mixing track"));try{e._source.outputNode.disconnect(this.destNode);}catch(e){}aC(this.trackList,e),this.updateEncoderConfig();}}updateEncoderConfig(){const e={};this.trackList.forEach(t=>{t._encoderConfig&&((t._encoderConfig.bitrate||0)>(e.bitrate||0)&&(e.bitrate=t._encoderConfig.bitrate),(t._encoderConfig.sampleRate||0)>(e.sampleRate||0)&&(e.sampleRate=t._encoderConfig.sampleRate),(t._encoderConfig.sampleSize||0)>(e.sampleSize||0)&&(e.sampleSize=t._encoderConfig.sampleSize),t._encoderConfig.stereo&&(e.stereo=!0));}),this._encoderConfig=e;}_updateRtpTransceiver(e){this._rtpTransceiver!==e&&(this._rtpTransceiver=e,this.trackList.forEach(t=>{t instanceof NI?t.emit(ES.TRANSCEIVER_UPDATED,e):t._updateRtpTransceiver(e);}));}}class bI extends EE{constructor(){super(...arguments),_p(this,"resultStorage",new Map);}setLocalAudioStats(e,t,i){this.record("AUDIO_INPUT_LEVEL_TOO_LOW",e,this.checkAudioInputLevel(i,t)),this.record("SEND_AUDIO_BITRATE_TOO_LOW",e,this.checkSendAudioBitrate(i,t));}setLocalVideoStats(e,t,i){this.record("SEND_VIDEO_BITRATE_TOO_LOW",e,this.checkSendVideoBitrate(i,t)),this.record("FRAMERATE_INPUT_TOO_LOW",e,this.checkFramerateInput(i,t)),this.record("FRAMERATE_SENT_TOO_LOW",e,this.checkFramerateSent(i));}setRemoteAudioStats(e,t){const i=e.getUserId();this.record("AUDIO_OUTPUT_LEVEL_TOO_LOW",i,this.checkAudioOutputLevel(t));}setRemoteVideoStats(e,t){const i=e.getUserId();this.record("RECV_VIDEO_DECODE_FAILED",i,this.checkVideoDecode(t));}record(e,t,i){if(GE("STATS_UPDATE_INTERVAL")>500)return;this.resultStorage.has(e)||this.resultStorage.set(e,{result:[],isPrevNormal:!0});const n=this.resultStorage.get(e);if(n&&(n.result.push(i),n.result.length>=5)){const i=n.result.includes(!0);n.isPrevNormal&&!i&&this.emit("exception",wI[e],e,t),!n.isPrevNormal&&i&&this.emit("exception",wI[e]+2e3,e+"_RECOVER",t),n.isPrevNormal=i,n.result=[];}}checkAudioOutputLevel(e){return !(e.receiveBitrate>0&&0===e.receiveLevel)}checkAudioInputLevel(e,t){return t instanceof NI&&!t.isActive||(!!t.muted||0!==e.sendVolumeLevel)}checkFramerateInput(e,t){let i=null;t._encoderConfig&&t._encoderConfig.frameRate&&(i=FI(t._encoderConfig.frameRate));const n=e.captureFrameRate;return !i||!n||!(i>10&&n<5||i<10&&i>=5&&n<=1)}checkFramerateSent(e){return !(e.captureFrameRate&&e.sendFrameRate&&e.captureFrameRate>5&&e.sendFrameRate<=1)}checkSendVideoBitrate(e,t){return !!t.muted||0!==e.sendBitrate}checkSendAudioBitrate(e,t){return t instanceof NI&&!t.isActive||(!!t.muted||0!==e.sendBitrate)}checkVideoDecode(e){return 0===e.receiveBitrate||0!==e.decodeFrameRate}}const wI={FRAMERATE_INPUT_TOO_LOW:1001,FRAMERATE_SENT_TOO_LOW:1002,SEND_VIDEO_BITRATE_TOO_LOW:1003,RECV_VIDEO_DECODE_FAILED:1005,AUDIO_INPUT_LEVEL_TOO_LOW:2001,AUDIO_OUTPUT_LEVEL_TOO_LOW:2002,SEND_AUDIO_BITRATE_TOO_LOW:2003};const DI=new class{markSubscribeStart(e,t){performance.mark("agora-web-sdk/".concat(e,"/subscribe-").concat(t));}markPublishStart(e,t){performance.mark("agora-web-sdk/".concat(e,"/publish-").concat(t));}measureFromSubscribeStart(e,t){const i=performance.getEntriesByName("agora-web-sdk/".concat(e,"/subscribe-").concat(t));if(i.length>0){const e=i[i.length-1];return Math.round(performance.now()-e.startTime)}return 0}measureFromPublishStart(e,t){const i=performance.getEntriesByName("agora-web-sdk/".concat(e,"/publish-").concat(t));if(i.length>0){const e=i[i.length-1];return Math.round(performance.now()-e.startTime)}return 0}};function PI(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n);}return i}function LI(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?PI(Object(i),!0).forEach((function(t){_p(e,t,i[t]);})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):PI(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t));}));}return e}class kI{constructor(e){_p(this,"store",void 0),_p(this,"onStatsException",void 0),_p(this,"onUploadPublishDuration",void 0),_p(this,"onStatsChanged",void 0),_p(this,"localStats",new Map),_p(this,"remoteStats",new Map),_p(this,"updateStatsInterval",void 0),_p(this,"trafficStats",void 0),_p(this,"trafficStatsPeerList",[]),_p(this,"uplinkStats",void 0),_p(this,"exceptionMonitor",void 0),_p(this,"p2pChannel",void 0),_p(this,"scalabilityMode",Lh.L1T1),_p(this,"updateStats",()=>{this.p2pChannel&&(this.updateRemoteStats(this.p2pChannel),this.updateLocalStats(this.p2pChannel));}),this.store=e,this.updateStatsInterval=window.setInterval(this.updateStats,1e3),this.exceptionMonitor=new bI,this.exceptionMonitor.on("exception",(e,t,i)=>{this.onStatsException&&this.onStatsException(e,t,i);});}reset(){this.localStats=new Map,this.remoteStats=new Map,this.trafficStats=void 0,this.trafficStatsPeerList=[],this.uplinkStats=void 0;}getLocalAudioTrackStats(){return this.localStats.get(bS.LocalAudioTrack)||LI({},jf)}getLocalVideoTrackStats(){return this.localStats.get(bS.LocalVideoTrack)||LI({},Ff)}getRemoteAudioTrackStats(e){const t=(e,t)=>{if(!this.trafficStats)return t;const i=this.trafficStats.peer_delay.find(t=>t.peer_uid===e);return i&&(t.publishDuration=i.B_ppad+(Date.now()-this.trafficStats.timestamp)),t},i={};if(e){var n;const r=null===(n=this.remoteStats.get(e))||void 0===n?void 0:n.audioStats;r&&(i[e]=t(e,r));}else Array.from(this.remoteStats.entries()).forEach(e=>{let[n,{audioStats:r}]=e;r&&(i[n]=t(n,r));});return i}getRemoteNetworkQualityStats(e){const t={};if(e){var i;const n=null===(i=this.remoteStats.get(e))||void 0===i?void 0:i.networkStats;n&&(t[e]=n);}else Array.from(this.remoteStats.entries()).forEach(e=>{let[i,{networkStats:n}]=e;n&&(t[i]=n);});return t}getRemoteVideoTrackStats(e){const t=(e,t)=>{if(!this.trafficStats)return t;const i=this.trafficStats.peer_delay.find(t=>t.peer_uid===e);return i&&(t.publishDuration=i.B_ppvd+(Date.now()-this.trafficStats.timestamp)),t},i={};if(e){var n;const r=null===(n=this.remoteStats.get(e))||void 0===n?void 0:n.videoStats;r&&(i[e]=t(e,r));}else Array.from(this.remoteStats.entries()).forEach(e=>{let[n,{videoStats:r}]=e;r&&(i[n]=t(n,r));});return i}getRTCStats(){let e=0,t=0,i=0,n=0;const r=this.localStats.get(bS.LocalAudioTrack);r&&(e+=r.sendBytes,t+=r.sendBitrate);const o=this.localStats.get(bS.LocalVideoTrack);o&&(e+=o.sendBytes,t+=o.sendBitrate);const s=this.localStats.get(bS.LocalVideoLowTrack);s&&(e+=s.sendBytes,t+=s.sendBitrate),this.remoteStats.forEach(e=>{let{audioStats:t,videoStats:r}=e;t&&(i+=t.receiveBytes,n+=t.receiveBitrate),r&&(i+=r.receiveBytes,n+=r.receiveBitrate);});let a=1;return this.trafficStats&&(a+=this.trafficStats.peer_delay.length),{Duration:0,UserCount:a,SendBitrate:t,SendBytes:e,RecvBytes:i,RecvBitrate:n,OutgoingAvailableBandwidth:this.uplinkStats?this.uplinkStats.B_uab/1e3:0,RTT:this.trafficStats?2*this.trafficStats.B_acd:0}}addLocalStats(e){this.localStats.set(e,void 0);}removeLocalStats(e){e?this.localStats.delete(e):this.localStats.clear();}addRemoteStats(e){this.remoteStats.set(e,{});}removeRemoteStats(e){e?this.remoteStats.delete(e):this.remoteStats.clear();}addP2PChannel(e){this.p2pChannel=e;}updateTrafficStats(e){e.peer_delay=e.peer_delay.filter(e=>void 0!==e.B_ppad||void 0!==e.B_ppvd);e.peer_delay.filter(e=>-1===this.trafficStatsPeerList.indexOf(e.peer_uid)).forEach(e=>{var t;const i=null===(t=this.p2pChannel)||void 0===t?void 0:t.getRemoteMedia(e.peer_uid),n=null!=i&&i.videoSSRC?DI.measureFromSubscribeStart(this.store.clientId,i.videoSSRC):0,r=null!=i&&i.audioSSRC?DI.measureFromSubscribeStart(this.store.clientId,i.audioSSRC):0;void 0!==e.B_ppad&&void 0!==e.B_ppvd&&(this.onUploadPublishDuration&&this.onUploadPublishDuration(e.peer_uid,e.B_ppad,e.B_ppvd,n>r?n:r),this.trafficStatsPeerList.push(e.peer_uid));}),this.trafficStats=e;}updateUplinkStats(e){this.uplinkStats&&this.uplinkStats.B_fir!==e.B_fir&&OE.debug("[".concat(this.store.clientId,"]: Period fir changes to ").concat(e.B_fir)),this.uplinkStats=e;}static isRemoteVideoFreeze(e,t,i){if(!e)return !1;const n=!!i&&t.framesDecodeFreezeTime>i.framesDecodeFreezeTime,r=!i||t.framesDecodeCount>i.framesDecodeCount;return n||!r}static isRemoteAudioFreeze(e){return !!e&&e._isFreeze()}isLocalVideoFreeze(e){return !(!e.inputFrame||!e.sentFrame)&&(e.inputFrame.frameRate>5&&e.sentFrame.frameRate<3)}updateLocalStats(e){Array.from(this.localStats.entries()).forEach(t=>{let[i,n]=t;switch(i){case bS.LocalVideoTrack:case bS.LocalVideoLowTrack:{const t=n,o=LI({},Ff),s=e.getStats(),a=e.getLocalMedia(i);if(s){const i=s.videoSend.find(e=>e.ssrc===(null==a?void 0:a.ssrcs[0].ssrcId));if(i){const n=e.getLocalVideoSize(),r=e.getEncoderConfig(bS.LocalVideoTrack);"H264"!==i.codec&&"H265"!==i.codec&&"VP8"!==i.codec&&"VP9"!==i.codec&&"AV1X"!==i.codec&&"AV1"!==i.codec||(o.codecType=i.codec),o.sendBytes=i.bytes,o.sendBitrate=t?8*Math.max(0,o.sendBytes-t.sendBytes):0,i.inputFrame?(o.captureFrameRate=i.inputFrame.frameRate,o.captureResolutionHeight=i.inputFrame.height,o.captureResolutionWidth=i.inputFrame.width):n&&(o.captureResolutionWidth=n.width,o.captureResolutionHeight=n.height),i.sentFrame?(o.sendFrameRate=i.sentFrame.frameRate,o.sendResolutionHeight=i.sentFrame.height,o.sendResolutionWidth=i.sentFrame.width):n&&(o.sendResolutionWidth=n.width,o.sendResolutionHeight=n.height),i.avgEncodeMs&&(o.encodeDelay=i.avgEncodeMs),r&&r.bitrateMax&&(o.targetSendBitrate=1e3*r.bitrateMax),o.sendPackets=i.packets,o.sendPacketsLost=i.packetsLost,o.totalDuration=t?t.totalDuration+1:1,o.totalFreezeTime=t?t.totalFreezeTime:0,this.isLocalVideoFreeze(i)&&(o.totalFreezeTime+=1),i.scalabilityMode&&this.scalabilityMode!==i.scalabilityMode&&(OE.debug("[".concat(this.store.clientId,"]: The scalabilityMode of the video sending stream is ").concat(i.scalabilityMode)),this.scalabilityMode=i.scalabilityMode);}this.trafficStats&&(o.sendPacketsLost=this.trafficStats.B_pvlr4/100);}var r;if(this.localStats.set(i,o),(null==t?void 0:t.sendResolutionWidth)!==o.sendResolutionWidth||(null==t?void 0:t.sendResolutionHeight)!==o.sendResolutionHeight)null===(r=this.onStatsChanged)||void 0===r||r.call(this,"resolution",{width:o.sendResolutionWidth,height:o.sendResolutionHeight});o&&a&&this.exceptionMonitor.setLocalVideoStats(this.store.uid,a.track,o);break}case bS.LocalAudioTrack:{const t=n,r=LI({},jf),o=e.getStats(),s=e.getLocalMedia(i);if(o){const i=o.audioSend.find(e=>e.ssrc===(null==s?void 0:s.ssrcs[0].ssrcId));if(i){if("opus"!==i.codec&&"aac"!==i.codec&&"PCMU"!==i.codec&&"PCMA"!==i.codec&&"G722"!==i.codec||(r.codecType=i.codec),i.inputLevel)r.sendVolumeLevel=Math.round(32767*i.inputLevel);else {const t=e.getLocalAudioVolume();t&&(r.sendVolumeLevel=Math.round(32767*t));}r.sendBytes=i.bytes,r.sendPackets=i.packets,r.sendPacketsLost=i.packetsLost,r.sendBitrate=t?8*Math.max(0,r.sendBytes-t.sendBytes):0;}}this.trafficStats&&(r.sendPacketsLost=this.trafficStats.B_pvlr4/100),this.localStats.set(bS.LocalAudioTrack,r),r&&s&&this.exceptionMonitor.setLocalAudioStats(this.store.uid,s.track,r);break}}});}updateRemoteStats(e){Array.from(this.remoteStats.entries()).forEach(t=>{let[i,{videoStats:n,audioStats:r,videoPcStats:o}]=t;const s=r,a=n,c=o,d=LI({},Bf),u=LI({},Wf),l=LI({},Gf),{audioTrack:h,videoTrack:p,audioSSRC:_,videoSSRC:E}=e.getRemoteMedia(i),m=e.getStats(),f=null==m?void 0:m.audioRecv.find(e=>e.ssrc===_),S=null==m?void 0:m.videoRecv.find(e=>e.ssrc===E),T=this.trafficStats&&this.trafficStats.peer_delay.find(e=>e.peer_uid===i);if(f&&("opus"!==f.codec&&"aac"!==f.codec&&"PCMU"!==f.codec&&"PCMA"!==f.codec&&"G722"!==f.codec||(d.codecType=f.codec),f.outputLevel?d.receiveLevel=Math.round(32767*f.outputLevel):h&&(d.receiveLevel=Math.round(32767*h.getVolumeLevel())),d.receiveBytes=f.bytes,d.receivePackets=f.packets,d.receivePacketsLost=f.packetsLost,d.packetLossRate=d.receivePacketsLost/(d.receivePackets+d.receivePacketsLost),d.receiveBitrate=s?8*Math.max(0,d.receiveBytes-s.receiveBytes):0,d.totalDuration=s?s.totalDuration+1:1,d.totalFreezeTime=s?s.totalFreezeTime:0,d.freezeRate=d.totalFreezeTime/d.totalDuration,d.receiveDelay=f.jitterBufferMs,d.totalDuration>10&&kI.isRemoteAudioFreeze(h)&&(d.totalFreezeTime+=1)),S){"H264"!==S.codec&&"H265"!==S.codec&&"VP8"!==S.codec&&"VP9"!==S.codec&&"AV1X"!==S.codec&&"AV1"!==S.codec||(u.codecType=S.codec),u.receiveBytes=S.bytes,u.receiveBitrate=a?8*Math.max(0,u.receiveBytes-a.receiveBytes):0,u.decodeFrameRate=S.decodeFrameRate<0?0:S.decodeFrameRate,u.renderFrameRate=S.decodeFrameRate<0?0:S.decodeFrameRate,S.outputFrame&&(u.renderFrameRate=S.outputFrame.frameRate),S.receivedFrame?(u.receiveFrameRate=S.receivedFrame.frameRate,u.receiveResolutionHeight=S.receivedFrame.height,u.receiveResolutionWidth=S.receivedFrame.width):p&&(u.receiveResolutionHeight=p._videoHeight||0,u.receiveResolutionWidth=p._videoWidth||0),void 0!==S.framesRateFirefox&&(u.receiveFrameRate=Math.round(S.framesRateFirefox)),u.receivePackets=S.packets,u.receivePacketsLost=S.packetsLost,u.packetLossRate=u.receivePacketsLost/(u.receivePackets+u.receivePacketsLost),u.totalDuration=a?a.totalDuration+1:1,u.totalFreezeTime=a?a.totalFreezeTime:0,u.receiveDelay=S.jitterBufferMs||0;const t=!!E&&e.getRemoteVideoIsReady(E);p&&t&&kI.isRemoteVideoFreeze(p,S,c)&&(u.totalFreezeTime+=1),u.freezeRate=u.totalFreezeTime/u.totalDuration;}T&&(d.end2EndDelay=T.B_ad,u.end2EndDelay=T.B_vd,d.transportDelay=T.B_ed,u.transportDelay=T.B_ed,d.currentPacketLossRate=T.B_ealr4/100,u.currentPacketLossRate=T.B_evlr4/100,l.uplinkNetworkQuality=T.B_punq?T.B_punq:0,l.downlinkNetworkQuality=T.B_pdnq?T.B_pdnq:0),this.remoteStats.set(i,{audioStats:d,videoStats:u,videoPcStats:S,networkStats:l}),h&&this.exceptionMonitor.setRemoteAudioStats(h,d),p&&this.exceptionMonitor.setRemoteVideoStats(p,u);});}}const MI=new class extends EE{get visibility(){return document.visibilityState}get lastHiddenTime(){return this._lastHiddenTime}get lastVisibleTime(){return this._lastVisibleTime}constructor(){super(),_p(this,"_lastHiddenTime",0),_p(this,"_lastVisibleTime",0),document.addEventListener("visibilitychange",()=>{"hidden"===document.visibilityState?this._lastHiddenTime=performance.now():this._lastVisibleTime=performance.now(),OE.debug("document visibility went ".concat(document.visibilityState)),this.emit("VISIBILITY_CHANGE",document.visibilityState);});}};function UI(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n);}return i}function xI(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?UI(Object(i),!0).forEach((function(t){_p(e,t,i[t]);})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):UI(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t));}));}return e}function VI(e){return e.match(/^[\.\:\d]+$/)?"".concat(e.replace(/[^\d]/g,"-"),".").concat(GE("TURN_DOMAIN")):(OE.info("Cannot recognized as IP address ".concat(e,". Used As Host instead")),e)}function jI(e,t){var i,n;const r=GE("GATEWAY_DOMAINS");let o=r[1]&&-1!==t.indexOf(r[1])?1:0;e.addresses=e.addresses||[];const s=e.addresses.map(e=>e.domain_prefix?{address:"".concat(e.domain_prefix,".").concat(r[o++%r.length],":").concat(e.port)}:e.ip.match(/^[\.\:\d]+$/)?{ip:e.ip,port:e.port,address:"".concat(e.ip.replace(/[^\d]/g,"-"),".").concat(r[o++%r.length],":").concat(e.port)}:(OE.info("Cannot recognized as IP address ".concat(e.ip,". Used As Host instead")),{ip:e.ip,port:e.port,address:"".concat(e.ip,":").concat(e.port)}));if(null!==(i=e.detail)&&void 0!==i&&i[18]&&"string"==typeof(null===(n=e.detail)||void 0===n?void 0:n[18])){const t=e.detail[18],i=null==t?void 0:t.split(";");for(let e=0;e<i.length;e++){var a;const t=mh(a=i[e]).call(a);s[e]&&t&&(s[e].ip6=t);}}return {gatewayAddrs:s,uid:e.uid,cid:e.cid,cert:e.cert,vid:e.detail&&e.detail[8],uni_lbs_ip:e.detail&&e.detail[1],res:e,csIp:e.detail&&e.detail[502]}}function FI(e){return "number"==typeof e?e:e.exact||e.ideal||e.max||e.min||0}function BI(e){const t=e._encoderConfig;if(!t)return {};const i={resolution:t.width&&t.height?"".concat(FI(t.width),"x").concat(FI(t.height)):void 0,maxVideoBW:t.bitrateMax,minVideoBW:t.bitrateMin};return "number"==typeof t.frameRate?(i.maxFrameRate=t.frameRate,i.minFrameRate=t.frameRate):t.frameRate&&(i.maxFrameRate=t.frameRate.max||t.frameRate.ideal||t.frameRate.exact||t.frameRate.min,i.minFrameRate=t.frameRate.min||t.frameRate.ideal||t.frameRate.exact||t.frameRate.max),i}function GI(e){return e>=0&&e<.17?1:e>=.17&&e<.36?2:e>=.36&&e<.59?3:e>=.59&&e<=1?4:e>1?5:0}function WI(e,t){let i,n,r=void 0;switch(t){case XS.CHOOSE_SERVER:i=4096,n="choose server";break;case XS.CLOUD_PROXY:i=1048576,n="proxy";break;case XS.CLOUD_PROXY_5:i=4194304,n="proxy5";break;case XS.CLOUD_PROXY_FALLBACK:i=4194310,n="proxy fallback";break;default:throw new SE(fE.UNEXPECTED_ERROR,"multi unlibs response transformer get unknown service id",{csIp:e.detail&&e.detail[502],retry:!1})}if(e.response_body.forEach(t=>{t.buffer&&t.buffer.flag===i&&(r={code:t.buffer.code,addresses:(t.buffer.edges_services||[]).map(e=>xI(xI({},e),{},{ticket:t.buffer.cert})),server_ts:e.enter_ts,uid:t.buffer.uid,cid:t.buffer.cid,cname:t.buffer.cname,detail:xI(xI({},t.buffer.detail),e.detail),flag:t.buffer.flag,opid:e.opid,cert:t.buffer.cert});}),!r)throw new SE(fE.MULTI_UNILBS_RESPONSE_ERROR,"cannot parse response ".concat(n," from multi unilbs response"),{csIp:e.detail&&e.detail[502]});return r}async function HI(e,t){return await Sl.all(e.addresses.map(async e=>({address:VI(e.ip),tcpport:e.port,udpport:e.port,username:t&&GE("ENCRYPT_PROXY_USERNAME_AND_PSW")&&window.isSecureContext?t.toString():PE.username,password:t&&GE("ENCRYPT_PROXY_USERNAME_AND_PSW")&&window.isSecureContext?await Ng(t.toString()):PE.password})))}function KI(e,t){const i=t._videoWidth||t.getMediaStreamTrack(!0).getSettings().width;return i||OE.warning("cannot get original video track's width, default scale down 4 times for low stream"),i?i/FI(e.width):4}function YI(e){let{candidateType:t,relayProtocol:i,type:n,address:r,port:o,protocol:s}=e;return "local-candidate"===n?{candidateType:t,relayProtocol:i,protocol:s}:{candidateType:t,relayProtocol:i,address:r,port:o,protocol:s}}function qI(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n);}return i}function JI(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?qI(Object(i),!0).forEach((function(t){_p(e,t,i[t]);})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):qI(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t));}));}return e}function XI(e){return window.TextEncoder?(new TextEncoder).encode(e).length:e.length}function zI(e){return new Sl(t=>{window.setTimeout(t,e);})}function QI(e){const t=new SE(fE.TIMEOUT,"timeout");return new Sl((i,n)=>{window.setTimeout(()=>n(t),e);})}function ZI(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:7,t=arguments.length>1?arguments[1]:void 0;const i=Math.random().toString(16).substr(2,e).toLowerCase();return i.length===e?"".concat(t).concat(i):"".concat(t).concat(i)+ZI(e-i.length,"")}function $I(){return ZI(32,"").toUpperCase()}const eC=()=>{};function tC(e){return new Sl((t,i)=>{let n=!1;const r=document.createElement("video");r.setAttribute("autoplay",""),r.setAttribute("muted",""),r.muted=!0,r.autoplay=!0,r.setAttribute("playsinline",""),r.setAttribute("style","position: fixed; top: 0; left: 0; width: 1px; height: 1px"),document.body.appendChild(r);const o=Yh()?"canplay":"playing";r.addEventListener(o,()=>{const e=r.videoWidth,i=r.videoHeight;!e&&Kh()||(n=!0,r.srcObject=null,r.remove(),t([e,i]));}),r.srcObject=new MediaStream([e]),r.play().catch(eC),setTimeout(()=>{n||(r.srcObject=null,r.remove(),t([r.videoWidth,r.videoHeight]));},4e3);})}function iC(e){return Sl.all(e.map(e=>e.then(e=>{throw e},e=>e))).then(e=>{throw e},e=>e)}function nC(e,t){for(var i=arguments.length,n=new Array(i>2?i-2:0),r=2;r<i;r++)n[r-2]=arguments[r];return 0===e.getListeners(t).length?Sl.reject(new SE(fE.UNEXPECTED_ERROR,"can not emit promise")):new Sl((i,r)=>{e.emit(t,...n,i,r);})}function rC(e,t){if(0===e.getListeners(t).length)return Sl.resolve();for(var i=arguments.length,n=new Array(i>2?i-2:0),r=2;r<i;r++)n[r-2]=arguments[r];return nC(e,t,...n)}function oC(e,t){if(0===e.getListeners(t).length)return null;for(var i=arguments.length,n=new Array(i>2?i-2:0),r=2;r<i;r++)n[r-2]=arguments[r];return sC(e,t,...n)}function sC(e,t){let i=null,n=null;for(var r=arguments.length,o=new Array(r>2?r-2:0),s=2;s<r;s++)o[s-2]=arguments[s];if(e.emit(t,...o,e=>{i=e;},e=>{n=e;}),null!==n)throw n;if(null===i)throw new SE(fE.UNEXPECTED_ERROR,"handler is not sync");return i}function aC(e,t){const i=e.indexOf(t);-1!==i&&e.splice(i,1);}function cC(e){const t=[];return e.forEach(e=>{-1===t.indexOf(e)&&t.push(e);}),t}function dC(e){Sl.resolve().then(e);}function uC(e){return JSON.parse(JSON.stringify(e))}const lC={};function hC(e,t){lC[t]||(lC[t]=!0,e());}function pC(e){const t=window.atob(e),i=new Uint8Array(new ArrayBuffer(t.length));for(let e=0;e<t.length;e+=1)i[e]=t.charCodeAt(e);return i}function _C(e){let t="";for(let i=0;i<e.length;i+=1)t+=String.fromCharCode(e[i]);return window.btoa(t)}const EC=new class{constructor(){_p(this,"fnMap",new Map);}throttleByKey(e,t,i,n){for(var r=arguments.length,o=new Array(r>4?r-4:0),s=4;s<r;s++)o[s-4]=arguments[s];if(this.fnMap.has(t)){const r=this.fnMap.get(t);if(r.threshold!==i){r.fn(...r.args),clearTimeout(r.timer);const s=window.setTimeout(()=>{const e=this.fnMap.get(t);e&&e.fn(...e.args),this.fnMap.delete(t);},i);this.fnMap.set(t,{fn:e,threshold:i,timer:s,args:o,skipFn:n});}else r.skipFn&&r.skipFn(...r.args),this.fnMap.set(t,JI(JI({},r),{},{fn:e,args:o,skipFn:n}));}else {const r=window.setTimeout(()=>{const e=this.fnMap.get(t);e&&e.fn(...e.args),this.fnMap.delete(t);},i);this.fnMap.set(t,{fn:e,threshold:i,timer:r,args:o,skipFn:n});}}},mC=EC.throttleByKey.bind(EC),fC=async e=>{let{fragementLength:t,referenceList:i,asyncMapHandler:n,allFailedhandler:r,promisesCollector:o}=e,s=0;const a=t;let c,d=0;const u=async()=>{const e=(()=>{const e=s*a,t=e+a;return i.slice(e,t).map(n)})();o&&o.push(...e);try{c=await iC(e);}catch(e){if(d+=a,s++,!(d>=i.length))return void await u();r(e);}e.forEach(e=>e.cancel());};return await u(),c};function SC(e){return "object"==typeof e&&null!==e&&!(e instanceof RegExp)}const TC={[Sf.ACCESS_POINT]:{[Rf.NO_FLAG_SET]:{desc:"flag is zero",retry:!1},[Rf.FLAG_SET_BUT_EMPTY]:{desc:"flag is empty",retry:!1},[Rf.INVALID_FALG_SET]:{desc:"invalid flag",retry:!1},[Rf.FLAG_SET_BUT_NO_RE]:{desc:"flag set unilbs but no request",retry:!1},[Rf.INVALID_SERVICE_ID]:{desc:"invalid service id",retry:!1},[Rf.NO_SERVICE_AVAILABLE]:{desc:"no service available",retry:!0},[Rf.NO_SERVICE_AVAILABLE_P2P]:{desc:"no unilbs p2p service available",retry:!0},[Rf.NO_SERVICE_AVAILABLE_VOET]:{desc:"no unilbs voice service available",retry:!0},[Rf.NO_SERVICE_AVAILABLE_WEBRTC]:{desc:"no unilbs webrtc service available",retry:!0},[Rf.NO_SERVICE_AVAILABLE_CDS]:{desc:"no cds service available",retry:!0},[Rf.NO_SERVICE_AVAILABLE_CDN]:{desc:"no cdn dispatcher service available",retry:!0},[Rf.NO_SERVICE_AVAILABLE_TDS]:{desc:"no tds service available",retry:!0},[Rf.NO_SERVICE_AVAILABLE_REPORT]:{desc:"no unilbs report service available",retry:!0},[Rf.NO_SERVICE_AVAILABLE_APP_CENTER]:{desc:"no app center service available",retry:!0},[Rf.NO_SERVICE_AVAILABLE_ENV0]:{desc:"no unilbs sig env0 service available",retry:!0},[Rf.NO_SERVICE_AVAILABLE_VOET]:{desc:"no unilbs voet service available",retry:!0},[Rf.NO_SERVICE_AVAILABLE_STRING_UID]:{desc:"no string uid service available",retry:!0},[Rf.NO_SERVICE_AVAILABLE_WEBRTC_UNILBS]:{desc:"no webrtc unilbs service available",retry:!0}},[Sf.UNILBS]:{[gf.INVALID_VENDOR_KEY]:{desc:"invalid vendor key, can not find appid",retry:!1},[gf.INVALID_CHANNEL_NAME]:{desc:"invalid channel name",retry:!1},[gf.INTERNAL_ERROR]:{desc:"unilbs internal error",retry:!1},[gf.NO_AUTHORIZED]:{desc:"invalid token, authorized failed",retry:!1},[gf.DYNAMIC_KEY_TIMEOUT]:{desc:"dynamic key or token timeout",retry:!1},[gf.NO_ACTIVE_STATUS]:{desc:"no active status",retry:!1},[gf.DYNAMIC_KEY_EXPIRED]:{desc:"dynamic key expired",retry:!1},[gf.STATIC_USE_DYNAMIC_KEY]:{desc:"static use dynamic key",retry:!1},[gf.DYNAMIC_USE_STATIC_KEY]:{desc:"dynamic use static key",retry:!1},[gf.USER_OVERLOAD]:{desc:"amount of users over load",retry:!1},[gf.FORBIDDEN_REGION]:{desc:"the request is forbidden in this area",retry:!1},[gf.CANNOT_MEET_AREA_DEMAND]:{desc:"unable to allocate services in this area",retry:!1}},[Sf.STRING_UID_ALLOCATOR]:{[Tf.IIIEGAL_APPID]:{desc:"invalid appid",retry:!1},[Tf.IIIEGAL_UID]:{desc:"invalid string uid",retry:!1},[Tf.INTERNAL_ERROR]:{desc:"string uid allocator internal error",retry:!0}}};function gC(e){const t=TC[Math.floor(e/1e4)];if(!t)return {desc:"unkonw error",retry:!1};const i=t[e%1e4];if(!i){if(Math.floor(e/1e4)===Sf.ACCESS_POINT){const t=e%1e4;if("1"===t.toString()[0])return {desc:e.toString(),retry:!1};if("2"===t.toString()[0])return {desc:e.toString(),retry:!0}}return {desc:"unkonw error",retry:!1}}return i}const RC={[If.K_TIMESTAMP_EXPIRED]:{desc:"K_TIMESTAMP_EXPIRED",action:"failed"},[If.K_CHANNEL_PERMISSION_INVALID]:{desc:"K_CHANNEL_PERMISSION_INVALID",action:"failed"},[If.K_CERTIFICATE_INVALID]:{desc:"K_CERTIFICATE_INVALID",action:"failed"},[If.K_CHANNEL_NAME_EMPTY]:{desc:"K_CHANNEL_NAME_EMPTY",action:"failed"},[If.K_CHANNEL_NOT_FOUND]:{desc:"K_CHANNEL_NOT_FOUND",action:"failed"},[If.K_TICKET_INVALID]:{desc:"K_TICKET_INVALID",action:"failed"},[If.K_CHANNEL_CONFLICTED]:{desc:"K_CHANNEL_CONFLICTED",action:"failed"},[If.K_SERVICE_NOT_READY]:{desc:"K_SERVICE_NOT_READY",action:"tryNext"},[If.K_SERVICE_TOO_HEAVY]:{desc:"K_SERVICE_TOO_HEAVY",action:"tryNext"},[If.K_UID_BANNED]:{desc:"K_UID_BANNED",action:"failed"},[If.K_IP_BANNED]:{desc:"K_IP_BANNED",action:"failed"},[If.ERR_INVALID_VENDOR_KEY]:{desc:"ERR_INVALID_VENDOR_KEY",action:"failed"},[If.ERR_INVALID_CHANNEL_NAME]:{desc:"ERR_INVALID_CHANNEL_NAME",action:"failed"},[If.WARN_NO_AVAILABLE_CHANNEL]:{desc:"WARN_NO_AVAILABLE_CHANNEL",action:"failed"},[If.WARN_LOOKUP_CHANNEL_TIMEOUT]:{desc:"WARN_LOOKUP_CHANNEL_TIMEOUT",action:"tryNext"},[If.WARN_LOOKUP_CHANNEL_REJECTED]:{desc:"WARN_LOOKUP_CHANNEL_REJECTED",action:"failed"},[If.WARN_OPEN_CHANNEL_TIMEOUT]:{desc:"WARN_OPEN_CHANNEL_TIMEOUT",action:"tryNext"},[If.WARN_OPEN_CHANNEL_REJECTED]:{desc:"WARN_OPEN_CHANNEL_REJECTED",action:"failed"},[If.WARN_REQUEST_DEFERRED]:{desc:"WARN_REQUEST_DEFERRED",action:"failed"},[If.ERR_DYNAMIC_KEY_TIMEOUT]:{desc:"ERR_DYNAMIC_KEY_TIMEOUT",action:"failed"},[If.ERR_NO_AUTHORIZED]:{desc:"ERR_NO_AUTHORIZED",action:"failed"},[If.ERR_VOM_SERVICE_UNAVAILABLE]:{desc:"ERR_VOM_SERVICE_UNAVAILABLE",action:"tryNext"},[If.ERR_NO_CHANNEL_AVAILABLE_CODE]:{desc:"ERR_NO_CHANNEL_AVAILABLE_CODE",action:"failed"},[If.ERR_MASTER_VOCS_UNAVAILABLE]:{desc:"ERR_MASTER_VOCS_UNAVAILABLE",action:"tryNext"},[If.ERR_INTERNAL_ERROR]:{desc:"ERR_INTERNAL_ERROR",action:"tryNext"},[If.ERR_NO_ACTIVE_STATUS]:{desc:"ERR_NO_ACTIVE_STATUS",action:"failed"},[If.ERR_INVALID_UID]:{desc:"ERR_INVALID_UID",action:"failed"},[If.ERR_DYNAMIC_KEY_EXPIRED]:{desc:"ERR_DYNAMIC_KEY_EXPIRED",action:"failed"},[If.ERR_STATIC_USE_DYANMIC_KE]:{desc:"ERR_STATIC_USE_DYANMIC_KE",action:"failed"},[If.ERR_DYNAMIC_USE_STATIC_KE]:{desc:"ERR_DYNAMIC_USE_STATIC_KE",action:"failed"},[If.ERR_NO_VOCS_AVAILABLE]:{desc:"ERR_NO_VOCS_AVAILABLE",action:"tryNext"},[If.ERR_NO_VOS_AVAILABLE]:{desc:"ERR_NO_VOS_AVAILABLE",action:"tryNext"},[If.ERR_JOIN_CHANNEL_TIMEOUT]:{desc:"ERR_JOIN_CHANNEL_TIMEOUT",action:"tryNext"},[If.ERR_JOIN_BY_MULTI_IP]:{desc:"ERR_JOIN_BY_MULTI_IP",action:"recover"},[If.ERR_NOT_JOINED]:{desc:"ERR_NOT_JOINED",action:"failed"},[If.ERR_REPEAT_JOIN_REQUEST]:{desc:"ERR_REPEAT_JOIN_REQUEST",action:"quit"},[If.ERR_REPEAT_JOIN_CHANNEL]:{desc:"ERR_REPEAT_JOIN_CHANNEL",action:"quit"},[If.ERR_INVALID_VENDOR_KEY]:{desc:"ERR_INVALID_VENDOR_KEY",action:"failed"},[If.ERR_INVALID_CHANNEL_NAME]:{desc:"ERR_INVALID_CHANNEL_NAME",action:"failed"},[If.ERR_INVALID_STRINGUID]:{desc:"ERR_INVALID_STRINGUID",action:"failed"},[If.ERR_TOO_MANY_USERS]:{desc:"ERR_TOO_MANY_USERS",action:"tryNext"},[If.ERR_SET_CLIENT_ROLE_TIMEOUT]:{desc:"ERR_SET_CLIENT_ROLE_TIMEOUT",action:"failed"},[If.ERR_SET_CLIENT_ROLE_NO_PERMISSION]:{desc:"ERR_SET_CLIENT_ROLE_TIMEOUT",action:"failed"},[If.ERR_SET_CLIENT_ROLE_ALREADY_IN_USE]:{desc:"ERR_SET_CLIENT_ROLE_ALREADY_IN_USE",action:"success"},[If.ERR_PUBLISH_REQUEST_INVALID]:{desc:"ERR_PUBLISH_REQUEST_INVALID",action:"failed"},[If.ERR_SUBSCRIBE_REQUEST_INVALID]:{desc:"ERR_SUBSCRIBE_REQUEST_INVALID",action:"failed"},[If.ERR_NOT_SUPPORTED_MESSAGE]:{desc:"ERR_NOT_SUPPORTED_MESSAGE",action:"failed"},[If.ERR_ILLEAGAL_PLUGIN]:{desc:"ERR_ILLEAGAL_PLUGIN",action:"failed"},[If.ILLEGAL_CLIENT_ROLE_LEVEL]:{desc:"ILLEGAL_CLIENT_ROLE_LEVEL",action:"failed"},[If.ERR_REJOIN_TOKEN_INVALID]:{desc:"ERR_REJOIN_TOKEN_INVALID",action:"failed"},[If.ERR_REJOIN_USER_NOT_JOINED]:{desc:"ERR_REJOIN_NOT_JOINED",action:"failed"},[If.ERR_INVALID_OPTIONAL_INFO]:{desc:"ERR_INVALID_OPTIONAL_INFO",action:"quit"},[If.ERR_TEST_RECOVER]:{desc:"ERR_TEST_RECOVER",action:"recover"},[If.ERR_TEST_TRYNEXT]:{desc:"ERR_TEST_TRYNEXT",action:"recover"},[If.ERR_TEST_RETRY]:{desc:"ERR_TEST_RETRY",action:"recover"},[If.ILLEGAL_AES_PASSWORD]:{desc:"ERR_TEST_RETRY",action:"failed"},[If.ERR_TOO_MANY_BROADCASTERS]:{desc:"ERR_TOO_MANY_BROADCASTERS",action:"failed"},[If.ERR_TOO_MANY_SUBSCRIBERS]:{desc:"ERR_TOO_MANY_SUBSCRIBERS",action:"failed"},[If.ERR_LICENSE_ILLEGAL]:{desc:"ERR_LICENSE_ILLEGAL",action:"quit"},[If.ERR_LICENSE_MISSING]:{desc:"ERR_LICENSE_MISSING",action:"quit"},[If.ERR_LICENSE_EXPIRED]:{desc:"ERR_LICENSE_EXPIRED",action:"quit"},[If.ERR_LICENSE_MINUTES_EXCEEDED]:{desc:"ERR_LICENSE_MINUTES_EXCEEDED",action:"quit"},[If.ERR_LICENSE_PERIOD_INVALID]:{desc:"ERR_LICENSE_PERIOD_INVALID",action:"quit"},[If.ERR_LICENSE_MULTIPLE_SDK_SERVICE]:{desc:"ERR_LICENSE_MULTIPLE_SDK_SERVICE",action:"quit"}};function IC(e){const t=RC[e];return t||{desc:"UNKNOW_ERROR_".concat(e),action:"failed"}}function CC(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n);}return i}class vC extends EE{get url(){return this.websocket?this.websocket.url:null}get reconnectMode(){return this._reconnectMode}set reconnectMode(e){["tryNext","recover"].includes(e)&&this.resetReconnectCount(e),this._reconnectMode=e;}get state(){return this._state}set state(e){e!==this._state&&(this._state=e,"reconnecting"===this._state?this.emit(Hf.RECONNECTING,this.reconnectReason):"connected"===this._state?this.emit(Hf.CONNECTED):"closed"===this._state?this.emit(Hf.CLOSED):"failed"===this._state&&this.emit(Hf.FAILED));}resetReconnectCount(e){OE.debug("websocket reset reconnect count, reason: "+e),this.reconnectCount=0;}constructor(e,t){let i=arguments.length>2&&void 0!==arguments[2]&&arguments[2],n=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=arguments.length>4?arguments[4]:void 0;super(),_p(this,"connectionID",0),_p(this,"currentURLIndex",0),_p(this,"urls",void 0),_p(this,"_reconnectMode","tryNext"),_p(this,"reconnectReason",void 0),_p(this,"_initMutex",new Ug("websocket")),_p(this,"name",void 0),_p(this,"_state","closed"),_p(this,"reconnectInterrupter",void 0),_p(this,"websocket",void 0),_p(this,"retryConfig",void 0),_p(this,"reconnectCount",0),_p(this,"forceCloseTimeout",5e3),_p(this,"onlineReconnectListener",void 0),_p(this,"useCompress",void 0),_p(this,"tryDoubleDomain",!1),_p(this,"wsInflateLength",0),_p(this,"wsDeflateLength",0),_p(this,"closeEstablishingWs",()=>{}),_p(this,"store",void 0),_p(this,"joinChannelServiceRecordIndex",void 0),this.store=r,this.name=e,this.retryConfig=function(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?CC(Object(i),!0).forEach((function(t){_p(e,t,i[t]);})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):CC(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t));}));}return e}({},t),this.useCompress=i,this.tryDoubleDomain=n;const{timeout:o,timeoutFactor:s}=t,a=Math.max(300,Math.floor(3*o/5)),c=Math.max(1.2,Math.floor(8*s)/10);PS.ONLINE&&(this.retryConfig.timeout=a,this.retryConfig.timeoutFactor=c),Ig.on(LS.NETWORK_STATE_CHANGE,(e,t)=>{e!==t&&(this.resetReconnectCount("network state change: ".concat(t," -> ").concat(e)),e===PS.ONLINE?(this.retryConfig.timeout=a,this.retryConfig.timeoutFactor=c):(this.retryConfig.timeout=o,this.retryConfig.timeoutFactor=s));});}getConnection(){return this.websocket||void 0}init(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:5e3;this.forceCloseTimeout=t;const i=(t,i)=>{this.urls=e;const n=this.urls[this.currentURLIndex];this.state="connecting",this.createWebSocketConnection(n).then(t).catch(i),this.once(Hf.CLOSED,()=>i(new SE(fE.WS_DISCONNECT))),this.once(Hf.CONNECTED,()=>t());};return this._initMutex.lock().then(e=>new Sl((e,t)=>{i(e,t);}).then(()=>{e();}).catch(()=>{e();}))}close(e,t){if(this.currentURLIndex=0,this.resetReconnectCount("close"),this.reconnectInterrupter&&this.reconnectInterrupter(),this.websocket){this.websocket.onclose=null,this.websocket.onopen=null,this.websocket.onmessage=null;const e=this.websocket;t?setTimeout(()=>e.close(),500):e.close(),this.websocket=void 0;}this.state=e?"failed":"closed",this.closeEstablishingWs&&this.closeEstablishingWs();}reconnect(e,t){if(!this.websocket)return void OE.warning("[".concat(this.name,"] can not reconnect, no websocket"));var i;(void 0!==e&&(this.reconnectMode=e),OE.debug("[".concat(this.name,"] reconnect is triggered initiative")),"number"==typeof this.joinChannelServiceRecordIndex)&&(null===(i=this.store)||void 0===i||i.recordJoinChannelService({status:"error",errors:[new Error(t)]},this.joinChannelServiceRecordIndex));const n=this.websocket.onclose;this.websocket.onclose=null,this.websocket.close(),n&&n.bind(this.websocket)({code:9999,reason:t});}sendMessage(e){let t=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(!this.websocket||this.websocket.readyState!==WebSocket.OPEN)throw new SE(fE.WS_ABORT,"websocket is not ready");try{t||(e=JSON.stringify(e)),this.websocket.send(e);}catch(e){throw new SE(fE.WS_ERR,"send websocket message error"+e.toString())}}setWsInflateData(e){this.wsDeflateLength=this.wsDeflateLength+e.originLength,this.wsInflateLength=this.wsInflateLength+e.compressedLength;}getWsInflateData(){const e=this.wsInflateLength,t=this.wsDeflateLength;return this.clearWsInflateData(),{wsInflateLength:e,wsDeflateLength:t}}clearWsInflateData(){this.wsInflateLength=0,this.wsDeflateLength=0;}async createWebSocketConnection(e,t){return this.connectionID+=1,this.connectionID,this.joinChannelServiceRecordIndex=void 0,new Sl((i,n)=>{var r;const o=e=>{var t;null===(t=this.store)||void 0===t||t.signalChannelOpen(),OE.debug("[".concat(this.name,"] websocket opened:"),e),this.reconnectMode="retry",this.state="connected",this.resetReconnectCount("opened"),i();},s=async e=>{if(OE.debug("[".concat(this.name,"] websocket close ").concat(this.websocket&&this.websocket.url,", code: ").concat(e.code,", reason: ").concat(e.reason,", current mode: ").concat(this.reconnectMode)),this.reconnectCount<this.retryConfig.maxRetryCount){"connected"===this.state&&(this.reconnectReason=e.reason,this.state="reconnecting");const t=oC(this,Hf.WILL_RECONNECT,this.reconnectMode)||this.reconnectMode,r=await this.reconnectWithAction(t);if("closed"===this.state)return void OE.debug("[".concat(this.connectionID,"] ws is closed, no need to reconnect"));if(!r)return n(new SE(fE.WS_DISCONNECT,"websocket reconnect failed: ".concat(e.code))),void this.close(!0);i();}else n(new SE(fE.WS_DISCONNECT,"websocket close: ".concat(e.code))),this.close();},a=e=>{this.emit(Hf.ON_MESSAGE,e);};this.websocket&&(this.websocket.onclose=null,this.websocket.close()),GE("GATEWAY_WSS_ADDRESS")&&this.name.startsWith("gateway")&&(e=GE("GATEWAY_WSS_ADDRESS")),OE.debug("[".concat(this.name,"] start connect, url: ").concat(e));const c=null===(r=this.store)||void 0===r?void 0:r.recordJoinChannelService({startTs:Date.now(),status:"pending",service:"gateway"});this.chooseBestWebsocketConnection(e,!!t,c).then(e=>{var t;this.websocket=e,o&&o(e.url),e.onclose=s,e.onmessage=a,null===(t=this.store)||void 0===t||t.recordJoinChannelService({endTs:Date.now(),status:"success"},c),this.joinChannelServiceRecordIndex=c;}).catch(e=>{var t;if(null===(t=this.store)||void 0===t||t.recordJoinChannelService({endTs:Date.now(),status:e instanceof SE&&e.code===fE.WS_ABORT?"aborted":"error",errors:[e]},c),"closed"!==this.state){if(e instanceof SE&&e.code===fE.WS_ERR){const t=new SE(fE.WS_ERR,"init websocket failed! Error: ".concat(e.toString()));return OE.error("[".concat(this.name,"]").concat(t)),void n(t)}s&&s(e);}else n(new SE(fE.WS_DISCONNECT,"websocket is closed: ".concat(e.toString())));});})}async reconnectWithAction(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];if(this.reconnectCount>=this.retryConfig.maxRetryCount)return !1;if(!this.urls)return !1;if("closed"===this.state)return !1;this.onlineReconnectListener||Ig.networkState!==PS.OFFLINE||(this.onlineReconnectListener=Ig.onlineWaiter&&Ig.onlineWaiter.then(()=>{this.onlineReconnectListener=void 0;}));let i=!0;if(this.reconnectInterrupter=()=>{i=!1;},t){const t=gE(this.reconnectCount,this.retryConfig);OE.debug("[".concat(this.name,"] wait ").concat(t,"ms to reconnect websocket, mode: ").concat(e)),await Sl.race([zI(t),this.onlineReconnectListener||new Sl(()=>{})]);}if("closed"===this.state||!i)return !1;this.reconnectCount+=1;const n=async(e,t)=>{this.emit(Hf.RECONNECT_CREATE_CONNECTION,t),await this.createWebSocketConnection(e);};try{if("retry"===e){const t=this.urls[this.currentURLIndex];this.emit(Hf.RECONNECT_WAITTING_FINISH,e),await n(t,e);}else if("tryNext"===e){if(this.currentURLIndex+=1,this.currentURLIndex>=this.urls.length)return await this.reconnectWithAction("recover",!1);OE.debug("[".concat(this.name,"] websocket url length: ").concat(this.urls.length," current index: ").concat(this.currentURLIndex));const t=this.urls[this.currentURLIndex];this.emit(Hf.RECONNECT_WAITTING_FINISH,e),await n(t,e);}else if("recover"===e){OE.debug("[".concat(this.name,"] request new urls")),this.resetReconnectCount("recover mode"),this.emit(Hf.RECONNECT_WAITTING_FINISH,e),this.urls=await nC(this,Hf.REQUEST_NEW_URLS),this.currentURLIndex=0;const t=this.urls[this.currentURLIndex];await n(t,e);}return !0}catch(i){var r;return OE.error("[".concat(this.name,"] reconnect failed"),i.toString()),null!=i&&null!==(r=i.data)&&void 0!==r&&r.desc&&Array.isArray(i.data.desc)&&i.data.desc.length&&i.data.desc.includes("dynamic key expired")?(this.emit(Hf.ON_TOKEN_PRIVILEGE_DID_EXPIRE),!1):await this.reconnectWithAction(e,t)}}async chooseBestWebsocketConnection(e,t,i){return new Sl((n,r)=>{let o=!1;const s=[];this.closeEstablishingWs=()=>{OE.debug("[choose-best-ws] close establishing websockets"),s.forEach(e=>{e.onclose=null,e.onopen=null,e.onmessage=null,e.close();}),r(new SE(fE.WS_ABORT,"choose best websocket aborted"));};const a=GE("GATEWAY_DOMAINS");let c;const d=e.indexOf("?h="),u=a.find(t=>-1!==d?e.includes(t,d):e.includes(t));OE.debug("[choose-best-ws] currentDomain: ",u,", domains: ",a);let l=!this.tryDoubleDomain||t||!u;if(!l&&u){var h;const t=Date.now();try{a.forEach(t=>{const i=-1===d?e.replace(u,t):e.substr(0,d)+e.substr(d).replace(u,t),n=new WebSocket(i);n.binaryType="arraybuffer",s.push(n),OE.debug("[choose-best-ws] ws is connecting:",n.url);});}catch(e){for(OE.debug("[choose-best-ws] ws create failed, fallback to single url"),s.forEach(e=>e.close());s.length;)s.pop();l=!0;}null===(h=this.store)||void 0===h||h.recordJoinChannelService({urls:s.map(e=>e.url),service:"gateway"},i),s.forEach(e=>{e.onopen=()=>{if(o)return;const i=Date.now()-t;OE.debug("[choose-best-ws] ws open cost ".concat(i,"ms")),s.filter(t=>t!==e).forEach(e=>{OE.debug("[choose-best-ws]close backup websocket: ".concat(e.url)),e.close();}),o=!0,n(e);},e.onclose=e=>{if(c=e,o)return;s.find(e=>!(e.readyState===WebSocket.CLOSED||e.readyState===WebSocket.CLOSING))||(OE.debug("[choose-best-ws] all websocket is closed"),o=!0,r(c));},e.onmessage=t=>{OE.debug("[choose-best-ws]".concat(e.url," onmessage: ").concat(t.data));};}),zI(this.forceCloseTimeout).then(()=>{s.forEach(e=>{e.readyState!==WebSocket.OPEN&&e.close();});});}if(l){var p;let t;OE.debug("[choose-best-ws] use single url: ",e),null===(p=this.store)||void 0===p||p.recordJoinChannelService({urls:[e],service:"gateway"},i);try{t=new WebSocket(e),s.push(t),t.binaryType="arraybuffer";}catch(e){const t=new SE(fE.WS_ERR,"init websocket failed! Error: ".concat(e.toString()));return OE.error("[".concat(this.name,"]").concat(t)),void r(t)}t.onopen=()=>{n(t);},t.onclose=e=>{r(e);},t.onmessage=e=>{OE.debug("[choose-best-ws]".concat(t.url," onmessage: ").concat(e.data));},zI(this.forceCloseTimeout).then(()=>{t&&t.readyState!==WebSocket.OPEN&&t.close();});}}).then(e=>(this.closeEstablishingWs=void 0,e)).catch(e=>{throw this.closeEstablishingWs=void 0,e})}}class yC{constructor(e){_p(this,"input",[]),_p(this,"size",void 0),this.size=e;}add(e){this.input.push(e),this.input.length>this.size&&this.input.splice(0,1);}mean(){var e;return 0===this.input.length?0:zi(e=this.input).call(e,(e,t)=>e+t)/this.input.length}}class AC extends EE{get connectionState(){return this._connectionState}set connectionState(e){e!==this._connectionState&&(this._connectionState=e,e===Of.CONNECTED?this.emit(Nf.WS_CONNECTED):e===Of.RECONNECTING?this.emit(Nf.WS_RECONNECTING,this._websocketReconnectReason):e===Of.CLOSED&&this.emit(Nf.WS_CLOSED,this._disconnectedReason));}get currentURLIndex(){return this.websocket.currentURLIndex}get url(){return this.websocket?this.websocket.url:null}get rtt(){return this.rttRolling.mean()}constructor(e,t){super(),_p(this,"_disconnectedReason",void 0),_p(this,"_websocketReconnectReason",void 0),_p(this,"_connectionState",Of.CLOSED),_p(this,"reconnectToken",void 0),_p(this,"websocket",void 0),_p(this,"openConnectionTime",void 0),_p(this,"clientId",void 0),_p(this,"lastMsgTime",Date.now()),_p(this,"uploadCache",[]),_p(this,"uploadCacheInterval",void 0),_p(this,"rttRolling",new yC(5)),_p(this,"pingpongTimer",void 0),_p(this,"wsInflateDataTimer",void 0),_p(this,"pingpongTimeoutCount",0),_p(this,"joinResponse",void 0),_p(this,"multiIpOption",void 0),_p(this,"initError",void 0),_p(this,"spec",void 0),_p(this,"store",void 0),_p(this,"onWebsocketMessage",e=>{if(e.data instanceof ArrayBuffer)return void this.emit(Nf.ON_BINARY_DATA,e.data);const t=JSON.parse(e.data);if(this.lastMsgTime=Date.now(),Object.prototype.hasOwnProperty.call(t,"_id")){const e="res-@".concat(t._id);this.emit(e,t._result,t._message);}else if(Object.prototype.hasOwnProperty.call(t,"_type")){if(this.emit(t._type,t._message),t._type===Df.ON_NOTIFICATION&&this.handleNotification(t._message),t._type===Df.ON_USER_BANNED)switch(t._message.error_code){case 14:this.close(vf.UID_BANNED);break;case 15:this.close(vf.IP_BANNED);break;case 16:this.close(vf.CHANNEL_BANNED);}if(t._type===Df.ON_USER_LICENSE_BANNED)switch(t._message.error_code){case If.ERR_LICENSE_MISSING:this.close(vf.LICENSE_MISSING);break;case If.ERR_LICENSE_EXPIRED:this.close(vf.LICENSE_EXPIRED);break;case If.ERR_LICENSE_MINUTES_EXCEEDED:this.close(vf.LICENSE_MINUTES_EXCEEDED);break;case If.ERR_LICENSE_PERIOD_INVALID:this.close(vf.LICENSE_PERIOD_INVALID);break;case If.ERR_LICENSE_MULTIPLE_SDK_SERVICE:this.close(vf.LICENSE_MULTIPLE_SDK_SERVICE);break;case If.ERR_LICENSE_ILLEGAL:this.close(vf.LICENSE_ILLEGAL);break;default:this.close();}}}),this.clientId=e.clientId,this.spec=e,this.store=t,this.websocket=new vC("gateway-".concat(this.clientId),this.spec.retryConfig,!0,!0,t),this.handleWebsocketEvents(),window.addEventListener("offline",()=>{this.connectionState===Of.CONNECTED&&this.reconnect("retry",Af.OFFLINE);});}async request(e,t,i,n){const r=ZI(6,""),o={_id:r,_type:e,_message:t},s=this.websocket.connectionID,a=()=>new Sl((t,i)=>{if(this.connectionState===Of.CONNECTED)return t();const n=()=>{this.off(Nf.WS_CLOSED,r),t();},r=()=>{this.off(Nf.WS_CONNECTED,n),i(new SE(fE.WS_ABORT));};this.once(Nf.WS_CONNECTED,n),this.once(Nf.WS_CLOSED,r),e!==bf.PUBLISH&&e!==bf.SUBSCRIBE&&e!==bf.UNSUBSCRIBE&&e!==bf.UNPUBLISH&&e!==bf.CONTROL&&e!==bf.RESTART_ICE||this.once(Nf.DISCONNECT_P2P,()=>{i(new SE(fE.DISCONNECT_P2P));}),e!==bf.PUBLISH&&e!==bf.RESTART_ICE||this.once(Nf.ABORT_P2P_EXECUTION,()=>{i(new SE(fE.DISCONNECT_P2P));});});if(this.connectionState!==Of.CONNECTING&&this.connectionState!==Of.RECONNECTING||e===bf.JOIN||e===bf.REJOIN||await a(),this.websocket.sendMessage(o,!0),n)return;const c=new Sl((i,n)=>{let o=!1;const a=(n,r)=>{o=!0,i({isSuccess:"success"===n,message:r||{}}),this.off(Nf.WS_CLOSED,c),this.off(Nf.WS_RECONNECTING,c),this.emit(Nf.REQUEST_SUCCESS,e,t);};this.once("res-@".concat(r),a);const c=()=>{n(new SE(fE.WS_ABORT,"type: ".concat(e))),this.off(Nf.WS_CLOSED,c),this.off(Nf.WS_RECONNECTING,c),this.off("res-@".concat(r),a);};this.once(Nf.WS_CLOSED,c),this.once(Nf.WS_RECONNECTING,c),zI(GE("SIGNAL_REQUEST_TIMEOUT")).then(()=>{this.websocket.connectionID!==s||o||(OE.warning("[".concat(this.clientId,"] ws request timeout, type: ").concat(e)),this.emit(Nf.REQUEST_TIMEOUT,e,t));});});let d=null;try{d=await c;}catch(n){if(this.connectionState===Of.CLOSED||e===bf.LEAVE)throw new SE(fE.WS_ABORT);return !this.spec.forceWaitGatewayResponse||i?n.throw():e===bf.JOIN||e===bf.REJOIN?null:(await a(),await this.request(e,t))}if(d.isSuccess)return d.message;const u=Number(d.message.error_code||d.message.code),l=IC(u),h=new SE(fE.UNEXPECTED_RESPONSE,"".concat(l.desc,": ").concat(d.message.error_str),{code:u,data:d.message});return "success"===l.action?d.message:(OE.warning("[".concat(this.clientId,"] [").concat(this.websocket.connectionID,"] unexpected response from type ").concat(e,", error_code: ").concat(u,", message: ").concat(l.desc,", action: ").concat(l.action)),u===If.ERR_TOO_MANY_BROADCASTERS?e===bf.JOIN||e===bf.REJOIN?(this.initError=h,this.close(),h.throw()):h.throw():"failed"===l.action?h.throw():"quit"===l.action?(this.initError=h,this.close(),h.throw()):(u===If.ERR_JOIN_BY_MULTI_IP?(this.multiIpOption=d.message.option,OE.warning("[".concat(this.clientId,"] detect multi ip, recover")),this.reconnect("recover",Af.MULTI_IP)):this.reconnect(l.action,Af.SERVER_ERROR),e===bf.JOIN||e===bf.REJOIN?null:await this.request(e,t)))}waitMessage(e,t){return new Sl(i=>{const n=r=>{(!t||t(r))&&(this.off(e,n),i(r));};this.on(e,n);})}upload(e,t){const i={_type:e,_message:t};try{this.websocket.sendMessage(i);}catch(e){const t=GE("MAX_UPLOAD_CACHE")||50;this.uploadCache.push(i),this.uploadCache.length>t&&this.uploadCache.splice(0,1),this.uploadCache.length>0&&!this.uploadCacheInterval&&(this.uploadCacheInterval=window.setInterval(()=>{if(this.connectionState!==Of.CONNECTED)return;const e=this.uploadCache.splice(0,1)[0];0===this.uploadCache.length&&(window.clearInterval(this.uploadCacheInterval),this.uploadCacheInterval=void 0),this.upload(e._type,e._message);},GE("UPLOAD_CACHE_INTERVAL")||2e3));}}send(e,t){const i={_type:e,_message:t};this.websocket.sendMessage(i);}init(e,t){return this.initError=void 0,this.multiIpOption=void 0,this.joinResponse=void 0,this.reconnectToken=void 0,this.openConnectionTime=void 0,new Sl((i,n)=>{this.once(Nf.WS_CONNECTED,()=>i(this.joinResponse)),this.once(Nf.WS_CLOSED,()=>n(this.initError||new SE(fE.WS_ABORT))),this.connectionState=Of.CONNECTING,this.websocket.init(e).catch(n),this.wsInflateDataTimer&&window.clearInterval(this.wsInflateDataTimer),this.wsInflateDataTimer=window.setInterval(()=>{this.handleWsInflateData();},2e4),setTimeout(()=>{t&&void 0===this.openConnectionTime&&(OE.debug("[".concat(this.clientId,"] init websocket timeout while join with fallback to proxy")),n(new SE(fE.INIT_WEBSOCKET_TIMEOUT)));},GE("JOIN_WITH_FALLBACK_PROXY_PENDING_DURATION"));})}close(e){this.pingpongTimer&&(this.pingpongTimeoutCount=0,window.clearInterval(this.pingpongTimer),this.pingpongTimer=void 0),this.wsInflateDataTimer&&(this.handleWsInflateData(),window.clearInterval(this.wsInflateDataTimer),this.wsInflateDataTimer=void 0),this.reconnectToken=void 0,this.joinResponse=void 0,this._disconnectedReason=e||vf.LEAVE,this.connectionState=Of.CLOSED,OE.debug("[".concat(this.clientId,"] ")+"will close websocket in signal"),this.websocket.close(),e===vf.FALLBACK&&(this.websocket.removeAllListeners(),this.websocket=new vC("gateway-".concat(this.clientId),this.spec.retryConfig,!0,!0,this.store),this.handleWebsocketEvents());}async join(){if(!this.joinResponse){this.emit(Nf.ABORT_P2P_EXECUTION);const e=await nC(this,Nf.REQUEST_JOIN_INFO),t=await this.request(bf.JOIN,e);if(!t)return this.emit(Nf.REPORT_JOIN_GATEWAY,fE.TIMEOUT,this.url||""),!1;this.joinResponse=t,this.emit(Nf.JOIN_RESPONSE,this.joinResponse),this.reconnectToken=this.joinResponse.rejoin_token;}return this.connectionState=Of.CONNECTED,this.pingpongTimer&&window.clearInterval(this.pingpongTimer),this.pingpongTimer=window.setInterval(this.handlePingPong.bind(this),3e3),!0}async rejoin(){if(!this.reconnectToken)throw new SE(fE.UNEXPECTED_ERROR,"can not rejoin, no rejoin token");const e=sC(this,Nf.REQUEST_REJOIN_INFO);e.token=this.reconnectToken;const t=await this.request(bf.REJOIN,e);return !!t&&(this.connectionState=Of.CONNECTED,this.pingpongTimer&&window.clearInterval(this.pingpongTimer),this.pingpongTimer=window.setInterval(this.handlePingPong.bind(this),3e3),t.peers&&t.peers.forEach(e=>{this.emit(Df.ON_USER_ONLINE,{uid:e.uid}),e.audio&&this.emit(Df.ON_ADD_AUDIO_STREAM,{uid:e.uid,uint_id:e.uint_id,audio:!0,ssrcId:e.audio_ssrc}),e.video&&this.emit(Df.ON_ADD_VIDEO_STREAM,{uid:e.uid,uint_id:e.uint_id,video:!0,ssrcId:e.video_ssrc}),e.audio_mute?this.emit(Df.MUTE_AUDIO,{uid:e.uid}):this.emit(Df.UNMUTE_AUDIO,{uid:e.uid}),e.video_mute?this.emit(Df.MUTE_VIDEO,{uid:e.uid}):this.emit(Df.UNMUTE_VIDEO,{uid:e.uid}),e.audio_enable_local?this.emit(Df.ENABLE_LOCAL_AUDIO,{uid:e.uid}):this.emit(Df.DISABLE_LOCAL_AUDIO,{uid:e.uid}),e.video_enable_local?this.emit(Df.ENABLE_LOCAL_VIDEO,{uid:e.uid}):this.emit(Df.DISABLE_LOCAL_VIDEO,{uid:e.uid}),e.audio||e.video||this.emit(Df.ON_REMOVE_STREAM,{uid:e.uid,uint_id:e.uint_id});}),!0)}reconnect(e,t){this.pingpongTimer&&(this.pingpongTimeoutCount=0,window.clearInterval(this.pingpongTimer),this.pingpongTimer=void 0),this.websocket.reconnect(e,t);}handleNotification(e){OE.debug("[".concat(this.clientId,"] receive notification: "),e);const t=IC(e.code);if("success"!==t.action){if("failed"!==t.action)return "quit"===t.action?("ERR_REPEAT_JOIN_CHANNEL"===t.desc&&this.close(vf.UID_BANNED),void this.close()):void this.reconnect(t.action,Af.SERVER_ERROR);OE.error("[".concat(this.clientId,"] ignore error: "),t.desc);}}handlePingPong(){if(!this.websocket||"connected"!==this.websocket.state)return;this.pingpongTimeoutCount>0&&this.rttRolling.add(3e3),this.pingpongTimeoutCount+=1;const e=GE("PING_PONG_TIME_OUT"),t=Date.now();this.pingpongTimeoutCount>=e&&(OE.warning("[".concat(this.clientId,"] PINGPONG Timeout. Last Socket Message: ").concat(t-this.lastMsgTime,"ms")),t-this.lastMsgTime>GE("WEBSOCKET_TIMEOUT_MIN"))?this.reconnect("retry",Af.TIMEOUT):this.request(bf.PING,void 0,!0).then(()=>{this.pingpongTimeoutCount=0;const e=Date.now()-t;this.rttRolling.add(e),GE("REPORT_STATS")&&this.send(bf.PING_BACK,{pingpongElapse:e});}).catch(e=>{});}handleWsInflateData(){const{wsInflateLength:e,wsDeflateLength:t}=this.websocket.getWsInflateData();0!==e&&0!==t&&this.upload(wf.WS_INFLATE_DATA_LENGTH,{ws_deflate_length:t,ws_inflate_length:e});}handleWebsocketEvents(){this.websocket.on(Hf.RECONNECT_WAITTING_FINISH,e=>{this.emit(Nf.WS_RECONNECT_WAITTING_FINISH,e);}),this.websocket.on(Hf.RECONNECT_CREATE_CONNECTION,e=>{this.emit(Nf.WS_RECONNECT_CREATE_CONNECTION,e);}),this.websocket.on(Hf.ON_MESSAGE,this.onWebsocketMessage),this.websocket.on(Hf.CLOSED,()=>{this.connectionState=Of.CLOSED;}),this.websocket.on(Hf.FAILED,()=>{this._disconnectedReason=vf.NETWORK_ERROR,this.connectionState=Of.CLOSED;}),this.websocket.on(Hf.RECONNECTING,e=>{this._websocketReconnectReason=e,this.joinResponse=void 0,this.connectionState===Of.CONNECTED?this.connectionState=Of.RECONNECTING:this.connectionState=Of.CONNECTING;}),this.websocket.on(Hf.WILL_RECONNECT,(e,t)=>{if(sC(this,Nf.IS_P2P_DISCONNECTED)&&"retry"===e)return OE.debug("".concat(this.clientId," reconnect mode is retry, but p2p lost, change to tryNext")),this.reconnectToken=void 0,this.emit(Nf.NEED_RENEW_SESSION),this.emit(Nf.DISCONNECT_P2P),t("tryNext");"retry"!==e&&(OE.debug("".concat(this.clientId," websockt will_connect event, renewSession reconnectMode is ").concat(e)),this.reconnectToken=void 0,this.emit(Nf.NEED_RENEW_SESSION),this.emit(Nf.DISCONNECT_P2P)),t(e);}),this.websocket.on(Hf.CONNECTED,()=>{this.openConnectionTime=Date.now(),this.reconnectToken?this.rejoin().catch(e=>{OE.warning("[".concat(this.clientId,"] rejoin failed ").concat(e)),this.reconnect("tryNext",Af.SERVER_ERROR);}):this.join().catch(e=>{if(this.emit(Nf.REPORT_JOIN_GATEWAY,e.message||e.code,this.url||""),e instanceof SE&&e.code===fE.UNEXPECTED_RESPONSE&&e.data.code===If.ERR_NO_AUTHORIZED)return OE.warning("[".concat(this.clientId,"] reconnect no authorized, recover")),void this.reconnect("recover",Af.SERVER_ERROR);OE.error("[".concat(this.clientId,"] join gateway request failed"),e.toString()),this.spec.forceWaitGatewayResponse?this.reconnect("tryNext",Af.SERVER_ERROR):(this.initError=e,this.close());});}),this.websocket.on(Hf.REQUEST_NEW_URLS,(e,t)=>{nC(this,Nf.REQUEST_RECOVER,this.multiIpOption).then(e).catch(t);}),this.websocket.on(Hf.ON_TOKEN_PRIVILEGE_DID_EXPIRE,()=>{this.emit(Df.ON_TOKEN_PRIVILEGE_DID_EXPIRE);});}}function OC(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n);}return i}class NC extends EE{get url(){return this._url?this._url:null}get reconnectMode(){return this._reconnectMode}set reconnectMode(e){["tryNext","recover"].includes(e)&&this.resetReconnectCount(e),this._reconnectMode=e;}get state(){return this._state}set state(e){e!==this._state&&(this._state=e,"reconnecting"===this._state?this.emit(FS.RECONNECTING,this.reconnectReason):"connected"===this._state?this.emit(FS.CONNECTED):"closed"===this._state?this.emit(FS.CLOSED):"failed"===this._state&&this.emit(FS.FAILED));}constructor(e,t,i,n){super(),_p(this,"connectionID",0),_p(this,"currentURLIndex",0),_p(this,"reconnectReason",void 0),_p(this,"_reconnectMode","tryNext"),_p(this,"_initMutex",void 0),_p(this,"_name",void 0),_p(this,"_state","closed"),_p(this,"_reconnectInterrupter",void 0),_p(this,"_url",void 0),_p(this,"_retryConfig",void 0),_p(this,"_reconnectCount",0),_p(this,"_forceCloseTimeout",5e3),_p(this,"_onlineReconnectListener",void 0),_p(this,"_closeEstablishingTransmitter",()=>{}),_p(this,"_store",void 0),_p(this,"_joinChannelServiceRecordIndex",void 0),_p(this,"_transmitter",void 0),_p(this,"_useCompress",void 0),_p(this,"_inflateLength",0),_p(this,"_deflateLength",0),this._store=n,this._name=e,this._retryConfig=function(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?OC(Object(i),!0).forEach((function(t){_p(e,t,i[t]);})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):OC(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t));}));}return e}({},t),this._useCompress=i;}resetReconnectCount(e){OE.debug("".concat(this._name," reset reconnect count, reason: ").concat(e)),this._reconnectCount=0;}close(e,t){if(this.currentURLIndex=0,this.resetReconnectCount("close"),this._reconnectInterrupter&&this._reconnectInterrupter(),this._transmitter){this._transmitter.onclose=null,this._transmitter.onopen=null,this._transmitter.onmessage=null;const e=this._transmitter;t?setTimeout(()=>e.close(),500):e.close(),this._transmitter=void 0;}this.state=e?"failed":"closed",this._closeEstablishingTransmitter&&this._closeEstablishingTransmitter();}reconnect(e,t){if(!this._transmitter)return void OE.warning("[".concat(this._name,"] can not reconnect, no websocket"));var i;(void 0!==e&&(this.reconnectMode=e),OE.debug("[".concat(this._name,"] reconnect is triggered initiative")),"number"==typeof this._joinChannelServiceRecordIndex)&&(null===(i=this._store)||void 0===i||i.recordJoinChannelService({status:"error",errors:[new Error(t)]},this._joinChannelServiceRecordIndex));const n=this._transmitter.onclose;this._transmitter.onclose=null,this._transmitter.close(),n&&n.bind(this._transmitter)({code:9999,reason:t});}getInflateData(){const e=this._inflateLength,t=this._deflateLength;return this.clearInflateData(),{inflateLength:e,deflateLength:t}}setInflateData(e){this._deflateLength=this._deflateLength+e.originLength,this._inflateLength=this._inflateLength+e.compressedLength;}clearInflateData(){this._inflateLength=0,this._deflateLength=0;}}function bC(e,t,i){if("getBigUint64"in DataView.prototype)return e.getBigUint64(t,i);const n=e.getUint32(t,i),r=e.getUint32(t+4,i),o=Number(!!i),s=Number(!i);return BigInt(n*s+r*o)<<BigInt(32)|BigInt(n*o+r*s)}function wC(e,t,i,n){if("setBigUint64"in DataView.prototype)return e.setBigUint64(t,i,n);const r=Number(i>>BigInt(32)),o=Number(i&BigInt(4294967295));n?(e.setUint32(t+4,r,n),e.setUint32(t,o,n)):(e.setUint32(t,r,n),e.setUint32(t+4,o,n));}let DC;!function(e){e[e.Default=0]="Default",e[e.Ack=1]="Ack";}(DC||(DC={}));class PC{constructor(e,t,i){_p(this,"version",1),_p(this,"initialRTO",void 0),_p(this,"maxBatchAckCount",void 0),_p(this,"maxRTO",void 0),_p(this,"initialRTT",void 0),_p(this,"ID",void 0),_p(this,"rtt",void 0),_p(this,"packetNumber",1),_p(this,"rtoRatioMap",new Map),_p(this,"timeoutMap",new Map),_p(this,"unorderedPacketQueue",[]),_p(this,"batchAckPacketQueue",[]),_p(this,"lastOrderedPacketNumber",0),_p(this,"batchAckTimer",void 0),_p(this,"sendImpl",void 0),_p(this,"receiveImpl",void 0),this.sendImpl=e,this.receiveImpl=t,this.ID=ZI(7,"transmitter-"),this.initialRTO=void 0!==(null==i?void 0:i.initialRTO)?i.initialRTO:GE("TRANSMITTER_INITIAL_RTO"),this.initialRTT=void 0!==(null==i?void 0:i.initialRTT)?i.initialRTT:GE("TRANSMITTER_INITIAL_RTT"),this.rtt=void 0!==(null==i?void 0:i.initialRTT)?i.initialRTT:GE("TRANSMITTER_INITIAL_RTT"),this.maxBatchAckCount=void 0!==(null==i?void 0:i.maxBatchAckCount)?i.maxBatchAckCount:GE("TRANSMITTER_MAX_BATCH_ACK_COUNT"),this.maxRTO=void 0!==(null==i?void 0:i.maxRTO)?i.maxRTO:GE("TRANSMITTER_MAX_RTO");}packetize(e,t){return {type:DC.Default,version:this.version,packetNumber:t,payload:e}}serialize(e){switch(e.type){case DC.Default:{let t;if("string"==typeof e.payload){t=(new TextEncoder).encode(e.payload);}else t=e.payload;const i=new ArrayBuffer(t.length+15),n=new DataView(i);n.setUint16(0,e.version),n.setUint8(2,e.type),n.setUint32(3,e.packetNumber),wC(n,7,BigInt(e.sendTs));return new Uint8Array(n.buffer).set(t,15),i}case DC.Ack:{const t=new ArrayBuffer(16),i=new DataView(t);return i.setUint16(0,e.version),i.setUint8(2,e.type),i.setUint32(3,e.maxAckPacketNumber),i.setUint8(7,e.shift),wC(i,8,BigInt(e.ackSendTs)),t}}}deserialize(e){const t=new DataView(e),i=t.getUint16(0),n=t.getUint8(2);switch(n){case DC.Default:{const r=t.getUint32(3),o=bC(t,7),s=e.slice(15),a=(new TextDecoder).decode(s);return {version:i,type:n,packetNumber:r,sendTs:Number(o),payload:a}}case DC.Ack:{const e=t.getUint32(3),r=t.getUint8(7),o=bC(t,8);return {version:i,type:n,maxAckPacketNumber:e,shift:r,ackSendTs:Number(o)}}default:throw OE.error("[".concat(this.ID,"] Unrecognized packet type ").concat(n)),new Error("Unrecognized packet type ".concat(n))}}sendMessage(e){const t=this.packetize(e,this.packetNumber);this.packetNumber=4294967295===this.packetNumber?1:this.packetNumber+1;const i=this.calculateRTO(t),n=window.setTimeout(()=>{this.resendMessage(t);},i);this.timeoutMap.set(t.packetNumber,n),this.sendPacket(t);}onData(e){const t=this.deserialize(e);t.type===DC.Default?this.ack(t):t.type===DC.Ack&&(this.updateRTT(t,Math.round(performance.now())),this.clearRTO(t));}close(){this.rtt=this.initialRTT,this.packetNumber=1,Array.from(this.timeoutMap.entries()).forEach(e=>{let[t,i]=e;window.clearTimeout(i);}),this.timeoutMap=new Map,this.rtoRatioMap=new Map,this.unorderedPacketQueue=[],this.batchAckPacketQueue=[],this.lastOrderedPacketNumber=0,void 0!==this.batchAckTimer&&window.clearTimeout(this.batchAckTimer);}resendMessage(e){const t=this.calculateRTO(e),i=window.setTimeout(()=>{this.resendMessage(e);},t);this.timeoutMap.set(e.packetNumber,i),this.sendPacket(e);}calculateRTO(e){const t=this.rtoRatioMap.get(e.packetNumber);if(void 0===t)return this.rtoRatioMap.set(e.packetNumber,1),this.initialRTO;{const i=9*this.rtt/8*t;return this.rtoRatioMap.set(e.packetNumber,t+1),i>this.maxRTO?this.maxRTO:i}}updateRTT(e,t){const i=e.ackSendTs;this.rtt=this.rtt*(7/8)+(t-i-this.rtt)/8;}ack(e){if(e.packetNumber===this.lastOrderedPacketNumber+1)for(this.batchAckPacketQueue.length>=this.maxBatchAckCount&&this.batchAck(),this.batchAckTimer?this.batchAckPacketQueue.push(e):(this.batchAckPacketQueue.push(e),this.batchAckTimer=window.setTimeout(()=>{this.batchAck();},this.rtt/8)),this.lastOrderedPacketNumber+=1,this.receiveImpl(e.payload);;){const e=this.unorderedPacketQueue[0];if(!e){this.unorderedPacketQueue.shift();break}this.batchAckTimer&&this.batchAck(),this.receiveImpl(e.payload),this.unorderedPacketQueue.shift(),this.lastOrderedPacketNumber+=1;}else if(e.packetNumber<=this.lastOrderedPacketNumber){const t={ackSendTs:e.sendTs,maxAckPacketNumber:e.packetNumber,shift:0,type:DC.Ack,version:this.version};this.sendPacket(t);}else if(e.packetNumber>this.lastOrderedPacketNumber){this.unorderedPacketQueue[e.packetNumber-this.lastOrderedPacketNumber-2]=e;const t={ackSendTs:e.sendTs,maxAckPacketNumber:e.packetNumber,shift:0,type:DC.Ack,version:this.version};this.sendPacket(t);}}batchAck(){window.clearTimeout(this.batchAckTimer),this.batchAckTimer=void 0;const e={ackSendTs:this.batchAckPacketQueue[this.batchAckPacketQueue.length-1].sendTs,maxAckPacketNumber:this.batchAckPacketQueue[this.batchAckPacketQueue.length-1].packetNumber,shift:this.batchAckPacketQueue.length-1,type:DC.Ack,version:this.version};this.sendPacket(e),this.batchAckPacketQueue=[];}sendPacket(e){e.type===DC.Default&&(e.sendTs=Math.round(performance.now()));const t=this.serialize(e);this.sendImpl(t);}clearRTO(e){for(let t=e.maxAckPacketNumber-e.shift;t<=e.maxAckPacketNumber;t++){const e=this.timeoutMap.get(t);void 0!==e&&window.clearTimeout(e),this.timeoutMap.delete(t),this.rtoRatioMap.delete(t);}}}class LC extends NC{constructor(e,t){super(e,t,arguments.length>2&&void 0!==arguments[2]&&arguments[2],arguments.length>3?arguments[3]:void 0),_p(this,"_initMutex",void 0),_p(this,"_reconnectInterrupter",void 0),_p(this,"_url",void 0),_p(this,"_transmitter",void 0),_p(this,"_addresses",void 0),_p(this,"_reliableTransmission",void 0),this._initMutex=new Ug("datachannel");const{timeout:i,timeoutFactor:n}=t,r=Math.max(300,Math.floor(3*i/5)),o=Math.max(1.2,Math.floor(8*n)/10);PS.ONLINE&&(this._retryConfig.timeout=r,this._retryConfig.timeoutFactor=o),Ig.on(LS.NETWORK_STATE_CHANGE,(e,t)=>{e!==t&&(this.resetReconnectCount("network state change: ".concat(t," -> ").concat(e)),e===PS.ONLINE?(this._retryConfig.timeout=r,this._retryConfig.timeoutFactor=o):(this._retryConfig.timeout=i,this._retryConfig.timeoutFactor=n));});}getConnection(){if(this._reliableTransmission)return this._reliableTransmission}async init(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:5e3;this._forceCloseTimeout=t;const i=(t,i)=>{this._addresses=e,this.currentURLIndex=this._addresses.findIndex(e=>e.fingerprint||GE("FINGERPRINT"));const n=this._addresses[this.currentURLIndex];this.state="connecting",this.createTransmitterConnection(n).then(t).catch(i),this.once(FS.CLOSED,()=>i(new SE(fE.WS_DISCONNECT))),this.once(FS.CONNECTED,()=>t());};return this._initMutex.lock().then(e=>new Sl((e,t)=>{i(e,t);}).then(()=>{e();}).catch(()=>{e();}))}sendMessage(e){let t=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(!this._transmitter||!this._reliableTransmission)throw new SE(fE.WS_ABORT,"datachannel is not ready");try{t||(e=JSON.stringify(e)),this._reliableTransmission.sendMessage(e);}catch(e){throw new SE(fE.WS_ERR,"send datachannel signal message error"+e.toString())}}unbindDcCloseEventListener(){this._transmitter&&(this._transmitter.onclose=null);}sendMessageWithJSON(e){const t=JSON.stringify(e);return {compressed:t,compressedLength:t.length,origin:e}}sendMessageWithUint8Array(e){return {compressed:e,compressedLength:e.byteLength,origin:e}}createTransmitterConnection(e){return this.connectionID+=1,this._joinChannelServiceRecordIndex=void 0,this._url="dc://".concat(e.ip,":").concat(e.port),new Sl((t,i)=>{var n;const r=()=>{OE.debug("[".concat(this._name,"] datachannel opened:"),this._url),this.reconnectMode="retry",this.state="connected",this.resetReconnectCount("opened"),t();},o=async e=>{var n;if(null===(n=this._closeEstablishingTransmitter)||void 0===n||n.call(this),OE.debug("[".concat(this._name,"] datachannel close ").concat(this._url,", code: ").concat(e.code,", reason: ").concat(e.reason,", current mode: ").concat(this.reconnectMode)),this._reconnectCount<this._retryConfig.maxRetryCount){"connected"===this.state&&(this.reconnectReason=e.reason,this.state="reconnecting");const n=oC(this,FS.WILL_RECONNECT,this.reconnectMode)||this.reconnectMode,r=await this.reconnectWithAction(n);if("closed"===this.state)return void OE.debug("[".concat(this.connectionID,"] dc is closed, no need to reconnect"));if(!r)return i(new SE(fE.WS_DISCONNECT,"datachannel reconnect failed: ".concat(e.code))),void this.close(!0);t();}else i(new SE(fE.WS_DISCONNECT,"datachannel close: ".concat(e.code))),this.close();},s=e=>{var t;null===(t=this._reliableTransmission)||void 0===t||t.onData(e.data);};this._transmitter&&(this._transmitter.onclose=null,this._transmitter.close()),this._reliableTransmission&&(this._reliableTransmission.close(),this._reliableTransmission=void 0),OE.debug("[".concat(this._name,"] start connect, address: ").concat(JSON.stringify(e)));const a=null===(n=this._store)||void 0===n?void 0:n.recordJoinChannelService({startTs:Date.now(),status:"pending",service:"gateway"}),c=Date.now();nC(this,FS.TO_CONNECT_DATACHANNEL,e).then(e=>{var t,i;if(!e)throw new Error("transmissonInfo not exist yet");const{transmitter:n,close:d}=e;this._transmitter=n,null===(t=this._store)||void 0===t||t.signalChannelOpen();const u=Date.now()-c;OE.debug("[choose dc] dc open cost ".concat(u,"ms"));this._reliableTransmission=new PC(e=>{var t;this._transmitter&&"open"===this._transmitter.readyState&&(null===(t=this._transmitter)||void 0===t||t.send(e));},e=>{"string"==typeof e&&this.emit(FS.ON_MESSAGE,e);}),this._closeEstablishingTransmitter=()=>{var e;null===(e=this._reliableTransmission)||void 0===e||e.close(),this._reliableTransmission=void 0,d();},r&&r(),n.onclose=o,n.onmessage=s,null===(i=this._store)||void 0===i||i.recordJoinChannelService({endTs:Date.now(),status:"success"},a),this._joinChannelServiceRecordIndex=a;}).catch(e=>{var t;if(null===(t=this._store)||void 0===t||t.recordJoinChannelService({endTs:Date.now(),status:e instanceof SE&&e.code===fE.WS_ABORT?"aborted":"error",errors:[e]},a),"closed"!==this.state){if(e instanceof SE&&e.code===fE.WS_ERR){const t=new SE(fE.WS_ERR,"init datachannel failed! Error: ".concat(e.toString()));return OE.error("[".concat(this._name,"]").concat(t)),void i(t)}o&&o(e);}else i(new SE(fE.WS_DISCONNECT,"datachannel is closed: ".concat(e.toString())));});})}async reconnectWithAction(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];if(this._reconnectCount>=this._retryConfig.maxRetryCount)return !1;if(!this._addresses)return !1;if("closed"===this.state)return !1;this._onlineReconnectListener||Ig.networkState!==PS.OFFLINE||(this._onlineReconnectListener=Ig.onlineWaiter&&Ig.onlineWaiter.then(()=>{this._onlineReconnectListener=void 0;}));let i=!0;if(this._reconnectInterrupter=()=>{i=!1;},t){const t=gE(this._reconnectCount,this._retryConfig);OE.debug("[".concat(this._name,"] wait ").concat(t,"ms to reconnect datachannel, mode: ").concat(e)),await Sl.race([zI(t),this._onlineReconnectListener||new Sl(()=>{})]);}if("closed"===this.state||!i)return !1;this._reconnectCount+=1;const n=async(e,t)=>{this.emit(FS.RECONNECT_CREATE_CONNECTION,t),await this.createTransmitterConnection(e);};try{if("retry"===e){const t=this._addresses[this.currentURLIndex];this.emit(FS.RECONNECT_WAITTING_FINISH,e),await n(t,e);}else if("tryNext"===e){this.currentURLIndex+=1;for(let e=this.currentURLIndex;e<this._addresses.length;e++){if(this._addresses[e].fingerprint||GE("FINGERPRINT")){this.currentURLIndex=e;break}this.currentURLIndex+=1;}if(this.currentURLIndex>=this._addresses.length)return OE.debug("[".concat(this._name,"] the available addresses are exhausted, change to recover")),await this.reconnectWithAction("recover",!1);OE.debug("[".concat(this._name,"] datachannel url length: ").concat(this._addresses.length," current index: ").concat(this.currentURLIndex));const t=this._addresses[this.currentURLIndex];this.emit(FS.RECONNECT_WAITTING_FINISH,e),await n(t,e);}else "recover"===e&&(OE.debug("[".concat(this._name,"] start to failback to websocket")),this.resetReconnectCount("recover mode"),this.emit(FS.RECONNECT_WAITTING_FINISH,e),this.emit(FS.FAILBACK));return !0}catch(i){var r;return OE.error("[".concat(this._name,"] reconnect failed"),i.toString()),null!=i&&null!==(r=i.data)&&void 0!==r&&r.desc&&Array.isArray(i.data.desc)&&i.data.desc.length&&i.data.desc.includes("dynamic key expired")?(this.emit(FS.ON_TOKEN_PRIVILEGE_DID_EXPIRE),!1):await this.reconnectWithAction(e,t)}}}class kC extends EE{get connectionState(){return this._connectionState}set connectionState(e){e!==this._connectionState&&(this._connectionState=e,e===Of.CONNECTED?this.emit(Nf.WS_CONNECTED):e===Of.RECONNECTING?this.emit(Nf.WS_RECONNECTING,this._websocketReconnectReason):e===Of.CLOSED&&this.emit(Nf.WS_CLOSED,this._disconnectedReason));}get currentURLIndex(){return this.websocket.currentURLIndex}get url(){return this.websocket?this.websocket.url:null}get rtt(){return this.rttRolling.mean()}constructor(e,t){super(),_p(this,"_disconnectedReason",void 0),_p(this,"_websocketReconnectReason",void 0),_p(this,"_connectionState",Of.CLOSED),_p(this,"reconnectToken",void 0),_p(this,"websocket",void 0),_p(this,"openConnectionTime",void 0),_p(this,"clientId",void 0),_p(this,"lastMsgTime",Date.now()),_p(this,"uploadCache",[]),_p(this,"uploadCacheInterval",void 0),_p(this,"rttRolling",new yC(5)),_p(this,"pingpongTimer",void 0),_p(this,"inflateDataTimer",void 0),_p(this,"pingpongTimeoutCount",0),_p(this,"joinResponse",void 0),_p(this,"multiIpOption",void 0),_p(this,"initError",void 0),_p(this,"spec",void 0),_p(this,"store",void 0),_p(this,"onWebsocketMessage",e=>{if(e instanceof ArrayBuffer)return void this.emit(Nf.ON_BINARY_DATA,e);const t=JSON.parse(e);if(this.lastMsgTime=Date.now(),Object.prototype.hasOwnProperty.call(t,"_id")){const e="res-@".concat(t._id);this.emit(e,t._result,t._message);}else if(Object.prototype.hasOwnProperty.call(t,"_type")&&(this.emit(t._type,t._message),t._type===Df.ON_NOTIFICATION&&this.handleNotification(t._message),t._type===Df.ON_USER_BANNED))switch(t._message.error_code){case 14:this.close(vf.UID_BANNED);break;case 15:this.close(vf.IP_BANNED);break;case 16:this.close(vf.CHANNEL_BANNED);}}),this.clientId=e.clientId,this.spec=e,this.store=t,this.websocket=new LC("gateway-".concat(this.clientId),this.spec.retryConfig,!0,t),this.handleWebsocketEvents(),window.addEventListener("offline",()=>{this.connectionState===Of.CONNECTED&&this.reconnect("retry",jS.OFFLINE);});}async request(e,t,i,n){const r=ZI(6,""),o={_id:r,_type:e,_message:t},s=this.websocket.connectionID,a=()=>new Sl((t,i)=>{if(this.connectionState===Of.CONNECTED)return t();const n=()=>{this.off(Nf.WS_CLOSED,r),t();},r=()=>{this.off(Nf.WS_CONNECTED,n),i(new SE(fE.WS_ABORT));};this.once(Nf.WS_CONNECTED,n),this.once(Nf.WS_CLOSED,r),e!==bf.PUBLISH&&e!==bf.SUBSCRIBE&&e!==bf.UNSUBSCRIBE&&e!==bf.UNPUBLISH&&e!==bf.CONTROL&&e!==bf.RESTART_ICE||this.once(Nf.DISCONNECT_P2P,()=>{i(new SE(fE.DISCONNECT_P2P));}),e!==bf.PUBLISH&&e!==bf.RESTART_ICE||this.once(Nf.ABORT_P2P_EXECUTION,()=>{i(new SE(fE.DISCONNECT_P2P));});});if(this.connectionState!==Of.CONNECTING&&this.connectionState!==Of.RECONNECTING||e===bf.JOIN||e===bf.REJOIN||await a(),e===bf.LEAVE&&(this.websocket.unbindDcCloseEventListener(),n=!0),this.websocket.sendMessage(o,!0,!1),n)return;const c=new Sl((i,n)=>{let o=!1;const a=(n,r)=>{o=!0,i({isSuccess:"success"===n,message:r||{}}),this.off(Nf.WS_CLOSED,c),this.off(Nf.WS_RECONNECTING,c),this.emit(Nf.REQUEST_SUCCESS,e,t);};this.once("res-@".concat(r),a);const c=()=>{n(new SE(fE.WS_ABORT,"type: ".concat(e))),this.off(Nf.WS_CLOSED,c),this.off(Nf.WS_RECONNECTING,c),this.off("res-@".concat(r),a);};this.once(Nf.WS_CLOSED,c),this.once(Nf.WS_RECONNECTING,c),zI(GE("SIGNAL_REQUEST_TIMEOUT")).then(()=>{this.websocket.connectionID!==s||o||(OE.warning("dc request timeout, type: ".concat(e)),this.emit(Nf.REQUEST_TIMEOUT,e,t));});});let d=null;try{d=await c;}catch(n){if(this.connectionState===Of.CLOSED||e===bf.LEAVE)throw new SE(fE.WS_ABORT);return !this.spec.forceWaitGatewayResponse||i?n.throw():e===bf.JOIN||e===bf.REJOIN?null:(await a(),await this.request(e,t))}if(d.isSuccess)return d.message;const u=Number(d.message.error_code||d.message.code),l=IC(u),h=new SE(fE.UNEXPECTED_RESPONSE,"".concat(l.desc,": ").concat(d.message.error_str),{code:u,data:d.message});return "success"===l.action?d.message:(OE.warning("[".concat(this.websocket.connectionID,"] unexpected response from type ").concat(e,", error_code: ").concat(u,", message: ").concat(l.desc,", action: ").concat(l.action)),u===If.ERR_TOO_MANY_BROADCASTERS?e===bf.JOIN||e===bf.REJOIN?(this.initError=h,this.close(),h.throw()):h.throw():"failed"===l.action?h.throw():"quit"===l.action?(this.initError=h,this.close(),h.throw()):(u===If.ERR_JOIN_BY_MULTI_IP?(this.multiIpOption=d.message.option,OE.warning("[".concat(this.clientId,"] detect multi ip, recover")),this.reconnect("recover",jS.MULTI_IP)):this.reconnect(l.action,jS.SERVER_ERROR),e===bf.JOIN||e===bf.REJOIN?null:await this.request(e,t)))}waitMessage(e,t){return new Sl(i=>{const n=r=>{(!t||t(r))&&(this.off(e,n),i(r));};this.on(e,n);})}upload(e,t){const i={_type:e,_message:t};try{this.websocket.sendMessage(i);}catch(e){const t=GE("MAX_UPLOAD_CACHE")||50;this.uploadCache.push(i),this.uploadCache.length>t&&this.uploadCache.splice(0,1),this.uploadCache.length>0&&!this.uploadCacheInterval&&(this.uploadCacheInterval=window.setInterval(()=>{if(this.connectionState!==Of.CONNECTED)return;const e=this.uploadCache.splice(0,1)[0];0===this.uploadCache.length&&(window.clearInterval(this.uploadCacheInterval),this.uploadCacheInterval=void 0),this.upload(e._type,e._message);},GE("UPLOAD_CACHE_INTERVAL")||2e3));}}send(e,t){const i={_type:e,_message:t};this.websocket.sendMessage(i);}init(e,t){return this.initError=void 0,this.multiIpOption=void 0,this.joinResponse=void 0,this.reconnectToken=void 0,this.openConnectionTime=void 0,new Sl((i,n)=>{this.once(Nf.WS_CONNECTED,()=>i(this.joinResponse)),this.once(Nf.WS_CLOSED,()=>n(this.initError||new SE(fE.WS_ABORT))),this.connectionState=Of.CONNECTING,this.websocket.init(e).catch(n),this.websocket.once(FS.FAILBACK,()=>{void 0===this.openConnectionTime&&n(new SE(fE.INIT_DATACHANNEL_TIMEOUT));}),this.inflateDataTimer&&window.clearInterval(this.inflateDataTimer),this.inflateDataTimer=window.setInterval(()=>{this.handleInflateData();},2e4),setTimeout(()=>{t&&void 0===this.openConnectionTime&&(OE.debug("[".concat(this.clientId,"] init datachannel timeout while join with failback to websocket")),n(new SE(fE.INIT_DATACHANNEL_TIMEOUT)));},GE("DC_JOIN_WITH_FAILBACK"));})}close(e){this.pingpongTimer&&(this.pingpongTimeoutCount=0,window.clearInterval(this.pingpongTimer),this.pingpongTimer=void 0),this.inflateDataTimer&&(this.handleInflateData(),window.clearInterval(this.inflateDataTimer),this.inflateDataTimer=void 0),this.reconnectToken=void 0,this.joinResponse=void 0,this._disconnectedReason=e||vf.LEAVE,this.connectionState=Of.CLOSED,OE.debug("[".concat(this.clientId,"] ")+"will close datachannel in signal"),this.websocket.close(),e===vf.FALLBACK&&(this.websocket.removeAllListeners(),this.websocket=new LC("gateway-".concat(this.clientId),this.spec.retryConfig,!0,this.store),this.handleWebsocketEvents());}async join(){if(!this.joinResponse){this.emit(Nf.ABORT_P2P_EXECUTION);const e=await nC(this,Nf.DATACHANNEL_CONNECTING),t=await this.request(bf.JOIN,e);if(!t)return this.emit(Nf.REPORT_JOIN_GATEWAY,fE.TIMEOUT,this.url||""),!1;this.joinResponse=t,this.emit(Nf.JOIN_RESPONSE,this.joinResponse),this.reconnectToken=this.joinResponse.rejoin_token;}return this.connectionState=Of.CONNECTED,this.pingpongTimer&&window.clearInterval(this.pingpongTimer),this.pingpongTimer=window.setInterval(this.handlePingPong.bind(this),3e3),!0}async rejoin(){if(!this.reconnectToken)throw new SE(fE.UNEXPECTED_ERROR,"can not rejoin, no rejoin token");const e=sC(this,Nf.REQUEST_REJOIN_INFO);e.token=this.reconnectToken;const t=await this.request(bf.REJOIN,e);return !!t&&(this.connectionState=Of.CONNECTED,this.pingpongTimer&&window.clearInterval(this.pingpongTimer),this.pingpongTimer=window.setInterval(this.handlePingPong.bind(this),3e3),t.peers&&t.peers.forEach(e=>{this.emit(Df.ON_USER_ONLINE,{uid:e.uid}),e.audio&&this.emit(Df.ON_ADD_AUDIO_STREAM,{uid:e.uid,uint_id:e.uint_id,audio:!0,ssrcId:e.audio_ssrc}),e.video&&this.emit(Df.ON_ADD_VIDEO_STREAM,{uid:e.uid,uint_id:e.uint_id,video:!0,ssrcId:e.video_ssrc}),e.audio_mute?this.emit(Df.MUTE_AUDIO,{uid:e.uid}):this.emit(Df.UNMUTE_AUDIO,{uid:e.uid}),e.video_mute?this.emit(Df.MUTE_VIDEO,{uid:e.uid}):this.emit(Df.UNMUTE_VIDEO,{uid:e.uid}),e.audio_enable_local?this.emit(Df.ENABLE_LOCAL_AUDIO,{uid:e.uid}):this.emit(Df.DISABLE_LOCAL_AUDIO,{uid:e.uid}),e.video_enable_local?this.emit(Df.ENABLE_LOCAL_VIDEO,{uid:e.uid}):this.emit(Df.DISABLE_LOCAL_VIDEO,{uid:e.uid}),e.audio||e.video||this.emit(Df.ON_REMOVE_STREAM,{uid:e.uid,uint_id:e.uint_id});}),!0)}reconnect(e,t){this.pingpongTimer&&(this.pingpongTimeoutCount=0,window.clearInterval(this.pingpongTimer),this.pingpongTimer=void 0),this.websocket.reconnect(e,t);}handleNotification(e){OE.debug("[".concat(this.clientId,"] receive notification: "),e);const t=IC(e.code);if("success"!==t.action){if("failed"!==t.action)return "quit"===t.action?("ERR_REPEAT_JOIN_CHANNEL"===t.desc&&this.close(vf.UID_BANNED),void this.close()):void this.reconnect(t.action,jS.SERVER_ERROR);OE.error("[".concat(this.clientId,"] ignore error: "),t.desc);}}handlePingPong(){if(!this.websocket||"connected"!==this.websocket.state)return;this.pingpongTimeoutCount>0&&this.rttRolling.add(3e3),this.pingpongTimeoutCount+=1;const e=GE("PING_PONG_TIME_OUT"),t=Date.now();this.pingpongTimeoutCount>=e&&(OE.warning("PINGPONG Timeout. Last Socket Message: ".concat(t-this.lastMsgTime,"ms")),t-this.lastMsgTime>GE("WEBSOCKET_TIMEOUT_MIN"))?this.reconnect("retry",jS.TIMEOUT):this.request(bf.PING,void 0,!0).then(()=>{this.pingpongTimeoutCount=0;const e=Date.now()-t;this.rttRolling.add(e),GE("REPORT_STATS")&&this.send(bf.PING_BACK,{pingpongElapse:e});}).catch(e=>{});}handleInflateData(){const{inflateLength:e,deflateLength:t}=this.websocket.getInflateData();0!==e&&0!==t&&this.upload(wf.WS_INFLATE_DATA_LENGTH,{ws_deflate_length:t,ws_inflate_length:e});}handleWebsocketEvents(){this.websocket.on(FS.RECONNECT_WAITTING_FINISH,e=>{this.emit(Nf.WS_RECONNECT_WAITTING_FINISH,e);}),this.websocket.on(FS.RECONNECT_CREATE_CONNECTION,e=>{this.emit(Nf.WS_RECONNECT_CREATE_CONNECTION,e);}),this.websocket.on(FS.ON_MESSAGE,this.onWebsocketMessage),this.websocket.on(FS.CLOSED,()=>{this.connectionState=Of.CLOSED;}),this.websocket.on(FS.FAILED,()=>{this._disconnectedReason=vf.NETWORK_ERROR,this.connectionState=Of.CLOSED;}),this.websocket.on(FS.RECONNECTING,e=>{this._websocketReconnectReason=e,this.joinResponse=void 0,this.connectionState===Of.CONNECTED?this.connectionState=Of.RECONNECTING:this.connectionState=Of.CONNECTING;}),this.websocket.on(FS.WILL_RECONNECT,(e,t)=>{if(sC(this,Nf.IS_P2P_DISCONNECTED)&&"retry"===e)return OE.debug("".concat(this.clientId," reconnect mode is retry, but p2p lost, change to tryNext")),this.reconnectToken=void 0,this.emit(Nf.NEED_RENEW_SESSION),this.emit(Nf.DISCONNECT_P2P),t("tryNext");"retry"!==e&&(OE.debug("".concat(this.clientId," websockt will_connect event, renewSession reconnectMode is ").concat(e)),this.reconnectToken=void 0,this.emit(Nf.NEED_RENEW_SESSION),this.emit(Nf.DISCONNECT_P2P)),t(e);}),this.websocket.on(FS.CONNECTED,()=>{this.openConnectionTime=Date.now(),this.reconnectToken?this.rejoin().catch(e=>{OE.warning("[".concat(this.clientId,"] rejoin failed ").concat(e)),this.reconnect("tryNext",jS.SERVER_ERROR);}):this.join().catch(e=>{if(this.emit(Nf.REPORT_JOIN_GATEWAY,e.message||e.code,this.url||""),e instanceof SE&&e.code===fE.UNEXPECTED_RESPONSE&&e.data.code===If.ERR_NO_AUTHORIZED)return OE.warning("[".concat(this.clientId,"] reconnect no authorized, recover")),void this.reconnect("recover",jS.SERVER_ERROR);OE.error("[".concat(this.clientId,"] join gateway request failed"),e.toString()),this.spec.forceWaitGatewayResponse?this.reconnect("tryNext",jS.SERVER_ERROR):(this.initError=e,this.close());});}),this.websocket.on(FS.REQUEST_NEW_URLS,(e,t)=>{nC(this,Nf.REQUEST_RECOVER,this.multiIpOption).then(e).catch(t);}),this.websocket.on(FS.ON_TOKEN_PRIVILEGE_DID_EXPIRE,()=>{this.emit(Df.ON_TOKEN_PRIVILEGE_DID_EXPIRE);}),this.websocket.on(FS.TO_CONNECT_DATACHANNEL,async(e,t,i)=>nC(this,Nf.DATACHANNEL_PRECONNECT,e).then(t).catch(i)),this.websocket.on(FS.FAILBACK,()=>{void 0!==this.openConnectionTime&&this.emit(Nf.DATACHANNEL_FAILBACK);});}}function MC(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n);}return i}function UC(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?MC(Object(i),!0).forEach((function(t){_p(e,t,i[t]);})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):MC(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t));}));}return e}const xC=new Map;class VC extends EE{get state(){return this._state}set state(e){if(e===this._state)return;const t=this._state;this._state=e,"DISCONNECTED"===e&&this._disconnectedReason?this.emit(aS.CONNECTION_STATE_CHANGE,e,t,this._disconnectedReason):this.emit(aS.CONNECTION_STATE_CHANGE,e,t);}get joinGatewayStartTime(){return this._joinGatewayStartTime}set joinGatewayStartTime(e){OE.debug("[".concat(this.store.clientId,"] set joinGatewayStartTime at ").concat(e)),this._joinGatewayStartTime=e;}constructor(e,t){super(),_p(this,"store",void 0),_p(this,"joinInfo",void 0),_p(this,"key",void 0),_p(this,"signal",void 0),_p(this,"role",void 0),_p(this,"inChannelInfo",{joinAt:null,duration:0}),_p(this,"spec",void 0),_p(this,"_state","DISCONNECTED"),_p(this,"_statsCollector",void 0),_p(this,"_disconnectedReason",void 0),_p(this,"isSignalRecover",!1),_p(this,"hasChangeBGPAddress",!1),_p(this,"trafficStatsInterval",void 0),_p(this,"networkQualityInterval",void 0),_p(this,"_joinGatewayStartTime",0),_p(this,"_signalTimeout",!1),_p(this,"_clientRoleOptions",void 0),_p(this,"_isProactiveJoin",!1),this.store=e,this.spec=t,this.signal=this.store.useDataChannel?new kC(UC(UC({},t),{},{retryConfig:t.websocketRetryConfig}),e):new AC(UC(UC({},t),{},{retryConfig:t.websocketRetryConfig}),e),this._statsCollector=t.statsCollector,this.role=t.role||"audience",this._clientRoleOptions=t.clientRoleOptions,this.handleSignalEvents();}async join(e,t,i){if(this.signal instanceof kC){let t=!1;"disabled"!==e.cloudProxyServer?(OE.debug("[".concat(this.store.clientId,"] Dc is not supported, because cloudProxyServer are not supported (").concat(e.cloudProxyServer,")")),t=!0):"".concat(e.apResponse.cid,"_").concat(e.apResponse.cert).length>255||"".concat(e.apResponse.cid,"_").concat(e.apResponse.cert).length<22?(OE.debug("[".concat(this.store.clientId,"] Dc is not supported, because ticket length is incorrect, it has to be between 22 and 255")),t=!0):e.apResponse.addresses.some(e=>e.fingerprint)||GE("FINGERPRINT")||(OE.debug("[".concat(this.store.clientId,"] Dc is not supported, because fingerprint does not exist")),t=!0),t&&this.resetSignal();}this.store.joinGatewayStart(),"disabled"!==e.cloudProxyServer&&(this.hasChangeBGPAddress=!0);const n=Date.now();let r=xC.get(e.cname);if(r||(r=new Map,xC.set(e.cname,r)),this._isProactiveJoin=!0,r.has(e.uid)){const t=new SE(fE.UID_CONFLICT);throw Pg.joinGateway(e.sid,{lts:n,succ:!1,ec:t.message,addr:null,uid:e.uid,cid:e.cid,firstSuccess:this._isProactiveJoin,avoidJoinStartTime:this.store.avoidJoinStart,isProxy:!!e.proxyServer,signalChannel:this.signal instanceof kC?"1":"0"}),this._isProactiveJoin=!1,t}r.set(e.uid,!0),this.joinInfo=e,this.key=t;let o=0;this.joinGatewayStartTime=n;const s=e.proxyServer;try{let t;if(OE.debug("[".concat(this.store.clientId,"] use ").concat(this.signal instanceof kC?"datachannel":"websocket"," join uid ").concat(o)),this.signal instanceof kC)t=await this.signal.init(e.apResponse.addresses,i);else {const n=e.proxyServer,r=n?e.gatewayAddrs.map(e=>{const t=e.address.split(":");return "wss://".concat(n,"/ws/?h=").concat(t[0],"&p=").concat(t[1])}):e.gatewayAddrs.map(e=>"wss://".concat(e.address));t=await this.signal.init(r,i);}o=t.uid,OE.debug("[".concat(this.store.clientId,"] ").concat(this.signal instanceof kC?"datachannel":"websocket"," join uid ").concat(o," cost ").concat(Date.now()-this.joinGatewayStartTime));}catch(t){if(t&&t.code===fE.INIT_WEBSOCKET_TIMEOUT)throw OE.warning("[".concat(this.store.clientId,"] User join failed"),t.toString()),t;if(t&&t.code===fE.INIT_DATACHANNEL_TIMEOUT)throw OE.warning("[".concat(this.store.clientId,"] User join datachannel failed"),t.toString()),this.resetSignal(),t;throw OE.error("[".concat(this.store.clientId,"] User join failed"),t.toString()),Pg.joinGateway(e.sid,{lts:n,succ:!1,ec:t.message,addr:this.signal.url,uid:e.uid,cid:e.cid,firstSuccess:this._isProactiveJoin,avoidJoinStartTime:this.store.avoidJoinStart,isProxy:!!s,signalChannel:this.signal instanceof kC?"1":"0"}),this._isProactiveJoin=!1,r.delete(e.uid),this.signal.close(),t}return this.state="CONNECTED",this.inChannelInfo.joinAt=Date.now(),OE.debug("[".concat(this.store.clientId,"] Connected to gateway server")),this.trafficStatsInterval=window.setInterval(()=>{this.updateTrafficStats().catch(e=>{OE.warning("[".concat(this.store.clientId,"] get traffic stats error"),e.toString());});},3e3),this.networkQualityInterval=window.setInterval(()=>{navigator&&void 0!==navigator.onLine&&!navigator.onLine?this.emit(aS.NETWORK_QUALITY,{downlinkNetworkQuality:6,uplinkNetworkQuality:6}):this._signalTimeout?this.emit(aS.NETWORK_QUALITY,{downlinkNetworkQuality:5,uplinkNetworkQuality:5}):"CONNECTED"===this.state&&this._statsCollector.trafficStats?this.emit(aS.NETWORK_QUALITY,{uplinkNetworkQuality:GI(this._statsCollector.trafficStats.B_unq),downlinkNetworkQuality:GI(this._statsCollector.trafficStats.B_dnq)}):this.emit(aS.NETWORK_QUALITY,{uplinkNetworkQuality:0,downlinkNetworkQuality:0});},2e3),this.store.joinGatewayEnd(),o}async leave(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0],t=arguments.length>1?arguments[1]:void 0;if("DISCONNECTED"!==this.state){t!==vf.FALLBACK&&(this.state="DISCONNECTING");try{e||this.signal.connectionState!==Of.CONNECTED||await function(e,t){return t===1/0?e:Sl.race([e,QI(t)])}(this.signal.request(bf.LEAVE,void 0,!0),3e3);}catch(e){OE.warning("[".concat(this.store.clientId,"] leave request failed, ignore"),e);}this.signal.close(t),t!==vf.FALLBACK&&(this.state="DISCONNECTED"),this.reset();}}async publish(e,t,i){if("CONNECTED"!==this.state&&"RECONNECTING"!==this.state)throw new SE(fE.INVALID_OPERATION,"can not publish when connection state is ".concat(this.state));const n={state:"offer",p2p_id:this.store.p2pId,ortc:t,mode:this.spec.mode,extend:GE("PUB_EXTEND"),twcc:!!GE("PUBLISH_TWCC"),rtx:!!GE("USE_PUB_RTX")};try{return (await this.signal.request(bf.PUBLISH,n,!0))._message}catch(n){if(i&&n.data&&n.data.code===If.ERR_PUBLISH_REQUEST_INVALID)return OE.warning("[".concat(this.store.clientId,"] receive publish error code, retry"),n.toString()),await this.tryUnpubBeforeRepub(e,t),this.publish(e,t,!1);throw n}}async unpublish(e,t){try{if("CONNECTED"!==this.state&&"RECONNECTING"!==this.state)throw new SE(fE.INVALID_OPERATION,"can not publish when connection state is ".concat(this.state));await this.signal.request(bf.UNPUBLISH,{stream_id:t,ortc:e},!0);}catch(e){OE.warning("[".concat(this.store.clientId,"] unpublish warning: "),e);}}async subscribe(e,t,i){if("CONNECTED"!==this.state&&"RECONNECTING"!==this.state)throw new SE(fE.INVALID_OPERATION,"can not subscribe when connection state is ".concat(this.state));const n={stream_id:e,stream_type:t.stream_type,mode:this.spec.mode,codec:this.spec.codec,p2p_id:this.store.p2pId,twcc:!!GE("SUBSCRIBE_TWCC"),rtx:!!GE("USE_SUB_RTX"),extend:GE("SUB_EXTEND"),ssrcId:t.ssrcId,svc:Array.isArray(GE("SVC"))&&0!==GE("SVC").length?GE("SVC"):void 0};try{return (await this.signal.request(bf.SUBSCRIBE,n,!0))._message}catch(n){if(i&&n.data&&n.data.code===If.ERR_SUBSCRIBE_REQUEST_INVALID)return OE.warning("[".concat(this.store.clientId,"] receiver subscribe error code, retry"),n.toString()),await this.tryUnsubBeforeResub(e,t),await this.subscribe(e,t,!1);throw n}}async subscribeAll(e,t){if("CONNECTED"!==this.state&&"RECONNECTING"!==this.state)throw new SE(fE.INVALID_OPERATION,"can not massSubscribe when connection state is ".concat(this.state));const i={p2p_id:this.store.p2pId,users:e,dtx:!1,rtx:!!GE("USE_SUB_RTX")};try{return await this.signal.request(bf.SUBSCRIBE_STREAMS,i,!0)}catch(i){if(t&&i.data&&i.data.code===If.ERR_SUBSCRIBE_REQUEST_INVALID)return OE.warning("[".concat(this.store.clientId,"] receiver massSubscribe error code, retry"),i.toString()),await this.tryMassUnsubBeforeResub(e),await this.subscribeAll(e,!1);throw i}}async setVideoProfile(e){const t=function(e){if(!(e.bitrateMax&&e.bitrateMin&&e.frameRate&&e.height&&e.width))return;let t=e.frameRate,i=e.width,n=e.height,r=!0;return "number"!=typeof t&&(t=t.exact||t.ideal||t.max||t.min||0,t||(r=!1)),"number"!=typeof i&&(i=i.exact||i.ideal||i.max||i.min||0,i||(r=!1)),"number"!=typeof n&&(n=n.exact||n.ideal||n.max||n.min||0,t||(r=!1)),r?{stream_type:0,width:i,height:n,fps:t,start_bps:1e3*e.bitrateMax,min_bps:1e3*e.bitrateMin,target_bps:1e3*e.bitrateMax}:void 0}(e);if(t)return this.signal.request(bf.SET_VIDEO_PROFILE,t);OE.debug("[".concat(this.store.clientId,"] encoder config is not complete, do not report to gateway"));}async unsubscribe(e,t){try{await this.signal.request(bf.UNSUBSCRIBE,{p2p_id:this.store.p2pId,ortc:e,stream_id:t},!0);}catch(e){OE.warning("[".concat(this.store.clientId,"] unsubscribe warning: "),e);}}async massUnsubscribe(e){try{await this.signal.request(bf.UNSUBSCRIBE_STREAMS,e,!0);}catch(e){OE.warning("[".concat(this.store.clientId,"] massUnsubscribeAll warning: "),e);}}async reconnectPC(e){const{iceParameters:t,dtlsParameters:i,rtpCapabilities:n}=e;return {gatewayEstablishParams:await this.signal.request(bf.CONNECT_PC,{p2p_id:this.store.p2pId,stream_id:this.store.uid,ortc:{iceParameters:t,dtlsParameters:i,rtpCapabilities:n}},!0),gatewayAddress:this.getCurrentGatewayAddress()}}getGatewayInfo(){return this.signal.request(bf.GATEWAY_INFO)}async renewToken(e){await this.signal.request(bf.RENEW_TOKEN,e),this.key=e.token;}async setClientRole(e,t){if(t&&(this._clientRoleOptions=Object.assign({},t)),"CONNECTED"!==this.state)return void(this.role=e);let i=void 0;i="audience"===e?this._clientRoleOptions&&this._clientRoleOptions.level?this._clientRoleOptions.level:2:0,await this.signal.request(bf.SET_CLIENT_ROLE,{role:e,level:i,client_ts:Date.now()}),this.role=e;}async setRemoteVideoStreamType(e,t){await this.signal.request(bf.SWITCH_VIDEO_STREAM,{stream_id:e,stream_type:t});}async setDefaultRemoteVideoStreamType(e){await this.signal.request(bf.DEFAULT_VIDEO_STREAM,{stream_type:e});}async setStreamFallbackOption(e,t){await this.signal.request(bf.SET_FALLBACK_OPTION,{stream_id:e,fallback_type:t});}async pickSVCLayer(e,t){await this.signal.request(bf.PICK_SVC_LAYER,{stream_id:e,spatial_layer:t.spatialLayer,temporal_layer:t.temporalLayer});}getInChannelInfo(){return this.inChannelInfo.joinAt&&(this.inChannelInfo.duration=Date.now()-this.inChannelInfo.joinAt),UC({},this.inChannelInfo)}async getGatewayVersion(){return (await this.signal.request(bf.GATEWAY_INFO)).version}reset(){if(this.inChannelInfo.joinAt&&(this.inChannelInfo.duration=Date.now()-this.inChannelInfo.joinAt,this.inChannelInfo.joinAt=null),this.trafficStatsInterval&&(window.clearInterval(this.trafficStatsInterval),this.trafficStatsInterval=void 0),this.joinInfo){const e=xC.get(this.joinInfo.cname);e&&e.delete(this.joinInfo.uid);}this.joinInfo=void 0,this.key=void 0,this.networkQualityInterval&&(window.clearInterval(this.networkQualityInterval),this.networkQualityInterval=void 0);}updateTurnConfigFromSignal(){if(!this.joinInfo)return;const e=function(e){let t;return t=e.startsWith("dc")?e.match(/(dc\:\/\/)?([^:]+):(\d+)/):e.match(/(wss\:\/\/)?([^:]+):(\d+)/),t?{username:PE.username,password:PE.password,turnServerURL:t[2],tcpport:parseInt(t[3])+30,udpport:parseInt(t[3])+30,forceturn:!1}:null}(("disabled"===this.joinInfo.cloudProxyServer?this.signal.url:this.joinInfo.gatewayAddrs[this.signal.currentURLIndex].address)||"");this.joinInfo.turnServer.serversFromGateway=[],e&&"off"!==this.joinInfo.turnServer.mode&&"disabled"===this.joinInfo.cloudProxyServer&&this.joinInfo.turnServer.serversFromGateway.push(UC(UC({},PE),{},{turnServerURL:e.turnServerURL,tcpport:e.tcpport,udpport:e.udpport,username:this.joinInfo.uid.toString(),password:this.joinInfo.token}));}async updateTrafficStats(){if("CONNECTED"!==this.state)return;const e=await this.signal.request(bf.TRAFFIC_STATS,void 0,!0);e.timestamp=Date.now(),e.peer_delay.forEach(e=>{const t=this._statsCollector.trafficStats&&this._statsCollector.trafficStats.peer_delay.find(t=>t.peer_uid===e.peer_uid);t&&t.B_st!==e.B_st&&dC(()=>{this.emit(aS.STREAM_TYPE_CHANGE,e.peer_uid,e.B_st);});}),this._statsCollector.updateTrafficStats(e);}getJoinMessage(e){if(!this.joinInfo||!this.key)throw new SE(fE.UNEXPECTED_ERROR,"can not generate join message, no join info");const t=Object.assign({},this.joinInfo.apResponse);let i=GE("REPORT_APP_SCENARIO");if("string"!=typeof i)try{i=JSON.stringify(i);}catch(e){i=void 0;}i&&i.length>128&&(i=void 0);const n=UC({license:this.joinInfo.license,p2p_id:this.store.p2pId,session_id:this.joinInfo.sid,app_id:this.joinInfo.appId,channel_key:this.key,channel_name:this.joinInfo.cname,sdk_version:bE,browser:navigator.userAgent,process_id:GE("PROCESS_ID"),mode:this.spec.mode,codec:this.spec.codec,role:this.role,has_changed_gateway:this.hasChangeBGPAddress,ap_response:t,extend:GE("JOIN_EXTEND"),details:{6:this.joinInfo.stringUid,cservice_map:"proxy3"===this.joinInfo.cloudProxyServer?"1":"proxy5"===this.joinInfo.cloudProxyServer?"2":void 0},features:{rejoin:!0},optionalInfo:this.joinInfo.optionalInfo,appScenario:i,attributes:{userAttributes:{enablePublishedUserList:GE("ENABLE_PUBLISHED_USER_LIST"),maxSubscription:GE("MAX_SUBSCRIPTION"),subscribeAudioFilterTopN:"number"==typeof GE("SUBSCRIBE_AUDIO_FILTER_TOPN")?GE("SUBSCRIBE_AUDIO_FILTER_TOPN"):void 0,enablePublishAudioFilter:"boolean"==typeof GE("ENABLE_PUBLISH_AUDIO_FILTER")?GE("ENABLE_PUBLISH_AUDIO_FILTER"):void 0,enableUserLicenseCheck:"boolean"==typeof GE("ENABLE_USER_LICENSE_CHECK")?GE("ENABLE_USER_LICENSE_CHECK"):void 0,enableRTX:!0===GE("USE_PUB_RTX")||!0===GE("USE_SUB_RTX")||void 0}},join_ts:this.joinGatewayStartTime},e);return this.joinInfo.stringUid&&(n.string_uid=this.joinInfo.stringUid),this.joinInfo.aesmode&&this.joinInfo.aespassword&&(n.aes_mode=this.joinInfo.aesmode,GE("ENCRYPT_AES")?(n.aes_secret=this.joinInfo.aespassword,n.aes_encrypt=!0):n.aes_secret=this.joinInfo.aespassword,this.joinInfo.aessalt&&(n.aes_salt=this.joinInfo.aessalt)),t.addresses[this.signal.websocket.currentURLIndex]&&(n.ap_response.ticket=t.addresses[this.signal.websocket.currentURLIndex].ticket,delete t.addresses),void 0!==this.joinInfo.defaultVideoStream&&(n.default_video_stream=this.joinInfo.defaultVideoStream),n}getRejoinMessage(){if(!this.joinInfo)throw new SE(fE.UNEXPECTED_ERROR,"can not generate rejoin message, no join info");return {session_id:this.joinInfo.sid,channel_name:this.joinInfo.cname,cid:this.joinInfo.cid,uid:this.joinInfo.uid,vid:Number(this.joinInfo.vid)}}handleSignalEvents(){this.signal.on(Nf.WS_RECONNECT_WAITTING_FINISH,e=>{["tryNext","recover"].includes(e)&&this.joinInfo&&Pg.adjustSessionStartTime(this.joinInfo.sid);}),this.signal.on(Nf.WS_RECONNECT_CREATE_CONNECTION,e=>{this.joinGatewayStartTime=Date.now();}),this.signal.on(Nf.WS_RECONNECTING,e=>{this.joinInfo&&Pg.WebSocketQuit(this.joinInfo.sid,{lts:Date.now(),succ:-1,cname:this.joinInfo.cname,uid:this.joinInfo.uid,cid:this.joinInfo.cid,errorCode:e||Af.NETWORK_ERROR}),this.joinInfo&&(this.state="RECONNECTING",Pg.sessionInit(this.joinInfo.sid,{lts:(new Date).getTime(),extend:this.isSignalRecover?{recover:!0}:{rejoin:!0},cname:this.joinInfo.cname,appid:this.joinInfo.appId,mode:this.spec.mode}),this.isSignalRecover=!1,this.joinGatewayStartTime=Date.now());}),this.signal.on(Nf.WS_CLOSED,e=>{let t;switch(e){case vf.LEAVE:t=Af.LEAVE;break;case vf.UID_BANNED:case vf.IP_BANNED:case vf.CHANNEL_BANNED:case vf.SERVER_ERROR:t=Af.SERVER_ERROR;break;case vf.FALLBACK:t=Af.FALLBACK;break;case vf.LICENSE_MISSING:case vf.LICENSE_EXPIRED:case vf.LICENSE_MINUTES_EXCEEDED:case vf.LICENSE_PERIOD_INVALID:case vf.LICENSE_MULTIPLE_SDK_SERVICE:case vf.LICENSE_ILLEGAL:t=e;break;default:t=Af.NETWORK_ERROR;}OE.debug("[".concat(this.store.clientId,"] [signal] websocket closed, reason: ").concat(t||"undefined -> "+Af.NETWORK_ERROR)),this.joinInfo&&Pg.WebSocketQuit(this.joinInfo.sid,{lts:Date.now(),succ:e===vf.LEAVE?1:-1,cname:this.joinInfo.cname,uid:this.joinInfo.uid,cid:this.joinInfo.cid,errorCode:t}),this._disconnectedReason=e,e!==vf.FALLBACK&&(this.state="DISCONNECTED"),this.reset();}),this.signal.on(Nf.WS_CONNECTED,()=>{if(this.updateTurnConfigFromSignal(),this.state="CONNECTED",this.joinInfo&&("audience"===this.role&&this._clientRoleOptions&&this._clientRoleOptions.level&&(OE.debug("[".concat(this.store.clientId,"] patch to send set client role, role: ").concat(this.role,", mode: ").concat(this.spec.mode,", level: ").concat(this._clientRoleOptions&&this._clientRoleOptions.level)),this.setClientRole(this.role,this._clientRoleOptions)),Pg.joinGateway(this.joinInfo.sid,{lts:this.joinGatewayStartTime,succ:!0,ec:null,vid:this.joinInfo.vid,addr:this.signal.url,uid:this.joinInfo.uid,cid:this.joinInfo.cid,firstSuccess:this._isProactiveJoin,avoidJoinStartTime:this.store.avoidJoinStart,isProxy:!!this.joinInfo.proxyServer,signalChannel:this.signal instanceof kC?"1":"0"}),this._isProactiveJoin=!1,this.joinInfo.useLocalAccessPoint&&1===this.joinInfo.setLocalAPVersion)){const e=this.signal.url&&this.signal.url.match(/wss\:\/\/([^:]+):(\d+)/);if(!e)return void OE.error("[".concat(this.store.clientId,"] set local access point after joined failed: ").concat(e));BE("EVENT_REPORT_DOMAIN",e[1]),BE("EVENT_REPORT_BACKUP_DOMAIN",e[1]),BE("LOG_UPLOAD_SERVER","".concat(e[1],":6444"));}}),this.signal.on(Df.ON_UPLINK_STATS,e=>{this._statsCollector.updateUplinkStats(e);}),this.signal.on(Nf.REQUEST_RECOVER,(e,t,i)=>{if(!this.joinInfo)return i(new SE(fE.UNEXPECTED_ERROR,"gateway: can not recover, no join info"));e&&(this.joinInfo.multiIP=e,this.hasChangeBGPAddress=!0),this.isSignalRecover=!0,nC(this,aS.REQUEST_NEW_GATEWAY_LIST).then(t).catch(i);}),this.signal.on(Nf.REQUEST_JOIN_INFO,async e=>{var t;this.updateTurnConfigFromSignal();const{iceParameters:i,dtlsParameters:n,rtpCapabilities:r}=await nC(this,aS.REQUEST_P2P_CONNECTION_PARAMS,{turnServer:null===(t=this.joinInfo)||void 0===t?void 0:t.turnServer});e(this.getJoinMessage({ortc:{iceParameters:i,dtlsParameters:n,rtpCapabilities:r,version:"2"}}));}),this.signal.on(Nf.REQUEST_REJOIN_INFO,e=>{e(this.getRejoinMessage());}),this.signal.on(Nf.REPORT_JOIN_GATEWAY,(e,t)=>{this.joinInfo&&(Pg.joinGateway(this.joinInfo.sid,{lts:this.joinGatewayStartTime,succ:!1,ec:e,addr:t,uid:this.joinInfo.uid,cid:this.joinInfo.cid,firstSuccess:this._isProactiveJoin,avoidJoinStartTime:this.store.avoidJoinStart,isProxy:!!this.joinInfo.proxyServer,signalChannel:this.signal instanceof kC?"1":"0"}),this._isProactiveJoin=!1);}),this.signal.on(Nf.IS_P2P_DISCONNECTED,e=>{e(sC(this,aS.IS_P2P_DISCONNECTED));}),this.signal.on(Nf.DISCONNECT_P2P,()=>{this.emit(aS.DISCONNECT_P2P);}),this.signal.on(Nf.NEED_RENEW_SESSION,()=>{this.emit(aS.NEED_RENEW_SESSION);}),this.signal.on(Nf.REQUEST_SUCCESS,()=>{this._signalTimeout=!1;}),this.signal.on(Nf.REQUEST_TIMEOUT,()=>{this._signalTimeout=!0;}),this.signal.on(Nf.JOIN_RESPONSE,e=>{const t=this.getCurrentGatewayAddress();this.emit(aS.JOIN_RESPONSE,e,t);}),this.signal.on(Nf.DATACHANNEL_PRECONNECT,async(e,t,i)=>{this.updateTurnConfigFromSignal();const n=this.getCurrentGatewayAddress();return nC(this,aS.DATACHANNEL_PRECONNECT,e,n).then(t).catch(i)}),this.signal.on(Nf.DATACHANNEL_CONNECTING,async e=>{const{iceParameters:t,dtlsParameters:i,rtpCapabilities:n}=await nC(this,aS.REQUEST_DC_CONNECTION_PARAMS);e(this.getJoinMessage({ortc:{iceParameters:t,dtlsParameters:i,rtpCapabilities:n,version:"2"}}));}),this.signal.on(Nf.DATACHANNEL_FAILBACK,()=>{OE.warning("[".concat(this.store.clientId,"] User join datachannel failed")),this.reset(),this.resetSignal(),this.emit(aS.DATACHANNEL_FAILBACK);});}async tryUnsubBeforeResub(e,t){try{await this.signal.request(bf.UNSUBSCRIBE,{p2p_id:this.store.p2pId,stream_id:e,ortc:[t]},!0);}catch(e){throw OE.warning("[".concat(this.store.clientId,"] tryUnsubBeforeResub warning"),e),e}}async tryUnpubBeforeRepub(e,t){try{await this.signal.request(bf.UNPUBLISH,{stream_id:e,ortc:t},!0);}catch(e){throw OE.warning("[".concat(this.store.clientId,"] tryUnpubBeforeRepub warning: "),e),e}}async tryMassUnsubBeforeResub(e){const t={users:e.map(e=>({stream_id:e.stream_id,stream_type:e.stream_type}))};try{await this.signal.request(bf.UNSUBSCRIBE_STREAMS,t,!0);}catch(e){throw OE.warning("[".concat(this.store.clientId,"] tryMassUnsubBeforeResub warning"),e),e}}async muteLocal(e,t){const i={action:e.find(e=>e.stream_type===sS.Audio)?"mute_local_audio":"mute_local_video",p2p_id:this.store.p2pId,ortc:e,stream_id:t};try{await this.signal.request(bf.CONTROL,i,!0,!0);}catch(e){throw OE.warning("[".concat(this.store.clientId,"] gateway muteLocal warning: "),e),e}}async unmuteLocal(e,t){const i={action:e.find(e=>e.stream_type===sS.Audio)?"unmute_local_audio":"unmute_local_video",p2p_id:this.store.p2pId,ortc:e,stream_id:t};try{await this.signal.request(bf.CONTROL,i,!0,!0);}catch(e){throw OE.warning("[".concat(this.store.clientId,"] gateway unmuteLocal warning: "),e),e}}uploadStats(e,t){this.signal.upload(e,t);}getSignalRTT(){return this.signal.rtt}async restartICE(e){const t={p2p_id:this.store.p2pId,stream_id:this.store.uid,ortc:e};try{return await this.signal.request(bf.RESTART_ICE,t,!0)}catch(e){throw OE.warning("[".concat(this.store.clientId,"] P2PChannel.restartICE warning: "),e),e}}reconnect(){"CONNECTED"===this.state&&this.signal.reconnect(void 0,Af.P2P_FAILED);}getCurrentGatewayAddress(){var e;if(!GE("GATEWAY_WSS_ADDRESS"))return null!==(e=this.joinInfo)&&void 0!==e&&e.gatewayAddrs?this.joinInfo.gatewayAddrs[this.signal.currentURLIndex]:void 0}async setPublishAudioFilterEnabled(e){await this.signal.request(bf.SET_PARAMETER,{enablePublishAudioFilter:e});}resetSignal(){this.signal&&(this.signal.removeAllListeners(),this.signal.close(vf.FALLBACK)),this.store.useDataChannel=!1,this.signal=new AC(UC(UC({},this.spec),{},{retryConfig:this.spec.websocketRetryConfig}),this.store),this.handleSignalEvents(),this.emit(aS.RESET_SIGNAL,dS.websocket);}}
/*! formdata-polyfill. MIT License. Jimmy W?rting <https://jimmy.warting.se/opensource> */!function(){var e;function i(e){var t=0;return function(){return t<e.length?{done:!1,value:e[t++]}:{done:!0}}}var n="function"==typeof Object.defineProperties?Object.defineProperty:function(e,t,i){return e==Array.prototype||e==Object.prototype||(e[t]=i.value),e};var r,o=function(e){e=["object"==typeof globalThis&&globalThis,e,"object"==typeof window&&window,"object"==typeof self&&self,"object"==typeof t&&t];for(var i=0;i<e.length;++i){var n=e[i];if(n&&n.Math==Math)return n}throw Error("Cannot find global object")}(this);function s(e,t){if(t)e:{var i=o;e=e.split(".");for(var r=0;r<e.length-1;r++){var s=e[r];if(!(s in i))break e;i=i[s];}(t=t(r=i[e=e[e.length-1]]))!=r&&null!=t&&n(i,e,{configurable:!0,writable:!0,value:t});}}function a(e){return (e={next:e})[Symbol.iterator]=function(){return this},e}function c(e){var t="undefined"!=typeof Symbol&&Symbol.iterator&&e[Symbol.iterator];return t?t.call(e):{next:i(e)}}if(s("Symbol",(function(e){function t(e,t){this.A=e,n(this,"description",{configurable:!0,writable:!0,value:t});}if(e)return e;t.prototype.toString=function(){return this.A};var i="jscomp_symbol_"+(1e9*Math.random()>>>0)+"_",r=0;return function e(n){if(this instanceof e)throw new TypeError("Symbol is not a constructor");return new t(i+(n||"")+"_"+r++,n)}})),s("Symbol.iterator",(function(e){if(e)return e;e=Symbol("Symbol.iterator");for(var t="Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array".split(" "),r=0;r<t.length;r++){var s=o[t[r]];"function"==typeof s&&"function"!=typeof s.prototype[e]&&n(s.prototype,e,{configurable:!0,writable:!0,value:function(){return a(i(this))}});}return e})),"function"==typeof Object.setPrototypeOf)r=Object.setPrototypeOf;else {var d;e:{var u={};try{u.__proto__={a:!0},d=u.a;break e}catch(e){}d=!1;}r=d?function(e,t){if(e.__proto__=t,e.__proto__!==t)throw new TypeError(e+" is not extensible");return e}:null;}var l=r;function h(){this.m=!1,this.j=null,this.v=void 0,this.h=1,this.u=this.C=0,this.l=null;}function p(e){if(e.m)throw new TypeError("Generator is already running");e.m=!0;}function _(e,t){return e.h=3,{value:t}}function E(e){this.g=new h,this.G=e;}function m(e,t,i,n){try{var r=t.call(e.g.j,i);if(!(r instanceof Object))throw new TypeError("Iterator result "+r+" is not an object");if(!r.done)return e.g.m=!1,r;var o=r.value;}catch(t){return e.g.j=null,e.g.s(t),f(e)}return e.g.j=null,n.call(e.g,o),f(e)}function f(e){for(;e.g.h;)try{var t=e.G(e.g);if(t)return e.g.m=!1,{value:t.value,done:!1}}catch(t){e.g.v=void 0,e.g.s(t);}if(e.g.m=!1,e.g.l){if(t=e.g.l,e.g.l=null,t.F)throw t.D;return {value:t.return,done:!0}}return {value:void 0,done:!0}}function S(e){this.next=function(t){return e.o(t)},this.throw=function(t){return e.s(t)},this.return=function(t){return function(e,t){p(e.g);var i=e.g.j;return i?m(e,"return"in i?i.return:function(e){return {value:e,done:!0}},t,e.g.return):(e.g.return(t),f(e))}(e,t)},this[Symbol.iterator]=function(){return this};}function T(e,t){return t=new S(new E(t)),l&&e.prototype&&l(t,e.prototype),t}if(h.prototype.o=function(e){this.v=e;},h.prototype.s=function(e){this.l={D:e,F:!0},this.h=this.C||this.u;},h.prototype.return=function(e){this.l={return:e},this.h=this.u;},E.prototype.o=function(e){return p(this.g),this.g.j?m(this,this.g.j.next,e,this.g.o):(this.g.o(e),f(this))},E.prototype.s=function(e){return p(this.g),this.g.j?m(this,this.g.j.throw,e,this.g.o):(this.g.s(e),f(this))},s("Array.prototype.entries",(function(e){return e||function(){return function(e,t){e instanceof String&&(e+="");var i=0,n=!1,r={next:function(){if(!n&&i<e.length){var r=i++;return {value:t(r,e[r]),done:!1}}return n=!0,{done:!0,value:void 0}}};return r[Symbol.iterator]=function(){return r},r}(this,(function(e,t){return [e,t]}))}})),"undefined"!=typeof Blob&&("undefined"==typeof FormData||!FormData.prototype.keys)){var g=function(e,t){for(var i=0;i<e.length;i++)t(e[i]);},R=function(e){return e.replace(/\r?\n|\r/g,"\r\n")},I=function(e,t,i){return t instanceof Blob?(i=void 0!==i?String(i+""):"string"==typeof t.name?t.name:"blob",t.name===i&&"[object Blob]"!==Object.prototype.toString.call(t)||(t=new File([t],i)),[String(e),t]):[String(e),String(t)]},C=function(e,t){if(e.length<t)throw new TypeError(t+" argument required, but only "+e.length+" present.")},v="object"==typeof globalThis?globalThis:"object"==typeof window?window:"object"==typeof self?self:this,y=v.FormData,A=v.XMLHttpRequest&&v.XMLHttpRequest.prototype.send,O=v.Request&&v.fetch,N=v.navigator&&v.navigator.sendBeacon,b=v.Element&&v.Element.prototype,w=v.Symbol&&Symbol.toStringTag;w&&(Blob.prototype[w]||(Blob.prototype[w]="Blob"),"File"in v&&!File.prototype[w]&&(File.prototype[w]="File"));try{new File([],"");}catch(e){v.File=function(e,t,i){return e=new Blob(e,i||{}),Object.defineProperties(e,{name:{value:t},lastModified:{value:+(i&&void 0!==i.lastModified?new Date(i.lastModified):new Date)},toString:{value:function(){return "[object File]"}}}),w&&Object.defineProperty(e,w,{value:"File"}),e};}var D=function(e){return e.replace(/\n/g,"%0A").replace(/\r/g,"%0D").replace(/"/g,"%22")},P=function(e){this.i=[];var t=this;e&&g(e.elements,(function(e){if(e.name&&!e.disabled&&"submit"!==e.type&&"button"!==e.type&&!e.matches("form fieldset[disabled] *"))if("file"===e.type){var i=e.files&&e.files.length?e.files:[new File([],"",{type:"application/octet-stream"})];g(i,(function(i){t.append(e.name,i);}));}else "select-multiple"===e.type||"select-one"===e.type?g(e.options,(function(i){!i.disabled&&i.selected&&t.append(e.name,i.value);})):"checkbox"===e.type||"radio"===e.type?e.checked&&t.append(e.name,e.value):(i="textarea"===e.type?R(e.value):e.value,t.append(e.name,i));}));};if((e=P.prototype).append=function(e,t,i){C(arguments,2),this.i.push(I(e,t,i));},e.delete=function(e){C(arguments,1);var t=[];e=String(e),g(this.i,(function(i){i[0]!==e&&t.push(i);})),this.i=t;},e.entries=function e(){var t,i=this;return T(e,(function(e){if(1==e.h&&(t=0),3!=e.h)return t<i.i.length?e=_(e,i.i[t]):(e.h=0,e=void 0),e;t++,e.h=2;}))},e.forEach=function(e,t){C(arguments,1);for(var i=c(this),n=i.next();!n.done;n=i.next()){var r=c(n.value);n=r.next().value,r=r.next().value,e.call(t,r,n,this);}},e.get=function(e){C(arguments,1);var t=this.i;e=String(e);for(var i=0;i<t.length;i++)if(t[i][0]===e)return t[i][1];return null},e.getAll=function(e){C(arguments,1);var t=[];return e=String(e),g(this.i,(function(i){i[0]===e&&t.push(i[1]);})),t},e.has=function(e){C(arguments,1),e=String(e);for(var t=0;t<this.i.length;t++)if(this.i[t][0]===e)return !0;return !1},e.keys=function e(){var t,i,n,r,o=this;return T(e,(function(e){if(1==e.h&&(t=c(o),i=t.next()),3!=e.h)return i.done?void(e.h=0):(n=i.value,r=c(n),_(e,r.next().value));i=t.next(),e.h=2;}))},e.set=function(e,t,i){C(arguments,2),e=String(e);var n=[],r=I(e,t,i),o=!0;g(this.i,(function(t){t[0]===e?o&&(o=!n.push(r)):n.push(t);})),o&&n.push(r),this.i=n;},e.values=function e(){var t,i,n,r,o=this;return T(e,(function(e){if(1==e.h&&(t=c(o),i=t.next()),3!=e.h)return i.done?void(e.h=0):(n=i.value,(r=c(n)).next(),_(e,r.next().value));i=t.next(),e.h=2;}))},P.prototype._asNative=function(){for(var e=new y,t=c(this),i=t.next();!i.done;i=t.next()){var n=c(i.value);i=n.next().value,n=n.next().value,e.append(i,n);}return e},P.prototype._blob=function(){var e="----formdata-polyfill-"+Math.random(),t=[],i="--"+e+'\r\nContent-Disposition: form-data; name="';return this.forEach((function(e,n){return "string"==typeof e?t.push(i+D(R(n))+'"\r\n\r\n'+R(e)+"\r\n"):t.push(i+D(R(n))+'"; filename="'+D(e.name)+'"\r\nContent-Type: '+(e.type||"application/octet-stream")+"\r\n\r\n",e,"\r\n")})),t.push("--"+e+"--"),new Blob(t,{type:"multipart/form-data; boundary="+e})},P.prototype[Symbol.iterator]=function(){return this.entries()},P.prototype.toString=function(){return "[object FormData]"},b&&!b.matches&&(b.matches=b.matchesSelector||b.mozMatchesSelector||b.msMatchesSelector||b.oMatchesSelector||b.webkitMatchesSelector||function(e){for(var t=(e=(this.document||this.ownerDocument).querySelectorAll(e)).length;0<=--t&&e.item(t)!==this;);return -1<t}),w&&(P.prototype[w]="FormData"),A){var L=v.XMLHttpRequest.prototype.setRequestHeader;v.XMLHttpRequest.prototype.setRequestHeader=function(e,t){L.call(this,e,t),"content-type"===e.toLowerCase()&&(this.B=!0);},v.XMLHttpRequest.prototype.send=function(e){e instanceof P?(e=e._blob(),this.B||this.setRequestHeader("Content-Type",e.type),A.call(this,e)):A.call(this,e);};}O&&(v.fetch=function(e,t){return t&&t.body&&t.body instanceof P&&(t.body=t.body._blob()),O.call(this,e,t)}),N&&(v.navigator.sendBeacon=function(e,t){return t instanceof P&&(t=t._asNative()),N.call(this,e,t)}),v.FormData=P;}}();const jC=()=>{const e=GE("AREAS");0===e.length&&e.push(SS.GLOBAL);return zi(e).call(e,(e,t,i)=>{const n=FC(t);return n?0===i?n:"".concat(e,",").concat(n):e},"")},FC=e=>e===SS.OVERSEA?"".concat(IS.ASIA,",").concat(IS.EUROPE,",").concat(IS.AFRICA,",").concat(IS.NORTH_AMERICA,",").concat(IS.SOUTH_AMERICA,",").concat(IS.OCEANIA):IS[e],BC=e=>{const t={CODE:"",WEBCS_DOMAIN:[],WEBCS_DOMAIN_BACKUP_LIST:[],PROXY_CS:[],CDS_AP:[],ACCOUNT_REGISTER:[],UAP_AP:[],EVENT_REPORT_DOMAIN:[],EVENT_REPORT_BACKUP_DOMAIN:[],LOG_UPLOAD_SERVER:[],PROXY_SERVER_TYPE3:[]};return e.map(e=>{const i=CS[e],n=Object.keys(i);n&&n.map(e=>{"CODE"!==e&&(t[e]=t[e].concat(i[e]));});}),t},GC={GLOBAL:{ASIA:[SS.CHINA,SS.JAPAN,SS.INDIA,SS.KOREA,SS.HKMC],EUROPE:[],NORTH_AMERICA:[SS.US],SOUTH_AMERICA:[],OCEANIA:[],AFRICA:[]}},WC=Object.keys(GC[SS.GLOBAL]),HC=[SS.CHINA,SS.NORTH_AMERICA,SS.EUROPE,SS.ASIA,SS.JAPAN,SS.INDIA,SS.OCEANIA,SS.SOUTH_AMERICA,SS.AFRICA,SS.KOREA,SS.HKMC,SS.US],KC=function(e,t){let i=[];if(e.includes(SS.GLOBAL)){const o=[SS.GLOBAL,SS.OVERSEA],s=Object.keys(CS);if(t===SS.GLOBAL)throw new SE(fE.INVALID_PARAMS,"GLOBAL is an invalid excludedArea value");if(t===SS.CHINA)i=[SS.OVERSEA];else if(r=t,WC.includes(r)){const e=(n=t,GC[SS.GLOBAL][n]||[]),r=[...o,t,...e];i=s.filter(e=>!r.includes(e));}else if(function(e){let t=!1;return WC.forEach(i=>{GC[SS.GLOBAL][i].includes(e)&&(t=!0);}),t}(t)){const e=function(e){let t;return WC.forEach(i=>{GC[SS.GLOBAL][i].includes(e)&&(t=i);}),t}(t),n=[...o,e,t];i=s.filter(e=>!n.includes(e));}else i=e;i=function(e){const t=[];return HC.forEach(i=>{e.includes(i)&&t.push(i);}),t.concat(e.filter(e=>!HC.includes(e)))}(i);}else i=e;var n,r;return i};function YC(e){if(!e&&GE("AREAS").includes(SS.EXTENSIONS))return OE.debug("update area from ap : reset"),void qC(DE,!0);if(!GE("AREAS").includes(SS.GLOBAL)||!e)return;let t=CS.EXTENSIONS;t&&(t={CODE:FC(SS.EXTENSIONS),WEBCS_DOMAIN:["ap-web-1-".concat(e,".agora.io")],WEBCS_DOMAIN_BACKUP_LIST:["ap-web-2-".concat(e,".ap.sd-rtn.com")],PROXY_CS:["proxy-ap-web-".concat(e,".agora.io")],CDS_AP:["cds-ap-web-1-".concat(e,".agora.io"),"cds-ap-web-2-".concat(e,".ap.sd-rtn.com")],ACCOUNT_REGISTER:["sua-ap-web-1-".concat(e,".agora.io"),"sua-ap-web-2-".concat(e,".ap.sd-rtn.com")],UAP_AP:["uap-ap-web-1-".concat(e,".agora.io"),"uap-ap-web-2-".concat(e,".ap.sd-rtn.com")],EVENT_REPORT_DOMAIN:["statscollector-1-".concat(e,".agora.io")],EVENT_REPORT_BACKUP_DOMAIN:["statscollector-2-".concat(e,".agora.io")],LOG_UPLOAD_SERVER:["logservice-".concat(e,".agora.io")],PROXY_SERVER_TYPE3:["webrtc-cloud-proxy-".concat(e,".agora.io")]},OE.debug("update area from ap success: ".concat(e,",config is "),t),BE("AREAS",[SS.EXTENSIONS],!0),Object.keys(t).map(e=>{if("LOG_UPLOAD_SERVER"===e||"EVENT_REPORT_DOMAIN"===e||"EVENT_REPORT_BACKUP_DOMAIN"===e||"PROXY_SERVER_TYPE3"===e){BE(e,t[e][0]);}else BE(e,t[e]);}));}function qC(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const i=Pg.reportApiInvoke(null,{name:_f.SET_AREA,options:e,tag:Ef.TRACER});try{let n=[];if("string"==typeof e&&(n=[e]),Array.isArray(e)&&(e.forEach(e=>{if(!RS.includes(e))throw new SE(fE.INVALID_PARAMS,"invalid area code")}),n=e),"[object Object]"===Object.prototype.toString.call(e)){const{areaCode:t,excludedArea:i}=e;if(!t)throw new SE(fE.INVALID_PARAMS,"area code is needed");let r=t;"string"==typeof t&&(r=[t]),n=i?KC(r,i):r;}if(!t){if(HE.AREAS){const e=new SE(fE.PROHIBITED_OPERATION,"setArea is prohibited because of config-distribute");return i.onError(e),void OE.warning("setArea is prohibited because of config-distribute")}if(n.includes(SS.GLOBAL)&&GE("AREAS")===SS.EXTENSIONS){const e=new SE(fE.PROHIBITED_OPERATION,"setArea is prohibited because of ap extensions");return i.onError(e),void OE.warning("setArea is prohibited because of ap extensions")}}BE("AREAS",n,t);const r=BC(n);Object.keys(r).map(e=>{if("LOG_UPLOAD_SERVER"===e||"EVENT_REPORT_DOMAIN"===e||"EVENT_REPORT_BACKUP_DOMAIN"===e||"PROXY_SERVER_TYPE3"===e){BE(e,r[e][0]);}else BE(e,r[e]);}),OE.debug("set area success:",n.join(","));}catch(e){throw i.onError(e),e}i.onSuccess();}function JC(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n);}return i}function XC(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?JC(Object(i),!0).forEach((function(t){_p(e,t,i[t]);})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):JC(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t));}));}return e}let zC=1;function QC(e,t,i,n,r){zC+=1;const o={sid:i.sid,command:"convergeAllocateEdge",uid:"666",appId:i.appId,ts:Math.floor(Date.now()/1e3),seq:zC,requestId:zC,version:bE,cname:i.cname},s={service_name:t,json_body:JSON.stringify(o)};let a,c,d=e[0];return RE(async()=>{a=Date.now();const e=await gg(d,{data:s,cancelToken:n,headers:{"X-Packet-Service-Type":"0","X-Packet-URI":"61"}});if(c=Date.now()-a,0!==e.code){const t=new SE(fE.UNEXPECTED_RESPONSE,"live streaming ap error, code"+e.code,{retry:!0,responseTime:c});throw OE.error(t.toString()),t}const i=JSON.parse(e.json_body);if(200!==i.code){const e=new SE(fE.UNEXPECTED_RESPONSE,"live streaming app center error, code: ".concat(i.code,", reason: ").concat(i.reason),{code:i.code,responseTime:c});throw OE.error(e.toString()),e}if(!i.servers||0===i.servers.length){const e=new SE(fE.UNEXPECTED_RESPONSE,"live streaming app center empty server",{code:i.code,responseTime:c});throw OE.error(e.toString()),e}const r=function(e,t){return {addressList:e.servers.map(e=>"wss://".concat(e.address.replace(/\./g,"-"),".").concat(GE("WORKER_DOMAIN"),":").concat(e.wss,"?serviceName=").concat(encodeURIComponent(t))),workerToken:e.workerToken,vid:e.vid}}(i,t);return GE("LIVE_STREAMING_ADDRESS")&&(r.addressList=GE("LIVE_STREAMING_ADDRESS")instanceof Array?GE("LIVE_STREAMING_ADDRESS"):[GE("LIVE_STREAMING_ADDRESS")]),XC(XC({},r),{},{responseTime:c})},(n,r)=>(Pg.apworkerEvent(i.sid,{success:!0,sc:200,serviceName:t,responseDetail:JSON.stringify(n.addressList),firstSuccess:0===r,responseTime:c,serverIp:e[r%e.length]}),!1),(n,r)=>(Pg.apworkerEvent(i.sid,{success:!1,sc:n.data&&n.data.code||200,serviceName:t,responseTime:c,serverIp:e[r%e.length]}),!!(n.code!==fE.OPERATION_ABORTED&&n.code!==fE.UNEXPECTED_RESPONSE||n.data&&n.data.retry)&&(d=e[(r+1)%e.length],!0)),r)}let ZC=1;function $C(e,t,i,n){let{url:r,areaCode:o}=e;const s=Date.now();let a;const[c,d]=rv(t,o,[XS.CHOOSE_SERVER]);let u=Ig.networkState;return RE(async()=>{u&&Ig.networkState===PS.OFFLINE&&Ig.onlineWaiter&&await Sl.race([Ig.onlineWaiter,zI(n&&n.maxRetryTimeout||TE.maxRetryTimeout)]),u=Ig.networkState;const{data:e,headers:o}=await gg(r,{data:c,cancelToken:i,headers:{"Content-Type":"multipart/form-data;"}},!0,!0);a="1"===o.http3?1:-1,Pg.reportResourceTiming(r,t.sid),tv(e,r,t,s,[XS.CHOOSE_SERVER],a);const d=WI(e,XS.CHOOSE_SERVER);return iv(d),jI(d,r)},e=>(e&&Pg.joinChooseServer(t.sid,{lts:s,succ:!0,csAddr:r,opid:d,serverList:e.gatewayAddrs.map(e=>e.address),ec:null,cid:e.cid.toString(),uid:e.uid.toString(),csIp:e.csIp,unilbsServerIds:[XS.CHOOSE_SERVER].toString(),isHttp3:a}),!1),e=>e.code!==fE.OPERATION_ABORTED&&(e.code===fE.CAN_NOT_GET_GATEWAY_SERVER?e.data.retry:(Pg.joinChooseServer(t.sid,{lts:s,succ:!1,csAddr:r,serverList:null,opid:d,ec:e.code,csIp:e.data&&e.data.csIp,unilbsServerIds:[XS.CHOOSE_SERVER].toString(),extend:JSON.stringify({networkState:u}),isHttp3:a}),OE.warning("[".concat(t.clientId,"] Choose server network error, retry"),e),!0)),n)}function ev(e,t,i,n){let r,{url:o,areaCode:s,serviceIds:a}=e;const c=Date.now(),[d,u]=rv(t,s,a);let l=void 0;return RE(async()=>{l&&Ig.networkState===PS.OFFLINE&&Ig.onlineWaiter&&await Sl.race([Ig.onlineWaiter,zI(n&&n.maxRetryTimeout||TE.maxRetryTimeout)]),l=Ig.networkState;const{data:e,headers:s}=await gg(o,{data:d,cancelToken:i,headers:{"Content-Type":"multipart/form-data;"}},!0,!0);r="1"===s.http3?1:-1,Pg.reportResourceTiming(o,t.sid),tv(e,o,t,c,a,r);const u=WI(e,XS.CHOOSE_SERVER),h=WI(e,"proxy5"===t.cloudProxyServer?XS.CLOUD_PROXY_5:"proxy3"===t.cloudProxyServer||"proxy4"===t.cloudProxyServer?XS.CLOUD_PROXY:XS.CLOUD_PROXY_FALLBACK);return iv(u),{gatewayInfo:jI(u,o),proxyInfo:h,url:o}},e=>(e.gatewayInfo&&Pg.joinChooseServer(t.sid,{lts:c,succ:!0,csAddr:o,serverList:e.gatewayInfo.gatewayAddrs.map(e=>e.address),ec:null,opid:u,cid:e.gatewayInfo.cid.toString(),uid:e.gatewayInfo.uid.toString(),csIp:e.gatewayInfo.csIp,unilbsServerIds:a.toString(),isHttp3:r}),e.proxyInfo&&Pg.joinWebProxyAP(t.sid,{lts:c,sucess:1,apServerAddr:o,turnServerAddrList:e.proxyInfo.addresses.map(e=>e.ip).join(","),errorCode:null,eventType:t.cloudProxyServer,unilbsServerIds:a.toString()}),!1),e=>e.code!==fE.OPERATION_ABORTED&&(e.code===fE.CAN_NOT_GET_GATEWAY_SERVER?e.data.retry:(Pg.joinWebProxyAP(t.sid,{lts:c,sucess:0,apServerAddr:o,turnServerAddrList:null,errorCode:e.code,eventType:t.cloudProxyServer,unilbsServerIds:a.toString(),extend:JSON.stringify({networkState:l})}),OE.warning("[".concat(t.clientId,"] multi unilbs network error, retry"),e),!0)),n)}const tv=(e,t,i,n,r,o)=>{const s=[],a=s=>{4096===s.flag?Pg.joinChooseServer(i.sid,{lts:n,succ:!1,csAddr:t,opid:e.opid,serverList:null,ec:s.error.message,csIp:s.error.data&&s.error.data.csIp,unilbsServerIds:r.toString(),isHttp3:o}):1048576!==s.flag&&4194304!==s.flag&&4194310!==s.flag||Pg.joinWebProxyAP(i.sid,{lts:n,sucess:0,apServerAddr:t,turnServerAddrList:null,errorCode:s.error.code,eventType:i.cloudProxyServer,unilbsServerIds:r.toString()});};if(e.response_body.forEach(t=>{const i=t.buffer.code;if(23===t.uri&&0===i&&!t.buffer.edges_services)if(4194310===t.buffer.flag)OE.warning("no edge services in ap response of proxy fallback, will not set proxy in iceServers"),t.buffer.edges_services=[];else {const i={error:new SE(fE.CAN_NOT_GET_GATEWAY_SERVER,"no edge services in ap response",{retry:!0,csIp:e.detail[502]}),flag:t.buffer.flag};s.push(i),a(i);}if(0!==i){const n=gC(i),r={error:new SE(fE.CAN_NOT_GET_GATEWAY_SERVER,n.desc,{desc:n.desc,retry:n.retry,csIp:e.detail[502]}),flag:t.buffer.flag};4194310===t.buffer.flag?OE.warning(r.error.toString()):s.push(r),a(r);}}),s.length)throw OE.warning("[".concat(i.clientId,"] multi unilbs ").concat(t," failed, ").concat(s.map(e=>"flag: ".concat(e.flag,", message: ").concat(e.error.message,", retry: ").concat(e.error.data.retry)).join(" | "))),new SE(fE.CAN_NOT_GET_GATEWAY_SERVER,s.map(e=>"flag: ".concat(e.flag,", message: ").concat(e.error.message)).join(" | "),{retry:!!s.find(e=>e.error.data.retry),csIp:e.detail[502],desc:[...new Set(s.map(e=>{var t,i;return null==e||null===(t=e.error)||void 0===t||null===(i=t.data)||void 0===i?void 0:i.desc}).filter(e=>!!e))]})},iv=e=>{var t,i,n,r;if(e.addresses&&0===e.addresses.length&&0===e.code)throw new SE(fE.CAN_NOT_GET_GATEWAY_SERVER,"void gateway address",{retry:!0,csIp:e.detail&&e.detail[502]});GE("AP_AREA")&&(null!==(n=e.detail)&&void 0!==n&&n[23]&&"string"==typeof(null===(r=e.detail)||void 0===r?void 0:r[23])?YC(e.detail[23].toLowerCase()):YC());if(null!==(t=e.detail)&&void 0!==t&&t[19]&&"string"==typeof(null===(i=e.detail)||void 0===i?void 0:i[19])){const t=e.detail[19],i=null==t?void 0:t.split(";");for(let t=0;t<i.length;t++){var o;const n=mh(o=i[t]).call(o);e.addresses[t]&&i&&(e.addresses[t].fingerprint=n);}}if(GE("GATEWAY_ADDRESS")&&GE("GATEWAY_ADDRESS").length>0){OE.debug("assign gateway address to",GE("GATEWAY_ADDRESS"));const t=GE("GATEWAY_ADDRESS").map(t=>{var i,n;const r=null!==(i=null===(n=e.addresses.find(e=>e.ip===t.ip&&e.port===t.port))||void 0===n?void 0:n.fingerprint)&&void 0!==i?i:"";return {ip:t.ip,port:t.port,ticket:e.addresses[0]&&e.addresses[0].ticket,fingerprint:r}});e.addresses=t;}},nv=(e,t)=>{if(e.response_body&&e.response_body.length){const t=e.response_body[0];if(0!==t.buffer.code){const e=gC(t.buffer.code);throw new SE(fE.UPDATE_TICKET_FAILED,"[".concat(t.buffer.code,"]: ").concat(e.desc),{retry:e.retry})}return t.buffer.ticket}throw OE.debug("update ticket request received ap response without response body:",t),new SE(fE.UPDATE_TICKET_FAILED,"cannot find response body from ap response",{retry:!1})},rv=(e,t,i)=>{const n=Math.floor(Math.random()*10**12),r={appid:e.appId,client_ts:Date.now(),opid:n,sid:e.sid,request_bodies:[{uri:22,buffer:{cname:e.cname,detail:{6:e.stringUid,11:t,12:GE("USE_NEW_TOKEN")?"1":void 0,22:t},key:e.token,service_ids:i,uid:e.uid||0}}]};r.request_bodies.forEach(t=>{e.multiIP&&e.multiIP.gateway_ip&&(t.buffer.detail[5]=JSON.stringify({vocs_ip:[e.multiIP.uni_lbs_ip],vos_ip:[e.multiIP.gateway_ip]}));});const o=new FormData;return o.append("request",JSON.stringify(r)),[o,n]},ov=(e,t)=>{const i=Math.floor(Math.random()*10**12),n={appid:e.appId,client_ts:Date.now(),opid:i,sid:e.sid,request_bodies:[{uri:28,buffer:{cname:e.cname,detail:{1:"",6:e.stringUid,12:"1"},token:e.token,service_ids:t,uid:e.uid||0,edges_services:e.apResponse.addresses.map(e=>({ip:e.ip,port:e.port}))}}]},r=new FormData;return r.append("request",JSON.stringify(n)),[r,i]};let sv=0;async function av(e,t,i,n){const r=async function(e,t,i,n){let r=null;const o=[],s=async()=>{const r=GE("WEBCS_DOMAIN").slice(0,GE("AJAX_REQUEST_CONCURRENT")).map(t=>({url:e.proxyServer?"https://".concat(e.proxyServer,"/ap/?url=").concat(t+"/api/v2/transpond/webrtc?v=2"):"https://".concat(t,"/api/v2/transpond/webrtc?v=2"),areaCode:jC()})),s=n.recordJoinChannelService({startTs:Date.now(),status:"pending",service:"chooseServer",urls:r.map(e=>e.url)}),a=await fC({fragementLength:GE("FRAGEMENT_LENGTH"),referenceList:r,asyncMapHandler:n=>(OE.debug("[".concat(e.clientId,"] Connect to choose_server:"),n.url),$C(n,e,t,i)),allFailedhandler:e=>{throw n.recordJoinChannelService({endTs:Date.now(),status:"error",errors:e},s),e[0]},promisesCollector:o});return n.recordJoinChannelService({endTs:Date.now(),status:"success"},s),a},a=async()=>{if(await zI(1e3),null!==r)return r;const s=GE("WEBCS_DOMAIN_BACKUP_LIST").map(t=>({url:e.proxyServer?"https://".concat(e.proxyServer,"/ap/?url=").concat(t+"/api/v2/transpond/webrtc?v=2"):"https://".concat(t,"/api/v2/transpond/webrtc?v=2"),areaCode:jC()})),a=n.recordJoinChannelService({endTs:void 0,startTs:Date.now(),status:"pending",service:"chooseServer",urls:s.map(e=>e.url)}),c=await fC({fragementLength:GE("FRAGEMENT_LENGTH"),referenceList:s,asyncMapHandler:n=>(OE.debug("[".concat(e.clientId,"] Connect to backup choose_server:"),n.url),$C(n,e,t,i)),allFailedhandler:e=>{throw n.recordJoinChannelService({endTs:Date.now(),status:"error",errors:e},a),e[0]},promisesCollector:o});return n.recordJoinChannelService({endTs:Date.now(),status:"success"},a),c};try{return r=await iC([s(),a()]),o.length&&o.forEach(e=>e.cancel&&"function"==typeof e.cancel&&e.cancel()),r}catch(e){throw e[0]}}(e,t,i,n);return {gatewayInfo:await r}}async function cv(e,t,i,n,r){const o=e.cloudProxyServer;if("disabled"===o){if(!n)return;if(e.useLocalAccessPoint)return await av(e,t,i,r);if(GE("JOIN_WITH_FALLBACK_MEDIA_PROXY")){const{gatewayInfo:n,proxyInfo:o}=await lv(e,t,i,r);return e.turnServer&&"auto"!==e.turnServer.mode||(e.turnServer={mode:"manual",servers:o.map(e=>({turnServerURL:e.address,tcpport:e.tcpport||PE.tcpport,udpport:e.udpport||PE.udpport,username:e.username||PE.username,password:e.password||PE.password,forceturn:!1,security:!0}))}),{gatewayInfo:n}}return await av(e,t,i,r)}const{proxyInfo:s,gatewayInfo:a}=await lv(e,t,i,r),c={gatewayInfo:a};return e.turnServer={mode:"manual",servers:s.map(e=>({turnServerURL:e.address,tcpport:"proxy3"===o?void 0:e.tcpport?e.tcpport:PE.tcpport,udpport:"proxy4"===o?void 0:e.udpport?e.udpport:PE.udpport,username:e.username||PE.username,password:e.password||PE.password,forceturn:"proxy4"!==o,security:"proxy5"===o}))},OE.debug("[".concat(e.clientId,"] set proxy server: ").concat(e.proxyServer,", mode: ").concat(o)),c}async function dv(e,t,i,n,r){const o=GE("ACCOUNT_REGISTER").slice(0,GE("AJAX_REQUEST_CONCURRENT"));let s=[];s=t.proxyServer?o.map(e=>"https://".concat(t.proxyServer,"/ap/?url=").concat(e+"/api/v1")):o.map(e=>"https://".concat(e,"/api/v1"));const a=null==r?void 0:r.recordJoinChannelService({startTs:Date.now(),status:"pending",service:"stringUID",urls:s});try{const o=await async function(e,t,i,n,r){const o=Date.now(),s={sid:i.sid,opid:10,appid:i.appId,string_uid:t};let a=e[0];const c=await RE(()=>gg(a+"".concat(-1===a.indexOf("?")?"?":"&","action=stringuid"),{data:s,cancelToken:n,headers:{"X-Packet-Service-Type":0,"X-Packet-URI":72}}),(i,n)=>{if(0===i.code){if(i.uid<=0||i.uid>=Math.pow(2,32))throw OE.error("Invalid Uint Uid ".concat(t," => ").concat(i.uid),i),Pg.reqUserAccount(s.sid,{lts:o,success:!1,serverAddr:a,stringUid:s.string_uid,uid:i.uid,errorCode:fE.INVALID_UINT_UID_FROM_STRING_UID,extend:s}),new SE(fE.INVALID_UINT_UID_FROM_STRING_UID);return Pg.reqUserAccount(s.sid,{lts:o,success:!0,serverAddr:a,stringUid:s.string_uid,uid:i.uid,errorCode:null,extend:s}),!1}const r=gC(i.code);return r.retry&&(a=e[(n+1)%e.length]),Pg.reqUserAccount(s.sid,{lts:o,success:!1,serverAddr:a,stringUid:s.string_uid,uid:i.uid,errorCode:r.desc,extend:s}),r.retry},(t,i)=>t.code!==fE.OPERATION_ABORTED&&(Pg.reqUserAccount(s.sid,{lts:o,success:!1,serverAddr:a,stringUid:s.string_uid,uid:null,errorCode:t.code,extend:s}),a=e[(i+1)%e.length],!0),r);if(0!==c.code){const e=gC(c.code);throw new SE(fE.UNEXPECTED_RESPONSE,e.desc)}return c}(s,e,t,i,n);return null==r||r.recordJoinChannelService({status:"success",endTs:Date.now()},a),o.uid}catch(e){throw null==r||r.recordJoinChannelService({status:"error",endTs:Date.now(),errors:[e]},a),e}}async function uv(e,t,i){const n=GE("CDS_AP").slice(0,GE("AJAX_REQUEST_CONCURRENT")).map(t=>e.proxyServer?"https://".concat(e.proxyServer,"/ap/?url=").concat(t+"/api/v1"):"https://".concat(t,"/api/v1?action=config")).map(n=>function(e,t,i,n){const r=xh(),o={flag:64,cipher_method:0,features:{device:r.name,system:r.os,system_general:navigator.userAgent,vendor:t.appId,version:bE,cname:t.cname,sid:t.sid,session_id:t.sid,detail:"",proxyServer:t.proxyServer}};return RE(()=>gg(e,{data:o,timeout:1e3,cancelToken:i,headers:{"X-Packet-Service-Type":0,"X-Packet-URI":54}}),void 0,e=>e.code!==fE.OPERATION_ABORTED,n)}(n,e,t,i));let r=null,o=null,s={};try{r=await iC(n);}catch(e){if(e.code===fE.OPERATION_ABORTED)throw e;o=e;}n.forEach(e=>e.cancel());if(Pg.reportApiInvoke(e.sid,{name:_f.REQUEST_CONFIG_DISTRIBUTE,options:{error:o,res:r}}).onSuccess(),r&&r.test_tags)try{s=function(e){if(!e.test_tags)return {};const t=e.test_tags,i=Object.keys(t),n={};return i.forEach(e=>{var i;const r=mh(i=e.slice(4)).call(i),o=JSON.parse(t[e])[1];n[r]=o;}),n}(r);}catch(e){}return s}async function lv(e,t,i,n){const r=GE("PROXY_SERVER_TYPE3"),o=(e,t,i)=>{let n=i||r;return Array.isArray(n)&&(n=t%2==0?r[1]:r[0]),"https://".concat(n,"/ap/?url=").concat(e)};let s=null;const a=[],c=async()=>{const r=GE("WEBCS_DOMAIN").slice(0,GE("AJAX_REQUEST_CONCURRENT")).map((t,i)=>{let n;return n="disabled"===e.cloudProxyServer&&e.proxyServer?o("".concat(t,"/api/v2/transpond/webrtc?v=2"),i,e.proxyServer):"disabled"===e.cloudProxyServer||"fallback"===e.cloudProxyServer?"https://".concat(t,"/api/v2/transpond/webrtc?v=2"):o("".concat(t,"/api/v2/transpond/webrtc?v=2"),i),{url:n,areaCode:jC(),serviceIds:[XS.CHOOSE_SERVER,"proxy5"===e.cloudProxyServer?XS.CLOUD_PROXY_5:"proxy3"===e.cloudProxyServer||"proxy4"===e.cloudProxyServer?XS.CLOUD_PROXY:XS.CLOUD_PROXY_FALLBACK]}}),s=n.recordJoinChannelService({startTs:Date.now(),status:"pending",service:"chooseServer",urls:r.map(e=>e.url)}),c=await fC({fragementLength:GE("FRAGEMENT_LENGTH"),referenceList:r,asyncMapHandler:n=>(OE.debug("[".concat(e.clientId,"] Connect to choose_server:"),n.url),ev(n,e,t,i)),allFailedhandler:e=>{throw n.recordJoinChannelService({endTs:Date.now(),status:"error",errors:e},s),e[0]},promisesCollector:a});return n.recordJoinChannelService({endTs:Date.now(),status:"success"},s),c},d=async()=>{if(await zI(1e3),null!==s)return s;const r=GE("WEBCS_DOMAIN_BACKUP_LIST").map((t,i)=>{let n;return n="disabled"===e.cloudProxyServer&&e.proxyServer?o("".concat(t,"/api/v2/transpond/webrtc?v=2"),i,e.proxyServer):"disabled"===e.cloudProxyServer||"fallback"===e.cloudProxyServer?"https://".concat(t,"/api/v2/transpond/webrtc?v=2"):o("".concat(t,"/api/v2/transpond/webrtc?v=2"),i),{url:n,areaCode:jC(),serviceIds:[XS.CHOOSE_SERVER,"proxy5"===e.cloudProxyServer?XS.CLOUD_PROXY_5:"proxy3"===e.cloudProxyServer||"proxy4"===e.cloudProxyServer?XS.CLOUD_PROXY:XS.CLOUD_PROXY_FALLBACK]}}),c=n.recordJoinChannelService({startTs:Date.now(),status:"pending",service:"chooseServer",urls:r.map(e=>e.url)}),d=await fC({fragementLength:GE("FRAGEMENT_LENGTH"),referenceList:r,asyncMapHandler:n=>(OE.debug("[".concat(e.clientId,"] Connect to backup choose_server:"),n.url),ev(n,e,t,i)),allFailedhandler:e=>{throw n.recordJoinChannelService({endTs:Date.now(),status:"error",errors:e},c),e[0]},promisesCollector:a});return n.recordJoinChannelService({endTs:Date.now(),status:"success"},c),d};let u,l,h;try{({gatewayInfo:u,proxyInfo:l,url:h}=await iC([c(),d()]));}catch(e){throw e[0]}if(a.length&&a.forEach(e=>e.cancel&&"function"==typeof e.cancel&&e.cancel()),!u||!l)throw new SE(fE.UNEXPECTED_ERROR,"missing gateway or proxy response").print();if(e.apUrl=h,"disabled"!==e.cloudProxyServer&&Array.isArray(r)&&h){const t=/^https?:\/\/(.+?)(\/.*)?$/.exec(h)[1];r.includes(t)&&(e.proxyServer=t,OE.setProxyServer(t),Pg.setProxyServer(t));}return s={gatewayInfo:u,proxyInfo:await HI(l,u.uid)},s}async function hv(e,t,i,n){const r=GE("UAP_AP").slice(0,GE("AJAX_REQUEST_CONCURRENT")).map(e=>t.proxyServer?"https://".concat(t.proxyServer,"/ap/?url=").concat(e+"/api/v1?action=uap"):"https://".concat(e,"/api/v1?action=uap"));return await QC(r,e,t,i,n)}async function pv(e,t,i){const n=GE("UAP_AP").slice(0,GE("AJAX_REQUEST_CONCURRENT")).map(t=>e.proxyServer?"https://".concat(e.proxyServer,"/ap/?url=").concat(t+"/api/v1?action=uap"):"https://".concat(t,"/api/v1?action=uap")).map(n=>function(e,t,i,n){const r={command:"convergeAllocateEdge",sid:t.sid,appId:t.appId,token:t.token,ts:Date.now(),version:bE,cname:t.cname,uid:t.uid.toString(),requestId:ZC,seq:ZC};ZC+=1;const o={service_name:"tele_channel",json_body:JSON.stringify(r)};return RE(async()=>{const t=await gg(e,{data:o,cancelToken:i,headers:{"X-Packet-Service-Type":0,"X-Packet-URI":61}});if(0!==t.code){const e=new SE(fE.UNEXPECTED_RESPONSE,"cross channel ap error, code"+t.code,{retry:!0});throw OE.error(e.toString()),e}const n=JSON.parse(t.json_body);if(200!==n.code){const e=new SE(fE.UNEXPECTED_RESPONSE,"cross channel app center error, code: ".concat(n.code,", reason: ").concat(n.reason));throw OE.error(e.toString()),e}if(!n.servers||0===n.servers.length){const e=new SE(fE.UNEXPECTED_RESPONSE,"cross channel app center empty server");throw OE.error(e.toString()),e}return {vid:n.vid,workerToken:n.workerToken,addressList:(GE("CHANNEL_MEDIA_RELAY_SERVERS")||n.servers).map(e=>"wss://".concat(e.address.replace(/\./g,"-"),".").concat(GE("WORKER_DOMAIN"),":").concat(e.wss))}},void 0,e=>!!(e.code!==fE.OPERATION_ABORTED&&e.code!==fE.UNEXPECTED_RESPONSE||e.data&&e.data.retry),n)}(n,e,t,i));try{const e=await iC(n);return n.forEach(e=>e.cancel()),e}catch(e){throw e[0]}}async function _v(e,t,i){let n=null;const r=[],o=async o=>{const s=GE(o?"WEBCS_DOMAIN_BACKUP_LIST":"WEBCS_DOMAIN").map(t=>e.proxyServer?"https://".concat(e.proxyServer,"/ap/?url=").concat(t+"/api/v2/transpond/webrtc?v=2"):"https://".concat(t,"/api/v2/transpond/webrtc?v=2"));return o&&(await zI(1e3),null!==n)?n:await fC({fragementLength:GE("FRAGEMENT_LENGTH"),referenceList:s,asyncMapHandler:n=>(OE.debug("[".concat(e.clientId,"] update ticket, Connect to ").concat(o?"backup":""," choose_server:"),n),function(e,t,i,n){const[r]=ov(t,[XS.CHOOSE_SERVER]);let o=Ig.networkState;return RE(async()=>{o&&Ig.networkState===PS.OFFLINE&&Ig.onlineWaiter&&await Sl.race([Ig.onlineWaiter,zI(n&&n.maxRetryTimeout||TE.maxRetryTimeout)]),o=Ig.networkState;const t=await gg(e,{data:r,cancelToken:i,headers:{"Content-Type":"multipart/form-data;"}},!0);return nv(t,e)},()=>!1,e=>e.code!==fE.OPERATION_ABORTED&&(e.code===fE.UPDATE_TICKET_FAILED?e.data.retry:(OE.warning("[".concat(t.clientId,"] update ticket network error, retry"),e),!0)),n)}(n,e,t,i)),allFailedhandler:e=>{throw e[0]},promisesCollector:r})};try{return n=await iC([o(!1),o(!0)]),r.length&&r.forEach(e=>e.cancel&&"function"==typeof e.cancel&&e.cancel()),n}catch(e){throw e[0]}}function Ev(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n);}return i}function mv(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?Ev(Object(i),!0).forEach((function(t){_p(e,t,i[t]);})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):Ev(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t));}));}return e}class fv extends EE{constructor(){super(),_p(this,"configs",void 0),_p(this,"joinInfo",void 0),_p(this,"cancelToken",void 0),_p(this,"retryConfig",{timeout:3e3,timeoutFactor:1.5,maxRetryCount:1,maxRetryTimeout:1e4}),_p(this,"interval",void 0),_p(this,"mutex",new Ug("config-distribute")),_p(this,"mutableParamsRead",!1);}startGetConfigDistribute(e,t){this.joinInfo=e,this.cancelToken=t,this.interval&&this.stopGetConfigDistribute(),GE("ENABLE_CONFIG_DISTRIBUTE")&&(this.updateConfigDistribute(),this.interval=window.setInterval(()=>{this.updateConfigDistribute();},GE("CONFIG_DISTRIBUTE_INTERVAL")));}stopGetConfigDistribute(){this.interval&&clearInterval(this.interval),this.interval=void 0,this.joinInfo=void 0,this.cancelToken=void 0;}async awaitConfigDistributeComplete(){if(!this.mutex.isLocked)return;(await this.mutex.lock())();}async updateConfigDistribute(){if(!this.mutableParamsRead){this.mutableParamsRead=!0;Pg.reportApiInvoke(null,{options:void 0,name:_f.LOAD_CONFIG_FROM_LOCALSTORAGE,tag:Ef.TRACER}).onSuccess(JSON.stringify(HE));}if(!this.joinInfo||!this.cancelToken||!this.retryConfig)return void OE.debug("[config-distribute] get config distribute interrupted have no joininfo");let e;const t=await this.mutex.lock();try{e=await uv(this.joinInfo,this.cancelToken,this.retryConfig),OE.debug("[config-distribute] get config distribute",JSON.stringify(e)),e.limit_bitrate&&this.handleBitrateLimit(e.limit_bitrate),this.cacheGlobalParameterConfig(e),this.configs=e;}catch(e){const t=new SE(fE.NETWORK_RESPONSE_ERROR,e);OE.warning("[config-distribute] ".concat(t.toString()));}finally{t();}}getBitrateLimit(){return this.configs?this.configs.limit_bitrate:void 0}handleBitrateLimit(e){var t;(t=e)&&t.uplink&&t.id&&void 0!==t.uplink.max_bitrate&&void 0!==t.uplink.min_bitrate&&(this.configs&&this.configs.limit_bitrate?this.configs&&this.configs.limit_bitrate&&this.configs.limit_bitrate.id!==e.id&&this.emit(vS.UPDATE_BITRATE_LIMIT,e):this.emit(vS.UPDATE_BITRATE_LIMIT,e));}getLowStreamConfigDistribute(){return this.configs&&this.configs.limit_bitrate&&mv({},this.configs.limit_bitrate.low_stream_uplink)}cacheGlobalParameterConfig(e){var t;const i=Hm(t=Object.keys(e).filter(e=>/^webrtc_ng_global_parameter/.test(e))).call(t);for(let t=0;t<i.length;t++)for(let n=i.length-1;n>t;n--){const t=i[n];if("number"==typeof e[t].__priority){const r=e[t].__priority,o=i[n-1];if("number"==typeof e[o].__priority){if(!(r>e[o].__priority))continue;{const e=t;i[n]=i[n-1],i[n-1]=e;}}else {const e=t;i[n]=i[n-1],i[n-1]=e;}}}const n={};i.forEach(t=>{const i=e[t],r=i.__expires;Object.keys(i).forEach(e=>{"__priority"===e||"__expires"===e||Object.prototype.hasOwnProperty.call(n,e)||(n[e]=mv({value:i[e]},r&&{expires:r}));});});try{const e=JSON.stringify(n),t=window.btoa(e);window.localStorage.setItem("websdk_ng_global_parameter",t),OE.debug("Caching global parameters ".concat(e));}catch(e){OE.error("Error caching global parameters:",e.message);}}}function Sv(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n);}return i}function Tv(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?Sv(Object(i),!0).forEach((function(t){_p(e,t,i[t]);})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):Sv(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t));}));}return e}class gv extends EE{constructor(e,t,i,n){super(),_p(this,"spec",void 0),_p(this,"token",void 0),_p(this,"websocket",void 0),_p(this,"pingpongTimer",void 0),_p(this,"reconnectMode","retry"),_p(this,"serviceMode",void 0),_p(this,"reqId",0),_p(this,"commandReqId",0),_p(this,"handleWebSocketOpen",()=>{this.reconnectMode="retry",this.startPingPong();}),_p(this,"handleWebSocketMessage",e=>{if(!e.data)return;const t=JSON.parse(e.data);t.requestId?this.emit("@".concat(t.requestId,"-").concat(t.sid),t):this.serviceMode===Kf.INJECT?this.emit(Zf.INJECT_STREAM_STATUS,t):(Pg.workerEvent(this.spec.sid,{actionType:"status",serverCode:t.code,workerType:this.serviceMode===Kf.TRANSCODE?1:2}),this.emit(Zf.PUBLISH_STREAM_STATUS,t));}),this.spec=t,this.token=e,this.serviceMode=n,this.websocket=new vC("live-streaming",i),this.websocket.on(Hf.CONNECTED,this.handleWebSocketOpen),this.websocket.on(Hf.ON_MESSAGE,this.handleWebSocketMessage),this.websocket.on(Hf.REQUEST_NEW_URLS,(e,t)=>{nC(this,Zf.REQUEST_NEW_ADDRESS).then(e).catch(t);}),this.websocket.on(Hf.RECONNECTING,()=>{this.websocket.reconnectMode=this.reconnectMode;});}init(e){return this.websocket.init(e)}async request(e,t,i,n){this.reqId+=1,"request"===e&&(this.commandReqId+=1);const r=this.commandReqId,o=this.reqId;if(!o||!this.websocket)throw new SE(fE.UNEXPECTED_ERROR);const s=Tv({command:e,sdkVersion:"4.18.2"===bE?"0.0.1":bE,seq:o,requestId:o,allocate:i,cname:this.spec.cname,appId:this.spec.appId,sid:this.spec.sid,uid:this.spec.uid.toString(),ts:Math.floor(Date.now()/1e3)},t);if("closed"===this.websocket.state)throw new SE(fE.WS_DISCONNECT);const a=()=>new Sl((e,t)=>{this.websocket.once(Hf.CLOSED,()=>t(new SE(fE.WS_ABORT))),this.websocket.once(Hf.CONNECTED,e);});"connected"!==this.websocket.state&&await a(),s.clientRequest&&(s.clientRequest.workerToken=this.token);const c=new Sl((e,t)=>{const i=()=>{t(new SE(fE.WS_ABORT));};this.websocket.once(Hf.RECONNECTING,i),this.websocket.once(Hf.CLOSED,i),this.once("@".concat(o,"-").concat(this.spec.sid),t=>{e(t);});});n&&Pg.workerEvent(this.spec.sid,Tv(Tv({},n),{},{requestId:r,actionType:"request",payload:JSON.stringify(t.clientRequest),serverCode:0,code:0}));const d=Date.now();this.websocket.sendMessage(s);let u=null;try{u=await c;}catch(n){if("closed"===this.websocket.state)throw n;return await a(),await this.request(e,t,i)}return n&&Pg.workerEvent(this.spec.sid,Tv(Tv({},n),{},{requestId:r,actionType:"response",payload:JSON.stringify(u.serverResponse),serverCode:u.code,success:200===u.code,responseTime:Date.now()-d})),200!==u.code&&this.handleResponseError(u),u}tryNextAddress(){this.reconnectMode="tryNext",this.websocket.reconnect("tryNext");}close(){const e="4.18.2"===bE?"0.0.1":bE;this.reqId+=1,"connected"===this.websocket.state?(this.websocket.sendMessage({command:"request",appId:this.spec.appId,cname:this.spec.cname,uid:this.spec.uid.toString(),sdkVersion:e,sid:this.spec.sid,seq:this.reqId,ts:Math.floor(Date.now()/1e3),requestId:this.reqId,clientRequest:{command:"DestroyWorker"}}),this.websocket.close(!1,!0)):this.websocket.close(!1),this.pingpongTimer&&(window.clearInterval(this.pingpongTimer),this.pingpongTimer=void 0);}handleResponseError(e){switch(e.code){case eS.LIVE_STREAM_RESPONSE_ALREADY_EXISTS_STREAM:return void OE.warning("live stream response already exists stream");case eS.LIVE_STREAM_RESPONSE_TRANSCODING_PARAMETER_ERROR:case eS.LIVE_STREAM_RESPONSE_BAD_STREAM:case eS.LIVE_STREAM_RESPONSE_WM_PARAMETER_ERROR:return new SE(fE.LIVE_STREAMING_INVALID_ARGUMENT,"",{code:e.code}).throw();case eS.LIVE_STREAM_RESPONSE_WM_WORKER_NOT_EXIST:if("UnpublishStream"===e.serverResponse.command||"UninjectStream"===e.serverResponse.command)return;throw new SE(fE.LIVE_STREAMING_INTERNAL_SERVER_ERROR,"live stream response wm worker not exist",{retry:!0});case eS.LIVE_STREAM_RESPONSE_NOT_AUTHORIZED:return new SE(fE.LIVE_STREAMING_PUBLISH_STREAM_NOT_AUTHORIZED,"",{code:e.code}).throw();case eS.LIVE_STREAM_RESPONSE_FAILED_LOAD_IMAGE:{const t=new SE(fE.LIVE_STREAMING_WARN_FAILED_LOAD_IMAGE);return this.emit(Zf.WARNING,t,e.serverResponse.url)}case eS.LIVE_STREAM_RESPONSE_REQUEST_TOO_OFTEN:{const t=new SE(fE.LIVE_STREAMING_WARN_FREQUENT_REQUEST);return this.emit(Zf.WARNING,t,e.serverResponse.url)}case eS.LIVE_STREAM_RESPONSE_NOT_FOUND_PUBLISH:throw new SE(fE.LIVE_STREAMING_INTERNAL_SERVER_ERROR,"live stream response wm worker not exist",{retry:!0});case eS.LIVE_STREAM_RESPONSE_NOT_SUPPORTED:return new SE(fE.LIVE_STREAMING_TRANSCODING_NOT_SUPPORTED,"",{code:e.code}).throw();case eS.LIVE_STREAM_RESPONSE_MAX_STREAM_NUM:{const t=new SE(fE.LIVE_STREAMING_WARN_STREAM_NUM_REACH_LIMIT);return this.emit(Zf.WARNING,t,e.serverResponse.url)}case eS.LIVE_STREAM_RESPONSE_INTERNAL_SERVER_ERROR:return new SE(fE.LIVE_STREAMING_INTERNAL_SERVER_ERROR,"",{code:e.code}).throw();case eS.LIVE_STREAM_RESPONSE_RESOURCE_LIMIT:throw new SE(fE.LIVE_STREAMING_INTERNAL_SERVER_ERROR,"live stream resource limit",{retry:!0,changeAddress:!0});case eS.LIVE_STREAM_RESPONSE_WORKER_LOST:case eS.LIVE_STREAM_RESPONSE_WORKER_QUIT:if("UnpublishStream"===e.serverResponse.command||"UninjectStream"===e.serverResponse.command)return;throw new SE(fE.LIVE_STREAMING_INTERNAL_SERVER_ERROR,"error fail send message",{retry:!0,changeAddress:!0});case eS.ERROR_FAIL_SEND_MESSAGE:if("UnpublishStream"===e.serverResponse.command||"UninjectStream"===e.serverResponse.command)return;if("UpdateTranscoding"===e.serverResponse.command||"ControlStream"===e.serverResponse.command)return new SE(fE.LIVE_STREAMING_INTERNAL_SERVER_ERROR,"error fail send message",{code:e.code}).throw();throw new SE(fE.LIVE_STREAMING_INTERNAL_SERVER_ERROR,"error fail send message",{retry:!0,changeAddress:!0});case eS.PUBLISH_STREAM_STATUS_ERROR_PUBLISH_BROKEN:case eS.PUBLISH_STREAM_STATUS_ERROR_RTMP_CONNECT:case eS.PUBLISH_STREAM_STATUS_ERROR_RTMP_HANDSHAKE:case eS.PUBLISH_STREAM_STATUS_ERROR_RTMP_PUBLISH:return new SE(fE.LIVE_STREAMING_CDN_ERROR,"",{code:e.code}).throw()}}startPingPong(){this.pingpongTimer&&window.clearInterval(this.pingpongTimer),this.pingpongTimer=window.setInterval(()=>{"connected"===this.websocket.state&&this.request("ping",{}).catch(eC);},6e3);}}function Rv(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n);}return i}function Iv(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?Rv(Object(i),!0).forEach((function(t){_p(e,t,i[t]);})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):Rv(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t));}));}return e}class Cv extends EE{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:TE,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:TE;super(),_p(this,"onLiveStreamWarning",void 0),_p(this,"onLiveStreamError",void 0),_p(this,"onInjectStatusChange",void 0),_p(this,"spec",void 0),_p(this,"retryTimeout",1e4),_p(this,"connection",void 0),_p(this,"httpRetryConfig",void 0),_p(this,"wsRetryConfig",void 0),_p(this,"streamingTasks",new Map),_p(this,"isStartingStreamingTask",!1),_p(this,"taskMutex",new Ug("live-streaming")),_p(this,"cancelToken",pE.CancelToken.source()),_p(this,"transcodingConfig",void 0),_p(this,"injectConfig",Iv({},Qf)),_p(this,"injectLoopTimes",0),_p(this,"uapResponse",void 0),_p(this,"lastTaskId",1),_p(this,"statusError",new Map),this.spec=e,this.httpRetryConfig=i,this.wsRetryConfig=t;}async setTranscodingConfig(e){const t=Iv(Iv({},zf),e);66!==t.videoCodecProfile&&77!==t.videoCodecProfile&&100!==t.videoCodecProfile&&(OE.debug("[".concat(this.spec.clientId,"] set transcoding config, fix video codec profile: ").concat(t.videoCodecProfile," -> 100")),t.videoCodecProfile=100),t.transcodingUsers||(t.transcodingUsers=t.userConfigs),t.transcodingUsers&&(t.transcodingUsers=t.transcodingUsers.map(e=>Iv(Iv(Iv({},qf),e),{},{zOrder:e.zOrder?e.zOrder+1:1}))),function(e){$m(e.width)||qm(e.width,"config.width",0,1e4),$m(e.height)||qm(e.height,"config.height",0,1e4),$m(e.videoBitrate)||qm(e.videoBitrate,"config.videoBitrate",1,1e6),$m(e.videoFrameRate)||qm(e.videoFrameRate,"config.videoFrameRate"),$m(e.lowLatency)||Km(e.lowLatency,"config.lowLatency"),$m(e.audioSampleRate)||Ym(e.audioSampleRate,"config.audioSampleRate",[32e3,44100,48e3]),$m(e.audioBitrate)||qm(e.audioBitrate,"config.audioBitrate",1,128),$m(e.audioChannels)||Ym(e.audioChannels,"config.audioChannels",[1,2,3,4,5]),$m(e.videoGop)||qm(e.videoGop,"config.videoGop"),$m(e.videoCodecProfile)||Ym(e.videoCodecProfile,"config.videoCodecProfile",[66,77,100]),$m(e.userCount)||qm(e.userCount,"config.userCount",0,17),$m(e.backgroundColor)||qm(e.backgroundColor,"config.backgroundColor",0,16777215),$m(e.userConfigExtraInfo)||Xm(e.userConfigExtraInfo,"config.userConfigExtraInfo",0,4096,!1),e.transcodingUsers&&!$m(e.transcodingUsers)&&(zm(e.transcodingUsers,"config.transcodingUsers"),e.transcodingUsers.forEach((e,t)=>{Zm(e.uid),$m(e.x)||qm(e.x,"transcodingUser[".concat(t,"].x"),0,1e4),$m(e.y)||qm(e.y,"transcodingUser[".concat(t,"].y"),0,1e4),$m(e.width)||qm(e.width,"transcodingUser[".concat(t,"].width"),0,1e4),$m(e.height)||qm(e.height,"transcodingUser[".concat(t,"].height"),0,1e4),$m(e.zOrder)||qm(e.zOrder-1,"transcodingUser[".concat(t,"].zOrder"),0,100),$m(e.alpha)||qm(e.alpha,"transcodingUser[".concat(t,"].alpha"),0,1,!1);})),$m(e.watermark)||Xf(e.watermark,"watermark"),$m(e.backgroundImage)||Xf(e.backgroundImage,"backgroundImage"),e.images&&!$m(e.images)&&(zm(e.images,"config.images"),e.images.forEach((e,t)=>{Xf(e,"images[".concat(t,"]"));}));}(t);const i=[];t.images&&i.push(...t.images.map(e=>Iv(Iv(Iv({},Jf),e),{},{zOrder:255}))),t.backgroundImage&&(i.push(Iv(Iv(Iv({},Jf),t.backgroundImage),{},{zOrder:0})),delete t.backgroundImage),t.watermark&&(i.push(Iv(Iv(Iv({},Jf),t.watermark),{},{zOrder:255})),delete t.watermark),t.images=i,t.transcodingUsers&&(t.userConfigs=t.transcodingUsers.map(e=>Iv({},e)),t.userCount=t.transcodingUsers.length,delete t.transcodingUsers);const n=(t.userConfigs||[]).map(e=>"number"==typeof e.uid?Sl.resolve(e.uid):dv(e.uid,this.spec,this.cancelToken.token,this.httpRetryConfig));if((await Sl.all(n)).forEach((e,i)=>{t.userConfigs&&t.userConfigs[i]&&(t.userConfigs[i].uid=e);}),this.transcodingConfig=t,this.connection)try{var r;const e=await this.connection.request("request",{clientRequest:{command:"UpdateTranscoding",transcodingConfig:this.transcodingConfig}},!1,{command:"UpdateTranscoding",workerType:1,requestByUser:!0,tid:Array.from(IR(r=this.streamingTasks).call(r)).map(e=>e.taskId).join("#")});OE.debug("[".concat(this.spec.clientId,"] update live transcoding config success, code: ").concat(e.code,", config:"),JSON.stringify(this.transcodingConfig));}catch(e){if(!e.data||!e.data.retry)throw e;e.data.changeAddress&&this.connection.tryNextAddress(),this.streamingTasks.forEach(t=>{OE.warning("[".concat(this.spec.clientId,"] live streaming receive error"),e.toString(),"try to republish",t.url),this.startLiveStreamingTask(t.url,t.mode,e).then(()=>{OE.debug("[".concat(this.spec.clientId,"] live streaming republish ").concat(t.url," success"));}).catch(e=>{OE.error("[".concat(this.spec.clientId,"] live streaming republish failed"),t.url,e.toString()),this.onLiveStreamError&&this.onLiveStreamError(t.url,e);});});}}setInjectStreamConfig(e,t){this.injectConfig=Object.assign({},this.injectConfig,e),this.injectLoopTimes=t;}async startLiveStreamingTask(e,t,i){var n;if(Array.from(IR(n=this.streamingTasks).call(n)).find(e=>e.mode===Kf.INJECT)&&t===Kf.INJECT)return new SE(fE.LIVE_STREAMING_TASK_CONFLICT,"inject stream over limit").throw();if(!this.transcodingConfig&&t===Kf.TRANSCODE)throw new SE(fE.INVALID_OPERATION,"[LiveStreaming] no transcoding config found, can not start transcoding streaming task");let r={command:"PublishStream",ts:Date.now(),url:e,uid:this.spec.uid.toString(),autoDestroyTime:100,acceptImageTimeout:!0};OE.debug("[".concat(this.spec.clientId,"] start live streaming ").concat(e,", mode: ").concat(t));const o=await this.taskMutex.lock();if(!this.connection&&i)return void o();if(this.streamingTasks.get(e)&&!i)return o(),new SE(fE.LIVE_STREAMING_TASK_CONFLICT).throw();try{this.connection||(this.connection=await this.connect(t));}catch(e){throw o(),e}switch(t){case Kf.TRANSCODE:r.transcodingConfig=Iv({},this.transcodingConfig);break;case Kf.RAW:break;case Kf.INJECT:r={cname:this.spec.cname,command:"InjectStream",sid:this.spec.sid,transcodingConfig:this.injectConfig,ts:Date.now(),url:e,loopTimes:this.injectLoopTimes};}this.uapResponse&&this.uapResponse.vid&&(r.vid=this.uapResponse.vid),this.isStartingStreamingTask=!0;const s=this.lastTaskId++;try{const n=new Sl((t,n)=>{zI(this.retryTimeout).then(()=>{if(i)return n(i);const t=this.statusError.get(e);return t?(this.statusError.delete(e),n(t)):void 0});}),a=await Sl.race([this.connection.request("request",{clientRequest:r},!0,{url:e,command:"PublishStream",workerType:t===Kf.TRANSCODE?1:2,requestByUser:!i,tid:s.toString()}),n]);this.isStartingStreamingTask=!1,OE.debug("[".concat(this.spec.clientId,"] live streaming started, code: ").concat(a.code)),this.streamingTasks.set(e,{clientRequest:r,mode:t,url:e,taskId:s}),o();}catch(n){if(o(),this.isStartingStreamingTask=!1,!n.data||!n.data.retry||i)throw n;return n.data.changeAddress?(this.connection.tryNextAddress(),await this.startLiveStreamingTask(e,t,n)):await this.startLiveStreamingTask(e,t,n)}}stopLiveStreamingTask(e){return new Sl((t,i)=>{const n=this.streamingTasks.get(e);if(!n||!this.connection)return new SE(fE.UNEXPECTED_ERROR,"can not find streaming task to stop").throw();const r=n.mode;n.abortTask=()=>{OE.debug("[".concat(this.spec.clientId,"] stop live streaming success(worker exception)")),this.streamingTasks.delete(e),t();},this.connection.request("request",{clientRequest:{command:r===Kf.INJECT?"UninjectStream":"UnpublishStream",url:n.url}},!1,{url:e,command:"UnPublishStream",workerType:r===Kf.TRANSCODE?1:2,requestByUser:!0,tid:(this.lastTaskId++).toString()}).then(i=>{OE.debug("[".concat(this.spec.clientId,"] stop live streaming success, code: ").concat(i.code)),this.streamingTasks.delete(e),0===this.streamingTasks.size&&r!==Kf.INJECT&&(this.connection&&this.connection.close(),this.connection=void 0),t(),r===Kf.INJECT&&this.onInjectStatusChange&&this.onInjectStatusChange(Yf.INJECT_STREAM_STATUS_STOP_SUCCESS,this.spec.uid,e);}).catch(i);})}async controlInjectStream(e,t,i,n){const r=this.streamingTasks.get(e);if(!r||!this.connection||r.mode!==Kf.INJECT)throw new SE(fE.INVALID_OPERATION,"can not find inject stream task to control");return (await this.connection.request("request",{clientRequest:{command:"ControlStream",url:e,control:t,audioVolume:i,position:n}})).serverResponse}resetAllTask(){var e;const t=Array.from(IR(e=this.streamingTasks).call(e));this.terminate();for(const e of t)this.startLiveStreamingTask(e.url,e.mode).catch(t=>{this.onLiveStreamError&&this.onLiveStreamError(e.url,t);});}terminate(){this.cancelToken&&this.cancelToken.cancel(),this.streamingTasks=new Map,this.isStartingStreamingTask=!1,this.statusError=new Map,this.cancelToken=pE.CancelToken.source(),this.uapResponse=void 0,this.connection&&this.connection.close(),this.connection=void 0;}async connect(e){if(this.connection)throw new SE(fE.UNEXPECTED_ERROR,"live streaming connection has already connected");const t=await nC(this,$f.REQUEST_WORKER_MANAGER_LIST,e);return this.uapResponse=t,this.connection=new gv(t.workerToken,this.spec,this.wsRetryConfig,e),this.connection.on(Zf.WARNING,(e,t)=>this.onLiveStreamWarning&&this.onLiveStreamWarning(t,e)),this.connection.on(Zf.PUBLISH_STREAM_STATUS,e=>this.handlePublishStreamServer(e)),this.connection.on(Zf.INJECT_STREAM_STATUS,e=>this.handleInjectStreamServerStatus(e)),this.connection.on(Zf.REQUEST_NEW_ADDRESS,(t,i)=>{if(!this.connection)return i(new SE(fE.UNEXPECTED_ERROR,"can not get new live streaming address list"));nC(this,$f.REQUEST_WORKER_MANAGER_LIST,e).then(e=>{this.uapResponse=e,t(e.addressList);}).catch(i);}),await this.connection.init(t.addressList),this.connection}handlePublishStreamServer(e){const t=e.serverStatus&&e.serverStatus.url||"empty_url",i=this.streamingTasks.get(t),n=e.reason;switch(e.code){case eS.PUBLISH_STREAM_STATUS_ERROR_PUBLISH_BROKEN:case eS.PUBLISH_STREAM_STATUS_ERROR_RTMP_CONNECT:case eS.PUBLISH_STREAM_STATUS_ERROR_RTMP_HANDSHAKE:case eS.PUBLISH_STREAM_STATUS_ERROR_RTMP_PUBLISH:{const n=new SE(fE.LIVE_STREAMING_CDN_ERROR,"",{code:e.code});if(i)return OE.error(n.toString()),this.onLiveStreamError&&this.onLiveStreamError(t,n);if(!this.isStartingStreamingTask)return;this.statusError.set(t,n);}case eS.LIVE_STREAM_RESPONSE_FAILED_LOAD_IMAGE:{const e=new SE(fE.LIVE_STREAMING_WARN_FAILED_LOAD_IMAGE,n);return this.onLiveStreamWarning&&this.onLiveStreamWarning(t,e)}case eS.LIVE_STREAM_RESPONSE_WORKER_LOST:case eS.LIVE_STREAM_RESPONSE_WORKER_QUIT:{var r;if(!this.connection)return;this.connection.tryNextAddress();const t=Array.from(IR(r=this.streamingTasks).call(r));for(const i of t)i.abortTask?i.abortTask():(OE.warning("[".concat(this.spec.clientId,"] publish stream status code"),e.code,"try to republish",i.url),this.startLiveStreamingTask(i.url,i.mode,new SE(fE.LIVE_STREAMING_INTERNAL_SERVER_ERROR,"",{code:e.code})).then(()=>{OE.debug("[".concat(this.spec.clientId,"] republish live stream success"),i.url);}).catch(e=>{OE.error(e.toString()),this.onLiveStreamError&&this.onLiveStreamError(i.url,e);}));return}}}handleInjectStreamServerStatus(e){const t=Number(e.uid),i=e.serverStatus&&e.serverStatus.url;switch(e.code){case 200:return void(this.onInjectStatusChange&&this.onInjectStatusChange(Yf.INJECT_STREAM_STATUS_START_SUCCESS,t,i));case 451:return this.onInjectStatusChange&&this.onInjectStatusChange(Yf.INJECT_STREAM_STATUS_START_ALREADY_EXISTS,t,i),void this.streamingTasks.delete(i);case 453:return this.onInjectStatusChange&&this.onInjectStatusChange(Yf.INJECT_STREAM_STATUS_START_UNAUTHORIZED,t,i),void this.streamingTasks.delete(i);case 470:return this.onInjectStatusChange&&this.onInjectStatusChange(Yf.INJECT_STREAM_STATUS_BROKEN,t,i),void this.streamingTasks.delete(i);case 499:return this.onInjectStatusChange&&this.onInjectStatusChange(Yf.INJECT_STREAM_STATUS_START_TIMEOUT,t,i),void this.streamingTasks.delete(i);default:return void OE.debug("inject stream server status",e)}}hasUrl(e){return this.streamingTasks.has(e)}}class vv{constructor(){_p(this,"destChannelMediaInfos",new Map),_p(this,"srcChannelMediaInfo",void 0);}setSrcChannelInfo(e){TS(e),this.srcChannelMediaInfo=e;}addDestChannelInfo(e){TS(e),this.destChannelMediaInfos.set(e.channelName,e);}removeDestChannelInfo(e){Qm(e),this.destChannelMediaInfos.delete(e);}getSrcChannelMediaInfo(){return this.srcChannelMediaInfo}getDestChannelMediaInfo(){return this.destChannelMediaInfos}}function yv(e){if(!(e instanceof vv)){return new SE(fE.INVALID_PARAMS,"Config should be instance of [ChannelMediaRelayConfiguration]").throw()}const t=e.getSrcChannelMediaInfo(),i=e.getDestChannelMediaInfo();if(!t){return new SE(fE.INVALID_PARAMS,"srcChannelMediaInfo should not be empty").throw()}if(0===i.size){return new SE(fE.INVALID_PARAMS,"destChannelMediaInfo should not be empty").throw()}}class Av extends EE{constructor(e,t,i){super(),_p(this,"ws",void 0),_p(this,"requestId",1),_p(this,"heartBeatTimer",void 0),_p(this,"joinInfo",void 0),_p(this,"clientId",void 0),_p(this,"onOpen",()=>{this.emit("open"),this.startHeartBeatCheck();}),_p(this,"onClose",e=>{this.emit("close"),this.dispose();}),_p(this,"onMessage",e=>{const t=JSON.parse(e.data);if(!t||"serverResponse"!==t.command||!t.requestId)return t&&"serverStatus"===t.command&&t.serverStatus&&t.serverStatus.command?(this.emit("status",t.serverStatus),void this.emit(t.serverStatus.command,t.serverStatus)):void 0;this.emit("req_".concat(t.requestId),t);}),this.joinInfo=e,this.clientId=t,this.ws=new vC("cross-channel-".concat(this.clientId),i),this.ws.on(Hf.RECONNECTING,()=>{this.ws.reconnectMode="retry",this.emit("reconnecting");}),this.ws.on(Hf.CONNECTED,this.onOpen),this.ws.on(Hf.ON_MESSAGE,this.onMessage),this.ws.on(Hf.CLOSED,this.onClose);}isConnect(){return "connected"===this.ws.state}sendMessage(e){const t=this.requestId++;return e.requestId=t,e.seq=t,this.ws.sendMessage(e),t}waitStatus(e){return new Sl((t,i)=>{const n=window.setTimeout(()=>{i(new SE(fE.TIMEOUT,"wait status timeout, status: ".concat(e)));},5e3);this.once(e,r=>{window.clearTimeout(n),r.state&&0!==r.state?i(new SE(fE.CROSS_CHANNEL_WAIT_STATUS_ERROR,"wait status error, status: ".concat(e))):t(void 0);}),this.once("dispose",()=>{window.clearTimeout(n),i(new SE(fE.WS_ABORT));});})}async request(e){if("closed"===this.ws.state)throw new SE(fE.WS_DISCONNECT);const t=()=>new Sl((e,t)=>{this.ws.once(Hf.CLOSED,()=>t(new SE(fE.WS_ABORT))),this.ws.once(Hf.CONNECTED,e);});"connected"!==this.ws.state&&await t();const i=this.sendMessage(e),n=new Sl((e,t)=>{const n=()=>{t(new SE(fE.WS_ABORT));};this.ws.once(Hf.RECONNECTING,n),this.ws.once(Hf.CLOSED,n),this.once("req_".concat(i),e),zI(3e3).then(()=>{this.removeAllListeners("req_".concat(i)),this.ws.off(Hf.RECONNECTING,n),this.ws.off(Hf.CLOSED,n),t(new SE(fE.TIMEOUT,"cross channel ws request timeout"));});}),r=await n;if(!r||200!==r.code)throw new SE(fE.CROSS_CHANNEL_SERVER_ERROR_RESPONSE,"response: ".concat(JSON.stringify(r)));return r}async connect(e){this.ws.removeAllListeners(Hf.REQUEST_NEW_URLS),this.ws.on(Hf.REQUEST_NEW_URLS,t=>{t(e);}),await this.ws.init(e);}dispose(){this.clearHeartBeatCheck(),this.emit("dispose"),this.removeAllListeners(),this.ws.close();}sendPing(e){const t=this.requestId++;return e.requestId=t,this.ws.sendMessage(e),t}startHeartBeatCheck(){this.heartBeatTimer&&window.clearInterval(this.heartBeatTimer),this.heartBeatTimer=window.setInterval(()=>{this.sendPing({command:"ping",appId:this.joinInfo.appId,cname:this.joinInfo.cname,uid:this.joinInfo.uid.toString(),sid:this.joinInfo.sid,ts:+new Date,requestId:0});},3e3);}clearHeartBeatCheck(){window.clearInterval(this.heartBeatTimer),this.heartBeatTimer=void 0;}}class Ov extends EE{set state(e){e!==this._state&&(e!==rS.RELAY_STATE_FAILURE&&(this.errorCode=oS.RELAY_OK),this.emit("state",e,this.errorCode),this._state=e);}get state(){return this._state}constructor(e,t,i,n,r){super(),_p(this,"joinInfo",void 0),_p(this,"sid",void 0),_p(this,"clientId",void 0),_p(this,"cancelToken",pE.CancelToken.source()),_p(this,"workerToken",void 0),_p(this,"requestId",0),_p(this,"signal",void 0),_p(this,"prevChannelMediaConfig",void 0),_p(this,"httpRetryConfig",void 0),_p(this,"_resolution",void 0),_p(this,"_state",rS.RELAY_STATE_IDLE),_p(this,"errorCode",oS.RELAY_OK),_p(this,"onStatus",e=>{OE.debug("[".concat(this.clientId,"] ChannelMediaStatus: ").concat(JSON.stringify(e))),e&&e.command&&("onAudioPacketReceived"===e.command&&this.emit("event",nS.PACKET_RECEIVED_AUDIO_FROM_SRC),"onVideoPacketReceived"===e.command&&this.emit("event",nS.PACKET_RECEIVED_VIDEO_FROM_SRC),"onSrcTokenPrivilegeDidExpire"===e.command&&(this.errorCode=oS.SRC_TOKEN_EXPIRED,this.state=rS.RELAY_STATE_FAILURE),"onDestTokenPrivilegeDidExpire"===e.command&&(this.errorCode=oS.DEST_TOKEN_EXPIRED,this.state=rS.RELAY_STATE_FAILURE));}),_p(this,"onReconnect",async()=>{OE.debug("[".concat(this.clientId,"] ChannelMediaSocket disconnect, reconnecting")),this.emit("event",nS.NETWORK_DISCONNECTED),this.state=rS.RELAY_STATE_IDLE,this.prevChannelMediaConfig&&this.sendStartRelayMessage(this.prevChannelMediaConfig).catch(e=>{this.state!==rS.RELAY_STATE_IDLE&&(OE.error("auto restart channel media relay failed",e.toString()),this.errorCode=oS.SERVER_CONNECTION_LOST,this.state=rS.RELAY_STATE_FAILURE);});}),this.joinInfo=e,this.clientId=t,this.sid=$I(),this.signal=new Av(this.joinInfo,this.clientId,i),this.httpRetryConfig=n,this._resolution=r;}async startChannelMediaRelay(e){if(this.state!==rS.RELAY_STATE_IDLE)throw new SE(fE.INVALID_OPERATION);this.state=rS.RELAY_STATE_CONNECTING,await this.connect(),OE.debug("[".concat(this.clientId,"] startChannelMediaRelay: connect success"));try{await this.sendStartRelayMessage(e);}catch(e){if(e.data&&e.data.serverResponse&&"SetSourceChannel"===e.data.serverResponse.command)throw new SE(fE.CROSS_CHANNEL_FAILED_JOIN_SRC);if(e.data&&e.data.serverResponse&&"SetDestChannelStatus"===e.serverResponse.command)throw new SE(fE.CROSS_CHANNEL_FAILED_JOIN_DEST);if(e.data&&e.data.serverResponse&&"StartPacketTransfer"===e.serverResponse.command)throw new SE(fE.CROSS_CHANNEL_FAILED_PACKET_SENT_TO_DEST);throw e}this.prevChannelMediaConfig=e;}async updateChannelMediaRelay(e){if(this.state!==rS.RELAY_STATE_RUNNING)throw new SE(fE.INVALID_OPERATION);await this.sendUpdateMessage(e),this.prevChannelMediaConfig=e;}async setVideoProfile(e){if(this._resolution=e,this.state!==rS.RELAY_STATE_RUNNING)throw new SE(fE.INVALID_OPERATION);const t=this.genMessage(iS.SetVideoProfile);await this.signal.request(t),OE.debug("[".concat(this.clientId,"] startChannelMediaRelay: setVideoProfile success"));}async stopChannelMediaRelay(){await this.sendStopRelayMessage(),OE.debug("[".concat(this.clientId,"] stopChannelMediaRelay: send stop message success")),this.state=rS.RELAY_STATE_IDLE,this.dispose();}dispose(){OE.debug("[".concat(this.clientId,"] disposeChannelMediaRelay")),this.cancelToken.cancel(),this.cancelToken=pE.CancelToken.source(),this.state=rS.RELAY_STATE_IDLE,this.emit("dispose"),this.signal.dispose(),this.prevChannelMediaConfig=void 0;}async connect(){const e=await pv(this.joinInfo,this.cancelToken.token,this.httpRetryConfig);this.workerToken=e.workerToken,await this.signal.connect(e.addressList),this.emit("event",nS.NETWORK_CONNECTED),this.signal.on("status",this.onStatus),this.signal.on("reconnecting",this.onReconnect);}async sendStartRelayMessage(e){const t=this.genMessage(iS.StopPacketTransfer);await this.signal.request(t),await this.signal.waitStatus("Normal Quit"),OE.debug("[".concat(this.clientId,"] startChannelMediaRelay: StopPacketTransfer success"));const i=this.genMessage(iS.SetSdkProfile,e);await this.signal.request(i),OE.debug("[".concat(this.clientId,"] startChannelMediaRelay: SetSdkProfile success"));const n=this.genMessage(iS.SetSourceChannel,e);await this.signal.request(n),await this.signal.waitStatus("SetSourceChannelStatus"),this.emit("event",nS.PACKET_JOINED_SRC_CHANNEL),OE.debug("[".concat(this.clientId,"] startChannelMediaRelay: SetSourceChannel success"));const r=this.genMessage(iS.SetSourceUserId,e);await this.signal.request(r),OE.debug("[".concat(this.clientId,"] startChannelMediaRelay: SetSourceUserId success"));const o=this.genMessage(iS.SetDestChannel,e);await this.signal.request(o),await this.signal.waitStatus("SetDestChannelStatus"),this.emit("event",nS.PACKET_JOINED_DEST_CHANNEL),OE.debug("[".concat(this.clientId,"] startChannelMediaRelay: SetDestChannel success"));const s=this.genMessage(iS.StartPacketTransfer,e);await this.signal.request(s),this.emit("event",nS.PACKET_SENT_TO_DEST_CHANNEL),this.state=rS.RELAY_STATE_RUNNING,OE.debug("[".concat(this.clientId,"] startChannelMediaRelay: StartPacketTransfer success")),this.setVideoProfile(this._resolution);}async sendUpdateMessage(e){const t=this.genMessage(iS.UpdateDestChannel,e);await this.signal.request(t),this.emit("event",nS.PACKET_UPDATE_DEST_CHANNEL),OE.debug("[".concat(this.clientId,"] sendUpdateMessage: UpdateDestChannel success"));}async sendStopRelayMessage(){const e=this.genMessage(iS.StopPacketTransfer);await this.signal.request(e),OE.debug("[".concat(this.clientId,"] sendStopRelayMessage: StopPacketTransfer success"));}genMessage(e,t){const i=[],n=[],r=[];this.requestId+=1;const o={appId:this.joinInfo.appId,cname:this.joinInfo.cname,uid:this.joinInfo.uid.toString(),sdkVersion:bE,sid:this.sid,ts:Date.now(),requestId:this.requestId,seq:this.requestId,allocate:!0,clientRequest:{}};"4.18.2"===o.sdkVersion&&(o.sdkVersion="0.0.1");let s=null,a=null;switch(e){case iS.SetSdkProfile:return o.clientRequest={command:"SetSdkProfile",type:"multi_channel"},o;case iS.SetSourceChannel:if(a=t&&t.getSrcChannelMediaInfo(),!a)throw new SE(fE.UNEXPECTED_ERROR,"can not find source config");return o.clientRequest={command:"SetSourceChannel",uid:"0",channelName:a.channelName,token:a.token||this.joinInfo.appId},o;case iS.SetSourceUserId:if(a=t&&t.getSrcChannelMediaInfo(),!a)throw new SE(fE.UNEXPECTED_ERROR,"can not find source config");return o.clientRequest={command:"SetSourceUserId",uid:a.uid+""},o;case iS.SetDestChannel:if(s=t&&t.getDestChannelMediaInfo(),!s)throw new SE(fE.UNEXPECTED_ERROR,"can not find dest config");return s.forEach(e=>{i.push(e.channelName),n.push(e.uid+""),r.push(e.token||this.joinInfo.appId);}),o.clientRequest={command:"SetDestChannel",channelName:i,uid:n,token:r},o;case iS.StartPacketTransfer:return o.clientRequest={command:"StartPacketTransfer"},o;case iS.Reconnect:return o.clientRequest={command:"Reconnect"},o;case iS.StopPacketTransfer:return o.clientRequest={command:"StopPacketTransfer"},o;case iS.UpdateDestChannel:if(s=t&&t.getDestChannelMediaInfo(),!s)throw new SE(fE.UNEXPECTED_ERROR,"can not find dest config");return s.forEach(e=>{i.push(e.channelName),n.push(e.uid+""),r.push(e.token||this.joinInfo.appId);}),o.clientRequest={command:"UpdateDestChannel",channelName:i,uid:n,token:r},o;case iS.SetVideoProfile:o.clientRequest={command:"SetVideoProfile",width:this._resolution.width,height:this._resolution.height};}return o}}const Nv=e=>{const t=document.createElement("canvas");return t.width=2,t.height=2,new Sl((i,n)=>{t.toBlob(async e=>{if(t.remove(),e){const n=await bv(e);i({buffer:n,width:t.width,height:t.height});}else n(new SE(fE.CONVERTING_VIDEO_FRAME_TO_BLOB_FAILED));},e,1);})},bv=async e=>{const t=await e.arrayBuffer();return new Uint8Array(t)};function wv(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n);}return i}function Dv(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?wv(Object(i),!0).forEach((function(t){_p(e,t,i[t]);})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):wv(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t));}));}return e}class Pv{get videoElementStatus(){return this._videoElementStatus}set videoElementStatus(e){e!==this._videoElementStatus&&(OE.debug("[".concat(this.trackId,"] video-element-status change ").concat(this._videoElementStatus," => ").concat(e)),this._videoElementStatus=e);}constructor(e){_p(this,"trackId",void 0),_p(this,"config",void 0),_p(this,"onFirstVideoFrameDecoded",void 0),_p(this,"freezeTimeCounterList",[]),_p(this,"renderFreezeAccTime",0),_p(this,"isKeepLastFrame",!1),_p(this,"timeUpdatedCount",0),_p(this,"freezeTime",0),_p(this,"playbackTime",0),_p(this,"lastTimeUpdatedTime",0),_p(this,"autoplayFailed",!1),_p(this,"videoTrack",void 0),_p(this,"videoElement",void 0),_p(this,"cacheVideoElement",void 0),_p(this,"videoElementCheckInterval",void 0),_p(this,"_videoElementStatus",sf.NONE),_p(this,"isGettingVideoDimensions",!1),_p(this,"startGetVideoDimensions",()=>{const e=()=>{if(this.isGettingVideoDimensions=!0,this.videoElement.videoWidth*this.videoElement.videoHeight>4)return OE.debug("[".concat(this.trackId,"] current video dimensions:"),this.videoElement.videoWidth,this.videoElement.videoHeight),void(this.isGettingVideoDimensions=!1);setTimeout(e,500);};!this.isGettingVideoDimensions&&e();}),_p(this,"autoResumeAfterInterruption",()=>{this.videoTrack&&"live"===this.videoTrack.readyState&&"running"===Gg.curState&&(OE.debug("[track-".concat(this.trackId,"] video element paused, auto resume for ").concat(jh())),ep()?(this.videoElement.srcObject=null,this.videoElement.srcObject=new MediaStream([this.videoTrack]),this.videoElement.play()):(this.videoElement.pause(),this.videoElement.play()));}),_p(this,"handleVideoEvents",e=>{switch(e.type){case"play":case"playing":this.startGetVideoDimensions(),this.videoElementStatus=sf.PLAYING;break;case"loadeddata":if(this.onFirstVideoFrameDecoded&&this.onFirstVideoFrameDecoded(),this.cacheVideoElement){try{this.cacheVideoElement.srcObject=null,this.cacheVideoElement.remove();}catch(e){}this.cacheVideoElement=void 0;}break;case"canplay":this.videoElementStatus=sf.CANPLAY;break;case"stalled":this.videoElementStatus=sf.STALLED;break;case"suspend":this.videoElementStatus=sf.SUSPEND;break;case"pause":this.videoElementStatus=sf.PAUSED,Yh()||tp()||Hh()&&this.autoplayFailed||!this.videoTrack||"live"!==this.videoTrack.readyState||(OE.debug("[track-".concat(this.trackId,"] video element paused, auto resume")),this.videoElement.play());break;case"waiting":this.videoElementStatus=sf.WAITING;break;case"abort":this.videoElementStatus=sf.ABORT;break;case"ended":this.videoElementStatus=sf.ENDED;break;case"emptied":this.videoElementStatus=sf.EMPTIED;break;case"error":{this.videoElementStatus=sf.ERROR;const e=this.videoElement.error;e&&OE.error("[".concat(this.trackId,"] media error, code: ").concat(e.code,", message: ").concat(e.message));break}case"timeupdate":{const e=performance.now();if(this.timeUpdatedCount+=1,this.timeUpdatedCount<10)return void(this.lastTimeUpdatedTime=e);const t=e-this.lastTimeUpdatedTime,i=this.lastTimeUpdatedTime;if(this.lastTimeUpdatedTime=e,MI.lastVisibleTime<MI.lastHiddenTime||i<MI.lastHiddenTime||i<MI.lastVisibleTime)return;for(t>GE("VIDEO_FREEZE_DURATION")&&(this.freezeTime+=t),this.playbackTime+=t;this.playbackTime>=6e3;){this.playbackTime-=6e3;const e=Math.min(6e3,this.freezeTime);this.freezeTimeCounterList.push(e),this.freezeTime=Math.max(0,this.freezeTime-6e3);}break}}}),_p(this,"autoResumeAfterInterruptionOnIOS15_16",()=>{this.videoTrack&&"live"===this.videoTrack.readyState&&(OE.debug("[track-".concat(this.trackId,"] video element paused, auto resume for ").concat(jh())),ep()?(this.videoElement.srcObject=null,this.videoElement.srcObject=new MediaStream([this.videoTrack]),this.videoElement.play()):(this.videoElement.pause(),this.videoElement.play()));}),this.trackId=e.trackId,this.config=e,e.element instanceof HTMLVideoElement?this.videoElement=e.element:this.videoElement=document.createElement("video"),Gg.on(kg.IOS_INTERRUPTION_END,this.autoResumeAfterInterruption),Gg.on(kg.IOS_15_16_INTERRUPTION_END,this.autoResumeAfterInterruptionOnIOS15_16);}getVideoElement(){return this.videoElement}getContainerElement(){var e;return null!==(e=this.videoElement.parentElement)&&void 0!==e?e:void 0}updateConfig(e){this.config=e,this.trackId=e.trackId,e.element!==this.videoElement&&(this.destroy(),this.videoElement=e.element),this.videoTrack&&this.initVideoElement();}updateVideoTrack(e){this.videoTrack!==e&&(this.videoTrack=e,this.initVideoElement());}play(e){const t=this.videoElement.play();t&&t.catch&&t.catch(t=>{e&&Pg.autoplayFailed(e,"video",t.message,this.trackId),"NotAllowedError"===t.name?(OE.warning("detected video element autoplay failed",t),this.autoplayFailed=!0,this.handleAutoPlayFailed()):OE.warning("[".concat(this.trackId,"] play warning: "),t);});const i=xh();if(("Safari"===i.name&&15===Number(i.version)||Zh())&&t&&t.then&&t.catch){const e=()=>{this.config.mirror&&(this.videoElement.style.transform="rotateY(180deg)");};t.then(e).catch(e);}}getCurrentFrame(){const e=document.createElement("canvas");e.width=this.videoElement.videoWidth,e.height=this.videoElement.videoHeight;const t=e.getContext("2d");if(!t)return OE.error("create canvas context failed!"),new ImageData(2,2);t.drawImage(this.videoElement,0,0,e.width,e.height);const i=t.getImageData(0,0,e.width,e.height);return e.remove(),i}async getCurrentFrameToUint8Array(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;const i=document.createElement("canvas");i.width=this.videoElement.videoWidth,i.height=this.videoElement.videoHeight;const n=i.getContext("2d");return n?(n.drawImage(this.videoElement,0,0,i.width,i.height),new Sl((n,r)=>{i.toBlob(async e=>{if(i.remove(),e){const t=await bv(e);n({buffer:t,width:i.width,height:i.height});}else r(new SE(fE.CONVERTING_VIDEO_FRAME_TO_BLOB_FAILED));},e,t<0?.1:t>1?1:t);})):await Nv(e)}destroy(){Gg.off(kg.IOS_INTERRUPTION_END,this.autoResumeAfterInterruption),Gg.off(kg.IOS_15_16_INTERRUPTION_END,this.autoResumeAfterInterruptionOnIOS15_16),this.videoElement.srcObject=null,this.resetVideoElement(),this.freezeTimeCounterList=[];}initVideoElement(){if(this.videoElementStatus=sf.INIT,!this.videoElementCheckInterval&&(Lv.forEach(e=>{this.videoElement.addEventListener(e,this.handleVideoEvents);}),this.videoElementCheckInterval=window.setInterval(()=>{(function(e){return e!==document.body&&document.body.contains(e)})(this.videoElement)||(this.videoElementStatus=sf.DESTROYED);},1e3),GE("ENABLE_VIDEO_FRAME_CALLBACK"))){var e,t;let i;const n=(e,t)=>{if(this.videoElementStatus===sf.PLAYING){if(i){const e=t.presentationTime-i.presentationTime;e>GE("VIDEO_FREEZE_DURATION")&&MI.lastVisibleTime>=MI.lastHiddenTime&&i.timestamp>MI.lastVisibleTime&&i.timestamp>MI.lastHiddenTime&&(this.renderFreezeAccTime+=e);}i=Dv(Dv({},t),{},{timestamp:e});}var r,o;GE("ENABLE_VIDEO_FRAME_CALLBACK")&&(null===(r=(o=this.videoElement).requestVideoFrameCallback)||void 0===r||r.call(o,n));};null===(e=(t=this.videoElement).requestVideoFrameCallback)||void 0===e||e.call(t,n);}this.videoElement.controls=!1,this.videoElement.setAttribute("playsinline",""),op()&&(this.videoElement.poster="noposter");const i=xh();if("Safari"===i.name&&15===Number(i.version)||Zh()||!this.config.mirror||(this.videoElement.style.transform="rotateY(180deg)"),this.config.fit?this.videoElement.style.objectFit=this.config.fit:this.videoElement.style.objectFit="cover",this.videoElement.setAttribute("muted",""),this.videoElement.muted=!0,this.videoElement.srcObject&&this.videoElement.srcObject instanceof MediaStream){this.videoElement.srcObject.getVideoTracks()[0]!==this.videoTrack&&(this.videoElement.srcObject=this.videoTrack?new MediaStream([this.videoTrack]):null,Kh()&&this.videoElement.load());}else this.videoElement.srcObject=this.videoTrack?new MediaStream([this.videoTrack]):null,Kh()&&this.videoElement.load();const n=this.videoElement.play();void 0!==n&&n.catch(e=>{OE.debug("[".concat(this.trackId,"] playback interrupted"),e.toString());});}resetVideoElement(){Lv.forEach(e=>{this.videoElement&&this.videoElement.removeEventListener(e,this.handleVideoEvents);}),this.videoElementCheckInterval&&(window.clearInterval(this.videoElementCheckInterval),this.videoElementCheckInterval=void 0),this.videoElementStatus=sf.NONE;}handleAutoPlayFailed(){const e=t=>{t.preventDefault(),this.videoElement.play().then(()=>{OE.debug("[".concat(this.trackId,"] Video element for trackId:").concat(this.trackId," autoplay resumed."));}).catch(e=>{OE.error(e);}),this.autoplayFailed=!1,sp()?document.body.removeEventListener("click",e,!0):(document.body.removeEventListener("touchstart",e,!0),document.body.removeEventListener("mousedown",e,!0));};sp()?document.body.addEventListener("click",e,!0):(document.body.addEventListener("touchstart",e,!0),document.body.addEventListener("mousedown",e,!0)),yg();}}const Lv=["play","playing","loadeddata","canplay","pause","stalled","suspend","waiting","abort","emptied","ended","timeupdate","error"];class kv extends Pv{constructor(e){super(e),_p(this,"container",void 0),_p(this,"slot",void 0),this.slot=e.element,this.updateConfig(e);}updateConfig(e){this.config=e,this.trackId=e.trackId;const t=e.element;t!==this.slot&&(this.destroy(),this.slot=t),this.createElements();}updateVideoTrack(e){this.videoTrack!==e&&(this.videoTrack=e,this.createElements());}play(e){var t;null!==(t=this.container)&&void 0!==t&&t.contains(this.videoElement)&&super.play(e);}getCurrentFrame(){var e;return null!==(e=this.container)&&void 0!==e&&e.contains(this.videoElement)?super.getCurrentFrame():new ImageData(2,2)}async getCurrentFrameToUint8Array(e){var t;let i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return null!==(t=this.container)&&void 0!==t&&t.contains(this.videoElement)?await super.getCurrentFrameToUint8Array(e,i):await Nv(e)}destroy(){if(super.destroy(),this.videoElement.remove(),this.videoElement=document.createElement("video"),this.container){try{this.container.remove(),this.slot.removeChild(this.container);}catch(e){}this.container=void 0;}}createElements(){this.container||(this.container=document.createElement("div")),this.container.id="agora-video-player-".concat(this.trackId),this.container.style.width="100%",this.container.style.height="100%",this.container.style.position="relative",this.container.style.overflow="hidden",this.videoTrack?(this.container.style.backgroundColor="black",GE("KEEP_LAST_FRAME")&&this.isKeepLastFrame&&this.videoElement.paused&&this.resetVideoElement(),this.mountedVideoElement()):this.unmountedVideoElement(),this.slot.appendChild(this.container);}mountedVideoElement(){var e;!this.container||null!==(e=this.container)&&void 0!==e&&e.contains(this.videoElement)||this.container.appendChild(this.videoElement),super.initVideoElement(),this.videoElement.id="video_".concat(this.trackId),this.videoElement.className="agora_video_player",this.videoElement.style.width="100%",this.videoElement.style.height="100%",this.videoElement.style.position="absolute",this.videoElement.style.left="0",this.videoElement.style.top="0";}unmountedVideoElement(){var e;if(null!==(e=this.container)&&void 0!==e&&e.contains(this.videoElement)){super.resetVideoElement();try{this.container&&this.container.removeChild(this.videoElement);}catch(e){}this.videoElement=document.createElement("video");}}resetVideoElement(){var e;null!==(e=this.container)&&void 0!==e&&e.contains(this.videoElement)&&(super.resetVideoElement(),this.cacheVideoElement=this.videoElement,this.videoElement=document.createElement("video"));}getContainerElement(){return this.container}}function Mv(e){const t={};e.facingMode&&(t.facingMode=e.facingMode),e.cameraId&&(t.deviceId={exact:e.cameraId});const i=UE(e.encoderConfig);return t.width=i.width,t.height=i.height,!np()&&i.frameRate&&(t.frameRate=i.frameRate),xh().name===wh.EDGE&&"object"==typeof t.frameRate&&(t.frameRate.max=60),Kh()&&(t.frameRate={ideal:30,max:30}),t}function Uv(e){const t={};e.screenSourceType&&(t.mediaSource=e.screenSourceType),e.extensionId&&Wh()&&(t.extensionId=e.extensionId);const{displaySurface:i,selfBrowserSurface:n,surfaceSwitching:r,systemAudio:o}=e;(qh(107)||Jh(107)||Xh(93))&&(i&&(Ym(i,"displaySurface",["browser","window","monitor"]),t.displaySurface=i),n?(Ym(n,"selfBrowserSurface",["exclude","include"]),t.selfBrowserSurface=n):t.selfBrowserSurface="include",r&&(Ym(r,"surfaceSwitching",["exclude","include"]),t.surfaceSwitching=r)),(qh(105)||Jh(105)||Xh(91))&&o&&(Ym(o,"systemAudio",["exclude","include"]),t.systemAudio=o),e.electronScreenSourceId&&(t.sourceId=e.electronScreenSourceId);const s=e.encoderConfig?xE(e.encoderConfig):null;return t.mandatory={chromeMediaSource:"desktop",maxWidth:s?s.width:void 0,maxHeight:s?s.height:void 0},s&&(s.frameRate&&("number"==typeof s.frameRate?(t.mandatory.maxFrameRate=s.frameRate,t.mandatory.minFrameRate=s.frameRate):(t.mandatory.maxFrameRate=s.frameRate.max||s.frameRate.ideal||s.frameRate.exact||void 0,t.mandatory.minFrameRate=s.frameRate.min||s.frameRate.ideal||s.frameRate.exact||void 0),t.frameRate=s.frameRate),s.width&&(t.width=s.width),s.height&&(t.height=s.height)),t}function xv(e){const t={};if(np()||(void 0!==e.AGC&&(t.autoGainControl=e.AGC),void 0!==e.AEC&&(t.echoCancellation=e.AEC),void 0!==e.ANS&&(t.noiseSuppression=e.ANS,Wh()&&e.ANS&&(t.googHighpassFilter=e.ANS))),e.encoderConfig){const i=FE(e.encoderConfig);t.channelCount=i.stereo?2:1,t.sampleRate=i.sampleRate,t.sampleSize=i.sampleSize;}return e.microphoneId&&(t.deviceId={exact:e.microphoneId}),op()&&(t.sampleRate=void 0),t}var Vv,jv;!function(e){e.COVERED="COVERED",e.POSITION="POSITION",e.SIZE="SIZE",e.STYLE="STYLE";}(Vv||(Vv={})),function(e){e.UNMOUNTED="UNMOUNTED",e.INVALID_HTML_ELEMENT="INVALID_HTML_ELEMENT";}(jv||(jv={}));var Fv,Bv,Gv,Wv,Hv,Kv,Yv,qv,Jv,Xv,zv,Qv,Zv,$v,ey,ty,iy,ny,ry,oy,sy,ay,cy,dy,uy,ly,hy,py,_y,Ey,my,fy,Sy,Ty,gy=new class{constructor(){_p(this,"_clientSize",null),_p(this,"getClientWidth",()=>document.documentElement?document.documentElement.clientWidth:document.body.clientWidth),_p(this,"getClientHeight",()=>document.documentElement?document.documentElement.clientHeight:document.body.clientHeight),_p(this,"getStyle",e=>window.getComputedStyle(e,null)),_p(this,"checkCssVisibleProperty",e=>{let t=!0;const i=this.getStyle(e),{display:n,visibility:r,opacity:o,filter:s}=i;if(("none"===n||["hidden","collapse"].includes(r)||Number(o)<.1)&&(t=!1),!t)return !1;if(s){s.split(" ").filter(e=>{const t=e.split("(")[0];return ["brightness","blur","opacity"].includes(t)}).map(e=>{const[t,i]=e.split(/\(|\)/);return [t,Number(i.match(/^[0-9\.]+/))]}).forEach(e=>{const[i,n]=e;switch(i){case"brightness":(n<.1||n>3)&&(t=!1);break;case"blur":n>3&&(t=!1);break;case"opacity":n<.1&&(t=!1);}});}return t}),_p(this,"checkPropertyUpToAllParentNodes",(e,t)=>{let i=!0,n=!0;const r=e=>t(e);let o=e;for(;o&&n;){r(o)||(i=!1,n=!1),o=o.parentElement,o||(n=!1);}return i}),_p(this,"checkActualCssVisibleIncludeInherit",e=>this.checkPropertyUpToAllParentNodes(e,this.checkCssVisibleProperty)),_p(this,"getSizeAboutClient",e=>{const{width:t,height:i,left:n,right:r,top:o,bottom:s}=e.getBoundingClientRect(),a=this.getClientWidth(),c=this.getClientHeight();return {width:t,height:i,left:n,right:r,top:o,bottom:s,clientWidth:a,clientHeight:c,clientMin:Math.min(a,c)}}),_p(this,"checkActualSize",()=>{const{width:e,height:t,clientMin:i}=this._clientSize;return this.checkSizeIsVisible(e,t,i)}),_p(this,"elementFromPoint",(e,t)=>document.elementFromPoint?document.elementFromPoint(e,t):null),_p(this,"checkCoverForAPoint",(e,t,i)=>{const n=this.elementFromPoint(e,t);return null!==n&&n!==i}),_p(this,"getPointPositionList",()=>{const{width:e,height:t,left:i,top:n}=this._clientSize,r=e/6,o=t/6,s=[],a=10**6;for(let e=0;e<5;e++)for(let t=0;t<5;t++){const c=(i*a+(0===e?.1:4===e?(r*e*a-1e5)/a:r*e)*a)/a,d=(n*a+(0===t?.1:4===t?(o*t*a-1e5)/a:o*t)*a)/a;s.push({x:c,y:d});}return [...s]}),_p(this,"checkElementCover",e=>this.getPointPositionList().map(t=>this.checkCoverForAPoint(t.x,t.y,e)).filter(e=>!!e).length>6),_p(this,"checkSizeIsVisible",(e,t,i)=>(e>50||i/e<=10)&&(t>50||i/t<=10)),_p(this,"checkSizeOfPartInClient",()=>{const{left:e,right:t,top:i,bottom:n,clientHeight:r,clientWidth:o,clientMin:s}=this._clientSize;let a,c,d,u;if(e<0)a=0;else {if(!(e<o))return !1;a=e;}if(t<0)return !1;if(c=t<o?t:o,i<0)d=0;else {if(!(i<r))return !1;d=i;}if(n<0)return !1;u=n<r?n:r;const l=c-a,h=u-d;return this.checkSizeIsVisible(l,h,s)}),_p(this,"returnHiddenResult",e=>(this._clientSize=null,{visible:!1,reason:e})),_p(this,"checkOneElementVisible",e=>{if(e instanceof HTMLElement){if(this.checkElementIsMountedOnDom(e)){if(this.checkActualCssVisibleIncludeInherit(e)){if(this._clientSize=this.getSizeAboutClient(e),this.checkElementCover(e))return this.returnHiddenResult(Vv.COVERED);{const e=this.checkActualSize(),t=this.checkSizeOfPartInClient();return e&&!t?this.returnHiddenResult(Vv.POSITION):e?(this._clientSize=null,{visible:!0}):this.returnHiddenResult(Vv.SIZE)}}return this.returnHiddenResult(Vv.STYLE)}return this.returnHiddenResult(jv.UNMOUNTED)}return this.returnHiddenResult(jv.INVALID_HTML_ELEMENT)}),_p(this,"checkElementIsMountedOnDom",e=>this.checkPropertyUpToAllParentNodes(e,e=>"HTML"!==e.nodeName.toUpperCase()?null!==e.parentElement:!!document.documentElement));}};function Ry(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n);}return i}function Iy(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?Ry(Object(i),!0).forEach((function(t){_p(e,t,i[t]);})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):Ry(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t));}));}return e}let Cy=(Fv=Dg({argsMap:(e,t,i)=>[e.getTrackId(),"string"==typeof t?t:t instanceof HTMLVideoElement?"HTMLVideoElement":"HTMLElement",i]}),Bv=_R(),Gv=Dg({argsMap:e=>[e.getTrackId()]}),Wv=xg("LocalVideoTrack","_enabledMutex"),Hv=Dg({argsMap:(e,t)=>[e.getTrackId(),t]}),Kv=_R(),Yv=xg("LocalVideoTrack","_enabledMutex"),qv=Dg({argsMap:(e,t)=>[e.getTrackId(),t]}),Jv=_R(),Xv=Dg({argsMap:(e,t)=>[e.getTrackId(),t]}),zv=_R(),Qv=_R(),Zv=Dg({argsMap:(e,t,i)=>[e.getTrackId(),t,i]}),$v=_R(),ey=_R(),ty=_R(),iy=_R(),ny=_R(),ry=_R(),oy=_R(),sy=Dg({argsMap:(e,t)=>[e.getTrackId(),t.name]}),ay=Dg({argsMap:e=>[e.getTrackId()]}),cy=Dg({argsMap:e=>[e.getTrackId()]}),dy=Dg({argsMap:(e,t,i)=>[e.getTrackId(),t.label,i]}),ag((uy=class e extends Vg{get isPlaying(){return !(!this._player||this._player.videoElementStatus!==sf.PLAYING)}get processorContext(){return this._processorContext}set processorContext(e){this._processorContext=e;}get __className__(){return "LocalVideoTrack"}constructor(e,t,i,n,r,o){if(super(e,r),_p(this,"trackMediaType","video"),_p(this,"_player",void 0),_p(this,"_videoVisibleTimer",null),_p(this,"_previousVideoVisibleStatus",void 0),_p(this,"_clearPreviousVideoVisibleStatus",()=>this._previousVideoVisibleStatus=void 0),_p(this,"_encoderConfig",void 0),_p(this,"_scalabiltyMode",{numSpatialLayers:1,numTemporalLayers:1}),_p(this,"_optimizationMode",void 0),_p(this,"_videoHeight",void 0),_p(this,"_videoWidth",void 0),_p(this,"_forceBitrateLimit",void 0),_p(this,"_enabled",!0),_p(this,"processorDestination",void 0),_p(this,"_processorContext",void 0),Hh()){const{width:t,height:i}=e.getSettings();this._videoWidth=t,this._videoHeight=i;}else this.updateMediaStreamTrackResolution();this._encoderConfig=t,this._scalabiltyMode=i,this._optimizationMode=n,this._hints=o||[],-1===this._hints.indexOf(lS.SCREEN_TRACK)&&this.updateBitrateFromProfile(),t&&-1!==this._hints.indexOf(lS.CUSTOM_TRACK)&&this.setEncoderConfiguration(t),this.processorContext=new AR(this.getTrackId(),"local"),this.processorDestination=new yR(this.processorContext),this.bindProcessorDestinationEvents();}play(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if("string"==typeof e){const t=document.getElementById(e);t?e=t:(OE.warning("[".concat(this.getTrackId(),'] can not find "#').concat(e,'" element, use document.body')),e=document.body);}OE.debug("[".concat(this.getTrackId(),"] start video playback in ").concat(e instanceof HTMLVideoElement?"HTMLVideoElement":"HTMLElement"),JSON.stringify(t));const i=Iy(Iy(Iy({},this._getDefaultPlayerConfig()),t),{},{trackId:this.getTrackId(),element:e});this._player?this._player.updateConfig(i):(e instanceof HTMLVideoElement?this._player=new Pv(i):this._player=new kv(i),this._player.updateVideoTrack(this._mediaStreamTrack)),this._player.play(),this._videoVisibleTimer&&window.clearInterval(this._videoVisibleTimer),this._clearPreviousVideoVisibleStatus(),this._videoVisibleTimer=window.setInterval(()=>{try{const e=this.getVideoElementVisibleStatus();this.safeEmit(mS.VIDEO_ELEMENT_VISIBLE_STATUS,e);}catch(e){}},GE("CHECK_VIDEO_VISIBLE_INTERVAL"));}stop(){this._player&&(this._videoVisibleTimer&&(window.clearInterval(this._videoVisibleTimer),this._videoVisibleTimer=null),this._clearPreviousVideoVisibleStatus(),this._player.destroy(),this._player=void 0,OE.debug("[".concat(this.getTrackId(),"] stop video playback")));}async setEnabled(e,t){if(!t){if(e===this._enabled)return;this.stateCheck("enabled",e);}if(OE.info("[".concat(this.getTrackId(),"] start setEnabled"),e),!e){this._originMediaStreamTrack.enabled=!1;try{await rC(this,uS.NEED_DISABLE_TRACK,this);}catch(e){throw OE.error("[".concat(this.getTrackId(),"] setEnabled to false error"),e.toString()),e}return t||(this._enabled=!1),void OE.info("[".concat(this.getTrackId(),"] setEnabled to false success"))}this._originMediaStreamTrack.enabled=!0;try{await rC(this,uS.NEED_ENABLE_TRACK,this);}catch(e){throw OE.error("[".concat(this.getTrackId(),"] setEnabled to true error"),e.toString()),e}OE.info("[".concat(this.getTrackId(),"] setEnabled to true success")),t||(this._enabled=!0);}async setMuted(e){e!==this._muted&&(this.stateCheck("muted",e),this._muted=e,this._originMediaStreamTrack.enabled=!e,OE.debug("[".concat(this.getTrackId(),"] start set muted: ").concat(e)),e?await rC(this,uS.NEED_MUTE_TRACK,this):await rC(this,uS.NEED_UNMUTE_TRACK,this));}async setEncoderConfiguration(e,t){if(!this._enabled)throw new SE(fE.TRACK_IS_DISABLED,"can not set encoder configuration when track is disabled");if(e=UE(e),this._forceBitrateLimit&&(e.bitrateMax=this._forceBitrateLimit.max_bitrate?this._forceBitrateLimit.max_bitrate:e.bitrateMax,e.bitrateMin=this._forceBitrateLimit.min_bitrate?this._forceBitrateLimit.min_bitrate:e.bitrateMin),e.width||e.height||e.frameRate){const t=Mv({encoderConfig:e});(Hh()||Yh()||tp())&&(t.deviceId=void 0),OE.debug("[".concat(this.getTrackId(),"] setEncoderConfiguration applyConstraints"),JSON.stringify(e),JSON.stringify(t));try{await this._originMediaStreamTrack.applyConstraints(t),this.updateMediaStreamTrackResolution();}catch(e){const t=new SE(fE.UNEXPECTED_ERROR,e.toString());throw OE.error("[".concat(this.getTrackId(),"] applyConstraints error"),t.toString()),t}}this._encoderConfig=e,-1===this._hints.indexOf(lS.SCREEN_TRACK)&&this.updateBitrateFromProfile();try{await rC(this,uS.NEED_UPDATE_VIDEO_ENCODER,this);}catch(e){return e.throw()}}getStats(){hC(()=>{OE.warning("[deprecated] LocalVideoTrack.getStats will be removed in the future, use AgoraRTCClient.getLocalVideoStats instead");},"localVideoTrackGetStatsWarning");const e=oC(this,uS.GET_STATS);return e||Iy({},Ff)}async setBeautyEffect(e){OE.error("LocalVideoTrack.setBeautyEffect was deprecated, please migrate to agora-extension-beauty-effect");}getCurrentFrameData(){return this._player?this._player.getCurrentFrame():new ImageData(2,2)}async getCurrentFrameImage(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return this._player?this._player.getCurrentFrameToUint8Array(e,t):await Nv(e)}clone(t,i,n,r){const o=this._mediaStreamTrack.clone();return new e(o,t,i,n,r)}async setBitrateLimit(e){if(OE.debug("[".concat(this.getTrackId(),"] set bitrate limit, ").concat(JSON.stringify(e))),e){this._forceBitrateLimit=e,this._encoderConfig&&(this._encoderConfig.bitrateMax?this._encoderConfig.bitrateMax=this._encoderConfig.bitrateMax<e.max_bitrate?this._encoderConfig.bitrateMax:e.max_bitrate:this._encoderConfig.bitrateMax=e.max_bitrate,this._encoderConfig.bitrateMin,this._encoderConfig.bitrateMin=e.min_bitrate);try{await rC(this,uS.NEED_UPDATE_VIDEO_ENCODER,this);}catch(e){return e.throw()}}}async setOptimizationMode(e){if("motion"!==e&&"detail"!==e&&"balanced"!==e)return void OE.error(fE.INVALID_PARAMS,"optimization mode must be motion, detail or balanced");const t=this._optimizationMode;try{this._optimizationMode=e,await rC(this,uS.SET_OPTIMIZATION_MODE,this);}catch(e){throw this._optimizationMode=t,OE.error("[".concat(this.getTrackId(),"] set optimization mode failed"),e.toString()),e}OE.info("[".concat(this.getTrackId(),"] set optimization mode success (").concat(e,")"));}setScalabiltyMode(e){if(1===e.numSpatialLayers&&1!==e.numTemporalLayers)return OE.error(fE.INVALID_PARAMS,"scalability mode currently not supported, no SVC."),void(this._scalabiltyMode={numSpatialLayers:1,numTemporalLayers:1});this._scalabiltyMode=e,OE.info("[".concat(this.getTrackId(),"] set scalability mode success (").concat(e,")"));}updateMediaStreamTrackResolution(){tC(this._originMediaStreamTrack).then(e=>{let[t,i]=e;this._videoHeight=i,this._videoWidth=t;}).catch(eC);}_updatePlayerSource(){this._player&&this._player.updateVideoTrack(this._mediaStreamTrack);}_getDefaultPlayerConfig(){return {fit:"contain"}}updateBitrateFromProfile(){if(!this._encoderConfig)return;const{width:e,height:t,frameRate:i}=this.getMediaStreamTrackSettings();if(!e||!t||!i)return;const[n,r]=function(e,t,i){const n=GE("BITRATE_ADAPTER_TYPE");let r;const o=200*Math.pow(i/15,.6)*Math.pow(e*t/640/360,.75),s=o;if("STANDARD_BITRATE"===n)r=4*o;else {if("COMPATIABLE_BITRATE"!==n)return;r=2*o;}return [Math.floor(r),Math.floor(s)]}(e,t,i)||[void 0,void 0];this._encoderConfig.bitrateMin||this._encoderConfig.bitrateMax||(this._encoderConfig.bitrateMin=r,this._encoderConfig.bitrateMax=n,OE.debug("[".concat(this.getTrackId(),"] update bitrate from profile, [w: ").concat(e,", h: ").concat(t,", fps: ").concat(i,"] => [brMax: ").concat(n,", brMin: ").concat(r,"]")));}getVideoElementVisibleStatus(){try{var e,t;const i=null==this||null===(e=this._player)||void 0===e?void 0:e.getContainerElement(),n={track:this,element:null==this||null===(t=this._player)||void 0===t?void 0:t.getVideoElement(),slot:null==i?void 0:i.parentElement},{element:r,slot:o}=n;if(this.isPlaying&&r instanceof HTMLVideoElement&&o instanceof HTMLElement){const e=gy.checkOneElementVisible(r),t=Object.assign({},e);if(t.visible!==this._previousVideoVisibleStatus){this._previousVideoVisibleStatus=t.visible;const e=Pg.reportApiInvoke(null,{tag:Ef.TRACER,name:_f.LOCAL_VIDEO_TRACK_GET_VIDEO_VISIBLE,options:[this.getTrackId()]});t.visible?e.onSuccess("Video is visible"):e.onSuccess("Invisible because of ".concat(t.reason));}return t}return}catch(e){throw new SE(fE.GET_VIDEO_ELEMENT_VISIBLE_ERROR,e.message)}}async renewMediaStreamTrack(e){}pipe(e){if(this.processor===e)return e;if(e._source)throw new SE(fE.INVALID_OPERATION,"Processor ".concat(e.name," already piped, please call unpipe beforehand."));return this.unpipe(),this.processor=e,this.processor._source=this,e.updateInput({track:this._originMediaStreamTrack,context:this.processorContext}),e}unpipe(){if(!this.processor)return;const e=this.processor;this.processor._source=void 0,this.processor=void 0,e.reset();}close(){super.close(),this.unbindProcessorDestinationEvents(),this.unbindProcessorContextEvents(),this.unpipe(),this.processorDestination._source&&this.processorDestination._source.unpipe();}async replaceTrack(e,t){if(!(e instanceof MediaStreamTrack))throw new SE(fE.INVALID_PARAMS,"track should be an instance of MediaStreamTrack");if("video"!==e.kind)throw new SE(fE.INVALID_PARAMS,"track should be a video MediaStreamTrack");await this._updateOriginMediaStreamTrack(e,t,!0),this.updateMediaStreamTrackResolution();}bindProcessorDestinationEvents(){this.processorDestination.on(kS.ON_TRACK,async e=>{e?e!==this._mediaStreamTrack&&(this._mediaStreamTrack=e,this._updatePlayerSource(),await rC(this,uS.NEED_REPLACE_TRACK,this)):this._mediaStreamTrack!==this._originMediaStreamTrack&&(this._mediaStreamTrack=this._originMediaStreamTrack,this._updatePlayerSource(),await rC(this,uS.NEED_REPLACE_TRACK,this));});}unbindProcessorDestinationEvents(){this.processorDestination.removeAllListeners(kS.ON_TRACK);}unbindProcessorContextEvents(){this.processorContext.removeAllListeners(MS.REQUEST_UPDATE_CONSTRAINTS),this.processorContext.removeAllListeners(MS.REQUEST_CONSTRAINTS);}}).prototype,"play",[Fv,Bv],Object.getOwnPropertyDescriptor(uy.prototype,"play"),uy.prototype),ag(uy.prototype,"stop",[Gv],Object.getOwnPropertyDescriptor(uy.prototype,"stop"),uy.prototype),ag(uy.prototype,"setEnabled",[Wv,Hv,Kv],Object.getOwnPropertyDescriptor(uy.prototype,"setEnabled"),uy.prototype),ag(uy.prototype,"setMuted",[Yv,qv,Jv],Object.getOwnPropertyDescriptor(uy.prototype,"setMuted"),uy.prototype),ag(uy.prototype,"setEncoderConfiguration",[Xv,zv],Object.getOwnPropertyDescriptor(uy.prototype,"setEncoderConfiguration"),uy.prototype),ag(uy.prototype,"getStats",[Qv],Object.getOwnPropertyDescriptor(uy.prototype,"getStats"),uy.prototype),ag(uy.prototype,"setBeautyEffect",[Zv,$v],Object.getOwnPropertyDescriptor(uy.prototype,"setBeautyEffect"),uy.prototype),ag(uy.prototype,"getCurrentFrameData",[ey],Object.getOwnPropertyDescriptor(uy.prototype,"getCurrentFrameData"),uy.prototype),ag(uy.prototype,"getCurrentFrameImage",[ty],Object.getOwnPropertyDescriptor(uy.prototype,"getCurrentFrameImage"),uy.prototype),ag(uy.prototype,"setBitrateLimit",[iy],Object.getOwnPropertyDescriptor(uy.prototype,"setBitrateLimit"),uy.prototype),ag(uy.prototype,"setOptimizationMode",[ny],Object.getOwnPropertyDescriptor(uy.prototype,"setOptimizationMode"),uy.prototype),ag(uy.prototype,"setScalabiltyMode",[ry],Object.getOwnPropertyDescriptor(uy.prototype,"setScalabiltyMode"),uy.prototype),ag(uy.prototype,"updateMediaStreamTrackResolution",[oy],Object.getOwnPropertyDescriptor(uy.prototype,"updateMediaStreamTrackResolution"),uy.prototype),ag(uy.prototype,"pipe",[sy],Object.getOwnPropertyDescriptor(uy.prototype,"pipe"),uy.prototype),ag(uy.prototype,"unpipe",[ay],Object.getOwnPropertyDescriptor(uy.prototype,"unpipe"),uy.prototype),ag(uy.prototype,"close",[cy],Object.getOwnPropertyDescriptor(uy.prototype,"close"),uy.prototype),ag(uy.prototype,"replaceTrack",[dy],Object.getOwnPropertyDescriptor(uy.prototype,"replaceTrack"),uy.prototype),uy),vy=(ly=Dg({argsMap:(e,t)=>[e.getTrackId(),t]}),hy=_R(),py=xg("CameraVideoTrack","_enabledMutex"),_y=Dg({argsMap:(e,t)=>[e.getTrackId(),t]}),Ey=_R(),my=Dg({argsMap:(e,t)=>[e.getTrackId(),t]}),fy=_R(),Sy=Dg({argsMap:e=>[e.getTrackId()]}),ag((Ty=class extends Cy{get __className__(){return "CameraVideoTrack"}constructor(e,t,i,n,r,o){super(e,UE(t.encoderConfig),n,r,o),_p(this,"_config",void 0),_p(this,"_originalConstraints",void 0),_p(this,"_constraints",void 0),_p(this,"_enabled",!0),_p(this,"_deviceName","default"),_p(this,"tryResumeVideoForIOS15_16WeChat",async()=>{(Zh()||$h())&&!function(){const e=xh();if(e.os!==bh.IOS||!e.osVersion)return !1;const t=e.osVersion.split(".");return 15===Number(t[0])&&Number(t[1])>=2}()&&ip()&&this._enabled&&!this._isClosed&&(OE.debug("[".concat(this.getTrackId(),"] try capture camera media device for interrupted iOS 15 device on WeChat.")),await this.renewMediaStreamTrack());}),this._config=t,this._originalConstraints=i,this._constraints=i,this._deviceName=e.label,this._encoderConfig=UE(this._config.encoderConfig),Gg.on(kg.IOS_15_16_INTERRUPTION_END,this.tryResumeVideoForIOS15_16WeChat),Gg.on(kg.IOS_INTERRUPTION_END,this.tryResumeVideoForIOS15_16WeChat),this.bindProcessorContextEvents();}async setDevice(e){if(OE.info("[".concat(this.getTrackId(),"] set device to ").concat(e)),this._enabled)try{const t=await lR.getDeviceById(e),i={};i.video=Iy({},this._constraints),i.video.deviceId={exact:e},i.video.facingMode=void 0,this._originMediaStreamTrack.stop();let n=null;try{n=await aR(i,this.getTrackId());}catch(e){throw OE.error("[".concat(this.getTrackId(),"] setDevice failed"),e.toString()),n=await aR({video:this._constraints},this.getTrackId()),await this._updateOriginMediaStreamTrack(n.getVideoTracks()[0],!1),e}await this._updateOriginMediaStreamTrack(n.getVideoTracks()[0],!1),this.updateMediaStreamTrackResolution(),this._deviceName=t.label,this._config.cameraId=e,this._constraints.deviceId={exact:e};}catch(e){throw OE.error("[".concat(this.getTrackId(),"] setDevice error"),e.toString()),e}else try{const t=await lR.getDeviceById(e);this._deviceName=t.label,this._config.cameraId=e,this._constraints.deviceId={exact:e};}catch(e){throw OE.error("[".concat(this.getTrackId(),"] setDevice error"),e.toString()),e}OE.info("[".concat(this.getTrackId(),"] setDevice success"));}async setEnabled(e,t){if(!t){if(e===this._enabled)return;this.stateCheck("enabled",e);}if(OE.info("[".concat(this.getTrackId(),"] start setEnabled"),e),e){try{if(this.isExternalTrack)this._originMediaStreamTrack.enabled=!0;else {const e=await aR({video:this._constraints},this.getTrackId());await this._updateOriginMediaStreamTrack(e.getVideoTracks()[0],!1);}await rC(this,uS.NEED_ENABLE_TRACK,this);}catch(e){throw OE.error("[".concat(this.getTrackId(),"] setEnabled true error"),e.toString()),e}this.updateMediaStreamTrackResolution(),OE.info("[".concat(this.getTrackId(),"] setEnabled to true success")),t||(this._enabled=!0);}else {this.isExternalTrack?this._originMediaStreamTrack.enabled=!1:(this._originMediaStreamTrack.onended=null,this._originMediaStreamTrack.stop()),t||(this._enabled=!1);try{await rC(this,uS.NEED_DISABLE_TRACK,this);}catch(e){throw OE.error("[".concat(this.getTrackId(),"] setEnabled to false error"),e.toString()),e}OE.info("[".concat(this.getTrackId(),"] setEnabled to false success"));}}async setEncoderConfiguration(e,t){if(!this._enabled)throw new SE(fE.TRACK_IS_DISABLED,"can not set encoder configuration when track is disabled");e=UE(e),this._forceBitrateLimit&&(e.bitrateMax=this._forceBitrateLimit.max_bitrate?this._forceBitrateLimit.max_bitrate:e.bitrateMax,e.bitrateMin=this._forceBitrateLimit.min_bitrate?this._forceBitrateLimit.min_bitrate:e.bitrateMin);const i=uC(this._config);i.encoderConfig=e;const n=Mv(i);(Hh()||Yh()||tp())&&(n.deviceId=void 0),OE.debug("[".concat(this.getTrackId(),"] setEncoderConfiguration applyConstraints"),JSON.stringify(e),JSON.stringify(n));try{await this._originMediaStreamTrack.applyConstraints(n),this.updateMediaStreamTrackResolution();}catch(e){const t=new SE(fE.UNEXPECTED_ERROR,e.toString());throw OE.error("[".concat(this.getTrackId(),"] applyConstraints error"),t.toString()),t}this._config=i,this._constraints=n,this._originalConstraints=n,this._encoderConfig=e,-1===this._hints.indexOf(lS.SCREEN_TRACK)&&this.updateBitrateFromProfile();try{await rC(this,uS.NEED_UPDATE_VIDEO_ENCODER,this);}catch(e){return e.throw()}}_getDefaultPlayerConfig(){return {mirror:!0,fit:"cover"}}onTrackEnded(){if((Yh()||tp())&&this._enabled&&!this._isClosed&&Gg.duringInterruption){const e=async()=>{Gg.off(kg.IOS_INTERRUPTION_END,e),this._enabled&&!this._isClosed&&(OE.debug("[".concat(this.getTrackId(),"] try capture camera media device for interrupted iOS device.")),await this.setEnabled(!1),await this.setEnabled(!0));};Gg.on(kg.IOS_INTERRUPTION_END,e);}else OE.debug("[".concat(this.getTrackId(),"] track ended")),this.safeEmit(mS.TRACK_ENDED);}async renewMediaStreamTrack(e){const t=e||this._constraints,i=lR.searchDeviceIdByName(this._deviceName);if(i&&!t.deviceId&&(t.deviceId={exact:i}),this._enabled){const e=await aR({video:t},this.getTrackId());this._constraints=t,await this._updateOriginMediaStreamTrack(e.getVideoTracks()[0],!0),this.updateMediaStreamTrackResolution();}}close(){super.close(),Gg.off(kg.IOS_15_16_INTERRUPTION_END,this.tryResumeVideoForIOS15_16WeChat),Gg.off(kg.IOS_INTERRUPTION_END,this.tryResumeVideoForIOS15_16WeChat);}bindProcessorContextEvents(){this.processorContext.on(MS.REQUEST_UPDATE_CONSTRAINTS,async(e,t,i)=>{try{const i=Object.assign({},this._originalConstraints,...e);await this.renewMediaStreamTrack(i),t();}catch(e){i(e);}}),this.processorContext.on(MS.REQUEST_CONSTRAINTS,async e=>{e(this._originMediaStreamTrack.getSettings());});}}).prototype,"setDevice",[ly,hy],Object.getOwnPropertyDescriptor(Ty.prototype,"setDevice"),Ty.prototype),ag(Ty.prototype,"setEnabled",[py,_y,Ey],Object.getOwnPropertyDescriptor(Ty.prototype,"setEnabled"),Ty.prototype),ag(Ty.prototype,"setEncoderConfiguration",[my,fy],Object.getOwnPropertyDescriptor(Ty.prototype,"setEncoderConfiguration"),Ty.prototype),ag(Ty.prototype,"close",[Sy],Object.getOwnPropertyDescriptor(Ty.prototype,"close"),Ty.prototype),Ty);class yy{get hasVideo(){return this._video_enabled_&&!this._video_muted_&&this._video_added_}get hasAudio(){return this._audio_enabled_&&!this._audio_muted_&&this._audio_added_}get audioTrack(){if(this.hasAudio)return this._audioTrack}get videoTrack(){if(this.hasVideo)return this._videoTrack}constructor(e,t){_p(this,"uid",void 0),_p(this,"_uintid",void 0),_p(this,"_trust_in_room_",!0),_p(this,"_trust_audio_enabled_state_",!0),_p(this,"_trust_video_enabled_state_",!0),_p(this,"_trust_audio_mute_state_",!0),_p(this,"_trust_video_mute_state_",!0),_p(this,"_audio_muted_",!1),_p(this,"_video_muted_",!1),_p(this,"_audio_enabled_",!0),_p(this,"_video_enabled_",!0),_p(this,"_audio_added_",!1),_p(this,"_video_added_",!1),_p(this,"_trust_video_stream_added_state_",!0),_p(this,"_trust_audio_stream_added_state_",!0),_p(this,"_audioTrack",void 0),_p(this,"_videoTrack",void 0),_p(this,"_audioSSRC",void 0),_p(this,"_videoSSRC",void 0),_p(this,"_audioOrtc",void 0),_p(this,"_videoOrtc",void 0),_p(this,"_cname",void 0),_p(this,"_rtxSsrcId",void 0),this.uid=e,this._uintid=t;}}var Ay=fl,Oy=pd,Ny=Rd;Ii({target:"Promise",stat:!0},{try:function(e){var t=Oy.f(this),i=Ny(e);return (i.error?t.reject:t.resolve)(i.value),t.promise}});var by=Ay,wy=Ii,Dy=h,Py=i,Ly=QS,ky=q,My=je,Uy=bi,xy=im,Vy=oT,jy=FT,Fy=ae,By=rt("isConcatSpreadable"),Gy=9007199254740991,Wy="Maximum allowed index exceeded",Hy=Dy.TypeError,Ky=Fy>=51||!Py((function(){var e=[];return e[By]=!1,e.concat()[0]!==e})),Yy=jy("concat"),qy=function(e){if(!ky(e))return !1;var t=e[By];return void 0!==t?!!t:Ly(e)};wy({target:"Array",proto:!0,forced:!Ky||!Yy},{concat:function(e){var t,i,n,r,o,s=My(this),a=Vy(s,0),c=0;for(t=-1,n=arguments.length;t<n;t++)if(qy(o=-1===t?s:arguments[t])){if(c+(r=Uy(o))>Gy)throw Hy(Wy);for(i=0;i<r;i++,c++)i in o&&xy(a,c,o[i]);}else {if(c>=Gy)throw Hy(Wy);xy(a,c++,o);}return a.length=c,a}});var Jy={},Xy=k,zy=K,Qy=Pn.f,Zy=cm,$y="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[];Jy.f=function(e){return $y&&"Window"==Xy(e)?function(e){try{return Qy(e)}catch(e){return Zy($y)}}(e):Qy(zy(e))};var eA={},tA=rt;eA.f=tA;var iA=J,nA=Ge,rA=eA,oA=Ht.f,sA=function(e){var t=iA.Symbol||(iA.Symbol={});nA(t,e)||oA(t,e,{value:rA.f(e)});},aA=Ii,cA=h,dA=$,uA=f,lA=C,hA=d,pA=g,_A=ue,EA=i,mA=Ge,fA=QS,SA=S,TA=q,gA=u,RA=fe,IA=zt,CA=je,vA=K,yA=Et,AA=wo,OA=w,NA=Pr,bA=hr,wA=Pn,DA=Jy,PA=Zn,LA=T,kA=Ht,MA=dr,UA=v,xA=pc,VA=xs,jA=we.exports,FA=Gn,BA=qe,GA=rt,WA=eA,HA=sA,KA=ta,YA=bs,qA=pT.forEach,JA=pn("hidden"),XA="Symbol",zA=GA("toPrimitive"),QA=YA.set,ZA=YA.getterFor(XA),$A=Object.prototype,eO=cA.Symbol,tO=eO&&eO.prototype,iO=cA.TypeError,nO=cA.QObject,rO=dA("JSON","stringify"),oO=LA.f,sO=kA.f,aO=DA.f,cO=UA.f,dO=hA([].push),uO=jA("symbols"),lO=jA("op-symbols"),hO=jA("string-to-symbol-registry"),pO=jA("symbol-to-string-registry"),_O=jA("wks"),EO=!nO||!nO.prototype||!nO.prototype.findChild,mO=pA&&EA((function(){return 7!=NA(sO({},"a",{get:function(){return sO(this,"a",{value:7}).a}})).a}))?function(e,t,i){var n=oO($A,t);n&&delete $A[t],sO(e,t,i),n&&e!==$A&&sO($A,t,n);}:sO,fO=function(e,t){var i=uO[e]=NA(tO);return QA(i,{type:XA,tag:e,description:t}),pA||(i.description=t),i},SO=function(e,t,i){e===$A&&SO(lO,t,i),IA(e);var n=yA(t);return IA(i),mA(uO,n)?(i.enumerable?(mA(e,JA)&&e[JA][n]&&(e[JA][n]=!1),i=NA(i,{enumerable:OA(0,!1)})):(mA(e,JA)||sO(e,JA,OA(1,{})),e[JA][n]=!0),mO(e,n,i)):sO(e,n,i)},TO=function(e,t){IA(e);var i=vA(t),n=bA(i).concat(CO(i));return qA(n,(function(t){pA&&!lA(gO,i,t)||SO(e,t,i[t]);})),e},gO=function(e){var t=yA(e),i=lA(cO,this,t);return !(this===$A&&mA(uO,t)&&!mA(lO,t))&&(!(i||!mA(this,t)||!mA(uO,t)||mA(this,JA)&&this[JA][t])||i)},RO=function(e,t){var i=vA(e),n=yA(t);if(i!==$A||!mA(uO,n)||mA(lO,n)){var r=oO(i,n);return !r||!mA(uO,n)||mA(i,JA)&&i[JA][n]||(r.enumerable=!0),r}},IO=function(e){var t=aO(vA(e)),i=[];return qA(t,(function(e){mA(uO,e)||mA(FA,e)||dO(i,e);})),i},CO=function(e){var t=e===$A,i=aO(t?lO:vA(e)),n=[];return qA(i,(function(e){!mA(uO,e)||t&&!mA($A,e)||dO(n,uO[e]);})),n};(_A||(VA(tO=(eO=function(){if(gA(tO,this))throw iO("Symbol is not a constructor");var e=arguments.length&&void 0!==arguments[0]?AA(arguments[0]):void 0,t=BA(e),i=function(e){this===$A&&lA(i,lO,e),mA(this,JA)&&mA(this[JA],t)&&(this[JA][t]=!1),mO(this,t,OA(1,e));};return pA&&EO&&mO($A,t,{configurable:!0,set:i}),fO(t,e)}).prototype,"toString",(function(){return ZA(this).tag})),VA(eO,"withoutSetter",(function(e){return fO(BA(e),e)})),UA.f=gO,kA.f=SO,MA.f=TO,LA.f=RO,wA.f=DA.f=IO,PA.f=CO,WA.f=function(e){return fO(GA(e),e)},pA&&sO(tO,"description",{configurable:!0,get:function(){return ZA(this).description}})),aA({global:!0,wrap:!0,forced:!_A,sham:!_A},{Symbol:eO}),qA(bA(_O),(function(e){HA(e);})),aA({target:XA,stat:!0,forced:!_A},{for:function(e){var t=AA(e);if(mA(hO,t))return hO[t];var i=eO(t);return hO[t]=i,pO[i]=t,i},keyFor:function(e){if(!RA(e))throw iO(e+" is not a symbol");if(mA(pO,e))return pO[e]},useSetter:function(){EO=!0;},useSimple:function(){EO=!1;}}),aA({target:"Object",stat:!0,forced:!_A,sham:!pA},{create:function(e,t){return void 0===t?NA(e):TO(NA(e),t)},defineProperty:SO,defineProperties:TO,getOwnPropertyDescriptor:RO}),aA({target:"Object",stat:!0,forced:!_A},{getOwnPropertyNames:IO,getOwnPropertySymbols:CO}),aA({target:"Object",stat:!0,forced:EA((function(){PA.f(1);}))},{getOwnPropertySymbols:function(e){return PA.f(CA(e))}}),rO)&&aA({target:"JSON",stat:!0,forced:!_A||EA((function(){var e=eO();return "[null]"!=rO([e])||"{}"!=rO({a:e})||"{}"!=rO(Object(e))}))},{stringify:function(e,t,i){var n=xA(arguments),r=t;if((TA(t)||void 0!==e)&&!RA(e))return fA(t)||(t=function(e,t){if(SA(r)&&(t=lA(r,this,e,t)),!RA(t))return t}),n[1]=t,uA(rO,null,n)}});if(!tO[zA]){var vO=tO.valueOf;VA(tO,zA,(function(e){return lA(vO,this)}));}KA(eO,XA),FA[JA]=!0,sA("asyncIterator"),sA("hasInstance"),sA("isConcatSpreadable"),sA("iterator"),sA("match"),sA("matchAll"),sA("replace"),sA("search"),sA("species"),sA("split"),sA("toPrimitive"),sA("toStringTag"),sA("unscopables"),ta(h.JSON,"JSON",!0);var yO=J.Symbol;sA("asyncDispose"),sA("dispose"),sA("matcher"),sA("metadata"),sA("observable"),sA("patternMatch"),sA("replaceAll");var AO=yO,OO=eA.f("asyncIterator"),NO=OO;function bO(e){this.wrapped=e;}function wO(e){var t,i;function n(t,i){try{var o=e[t](i),s=o.value,a=s instanceof bO;by.resolve(a?s.wrapped:s).then((function(e){a?n("return"===t?"return":"next",e):r(o.done?"return":"normal",e);}),(function(e){n("throw",e);}));}catch(e){r("throw",e);}}function r(e,r){switch(e){case"return":t.resolve({value:r,done:!0});break;case"throw":t.reject(r);break;default:t.resolve({value:r,done:!1});}(t=t.next)?n(t.key,t.arg):i=null;}this._invoke=function(e,r){return new by((function(o,s){var a={key:e,arg:r,resolve:o,reject:s,next:null};i?i=i.next=a:(t=i=a,n(e,r));}))},"function"!=typeof e.return&&(this.return=void 0);}function DO(e){return function(){return new wO(e.apply(this,arguments))}}function PO(e){return new bO(e)}wO.prototype["function"==typeof AO&&NO||"@@asyncIterator"]=function(){return this},wO.prototype.next=function(e){return this._invoke("next",e)},wO.prototype.throw=function(e){return this._invoke("throw",e)},wO.prototype.return=function(e){return this._invoke("return",e)};var LO=eA.f("iterator");function kO(e,t){var i={},n=!1;function r(i,r){return n=!0,r=new by((function(t){t(e[i](r));})),{done:!1,value:t(r)}}return i[void 0!==AO&&LO||"@@iterator"]=function(){return this},i.next=function(e){return n?(n=!1,e):r("next",e)},"function"==typeof e.throw&&(i.throw=function(e){if(n)throw n=!1,e;return r("throw",e)}),"function"==typeof e.return&&(i.return=function(e){return n?(n=!1,e):r("return",e)}),i}var MO=OO,UO={exports:{}};function xO(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n);}return i}function VO(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?xO(Object(i),!0).forEach((function(t){_p(e,t,i[t]);})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):xO(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t));}));}return e}function jO(e,t,i,n,r,o,s){let a=[],c=[],d=[],u=[],l=!1,h=!1;if(UO.exports.parse(e).mediaDescriptions.forEach(e=>{s&&s!==e.attributes.direction||("video"!==e.media.mediaType||l||(c=e.attributes.payloads,u=e.attributes.extmaps,l=!0),"audio"!==e.media.mediaType||h||(a=e.attributes.payloads,d=e.attributes.extmaps,h=!0));}),!u||0===c.length)throw new Error("Cannot get video capabilities from SDP.");if(!d||0===a.length)throw new Error("Cannot get audio capabilities from SDP.");return c.forEach(e=>{var t;null!==(t=e.rtpMap)&&void 0!==t&&t.clockRate&&(e.rtpMap.clockRate=parseInt(e.rtpMap.clockRate));}),a.forEach(e=>{var t;null!==(t=e.rtpMap)&&void 0!==t&&t.clockRate&&(e.rtpMap.clockRate=parseInt(e.rtpMap.clockRate));}),t&&(a=a.filter(e=>{var t;return "rtx"!==(null===(t=e.rtpMap)||void 0===t?void 0:t.encodingName.toLowerCase())}),c=c.filter(e=>{var t;return "rtx"!==(null===(t=e.rtpMap)||void 0===t?void 0:t.encodingName.toLowerCase())})),i&&(c=c.filter(e=>{var t;return !/(red)|(ulpfec)|(flexfec)/i.test((null===(t=e.rtpMap)||void 0===t?void 0:t.encodingName)||"")})),n&&(a=a.filter(e=>{var t;return !/(red)|(ulpfec)|(flexfec)/i.test((null===(t=e.rtpMap)||void 0===t?void 0:t.encodingName)||"")})),r&&(null==r?void 0:r.length)>0&&(a=a.filter(e=>{var t;return r.includes((null===(t=e.rtpMap)||void 0===t?void 0:t.encodingName.toLowerCase())||"")})),o&&(null==o?void 0:o.length)>0&&(c=c.filter(e=>{var t;return o.includes((null===(t=e.rtpMap)||void 0===t?void 0:t.encodingName.toLowerCase())||"")})),{audioCodecs:a,videoCodecs:c,audioExtensions:d,videoExtensions:u}}function FO(e){const t=UO.exports.parse(e);let i,n;for(const e of t.mediaDescriptions){if(!i){const t=e.attributes.iceUfrag,n=e.attributes.icePwd;if(!t||!n)throw new Error("Cannot get iceUfrag or icePwd from SDP.");i={iceUfrag:t,icePwd:n};}if(!n){const t=e.attributes.fingerprints;t.length>0&&(n={fingerprints:t});}}if(!n&&t.attributes.fingerprints.length>0&&(n={fingerprints:t.attributes.fingerprints}),!n||!i)throw new Error("Cannot get iceParameters or dtlsParameters from SDP.");return {iceParameters:i,dtlsParameters:n}}function BO(e,t){const i=[],n=e.attributes.ssrcGroups.filter(e=>"FID"===e.semantic),r=e.attributes.ssrcGroups.find(e=>"SIM"===e.semantic),o=e.attributes.ssrcs;if(r)r.ssrcIds.forEach(e=>{var r;const o=null===(r=n.find(t=>t.ssrcIds[0]===e))||void 0===r?void 0:r.ssrcIds[1];i.push({ssrcId:e,rtx:t?o:void 0});});else if(n.length>0){const e=n[0].ssrcIds[0],r=n[0].ssrcIds[1];i.push({ssrcId:e,rtx:t?r:void 0});}else {if(0===o.length)throw new Error("No ssrcs found on local media description.");i.push({ssrcId:o[0].ssrcId});}return i}function GO(e,t){const{cname:i}=e;let n;t&&t.ip&&"number"==typeof t.port?(n=[{foundation:"udpcandidate",componentId:"1",transport:"udp",priority:"2103266323",connectionAddress:t.ip,port:t.port.toString(),type:"host",extension:{}}],OE.debug("Using remote candidate from AP ".concat(t.ip,":").concat(t.port)),t.ip6&&(n.push({foundation:"udpcandidate",componentId:"1",transport:"udp",priority:"2103266323",connectionAddress:t.ip6,port:t.port.toString(),type:"host",extension:{}}),OE.debug("Using IPV6 remote candidate from AP ".concat(t.ip6,":").concat(t.port)))):n=e.iceParameters.candidates.map(e=>({foundation:e.foundation,componentId:"1",transport:e.protocol,priority:e.priority.toString(),connectionAddress:e.ip,port:e.port.toString(),type:e.type,extension:{}}));const r={fingerprints:e.dtlsParameters.fingerprints.map(e=>({hashFunction:e.algorithm,fingerprint:e.fingerprint}))},o={iceUfrag:e.iceParameters.iceUfrag,icePwd:e.iceParameters.icePwd};let s;switch(e.dtlsParameters.role){case"server":s="passive";break;case"client":s="active";break;case"auto":s="actpass";}return {dtlsParameters:r,iceParameters:o,candidates:n,rtpCapabilities:ZO(e.rtpCapabilities),setup:s,cname:i}}function WO(e,t,i){const n=[],r=[];return e.forEach(e=>{let{ssrcId:o,rtx:s}=e;const a=ZI(8,"track-"),c={ssrcId:o,attributes:VO({label:a,mslabel:i=i||ZI(10,""),msid:"".concat(i," ").concat(a)},t&&{cname:t})};if(n.push(c),void 0!==s){const e={ssrcId:s,attributes:VO({label:a,mslabel:i,msid:"".concat(i," ").concat(a)},t&&{cname:t})};n.push(e),r.push({semantic:"FID",ssrcIds:[o,s]});}}),e.length>1&&r.push({semantic:"SIM",ssrcIds:e.map(e=>{let{ssrcId:t}=e;return t})}),{ssrcs:n,ssrcGroups:r}}function HO(e,t){t instanceof yI&&e.attributes.payloads.forEach(e=>{var i;const n=null===(i=e.rtpMap)||void 0===i?void 0:i.encodingName.toLowerCase();if(!n||-1===["opus","pcmu","pcma","g722"].indexOf(n))return;e.fmtp||(e.fmtp={parameters:{}}),e.fmtp.parameters.minptime="10",e.fmtp.parameters.useinbandfec="1";const r=t._encoderConfig;r&&"pcmu"!==n&&"pcma"!==n&&"g722"!==n&&(r.bitrate&&!Kh()&&(e.fmtp.parameters.maxaveragebitrate="".concat(Math.floor(1e3*r.bitrate))),r.sampleRate&&(e.fmtp.parameters.maxplaybackrate="".concat(r.sampleRate),e.fmtp.parameters["sprop-maxcapturerate"]="".concat(r.sampleRate)),r.stereo&&(e.fmtp.parameters.stereo="1",e.fmtp.parameters["sprop-stereo"]="1"));});}function KO(e){const t=e.attributes.unrecognized.findIndex(e=>"x-google-flag"===e.attField&&"conference"===e.attValue);-1!==t&&e.attributes.unrecognized.splice(t,1);}function YO(e,t){if(!(t instanceof Cy&&t._encoderConfig&&-1===t._hints.indexOf(lS.SCREEN_TRACK)))return;const i=t._encoderConfig;JS().supportMinBitrate&&i.bitrateMin&&e.attributes.payloads.forEach(e=>{var t;["h264","h265","vp8","vp9","av1"].includes((null===(t=e.rtpMap)||void 0===t?void 0:t.encodingName.toLowerCase())||"")&&(e.fmtp||(e.fmtp={parameters:{}}),e.fmtp.parameters["x-google-min-bitrate"]="".concat(i.bitrateMin));}),JS().supportMinBitrate&&!t._hints.includes(lS.LOW_STREAM)&&i.bitrateMax&&e.attributes.payloads.forEach(e=>{var t;["h264","h265","vp8","vp9","av1"].includes((null===(t=e.rtpMap)||void 0===t?void 0:t.encodingName.toLowerCase())||"")&&(e.fmtp||(e.fmtp={parameters:{}}),e.fmtp.parameters["x-google-start-bitrate"]="".concat(GE("X_GOOGLE_START_BITRATE")||Math.floor(i.bitrateMax)));});}function qO(e){if("video"!==e.media.mediaType)return;const t=xh();if(t.name!==wh.SAFARI&&t.os!==bh.IOS)return;const i=e.attributes.extmaps.findIndex(e=>/video-orientation/g.test(e.extensionName));-1!==i&&e.attributes.extmaps.splice(i,1);}function JO(e,t,i){if(!t)return;let n,r;if("video"===e.media.mediaType?(n=i.videoExtensions,r=i.videoCodecs):(n=i.audioExtensions,r=i.audioCodecs),!0===t.twcc){const t=n.find(e=>"http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01"===e.extensionName);if(t){e.attributes.extmaps.find(e=>"http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01"===e.extensionName)||e.attributes.extmaps.push({entry:t.entry,extensionName:"http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01"});(function(e,t){return t.filter(t=>!!e.find(e=>e.payloadType===t.payloadType&&!!e.rtcpFeedbacks.find(e=>"transport-cc"===e.type)))})(r,e.attributes.payloads).forEach(e=>{e.rtcpFeedbacks.find(e=>"transport-cc"===e.type)||e.rtcpFeedbacks.push({type:"transport-cc"});});}}else if(!1===t.twcc){const t=e.attributes.extmaps.findIndex(e=>"http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01"===e.extensionName);-1!==t&&e.attributes.extmaps.splice(t,1),e.attributes.payloads.forEach(e=>{const t=e.rtcpFeedbacks.findIndex(e=>"transport-cc"===e.type);-1!==t&&e.rtcpFeedbacks.splice(t,1);});}if(!0===t.remb){const t=n.find(e=>"http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time"===e.extensionName);if(t){e.attributes.extmaps.find(e=>"http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time"===e.extensionName)||e.attributes.extmaps.push({entry:t.entry,extensionName:"http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time"});(function(e,t){return t.filter(t=>!!e.find(e=>e.payloadType===t.payloadType&&!!e.rtcpFeedbacks.find(e=>"goog-remb"===e.type)))})(r,e.attributes.payloads).forEach(e=>{e.rtcpFeedbacks.find(e=>"goog-remb"===e.type)||e.rtcpFeedbacks.push({type:"goog-remb"});});}}else if(!1===t.remb){const t=e.attributes.extmaps.findIndex(e=>"http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time"===e.extensionName);-1!==t&&e.attributes.extmaps.splice(t,1),e.attributes.payloads.forEach(e=>{const t=e.rtcpFeedbacks.findIndex(e=>"goog-remb"===e.type);-1!==t&&e.rtcpFeedbacks.splice(t,1);});}}function XO(e,t,i){if(Kh())return;if("video"!==e.media.mediaType)return;if(!(t instanceof Cy))return;if("vp9"!==i&&"vp8"!==i)return;if("vp8"===i&&!GE("SIMULCAST"))return;if(void 0===t._scalabiltyMode||t._scalabiltyMode.numSpatialLayers<=1)return;const n="vp8"===i?2:t._scalabiltyMode.numSpatialLayers,r=e.attributes.ssrcs[0],o=e.attributes.ssrcGroups.find(e=>"FID"===e.semantic&&e.ssrcIds[0]===r.ssrcId),s={semantic:"SIM",ssrcIds:[r.ssrcId]};for(let t=1;t<n;t++)e.attributes.ssrcs.push({ssrcId:r.ssrcId+t,attributes:uC(r.attributes)}),s.ssrcIds.push(r.ssrcId+t),o&&(e.attributes.ssrcs.push({ssrcId:o.ssrcIds[1]+t,attributes:uC(r.attributes)}),e.attributes.ssrcGroups.push({semantic:"FID",ssrcIds:[r.ssrcId+t,o.ssrcIds[1]+t]}));e.attributes.ssrcGroups.unshift(s);}async function zO(e,t,i,n,r){const o=new RTCPeerConnection;o.addTransceiver("video",{direction:"sendonly"}),o.addTransceiver("audio",{direction:"sendonly"}),o.addTransceiver("video",{direction:"recvonly"}),o.addTransceiver("audio",{direction:"recvonly"});const s=(await o.createOffer()).sdp,a=jO(s,e,t,i,n,r,"sendonly"),c=jO(s,e,t,i,n,r,"recvonly"),d={audioCodecs:[],audioExtensions:[],videoCodecs:[],videoExtensions:[]},u={audioCodecs:[],audioExtensions:[],videoCodecs:[],videoExtensions:[]},l={audioCodecs:[],audioExtensions:[],videoCodecs:[],videoExtensions:[]};if(QO(a,c,"videoExtensions",d,u,l),QO(a,c,"videoCodecs",d,u,l),QO(a,c,"audioExtensions",d,u,l),QO(a,c,"audioCodecs",d,u,l),GE("RAISE_H264_BASELINE_PRIORITY")){const e=l.videoCodecs.findIndex(e=>{var t,i;return "h264"===(null===(t=e.rtpMap)||void 0===t?void 0:t.encodingName.toLocaleLowerCase())&&"42001f"===(null===(i=e.fmtp)||void 0===i?void 0:i.parameters["profile-level-id"])});if(-1!==e){const t=l.videoCodecs.findIndex(e=>{var t;return "h264"===(null===(t=e.rtpMap)||void 0===t?void 0:t.encodingName.toLocaleLowerCase())});if(t<e){OE.debug("raising H264 baseline profile priority");const i=l.videoCodecs[e];l.videoCodecs.splice(e,1),l.videoCodecs.splice(t,0,i);}-1!==t&&(u.videoCodecs=u.videoCodecs.filter(e=>{var t,i;return !("h264"===(null===(t=e.rtpMap)||void 0===t?void 0:t.encodingName.toLocaleLowerCase())&&"42001f"!==(null===(i=e.fmtp)||void 0===i?void 0:i.parameters["profile-level-id"]))})),-1!==t&&GE("FILTER_SEND_H264_BASELINE")&&(d.videoCodecs=d.videoCodecs.filter(e=>{var t,i;return !("h264"===(null===(t=e.rtpMap)||void 0===t?void 0:t.encodingName.toLocaleLowerCase())&&"42001f"!==(null===(i=e.fmtp)||void 0===i?void 0:i.parameters["profile-level-id"]))}));}}try{o.close();}catch(e){}return {send:d,recv:u,sendrecv:l}}function QO(e,t,i,n,r,o){if("videoExtensions"===i||"audioExtensions"===i){const s=[];return e[i].forEach(e=>{t[i].some((t,i)=>{if(e.entry===t.entry&&e.extensionName===t.extensionName)return s.push(i),!0})?o[i].push(e):n[i].push(e);}),void t[i].forEach((e,t)=>{-1===s.indexOf(t)&&r[i].push(e);})}if("videoCodecs"===i||"audioCodecs"===i){const s=[];return e[i].forEach(e=>{t[i].some((t,i)=>{if(e.payloadType===t.payloadType&&JSON.stringify(e)===JSON.stringify(t))return s.push(i),!0})?o[i].push(e):n[i].push(e);}),void t[i].forEach((e,t)=>{-1===s.indexOf(t)&&r[i].push(e);})}}function ZO(e){const{send:t,recv:i,sendrecv:n}=e;if(!n){if(!t||!i)throw new Error("cannot merge rtp capabilities because one of send or recv is empty!");return {send:t,recv:i}}let r,o;return t?(r={audioCodecs:[],audioExtensions:[],videoCodecs:[],videoExtensions:[]},r.audioCodecs=[...t.audioCodecs,...n.audioCodecs],r.videoCodecs=[...t.videoCodecs,...n.videoCodecs],r.audioExtensions=[...t.audioExtensions,...n.audioExtensions],r.videoExtensions=[...t.videoExtensions,...n.videoExtensions]):r=n,i?(o={audioCodecs:[],audioExtensions:[],videoCodecs:[],videoExtensions:[]},o.audioCodecs=[...i.audioCodecs,...n.audioCodecs],o.videoCodecs=[...i.videoCodecs,...n.videoCodecs],o.audioExtensions=[...i.audioExtensions,...n.audioExtensions],o.videoExtensions=[...i.videoExtensions,...n.videoExtensions]):o=n,{send:r,recv:o}}function $O(e){if("audio"!==e.media.mediaType)return;e.attributes.payloads.filter(e=>{var t;return "opus"===(null===(t=e.rtpMap)||void 0===t?void 0:t.encodingName.toLowerCase())}).forEach(e=>{e.fmtp||(e.fmtp={parameters:{}}),e.fmtp.parameters.stereo="1",e.fmtp.parameters["sprop-stereo"]="1";});}function eN(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n);}return i}function tN(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?eN(Object(i),!0).forEach((function(t){_p(e,t,i[t]);})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):eN(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t));}));}return e}!function(e,t){e.exports=(()=>{var e={8:(e,t,i)=>{i.r(t),i.d(t,{Parser:()=>I,Printer:()=>O,parse:()=>D,print:()=>P});const n="\n",r="".concat("\r").concat(n),o=" ";let s;function a(e){return e>="0"&&e<="9"}function c(e){return e>="!"&&e<="~"}function d(e){return c(e)||e>=""&&e<="ÿ"}function u(e){return "!"===e||e>="#"&&e<="'"||e>="*"&&e<="+"||e>="-"&&e<="."||e>="0"&&e<="9"||e>="A"&&e<="Z"||e>="^"&&e<="~"}function l(e){return e>="1"&&e<="9"}function h(e){return e>="A"&&e<="Z"||e>="a"&&e<="z"}function p(e){return "d"===e||"h"===e||"m"===e||"s"===e}function _(e){return e>""&&e<"\t"||e>"\v"&&e<"\f"||e>""&&e<"ÿ"}function E(e){return h(e)||a(e)||"+"===e||"/"===e}function m(e){return a(e)||h(e)||"+"===e||"/"===e||"-"===e||"_"===e}function f(e){return h(e)||a(e)||"+"===e||"/"===e}function S(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n);}return i}function T(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?S(Object(i),!0).forEach((function(t){g(e,t,i[t]);})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):S(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t));}));}return e}function g(e,t,i){return t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}!function(e){e.VERSION="v",e.ORIGIN="o",e.SESSION_NAME="s",e.INFORMATION="i",e.URI="u",e.EMAIL="e",e.PHONE="p",e.CONNECTION="c",e.BANDWIDTH="b",e.TIME="t",e.REPEAT="r",e.ZONE_ADJUSTMENTS="z",e.KEY="k",e.ATTRIBUTE="a",e.MEDIA="m";}(s||(s={}));class R{consumeText(e,t){let i=t;for(;i<e.length;){const t=e[i];if("\0"===t||"\r"===t||t===n)break;i+=1;}if(i-t==0)throw new Error("Invalid text, at ".concat(e));return i}consumeUnicastAddress(e,t,i){return this.consumeTill(e,t,o)}consumeOneOrMore(e,t,i){let n=t;for(;i(e[n]);)n++;if(n-t==0)throw new Error("Invalid rule at ".concat(t,"."));return n}consumeSpace(e,t){if(e[t]===o)return t+1;throw new Error("Invalid space at ".concat(t,"."))}consumeIP4Address(e,t){let i=t;for(let t=0;t<4;t++)if(i=this.consumeDecimalUChar(e,i),3!==t){if("."!==e[i])throw new Error("Invalid IP4 address.");i++;}return i}consumeDecimalUChar(e,t){let i=t;for(let t=0;t<3&&a(e[i]);t++,i++);if(i-t==0)throw new Error("Invalid decimal uchar.");const n=parseInt(e.slice(t,i));if(n>=0&&n<=255)return i;throw new Error("Invalid decimal uchar")}consumeIP6Address(e,t){let i=this.consumeHexpart(e,t);return ":"===e[i]?(i+=1,i=this.consumeIP4Address(e,i),i):i}consumeHexpart(e,t){let i=t;if(":"===e[i]&&":"===e[i+1]){i+=2;try{i=this.consumeHexseq(e,i);}catch(e){}return i}if(i=this.consumeHexseq(e,i),":"===e[i]&&":"===e[i+1]){i+=2;try{i=this.consumeHexseq(e,i);}catch(e){}return i}return i}consumeHexseq(e,t){let i=t;for(;i=this.consumeHex4(e,i),":"===e[i]&&":"!==e[i+1];)i+=1;return i}consumeHex4(e,t){let i=0;for(;i<4;i++)if(!((n=e[t+i])>="0"&&n<="9"||n>="a"&&n<="f"||n>="A"&&n<="F")){if(0===i)throw new Error("Invalid hex 4");break}var n;return t+i}consumeFQDN(e,t){let i=t;for(;a(e[i])||h(e[i])||"-"===e[i]||"."===e[i];)i+=1;if(i-t<4)throw new Error("Invalid FQDN");return i}consumeExtnAddr(e,t){return this.consumeOneOrMore(e,t,d)}consumeMulticastAddress(e,t,i){switch(i){case"IP4":case"ip4":return this.consumeIP4MulticastAddress(e,t);case"IP6":case"ip6":return this.consumeIP6MulticastAddress(e,t);default:try{return this.consumeFQDN(e,t)}catch(i){return this.consumeExtnAddr(e,t)}}}consumeIP6MulticastAddress(e,t){const i=this.consumeHexpart(e,t);return "/"===e[i]?this.consumeInteger(e,i+1):i}consumeIP4MulticastAddress(e,t){let i=t+3;const n=e.slice(t,i),r=parseInt(n);if(r<224||r>239)throw new Error("Invalid IP4 multicast address, IPv4 multicast addresses may be in the range 224.0.0.0 to 239.255.255.255.");for(let t=0;t<3;t++){if("."!==e[i])throw new Error("Invalid IP4 multicast address.");i+=1,i=this.consumeDecimalUChar(e,i);}return "/"===e[i]&&(i+=1),i=this.consumeTTL(e,i),"/"===e[i]&&(i=this.consumeInteger(e,i)),i}consumeInteger(e,t){if(!l(e[t]))throw new Error("Invalid integer.");for(t+=1;a(e[t]);)t+=1;return t}consumeTTL(e,t){if("0"===e[t])return t+1;if(!l(e[t]))throw new Error("Invalid TTL.");t+=1;for(let i=0;i<2&&a(e[t]);i++)t+=1;return t}consumeToken(e,t){return this.consumeOneOrMore(e,t,u)}consumeTime(e,t){let i=t;if("0"===e[i])return i+1;for(l(e[i])&&(i+=1);a(e[i]);)i++;if(i-t<10)throw new Error("Invalid time");return i}consumeAddress(e,t){return this.consumeTill(e,t,o)}consumeTypedTime(e,t){let i=t;return i=this.consumeOneOrMore(e,i,a),p(e[i])?i+1:i}consumeRepeatInterval(e,t){if(!l(e[t]))throw new Error("Invalid repeat interval");for(t+=1;a(e[t]);)t+=1;return p(e[t])&&(t+=1),t}consumePort(e,t){return this.consumeOneOrMore(e,t,a)}consume(e,t,i){for(let n=0;n<i.length;n++){if(t+n>=e.length)throw new Error("consume exceeding value length");if(e[t+n]!==i[n])throw new Error("consume ".concat(i," failed at ").concat(n))}return t+i.length}consumeTill(e,t,i){let n=t;for(;n<e.length&&("string"!=typeof i||e[n]!==i)&&("function"!=typeof i||!i(e[n]));)n++;return n}}class I extends R{constructor(){super(),g(this,"records",[]),g(this,"currentLine",0);}parse(e){const t=this.probeEOL(e);this.records=e.split(t).filter(e=>!!e.trim()).map(this.parseLine),this.currentLine=0;const i=this.parseVersion(),n=this.parseOrigin(),r=this.parseSessionName(),o=this.parseInformation(),s=this.parseUri(),a=this.parseEmail(),c=this.parsePhone(),d=this.parseConnection(),u=this.parseBandWidth(),l=this.parseTimeFields(),h=this.parseKey(),p=this.parseSessionAttribute(),_=this.parseMediaDescription();if(this.currentLine!==this.records.length)throw new Error("parsing failed, non exhaustive sdp lines.");return {version:i,origin:n,sessionName:r,information:o,uri:s,emails:a,phones:c,connection:d,bandwidths:u,timeFields:l,key:h,attributes:p,mediaDescriptions:_}}getCurrentRecord(){const e=this.records[this.currentLine];if(!e)throw new Error("Record doesn't exit.");return e}probeEOL(e){for(let t=0;t<e.length;t++)if(e[t]===n)return "\r"===e[t-1]?r:n;throw new Error("Invalid newline character.")}parseLine(e,t){if(e.length<2)throw new Error("Invalid sdp line, sdp line should be of form <type>=<value>.");const i=e[0];if("="!==e[1])throw new Error('Invalid sdp line, <type> should be a single character followed by an "=" sign.');return {type:i,value:e.slice(2),line:t,cur:0}}parseSessionAttribute(){const e=new v;for(;this.currentLine<this.records.length;){const t=this.getCurrentRecord();if(t.type!==s.ATTRIBUTE)break;const i={attField:this.extractOneOrMore(t,e=>u(e)&&":"!==e),_cur:0};":"===t.value[t.cur]&&(t.cur+=1,i.attValue=this.extractOneOrMore(t,_)),e.parse(i),this.currentLine++;}return e.digest()}parseMediaAttributes(e){const t=new y(e);for(;this.currentLine<this.records.length;){const e=this.getCurrentRecord();if(e.type!==s.ATTRIBUTE)break;const i={attField:this.extractOneOrMore(e,e=>u(e)&&":"!==e),_cur:0};":"===e.value[e.cur]&&(e.cur+=1,i.attValue=this.extractOneOrMore(e,_)),t.parse(i),this.currentLine++;}return t.digest()}parseKey(){const e=this.getCurrentRecord();if(e.type===s.KEY){if("prompt"===e.value||"clear:"===e.value||"base64:"===e.value||"uri:"===e.value)return e.value;throw this.currentLine++,new Error("Invalid key.")}}parseZone(){const e=this.getCurrentRecord();if(e.type===s.ZONE_ADJUSTMENTS){const t=[];for(;;)try{const i=this.extract(e,this.consumeTime);this.consumeSpaceForRecord(e);let n=!1;"-"===e.value[e.cur]&&(n=!0,e.cur+=1);const r=this.extract(e,this.consumeTypedTime);t.push({time:i,typedTime:r,back:n});}catch(e){break}if(0===t.length)throw new Error("Invalid zone adjustments");return this.currentLine++,t}return []}parseRepeat(){const e=[];for(;;){const t=this.getCurrentRecord();if(t.type!==s.REPEAT)break;{const i=this.extract(t,this.consumeRepeatInterval),n=this.parseTypedTime(t);e.push({repeatInterval:i,typedTimes:n}),this.currentLine++;}}return e}parseTypedTime(e){const t=[];for(;;)try{this.consumeSpaceForRecord(e),t.push(this.extract(e,this.consumeTypedTime));}catch(e){break}if(0===t.length)throw new Error("Invalid typed time.");return t}parseTime(){const e=this.getCurrentRecord(),t=this.extract(e,this.consumeTime);this.consumeSpaceForRecord(e);const i=this.extract(e,this.consumeTime);return this.currentLine++,{startTime:t,stopTime:i}}parseBandWidth(){const e=[];for(;this.currentLine<this.records.length;){const t=this.getCurrentRecord();if(t.type!==s.BANDWIDTH)break;{const i=this.extractOneOrMore(t,u);if(":"!==t.value[t.cur])throw new Error("Invalid bandwidth field.");t.cur++;const n=this.extractOneOrMore(t,a);e.push({bwtype:i,bandwidth:n}),this.currentLine++;}}return e}parseVersion(){const e=this.getCurrentRecord();if(e.type!==s.VERSION)throw new Error("first sdp record must be version");const t=e.value.slice(0,this.consumeOneOrMore(e.value,0,a));if(t.length!==e.value.length)throw new Error('invalid proto version, "v='.concat(e.value,'"'));return this.currentLine++,t}parseOrigin(){const e=this.getCurrentRecord();if(e.type!==s.ORIGIN)throw new Error("second line of sdp must be origin");const t=this.extractOneOrMore(e,d);this.consumeSpaceForRecord(e);const i=this.extractOneOrMore(e,a);this.consumeSpaceForRecord(e);const n=this.extractOneOrMore(e,a);this.consumeSpaceForRecord(e);const r=this.extractOneOrMore(e,u);this.consumeSpaceForRecord(e);const o=this.extractOneOrMore(e,u);this.consumeSpaceForRecord(e);const c=this.extract(e,this.consumeUnicastAddress);return this.currentLine++,{username:t,sessId:i,sessVersion:n,nettype:r,addrtype:o,unicastAddress:c}}parseSessionName(){const e=this.getCurrentRecord();if(e.type===s.SESSION_NAME){const t=this.extract(e,this.consumeText);return this.currentLine++,t}}parseInformation(){const e=this.getCurrentRecord();if(e.type!==s.INFORMATION)return;const t=this.extract(e,this.consumeText);return this.currentLine++,t}parseUri(){const e=this.getCurrentRecord();if(e.type===s.URI)return this.currentLine++,e.value}parseEmail(){const e=[];for(;;){const t=this.getCurrentRecord();if(t.type!==s.EMAIL)break;e.push(t.value),this.currentLine++;}return e}parsePhone(){const e=[];for(;;){const t=this.getCurrentRecord();if(t.type!==s.PHONE)break;e.push(t.value),this.currentLine++;}return e}parseConnection(){const e=this.getCurrentRecord();if(e.type===s.CONNECTION){const t=this.extractOneOrMore(e,u);this.consumeSpaceForRecord(e);const i=this.extractOneOrMore(e,u);this.consumeSpaceForRecord(e);const n=this.extract(e,this.consumeAddress);return this.currentLine++,{nettype:t,addrtype:i,address:n}}}parseMedia(){const e=this.getCurrentRecord(),t=this.extract(e,this.consumeToken);this.consumeSpaceForRecord(e);let i=this.extract(e,this.consumePort);"/"===e.value[e.cur]&&(e.cur+=1,i+=this.extract(e,this.consumeInteger)),this.consumeSpaceForRecord(e);const n=[];for(n.push(this.extract(e,this.consumeToken));"/"===e.value[e.cur];)e.cur+=1,n.push(this.extract(e,this.consumeToken));if(0===n.length)throw new Error("Invalid proto");const r=this.parseFmt(e);return this.currentLine++,{mediaType:t,port:i,protos:n,fmts:r}}parseTimeFields(){const e=[];for(;this.getCurrentRecord().type===s.TIME;){const t=this.parseTime(),i=this.parseRepeat(),n=this.parseZone();e.push({time:t,repeats:i,zones:n});}return e}parseMediaDescription(){const e=[];for(;this.currentLine<this.records.length&&this.getCurrentRecord().type===s.MEDIA;){const t=this.parseMedia(),i=this.parseInformation(),n=this.parseConnections(),r=this.parseBandWidth(),o=this.parseKey(),s=this.parseMediaAttributes(t);e.push({media:t,information:i,connections:n,bandwidths:r,key:o,attributes:s});}return e}parseConnections(){const e=[];for(;this.currentLine<this.records.length&&this.getCurrentRecord().type===s.CONNECTION;)e.push(this.parseConnection());return e}parseFmt(e){const t=[];for(;;)try{this.consumeSpaceForRecord(e),t.push(this.extract(e,this.consumeToken));}catch(e){break}if(0===t.length)throw new Error("Invalid fmts");return t}extract(e,t,...i){const n=t.call(this,e.value,e.cur,...i),r=e.value.slice(e.cur,n);return e.cur=n,r}extractOneOrMore(e,t){const i=this.consumeOneOrMore(e.value,e.cur,t),n=e.value.slice(e.cur,i);return e.cur=i,n}consumeSpaceForRecord(e){if(e.value[e.cur]!==o)throw new Error("Invalid space at ".concat(e.cur,"."));e.cur+=1;}}class C extends R{constructor(...e){super(...e),g(this,"attributes",void 0),g(this,"digested",!1);}extractOneOrMore(e,t,i){const n=this.consumeOneOrMore(e.attValue,e._cur,t),r=e.attValue.slice(e._cur,n),[o,s]=i||[];if("number"==typeof o&&r.length<o)throw new Error("error in length, should be more or equal than ".concat(o," characters."));if("number"==typeof s&&r.length>s)throw new Error("error in length, should be less or equal than ".concat(s," characters."));return e._cur=n,r}consumeAttributeSpace(e){if(e.attValue[e._cur]!==o)throw new Error("Invalid space at ".concat(e._cur,"."));e._cur+=1;}extract(e,t,...i){if(!e.attValue)throw new Error("Nothing to extract from attValue.");const n=t.call(this,e.attValue,e._cur,...i),r=e.attValue.slice(e._cur,n);return e._cur=n,r}atEnd(e){if(!e.attValue)throw new Error;return e._cur>=e.attValue.length}peekChar(e){if(!e.attValue)throw new Error;return e.attValue[e._cur]}peek(e,t){if(!e.attValue)throw new Error;for(let i=0;i<t.length;i++)if(t[i]!==e.attValue[e._cur+i])return !1;return !0}parseIceUfrag(e){if(this.attributes.iceUfrag)throw new Error("Invalid ice-ufrag, should be only a single line if 'a=ice-ufrag'");this.attributes.iceUfrag=this.extractOneOrMore(e,E,[4,256]);}parseIcePwd(e){if(this.attributes.icePwd)throw new Error("Invalid ice-pwd, should be only a single line if 'a=ice-pwd'");this.attributes.icePwd=this.extractOneOrMore(e,E,[22,256]);}parseIceOptions(e){if(this.attributes.iceOptions)throw new Error("Invalid ice-options, should be only one 'ice-options' line");const t=[];for(;!this.atEnd(e);){t.push(this.extractOneOrMore(e,E));try{this.consumeAttributeSpace(e);}catch(t){if(this.atEnd(e))break;throw t}}this.attributes.iceOptions=t;}parseFingerprint(e){const t=this.extract(e,this.consumeToken);this.consumeAttributeSpace(e);const i=this.extract(e,this.consumeTill);this.attributes.fingerprints.push({hashFunction:t,fingerprint:i});}parseExtmap(e){const t=this.extractOneOrMore(e,a);let i;"/"===this.peekChar(e)&&(this.extract(e,this.consume,"/"),i=this.extract(e,this.consumeToken)),this.consumeAttributeSpace(e);const n=this.extract(e,this.consumeTill,o),r=T(T({entry:parseInt(t,10)},i&&{direction:i}),{},{extensionName:n});this.peekChar(e)===o&&(this.consumeAttributeSpace(e),r.extensionAttributes=this.extract(e,this.consumeTill)),this.attributes.extmaps.push(r);}parseSetup(e){if(this.attributes.setup)throw new Error("must only be one single 'a=setup' line.");const t=this.extract(e,this.consumeTill);if("active"!==t&&"passive"!==t&&"actpass"!==t&&"holdconn"!==t)throw new Error("role must be one of 'active', 'passive', 'actpass', 'holdconn'.");this.attributes.setup=t;}}class v extends C{constructor(...e){super(...e),g(this,"attributes",{unrecognized:[],groups:[],extmaps:[],fingerprints:[],identities:[]});}parse(e){if(this.digested)throw new Error("already digested");try{switch(e.attField){case"group":this.parseGroup(e);break;case"ice-lite":this.parseIceLite();break;case"ice-ufrag":this.parseIceUfrag(e);break;case"ice-pwd":this.parseIcePwd(e);break;case"ice-options":this.parseIceOptions(e);break;case"fingerprint":this.parseFingerprint(e);break;case"setup":this.parseSetup(e);break;case"tls-id":this.parseTlsId(e);break;case"identity":this.parseIdentity(e);break;case"extmap":this.parseExtmap(e);break;case"msid-semantic":this.parseMsidSemantic(e);break;default:e.ignored=!0,this.attributes.unrecognized.push(e);}}catch(t){throw console.error("parsing session attribute ".concat(e.attField,' error, "a=').concat(e.attField,":").concat(e.attValue,'"')),t}if(!e.ignored&&e.attValue&&!this.atEnd(e))throw new Error("attribute parsing error")}digest(){return this.digested=!0,this.attributes}parseGroup(e){const t=this.extract(e,this.consumeToken),i=[];for(;!this.atEnd(e)&&this.peekChar(e)===o;)this.consumeAttributeSpace(e),i.push(this.extract(e,this.consumeToken));this.attributes.groups.push({semantic:t,identificationTag:i});}parseIceLite(){if(this.attributes.iceLite)throw new Error("Invalid ice-lite, should be only a single line of 'a=ice-lite'");this.attributes.iceLite=!0;}parseTlsId(e){if(this.attributes.tlsId)throw new Error("must be only one tld-id line");this.attributes.tlsId=this.extractOneOrMore(e,m);}parseIdentity(e){const t=this.extractOneOrMore(e,f),i=[];for(;!this.atEnd(e)&&this.peekChar(e)===o;){this.consumeAttributeSpace(e);const t=this.extract(e,this.consumeToken);this.extract(e,this.consume,"=");const n=this.extractOneOrMore(e,e=>e!==o&&_(e));i.push({name:t,value:n});}this.attributes.identities.push({assertionValue:t,extensions:i});}parseMsidSemantic(e){this.peekChar(e)===o&&this.consumeAttributeSpace(e);const t={semantic:this.extract(e,this.consumeToken),identifierList:[]};for(;;){try{this.consumeAttributeSpace(e);}catch(e){break}if("*"===this.peekChar(e)){this.extract(e,this.consume,"*"),t.applyForAll=!0;break}{const i=this.extract(e,this.consumeTill,o);t.identifierList.push(i);}}this.attributes.msidSemantic=t;}}class y extends C{constructor(e){super(),g(this,"attributes",void 0),-1!==e.protos.indexOf("RTP")||e.protos.indexOf("rtp"),this.attributes={unrecognized:[],candidates:[],extmaps:[],fingerprints:[],imageattr:[],msids:[],remoteCandidatesList:[],rids:[],ssrcs:[],ssrcGroups:[],rtcpFeedbackWildcards:[],payloads:[]};}parse(e){if(this.digested)throw new Error("already digested");try{switch(e.attField){case"extmap":this.parseExtmap(e);break;case"setup":this.parseSetup(e);break;case"ice-ufrag":this.parseIceUfrag(e);break;case"ice-pwd":this.parseIcePwd(e);break;case"ice-options":this.parseIceOptions(e);break;case"candidate":this.parseCandidate(e);break;case"remote-candidate":this.parseRemoteCandidate(e);break;case"end-of-candidates":this.parseEndOfCandidates();break;case"fingerprint":this.parseFingerprint(e);break;case"rtpmap":this.parseRtpmap(e);break;case"ptime":this.parsePtime(e);break;case"maxptime":this.parseMaxPtime(e);break;case"sendrecv":case"recvonly":case"sendonly":case"inactive":this.parseDirection(e);break;case"ssrc":this.parseSSRC(e);break;case"fmtp":this.parseFmtp(e);break;case"rtcp-fb":this.parseRtcpFb(e);break;case"rtcp-mux":this.parseRTCPMux();break;case"rtcp-mux-only":this.parseRTCPMuxOnly();break;case"rtcp-rsize":this.parseRTCPRsize();break;case"rtcp":this.parseRTCP(e);break;case"mid":this.parseMid(e);break;case"msid":this.parseMsid(e);break;case"imageattr":this.parseImageAttr(e);break;case"rid":this.parseRid(e);break;case"simulcast":this.parseSimulcast(e);break;case"sctp-port":this.parseSctpPort(e);break;case"max-message-size":this.parseMaxMessageSize(e);break;case"ssrc-group":this.parseSSRCGroup(e);break;default:e.ignored=!0,this.attributes.unrecognized.push(e);}}catch(t){throw console.error("parsing media attribute ".concat(e.attField,' error, "a=').concat(e.attField,":").concat(e.attValue,'"')),t}if(!e.ignored&&e.attValue&&!this.atEnd(e))throw new Error("attribute parsing error")}parseCandidate(e){const t=this.extractOneOrMore(e,E,[1,32]);this.consumeAttributeSpace(e);const i=this.extractOneOrMore(e,a,[1,5]);this.consumeAttributeSpace(e);const n=this.extract(e,this.consumeToken);this.consumeAttributeSpace(e);const r=this.extractOneOrMore(e,a,[1,10]);this.consumeAttributeSpace(e);const s=this.extract(e,this.consumeAddress);this.consumeAttributeSpace(e);const d=this.extract(e,this.consumePort);this.consumeAttributeSpace(e),this.extract(e,this.consume,"typ"),this.consumeAttributeSpace(e);const u={foundation:t,componentId:i,transport:n,priority:r,connectionAddress:s,port:d,type:this.extract(e,this.consumeToken),extension:{}};for(this.peek(e," raddr")&&(this.extract(e,this.consume," raddr"),this.consumeAttributeSpace(e),u.relAddr=this.extract(e,this.consumeAddress)),this.peek(e," rport")&&(this.extract(e,this.consume," rport"),this.consumeAttributeSpace(e),u.relPort=this.extract(e,this.consumePort));this.peekChar(e)===o;){this.consumeAttributeSpace(e);const t=this.extract(e,this.consumeToken);this.consumeAttributeSpace(e),u.extension[t]=this.extractOneOrMore(e,c);}this.attributes.candidates.push(u);}parseRemoteCandidate(e){const t=[];for(;;){const i=this.extractOneOrMore(e,a,[1,5]);this.consumeAttributeSpace(e);const n=this.extract(e,this.consumeAddress);this.consumeAttributeSpace(e);const r=this.extract(e,this.consumePort);t.push({componentId:i,connectionAddress:n,port:r});try{this.consumeAttributeSpace(e);}catch(e){break}}this.attributes.remoteCandidatesList.push(t);}parseEndOfCandidates(){if(this.attributes.endOfCandidates)throw new Error("must be only one line of end-of-candidates");this.attributes.endOfCandidates=!0;}parseRtpmap(e){const t=this.extract(e,this.consumeToken);this.consumeAttributeSpace(e);const i=this.extract(e,this.consumeTill,"/");this.extract(e,this.consume,"/");const n={encodingName:i,clockRate:this.extractOneOrMore(e,a)};this.atEnd(e)||"/"!==this.peekChar(e)||(this.extract(e,this.consume,"/"),n.encodingParameters=parseInt(this.extract(e,this.consumeTill),10));const r=this.attributes.payloads.find(e=>e.payloadType===parseInt(t,10));r?r.rtpMap=n:this.attributes.payloads.push({payloadType:parseInt(t,10),rtpMap:n,rtcpFeedbacks:[]});}parsePtime(e){if(this.attributes.ptime)throw new Error("must be only one line of ptime");this.attributes.ptime=this.extract(e,this.consumeTill);}parseMaxPtime(e){if(this.attributes.maxPtime)throw new Error("must be only one line of ptime");this.attributes.maxPtime=this.extract(e,this.consumeTill);}parseDirection(e){if(this.attributes.direction)throw new Error("must be only one line of direction info");this.attributes.direction=e.attField;}parseSSRC(e){const t=this.extractOneOrMore(e,a);this.consumeAttributeSpace(e);const i=this.extract(e,this.consumeTill,":");let n;":"===this.peekChar(e)&&(this.extract(e,this.consume,":"),n=this.extract(e,this.consumeTill));const r=this.attributes.ssrcs.find(e=>e.ssrcId===parseInt(t,10));r?r.attributes[i]=n:this.attributes.ssrcs.push({ssrcId:parseInt(t,10),attributes:{[i]:n}});}parseFmtp(e){const t=this.extract(e,this.consumeTill,o);this.consumeAttributeSpace(e);const i=this.extract(e,this.consumeTill),n={};i.split(";").forEach(e=>{let[t,i]=e.split("=");t=t.trim();const r="string"==typeof i?i.trim():null;"string"==typeof t&&t.length>0&&(n[t]=r);});const r=this.attributes.payloads.find(e=>e.payloadType===parseInt(t,10));r?r.fmtp={parameters:n}:this.attributes.payloads.push({payloadType:parseInt(t,10),rtcpFeedbacks:[],fmtp:{parameters:n}});}parseFmtParameters(e){const t={},i=this.extract(e,this.consumeTill,"=");e._cur++;const n=this.extract(e,this.consumeTill,";");for(t[i]=n;";"===e.attValue[e._cur];){const i=this.extract(e,this.consumeTill,"=");e._cur++;const n=this.extract(e,this.consumeTill,";");t[i]=n;}return t}parseRtcpFb(e){let t="";t="*"===this.peekChar(e)?this.extract(e,this.consume,"*"):this.extract(e,this.consumeTill,o),this.consumeAttributeSpace(e);const i=this.extract(e,this.consumeTill,o);let n;switch(i){case"trr-int":n={type:i,interval:this.extract(e,this.consumeTill)};break;case"ack":case"nack":default:{const t={type:i};this.peekChar(e)===o&&(this.consumeAttributeSpace(e),t.parameter=this.extract(e,this.consumeToken),this.peekChar(e)===o&&(t.additional=this.extract(e,this.consumeTill))),n=t;}}if("*"===t)this.attributes.rtcpFeedbackWildcards.push(n);else {const e=this.attributes.payloads.find(e=>e.payloadType===parseInt(t,10));e?e.rtcpFeedbacks.push(n):this.attributes.payloads.push({payloadType:parseInt(t,10),rtcpFeedbacks:[n]});}}parseRTCPMux(){if(this.attributes.rtcpMux)throw new Error("must be single line of rtcp-mux");this.attributes.rtcpMux=!0;}parseRTCPMuxOnly(){if(this.attributes.rtcpMuxOnly)throw new Error("must be single line of rtcp-only");this.attributes.rtcpMuxOnly=!0;}parseRTCPRsize(){if(this.attributes.rtcpRsize)throw new Error("must be single line of rtcp-rsize");this.attributes.rtcpRsize=!0;}parseRTCP(e){if(this.attributes.rtcp)throw new Error("must be single line of rtcp");const t={port:this.extract(e,this.consumePort)};this.peekChar(e)===o&&(this.consumeAttributeSpace(e),t.netType=this.extractOneOrMore(e,u),this.consumeAttributeSpace(e),t.addressType=this.extractOneOrMore(e,u),this.consumeAttributeSpace(e),t.address=this.extract(e,this.consumeAddress)),this.attributes.rtcp=t;}parseMsid(e){const t={id:this.extractOneOrMore(e,u,[1,64])};this.peekChar(e)===o&&(this.consumeAttributeSpace(e),t.appdata=this.extractOneOrMore(e,u,[1,64])),this.attributes.msids.push(t);}parseImageAttr(e){this.attributes.imageattr.push(e.attValue);}parseRid(e){const t=this.extractOneOrMore(e,e=>h(e)||a(e)||"_"===e||"-"===e);this.consumeAttributeSpace(e);const i={id:t,direction:this.extract(e,this.consumeToken),params:[]};if(this.peekChar(e)===o){if(this.consumeAttributeSpace(e),this.peek(e,"pt=")){this.extract(e,this.consume,"pt=");const t=[];for(;;){const i=this.extract(e,this.consumeToken);t.push(i);try{this.extract(e,this.consume,",");}catch(e){break}}i.payloads=t,this.peekChar(e)===o&&this.extract(e,this.consume,o);}for(;;){const t=this.extract(e,this.consumeToken);switch(t){case"depend":{const n={type:t,rids:this.extract(e,this.consume,"=").split(",")};i.params.push(n);break}case"max-width":case"height-width":case"max-fps":case"max-fs":case"max-br":case"max-pps":case"max-bpp":default:{const n={type:t};"="===this.peekChar(e)&&(this.extract(e,this.consume,"="),n.val=this.extract(e,this.consumeTill,";")),i.params.push(n);}}try{this.extract(e,this.consume,";");}catch(e){break}}}this.attributes.rids.push(i);}parseSimulcast(e){if(this.attributes.simulcast)throw new Error("must be single line of simulcast");this.attributes.simulcast=e.attValue,this.extract(e,this.consumeTill);}parseSctpPort(e){this.attributes.sctpPort=this.extractOneOrMore(e,a,[1,5]);}parseMaxMessageSize(e){this.attributes.maxMessageSize=this.extractOneOrMore(e,a,[1,void 0]);}digest(){return this.digested=!0,this.attributes}parseMid(e){this.attributes.mid=this.extract(e,this.consumeToken);}parseSSRCGroup(e){const t=this.extract(e,this.consumeToken),i=[];for(;;)try{this.consumeAttributeSpace(e);const t=this.extract(e,this.consumeInteger);i.push(parseInt(t,10));}catch(e){break}this.attributes.ssrcGroups.push({semantic:t,ssrcIds:i});}}function A(e,t,i){return t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}class O{constructor(){A(this,"eol",r);}print(e,t){let i="";return t&&(this.eol=t),i+=this.printVersion(e.version),i+=this.printOrigin(e.origin),i+=this.printSessionName(e.sessionName),i+=this.printInformation(e.information),i+=this.printUri(e.uri),i+=this.printEmail(e.emails),i+=this.printPhone(e.phones),i+=this.printConnection(e.connection),i+=this.printBandwidth(e.bandwidths),i+=this.printTimeFields(e.timeFields),i+=this.printKey(e.key),i+=this.printSessionAttributes(e.attributes),i+=this.printMediaDescription(e.mediaDescriptions),i}printVersion(e){return "v=".concat(e).concat(this.eol)}printOrigin(e){return "o=".concat(e.username," ").concat(e.sessId," ").concat(e.sessVersion," ").concat(e.nettype," ").concat(e.addrtype," ").concat(e.unicastAddress).concat(this.eol)}printSessionName(e){return e?"s=".concat(e).concat(this.eol):""}printInformation(e){return e?"i=".concat(e).concat(this.eol):""}printUri(e){return e?"u=".concat(e).concat(this.eol):""}printEmail(e){let t="";for(const i of e)t+="e=".concat(i).concat(this.eol);return t}printPhone(e){let t="";for(const i of e)t+="e=".concat(i).concat(this.eol);return t}printConnection(e){return e?"c=".concat(e.nettype," ").concat(e.addrtype," ").concat(e.address).concat(this.eol):""}printBandwidth(e){let t="";for(const i of e)t+="b=".concat(i.bwtype,":").concat(i.bandwidth).concat(this.eol);return t}printTimeFields(e){let t="";for(const i of e){t+="t=".concat(i.time.startTime," ").concat(i.time.startTime).concat(this.eol);for(const e of i.repeats)t+="r=".concat(e.repeatInterval," ").concat(e.typedTimes.join(" ")).concat(this.eol);i.zoneAdjustments&&(t+="z=",t+="z=".concat(i.zoneAdjustments.map(e=>"".concat(e.time," ").concat(e.back?"-":""," ").concat(e.typedTime)).join(" ")).concat(this.eol),t+=this.eol);}return t}printKey(e){return e?"k=".concat(e).concat(this.eol):""}printAttributes(e){let t="";for(const i of e)t+="a=".concat(i.attField).concat(i.attValue?":".concat(i.attValue):"").concat(this.eol);return t}printMediaDescription(e){let t="";for(const i of e)t+=this.printMedia(i.media),t+=this.printInformation(i.information),t+=this.printConnections(i.connections),t+=this.printBandwidth(i.bandwidths),t+=this.printKey(i.key),t+=this.printMediaAttributes(i);return t}printConnections(e){let t="";for(const i of e)t+=this.printConnection(i);return t}printMedia(e){return "m=".concat(e.mediaType," ").concat(e.port," ").concat(e.protos.join("/")," ").concat(e.fmts.join(" ")).concat(this.eol)}printSessionAttributes(e){return new b(this.eol).print(e)}printMediaAttributes(e){return new w(this.eol).print(e)}}class N{constructor(e){A(this,"eol",void 0),this.eol=e;}printIceUfrag(e){return void 0===e?"":"a=ice-ufrag:".concat(e).concat(this.eol)}printIcePwd(e){return void 0===e?"":"a=ice-pwd:".concat(e).concat(this.eol)}printIceOptions(e){return void 0===e?"":"a=ice-options:".concat(e.join(o)).concat(this.eol)}printFingerprints(e){return e.length>0?e.map(e=>"a=fingerprint:".concat(e.hashFunction).concat(o).concat(e.fingerprint)).join(this.eol)+this.eol:""}printExtmap(e){return e.map(e=>"a=extmap:".concat(e.entry).concat(e.direction?"/".concat(e.direction):"").concat(o).concat(e.extensionName).concat(e.extensionAttributes?"".concat(o).concat(e.extensionAttributes):"").concat(this.eol)).join("")}printSetup(e){return void 0===e?"":"a=setup:".concat(e).concat(this.eol)}printUnrecognized(e){return e.map(e=>"a=".concat(e.attField).concat(e.attValue?":".concat(e.attValue):"").concat(this.eol)).join("")}}class b extends N{print(e){let t="";return t+=this.printGroups(e.groups),t+=this.printMsidSemantic(e.msidSemantic),t+=this.printIceLite(e.iceLite),t+=this.printIceUfrag(e.iceUfrag),t+=this.printIcePwd(e.icePwd),t+=this.printIceOptions(e.iceOptions),t+=this.printFingerprints(e.fingerprints),t+=this.printSetup(e.setup),t+=this.printTlsId(e.tlsId),t+=this.printIdentity(e.identities),t+=this.printExtmap(e.extmaps),t+=this.printUnrecognized(e.unrecognized),t}printGroups(e){let t="";return e.length>0&&(t+=e.map(e=>"a=group:".concat(e.semantic).concat(e.identificationTag.map(e=>"".concat(o).concat(e)).join("")).concat(this.eol)).join("")),t}printIceLite(e){return void 0===e?"":"a=ice-lite"+this.eol}printTlsId(e){return e?"a=tls-id:".concat(e).concat(this.eol):""}printIdentity(e){return 0===e.length?"":e.map(e=>"a=identity:".concat(e.assertionValue).concat(e.extensions.map(e=>"".concat(o).concat(e.name).concat(e.value?"=".concat(e.value):"")))).join(this.eol)+this.eol}printMsidSemantic(e){if(!e)return "";let t="a=msid-semantic:".concat(e.semantic);return e.applyForAll?t+="".concat(o,"*"):e.identifierList.length>0&&(t+=e.identifierList.map(e=>"".concat(o).concat(e))),t+this.eol}}class w extends N{print(e){const t=e.attributes;let i="";return i+=this.printRTCP(t.rtcp),i+=this.printIceUfrag(t.iceUfrag),i+=this.printIcePwd(t.icePwd),i+=this.printIceOptions(t.iceOptions),i+=this.printCandidates(t.candidates),i+=this.printRemoteCandidatesList(t.remoteCandidatesList),i+=this.printEndOfCandidates(t.endOfCandidates),i+=this.printFingerprints(t.fingerprints),i+=this.printSetup(t.setup),i+=this.printMid(t.mid),i+=this.printExtmap(t.extmaps),i+=this.printRTPRelated(t),i+=this.printPtime(t.ptime),i+=this.printMaxPtime(t.maxPtime),i+=this.printDirection(t.direction),i+=this.printSSRCGroups(t.ssrcGroups),i+=this.printSSRC(t.ssrcs),i+=this.printRTCPMux(t.rtcpMux),i+=this.printRTCPMuxOnly(t.rtcpMuxOnly),i+=this.printRTCPRsize(t.rtcpRsize),i+=this.printMSId(t.msids),i+=this.printImageattr(t.imageattr),i+=this.printRid(t.rids),i+=this.printSimulcast(t.simulcast),i+=this.printSCTPPort(t.sctpPort),i+=this.printMaxMessageSize(t.maxMessageSize),i+=this.printUnrecognized(t.unrecognized),i}printCandidates(e){return e.map(e=>"a=candidate:".concat(e.foundation).concat(o).concat(e.componentId).concat(o).concat(e.transport).concat(o).concat(e.priority).concat(o).concat(e.connectionAddress).concat(o).concat(e.port).concat(o,"typ").concat(o).concat(e.type).concat(e.relAddr?"".concat(o,"raddr").concat(o).concat(e.relAddr):"").concat(e.relPort?"".concat(o,"rport").concat(o).concat(e.relPort):"").concat(Object.keys(e.extension).map(t=>"".concat(o).concat(t).concat(o).concat(e.extension[t])).join("")).concat(this.eol)).join("")}printRemoteCandidatesList(e){return e.map(e=>"a=remote-candidates:".concat(e.join(o)).concat(this.eol)).join("")}printEndOfCandidates(e){return void 0===e?"":"a=end-of-candidates"+this.eol}printRTPRelated(e){if(!e.payloads)return "";const t=e.payloads;let i="";i+=e.rtcpFeedbackWildcards.map(e=>this.printRTCPFeedback("*",e)).join("");for(const e of t)i+=this.printRtpMap(e.payloadType,e.rtpMap),i+=this.printFmtp(e.payloadType,e.fmtp),i+=e.rtcpFeedbacks.map(t=>this.printRTCPFeedback(e.payloadType,t)).join("");return i}printFmtp(e,t){if(!t)return "";const i=Object.keys(t.parameters);return 1===i.length&&null===t.parameters[i[0]]?"a=fmtp:".concat(e).concat(o).concat(i[0]).concat(this.eol):"a=fmtp:".concat(e).concat(o).concat(Object.keys(t.parameters).map(e=>"".concat(e,"=").concat(t.parameters[e])).join(";")).concat(this.eol)}printRtpMap(e,t){return t?"a=rtpmap:".concat(e).concat(o).concat(t.encodingName,"/").concat(t.clockRate).concat(t.encodingParameters?"/".concat(t.encodingParameters):"").concat(this.eol):""}printRTCPFeedback(e,t){let i="a=rtcp-fb:".concat(e).concat(o),n=t;switch(n.type){case"trr-int":i+="ttr-int".concat(o).concat(n.interval);break;case"ack":case"nack":default:n=n,i+="".concat(n.type),n.parameter&&(i+="".concat(o).concat(n.parameter),n.additional&&(i+="".concat(o).concat(n.additional)));}return i+this.eol}printPtime(e){return void 0===e?"":"a=ptime:".concat(e).concat(this.eol)}printMaxPtime(e){return void 0===e?"":"a=maxptime:".concat(e).concat(this.eol)}printDirection(e){return void 0===e?"":"a=".concat(e).concat(this.eol)}printSSRC(e){return e.map(e=>Object.keys(e.attributes).map(t=>"a=ssrc:".concat(e.ssrcId.toString(10)).concat(o).concat(t).concat(e.attributes[t]?":".concat(e.attributes[t]):"").concat(this.eol)).join("")).join("")}printRTCPMux(e){return void 0===e?"":"a=rtcp-mux".concat(this.eol)}printRTCPMuxOnly(e){return void 0===e?"":"a=rtcp-mux-only".concat(this.eol)}printRTCPRsize(e){return void 0===e?"":"a=rtcp-rsize".concat(this.eol)}printRTCP(e){if(void 0===e)return "";let t="a=rtcp:".concat(e.port);return e.netType&&(t+="".concat(o).concat(e.netType)),e.addressType&&(t+="".concat(o).concat(e.addressType)),e.address&&(t+="".concat(o).concat(e.address)),t+this.eol}printMSId(e){return e.map(e=>"a=msid:".concat(e.id).concat(e.appdata?"".concat(o).concat(e.appdata):"").concat(this.eol)).join("")}printImageattr(e){return e.map(e=>"a=imageattr:".concat(e).concat(this.eol)).join("")}printRid(e){return e.map(e=>{let t="a=rid:".concat(e.id).concat(o).concat(e.direction);return e.payloads&&(t+="".concat(o,"pt=").concat(e.payloads.join(","))),e.params.length>0&&(t+="".concat(o).concat(e.params.map(e=>"depend"===e.type?"depend=".concat(e.rids.join(",")):"".concat(e.type,"=").concat(e.val)).join(";"))),t+this.eol}).join("")}printSimulcast(e){return void 0===e?"":"a=simulcast:".concat(e).concat(this.eol)}printSCTPPort(e){return void 0===e?"":"a=sctp-port:".concat(e).concat(this.eol)}printMaxMessageSize(e){return void 0===e?"":"a=max-message-size:".concat(e).concat(this.eol)}printMid(e){return void 0===e?"":"a=mid:".concat(e).concat(this.eol)}printSSRCGroups(e){return e.map(e=>"a=ssrc-group:".concat(e.semantic).concat(e.ssrcIds.map(e=>"".concat(o).concat(e.toString(10))).join("")).concat(this.eol)).join("")}}function D(e){return (new I).parse(e)}function P(e,t){return (new O).print(e,t)}}},t={};function i(n){if(t[n])return t[n].exports;var r=t[n]={exports:{}};return e[n](r,r.exports,i),r.exports}return i.d=(e,t)=>{for(var n in t)i.o(t,n)&&!i.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]});},i.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),i.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0});},i(8)})();}(UO);class iN{constructor(e){_p(this,"sessionDesc",void 0),_p(this,"localCapabilities",void 0),_p(this,"rtpCapabilities",void 0),_p(this,"candidates",void 0),_p(this,"iceParameters",void 0),_p(this,"dtlsParameters",void 0),_p(this,"setup",void 0),_p(this,"currentMidIndex",void 0),_p(this,"cname",void 0),e=uC(e);const{remoteIceParameters:t,remoteDtlsParameters:i,candidates:n,remoteRTPCapabilities:r,remoteSetup:o,localCapabilities:s,sdkCodec:a,cname:c}=e,d=UO.exports.parse("v=0\no=- 0 0 IN IP4 127.0.0.1\ns=AgoraGateway\nt=0 0\na=group:BUNDLE audio video\na=msid-semantic: WMS\na=ice-lite\nm=audio 9 UDP/TLS/RTP/SAVPF 0\nc=IN IP4 127.0.0.1\na=rtcp:9 IN IP4 0.0.0.0\na=sendrecv\na=rtcp-mux\na=rtcp-rsize\na=mid:audio\nm=video 9 UDP/TLS/RTP/SAVPF 0\nc=IN IP4 127.0.0.1\na=rtcp:9 IN IP4 0.0.0.0\na=sendrecv\na=rtcp-mux\na=rtcp-rsize\na=mid:video\n");this.rtpCapabilities=r,this.candidates=n,this.iceParameters=t,this.dtlsParameters=i,this.setup=o,this.localCapabilities=s,this.cname=c;for(let e=0;e<d.mediaDescriptions.length;e++){const s=d.mediaDescriptions[e];s.attributes.iceUfrag=t.iceUfrag,s.attributes.icePwd=t.icePwd,s.attributes.fingerprints=i.fingerprints,s.attributes.candidates=n,s.attributes.setup=o,"video"===s.media.mediaType&&(s.media.fmts=r.videoCodecs.map(e=>e.payloadType.toString(10)),s.attributes.payloads=r.videoCodecs,s.attributes.extmaps=r.videoExtensions),"audio"===s.media.mediaType&&(s.media.fmts=r.audioCodecs.map(e=>e.payloadType.toString(10)),s.attributes.payloads=r.audioCodecs,s.attributes.extmaps=r.audioExtensions),d.mediaDescriptions[e]=this.mungMediaDesc(s);}this.sessionDesc=d,this.currentMidIndex=d.mediaDescriptions.length-1;}toString(){return UO.exports.print(this.sessionDesc)}send(e,t,i){const{ssrcs:n,ssrcGroups:r}=WO(t,this.cname),o=this.sessionDesc.mediaDescriptions.find(t=>e===AS.VIDEO?"video"===t.media.mediaType:"audio"===t.media.mediaType),s=n[0].attributes.label,a=n[0].attributes.mslabel;return o.attributes.ssrcs=o.attributes.ssrcs.concat(n),o.attributes.ssrcGroups=o.attributes.ssrcGroups.concat(r),{id:s,mslabel:a}}batchSend(e){return e.map(e=>{let{kind:t,ssrcMsg:i}=e;return this.send(t,i,void 0)})}stopSending(e){this.sessionDesc.mediaDescriptions.forEach(t=>{const i=[],n=[],r=[];t.attributes.ssrcs.forEach(t=>{e.includes(t.attributes.label||"")?r.push(t):i.push(t);}),t.attributes.ssrcGroups.forEach(e=>{r.map(e=>e.ssrcId).includes(e.ssrcIds[0])||n.push(e);}),t.attributes.ssrcs=i,t.attributes.ssrcGroups=n;});}mute(e){const t=this.sessionDesc.mediaDescriptions.find(t=>t.attributes.mid===e);if(!t)throw new Error("mediaDescription not found with ".concat(e," in remote SDP when calling RemoteSDP.mute."));t.attributes.direction="inactive";}unmute(e){const t=this.sessionDesc.mediaDescriptions.find(t=>t.attributes.mid===e);if(!t)throw new Error("mediaDescription not found with ".concat(e," in remote SDP when calling RemoteSDP.unmute."));t.attributes.direction="sendonly";}receive(e,t,i){e.forEach((e,t)=>{const i=e._mediaStreamTrack,n=this.sessionDesc.mediaDescriptions.findIndex(e=>e.attributes.mid===i.kind),r=this.mungRecvMediaDsec(this.sessionDesc.mediaDescriptions[n],e);this.sessionDesc.mediaDescriptions[n]=r;});}stopReceiving(e){}updateCandidates(e){e===OS.TCP?this.candidates.forEach(e=>{-1===this.candidates.findIndex(t=>"tcp"===t.transport&&t.connectionAddress===e.connectionAddress&&t.port===e.port)&&this.candidates.push(tN(tN({},e),{},{foundation:"tcpcandidate",priority:Number(e.priority)-1+"",transport:"tcp",port:Number(e.port)+90+""}));}):this.candidates=this.candidates.filter(e=>"tcp"!==e.transport);for(const e of this.sessionDesc.mediaDescriptions)e.attributes.candidates=this.candidates;}restartICE(e){e=uC(e),this.iceParameters=e,this.sessionDesc.mediaDescriptions.forEach(t=>{t.attributes.iceUfrag=e.iceUfrag,t.attributes.icePwd=e.icePwd;});}predictReceivingMids(e){const t=[];for(let i=0;i<e;i++)t.push((this.currentMidIndex+i+1).toString(10));return t}mungRecvMediaDsec(e,t){const i=uC(e);return HO(i,t),YO(i,t),i}updateRecvMedia(e,t){const i=this.sessionDesc.mediaDescriptions.findIndex(t=>t.attributes.mid===e);if(-1!==i){const e=this.mungRecvMediaDsec(this.sessionDesc.mediaDescriptions[i],t);this.sessionDesc.mediaDescriptions[i]=e;}}bumpMid(e){this.currentMidIndex+=e;}updateTrackLabel(e,t,i){const n=this.sessionDesc.mediaDescriptions.find(t=>e===AS.VIDEO?"video"===t.attributes.mid:"audio"===t.attributes.mid);if(n){const e=n.attributes.ssrcs.find(e=>e.attributes.label===t);var r;if(e)e.attributes.label=i,null===(r=e.attributes.msid)||void 0===r||r.replace(t,i);}}mungMediaDesc(e){const t=uC(e);return KO(t),function(e){const t=e.attributes.extmaps.find(e=>"http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01"===e.extensionName);t&&e.attributes.extmaps.splice(e.attributes.extmaps.indexOf(t),1),e.attributes.payloads.forEach(e=>{const t=e.rtcpFeedbacks.findIndex(e=>"transport-cc"===e.type);-1!==t&&e.rtcpFeedbacks.splice(t,1);});}(t),t}getSSRC(e){for(const t of this.sessionDesc.mediaDescriptions)for(const i of t.attributes.ssrcs)if(i.attributes.label===e)return [i]}}function nN(e){if(Array.isArray(e))return e.map(e=>e);if(!rN(e))return e;const t={};for(const i in e)rN(e[i])||Array.isArray(e[i])?t[i]=nN(e[i]):t[i]=e[i];return t}function rN(e){return !("object"!=typeof e||Array.isArray(e)||!e)}function oN(){const e=navigator.userAgent.toLocaleLowerCase().match(/chrome\/[\d]*/i);return e&&e[0]?Number(e[0].split("/")[1]):null}function sN(e){if(!window.RTCStatsReport)return !1;return e.getStats()instanceof Sl}class aN{constructor(e){_p(this,"input",[]),_p(this,"size",void 0),this.size=e;}add(e){this.input.push(e),this.input.length>this.size&&this.input.splice(0,1);}diffMean(){return 0===this.input.length?0:(this.input[this.input.length-1]-this.input[0])/this.input.length}}const cN={address:"unknown",candidateType:"unknown",id:"unknown",port:0,priority:0,protocol:"unknown",type:"unknown"},dN={timestamp:0,bitrate:{actualEncoded:0,transmit:0},sendPacketLossRate:0,recvPacketLossRate:0,videoRecv:[],videoSend:[],audioRecv:[],audioSend:[],selectedCandidatePair:{id:"unknown",localCandidate:cN,remoteCandidate:cN}},uN={firsCount:0,nacksCount:0,plisCount:0,framesDecodeCount:0,framesDecodeInterval:0,framesDecodeFreezeTime:0,decodeFrameRate:0,bytes:0,packetsLost:0,packetLostRate:0,packets:0,ssrc:0,qpSumPerFrame:0},lN={firsCount:0,nacksCount:0,plisCount:0,frameCount:0,bytes:0,packets:0,packetsLost:0,packetLostRate:0,ssrc:0,rttMs:0,qpSumPerFrame:0},hN={bytes:0,packets:0,packetsLost:0,packetLostRate:0,ssrc:0,rttMs:0},pN={jitterBufferMs:0,jitterMs:0,bytes:0,packetsLost:0,packetLostRate:0,packets:0,ssrc:0,receivedFrames:0,droppedFrames:0,concealedSamples:0};function _N(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n);}return i}function EN(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?_N(Object(i),!0).forEach((function(t){_p(e,t,i[t]);})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):_N(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t));}));}return e}class mN{constructor(e,t){_p(this,"onFirstVideoReceived",void 0),_p(this,"onFirstVideoDecoded",void 0),_p(this,"onFirstAudioReceived",void 0),_p(this,"onFirstVideoDecodedTimeout",void 0),_p(this,"onFirstAudioDecoded",void 0),_p(this,"onSelectedLocalCandidateChanged",void 0),_p(this,"onSelectedRemoteCandidateChanged",void 0),_p(this,"videoIsReady",!1),_p(this,"videoIsReady2",{}),_p(this,"pc",void 0),_p(this,"options",void 0),_p(this,"intervalTimer",void 0),_p(this,"stats",nN(dN)),_p(this,"isFirstVideoReceived",{}),_p(this,"isFirstVideoDecoded",{}),_p(this,"isFirstAudioReceived",{}),_p(this,"isFirstAudioDecoded",{}),_p(this,"isFirstVideoDecodedTimeout",{}),_p(this,"lossRateWindowStats",[]),this.pc=e,this.options=t,this.intervalTimer=window.setInterval(async()=>{this.updateStats();},this.options.updateInterval);}getStats(){return this.stats}getSelectedCandidatePair(){return new Sl(e=>{e({local:EN({},cN),remote:EN({},cN)});})}setVideoIsReady(e){this.videoIsReady=e;}setVideoIsReady2(e,t){this.videoIsReady2[e]=t;}getVideoIsReady(e){return this.videoIsReady2[e]||!1}setIsFirstAudioDecoded(e){}destroy(){window.clearInterval(this.intervalTimer),this.pc=void 0;}calcLossRate(e){this.lossRateWindowStats.push(e),this.lossRateWindowStats.length>this.options.lossRateInterval&&this.lossRateWindowStats.splice(0,1);const t=this.lossRateWindowStats.length,i=["videoSend","audioSend","videoRecv","audioRecv"];let n=0,r=0,o=0,s=0;for(const a of i)e[a].forEach((e,i)=>{if(!this.lossRateWindowStats[t-1][a][i]||!this.lossRateWindowStats[0][a][i])return;const c=this.lossRateWindowStats[t-1][a][i].packets-this.lossRateWindowStats[0][a][i].packets,d=this.lossRateWindowStats[t-1][a][i].packetsLost-this.lossRateWindowStats[0][a][i].packetsLost;"videoSend"===a||"audioSend"===a?(n+=c,o+=d):(r+=c,s+=d),Number.isNaN(c)||Number.isNaN(c)?e.packetLostRate=0:e.packetLostRate=c<=0||d<=0?0:d/(c+d);});e.sendPacketLossRate=n<=0||o<=0?0:o/(n+o),e.recvPacketLossRate=r<=0||s<=0?0:s/(r+s);}}function fN(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n);}return i}function SN(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?fN(Object(i),!0).forEach((function(t){_p(e,t,i[t]);})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):fN(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t));}));}return e}class TN extends mN{constructor(){super(...arguments),_p(this,"_stats",dN),_p(this,"lastDecodeVideoReceiverStats",new Map);}async updateStats(){const e=await this._getStats(),t=this.statsResponsesToObjects(e);this._stats=nN(dN);const i=t.filter(e=>"ssrc"===e.type);this.processSSRCStats(i);const n=t.find(e=>"VideoBwe"===e.type);n&&this.processBandwidthStats(n),this._stats.timestamp=Date.now(),this.calcLossRate(this._stats),this.stats=this._stats;}processBandwidthStats(e){this._stats.bitrate={actualEncoded:Number(e.googActualEncBitrate),targetEncoded:Number(e.googTargetEncBitrate),retransmit:Number(e.googRetransmitBitrate),transmit:Number(e.googTransmitBitrate)},this._stats.sendBandwidth=Number(e.googAvailableSendBandwidth);}processSSRCStats(e){e.forEach(e=>{const t=e.id.includes("send");switch("".concat(e.mediaType,"_").concat(t?"send":"recv")){case"video_send":{const t=nN(lN);t.codec=e.googCodecName,t.adaptionChangeReason="none",e.googCpuLimitedResolution&&(t.adaptionChangeReason="cpu"),e.googBandwidthLimitedResolution&&(t.adaptionChangeReason="bandwidth"),t.avgEncodeMs=Number(e.googAvgEncodeMs),t.inputFrame={width:Number(e.googFrameWidthInput)||Number(e.googFrameWidthSent),height:Number(e.googFrameHeightInput)||Number(e.googFrameHeightSent),frameRate:Number(e.googFrameRateInput)},t.sentFrame={width:Number(e.googFrameWidthSent),height:Number(e.googFrameHeightSent),frameRate:Number(e.googFrameRateInput)},t.firsCount=Number(e.googFirReceived),t.nacksCount=Number(e.googNacksReceived),t.plisCount=Number(e.googPlisReceived),t.frameCount=Number(e.framesEncoded),t.bytes=Number(e.bytesSent),t.packets=Number(e.packetsSent),t.packetsLost=Number(e.packetsLost),t.ssrc=Number(e.ssrc),t.rttMs=Number(e.googRtt||0),this._stats.videoSend.push(t),this._stats.rtt=t.rttMs;break}case"video_recv":{const t=nN(uN),i=this.lastDecodeVideoReceiverStats.get(Number(e.ssrc));if(t.codec=e.googCodecName,t.targetDelayMs=Number(e.googTargetDelayMs),t.renderDelayMs=Number(e.googRenderDelayMs),t.currentDelayMs=Number(e.googCurrentDelayMs),t.minPlayoutDelayMs=Number(e.googMinPlayoutDelayMs),t.decodeMs=Number(e.googDecodeMs),t.maxDecodeMs=Number(e.googMaxDecodeMs),t.receivedFrame={width:Number(e.googFrameWidthReceived),height:Number(e.googFrameHeightReceived),frameRate:Number(e.googFrameRateReceived)},t.decodedFrame={width:Number(e.googFrameWidthReceived),height:Number(e.googFrameHeightReceived),frameRate:Number(e.googFrameRateDecoded)},t.decodeFrameRate=Number(e.googFrameRateDecoded),t.outputFrame={width:Number(e.googFrameWidthReceived),height:Number(e.googFrameHeightReceived),frameRate:Number(e.googFrameRateOutput)},t.jitterBufferMs=Number(e.googJitterBufferMs),t.firsCount=Number(e.googFirsSent),t.nacksCount=Number(e.googNacksSent),t.plisCount=Number(e.googPlisSent),t.framesDecodeCount=Number(e.framesDecoded),t.bytes=Number(e.bytesReceived),t.packets=Number(e.packetsReceived),t.packetsLost=Number(e.packetsLost),t.ssrc=Number(e.ssrc),t.packets>0&&!this.isFirstVideoReceived[t.ssrc]&&(this.onFirstVideoReceived&&this.onFirstVideoReceived(t.ssrc),this.isFirstVideoReceived[t.ssrc]=!0),t.framesDecodeCount>0&&!this.isFirstVideoDecoded[t.ssrc]&&(this.onFirstVideoDecoded&&this.onFirstVideoDecoded(t.ssrc,t.decodedFrame.width,t.decodedFrame.height),this.isFirstVideoDecoded[t.ssrc]=!0),i){const n=i.stats,r=Date.now()-i.lts;t.framesDecodeFreezeTime=n.framesDecodeFreezeTime,t.framesDecodeInterval=n.framesDecodeInterval,t.framesDecodeCount>n.framesDecodeCount&&this.isFirstVideoDecoded[t.ssrc]?(i.lts=Date.now(),t.framesDecodeInterval=r,t.framesDecodeInterval>=this.options.freezeRateLimit&&(this.getVideoIsReady(parseInt(e.ssrc,10))?t.framesDecodeFreezeTime+=t.framesDecodeInterval:this.setVideoIsReady2(parseInt(e.ssrc,10),!0))):t.framesDecodeCount<i.stats.framesDecodeCount&&(t.framesDecodeInterval=0);}this.lastDecodeVideoReceiverStats.set(t.ssrc,{stats:SN({},t),lts:Date.now()}),this._stats.videoRecv.push(t);break}case"audio_recv":{const t=nN(pN);t.codec=e.googCodecName,t.outputLevel=Math.abs(Number(e.audioOutputLevel))/32767,t.decodingCNG=Number(e.googDecodingCNG),t.decodingCTN=Number(e.googDecodingCTN),t.decodingCTSG=Number(e.googDecodingCTSG),t.decodingNormal=Number(e.googDecodingNormal),t.decodingPLC=Number(e.googDecodingPLC),t.decodingPLCCNG=Number(e.googDecodingPLCCNG),t.expandRate=Number(e.googExpandRate),t.accelerateRate=Number(e.googAccelerateRate),t.preemptiveExpandRate=Number(e.googPreemptiveExpandRate),t.secondaryDecodedRate=Number(e.googSecondaryDecodedRate),t.speechExpandRate=Number(e.googSpeechExpandRate),t.preferredJitterBufferMs=Number(e.googPreferredJitterBufferMs),t.jitterBufferMs=Number(e.googJitterBufferMs),t.jitterMs=Number(e.googJitterReceived),t.bytes=Number(e.bytesReceived),t.packets=Number(e.packetsReceived),t.packetsLost=Number(e.packetsLost),t.ssrc=Number(e.ssrc),t.receivedFrames=Number(e.googDecodingCTN)||Number(e.packetsReceived),t.droppedFrames=Number(e.googDecodingPLC)+Number(e.googDecodingPLCCNG)||Number(e.packetsLost),t.receivedFrames>0&&!this.isFirstAudioReceived[t.ssrc]&&(this.onFirstAudioReceived&&this.onFirstAudioReceived(t.ssrc),this.isFirstAudioReceived[t.ssrc]=!0),t.decodingNormal>0&&!this.isFirstAudioDecoded[t.ssrc]&&(this.onFirstAudioDecoded&&this.onFirstAudioDecoded(t.ssrc),this.isFirstAudioDecoded[t.ssrc]=!0),this._stats.audioRecv.push(t);break}case"audio_send":{const t=nN(hN);t.codec=e.googCodecName,t.inputLevel=Math.abs(Number(e.audioInputLevel))/32767,t.aecReturnLoss=Number(e.googEchoCancellationReturnLoss||0),t.aecReturnLossEnhancement=Number(e.googEchoCancellationReturnLossEnhancement||0),t.residualEchoLikelihood=Number(e.googResidualEchoLikelihood||0),t.residualEchoLikelihoodRecentMax=Number(e.googResidualEchoLikelihoodRecentMax||0),t.bytes=Number(e.bytesSent),t.packets=Number(e.packetsSent),t.packetsLost=Number(e.packetsLost),t.ssrc=Number(e.ssrc),t.rttMs=Number(e.googRtt||0),this._stats.rtt=t.rttMs,this._stats.audioSend.push(t);break}}});}_getStats(){return new Sl((e,t)=>{this.pc.getStats(e,t);})}statsResponsesToObjects(e){const t=[];return e.result().forEach(e=>{const i={id:e.id,timestamp:e.timestamp.valueOf().toString(),type:e.type};e.names().forEach(t=>{i[t]=e.stat(t);}),t.push(i);}),t}}function gN(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n);}return i}function RN(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?gN(Object(i),!0).forEach((function(t){_p(e,t,i[t]);})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):gN(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t));}));}return e}class IN extends mN{constructor(){super(...arguments),_p(this,"_stats",dN),_p(this,"report",void 0),_p(this,"lastDecodeVideoReceiverStats",new Map),_p(this,"lastVideoFramesRecv",new Map),_p(this,"lastVideoFramesSent",new Map),_p(this,"lastVideoFramesDecode",new Map),_p(this,"lastVideoJBDelay",new Map),_p(this,"lastAudioJBDelay",new Map),_p(this,"mediaBytesSent",new Map),_p(this,"mediaBytesRetransmit",new Map),_p(this,"mediaBytesTargetEncode",new Map),_p(this,"lastEncoderMs",new Map);}async updateStats(){this.report=await this.pc.getStats(),this._stats=nN(dN),this.report.forEach(e=>{switch(e.type){case kh.OUTBOUND:"audio"===e.mediaType?this.processAudioOutboundStats(e):"video"===e.mediaType&&this.processVideoOutboundStats(e);break;case kh.INBOUND:"audio"===e.mediaType?this.processAudioInboundStats(e):"video"===e.mediaType&&this.processVideoInboundStats(e);break;case kh.TRANSPORT:{const t=this.report.get(e.selectedCandidatePairId);t&&this.processCandidatePairStats(t);break}case kh.CANDIDATE_PAIR:e.selected&&this.processCandidatePairStats(e);}}),this.updateSendBitrate(),this._stats.timestamp=Date.now(),this.calcLossRate(this._stats),this.stats=this._stats;}async getSelectedCandidatePair(){const e=await this.pc.getStats(),t={local:RN({},cN),remote:RN({},cN)};return e.forEach(i=>{let n;if(i.type===kh.TRANSPORT&&(n=e.get(i.selectedCandidatePairId)),i.type===kh.CANDIDATE_PAIR&&i.selected&&(n=i),n){const i=(e,t)=>{e.type=t.type,e.id=t.id,t.address&&(e.address=t.address),t.candidateType&&(e.candidateType=t.candidateType),t.port&&(e.port=t.port),t.priority&&(e.priority=t.priority),t.protocol&&(e.protocol=t.protocol),t.relayProtocol&&(e.relayProtocol=t.relayProtocol);};if(n.localCandidateId){const r=e.get(n.localCandidateId);r&&i(t.local,r);}if(n.remoteCandidateId){const r=e.get(n.remoteCandidateId);r&&i(t.remote,r);}}}),t}processCandidatePairStats(e){if(this._stats.sendBandwidth=e.availableOutgoingBitrate||0,e.currentRoundTripTime&&(this._stats.rtt=1e3*e.currentRoundTripTime),this._stats.videoSend.forEach(t=>{e.currentRoundTripTime&&(t.rttMs=1e3*e.currentRoundTripTime);}),this._stats.audioSend.forEach(t=>{e.currentRoundTripTime&&(t.rttMs=1e3*e.currentRoundTripTime);}),this._stats.selectedCandidatePair.id=e.id,e.localCandidateId){const t=this.report.get(e.localCandidateId);t&&this.processCandidateStats(t);}if(e.remoteCandidateId){const t=this.report.get(e.remoteCandidateId);t&&this.processCandidateStats(t);}}processCandidateStats(e){let t;e.type===kh.LOCAL_CANDIDATE&&(t=this._stats.selectedCandidatePair.localCandidate),e.type===kh.REMOTE_CANDIDATE&&(t=this._stats.selectedCandidatePair.remoteCandidate),t&&(t.type=e.type,t.id=e.id,e.address&&(t.address=e.address),e.candidateType&&(t.candidateType=e.candidateType),e.port&&(t.port=e.port),e.priority&&(t.priority=e.priority),e.protocol&&(t.protocol=e.protocol),e.relayProtocol&&(t.relayProtocol=e.relayProtocol),e.type===kh.LOCAL_CANDIDATE&&this.stats.selectedCandidatePair.localCandidate.id!==t.id&&this.onSelectedLocalCandidateChanged&&this.onSelectedLocalCandidateChanged(RN({},t),RN({},this.stats.selectedCandidatePair.localCandidate)),e.type===kh.REMOTE_CANDIDATE&&this.stats.selectedCandidatePair.remoteCandidate.id!==t.id&&this.onSelectedRemoteCandidateChanged&&this.onSelectedRemoteCandidateChanged(RN({},t),RN({},this.stats.selectedCandidatePair.remoteCandidate)));}processAudioInboundStats(e){let t=this._stats.audioRecv.find(t=>t.ssrc===e.ssrc);t||(t=nN(pN),this._stats.audioRecv.push(t)),t.ssrc=e.ssrc,t.packets=e.packetsReceived,t.packetsLost=e.packetsLost,t.bytes=e.bytesReceived,t.jitterMs=1e3*e.jitter,this.processAudioTrackReceiverStats(e,e.trackId,t),e.codecId&&(t.codec=this.getCodecFromCodecStats(e.codecId)),t.receivedFrames||(t.receivedFrames=e.packetsReceived),t.droppedFrames||(t.droppedFrames=e.packetsLost),t.receivedFrames>0&&!this.isFirstAudioReceived[t.ssrc]&&(this.onFirstAudioReceived&&this.onFirstAudioReceived(t.ssrc),this.isFirstAudioReceived[t.ssrc]=!0),t.outputLevel&&t.outputLevel>0&&!this.isFirstAudioDecoded[t.ssrc]&&(this.onFirstAudioDecoded&&this.onFirstAudioDecoded(t.ssrc),this.isFirstAudioDecoded[t.ssrc]=!0),"number"==typeof e.concealedSamples&&(t.concealedSamples=e.concealedSamples);}processVideoInboundStats(e){let t=this._stats.videoRecv.find(t=>t.ssrc===e.ssrc);t||(t=nN(uN),this._stats.videoRecv.push(t)),t.ssrc=e.ssrc,t.packets=e.packetsReceived,t.packetsLost=e.packetsLost,t.bytes=e.bytesReceived,t.firsCount=e.firCount,t.nacksCount=e.nackCount,t.plisCount=e.pliCount,t.framesDecodeCount=e.framesDecoded,t.totalInterFrameDelay=e.totalInterFrameDelay,t.totalSquaredInterFrameDelay=e.totalSquaredInterFrameDelay;const i=this.lastDecodeVideoReceiverStats.get(t.ssrc),n=this.lastVideoFramesDecode.get(t.ssrc),r=Date.now();if(t.framesDecodeCount>0&&!this.isFirstVideoDecoded[t.ssrc]){const e=t.decodedFrame?t.decodedFrame.width:0,i=t.decodedFrame?t.decodedFrame.height:0;this.onFirstVideoDecoded&&this.onFirstVideoDecoded(t.ssrc,e,i),this.isFirstVideoDecoded[t.ssrc]=!0;}if(i){const n=i.stats,o=r-i.lts;t.framesDecodeFreezeTime=n.framesDecodeFreezeTime,t.framesDecodeInterval=n.framesDecodeInterval,!this.isFirstVideoDecoded[t.ssrc]&&o>this.options.firstVideoDecodedTimeout&&!this.isFirstVideoDecodedTimeout[t.ssrc]&&(this.onFirstVideoDecodedTimeout&&this.onFirstVideoDecodedTimeout(t.ssrc),this.isFirstVideoDecodedTimeout[t.ssrc]=!0),t.framesDecodeCount>n.framesDecodeCount&&this.isFirstVideoDecoded[t.ssrc]?(i.lts=Date.now(),t.framesDecodeInterval=o,t.framesDecodeInterval>=this.options.freezeRateLimit&&(this.getVideoIsReady(parseInt(e.ssrc))?t.framesDecodeFreezeTime+=t.framesDecodeInterval:this.setVideoIsReady2(parseInt(e.ssrc,10),!0))):t.framesDecodeCount<n.framesDecodeCount&&(t.framesDecodeInterval=0),e.framesDecoded&&e.qpSum&&(i.stats.framesDecodeCount>e.framesDecoded?t.qpSumPerFrame=e.qpSum/e.framesDecoded:t.qpSumPerFrame=(e.qpSum-i.qpSum)/(e.framesDecoded-i.stats.framesDecodeCount));}n&&r-n.lts>=800?(t.decodeFrameRate=Math.round((t.framesDecodeCount-n.count)/((r-n.lts)/1e3)),this.lastVideoFramesDecode.set(t.ssrc,{count:t.framesDecodeCount,lts:r,rate:t.decodeFrameRate})):n?t.decodeFrameRate=n.rate:this.lastVideoFramesDecode.set(t.ssrc,{count:t.framesDecodeCount,lts:r,rate:0}),e.totalDecodeTime&&(t.decodeMs=1e3*e.totalDecodeTime),this.processVideoTrackReceiverStats(e,e.trackId,t),e.codecId&&(t.codec=this.getCodecFromCodecStats(e.codecId)),e.framerateMean&&(t.framesRateFirefox=e.framerateMean),t.packets>0&&!this.isFirstVideoReceived[t.ssrc]&&(this.onFirstVideoReceived&&this.onFirstVideoReceived(t.ssrc),this.isFirstVideoReceived[t.ssrc]=!0),this.lastDecodeVideoReceiverStats.set(t.ssrc,{stats:RN({},t),lts:i?i.lts:Date.now(),qpSum:e.qpSum});}processVideoOutboundStats(e){let t=this._stats.videoSend.find(t=>t.ssrc===e.ssrc);t||(t=nN(lN),this._stats.videoSend.push(t));const i=this.mediaBytesSent.get(e.ssrc);if(i)i.add(e.bytesSent);else {const t=new aN(10);t.add(e.bytesSent),this.mediaBytesSent.set(e.ssrc,t);}if(void 0!==e.retransmittedBytesSent){const t=this.mediaBytesRetransmit.get(e.ssrc);if(t)t.add(e.retransmittedBytesSent);else {const t=new aN(10);t.add(e.retransmittedBytesSent),this.mediaBytesRetransmit.set(e.ssrc,t);}}if(e.totalEncodedBytesTarget){const t=this.mediaBytesTargetEncode.get(e.ssrc);if(t)t.add(e.totalEncodedBytesTarget);else {const t=new aN(10);t.add(e.totalEncodedBytesTarget),this.mediaBytesTargetEncode.set(e.ssrc,t);}}if(t.ssrc=e.ssrc,t.bytes=e.bytesSent,t.packets=e.packetsSent,t.firsCount=e.firCount,t.nacksCount=e.nackCount,t.plisCount=e.pliCount,t.frameCount=e.framesEncoded,t.adaptionChangeReason=e.qualityLimitationReason,t.scalabilityMode=e.scalabilityMode,e.totalEncodeTime&&e.framesEncoded){const i=this.lastEncoderMs.get(e.ssrc);if(!i||i.lastFrameCount>e.framesEncoded)t.avgEncodeMs=1e3*e.totalEncodeTime/e.framesEncoded;else {const n=e.framesEncoded-i.lastFrameCount,r=e.totalEncodeTime-i.lastEncoderTime;t.avgEncodeMs=1e3*r/n;}}if(e.framesEncoded&&e.qpSum){const i=this.lastEncoderMs.get(e.ssrc);!i||i.lastFrameCount>e.framesEncoded?t.qpSumPerFrame=e.qpSum/e.framesEncoded:t.qpSumPerFrame=(e.qpSum-i.lastQpSum)/(e.framesEncoded-i.lastFrameCount);}if(this.lastEncoderMs.set(e.ssrc,{lastFrameCount:e.framesEncoded,lastEncoderTime:e.totalEncodeTime,lastQpSum:e.qpSum,lts:Date.now()}),e.codecId&&(t.codec=this.getCodecFromCodecStats(e.codecId)),e.mediaSourceId&&this.processVideoMediaSource(e.mediaSourceId,t),this.processVideoTrackSenderStats(e,e.trackId,t),e.remoteId)this.processRemoteInboundStats(e.remoteId,t);else {const i=this.findRemoteStatsId(e.ssrc,kh.REMOTE_INBOUND);i&&this.processRemoteInboundStats(i,t);}}processAudioOutboundStats(e){let t=this._stats.audioSend.find(t=>t.ssrc===e.ssrc);if(t||(t=nN(hN),this._stats.audioSend.push(t)),t.ssrc=e.ssrc,t.packets=e.packetsSent,t.bytes=e.bytesSent,e.mediaSourceId&&this.processAudioMediaSource(e.mediaSourceId,t),e.codecId&&(t.codec=this.getCodecFromCodecStats(e.codecId)),this.processAudioTrackSenderStats(e,e.trackId,t),e.remoteId)this.processRemoteInboundStats(e.remoteId,t);else {const i=this.findRemoteStatsId(e.ssrc,kh.REMOTE_INBOUND);i&&this.processRemoteInboundStats(i,t);}}findRemoteStatsId(e,t){var i;const n=Array.from(IR(i=this.report).call(i)).find(i=>i.type===t&&i.ssrc===e);return n?n.id:null}processVideoMediaSource(e,t){const i=this.report.get(e);i&&i.width&&i.height&&i.framesPerSecond&&(t.inputFrame={width:i.width,height:i.height,frameRate:i.framesPerSecond});}processAudioMediaSource(e,t){const i=this.report.get(e);i&&(t.inputLevel=i.audioLevel);}processVideoTrackSenderStats(e,t,i){var n,r,o;const s=t?this.report.get(t):void 0,a=null!==(n=null==s?void 0:s.framesSent)&&void 0!==n?n:e.framesSent;let c=null!==(r=null==s?void 0:s.frameWidth)&&void 0!==r?r:e.frameWidth,d=null!==(o=null==s?void 0:s.frameHeight)&&void 0!==o?o:e.frameHeight;if("number"!=typeof a)return;"number"==typeof c&&"number"==typeof d||(c=0,d=0);let u=0;const l=Date.now(),h=this.lastVideoFramesSent.get(i.ssrc);h&&l-h.lts>=800?(u=Math.round((a-h.count)/((l-h.lts)/1e3)),this.lastVideoFramesSent.set(i.ssrc,{count:a,lts:l,rate:u})):h?u=h.rate:this.lastVideoFramesSent.set(i.ssrc,{count:a,lts:l,rate:0}),i.sentFrame={width:c,height:d,frameRate:Math.max(0,u)};}processVideoTrackReceiverStats(e,t,i){var n,r,o,s,a;const c=t?this.report.get(t):void 0,d=null!==(n=null==c?void 0:c.framesReceived)&&void 0!==n?n:e.framesReceived,u=null!==(r=null==c?void 0:c.frameWidth)&&void 0!==r?r:e.frameWidth,l=null!==(o=null==c?void 0:c.frameHeight)&&void 0!==o?o:e.frameHeight,h=null!==(s=null==c?void 0:c.jitterBufferDelay)&&void 0!==s?s:e.jitterBufferDelay,p=null!==(a=null==c?void 0:c.jitterBufferEmittedCount)&&void 0!==a?a:e.jitterBufferEmittedCount;if("number"==typeof d){const e=this.lastVideoFramesRecv.get(i.ssrc),t=Date.now();i.framesReceivedCount=d;let n=0;e&&t-e.lts>=800?(n=Math.round((d-e.count)/((t-e.lts)/1e3)),this.lastVideoFramesRecv.set(i.ssrc,{count:d,lts:t,rate:n})):e?n=e.rate:this.lastVideoFramesRecv.set(i.ssrc,{count:d,lts:t,rate:0}),i.receivedFrame={width:u||0,height:l||0,frameRate:n||0},i.decodedFrame={width:u||0,height:l||0,frameRate:i.decodeFrameRate||0},i.outputFrame={width:u||0,height:l||0,frameRate:i.decodeFrameRate||0};}if(h&&p){let e=this.lastVideoJBDelay.get(i.ssrc);this.lastVideoJBDelay.set(i.ssrc,{jitterBufferDelay:h,jitterBufferEmittedCount:p}),e||(e={jitterBufferDelay:0,jitterBufferEmittedCount:0});const t=1e3*(h-e.jitterBufferDelay)/(p-e.jitterBufferEmittedCount);i.jitterBufferMs=t,i.currentDelayMs=Math.round(t);}}processAudioTrackSenderStats(e,t,i){var n,r,o,s;const a=t?this.report.get(t):void 0,c=null!==(n=null!==(r=null==a?void 0:a.echoReturnLoss)&&void 0!==r?r:e.echoReturnLoss)&&void 0!==n?n:0,d=null!==(o=null!==(s=null==a?void 0:a.echoReturnLossEnhancement)&&void 0!==s?s:e.echoReturnLossEnhancement)&&void 0!==o?o:0;i.aecReturnLoss=c,i.aecReturnLossEnhancement=d;}processAudioTrackReceiverStats(e,t,i){var n,r,o,s,a,c,d;const u=t?this.report.get(t):void 0,l=null!==(n=null==u?void 0:u.removedSamplesForAcceleration)&&void 0!==n?n:e.removedSamplesForAcceleration,h=null!==(r=null==u?void 0:u.totalSamplesReceived)&&void 0!==r?r:e.totalSamplesReceived,p=null!==(o=null==u?void 0:u.jitterBufferDelay)&&void 0!==o?o:e.jitterBufferDelay,_=null!==(s=null==u?void 0:u.jitterBufferEmittedCount)&&void 0!==s?s:e.jitterBufferEmittedCount,E=null!==(a=null==u?void 0:u.audioLevel)&&void 0!==a?a:null==e?void 0:e.audioLevel,m=null!==(c=null==u?void 0:u.totalSamplesDuration)&&void 0!==c?c:null==e?void 0:e.totalSamplesDuration,f=null!==(d=null==u?void 0:u.concealedSamples)&&void 0!==d?d:e.concealedSamples;if(l&&h&&(i.accelerateRate=l/h),p&&_){let e=this.lastAudioJBDelay.get(i.ssrc);this.lastAudioJBDelay.set(i.ssrc,{jitterBufferDelay:p,jitterBufferEmittedCount:_}),e||(e={jitterBufferDelay:0,jitterBufferEmittedCount:0});const t=1e3*(p-e.jitterBufferDelay)/(_-e.jitterBufferEmittedCount);i.jitterBufferMs=Math.round(t);}i.outputLevel=E;let S=1920;m&&h&&(S=h/m/50,i.receivedFrames=Math.round(h/S)),f&&(i.droppedFrames=Math.round(f/S));}processRemoteInboundStats(e,t){const i=this.report.get(e);i&&(t.packetsLost=i.packetsLost,i.roundTripTime&&(t.rttMs=1e3*i.roundTripTime));}getCodecFromCodecStats(e){const t=this.report.get(e);if(!t)return "";const i=t.mimeType.match(/\/(.*)$/);return i&&i[1]?i[1]:""}updateSendBitrate(){let e=0,t=null,i=null;this.mediaBytesSent.forEach(t=>{e+=t.diffMean();}),this.mediaBytesRetransmit.forEach(e=>{t=null===t?e.diffMean():t+e.diffMean();}),this.mediaBytesTargetEncode.forEach(e=>{i=null===i?e.diffMean():i+e.diffMean();});const n=null!==t?e-t:e;this._stats.bitrate={actualEncoded:8*n/(this.options.updateInterval/1e3),transmit:8*e/(this.options.updateInterval/1e3)},null!==t&&(this._stats.bitrate.retransmit=8*t/(this.options.updateInterval/1e3)),null!==i&&(this._stats.bitrate.targetEncoded=8*i/(this.options.updateInterval/1e3));}}class CN extends mN{updateStats(){return Sl.resolve()}}function vN(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:250,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:8,n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:500,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1e4;const o=oN();return o?o<76?new TN(e,{updateInterval:t,lossRateInterval:i,freezeRateLimit:n,firstVideoDecodedTimeout:r}):new IN(e,{updateInterval:t,lossRateInterval:i,freezeRateLimit:n,firstVideoDecodedTimeout:r}):sN(e)?new IN(e,{updateInterval:t,lossRateInterval:i,freezeRateLimit:n,firstVideoDecodedTimeout:r}):new CN(e,{updateInterval:t,lossRateInterval:i,freezeRateLimit:n,firstVideoDecodedTimeout:r})}var yN;function AN(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n);}return i}function ON(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?AN(Object(i),!0).forEach((function(t){_p(e,t,i[t]);})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):AN(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t));}));}return e}let NN=(ag((yN=class e extends YS{get peerConnectionState(){return this.peerConnection.connectionState}get iceConnectionState(){return this.peerConnection.iceConnectionState}get currentLocalDescription(){return this.peerConnection.currentLocalDescription}get currentRemoteDescription(){return this.peerConnection.currentRemoteDescription}constructor(t,i){super(t,i),_p(this,"store",void 0),_p(this,"peerConnection",void 0),_p(this,"remoteSDP",void 0),_p(this,"initialOffer",void 0),_p(this,"statsFilter",void 0),_p(this,"useRTX",!1),_p(this,"localCapabilities",void 0),_p(this,"localCandidateCount",0),_p(this,"allCandidatesReceived",!1),_p(this,"establishPromise",void 0),_p(this,"mutex",new Ug("P2PConnection-mutex")),this.store=i,this.peerConnection=new RTCPeerConnection(e.resolvePCConfiguration(t),{optional:[{googDscp:!0}]}),this.statsFilter=vN(this.peerConnection,GE("STATS_UPDATE_INTERVAL"),void 0,Kh()?1200:void 0),this.bindPCEvents(),this.bindStatsEvents(),this.store.p2pId=this.store.p2pId+1,this.establishPromise=this.establish();}async establish(){try{const e=await this.peerConnection.createOffer({offerToReceiveAudio:!0,offerToReceiveVideo:!0});if(!e.sdp)throw new Error("Cannot get initialOffer.sdp when trying to establish PeerConnection.");const t=FO(e.sdp),i=jO(e.sdp,!this.useRTX,GE("FILTER_VIDEO_FEC"),GE("FILTER_AUDIO_FEC"),["opus"]);return this.localCapabilities=i,this.initialOffer=e,ON(ON({},t),{},{rtpCapabilities:{send:{audioCodecs:[],audioExtensions:[],videoCodecs:[],videoExtensions:[]},recv:{audioCodecs:[],audioExtensions:[],videoCodecs:[],videoExtensions:[]},sendrecv:i},offerSDP:e.sdp})}catch(e){throw new SE(fE.GET_LOCAL_CONNECTION_PARAMS_FAILED,e.toString())}}async connect(e,t,i,n,r,o){try{if(!this.initialOffer)throw new Error("Cannot establish P2PConnection without initial offer.");this.remoteSDP=new iN({remoteIceParameters:e,remoteDtlsParameters:t,candidates:i,remoteRTPCapabilities:n.send,remoteSetup:r,localCapabilities:this.localCapabilities,sdkCodec:this.store.codec,cname:o});const s=this.remoteSDP.toString();await this.peerConnection.setLocalDescription(this.initialOffer),await this.peerConnection.setRemoteDescription({type:"answer",sdp:s});}catch(e){throw new SE(fE.EXCHANGE_SDP_FAILED,"P2PConnection.connect failed; ".concat(e.toString()))}}send(e,t){var i=this;return DO((function*(){const n=yield PO(i.mutex.lock());try{if(!i.remoteSDP)throw new Error("Cannot call P2PConnection.send before remote SDP created");const r=e.map(e=>i.peerConnection.addTrack(e._mediaStreamTrack)),o=yield PO(i.peerConnection.createOffer()),s=UO.exports.parse(o.sdp),a=e.map(e=>{const t=e._mediaStreamTrack,n=s.mediaDescriptions.find(e=>e.attributes.mid===t.kind);if(!n)throw new Error("Cannot extract ssrc from mediaDescription.");return function(e,t,i){const n=e.attributes.ssrcs.filter(e=>e.attributes.label===t),r=e.attributes.ssrcGroups;if(0===n.length)throw new Error("Cannot extract ssrc from plan-b SDP.");if(r&&n.length>1){const e=r.find(e=>-1!==e.ssrcIds.indexOf(n[0].ssrcId));return e?[{ssrcId:e.ssrcIds[0],rtx:i?e.ssrcIds[1]:void 0}]:[{ssrcId:n[0].ssrcId}]}return [{ssrcId:n[0].ssrcId}]}(n,t.id,i.useRTX)});let c;try{c=yield a;}catch(e){throw r.forEach(e=>{Hh()&&e.replaceTrack(null),i.peerConnection.removeTrack(e);}),e}const d=i.mungSendOfferSDP(o.sdp,e);i.remoteSDP.receive(e,t,c);const u=i.remoteSDP.toString();return yield PO(i.peerConnection.setLocalDescription({type:"offer",sdp:d})),yield PO(i.applySendEncodings(r,e)),yield PO(i.peerConnection.setRemoteDescription({type:"answer",sdp:u})),e.map((e,t)=>{const i=e._mediaStreamTrack.id;return {localSSRC:a[t],id:i}})}catch(e){throw new SE(fE.EXCHANGE_SDP_FAILED,"P2PConnection.send failed; ".concat(e.toString()))}finally{n();}}))()}async stopSending(e){try{if(!this.remoteSDP)throw new Error("Cannot call P2PConnection.stopSending before remote SDP created");const t=this.peerConnection.getSenders().filter(t=>{var i;return -1!==e.indexOf((null===(i=t.track)||void 0===i?void 0:i.id)||"")});if(t.length!==e.length)throw new Error("Transceivers' length doesn't match mids' length when trying to call P2PConnection.stopSending.");t.map(e=>{Hh()&&e.replaceTrack(null),this.peerConnection.removeTrack(e);});const i=await this.peerConnection.createOffer();await this.peerConnection.setLocalDescription(i),this.remoteSDP.stopReceiving(e);const n=this.remoteSDP.toString();await this.peerConnection.setRemoteDescription({type:"answer",sdp:n});}catch(e){throw new SE(fE.EXCHANGE_SDP_FAILED,"P2PConnection.stopSending failed; ".concat(e.toString()))}}async receive(e,t,i,n){try{if(!this.remoteSDP)throw new Error("Cannot call P2PConnection.receive ".concat(e," before remoteSDP created."));const{id:i,mslabel:r}=this.remoteSDP.send(e,t,n),o=new Sl((t,n)=>{const o=setTimeout(()=>{n(new Error("Cannot receive track, id: ".concat(i)));},1e4),s=n=>{const a=xh();if(("Safari"===a.name&&11===Number(a.version)||Yh())&&n.track.id!==i&&n.streams[0].id===r){var c;const r=n.streams[0].getTracks()[0];return null===(c=this.remoteSDP)||void 0===c||c.updateTrackLabel(e,i,n.track.id),this.peerConnection.removeEventListener("track",s),clearTimeout(o),void t(r)}if(n.track.id===i)return this.peerConnection.removeEventListener("track",s),clearTimeout(o),void t(n.track)};this.peerConnection.addEventListener("track",s);}),s=this.remoteSDP.toString();await this.peerConnection.setRemoteDescription({type:"offer",sdp:s});const a=await this.peerConnection.createAnswer();await this.peerConnection.setLocalDescription(a);return {track:await o,id:i}}catch(e){throw new SE(fE.EXCHANGE_SDP_FAILED,"P2PConnection.receive failed; ".concat(e.toString()))}}async stopReceiving(e){try{if(!this.remoteSDP)throw new Error("Cannot call P2PConnection.stopReceiving before remote SDP created.");this.remoteSDP.stopSending(e);const t=this.remoteSDP.toString();await this.peerConnection.setRemoteDescription({type:"offer",sdp:t});const i=await this.peerConnection.createAnswer();await this.peerConnection.setLocalDescription(i);}catch(e){throw new SE(fE.EXCHANGE_SDP_FAILED,"P2PConnection stopReceiving failed; ".concat(e.toString()))}}async muteRemote(e){}async unmuteRemote(e){}async muteLocal(e){try{if(!this.remoteSDP)throw new Error("Cannot call P2PConnection.muteLocal before remote SDP created.");const t=this.peerConnection.getSenders().filter(t=>{var i;return -1!==e.indexOf((null===(i=t.track)||void 0===i?void 0:i.id)||"")});if(t.length!==e.length)throw new Error("sender' length doesn't match mids' length.");t.map(e=>{if(Hh()&&e.track)e.track.enabled=!1;else {const t=e.getParameters();t.encodings.forEach(e=>e.active=!1),e.setParameters(t);}});}catch(e){throw new SE(fE.EXCHANGE_SDP_FAILED,"P2PConnection.muteLocal failed; ".concat(e.toString()))}}async unmuteLocal(e){try{if(!this.remoteSDP)throw new Error("Cannot call P2PConnection.unmuteLocal before remote SDP created.");const t=this.peerConnection.getSenders().filter(t=>{var i;return -1!==e.indexOf((null===(i=t.track)||void 0===i?void 0:i.id)||"")});if(t.length!==e.length)throw new Error("Senders' length doesn't match mids' length.");t.map(async e=>{if(Hh()&&e.track)e.track.enabled=!0;else {const t=e.getParameters();t.encodings.forEach(e=>e.active=!0),await e.setParameters(t);}});const i=await this.peerConnection.createOffer();await this.peerConnection.setLocalDescription(i);const n=this.remoteSDP.toString();await this.peerConnection.setRemoteDescription({type:"answer",sdp:n});}catch(e){throw new SE(fE.EXCHANGE_SDP_FAILED,"P2PConnection.unmuteLocal failed; ".concat(e.toString()))}}restartICE(e){var t=this;return DO((function*(){const i=yield PO(t.mutex.lock("From P2PConnection.restartICE"));try{if(!t.remoteSDP)throw new Error("Cannot restartICE before remoteSDP created.");if(JS().supportPCSetConfiguration){const i=t.peerConnection.getConfiguration(),n=e===OS.RELAY?"relay":"all";i.iceTransportPolicy!==n&&(OE.debug("[".concat(t.store.clientId,"] restartICE change iceTransportPolicy from [").concat(i.iceTransportPolicy,"] to [").concat(n,"]")),i.iceTransportPolicy=n,t.peerConnection.setConfiguration(i));}else if(e===OS.RELAY)return;e!==OS.RELAY&&t.remoteSDP.updateCandidates(e);const n=yield PO(t.peerConnection.createOffer({iceRestart:!0}));if(!n.sdp)throw new Error("Cannot restartICE because restart offer SDP does not exist.");const r=FO(n.sdp),{remoteIceParameters:o}=yield r.iceParameters;t.remoteSDP.restartICE(o);const s=t.remoteSDP.toString();yield PO(t.peerConnection.setLocalDescription(n)),yield PO(t.peerConnection.setRemoteDescription({type:"answer",sdp:s}));}catch(e){OE.warning("[".concat(t.store.clientId,"] restart ICE failed, abort operation"),e);}finally{i();}}))()}close(){var e;this.peerConnection.close(),null===(e=this.onConnectionStateChange)||void 0===e||e.call(this,"closed"),this.unbindPCEvents(),this.unbindStatsEvents(),this.removeAllListeners(),this.statsFilter.destroy();}getStats(){return this.statsFilter.getStats()}getRemoteVideoIsReady(e){return this.statsFilter.getVideoIsReady(e)}async updateEncoderConfig(e,t){try{if(!this.remoteSDP)throw new Error("Cannot call P2PConnection.updateEncoderConfig before remote SDP created.");const e=await this.peerConnection.createOffer(),i=this.mungSendOfferSDP(e.sdp,[t]);this.remoteSDP.updateRecvMedia(t._mediaStreamTrack.kind,t);const n=this.remoteSDP.toString();await this.peerConnection.setLocalDescription({type:"offer",sdp:i}),await this.peerConnection.setRemoteDescription({type:"answer",sdp:n});}catch(e){throw new SE(fE.EXCHANGE_SDP_FAILED,e.toString())}}async updateSendParameters(e,t){const i=this.peerConnection.getSenders().filter(t=>{var i;return (null===(i=t.track)||void 0===i?void 0:i.id)===e});1===i.length&&await this.applySendEncodings(i,[t]);}setStatsRemoteVideoIsReady(e,t){this.statsFilter.setVideoIsReady2(e,t);}async replaceTrack(e,t){const i=this.peerConnection.getSenders().find(e=>{var i;return (null===(i=e.track)||void 0===i?void 0:i.id)===t});i&&await i.replaceTrack(e._mediaStreamTrack);}bindPCEvents(){this.peerConnection.oniceconnectionstatechange=()=>{var e;null===(e=this.onICEConnectionStateChange)||void 0===e||e.call(this,this.peerConnection.iceConnectionState);},this.peerConnection.onconnectionstatechange=()=>{var e;null===(e=this.onConnectionStateChange)||void 0===e||e.call(this,this.peerConnection.connectionState);},this.peerConnection.onicecandidate=e=>{e.candidate?this.localCandidateCount+=1:(this.peerConnection.onicecandidate=null,this.allCandidatesReceived=!0,OE.debug("[".concat(this.store.clientId,"] [pc-").concat(this.store.p2pId,"] local candidate count"),this.localCandidateCount));},setTimeout(()=>{this.allCandidatesReceived||(this.allCandidatesReceived=!0,OE.debug("[".concat(this.store.clientId,"] [pc-").concat(this.store.p2pId,"] onicecandidate timeout, local candidate count"),this.localCandidateCount));},GE("CANDIDATE_TIMEOUT"));}unbindPCEvents(){this.peerConnection.oniceconnectionstatechange=null,this.peerConnection.onconnectionstatechange=null,this.peerConnection.onsignalingstatechange=null,this.peerConnection.onicecandidateerror=null,this.peerConnection.onicecandidate=null,this.peerConnection.ontrack=null;}static resolvePCConfiguration(t){const i={iceServers:[],sdpSemantics:"plan-b"};return t.iceServers?i.iceServers=t.iceServers:t.turnServer&&"off"!==t.turnServer.mode&&(Uf(t.turnServer.servers)?i.iceServers=t.turnServer.servers:(i.iceServers&&i.iceServers.push(...e.turnServerConfigToIceServers(t.turnServer.servers)),GE("USE_TURN_SERVER_OF_GATEWAY")&&i.iceServers&&t.turnServer.serversFromGateway&&i.iceServers.push(...e.turnServerConfigToIceServers(t.turnServer.serversFromGateway)),t.turnServer.servers.concat(t.turnServer.serversFromGateway||[]).forEach(e=>{e.forceturn&&(i.iceTransportPolicy="relay");}))),i}static turnServerConfigToIceServers(e){const t=[];return e.forEach(e=>{e.security?e.tcpport&&t.push({username:e.username,credential:e.password,credentialType:"password",urls:"turns:".concat(e.turnServerURL,":").concat(e.tcpport,"?transport=tcp")}):(e.udpport&&t.push({username:e.username,credential:e.password,credentialType:"password",urls:"turn:".concat(e.turnServerURL,":").concat(e.udpport,"?transport=udp")}),e.tcpport&&t.push({username:e.username,credential:e.password,credentialType:"password",urls:"turn:".concat(e.turnServerURL,":").concat(e.tcpport,"?transport=tcp")}));}),t}async applySendEncodings(e,t){try{if(!JS().supportSetRtpSenderParameters)return;if(e.length!==t.length)return;for(let n=0;n<e.length;n++){var i;const r=e[n],o=t[n];if(!o)continue;const s={},a={};if(o instanceof Cy)switch(o._optimizationMode){case"motion":s.degradationPreference="maintain-framerate";break;case"detail":s.degradationPreference="maintain-resolution";break;default:s.degradationPreference="balanced";}if(GE("DSCP_TYPE")&&rp()){const e=GE("DSCP_TYPE");["very-low","low","medium","high"].includes(e)&&(a.networkPriority=e);}const c=r.getParameters(),d=null===(i=c.encodings)||void 0===i?void 0:i[0];d&&Object.assign(d,a),Object.assign(c,s),await r.setParameters(c);}}catch(e){OE.debug("[".concat(this.store.clientId,"] Apply RTPSendEncodings failed."));}}mungSendOfferSDP(e,t){const i=UO.exports.parse(e);return t.forEach((e,t)=>{const n=e._mediaStreamTrack,r=i.mediaDescriptions.find(e=>e.attributes.mid===n.kind);r&&HO(r,e);}),UO.exports.print(i)}bindStatsEvents(){this.statsFilter.onFirstAudioReceived=e=>{var t;null===(t=this.onFirstAudioReceived)||void 0===t||t.call(this,e);},this.statsFilter.onFirstVideoReceived=e=>{var t;null===(t=this.onFirstVideoReceived)||void 0===t||t.call(this,e);},this.statsFilter.onFirstAudioDecoded=e=>{var t;null===(t=this.onFirstAudioDecoded)||void 0===t||t.call(this,e);},this.statsFilter.onFirstVideoDecoded=(e,t,i)=>{var n;null===(n=this.onFirstVideoDecoded)||void 0===n||n.call(this,e,t,i);},this.statsFilter.onSelectedLocalCandidateChanged=(e,t)=>{var i;null===(i=this.onSelectedLocalCandidateChanged)||void 0===i||i.call(this,e,t);},this.statsFilter.onSelectedRemoteCandidateChanged=(e,t)=>{var i;null===(i=this.onSelectedRemoteCandidateChanged)||void 0===i||i.call(this,e,t);};}unbindStatsEvents(){this.statsFilter.onFirstAudioReceived=void 0,this.statsFilter.onFirstVideoReceived=void 0,this.statsFilter.onFirstAudioDecoded=void 0,this.statsFilter.onFirstVideoDecoded=void 0,this.statsFilter.onSelectedLocalCandidateChanged=void 0,this.statsFilter.onSelectedRemoteCandidateChanged=void 0;}async batchReceive(e){try{if(!this.remoteSDP)throw new Error("Cannot call P2PConnection.batchReceive before remoteSDP created.");const t=this.remoteSDP.batchSend(e).map((t,i)=>{let{id:n,mslabel:r}=t;const{kind:o}=e[i];return new Sl((e,t)=>{const i=setTimeout(()=>{t(new Error("Cannot receive track, id: ".concat(n)));},1e4),s=t=>{const a=xh();if("Safari"===a.name&&11===Number(a.version)&&t.track.id!==n&&t.streams[0].id===r){var c;const r=t.streams[0].getTracks()[0];return null===(c=this.remoteSDP)||void 0===c||c.updateTrackLabel(o,n,t.track.id),this.peerConnection.removeEventListener("track",s),clearTimeout(i),void e({track:r,id:n})}if(t.track.id===n)return this.peerConnection.removeEventListener("track",s),clearTimeout(i),void e({track:t.track,id:n})};this.peerConnection.addEventListener("track",s);})}),i=this.remoteSDP.toString();await this.peerConnection.setRemoteDescription({type:"offer",sdp:i});const n=await this.peerConnection.createAnswer();return await this.peerConnection.setLocalDescription(n),await Sl.all(t)}catch(e){throw new SE(fE.EXCHANGE_SDP_FAILED,"P2PConnection.receive failed; ".concat(e.toString()))}}async getRemoteSSRC(e){if(!this.remoteSDP)return;const t=this.remoteSDP.getSSRC(e);return null==t?void 0:t[0].ssrcId}setConfiguration(t){if(JS().supportPCSetConfiguration){const i=e.resolvePCConfiguration(t);this.peerConnection.setConfiguration(i);}}}).prototype,"connect",[bN],Object.getOwnPropertyDescriptor(yN.prototype,"connect"),yN.prototype),ag(yN.prototype,"stopSending",[bN],Object.getOwnPropertyDescriptor(yN.prototype,"stopSending"),yN.prototype),ag(yN.prototype,"receive",[bN],Object.getOwnPropertyDescriptor(yN.prototype,"receive"),yN.prototype),ag(yN.prototype,"stopReceiving",[bN],Object.getOwnPropertyDescriptor(yN.prototype,"stopReceiving"),yN.prototype),ag(yN.prototype,"muteRemote",[bN],Object.getOwnPropertyDescriptor(yN.prototype,"muteRemote"),yN.prototype),ag(yN.prototype,"unmuteRemote",[bN],Object.getOwnPropertyDescriptor(yN.prototype,"unmuteRemote"),yN.prototype),ag(yN.prototype,"muteLocal",[bN],Object.getOwnPropertyDescriptor(yN.prototype,"muteLocal"),yN.prototype),ag(yN.prototype,"unmuteLocal",[bN],Object.getOwnPropertyDescriptor(yN.prototype,"unmuteLocal"),yN.prototype),ag(yN.prototype,"close",[bN],Object.getOwnPropertyDescriptor(yN.prototype,"close"),yN.prototype),ag(yN.prototype,"updateEncoderConfig",[bN],Object.getOwnPropertyDescriptor(yN.prototype,"updateEncoderConfig"),yN.prototype),ag(yN.prototype,"updateSendParameters",[bN],Object.getOwnPropertyDescriptor(yN.prototype,"updateSendParameters"),yN.prototype),ag(yN.prototype,"replaceTrack",[bN],Object.getOwnPropertyDescriptor(yN.prototype,"replaceTrack"),yN.prototype),ag(yN.prototype,"getRemoteSSRC",[bN],Object.getOwnPropertyDescriptor(yN.prototype,"getRemoteSSRC"),yN.prototype),yN);function bN(e,t,i){const n=e[t];if("function"!=typeof n)throw new Error("Cannot use mutex on object property.");return i.value=async function(){const e=this.mutex,i=await e.lock("Locking from P2PConnection.".concat(t));try{for(var r=arguments.length,o=new Array(r),s=0;s<r;s++)o[s]=arguments[s];return await n.apply(this,o)}finally{i();}},i}function wN(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n);}return i}function DN(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?wN(Object(i),!0).forEach((function(t){_p(e,t,i[t]);})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):wN(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t));}));}return e}const PN="9",LN=4e4;class kN{get localCapabilities(){return uC(this._localCapabilities)}get rtpCapabilities(){return uC(this._rtpCapabilities)}get candidates(){return uC(this._candidates)}get iceParameters(){return uC(this._iceParameters)}get dtlsParameters(){return uC(this._dtlsParameters)}constructor(e){_p(this,"sessionDesc",void 0),_p(this,"_localCapabilities",void 0),_p(this,"_rtpCapabilities",void 0),_p(this,"_candidates",void 0),_p(this,"_iceParameters",void 0),_p(this,"_dtlsParameters",void 0),_p(this,"setup",void 0),_p(this,"currentMidIndex",void 0),_p(this,"cname",void 0),_p(this,"firefoxSsrcMidMap",new Map),e=uC(e);const{remoteIceParameters:t,remoteDtlsParameters:i,candidates:n,remoteRTPCapabilities:r,remoteSetup:o,localCapabilities:s,cname:a}=e,c=UO.exports.parse("v=0\no=- 0 0 IN IP4 127.0.0.1\ns=AgoraGateway\nt=0 0\na=group:BUNDLE 0 1\na=msid-semantic: WMS\na=ice-lite\nm=video 9 UDP/TLS/RTP/SAVPF 0\nc=IN IP4 127.0.0.1\na=rtcp:9 IN IP4 0.0.0.0\na=sendonly\na=rtcp-mux\na=rtcp-rsize\na=mid:0\nm=audio 9 UDP/TLS/RTP/SAVPF 0\nc=IN IP4 127.0.0.1\na=rtcp:9 IN IP4 0.0.0.0\na=sendonly\na=rtcp-mux\na=rtcp-rsize\na=mid:1\n");this._rtpCapabilities=r,this._candidates=n,this._iceParameters=t,this._dtlsParameters=i,this._localCapabilities=s,this.setup=o,this.cname=a;const d=this.rtpCapabilities.send;for(const e of c.mediaDescriptions){if(e.attributes.iceUfrag=t.iceUfrag,e.attributes.icePwd=t.icePwd,e.attributes.fingerprints=i.fingerprints,e.attributes.candidates=n,e.attributes.setup=o,"video"===e.media.mediaType&&(e.media.fmts=d.videoCodecs.map(e=>e.payloadType.toString(10)),e.attributes.payloads=d.videoCodecs,e.attributes.extmaps=d.videoExtensions,GE("PRELOAD_MEDIA_COUNT")>0)){const{ssrcs:t,ssrcGroups:i}=WO([{ssrcId:LN,rtx:GE("USE_SUB_RTX")?40001:void 0}],this.cname);e.attributes.ssrcs=t,e.attributes.ssrcGroups=i;}if("audio"===e.media.mediaType&&(e.media.fmts=d.audioCodecs.map(e=>e.payloadType.toString(10)),e.attributes.payloads=d.audioCodecs,e.attributes.extmaps=d.audioExtensions,$O(e),GE("PRELOAD_MEDIA_COUNT")>0)){const{ssrcs:t,ssrcGroups:i}=WO([{ssrcId:2e4}],this.cname);e.attributes.ssrcs=t,e.attributes.ssrcGroups=i;}}this.sessionDesc=c,this.currentMidIndex=c.mediaDescriptions.length-1;}preloadRemoteMedia(){const e=GE("PRELOAD_MEDIA_COUNT");this.rtpCapabilities;const t=this.candidates,i=this.dtlsParameters,n=this.iceParameters,r=this.rtpCapabilities.send;for(let o=1;o<e;o++){const e=2*o+2e4,s=2*o+LN,{ssrcs:a,ssrcGroups:c}=WO([{ssrcId:e}],this.cname),{ssrcs:d,ssrcGroups:u}=WO([{ssrcId:s,rtx:GE("USE_SUB_RTX")?s+1:void 0}],this.cname);this.sessionDesc.mediaDescriptions.push({media:{mediaType:"video",port:PN,protos:["UDP","TLS","RTP","SAVPF"],fmts:r.videoCodecs.map(e=>e.payloadType.toString(10))},connections:[{nettype:"IN",addrtype:"IP4",address:"127.0.0.1"}],bandwidths:[],attributes:{iceUfrag:n.iceUfrag,icePwd:n.icePwd,unrecognized:[],candidates:t,extmaps:r.videoExtensions,fingerprints:i.fingerprints,imageattr:[],msids:[],remoteCandidatesList:[],rids:[],ssrcs:d,ssrcGroups:u,rtcpFeedbackWildcards:[],payloads:r.videoCodecs,rtcp:{port:"9",netType:"IN",addressType:"IP4",address:"0.0.0.0"},setup:this.setup,direction:"sendonly",rtcpMux:!0,rtcpRsize:!0,mid:"".concat(2*o)}}),this.sessionDesc.mediaDescriptions.push({media:{mediaType:"audio",port:PN,protos:["UDP","TLS","RTP","SAVPF"],fmts:r.audioCodecs.map(e=>e.payloadType.toString(10))},connections:[{nettype:"IN",addrtype:"IP4",address:"127.0.0.1"}],bandwidths:[],attributes:{iceUfrag:n.iceUfrag,icePwd:n.icePwd,unrecognized:[],candidates:t,extmaps:r.audioExtensions,fingerprints:i.fingerprints,imageattr:[],msids:[],remoteCandidatesList:[],rids:[],ssrcs:a,ssrcGroups:c,rtcpFeedbackWildcards:[],payloads:r.audioCodecs,rtcp:{port:"9",netType:"IN",addressType:"IP4",address:"0.0.0.0"},setup:this.setup,direction:"sendonly",rtcpMux:!0,rtcpRsize:!0,mid:"".concat(2*o+1)}}),this.currentMidIndex+=2;}this.updateBundleMids();}toString(){return UO.exports.print(this.sessionDesc)}send(e,t,i,n){const{ssrcs:r,ssrcGroups:o}=WO(t,this.cname,GE("SYNC_GROUP")?i:void 0),s=this.findPreloadMediaDesc(r);if(s){if(Kh()&&this.firefoxSsrcMidMap.set(r[0].ssrcId,s.attributes.mid),n&&(n.twcc||n.remb)){const e=this.sessionDesc.mediaDescriptions.indexOf(s);return this.sessionDesc.mediaDescriptions[e]=this.mungSendMediaDesc(s,n),{mid:s.attributes.mid,needExchangeSDP:!0}}return {mid:s.attributes.mid,needExchangeSDP:!1}}{const t=this.findAvailableMediaIndex(e,r);let i;return -1===t||1===t&&(Hh()||zh())||0===t&&GE("USE_SUB_RTX")||Qh()?(i=this.createOrRecycleSendMedia(e,r,o,"sendonly",n),this.updateBundleMids()):(i=uC(this.sessionDesc.mediaDescriptions[t]),i.attributes.direction="sendonly",i.attributes.ssrcs=r,i.attributes.ssrcGroups=o,this.sessionDesc.mediaDescriptions[t]=this.mungSendMediaDesc(i,n)),Kh()&&this.firefoxSsrcMidMap.set(r[0].ssrcId,i.attributes.mid),{mid:i.attributes.mid,needExchangeSDP:!0}}}batchSend(e){const t=e.map(e=>{let{kind:t,ssrcMsg:i,mslabel:n}=e;return this.send(t,i,n)}),i=[];let n=!1;return t.forEach(e=>{let{mid:t,needExchangeSDP:r}=e;r&&(n=!0),i.push(t);}),{mids:i,needExchangeSDP:n}}stopSending(e){const t=this.sessionDesc.mediaDescriptions.filter(t=>t.attributes.mid&&-1!==e.indexOf(t.attributes.mid));if(t.length!==e.length)throw new Error("mediaDescriptions' length doesn't match mids' length when calling RemoteSDP.stopSending.");t.forEach(e=>{"0"===e.attributes.mid||Kh()||Qh()?e.attributes.ssrcs=[]:(e.attributes.ssrcs=[],e.attributes.direction="inactive",e.media.port="0");}),this.updateBundleMids();}mute(e){const t=this.sessionDesc.mediaDescriptions.find(t=>t.attributes.mid===e);if(!t)throw new Error("mediaDescription not found with ".concat(e," in remote SDP when calling RemoteSDP.mute."));t.attributes.direction="inactive";}unmute(e){const t=this.sessionDesc.mediaDescriptions.find(t=>t.attributes.mid===e);if(!t)throw new Error("mediaDescription not found with ".concat(e," in remote SDP when calling RemoteSDP.unmute."));t.attributes.direction="sendonly";}muteRemote(e){const t=this.sessionDesc.mediaDescriptions.filter(t=>e.includes(t.attributes.mid||""));if(t.length!==e.length)throw new Error("mediaDescriptions' length doesn't match mids' length when calling RemoteSDP.muteRemote.");t.forEach(e=>{e.attributes.direction="inactive";});}unmuteRemote(e){const t=this.sessionDesc.mediaDescriptions.filter(t=>e.includes(t.attributes.mid||""));if(t.length!==e.length)throw new Error("mediaDescriptions' length doesn't match mids' length when calling RemoteSDP.muteRemote.");t.forEach(e=>{e.attributes.direction="recvonly";});}receive(e,t,i,n){e.forEach((e,r)=>{this.createOrRecycleRecvMedia(e,[],"recvonly",t,i,n[r]);}),this.updateBundleMids();}stopReceiving(e){const t=this.sessionDesc.mediaDescriptions.filter(t=>-1!==e.indexOf(t.attributes.mid));if(t.length!==e.length)throw new Error("MediaDescriptions' length doesn't match mids's length when calling RemoteSDP.receive.");t.forEach(e=>{e.media.port="0",e.attributes.direction="inactive";}),this.updateBundleMids();}updateCandidates(e){e===OS.TCP?this._candidates.forEach(e=>{-1===this._candidates.findIndex(t=>"tcp"===t.transport&&t.connectionAddress===e.connectionAddress&&t.port===e.port)&&this._candidates.push(DN(DN({},e),{},{foundation:"tcpcandidate",priority:Number(e.priority)-1+"",transport:"tcp",port:Number(e.port)+90+""}));}):this._candidates=this._candidates.filter(e=>"tcp"!==e.transport);for(const e of this.sessionDesc.mediaDescriptions)e.attributes.candidates=this.candidates;}restartICE(e){e=uC(e),this._iceParameters=e,this.sessionDesc.mediaDescriptions.forEach(t=>{t.attributes.iceUfrag=e.iceUfrag,t.attributes.icePwd=e.icePwd;});}predictReceivingMids(e){const t=[];for(let i=0;i<e;i++)t.push((this.currentMidIndex+i+1).toString(10));return t}findAvailableMediaIndex(e,t){return this.sessionDesc.mediaDescriptions.findIndex(i=>{const n=i.media.mediaType===e&&"0"!==i.media.port&&("sendonly"===i.attributes.direction||"sendrecv"===i.attributes.direction)&&0===i.attributes.ssrcs.length;if(Kh()){if(n){const e=this.firefoxSsrcMidMap.get(t[0].ssrcId);return !(e||"0"!==i.attributes.mid&&"1"!==i.attributes.mid)||!(!e||e!==i.attributes.mid)}return !1}return n})}createOrRecycleRecvMedia(e,t,i,n,r,o){const s=e._mediaStreamTrack.kind,a=this.rtpCapabilities.recv,c=this.localCapabilities.send;let d=[];if(s===AS.VIDEO){var u,l;if(GE("H264_PROFILE_LEVEL_ID")&&"h264"===n&&(d=a.videoCodecs.filter(e=>{var t,i;return ((null===(t=e.rtpMap)||void 0===t?void 0:t.encodingName.toLowerCase())||"").includes(n)&&(null==e||null===(i=e.fmtp)||void 0===i?void 0:i.parameters["profile-level-id"])===GE("H264_PROFILE_LEVEL_ID")})),!d||0===(null===(u=d)||void 0===u?void 0:u.length)){const e=c.videoCodecs.filter(e=>{var t;return ((null===(t=e.rtpMap)||void 0===t?void 0:t.encodingName.toLowerCase())||"").includes(n)});0!==e.length&&(d=a.videoCodecs.filter(t=>e.some(e=>e.payloadType===t.payloadType)));}if(GE("USE_PUB_RTX")){const e=d.map(e=>e.payloadType.toString()),t=a.videoCodecs.filter(t=>{var i,n;return "rtx"===(null===(i=t.rtpMap)||void 0===i?void 0:i.encodingName)&&e.includes((null===(n=t.fmtp)||void 0===n?void 0:n.parameters.apt)||"")});d=[...d,...t];}if(0===d.length)OE.warning("codec ".concat(n," not included in rtpCapabilities, fallback to default payloads: ").concat(null===(l=a.videoCodecs[0].rtpMap)||void 0===l?void 0:l.encodingName)),d=a.videoCodecs;}else d=a.audioCodecs.filter(e=>{var t;return ((null===(t=e.rtpMap)||void 0===t?void 0:t.encodingName.toLowerCase())||"").includes(r)}),0===d.length&&(OE.warning("codec ".concat(r," not included in rtpCapabilities, fallback to opus")),d=a.audioCodecs.filter(e=>{var t;return ((null===(t=e.rtpMap)||void 0===t?void 0:t.encodingName.toLowerCase())||"").includes("opus")}));const h=s===AS.VIDEO?a.videoExtensions:a.audioExtensions;this.currentMidIndex+=1;const p="".concat(this.currentMidIndex);let _={media:{mediaType:s,port:PN,protos:["UDP","TLS","RTP","SAVPF"],fmts:d.map(e=>e.payloadType.toString(10))},connections:[{nettype:"IN",addrtype:"IP4",address:"127.0.0.1"}],bandwidths:[],attributes:{iceUfrag:this.iceParameters.iceUfrag,icePwd:this.iceParameters.icePwd,unrecognized:[],candidates:this.candidates,extmaps:h,fingerprints:this.dtlsParameters.fingerprints,imageattr:[],msids:[],remoteCandidatesList:[],rids:[],ssrcs:t,ssrcGroups:[],rtcpFeedbackWildcards:[],payloads:d,rtcp:{port:"9",netType:"IN",addressType:"IP4",address:"0.0.0.0"},setup:this.setup,direction:i,rtcpMux:!0,rtcpRsize:!0,mid:"".concat(p)}};_=this.mungRecvMediaDsec(_,e,o);const E=this.findFirstClosedMedia(s);if(E){const e=this.sessionDesc.mediaDescriptions.indexOf(E);this.sessionDesc.mediaDescriptions[e]=_;}else this.sessionDesc.mediaDescriptions.push(_);return _}createOrRecycleSendMedia(e,t,i,n,r){const o=this.rtpCapabilities.send,s=e===AS.VIDEO?o.videoCodecs:o.audioCodecs,a=e===AS.VIDEO?o.videoExtensions:o.audioExtensions;this.currentMidIndex+=1;const c="".concat(this.currentMidIndex);let d={media:{mediaType:e,port:PN,protos:["UDP","TLS","RTP","SAVPF"],fmts:s.map(e=>e.payloadType.toString(10))},connections:[{nettype:"IN",addrtype:"IP4",address:"127.0.0.1"}],bandwidths:[],attributes:{iceUfrag:this.iceParameters.iceUfrag,icePwd:this.iceParameters.icePwd,unrecognized:[],candidates:this.candidates,extmaps:a,fingerprints:this.dtlsParameters.fingerprints,imageattr:[],msids:[],remoteCandidatesList:[],rids:[],ssrcs:t,ssrcGroups:i,rtcpFeedbackWildcards:[],payloads:s,rtcp:{port:"9",netType:"IN",addressType:"IP4",address:"0.0.0.0"},setup:this.setup,direction:n,rtcpMux:!0,rtcpRsize:!0,mid:"".concat(c)}};d=this.mungSendMediaDesc(d,r);const u=this.findFirstClosedMedia(e);if(u){const e=this.sessionDesc.mediaDescriptions.indexOf(u);this.sessionDesc.mediaDescriptions[e]=d;}else this.sessionDesc.mediaDescriptions.push(d);return d}updateBundleMids(){this.sessionDesc.attributes.groups[0].identificationTag=this.sessionDesc.mediaDescriptions.filter(e=>"0"!==e.media.port).map(e=>e.attributes.mid);}mungRecvMediaDsec(e,t,i){const n=uC(e);return KO(n),HO(n,t),YO(n,t),qO(n),JO(n,i,this.localCapabilities.send),n}mungSendMediaDesc(e,t){const i=uC(e);return JO(i,t,this.localCapabilities.recv),$O(i),i}updateRecvMedia(e,t){const i=this.sessionDesc.mediaDescriptions.findIndex(t=>t.attributes.mid===e);if(-1!==i){const e=this.mungRecvMediaDsec(this.sessionDesc.mediaDescriptions[i],t);this.sessionDesc.mediaDescriptions[i]=e;}}bumpMid(e){this.currentMidIndex+=e;}findFirstClosedMedia(e){return this.sessionDesc.mediaDescriptions.find(t=>Kh()?"0"===t.media.port&&t.media.mediaType===e:"0"===t.media.port)}findPreloadMediaDesc(e){return this.sessionDesc.mediaDescriptions.find(t=>{var i,n;return (null===(i=t.attributes)||void 0===i||null===(n=i.ssrcs[0])||void 0===n?void 0:n.ssrcId)===e[0].ssrcId})}getSSRC(e){var t;return null===(t=this.sessionDesc.mediaDescriptions.find(t=>t.attributes.mid===e))||void 0===t?void 0:t.attributes.ssrcs}}var MN;function UN(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n);}return i}function xN(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?UN(Object(i),!0).forEach((function(t){_p(e,t,i[t]);})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):UN(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t));}));}return e}let VN=(ag((MN=class e extends YS{get currentLocalDescription(){return this.peerConnection.currentLocalDescription}get currentRemoteDescription(){return this.peerConnection.currentRemoteDescription}get peerConnectionState(){return this.peerConnection.connectionState}get iceConnectionState(){return this.peerConnection.iceConnectionState}get dtlsTransportState(){var e,t,i;return null!==(e=null===(t=this.peerConnection.getReceivers()[0])||void 0===t||null===(i=t.transport)||void 0===i?void 0:i.state)&&void 0!==e?e:null}constructor(t,i){super(t,i),_p(this,"store",void 0),_p(this,"peerConnection",void 0),_p(this,"remoteSDP",void 0),_p(this,"initialOffer",void 0),_p(this,"transportEventReceiver",void 0),_p(this,"statsFilter",void 0),_p(this,"localCapabilities",void 0),_p(this,"localCandidateCount",0),_p(this,"allCandidatesReceived",!1),_p(this,"selectedCandidatePairTimer",void 0),_p(this,"establishPromise",void 0),_p(this,"mutex",new Ug("P2PConnection-mutex")),this.store=i,this.peerConnection=new RTCPeerConnection(e.resolvePCConfiguration(t),{optional:[{googDscp:!0}]}),this.statsFilter=vN(this.peerConnection,GE("STATS_UPDATE_INTERVAL"),void 0,Kh()?1200:void 0),this.bindPCEvents(),this.bindStatsEvents(),this.store.p2pId=this.store.p2pId+1,this.establishPromise=this.establish();}async establish(){try{this.peerConnection.addTransceiver("video",{direction:"recvonly"}),this.peerConnection.addTransceiver("audio",{direction:"recvonly"});const e=await this.peerConnection.createOffer();if(!e.sdp)throw new Error("Cannot get initialOffer.sdp when trying to establish PeerConnection.");const t=FO(e.sdp),i=await zO(!GE("USE_PUB_RTX")&&!GE("USE_SUB_RTX"),GE("FILTER_VIDEO_FEC"),GE("FILTER_AUDIO_FEC"));return this.localCapabilities=ZO(i),this.initialOffer=e,xN(xN({},t),{},{rtpCapabilities:i,offerSDP:e.sdp})}catch(e){throw new SE(fE.GET_LOCAL_CONNECTION_PARAMS_FAILED,e.toString())}}async connect(e,t,i,n,r,o){try{if(!this.initialOffer)throw new Error("Cannot establish P2PConnection without initial offer.");this.remoteSDP=new kN({remoteIceParameters:e,remoteDtlsParameters:t,candidates:i,remoteRTPCapabilities:n,remoteSetup:r,localCapabilities:this.localCapabilities,cname:o});const s=this.remoteSDP.toString(),a=UO.exports.parse(this.initialOffer.sdp),c=a.mediaDescriptions.find(e=>"audio"===e.media.mediaType);c&&$O(c);const d=UO.exports.print(a),u=this.logSDPExchange(d||"","offer","local","connect");this.store.descriptionStart(),await this.peerConnection.setLocalDescription({type:"offer",sdp:d}),null==u||u(s),await this.peerConnection.setRemoteDescription({type:"answer",sdp:s});const l=this.peerConnection.getTransceivers()[0];if(null!=l&&l.receiver&&this.tryBindTransportEvents(l.receiver),GE("PRELOAD_MEDIA_COUNT")>0){this.remoteSDP.preloadRemoteMedia();const e=this.remoteSDP.toString();await this.peerConnection.setRemoteDescription({type:"offer",sdp:e});const t=await this.peerConnection.createAnswer();await this.peerConnection.setLocalDescription(t);}}catch(e){throw new SE(fE.EXCHANGE_SDP_FAILED,"P2PConnection.connect failed; ".concat(e.toString()))}}send(e,t,i){var n=this;return DO((function*(){const r=yield PO(n.mutex.lock("From P2PConnection.send"));try{if(!n.remoteSDP)throw new Error("Cannot call P2PConnection.send before remote SDP created");const o=[];e.forEach(e=>{const t=n.peerConnection.addTransceiver(e._mediaStreamTrack,{direction:"sendonly"});o.push(t),e._updateRtpTransceiver(t);}),Kh()&&!0===GE("SIMULCAST")&&(yield PO(n.applySimulcastForFirefox(o,e)));const s=yield PO(n.peerConnection.createOffer()),a=n.remoteSDP.predictReceivingMids(e.length),c=n.mungSendOfferSDP(s.sdp,e,a),d=UO.exports.parse(c),u=a.map(e=>{const t=d.mediaDescriptions.find(t=>t.attributes.mid===e);if(!t)throw new Error("Cannot extract ssrc from mediaDescription.");return BO(t,GE("USE_PUB_RTX"))});let l;try{l=yield u;}catch(r){l=[],n.remoteSDP.receive(e,t,i,l);const o=n.remoteSDP.toString();throw yield PO(n.peerConnection.setLocalDescription({type:"offer",sdp:c})),yield PO(n.peerConnection.setRemoteDescription({type:"answer",sdp:o})),yield PO(n.stopSending(a,!0)),r}n.remoteSDP.receive(e,t,i,l);const h=n.remoteSDP.toString(),p=n.logSDPExchange(c,"offer","local","send");return yield PO(n.peerConnection.setLocalDescription({type:"offer",sdp:c})),yield PO(n.applySimulcastEncodings(o,e)),yield PO(n.applySendEncodings(o,e)),null==p||p(h),yield PO(n.peerConnection.setRemoteDescription({type:"answer",sdp:h})),o.map((e,t)=>{const i=a[t];return {localSSRC:u[t],id:i,transceiver:e}})}catch(e){throw e instanceof SE?e:new SE(fE.EXCHANGE_SDP_FAILED,"P2PConnection.send failed; ".concat(e.toString()))}finally{r();}}))()}async stopSending(e,t){const i=t?void 0:await this.mutex.lock("From P2PConnection.stopSending");try{if(!this.remoteSDP)throw new Error("Cannot call P2PConnection.stopSending before remote SDP created");const t=this.peerConnection.getTransceivers().filter(t=>-1!==e.indexOf(t.mid));if(t.length!==e.length)throw new Error("Transceivers' length doesn't match mids' length when trying to call P2PConnection.stopSending.");t.map(e=>{var t;e.direction="inactive",null===(t=e.stop)||void 0===t||t.call(e);});const n=await this.peerConnection.createOffer(),r=this.logSDPExchange(n.sdp||"","offer","local","stopSending");await this.peerConnection.setLocalDescription(n),this.remoteSDP.stopReceiving(e);const o=this.remoteSDP.toString();null==r||r(o),await this.peerConnection.setRemoteDescription({type:"answer",sdp:o});}catch(e){throw new SE(fE.EXCHANGE_SDP_FAILED,"P2PConnection.stopSending failed; ".concat(e.toString()))}finally{i&&i();}}async receive(e,t,i,n){try{if(!this.remoteSDP)throw new Error("Cannot call P2PConnection.receive ".concat(e," before remoteSDP created."));const{mid:r,needExchangeSDP:o}=this.remoteSDP.send(e,t,i,n);if(o){const t=this.remoteSDP.toString(),i=this.logSDPExchange(t,"offer","remote","receive");await this.peerConnection.setRemoteDescription({type:"offer",sdp:t});const n=await this.peerConnection.createAnswer(),o=this.mungReceiveAnswerSDP(n.sdp,r,e);null==i||i(o||""),await this.peerConnection.setLocalDescription({type:"answer",sdp:o}),OE.debug("[".concat(this.store.clientId,"] [P2PConnection] receive ").concat(e," by exchanging SDP."));}else OE.debug("[".concat(this.store.clientId,"] [P2PConnection] receive ").concat(e," no need to exchange SDP."));const s=this.peerConnection.getTransceivers().find(e=>e.mid===r);if(!s)throw new Error("Cannot get transceiver after setLocalDescription.");return {track:s.receiver.track,id:r,transceiver:s}}catch(e){throw new SE(fE.EXCHANGE_SDP_FAILED,"P2PConnection.receive failed; ".concat(e.toString()))}}async batchReceive(e){try{if(!this.remoteSDP)throw new Error("Cannot call P2PConnection.batchReceive before remoteSDP created.");const{mids:t,needExchangeSDP:i}=this.remoteSDP.batchSend(e);if(i){const e=this.remoteSDP.toString(),t=this.logSDPExchange(e,"offer","remote","receive");await this.peerConnection.setRemoteDescription({type:"offer",sdp:e});const i=await this.peerConnection.createAnswer();null==t||t(i.sdp||""),await this.peerConnection.setLocalDescription(i),OE.debug("[".concat(this.store.clientId,"] [P2PConnection] batchReceive by exchanging SDP."));}else OE.debug("[".concat(this.store.clientId,"] [P2PConnection] batchReceive no need to exchange SDP."));return t.map(e=>{const t=this.peerConnection.getTransceivers().find(t=>t.mid===e);if(!t)throw new Error("Cannot get transceiver after setLocalDescription.");return {track:t.receiver.track,id:e,transceiver:t}})}catch(e){throw new SE(fE.EXCHANGE_SDP_FAILED,"P2PConnection.receive failed; ".concat(e.toString()))}}async stopReceiving(e){try{if(!this.remoteSDP)throw new Error("Cannot call P2PConnection.stopReceiving before remote SDP created.");this.remoteSDP.stopSending(e);const t=this.remoteSDP.toString(),i=this.logSDPExchange(t,"offer","remote","stopReceiving");await this.peerConnection.setRemoteDescription({type:"offer",sdp:t});const n=await this.peerConnection.createAnswer();null==i||i(n.sdp||""),await this.peerConnection.setLocalDescription(n);}catch(e){throw new SE(fE.EXCHANGE_SDP_FAILED,"P2PConnection stopReceiving failed; ".concat(e.toString()))}}async muteRemote(e){try{if(!this.remoteSDP)throw new Error("Cannot call P2PConnection.muteRemote mid=".concat(e," before remote SDP created."));this.remoteSDP.mute(e);const t=this.remoteSDP.toString(),i=this.logSDPExchange(t,"offer","remote","muteRemote");await this.peerConnection.setRemoteDescription({type:"offer",sdp:t});const n=await this.peerConnection.createAnswer();null==i||i(n.sdp||""),await this.peerConnection.setLocalDescription(n);}catch(e){throw new SE(fE.EXCHANGE_SDP_FAILED,"P2PConnection.muteRemote failed; ".concat(e.toString()))}}async unmuteRemote(e){try{if(!this.remoteSDP)throw new Error("Cannot call P2PConnection.unmuteRemote mid=".concat(e," before remote SDP created."));this.remoteSDP.unmute(e);const t=this.remoteSDP.toString(),i=this.logSDPExchange(t,"offer","remote","unmuteRemote");await this.peerConnection.setRemoteDescription({type:"offer",sdp:t});const n=await this.peerConnection.createAnswer();null==i||i(n.sdp||""),await this.peerConnection.setLocalDescription(n);}catch(e){throw new SE(fE.EXCHANGE_SDP_FAILED,"P2PConnection.unmuteRemote failed; ".concat(e.toString()))}}async muteLocal(e){try{if(!this.remoteSDP)throw new Error("Cannot call P2PConnection.muteLocal before remote SDP created.");const t=this.peerConnection.getTransceivers().filter(t=>t.mid&&-1!==e.indexOf(t.mid));if(t.length!==e.length)throw new Error("Transceivers' length doesn't match mids' length.");t.map(e=>{e.direction="inactive";});const i=await this.peerConnection.createOffer(),n=this.logSDPExchange(i.sdp||"","offer","local","muteLocal");await this.peerConnection.setLocalDescription(i),this.remoteSDP.muteRemote(e);const r=this.remoteSDP.toString();null==n||n(r),await this.peerConnection.setRemoteDescription({type:"answer",sdp:r});}catch(e){throw new SE(fE.EXCHANGE_SDP_FAILED,"P2PConnection.muteLocal failed; ".concat(e.toString()))}}async unmuteLocal(e){try{if(!this.remoteSDP)throw new Error("Cannot call P2PConnection.unmuteLocal before remote SDP created.");const t=this.peerConnection.getTransceivers().filter(t=>t.mid&&-1!==e.indexOf(t.mid));if(t.length!==e.length)throw new Error("Transceivers' length doesn't match mids' length.");t.map(async(e,t)=>{e.direction="sendonly";});const i=await this.peerConnection.createOffer(),n=this.logSDPExchange(i.sdp||"","offer","local","unmuteLocal");await this.peerConnection.setLocalDescription(i),this.remoteSDP.unmuteRemote(e);const r=this.remoteSDP.toString();null==n||n(r),await this.peerConnection.setRemoteDescription({type:"answer",sdp:r});}catch(e){throw new SE(fE.EXCHANGE_SDP_FAILED,"P2PConnection.unmuteLocal failed; ".concat(e.toString()))}}restartICE(e){var t=this;return DO((function*(){const i=yield PO(t.mutex.lock("From P2PConnection.restartICE"));try{if(!t.remoteSDP)throw new Error("Cannot restartICE before remoteSDP created.");if(JS().supportPCSetConfiguration){const i=t.peerConnection.getConfiguration(),n=e===OS.RELAY?"relay":"all";i.iceTransportPolicy!==n&&(OE.debug("[".concat(t.store.clientId,"] restartICE change iceTransportPolicy from [").concat(i.iceTransportPolicy,"] to [").concat(n,"]")),i.iceTransportPolicy=n,t.peerConnection.setConfiguration(i));}else if(e===OS.RELAY)return;e!==OS.RELAY&&t.remoteSDP.updateCandidates(e);const n=yield PO(t.peerConnection.createOffer({iceRestart:!0}));if(!n.sdp)throw new Error("Cannot restartICE because restart offer SDP does not exist.");const r=FO(n.sdp),{remoteIceParameters:o}=yield r.iceParameters;t.remoteSDP.restartICE(o);const s=t.remoteSDP.toString(),a=t.logSDPExchange(n.sdp||"","offer","local","restartICE");t.store.descriptionStart(),yield PO(t.peerConnection.setLocalDescription(n)),null==a||a(s),yield PO(t.peerConnection.setRemoteDescription({type:"answer",sdp:s}));}catch(e){OE.warning("[".concat(t.store.clientId,"] restart ICE failed, abort operation"),e);}finally{i();}}))()}close(){var e;this.peerConnection.close(),null===(e=this.onConnectionStateChange)||void 0===e||e.call(this,"closed"),this.tryUnbindTransportEvents(),this.unbindPCEvents(),this.unbindStatsEvents(),this.removeAllListeners(),this.transportEventReceiver=void 0,this.statsFilter.destroy();}getStats(){return this.statsFilter.getStats()}getRemoteVideoIsReady(e){return this.statsFilter.getVideoIsReady(e)}async updateEncoderConfig(e,t){try{if(!this.remoteSDP)throw new Error("Cannot call P2PConnection.updateEncoderConfig before remote SDP created.");const i=await this.peerConnection.createOffer(),n=this.mungSendOfferSDP(i.sdp,[t],[e]);this.remoteSDP.updateRecvMedia(e,t);const r=this.remoteSDP.toString(),o=this.logSDPExchange(n,"offer","local","updateEncoderConfig");await this.peerConnection.setLocalDescription({type:"offer",sdp:n}),null==o||o(r),await this.peerConnection.setRemoteDescription({type:"answer",sdp:r});}catch(e){throw new SE(fE.EXCHANGE_SDP_FAILED,e.toString())}}async updateSendParameters(e,t){const i=this.peerConnection.getTransceivers().filter(t=>t.mid===e);1===i.length&&(this.isVP8Simulcast(t)?Kh()||await this.applySimulcastEncodings(i,[t]):await this.applySendEncodings(i,[t]));}setStatsRemoteVideoIsReady(e,t){this.statsFilter.setVideoIsReady2(e,t);}async replaceTrack(e,t){const i=this.peerConnection.getTransceivers().find(e=>e.mid===t);i&&await i.sender.replaceTrack(e._mediaStreamTrack);}async getSelectedCandidatePair(){const e=this.peerConnection.getReceivers();if(e.length>0&&e[0].transport&&e[0].transport.iceTransport&&e[0].transport.iceTransport.getSelectedCandidatePair&&e[0].transport.iceTransport.getSelectedCandidatePair()){const t=e[0].transport.iceTransport,{local:i,remote:n}=t.getSelectedCandidatePair();return {local:xN(xN({},cN),{},{candidateType:i.type,protocol:i.protocol,address:i.address,port:i.port}),remote:xN(xN({},cN),{},{candidateType:n.type,protocol:n.protocol,address:n.address,port:n.port})}}return this.statsFilter.getSelectedCandidatePair()}bindPCEvents(){this.peerConnection.oniceconnectionstatechange=()=>{var e;null===(e=this.onICEConnectionStateChange)||void 0===e||e.call(this,this.peerConnection.iceConnectionState);},this.peerConnection.onconnectionstatechange=()=>{var e;null===(e=this.onConnectionStateChange)||void 0===e||e.call(this,this.peerConnection.connectionState);},this.peerConnection.onicecandidate=e=>{e.candidate?this.localCandidateCount+=1:(this.peerConnection.onicecandidate=null,this.allCandidatesReceived=!0,OE.debug("[".concat(this.store.clientId,"] [pc-").concat(this.store.p2pId,"] local candidate count"),this.localCandidateCount));},setTimeout(()=>{this.allCandidatesReceived||(this.allCandidatesReceived=!0,OE.debug("[".concat(this.store.clientId,"] [pc-").concat(this.store.p2pId,"] onicecandidate timeout, local candidate count"),this.localCandidateCount));},GE("CANDIDATE_TIMEOUT"));}unbindPCEvents(){this.peerConnection.oniceconnectionstatechange=null,this.peerConnection.onconnectionstatechange=null,this.peerConnection.onsignalingstatechange=null,this.peerConnection.onicecandidateerror=null,this.peerConnection.onicecandidate=null,this.peerConnection.ontrack=null;}static resolvePCConfiguration(t){const i={iceServers:[]};return t.iceServers?i.iceServers=t.iceServers:t.turnServer&&"off"!==t.turnServer.mode&&(Uf(t.turnServer.servers)?i.iceServers=t.turnServer.servers:(i.iceServers&&i.iceServers.push(...e.turnServerConfigToIceServers(t.turnServer.servers)),GE("USE_TURN_SERVER_OF_GATEWAY")&&i.iceServers&&t.turnServer.serversFromGateway&&i.iceServers.push(...e.turnServerConfigToIceServers(t.turnServer.serversFromGateway)),GE("FORCE_TURN_TCP")?i.iceTransportPolicy="relay":t.turnServer.servers.concat(t.turnServer.serversFromGateway||[]).forEach(e=>{e.forceturn&&(i.iceTransportPolicy="relay");}))),GE("ENABLE_ENCODED_TRANSFORM")&&JS().supportWebRTCEncodedTransform&&(i.encodedInsertableStreams=!0),i}static turnServerConfigToIceServers(e){const t=[];return e.forEach(e=>{e.security?e.tcpport&&t.push({username:e.username,credential:e.password,credentialType:"password",urls:"turns:".concat(VI(e.turnServerURL),":").concat(e.tcpport,"?transport=tcp")}):(e.udpport&&!GE("FORCE_TURN_TCP")&&t.push({username:e.username,credential:e.password,credentialType:"password",urls:"turn:".concat(e.turnServerURL,":").concat(e.udpport,"?transport=udp")}),e.tcpport&&t.push({username:e.username,credential:e.password,credentialType:"password",urls:"turn:".concat(e.turnServerURL,":").concat(e.tcpport,"?transport=tcp")}));}),t}tryBindTransportEvents(e){const t=e.transport;if(t){this.transportEventReceiver=e,t.onstatechange=()=>{var e;null!=t&&t.state&&(null===(e=this.onDTLSTransportStateChange)||void 0===e||e.call(this,t.state));},t.onerror=e=>{var t;null===(t=this.onDTLSTransportError)||void 0===t||t.call(this,"error"in e?e.error:e);};const i=t.iceTransport;i&&(i.onstatechange=()=>{const e=null==t?void 0:t.iceTransport.state;var i;e&&(null===(i=this.onICETransportStateChange)||void 0===i||i.call(this,e));},i.getSelectedCandidatePair&&(i.onselectedcandidatepairchange=()=>{if(i.getSelectedCandidatePair()){const{local:e,remote:t}=i.getSelectedCandidatePair();OE.info("[".concat(this.store.clientId,"] [pc-").concat(this.store.p2pId,"] selectedcandidatepairchange: local ").concat(JSON.stringify({candidateType:e.type,protocol:e.protocol}),", remote ").concat(JSON.stringify({candidateType:t.type,protocol:t.protocol,address:t.address,port:t.port})," )"));}}));}}tryUnbindTransportEvents(){this.transportEventReceiver&&this.transportEventReceiver.transport&&(this.transportEventReceiver.transport.onstatechange=null,this.transportEventReceiver.transport.onerror=null,this.transportEventReceiver.transport.iceTransport&&(this.transportEventReceiver.transport.iceTransport.onstatechange=null));}async applySendEncodings(e,t){try{if(!JS().supportSetRtpSenderParameters)return;if(e.length!==t.length)return;for(let c=0;c<e.length;c++){const d=e[c],u=t[c];if(u&&u instanceof Cy){var i,n;if(this.isVP8Simulcast(u))continue;const e={},t={};switch(u._optimizationMode){case"motion":e.degradationPreference="maintain-framerate";break;case"detail":e.degradationPreference="maintain-resolution";break;default:e.degradationPreference="balanced";}var r,o,s,a;if(null!==(i=u._encoderConfig)&&void 0!==i&&i.bitrateMax)t.maxBitrate=1e3*(null===(r=u._encoderConfig)||void 0===r?void 0:r.bitrateMax);if(u._hints.includes(lS.LOW_STREAM))null!==(o=u._encoderConfig)&&void 0!==o&&o.frameRate&&(t.maxFramerate=FI(u._encoderConfig.frameRate)),null!==(s=u._encoderConfig)&&void 0!==s&&s.scaleResolutionDownBy&&(null===(a=u._encoderConfig)||void 0===a?void 0:a.scaleResolutionDownBy)>1&&(t.scaleResolutionDownBy=u._encoderConfig.scaleResolutionDownBy);if(GE("DSCP_TYPE")&&rp()){const e=GE("DSCP_TYPE");["very-low","low","medium","high"].includes(e)&&(t.networkPriority=e);}const c=d.sender.getParameters(),l=null===(n=c.encodings)||void 0===n?void 0:n[0];Kh()&&!l&&(e.encodings=[t]),l&&Object.assign(l,t),Object.assign(c,e),await d.sender.setParameters(c);}}}catch(e){OE.debug("[".concat(this.store.clientId,"] Apply RTPSendEncodings failed."));}}mungSendOfferSDP(e,t,i){const n=UO.exports.parse(e);return t.forEach((e,t)=>{const r=i[t],o=n.mediaDescriptions.find(e=>e.attributes.mid===r);o&&(HO(o,e),XO(o,e,this.store.codec));}),UO.exports.print(n)}mungReceiveAnswerSDP(e,t,i){const n=UO.exports.parse(e),r=n.mediaDescriptions.find(e=>e.attributes.mid===t);return r&&i===AS.AUDIO&&"audio"===r.media.mediaType&&$O(r),UO.exports.print(n)}bindStatsEvents(){this.statsFilter.onFirstAudioReceived=e=>{var t;null===(t=this.onFirstAudioReceived)||void 0===t||t.call(this,e);},this.statsFilter.onFirstVideoReceived=e=>{var t;null===(t=this.onFirstVideoReceived)||void 0===t||t.call(this,e);},this.statsFilter.onFirstAudioDecoded=e=>{var t;null===(t=this.onFirstAudioDecoded)||void 0===t||t.call(this,e);},this.statsFilter.onFirstVideoDecoded=(e,t,i)=>{var n;null===(n=this.onFirstVideoDecoded)||void 0===n||n.call(this,e,t,i);},this.statsFilter.onSelectedLocalCandidateChanged=(e,t)=>{var i;null===(i=this.onSelectedLocalCandidateChanged)||void 0===i||i.call(this,e,t);},this.statsFilter.onSelectedRemoteCandidateChanged=(e,t)=>{var i;null===(i=this.onSelectedRemoteCandidateChanged)||void 0===i||i.call(this,e,t);},this.statsFilter.onFirstVideoDecodedTimeout=e=>{var t;null===(t=this.onFirstVideoDecodedTimeout)||void 0===t||t.call(this,e);};}unbindStatsEvents(){this.statsFilter.onFirstAudioReceived=void 0,this.statsFilter.onFirstVideoReceived=void 0,this.statsFilter.onFirstAudioDecoded=void 0,this.statsFilter.onFirstVideoDecoded=void 0,this.statsFilter.onSelectedLocalCandidateChanged=void 0,this.statsFilter.onSelectedRemoteCandidateChanged=void 0,this.statsFilter.onFirstVideoDecodedTimeout=void 0;}async applySimulcastForFirefox(e,t){if(e.length===t.length)for(let s=0;s<e.length;s++){var i,n,r,o;const a=e[s],c=t[s];if(c instanceof Cy&&!c._hints.includes(lS.LOW_STREAM)&&null!==(i=c._encoderConfig)&&void 0!==i&&i.bitrateMax&&(null===(n=c._encoderConfig)||void 0===n?void 0:n.bitrateMax)>200&&null!==(r=c._scalabiltyMode)&&void 0!==r&&r.numSpatialLayers&&(null===(o=c._scalabiltyMode)||void 0===o?void 0:o.numSpatialLayers)>1&&"vp8"===this.store.codec){const e={},t={high:1e3*(c._encoderConfig.bitrateMax-50),medium:5e4};e.encodings=[{rid:"m",active:!0,maxBitrate:t.medium,scaleResolutionDownBy:4},{rid:"h",active:!0,maxBitrate:t.high}];const i=a.sender.getParameters();await a.sender.setParameters(Object.assign(i,e));}}}async applySimulcastEncodings(e,t){if(!Kh()&&e.length===t.length)for(let i=0;i<e.length;i++){const n=t[i];if(n instanceof Cy&&this.isVP8Simulcast(n)){const t=e[i],r={},o={high:1e3*(n._encoderConfig.bitrateMax-50),medium:5e4};r.encodings=[{active:!0,adaptivePtime:!1,networkPriority:"high",priority:"high",maxBitrate:o.high},{active:!0,adaptivePtime:!1,networkPriority:"low",priority:"low",maxBitrate:o.medium,scaleResolutionDownBy:4}];const s=t.sender.getParameters();await t.sender.setParameters(Object.assign(s,r));}}}isVP8Simulcast(e){var t,i,n,r;return !!(e instanceof Cy&&GE("SIMULCAST")&&"vp8"===this.store.codec&&!e._hints.includes(lS.LOW_STREAM)&&null!==(t=e._encoderConfig)&&void 0!==t&&t.bitrateMax&&(null===(i=e._encoderConfig)||void 0===i?void 0:i.bitrateMax)>200&&null!==(n=e._scalabiltyMode)&&void 0!==n&&n.numSpatialLayers&&(null===(r=e._scalabiltyMode)||void 0===r?void 0:r.numSpatialLayers)>1)}logSDPExchange(e,t,i,n){if(GE("SDP_LOGGING"))return OE.upload("[".concat(this.store.clientId,"] exchanging ").concat(i," ").concat(t," SDP during P2PConnection.").concat(n,"\n"),e),"offer"===t?e=>{this.logSDPExchange(e,"answer","local"===i?"remote":"local",n);}:void 0}async getRemoteSSRC(e){if(!this.remoteSDP)return;const t=this.remoteSDP.getSSRC(e);return null==t?void 0:t[0].ssrcId}setConfiguration(t){if(JS().supportPCSetConfiguration){const i=e.resolvePCConfiguration(t);this.peerConnection.setConfiguration(i);}}}).prototype,"connect",[jN],Object.getOwnPropertyDescriptor(MN.prototype,"connect"),MN.prototype),ag(MN.prototype,"receive",[jN],Object.getOwnPropertyDescriptor(MN.prototype,"receive"),MN.prototype),ag(MN.prototype,"batchReceive",[jN],Object.getOwnPropertyDescriptor(MN.prototype,"batchReceive"),MN.prototype),ag(MN.prototype,"stopReceiving",[jN],Object.getOwnPropertyDescriptor(MN.prototype,"stopReceiving"),MN.prototype),ag(MN.prototype,"muteRemote",[jN],Object.getOwnPropertyDescriptor(MN.prototype,"muteRemote"),MN.prototype),ag(MN.prototype,"unmuteRemote",[jN],Object.getOwnPropertyDescriptor(MN.prototype,"unmuteRemote"),MN.prototype),ag(MN.prototype,"muteLocal",[jN],Object.getOwnPropertyDescriptor(MN.prototype,"muteLocal"),MN.prototype),ag(MN.prototype,"unmuteLocal",[jN],Object.getOwnPropertyDescriptor(MN.prototype,"unmuteLocal"),MN.prototype),ag(MN.prototype,"close",[jN],Object.getOwnPropertyDescriptor(MN.prototype,"close"),MN.prototype),ag(MN.prototype,"updateEncoderConfig",[jN],Object.getOwnPropertyDescriptor(MN.prototype,"updateEncoderConfig"),MN.prototype),ag(MN.prototype,"updateSendParameters",[jN],Object.getOwnPropertyDescriptor(MN.prototype,"updateSendParameters"),MN.prototype),ag(MN.prototype,"replaceTrack",[jN],Object.getOwnPropertyDescriptor(MN.prototype,"replaceTrack"),MN.prototype),ag(MN.prototype,"getRemoteSSRC",[jN],Object.getOwnPropertyDescriptor(MN.prototype,"getRemoteSSRC"),MN.prototype),MN);function jN(e,t,i){const n=e[t];if("function"!=typeof n)throw new Error("Cannot use mutex on object property.");return i.value=async function(){const e=this.mutex,i=await e.lock("From P2PConnection.".concat(t));try{for(var r=arguments.length,o=new Array(r),s=0;s<r;s++)o[s]=arguments[s];return await n.apply(this,o)}finally{i();}},i}function FN(e,t){let i=document.createElement("video"),n=document.createElement("canvas");i.setAttribute("style","display:none"),n.setAttribute("style","display:none"),i.setAttribute("muted",""),i.muted=!0,i.setAttribute("autoplay",""),i.autoplay=!0,i.setAttribute("playsinline",""),n.width=FI(t.width),n.height=FI(t.height);const r=FI(t.framerate||15);document.body.append(i),document.body.append(n);let o=e._mediaStreamTrack;i.srcObject=new MediaStream([o]),i.play();const s=n.getContext("2d");if(!s)throw new SE(fE.UNEXPECTED_ERROR,"can not get canvas context");const a=JS(),c=n.captureStream(a.supportRequestFrame?0:r).getVideoTracks()[0],d=Jg(()=>(()=>{if(i.paused&&i.play(),i.videoHeight>2&&i.videoWidth>2){const e=i.videoWidth,t=i.videoHeight/e,r=n.width*t;Math.abs(r-n.height)>=2&&(OE.debug("adjust low stream resolution","".concat(n.width,"x").concat(n.height," -> ").concat(n.width,"x").concat(r)),n.height=r);}s.drawImage(i,0,0,n.width,n.height),c.requestFrame&&c.requestFrame(),o!==e._mediaStreamTrack&&(o=e._mediaStreamTrack,i.srcObject=new MediaStream([o]));})(),r),u=c.stop;return c.stop=()=>{u.call(c),d(),i&&(i.remove(),i=null),n&&(n.width=0,n.remove(),n=null),OE.debug("clean low stream renderer");},c}var BN,GN,WN,HN,KN,YN,qN,JN,XN,zN,QN,ZN;function $N(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n);}return i}function eb(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?$N(Object(i),!0).forEach((function(t){_p(e,t,i[t]);})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):$N(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t));}));}return e}class tb extends Lg{getUserId(){return this._userId}constructor(e,t,i,n){super(e,"track-".concat(e.kind,"-").concat(t,"-").concat(n.clientId,"_").concat(ZI(5,""))),_p(this,"_userId",void 0),_p(this,"_uintId",void 0),_p(this,"_isDestroyed",!1),_p(this,"store",void 0),_p(this,"processor",void 0),_p(this,"processorContext",void 0),this._userId=t,this._uintId=i,this.store=n;}_updateOriginMediaStreamTrack(e){this._originMediaStreamTrack=e,this._mediaStreamTrack=e,this._updatePlayerSource(),this.processor&&this.processor.updateInput({track:this._originMediaStreamTrack,context:this.processorContext});}_destroy(){this._isDestroyed=!0,OE.info("[".concat(this.getTrackId(),"] is destroyed")),this.stop(),super.close();}getProcessorStats(){return this.processorContext.gatherStats()}getProcessorUsage(){return this.processorContext.gatherUsage()}}let ib=(BN=Dg({argsMap:(e,t,i)=>[e.getTrackId(),"string"==typeof t?t:t instanceof HTMLVideoElement?"HTMLVideoElement":"HTMLElement",i]}),GN=Dg({argsMap:e=>[e.getTrackId()]}),WN=Dg({argsMap:(e,t)=>[e.getTrackId(),t.name]}),HN=Dg({argsMap:e=>[e.getTrackId()]}),ag((KN=class extends tb{get isPlaying(){return !(!this._player||this._player.videoElementStatus!==sf.PLAYING)}get __className__(){return "RemoteVideoTrack"}constructor(e,t,i,n){super(e,t,i,n),_p(this,"_videoVisibleTimer",null),_p(this,"_previousVideoVisibleStatus",void 0),_p(this,"_clearPreviousVideoVisibleStatus",()=>this._previousVideoVisibleStatus=void 0),_p(this,"trackMediaType","video"),_p(this,"_videoWidth",void 0),_p(this,"_videoHeight",void 0),_p(this,"_player",void 0),_p(this,"processorDestination",void 0),_p(this,"processorContext",void 0),this.updateMediaStreamTrackResolution(),this.processorContext=new AR(this.getTrackId(),"remote"),this.processorDestination=new yR(this.processorContext),this.bindProcessorDestinationEvents();}getStats(){hC(()=>{OE.warning("[deprecated] RemoteVideoTrack.getStats will be removed in the future, use AgoraRTCClient.getRemoteVideoStats instead");},"remoteVideoTrackGetStatsWarning");return oC(this,uS.GET_STATS)||eb({},Wf)}play(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if("string"==typeof e){const t=document.getElementById(e);t?e=t:(OE.warning("[".concat(this.getTrackId(),'] can not find "#').concat(e,'" element, use document.body')),e=document.body);}OE.debug("[".concat(this.getTrackId(),"] start video playback in ").concat(e instanceof HTMLVideoElement?"HTMLVideoElement":"HTMLElement"),JSON.stringify(t));const i=eb(eb({fit:"cover"},t),{},{trackId:this.getTrackId(),element:e});this._player?this._player.updateConfig(i):(e instanceof HTMLVideoElement?this._player=new Pv(i):this._player=new kv(i),this._player.updateVideoTrack(this._mediaStreamTrack),this._player.onFirstVideoFrameDecoded=()=>{this.store.subscribe(this.getUserId(),"video",void 0,void 0,Date.now()),this.safeEmit(fS.FIRST_FRAME_DECODED);}),this._player.play(this.store.sessionId||void 0),this._videoVisibleTimer&&window.clearInterval(this._videoVisibleTimer),this._clearPreviousVideoVisibleStatus(),this._videoVisibleTimer=window.setInterval(()=>{try{const e=this.getVideoElementVisibleStatus();this.safeEmit(fS.VIDEO_ELEMENT_VISIBLE_STATUS,e);}catch(e){}},GE("CHECK_VIDEO_VISIBLE_INTERVAL"));}stop(){this._player&&(this._videoVisibleTimer&&(window.clearInterval(this._videoVisibleTimer),this._videoVisibleTimer=null),this._clearPreviousVideoVisibleStatus(),this._player.destroy(),this._player=void 0,OE.debug("[".concat(this.getTrackId(),"] stop video playback")));}getCurrentFrameData(){return this._player?this._player.getCurrentFrame():new ImageData(2,2)}updateMediaStreamTrackResolution(){tC(this._originMediaStreamTrack).then(e=>{let[t,i]=e;this._videoHeight=i,this._videoWidth=t;}).catch(eC);}_updatePlayerSource(){OE.debug("[".concat(this.getTrackId(),"] update player source track")),this._player&&this._player.updateVideoTrack(this._mediaStreamTrack);}getVideoElementVisibleStatus(){try{var e,t;const i=null==this||null===(e=this._player)||void 0===e?void 0:e.getContainerElement(),n={track:this,element:null==this||null===(t=this._player)||void 0===t?void 0:t.getVideoElement(),slot:null==i?void 0:i.parentElement},{element:r,slot:o}=n;if(this.isPlaying&&r instanceof HTMLVideoElement&&o instanceof HTMLElement){const e=gy.checkOneElementVisible(r),t=Object.assign({},e);if(t.visible!==this._previousVideoVisibleStatus){this._previousVideoVisibleStatus=t.visible;const e=Pg.reportApiInvoke(null,{tag:Ef.TRACER,name:_f.REMOTE_VIDEO_TRACK_GET_VIDEO_VISIBLE,options:[this.getTrackId()]});t.visible?e.onSuccess("Video is visible"):e.onSuccess("Invisible because of ".concat(t.reason));}return t}return}catch(e){throw new SE(fE.GET_VIDEO_ELEMENT_VISIBLE_ERROR,e.message)}}pipe(e){if(this.processor===e)return e;if(e._source)throw new SE(fE.INVALID_OPERATION,"Processor ".concat(e.name," already piped, please call unpipe beforehand."));return this.unpipe(),this.processor=e,this.processor._source=this,e.updateInput({track:this._originMediaStreamTrack,context:this.processorContext}),e}unpipe(){if(!this.processor)return;const e=this.processor;this.processor._source=void 0,this.processor=void 0,e.reset();}bindProcessorDestinationEvents(){this.processorDestination.on(kS.ON_TRACK,async e=>{e?e!==this._mediaStreamTrack&&(this._mediaStreamTrack=e,this._updatePlayerSource()):this._mediaStreamTrack!==this._originMediaStreamTrack&&(this._mediaStreamTrack=this._originMediaStreamTrack,this._updatePlayerSource());});}unbindProcessorDestinationEvents(){this.processorDestination.removeAllListeners(kS.ON_TRACK);}_destroy(){super._destroy(),this.unbindProcessorDestinationEvents();}}).prototype,"play",[BN],Object.getOwnPropertyDescriptor(KN.prototype,"play"),KN.prototype),ag(KN.prototype,"stop",[GN],Object.getOwnPropertyDescriptor(KN.prototype,"stop"),KN.prototype),ag(KN.prototype,"pipe",[WN],Object.getOwnPropertyDescriptor(KN.prototype,"pipe"),KN.prototype),ag(KN.prototype,"unpipe",[HN],Object.getOwnPropertyDescriptor(KN.prototype,"unpipe"),KN.prototype),KN),nb=(YN=Dg({argsMap:(e,t)=>[e.getTrackId(),t],throttleTime:300}),qN=Dg({argsMap:(e,t)=>[e.getTrackId(),t]}),JN=Dg({argsMap:e=>[e.getTrackId()]}),XN=Dg({argsMap:e=>[e.getTrackId()]}),zN=Dg({argsMap:(e,t)=>[e.getTrackId(),t.name]}),QN=Dg({argsMap:e=>[e.getTrackId()]}),ag((ZN=class extends tb{get isPlaying(){return this._useAudioElement?pR.isPlaying(this.getTrackId()):this._source.isPlayed}get __className__(){return "RemoteAudioTrack"}constructor(e,t,i,n){super(e,t,i,n),_p(this,"trackMediaType","audio"),_p(this,"_source",void 0),_p(this,"_useAudioElement",!0),_p(this,"_volume",100),_p(this,"processorContext",void 0),_p(this,"processorDestination",void 0),_p(this,"_played",!1),_p(this,"_bypassWebAudio",!1),GE("DISABLE_WEBAUDIO")?(this._source=new bR,this._bypassWebAudio=!0,this._useAudioElement=!0):(this._source=new Qg(e,!0),GE("REMOTE_AUDIO_TRACK_USES_WEB_AUDIO")&&(this._useAudioElement=!1)),this._source.once(Lf.RECEIVE_TRACK_BUFFER,()=>{this.safeEmit(fS.FIRST_FRAME_DECODED);}),this.processorContext=new NR(this._source.context,this.getTrackId(),"remote"),this.processorDestination=new OR(this.processorContext),this.bindProcessorDestinationEvents(),this._source.on(Lf.UPDATE_SOURCE,()=>{this.processor&&this.processor.updateInput({node:this._source.processSourceNode,context:this.processorContext});});}setAudioFrameCallback(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:4096;if(!e)return this._source.removeAllListeners(Lf.ON_AUDIO_BUFFER),void this._source.stopGetAudioBuffer();this._source.startGetAudioBuffer(t),this._source.removeAllListeners(Lf.ON_AUDIO_BUFFER),this._source.on(Lf.ON_AUDIO_BUFFER,t=>e(t));}setVolume(e){this._volume=e,this._useAudioElement?pR.setVolume(this.getTrackId(),e):this._source.setVolume(e/100);}async setPlaybackDevice(e){if(!this._useAudioElement)throw new SE(fE.NOT_SUPPORTED,"your browser does not support setting the audio output device");await pR.setSinkID(this.getTrackId(),e);}getVolumeLevel(){return this._source.getAccurateVolumeLevel()}getStats(){hC(()=>{OE.warning("[deprecated] RemoteAudioTrack.getStats will be removed in the future, use AgoraRTCClient.getRemoteAudioStats instead");},"remoteAudioTrackGetStatsWarning");return oC(this,uS.GET_STATS)||eb({},Bf)}play(){OE.debug("[".concat(this.getTrackId(),"] start audio playback")),this._played=!0,this._useAudioElement?(OE.debug("[".concat(this.getTrackId(),"] use audio element to play")),pR.play(this._mediaStreamTrack,this.getTrackId(),this._volume,this.store.sessionId||void 0)):this._source.play();}stop(){OE.debug("[".concat(this.getTrackId(),"] stop audio playback")),this._played=!1,this._useAudioElement?pR.stop(this.getTrackId()):this._source.stop();}_destroy(){super._destroy(),this._played=!1,this.unbindProcessorDestinationEvents(),this._source.destroy();}_isFreeze(){return this._source.isFreeze}_updatePlayerSource(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];OE.debug("[".concat(this.getTrackId(),"] update player source track")),e&&this._source.updateTrack(this._mediaStreamTrack),this._useAudioElement&&pR.updateTrack(this.getTrackId(),this._mediaStreamTrack);}pipe(e){if(this._bypassWebAudio)throw new SE(fE.NOT_SUPPORTED,"can not pipe extension when WebAudio disabled");if(this.processor===e)return e;if(e._source)throw new SE(fE.INVALID_OPERATION,"Processor ".concat(e.name," already piped, please call unpipe beforehand."));return this.unpipe(),this.processor=e,this.processor._source=this,e.updateInput({track:this._originMediaStreamTrack,node:this._source.processSourceNode,context:this.processorContext}),e}unpipe(){var e;if(this._bypassWebAudio)throw new SE(fE.NOT_SUPPORTED,"can not unpipe extension when WebAudio disabled");if(!this.processor)return;const t=this.processor;null===(e=this._source.processSourceNode)||void 0===e||e.disconnect(),this.processor._source=!1,this.processor=void 0,t.reset();}bindProcessorDestinationEvents(){this.processorDestination.on(kS.ON_TRACK,async e=>{e?e!==this._mediaStreamTrack&&(this._mediaStreamTrack=e,this._updatePlayerSource(!1),this._source.processedNode=this._source.createMediaStreamSourceNode(e)):this._mediaStreamTrack!==this._originMediaStreamTrack&&(this._mediaStreamTrack=this._originMediaStreamTrack,this._updatePlayerSource());}),this.processorDestination.on(kS.ON_NODE,e=>{this._source.processedNode=e;const t=!e;this._useAudioElement!==t&&(this._played?(this.stop(),this._useAudioElement=t,this.play()):this._useAudioElement=t);});}unbindProcessorDestinationEvents(){this.processorDestination.removeAllListeners(kS.ON_TRACK),this.processorDestination.removeAllListeners(kS.ON_NODE);}}).prototype,"setVolume",[YN],Object.getOwnPropertyDescriptor(ZN.prototype,"setVolume"),ZN.prototype),ag(ZN.prototype,"setPlaybackDevice",[qN],Object.getOwnPropertyDescriptor(ZN.prototype,"setPlaybackDevice"),ZN.prototype),ag(ZN.prototype,"play",[JN],Object.getOwnPropertyDescriptor(ZN.prototype,"play"),ZN.prototype),ag(ZN.prototype,"stop",[XN],Object.getOwnPropertyDescriptor(ZN.prototype,"stop"),ZN.prototype),ag(ZN.prototype,"pipe",[zN],Object.getOwnPropertyDescriptor(ZN.prototype,"pipe"),ZN.prototype),ag(ZN.prototype,"unpipe",[QN],Object.getOwnPropertyDescriptor(ZN.prototype,"unpipe"),ZN.prototype),ZN);function rb(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n);}return i}function ob(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?rb(Object(i),!0).forEach((function(t){_p(e,t,i[t]);})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):rb(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t));}));}return e}class sb extends EE{constructor(){super(),_p(this,"uplinkStatsUploadInterval",void 0),_p(this,"uplinkRelatedStatsUploadInterval",void 0),_p(this,"uplinkDenoiserStatsUploadInterval",void 0),_p(this,"transportStatsUploadInterval",void 0),_p(this,"uplinkExtensionStatsUploadInterval",void 0),_p(this,"downlinkExtensionStatsUploadInterval",void 0),_p(this,"extensionUsageStatsUploadInterval",void 0),_p(this,"downlinkStatsUploadInterval",void 0),_p(this,"downlinkRelatedStatsUploadInterval",void 0),_p(this,"lastStats",void 0),_p(this,"uploadUnplinkStarted",!1),_p(this,"uploadDownlinkStarted",!1),_p(this,"uploadTransportStarted",!1),_p(this,"uploadExtensionUsageStarted",!1),_p(this,"requestStats",void 0),_p(this,"requestLocalMedia",void 0),_p(this,"requestRemoteMedia",void 0),_p(this,"requestAllTracks",void 0),_p(this,"requestVideoIsReady",void 0),_p(this,"requestUpload",void 0);}startUploadTransportStats(){this.uploadTransportStarted||(this.uploadTransportStarted=!0,this.transportStatsUploadInterval&&window.clearInterval(this.transportStatsUploadInterval),this.transportStatsUploadInterval=window.setInterval(()=>{var e;const t=null===(e=this.requestStats)||void 0===e?void 0:e.call(this);t&&this.uploadTransportStats(t);},1e3));}startUploadExtensionUsageStats(){if(this.uploadExtensionUsageStarted)return;this.uploadExtensionUsageStarted=!0,this.extensionUsageStatsUploadInterval&&window.clearInterval(this.extensionUsageStatsUploadInterval);const e=new Map;this.extensionUsageStatsUploadInterval=window.setInterval(async()=>{var t,i,n;const r=Date.now(),o={connectionInterval:GE("EXTENSION_USAGE_UPLOAD_INTERVAL")/1e3,details:[],lts:r};let s=[];const a=(null===(t=this.requestAllTracks)||void 0===t?void 0:t.call(this))||[];for(const e of a)!e.muted&&e.enabled&&(s=s.concat(await e.getProcessorUsage()));const c=(null===(i=this.requestRemoteMedia)||void 0===i?void 0:i.call(this))||[];for(const[e,t]of c)t.has(AS.VIDEO)&&e.videoTrack&&(s=s.concat(await e.videoTrack.getProcessorUsage())),t.has(AS.AUDIO)&&e.audioTrack&&(s=s.concat(await e.audioTrack.getProcessorUsage()));if(0===s.length)return;o.details=function(e,t){const i={};for(const{id:s,value:a,level:c,direction:d}of e){var n;const e=null!==(n=t.get(s))&&void 0!==n?n:0,u=2===a?e+GE("EXTENSION_USAGE_UPLOAD_INTERVAL")/1e3:e;var r,o;t.set(s,u),i[s]?(2===a&&(i[s].value=a),c>i[s].level&&(i[s].level=c),"remote"===d&&(i[s].remoteUidCount+=1),i[s].totalTs=null!==(r=t.get(s))&&void 0!==r?r:0):i[s]={value:a,level:c,remoteUidCount:"local"===d?0:1,totalTs:null!==(o=t.get(s))&&void 0!==o?o:0};}return Object.keys(i).map(e=>{const{level:t,value:n,totalTs:r}=i[e];return {id:e,level:t,value:n,totalTs:r}})}(s,e);const d=Date.now(),u=d>r?d:r+1;null===(n=this.requestUpload)||void 0===n||n.call(this,wf.EXTENSION_USAGE_STATS,{usageStats:o,sendTs:u});},GE("EXTENSION_USAGE_UPLOAD_INTERVAL"));}startUploadUplinkStats(){this.uploadUnplinkStarted||(this.uploadUnplinkStarted=!0,this.uplinkStatsUploadInterval&&window.clearInterval(this.uplinkStatsUploadInterval),this.uplinkStatsUploadInterval=window.setInterval(()=>{var e;const t=null===(e=this.requestStats)||void 0===e?void 0:e.call(this);t&&(this.uploadUplinkStats(t),this.lastStats=t);},3e3),this.uplinkRelatedStatsUploadInterval&&window.clearInterval(this.uplinkRelatedStatsUploadInterval),this.uplinkRelatedStatsUploadInterval=window.setInterval(()=>{var e;const t=null===(e=this.requestStats)||void 0===e?void 0:e.call(this);t&&this.uploadRelatedUplinkStats(t,this.lastStats),this.lastStats=t;},1e3),this.uplinkDenoiserStatsUploadInterval&&window.clearInterval(this.uplinkDenoiserStatsUploadInterval),this.uplinkDenoiserStatsUploadInterval=window.setInterval(()=>{var e;const t=null===(e=this.requestAllTracks)||void 0===e?void 0:e.call(this);t&&this.uploadDenoiserStats(t);},2e3),this.uplinkExtensionStatsUploadInterval&&window.clearInterval(this.uplinkExtensionStatsUploadInterval),this.uplinkExtensionStatsUploadInterval=window.setInterval(()=>{var e;const t=null===(e=this.requestAllTracks)||void 0===e?void 0:e.call(this);t&&this.uploadExtensionStats(t);},2e3));}uploadTransportStats(e){dC(()=>{var t;null===(t=this.requestUpload)||void 0===t||t.call(this,wf.TRANSPORT_STATS,function(e){const t={connectionType:100,googRtt:e.rtt};if("relay"===e.selectedCandidatePair.localCandidate.candidateType){const i=e.selectedCandidatePair.localCandidate.relayProtocol;"udp"===i&&(t.connectionType=101),"tcp"===i&&(t.connectionType=103),"tls"===i&&(t.connectionType=104);}return t}(e));});}uploadUplinkStats(e){var t;((null===(t=this.requestLocalMedia)||void 0===t?void 0:t.call(this))||[]).forEach(t=>{let[i,{track:n,ssrcs:r}]=t;switch(i){case bS.LocalVideoLowTrack:case bS.LocalVideoTrack:{const t=function(e,t,i){var n;const r=t.videoSend.find(t=>t.ssrc===e);if(!r)return null;const o={id:ZI(10,""),timestamp:new Date(t.timestamp).toISOString(),mediaType:"video",type:"ssrc",ssrc:r.ssrc.toString()};switch(o.A_vstd=i._originMediaStreamTrack&&!i._originMediaStreamTrack.enabled||i._mediaStreamTrack&&!i._mediaStreamTrack.enabled?"1":"0",r.sentFrame&&(o.A_fhs=r.sentFrame.height.toString(),o.A_frs=r.sentFrame.frameRate.toString(),o.A_fws=r.sentFrame.width.toString()),r.adaptionChangeReason){case"none":o.A_ac="0";break;case"cpu":o.A_ac="1";break;case"bandwidth":o.A_ac="2";break;case"other":o.A_ac="3";}return o.A_lvps=af[i._player?i._player.videoElementStatus:"uninit"].toString(),o.A_nr=null===(n=r.nacksCount)||void 0===n?void 0:n.toString(),r.avgEncodeMs&&(o.A_aem=r.avgEncodeMs.toFixed(0).toString()),o}(r[0].ssrcId,e,n),o=i===bS.LocalVideoTrack?function(e,t,i){var n,r,o,s,a,c,d,u;const l=t.videoSend.find(t=>t.ssrc===e);if(!l)return null;const h={id:ZI(10,""),timestamp:new Date(t.timestamp).toISOString(),mediaType:"video",type:"ssrc",ssrc:l.ssrc.toString()},p=null!==(n=null!==(r=null===(o=l.inputFrame)||void 0===o?void 0:o.height)&&void 0!==r?r:null==i?void 0:i._videoHeight)&&void 0!==n?n:0,_=null!==(s=null!==(a=null===(c=l.inputFrame)||void 0===c?void 0:c.width)&&void 0!==a?a:null==i?void 0:i._videoWidth)&&void 0!==s?s:0,E=null!==(d=null===(u=l.inputFrame)||void 0===u?void 0:u.frameRate)&&void 0!==d?d:0;return p&&(h.A_fhi=p+""),_&&(h.A_fwi=_+""),E&&(h.A_fri=E+""),h}(r[0].ssrcId,e,n):null;t&&dC(()=>{var e;return null===(e=this.requestUpload)||void 0===e?void 0:e.call(this,wf.PUBLISH_STATS,{stream_type:i===bS.LocalVideoLowTrack?"low":"high",stats:ob(ob({},t),o)})});const s=function(e){const t={id:"bweforvideo",timestamp:new Date(e.timestamp).toISOString(),type:"VideoBwe"};return e.bitrate.retransmit&&(t.A_rb=e.bitrate.retransmit.toString()),e.bitrate.targetEncoded&&(t.A_teb=e.bitrate.targetEncoded.toString()),t.A_aeb=e.bitrate.actualEncoded.toString(),t.A_tb=e.bitrate.transmit.toString(),void 0!==e.sendBandwidth&&(t.A_asb=e.sendBandwidth.toString()),t}(e);s&&setTimeout(()=>{var e;return null===(e=this.requestUpload)||void 0===e?void 0:e.call(this,wf.PUBLISH_STATS,{stream_type:i===bS.LocalVideoLowTrack?"low":"high",stats:s})},1e3);break}case bS.LocalAudioTrack:{const t=function(e,t,i){const n=t.audioSend.find(t=>t.ssrc===e);if(!n)return null;const r={id:ZI(10,""),timestamp:new Date(t.timestamp).toISOString(),mediaType:"audio",type:"ssrc",ssrc:n.ssrc.toString()};return r.A_astd=i._originMediaStreamTrack&&!i._originMediaStreamTrack.enabled||i._mediaStreamTrack&&!i._mediaStreamTrack.enabled?"1":"0",n.inputLevel?r.A_ail=Math.round(100*n.inputLevel).toString():r.A_ail=Math.round(100*i._source.getAccurateVolumeLevel()).toString(),r.A_apil=Math.round(100*i._source.getAccurateVolumeLevel()).toString(),n.aecReturnLoss&&(r.A_ecrl=Math.round(n.aecReturnLoss).toString()),n.aecReturnLossEnhancement&&(r.A_ecrle=Math.round(n.aecReturnLossEnhancement).toString()),r}(r[0].ssrcId,e,n);t&&dC(()=>{var e;return null===(e=this.requestUpload)||void 0===e?void 0:e.call(this,wf.PUBLISH_STATS,{stream_type:"high",stats:t})});break}}});}uploadRelatedUplinkStats(e,t){var i;((null===(i=this.requestLocalMedia)||void 0===i?void 0:i.call(this))||[]).filter(e=>{let[t]=e;return t===bS.LocalVideoLowTrack||t===bS.LocalVideoTrack}).forEach(t=>{let[i,{ssrcs:n}]=t;const r=function(e,t){const i=t.videoSend.find(t=>t.ssrc===e);return i?{mediaType:"video",isVideoMute:!1,frameRateInput:i.inputFrame&&i.inputFrame.frameRate.toString(),frameRateSent:i.sentFrame&&i.sentFrame.frameRate.toString(),googRtt:i.rttMs.toString(),qpSumPerFrame:Math.floor(i.qpSumPerFrame).toString()}:null}(n[0].ssrcId,e);r&&dC(()=>{var e;null===(e=this.requestUpload)||void 0===e||e.call(this,wf.PUBLISH_RELATED_STATS,{stream_type:i===bS.LocalVideoLowTrack?"low":"high",stats:r});});});}uploadDenoiserStats(e){for(let r=0;r<e.length;r++){const o=e[r];if(o instanceof AI){var t,i,n;const e=null===(t=(i=o._external).getDenoiserStats)||void 0===t?void 0:t.call(i);return void(e&&(null===(n=this.requestUpload)||void 0===n||n.call(this,wf.DENOISER_STATS,e)))}}}uploadExtensionStats(e){for(let t=0;t<e.length;t++){e[t].getProcessorStats().forEach(e=>{var t;null===(t=this.requestUpload)||void 0===t||t.call(this,e.type,e.stats);});}}stopUploadUplinkStats(){this.uploadUnplinkStarted&&(this.uploadUnplinkStarted=!1,this.uplinkStatsUploadInterval&&window.clearInterval(this.uplinkStatsUploadInterval),this.uplinkRelatedStatsUploadInterval&&window.clearInterval(this.uplinkRelatedStatsUploadInterval),this.uplinkDenoiserStatsUploadInterval&&window.clearInterval(this.uplinkDenoiserStatsUploadInterval),this.uplinkStatsUploadInterval=void 0,this.uplinkRelatedStatsUploadInterval=void 0,this.uplinkDenoiserStatsUploadInterval=void 0);}startUploadDownlinkStats(){if(this.uploadDownlinkStarted)return;let e;this.uploadDownlinkStarted=!0,this.downlinkStatsUploadInterval&&window.clearInterval(this.downlinkStatsUploadInterval);let t=!1;this.downlinkStatsUploadInterval=window.setInterval(()=>{var i;const n=null===(i=this.requestStats)||void 0===i?void 0:i.call(this);n&&(this.uploadDownlinkStats(n,t,e),e=n),t=!t;},3e3),this.downlinkRelatedStatsUploadInterval&&window.clearInterval(this.downlinkRelatedStatsUploadInterval),this.downlinkRelatedStatsUploadInterval=window.setInterval(()=>{var e;const t=null===(e=this.requestStats)||void 0===e?void 0:e.call(this);t&&(this.uploadRelatedDownlinkStats(t,this.lastStats),this.lastStats=t);},1e3),this.downlinkExtensionStatsUploadInterval&&window.clearInterval(this.downlinkExtensionStatsUploadInterval),this.downlinkExtensionStatsUploadInterval=window.setInterval(()=>{var e;const t=null===(e=this.requestRemoteMedia)||void 0===e?void 0:e.call(this);t&&this.uploadDownlinkExtensionStats(t);},2e3);}uploadDownlinkStats(e,t,i){var n;((null===(n=this.requestRemoteMedia)||void 0===n?void 0:n.call(this))||[]).forEach(n=>{let[r,o]=n;if(o.has(AS.VIDEO)&&r.videoTrack){const n=r.videoTrack?function(e,t,i,n,r){const o=t.videoRecv.find(t=>t.ssrc===e);if(!o)return null;const s={id:ZI(10,""),timestamp:new Date(t.timestamp).toISOString(),mediaType:"video",type:"ssrc",ssrc:o.ssrc.toString()};var a,c;if(s.bytesReceived=o.bytes.toString(),s.packetsLost=o.packetsLost.toString(),s.packetsReceived=o.packets.toString(),o.framesRateFirefox&&(s.A_frr=o.framesRateFirefox.toString()),o.receivedFrame?(s.A_frr=o.receivedFrame.frameRate.toString(),s.A_fhr=o.receivedFrame.height.toString(),s.A_fwr=o.receivedFrame.width.toString()):(s.A_fhr=null===(a=n._videoHeight)||void 0===a?void 0:a.toString(),s.A_fwr=null===(c=n._videoWidth)||void 0===c?void 0:c.toString()),s.A_frd=o.decodeFrameRate.toString(),o.outputFrame&&(s.A_fro=o.outputFrame.frameRate.toString()),void 0!==o.jitterBufferMs&&(s.A_jbm=Math.floor(o.jitterBufferMs).toString()),void 0!==o.currentDelayMs&&(s.A_cdm=Math.floor(o.currentDelayMs).toString()),s.A_fs=o.firsCount.toString(),s.A_ns=o.nacksCount.toString(),s.A_ps=o.plisCount.toString(),n&&(s.A_vrtd=n._originMediaStreamTrack.enabled&&n._mediaStreamTrack.enabled?"0":"1"),n._player&&n._player.freezeTimeCounterList.length>0&&(s.A_vrft=Math.round(n._player.freezeTimeCounterList.splice(0,1)[0]).toString()),r&&n._player&&"visible"===MI.visibility){const e=Math.min(6e3,n._player.renderFreezeAccTime);s.A_vrrft=Math.round(e).toString(),n._player.renderFreezeAccTime=Math.max(0,n._player.renderFreezeAccTime-e);}if(s.A_rvps=af[n._player?n._player.videoElementStatus:"uninit"].toString(),i){const t=i.videoRecv.find(t=>t.ssrc===e);if(t&&void 0!==o.totalInterFrameDelay&&void 0!==o.totalSquaredInterFrameDelay&&void 0!==t.totalInterFrameDelay&&void 0!==t.totalSquaredInterFrameDelay){const e=o.totalInterFrameDelay-t.totalInterFrameDelay,i=o.totalSquaredInterFrameDelay-t.totalSquaredInterFrameDelay,n=o.framesDecodeCount-t.framesDecodeCount,r=e/n*1e3,a=Math.round(1e3*Math.sqrt((i-Math.pow(e,2)/n)/n));!isNaN(a)&&r+a>Math.max(3*r,r+150)&&(s.A_ifdsd=a.toString());}}return s}(r._videoSSRC,e,i,r.videoTrack,t):void 0;n&&dC(()=>{var e;return null===(e=this.requestUpload)||void 0===e?void 0:e.call(this,wf.SUBSCRIBE_STATS,{stream_id:r.uid,stats:n})});}if(o.has(AS.AUDIO)&&r.audioTrack){const t=r.audioTrack?function(e,t,i,n){const r=t.audioRecv.find(t=>t.ssrc===e);if(!r)return null;const o={id:ZI(10,""),timestamp:new Date(t.timestamp).toISOString(),mediaType:"audio",type:"ssrc",ssrc:r.ssrc.toString()};if(o.bytesReceived=r.bytes.toString(),o.packetsLost=r.packetsLost.toString(),o.packetsReceived=r.packets.toString(),r.outputLevel?o.A_aol=Math.round(100*r.outputLevel).toString():o.A_aol=Math.round(100*n._source.getAccurateVolumeLevel()).toString(),o.A_apol=Math.round(100*n._source.getAccurateVolumeLevel()).toString(),n&&(o.A_artd=n._originMediaStreamTrack.enabled&&n._mediaStreamTrack.enabled?"0":"1"),o.A_jr=r.jitterMs.toString(),o.A_jbm=Math.floor(r.jitterBufferMs).toString(),o.A_cdm=Math.floor(r.jitterBufferMs).toString(),o.A_raps=af[pR.getPlayerState(n.getTrackId())].toString(),i){const t=i.audioRecv.find(t=>t.ssrc===e);if(t){const e=r.concealedSamples-t.concealedSamples;e>0&&(o.A_cs=Math.round(e).toString());}}return o}(r._audioSSRC,e,i,r.audioTrack):void 0;t&&dC(()=>{var e;return null===(e=this.requestUpload)||void 0===e?void 0:e.call(this,wf.SUBSCRIBE_STATS,{stream_id:r.uid,stats:t})});}});}uploadRelatedDownlinkStats(e,t){var i;((null===(i=this.requestRemoteMedia)||void 0===i?void 0:i.call(this))||[]).forEach(i=>{let[n,r]=i;if(r.has(AS.VIDEO)&&n.videoTrack){var o;const i=!0===(n._videoSSRC&&(null===(o=this.requestVideoIsReady)||void 0===o?void 0:o.call(this,n._videoSSRC))||!1),r=function(e,t,i,n,r,o){const s=i.videoRecv.find(t=>t.ssrc===e),a=r?r.videoRecv.find(t=>t.ssrc===e):void 0;if(!s)return null;const c=kI.isRemoteVideoFreeze(o,s,a)&&t,d={mediaType:"video",isVideoMute:!1,peerId:n,frameRateReceived:s.receivedFrame&&s.receivedFrame.frameRate.toString(),frameRateDecoded:s.decodedFrame&&s.decodedFrame.frameRate.toString(),isFreeze:c,bytesReceived:s.bytes.toString(),packetsReceived:s.packets.toString(),packetsLost:s.packetsLost.toString(),qpSumPerFrame:Math.floor(s.qpSumPerFrame).toString()};return s.framesRateFirefox&&(d.frameRateDecoded=s.framesRateFirefox.toString(),d.frameRateReceived=s.framesRateFirefox.toString()),d}(n._videoSSRC,i,e,n.uid,t,n.videoTrack);r&&dC(()=>{var e;null===(e=this.requestUpload)||void 0===e||e.call(this,wf.SUBSCRIBE_RELATED_STATS,{stream_id:n.uid,stats:r});});}if(r.has(AS.AUDIO)&&n.audioTrack){const t=function(e,t,i,n){const r=t.audioRecv.find(t=>t.ssrc===e);if(!r)return null;const o=kI.isRemoteAudioFreeze(n);return {mediaType:"audio",isAudioMute:!1,peerId:i,googJitterReceived:r.jitterMs.toString(),isFreeze:o,bytesReceived:r.bytes.toString(),packetsReceived:r.packets.toString(),packetsLost:r.packetsLost.toString(),frameReceived:r.receivedFrames.toString(),frameDropped:r.droppedFrames.toString()}}(n._audioSSRC,e,n.uid,n.audioTrack);t&&dC(()=>{var e;null===(e=this.requestUpload)||void 0===e||e.call(this,wf.SUBSCRIBE_RELATED_STATS,{stream_id:n.uid,stats:t});});}});}stopUploadDownlinkStats(){this.uploadDownlinkStarted&&(this.uploadDownlinkStarted=!1,this.downlinkStatsUploadInterval&&window.clearInterval(this.downlinkStatsUploadInterval),this.downlinkRelatedStatsUploadInterval&&window.clearInterval(this.downlinkRelatedStatsUploadInterval),this.downlinkStatsUploadInterval=void 0,this.downlinkRelatedStatsUploadInterval=void 0);}stopUploadTransportStats(){this.uploadTransportStarted&&(this.uploadTransportStarted=!1,this.transportStatsUploadInterval&&window.clearInterval(this.transportStatsUploadInterval),this.transportStatsUploadInterval=void 0);}stopUploadExtensionUsageStats(){this.uploadExtensionUsageStarted&&(this.uploadExtensionUsageStarted=!1,this.extensionUsageStatsUploadInterval&&window.clearInterval(this.extensionUsageStatsUploadInterval),this.extensionUsageStatsUploadInterval=void 0);}uploadDownlinkExtensionStats(e){e.forEach(e=>{let[t,i]=e;if(i.has(AS.VIDEO)&&t.videoTrack){t.videoTrack.getProcessorStats().forEach(e=>{var t;null===(t=this.requestUpload)||void 0===t||t.call(this,e.type,e.stats);});}if(i.has(AS.AUDIO)&&t.audioTrack){t.audioTrack.getProcessorStats().forEach(e=>{var t;null===(t=this.requestUpload)||void 0===t||t.call(this,e.type,e.stats);});}});}}function ab(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n);}return i}function cb(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?ab(Object(i),!0).forEach((function(t){_p(e,t,i[t]);})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):ab(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t));}));}return e}const db="v=0\no=- 0 0 IN IP4 127.0.0.1\ns=AgoraGateway\nt=0 0\na=group:BUNDLE 0\na=msid-semantic: WMS\na=ice-lite\nm=application 9 UDP/DTLS/SCTP webrtc-datachannel\nc=IN IP4 127.0.0.1\na=mid:0\n",ub="9",lb=2e4,hb=4e4;class pb{get localCapabilities(){return uC(this._localCapabilities)}get rtpCapabilities(){return uC(this._rtpCapabilities)}get candidates(){return uC(this._candidates)}get iceParameters(){return uC(this._iceParameters)}get dtlsParameters(){return uC(this._dtlsParameters)}constructor(e){_p(this,"sessionDesc",void 0),_p(this,"_localCapabilities",void 0),_p(this,"_rtpCapabilities",void 0),_p(this,"_candidates",void 0),_p(this,"_iceParameters",void 0),_p(this,"_dtlsParameters",void 0),_p(this,"setup",void 0),_p(this,"currentMidIndex",void 0),_p(this,"cname",void 0),_p(this,"firefoxSsrcMidMap",new Map),e=uC(e);const{remoteIceParameters:t,remoteDtlsParameters:i,candidates:n,remoteRTPCapabilities:r,remoteSetup:o,localCapabilities:s,cname:a}=e,c=UO.exports.parse(db);this._rtpCapabilities=r,this._candidates=n,this._iceParameters=t,this._dtlsParameters=i,this._localCapabilities=s,this.setup=o,this.cname=a;const d=this.rtpCapabilities.send;for(const e of c.mediaDescriptions){if(e.attributes.iceUfrag=t.iceUfrag,e.attributes.icePwd=t.icePwd,e.attributes.fingerprints=i.fingerprints,e.attributes.candidates=n,e.attributes.setup=o,"application"===e.media.mediaType&&(e.attributes.sctpPort="5000"),"video"===e.media.mediaType&&(e.media.fmts=d.videoCodecs.map(e=>e.payloadType.toString(10)),e.attributes.payloads=d.videoCodecs,e.attributes.extmaps=d.videoExtensions,GE("PRELOAD_MEDIA_COUNT")>0)){const{ssrcs:t,ssrcGroups:i}=WO([{ssrcId:hb,rtx:GE("USE_SUB_RTX")?40001:void 0}],this.cname);e.attributes.ssrcs=t,e.attributes.ssrcGroups=i;}if("audio"===e.media.mediaType&&(e.media.fmts=d.audioCodecs.map(e=>e.payloadType.toString(10)),e.attributes.payloads=d.audioCodecs,e.attributes.extmaps=d.audioExtensions,$O(e),GE("PRELOAD_MEDIA_COUNT")>0)){const{ssrcs:t,ssrcGroups:i}=WO([{ssrcId:lb}],this.cname);e.attributes.ssrcs=t,e.attributes.ssrcGroups=i;}}this.sessionDesc=c,this.currentMidIndex=c.mediaDescriptions.length-1;}updateRemoteRTPCapabilities(e){const t=UO.exports.parse(db);this._rtpCapabilities=e;const i=this.rtpCapabilities.send;for(const e of t.mediaDescriptions){if(e.attributes.iceUfrag=this._iceParameters.iceUfrag,e.attributes.icePwd=this._iceParameters.icePwd,e.attributes.fingerprints=this._dtlsParameters.fingerprints,e.attributes.candidates=this._candidates,e.attributes.setup=this.setup,"application"===e.media.mediaType&&(e.attributes.sctpPort="5000"),"video"===e.media.mediaType&&(e.media.fmts=i.videoCodecs.map(e=>e.payloadType.toString(10)),e.attributes.payloads=i.videoCodecs,e.attributes.extmaps=i.videoExtensions,GE("PRELOAD_MEDIA_COUNT")>0)){const{ssrcs:t,ssrcGroups:i}=WO([{ssrcId:hb,rtx:GE("USE_SUB_RTX")?40001:void 0}],this.cname);e.attributes.ssrcs=t,e.attributes.ssrcGroups=i;}if("audio"===e.media.mediaType&&(e.media.fmts=i.audioCodecs.map(e=>e.payloadType.toString(10)),e.attributes.payloads=i.audioCodecs,e.attributes.extmaps=i.audioExtensions,GE("PRELOAD_MEDIA_COUNT")>0)){const{ssrcs:t,ssrcGroups:i}=WO([{ssrcId:lb}],this.cname);e.attributes.ssrcs=t,e.attributes.ssrcGroups=i;}}this.sessionDesc=t,this.currentMidIndex=t.mediaDescriptions.length-1;}preloadRemoteMedia(e){this.rtpCapabilities;const t=this.candidates,i=this.dtlsParameters,n=this.iceParameters,r=this.rtpCapabilities.send;for(let o=1;o<e;o++){const e=2*o+lb,s=2*o+hb,{ssrcs:a,ssrcGroups:c}=WO([{ssrcId:e}],this.cname),{ssrcs:d,ssrcGroups:u}=WO([{ssrcId:s,rtx:GE("USE_SUB_RTX")?s+1:void 0}],this.cname);this.sessionDesc.mediaDescriptions.push({media:{mediaType:"video",port:ub,protos:["UDP","TLS","RTP","SAVPF"],fmts:r.videoCodecs.map(e=>e.payloadType.toString(10))},connections:[{nettype:"IN",addrtype:"IP4",address:"127.0.0.1"}],bandwidths:[],attributes:{iceUfrag:n.iceUfrag,icePwd:n.icePwd,unrecognized:[],candidates:t,extmaps:r.videoExtensions,fingerprints:i.fingerprints,imageattr:[],msids:[],remoteCandidatesList:[],rids:[],ssrcs:d,ssrcGroups:u,rtcpFeedbackWildcards:[],payloads:r.videoCodecs,rtcp:{port:"9",netType:"IN",addressType:"IP4",address:"0.0.0.0"},setup:this.setup,direction:"sendonly",rtcpMux:!0,rtcpRsize:!0,mid:"".concat(2*o-1)}}),this.sessionDesc.mediaDescriptions.push({media:{mediaType:"audio",port:ub,protos:["UDP","TLS","RTP","SAVPF"],fmts:r.audioCodecs.map(e=>e.payloadType.toString(10))},connections:[{nettype:"IN",addrtype:"IP4",address:"127.0.0.1"}],bandwidths:[],attributes:{iceUfrag:n.iceUfrag,icePwd:n.icePwd,unrecognized:[],candidates:t,extmaps:r.audioExtensions,fingerprints:i.fingerprints,imageattr:[],msids:[],remoteCandidatesList:[],rids:[],ssrcs:a,ssrcGroups:c,rtcpFeedbackWildcards:[],payloads:r.audioCodecs,rtcp:{port:"9",netType:"IN",addressType:"IP4",address:"0.0.0.0"},setup:this.setup,direction:"sendonly",rtcpMux:!0,rtcpRsize:!0,mid:"".concat(2*o)}}),this.currentMidIndex+=2;}this.updateBundleMids();}toString(){return UO.exports.print(this.sessionDesc)}send(e,t,i,n){const{ssrcs:r,ssrcGroups:o}=WO(t,this.cname,GE("SYNC_GROUP")?i:void 0),s=this.findPreloadMediaDesc(r);if(s){if(Kh()&&this.firefoxSsrcMidMap.set(r[0].ssrcId,s.attributes.mid),n&&(n.twcc||n.remb)){const e=this.sessionDesc.mediaDescriptions.indexOf(s);return this.sessionDesc.mediaDescriptions[e]=this.mungSendMediaDesc(s,n),{mid:s.attributes.mid,needExchangeSDP:!0}}return {mid:s.attributes.mid,needExchangeSDP:!1}}{const t=this.findAvailableMediaIndex(e,r);let i;return -1===t||Hh()||Yh()||zh()||0===t&&GE("USE_SUB_RTX")?(i=this.createOrRecycleSendMedia(e,r,o,"sendonly",n),this.updateBundleMids()):(i=uC(this.sessionDesc.mediaDescriptions[t]),i.attributes.direction="sendonly",i.attributes.ssrcs=r,i.attributes.ssrcGroups=o,this.sessionDesc.mediaDescriptions[t]=this.mungSendMediaDesc(i,n)),Kh()&&this.firefoxSsrcMidMap.set(r[0].ssrcId,i.attributes.mid),{mid:i.attributes.mid,needExchangeSDP:!0}}}batchSend(e){const t=e.map(e=>{let{kind:t,ssrcMsg:i,mslabel:n}=e;return this.send(t,i,n)}),i=[];let n=!1;return t.forEach(e=>{let{mid:t,needExchangeSDP:r}=e;r&&(n=!0),i.push(t);}),{mids:i,needExchangeSDP:n}}stopSending(e){const t=this.sessionDesc.mediaDescriptions.filter(t=>t.attributes.mid&&-1!==e.indexOf(t.attributes.mid));if(t.length!==e.length)throw new Error("mediaDescriptions' length doesn't match mids' length when calling RemoteSDP.stopSending.");t.forEach(e=>{"0"===e.attributes.mid||Kh()||Hh()||Yh()?e.attributes.ssrcs=[]:(e.attributes.ssrcs=[],e.attributes.direction="inactive",e.media.port="0");}),this.updateBundleMids();}mute(e){const t=this.sessionDesc.mediaDescriptions.find(t=>t.attributes.mid===e);if(!t)throw new Error("mediaDescription not found with ".concat(e," in remote SDP when calling RemoteSDP.mute."));t.attributes.direction="inactive";}unmute(e){const t=this.sessionDesc.mediaDescriptions.find(t=>t.attributes.mid===e);if(!t)throw new Error("mediaDescription not found with ".concat(e," in remote SDP when calling RemoteSDP.unmute."));t.attributes.direction="sendonly";}muteRemote(e){const t=this.sessionDesc.mediaDescriptions.filter(t=>e.includes(t.attributes.mid||""));if(t.length!==e.length)throw new Error("mediaDescriptions' length doesn't match mids' length when calling RemoteSDP.muteRemote.");t.forEach(e=>{e.attributes.direction="inactive";});}unmuteRemote(e){const t=this.sessionDesc.mediaDescriptions.filter(t=>e.includes(t.attributes.mid||""));if(t.length!==e.length)throw new Error("mediaDescriptions' length doesn't match mids' length when calling RemoteSDP.muteRemote.");t.forEach(e=>{e.attributes.direction="recvonly";});}receive(e,t,i,n){e.forEach((e,r)=>{this.createOrRecycleRecvMedia(e,[],"recvonly",t,i,n[r]);}),this.updateBundleMids();}stopReceiving(e){const t=this.sessionDesc.mediaDescriptions.filter(t=>-1!==e.indexOf(t.attributes.mid));if(t.length!==e.length)throw new Error("MediaDescriptions' length doesn't match mids's length when calling RemoteSDP.receive.");t.forEach(e=>{e.media.port="0",e.attributes.direction="inactive";}),this.updateBundleMids();}updateCandidates(e){e===OS.TCP?this._candidates.forEach(e=>{-1===this._candidates.findIndex(t=>"tcp"===t.transport&&t.connectionAddress===e.connectionAddress&&t.port===e.port)&&this._candidates.push(cb(cb({},e),{},{foundation:"tcpcandidate",priority:Number(e.priority)-1+"",transport:"tcp",port:Number(e.port)+90+""}));}):this._candidates=this._candidates.filter(e=>"tcp"!==e.transport);for(const e of this.sessionDesc.mediaDescriptions)e.attributes.candidates=this.candidates;}restartICE(e){e=uC(e),this._iceParameters=e,this.sessionDesc.mediaDescriptions.forEach(t=>{t.attributes.iceUfrag=e.iceUfrag,t.attributes.icePwd=e.icePwd;});}predictReceivingMids(e){const t=[];for(let i=0;i<e;i++)t.push((this.currentMidIndex+i+1).toString(10));return t}findAvailableMediaIndex(e,t){return this.sessionDesc.mediaDescriptions.findIndex(i=>{const n=i.media.mediaType===e&&"0"!==i.media.port&&("sendonly"===i.attributes.direction||"sendrecv"===i.attributes.direction)&&0===i.attributes.ssrcs.length;if(Kh()){if(n){const e=this.firefoxSsrcMidMap.get(t[0].ssrcId);return !(e||"0"!==i.attributes.mid&&"1"!==i.attributes.mid)||!(!e||e!==i.attributes.mid)}return !1}return n})}createOrRecycleRecvMedia(e,t,i,n,r,o){const s=e._mediaStreamTrack.kind,a=this.rtpCapabilities.recv,c=this.localCapabilities.send;let d=[];if(s===AS.VIDEO){var u,l;if(GE("H264_PROFILE_LEVEL_ID")&&"h264"===n&&(d=a.videoCodecs.filter(e=>{var t,i;return ((null===(t=e.rtpMap)||void 0===t?void 0:t.encodingName.toLowerCase())||"").includes(n)&&(null==e||null===(i=e.fmtp)||void 0===i?void 0:i.parameters["profile-level-id"])===GE("H264_PROFILE_LEVEL_ID")})),!d||0===(null===(u=d)||void 0===u?void 0:u.length)){const e=c.videoCodecs.filter(e=>{var t;return ((null===(t=e.rtpMap)||void 0===t?void 0:t.encodingName.toLowerCase())||"").includes(n)});0!==e.length&&(d=a.videoCodecs.filter(t=>e.some(e=>e.payloadType===t.payloadType)));}if(GE("USE_PUB_RTX")){const e=d.map(e=>e.payloadType.toString()),t=a.videoCodecs.filter(t=>{var i,n;return "rtx"===(null===(i=t.rtpMap)||void 0===i?void 0:i.encodingName)&&e.includes((null===(n=t.fmtp)||void 0===n?void 0:n.parameters.apt)||"")});d=[...d,...t];}if(0===d.length)OE.warning("codec ".concat(n," not included in rtpCapabilities, fallback to default payloads: ").concat(null===(l=a.videoCodecs[0].rtpMap)||void 0===l?void 0:l.encodingName)),d=a.videoCodecs;}else d=a.audioCodecs.filter(e=>{var t;return ((null===(t=e.rtpMap)||void 0===t?void 0:t.encodingName.toLowerCase())||"").includes(r)}),0===d.length&&(OE.warning("codec ".concat(r," not included in rtpCapabilities, fallback to opus")),d=a.audioCodecs.filter(e=>{var t;return ((null===(t=e.rtpMap)||void 0===t?void 0:t.encodingName.toLowerCase())||"").includes("opus")}));const h=s===AS.VIDEO?a.videoExtensions:a.audioExtensions;this.currentMidIndex+=1;const p="".concat(this.currentMidIndex);let _={media:{mediaType:s,port:ub,protos:["UDP","TLS","RTP","SAVPF"],fmts:d.map(e=>e.payloadType.toString(10))},connections:[{nettype:"IN",addrtype:"IP4",address:"127.0.0.1"}],bandwidths:[],attributes:{iceUfrag:this.iceParameters.iceUfrag,icePwd:this.iceParameters.icePwd,unrecognized:[],candidates:this.candidates,extmaps:h,fingerprints:this.dtlsParameters.fingerprints,imageattr:[],msids:[],remoteCandidatesList:[],rids:[],ssrcs:t,ssrcGroups:[],rtcpFeedbackWildcards:[],payloads:d,rtcp:{port:"9",netType:"IN",addressType:"IP4",address:"0.0.0.0"},setup:this.setup,direction:i,rtcpMux:!0,rtcpRsize:!0,mid:"".concat(p)}};_=this.mungRecvMediaDsec(_,e,o);const E=this.findFirstClosedMedia(s);if(E){const e=this.sessionDesc.mediaDescriptions.indexOf(E);this.sessionDesc.mediaDescriptions[e]=_;}else this.sessionDesc.mediaDescriptions.push(_);return _}createOrRecycleSendMedia(e,t,i,n,r){const o=this.rtpCapabilities.send,s=e===AS.VIDEO?o.videoCodecs:o.audioCodecs,a=e===AS.VIDEO?o.videoExtensions:o.audioExtensions;this.currentMidIndex+=1;const c="".concat(this.currentMidIndex);let d={media:{mediaType:e,port:ub,protos:["UDP","TLS","RTP","SAVPF"],fmts:s.map(e=>e.payloadType.toString(10))},connections:[{nettype:"IN",addrtype:"IP4",address:"127.0.0.1"}],bandwidths:[],attributes:{iceUfrag:this.iceParameters.iceUfrag,icePwd:this.iceParameters.icePwd,unrecognized:[],candidates:this.candidates,extmaps:a,fingerprints:this.dtlsParameters.fingerprints,imageattr:[],msids:[],remoteCandidatesList:[],rids:[],ssrcs:t,ssrcGroups:i,rtcpFeedbackWildcards:[],payloads:s,rtcp:{port:"9",netType:"IN",addressType:"IP4",address:"0.0.0.0"},setup:this.setup,direction:n,rtcpMux:!0,rtcpRsize:!0,mid:"".concat(c)}};d=this.mungSendMediaDesc(d,r);const u=this.findFirstClosedMedia(e);if(u){const e=this.sessionDesc.mediaDescriptions.indexOf(u);this.sessionDesc.mediaDescriptions[e]=d;}else this.sessionDesc.mediaDescriptions.push(d);return d}updateBundleMids(){this.sessionDesc.attributes.groups[0].identificationTag=this.sessionDesc.mediaDescriptions.filter(e=>"0"!==e.media.port).map(e=>e.attributes.mid);}mungRecvMediaDsec(e,t,i){const n=uC(e);return KO(n),HO(n,t),YO(n,t),qO(n),JO(n,i,this.localCapabilities.send),n}mungSendMediaDesc(e,t){const i=uC(e);return JO(i,t,this.localCapabilities.recv),$O(i),i}updateRecvMedia(e,t){const i=this.sessionDesc.mediaDescriptions.findIndex(t=>t.attributes.mid===e);if(-1!==i){const e=this.mungRecvMediaDsec(this.sessionDesc.mediaDescriptions[i],t);this.sessionDesc.mediaDescriptions[i]=e;}}bumpMid(e){this.currentMidIndex+=e;}findFirstClosedMedia(e){return this.sessionDesc.mediaDescriptions.find(t=>Kh()?"0"===t.media.port&&t.media.mediaType===e:"0"===t.media.port)}findPreloadMediaDesc(e){return this.sessionDesc.mediaDescriptions.find(t=>{var i,n;return (null===(i=t.attributes)||void 0===i||null===(n=i.ssrcs[0])||void 0===n?void 0:n.ssrcId)===e[0].ssrcId})}getSSRC(e){var t;return null===(t=this.sessionDesc.mediaDescriptions.find(t=>t.attributes.mid===e))||void 0===t?void 0:t.attributes.ssrcs}}var _b;function Eb(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n);}return i}function mb(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?Eb(Object(i),!0).forEach((function(t){_p(e,t,i[t]);})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):Eb(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t));}));}return e}let fb=(ag((_b=class e extends YS{get currentLocalDescription(){return this.peerConnection.currentLocalDescription}get currentRemoteDescription(){return this.peerConnection.currentRemoteDescription}get peerConnectionState(){return this.peerConnection.connectionState}get iceConnectionState(){return this.peerConnection.iceConnectionState}constructor(e,t,i){super(e,t),_p(this,"store",void 0),_p(this,"peerConnection",void 0),_p(this,"remoteSDP",void 0),_p(this,"initialOffer",void 0),_p(this,"transportEventReceiver",void 0),_p(this,"statsFilter",void 0),_p(this,"localCapabilities",void 0),_p(this,"localCandidateCount",0),_p(this,"allCandidatesReceived",!1),_p(this,"establishPromise",void 0),_p(this,"mutex",new Ug("NVExtentionsConnection-mutex")),_p(this,"rtcMedia",void 0),this.store=t,this.peerConnection=i,this.statsFilter=vN(this.peerConnection,GE("STATS_UPDATE_INTERVAL"),void 0,Kh()?1200:void 0),this.bindPCEvents(),this.bindStatsEvents(),this.store.p2pId=this.store.p2pId+1,this.establishPromise=this.establish();}async establish(e){try{const e=await this.peerConnection.createOffer();if(!e.sdp)throw new Error("Cannot get initialOffer.sdp when trying to establish PeerConnection.");const t=FO(e.sdp),i=await zO(!GE("USE_PUB_RTX")&&!GE("USE_SUB_RTX"),GE("FILTER_VIDEO_FEC"),GE("FILTER_AUDIO_FEC"));return this.localCapabilities=i,this.initialOffer=e,mb(mb({},t),{},{rtpCapabilities:i,offerSDP:e.sdp})}catch(e){throw new SE(fE.GET_LOCAL_CONNECTION_PARAMS_FAILED,e.toString())}}async connect(e,t,i,n,r,o){try{if(!this.initialOffer)throw new Error("Cannot establish NVConnection without initial offer.");this.remoteSDP=new pb({remoteIceParameters:e,remoteDtlsParameters:t,candidates:i,remoteRTPCapabilities:n,remoteSetup:r,localCapabilities:ZO(this.localCapabilities),cname:o});const s=this.remoteSDP.toString(),a=UO.exports.parse(this.initialOffer.sdp),c=a.mediaDescriptions.find(e=>"audio"===e.media.mediaType);c&&$O(c);const d=UO.exports.print(a),u=this.logSDPExchange(d||"","offer","local","connect");await this.peerConnection.setLocalDescription({type:"offer",sdp:d}),null==u||u(s),await this.peerConnection.setRemoteDescription({type:"answer",sdp:s});}catch(e){throw new SE(fE.EXCHANGE_SDP_FAILED,"NV.connect failed; ".concat(e.toString()))}}async updateRemoteConnect(e){var t,i,n;null===(t=this.remoteSDP)||void 0===t||t.updateRemoteRTPCapabilities(e),null===(i=this.remoteSDP)||void 0===i||i.preloadRemoteMedia(2);const r=null===(n=this.remoteSDP)||void 0===n?void 0:n.toString();await this.peerConnection.setRemoteDescription({type:"offer",sdp:r});const o=await this.peerConnection.createAnswer();await this.peerConnection.setLocalDescription(o),OE.debug("[NVExtentionsConnection] updateRemoteRTPCapabilities by exchanging SDP.");}send(e,t,i){var n=this;return DO((function*(){const r=yield PO(n.mutex.lock("From NVExtentionsConnection.send"));try{if(!n.remoteSDP)throw new Error("Cannot call NVExtentionsConnection.send before remote SDP created");const o=[];e.forEach(e=>{const t=n.peerConnection.addTransceiver(e._mediaStreamTrack,{direction:"sendonly"});o.push(t);}),Kh()&&!0===GE("SIMULCAST")&&(yield PO(n.applySimulcastForFirefox(o,e)));const s=yield PO(n.peerConnection.createOffer()),a=n.remoteSDP.predictReceivingMids(e.length),c=n.mungSendOfferSDP(s.sdp,e,a),d=UO.exports.parse(c),u=a.map(e=>{const t=d.mediaDescriptions.find(t=>t.attributes.mid===e);if(!t)throw new Error("Cannot extract ssrc from mediaDescription.");return BO(t,GE("USE_PUB_RTX"))});let l;try{l=yield u;}catch(r){l=[],n.remoteSDP.receive(e,t,i,l);const o=n.remoteSDP.toString();throw yield PO(n.peerConnection.setLocalDescription({type:"offer",sdp:c})),yield PO(n.peerConnection.setRemoteDescription({type:"answer",sdp:o})),yield PO(n.stopSending(a,!0)),r}n.remoteSDP.receive(e,t,i,l);const h=n.remoteSDP.toString(),p=n.logSDPExchange(c,"offer","local","send");return yield PO(n.peerConnection.setLocalDescription({type:"offer",sdp:c})),yield PO(n.applySimulcastEncodings(o,e)),yield PO(n.applySendEncodings(o,e)),null==p||p(h),yield PO(n.peerConnection.setRemoteDescription({type:"answer",sdp:h})),o.map((e,t)=>{const i=a[t];return {localSSRC:u[t],id:i,transceiver:e}})}catch(e){throw e instanceof SE?e:new SE(fE.EXCHANGE_SDP_FAILED,"NVExtentionsConnection.send failed; ".concat(e.toString()))}finally{r();}}))()}async stopSending(e,t){const i=t?void 0:await this.mutex.lock("From NVExtentionsConnection.stopSending");try{if(!this.remoteSDP)throw new Error("Cannot call NVExtentionsConnection.stopSending before remote SDP created");const t=this.peerConnection.getTransceivers().filter(t=>-1!==e.indexOf(t.mid));if(t.length!==e.length)throw new Error("Transceivers' length doesn't match mids' length when trying to call NVExtentionsConnection.stopSending.");t.map(e=>{var t;e.direction="inactive",null===(t=e.stop)||void 0===t||t.call(e);});const n=await this.peerConnection.createOffer(),r=this.logSDPExchange(n.sdp||"","offer","local","stopSending");await this.peerConnection.setLocalDescription(n),this.remoteSDP.stopReceiving(e);const o=this.remoteSDP.toString();null==r||r(o),await this.peerConnection.setRemoteDescription({type:"answer",sdp:o});}catch(e){throw new SE(fE.EXCHANGE_SDP_FAILED,"NVExtentionsConnection.stopSending failed; ".concat(e.toString()))}finally{i&&i();}}async receive(e,t,i,n){try{if(!this.remoteSDP)throw new Error("Cannot call NVExtentionsConnection.receive ".concat(e," before remoteSDP created."));const{mid:r,needExchangeSDP:o}=this.remoteSDP.send(e,t,i,n);if(o){const t=this.remoteSDP.toString(),i=this.logSDPExchange(t,"offer","remote","receive");await this.peerConnection.setRemoteDescription({type:"offer",sdp:t});const n=await this.peerConnection.createAnswer(),o=this.mungReceiveAnswerSDP(n.sdp,r,e);null==i||i(o||""),await this.peerConnection.setLocalDescription({type:"answer",sdp:o}),OE.debug("[NVExtentionsConnection] receive ".concat(e," by exchanging SDP."));}else OE.debug("[NVExtentionsConnection] receive ".concat(e," no need to exchange SDP."));const s=this.peerConnection.getTransceivers().find(e=>e.mid===r);if(!s)throw new Error("Cannot get transceiver after setLocalDescription.");return {track:s.receiver.track,id:r}}catch(e){throw new SE(fE.EXCHANGE_SDP_FAILED,"NVExtentionsConnection.receive failed; ".concat(e.toString()))}}async batchReceive(e){try{if(!this.remoteSDP)throw new Error("Cannot call NVExtentionsConnection.batchReceive before remoteSDP created.");const{mids:t,needExchangeSDP:i}=this.remoteSDP.batchSend(e);if(i){const e=this.remoteSDP.toString(),t=this.logSDPExchange(e,"offer","remote","receive");await this.peerConnection.setRemoteDescription({type:"offer",sdp:e});const i=await this.peerConnection.createAnswer();null==t||t(i.sdp||""),await this.peerConnection.setLocalDescription(i),OE.debug("[NVExtentionsConnection] batchReceive by exchanging SDP.");}else OE.debug("[NVExtentionsConnection] batchReceive no need to exchange SDP.");return t.map(e=>{const t=this.peerConnection.getTransceivers().find(t=>t.mid===e);if(!t)throw new Error("Cannot get transceiver after setLocalDescription.");return {track:t.receiver.track,id:e}})}catch(e){throw new SE(fE.EXCHANGE_SDP_FAILED,"NVExtentionsConnection.receive failed; ".concat(e.toString()))}}async stopReceiving(e){try{if(!this.remoteSDP)throw new Error("Cannot call NVExtentionsConnection.stopReceiving before remote SDP created.");this.remoteSDP.stopSending(e);const t=this.remoteSDP.toString(),i=this.logSDPExchange(t,"offer","remote","stopReceiving");await this.peerConnection.setRemoteDescription({type:"offer",sdp:t});const n=await this.peerConnection.createAnswer();null==i||i(n.sdp||""),await this.peerConnection.setLocalDescription(n);}catch(e){throw new SE(fE.EXCHANGE_SDP_FAILED,"NVExtentionsConnection stopReceiving failed; ".concat(e.toString()))}}async muteRemote(e){try{if(!this.remoteSDP)throw new Error("Cannot call NVExtentionsConnection.muteRemote mid=".concat(e," before remote SDP created."));this.remoteSDP.mute(e);const t=this.remoteSDP.toString(),i=this.logSDPExchange(t,"offer","remote","muteRemote");await this.peerConnection.setRemoteDescription({type:"offer",sdp:t});const n=await this.peerConnection.createAnswer();null==i||i(n.sdp||""),await this.peerConnection.setLocalDescription(n);}catch(e){throw new SE(fE.EXCHANGE_SDP_FAILED,"NVExtentionsConnection.muteRemote failed; ".concat(e.toString()))}}async unmuteRemote(e){try{if(!this.remoteSDP)throw new Error("Cannot call NVExtentionsConnection.unmuteRemote mid=".concat(e," before remote SDP created."));this.remoteSDP.unmute(e);const t=this.remoteSDP.toString(),i=this.logSDPExchange(t,"offer","remote","unmuteRemote");await this.peerConnection.setRemoteDescription({type:"offer",sdp:t});const n=await this.peerConnection.createAnswer();null==i||i(n.sdp||""),await this.peerConnection.setLocalDescription(n);}catch(e){throw new SE(fE.EXCHANGE_SDP_FAILED,"NVExtentionsConnection.unmuteRemote failed; ".concat(e.toString()))}}async muteLocal(e){try{if(!this.remoteSDP)throw new Error("Cannot call NVExtentionsConnection.muteLocal before remote SDP created.");const t=this.peerConnection.getTransceivers().filter(t=>t.mid&&-1!==e.indexOf(t.mid));if(t.length!==e.length)throw new Error("Transceivers' length doesn't match mids' length.");t.map(e=>{e.direction="inactive";});const i=await this.peerConnection.createOffer(),n=this.logSDPExchange(i.sdp||"","offer","local","muteLocal");await this.peerConnection.setLocalDescription(i),this.remoteSDP.muteRemote(e);const r=this.remoteSDP.toString();null==n||n(r),await this.peerConnection.setRemoteDescription({type:"answer",sdp:r});}catch(e){throw new SE(fE.EXCHANGE_SDP_FAILED,"NVExtentionsConnection.muteLocal failed; ".concat(e.toString()))}}async unmuteLocal(e){try{if(!this.remoteSDP)throw new Error("Cannot call NVExtentionsConnection.unmuteLocal before remote SDP created.");const t=this.peerConnection.getTransceivers().filter(t=>t.mid&&-1!==e.indexOf(t.mid));if(t.length!==e.length)throw new Error("Transceivers' length doesn't match mids' length.");t.map(async(e,t)=>{e.direction="sendonly";});const i=await this.peerConnection.createOffer(),n=this.logSDPExchange(i.sdp||"","offer","local","unmuteLocal");await this.peerConnection.setLocalDescription(i),this.remoteSDP.unmuteRemote(e);const r=this.remoteSDP.toString();null==n||n(r),await this.peerConnection.setRemoteDescription({type:"answer",sdp:r});}catch(e){throw new SE(fE.EXCHANGE_SDP_FAILED,"NVExtentionsConnection.unmuteLocal failed; ".concat(e.toString()))}}restartICE(e){var t=this;return DO((function*(){const i=yield PO(t.mutex.lock("From NVExtentionsConnection.restartICE"));try{if(!t.remoteSDP)throw new Error("Cannot restartICE before remoteSDP created.");if(JS().supportPCSetConfiguration){const i=t.peerConnection.getConfiguration(),n=e===OS.RELAY?"relay":"all";i.iceTransportPolicy!==n&&(OE.debug("restartICE change iceTransportPolicy from [".concat(i.iceTransportPolicy,"] to [").concat(n,"]")),i.iceTransportPolicy=n,t.peerConnection.setConfiguration(i));}else if(e===OS.RELAY)return;e!==OS.RELAY&&t.remoteSDP.updateCandidates(e);const n=yield PO(t.peerConnection.createOffer({iceRestart:!0}));if(!n.sdp)throw new Error("Cannot restartICE because restart offer SDP does not exist.");const r=FO(n.sdp),{remoteIceParameters:o}=yield r.iceParameters;t.remoteSDP.restartICE(o);const s=t.remoteSDP.toString(),a=t.logSDPExchange(n.sdp||"","offer","local","restartICE");yield PO(t.peerConnection.setLocalDescription(n)),null==a||a(s),yield PO(t.peerConnection.setRemoteDescription({type:"answer",sdp:s}));}catch(e){OE.warning("restart ICE failed, abort operation",e);}finally{i();}}))()}close(){var e;null===(e=this.onConnectionStateChange)||void 0===e||e.call(this,"closed"),this.unbindPCEvents(),this.unbindStatsEvents(),this.removeAllListeners(),this.transportEventReceiver=void 0,this.statsFilter.destroy();}getStats(){return this.statsFilter.getStats()}getRemoteVideoIsReady(e){return this.statsFilter.getVideoIsReady(e)}async updateEncoderConfig(e,t){try{if(!this.remoteSDP)throw new Error("Cannot call NVExtentionsConnection.updateEncoderConfig before remote SDP created.");const i=await this.peerConnection.createOffer(),n=this.mungSendOfferSDP(i.sdp,[t],[e]);this.remoteSDP.updateRecvMedia(e,t);const r=this.remoteSDP.toString(),o=this.logSDPExchange(n,"offer","local","updateEncoderConfig");await this.peerConnection.setLocalDescription({type:"offer",sdp:n}),null==o||o(r),await this.peerConnection.setRemoteDescription({type:"answer",sdp:r});}catch(e){throw new SE(fE.EXCHANGE_SDP_FAILED,e.toString())}}async updateSendParameters(e,t){const i=this.peerConnection.getTransceivers().filter(t=>t.mid===e);1===i.length&&(this.isVP8Simulcast(t)?Kh()||await this.applySimulcastEncodings(i,[t]):await this.applySendEncodings(i,[t]));}setStatsRemoteVideoIsReady(e,t){this.statsFilter.setVideoIsReady2(e,t);}async replaceTrack(e,t){const i=this.peerConnection.getTransceivers().find(e=>e.mid===t);i&&await i.sender.replaceTrack(e._mediaStreamTrack);}getP2PConnectionParams(){var e;if(null===(e=this.peerConnection.currentLocalDescription)||void 0===e||!e.sdp||!this.localCapabilities)throw new Error;return mb(mb({},FO(this.peerConnection.currentLocalDescription.sdp)),{},{rtpCapabilities:this.localCapabilities})}bindPCEvents(){this.peerConnection.oniceconnectionstatechange=()=>{var e;null===(e=this.onICEConnectionStateChange)||void 0===e||e.call(this,this.peerConnection.iceConnectionState);},this.peerConnection.onconnectionstatechange=()=>{var e;null===(e=this.onConnectionStateChange)||void 0===e||e.call(this,this.peerConnection.connectionState);},this.peerConnection.onicecandidate=e=>{e.candidate?this.localCandidateCount+=1:(this.peerConnection.onicecandidate=null,this.allCandidatesReceived=!0,OE.debug("[pc-".concat(this.store.p2pId,"] local candidate count"),this.localCandidateCount));},setTimeout(()=>{this.allCandidatesReceived||(this.allCandidatesReceived=!0,OE.debug("[pc-".concat(this.store.p2pId,"] onicecandidate timeout, local candidate count"),this.localCandidateCount));},GE("CANDIDATE_TIMEOUT"));}unbindPCEvents(){this.peerConnection.oniceconnectionstatechange=null,this.peerConnection.onconnectionstatechange=null,this.peerConnection.onsignalingstatechange=null,this.peerConnection.onicecandidateerror=null,this.peerConnection.onicecandidate=null,this.peerConnection.ontrack=null;}static resolvePCConfiguration(t){const i={iceServers:[]};return t.iceServers?i.iceServers=t.iceServers:t.turnServer&&"off"!==t.turnServer.mode&&(Uf(t.turnServer.servers)?i.iceServers=t.turnServer.servers:(i.iceServers&&i.iceServers.push(...e.turnServerConfigToIceServers(t.turnServer.servers)),GE("USE_TURN_SERVER_OF_GATEWAY")&&i.iceServers&&t.turnServer.serversFromGateway&&i.iceServers.push(...e.turnServerConfigToIceServers(t.turnServer.serversFromGateway)),GE("FORCE_TURN_TCP")?i.iceTransportPolicy="relay":t.turnServer.servers.concat(t.turnServer.serversFromGateway||[]).forEach(e=>{e.forceturn&&(i.iceTransportPolicy="relay");}))),i}static turnServerConfigToIceServers(e){const t=[];return e.forEach(e=>{e.security?e.tcpport&&t.push({username:e.username,credential:e.password,credentialType:"password",urls:"turns:".concat(VI(e.turnServerURL),":").concat(e.tcpport,"?transport=tcp")}):(e.udpport&&!GE("FORCE_TURN_TCP")&&t.push({username:e.username,credential:e.password,credentialType:"password",urls:"turn:".concat(e.turnServerURL,":").concat(e.udpport,"?transport=udp")}),e.tcpport&&t.push({username:e.username,credential:e.password,credentialType:"password",urls:"turn:".concat(e.turnServerURL,":").concat(e.tcpport,"?transport=tcp")}));}),t}async applySendEncodings(e,t){try{if(!JS().supportSetRtpSenderParameters)return;if(e.length!==t.length)return;for(let c=0;c<e.length;c++){const d=e[c],u=t[c];if(u&&u instanceof Cy){var i,n;if(this.isVP8Simulcast(u))continue;const e={},t={};switch(u._optimizationMode){case"motion":e.degradationPreference="maintain-framerate";break;case"detail":e.degradationPreference="maintain-resolution";break;default:e.degradationPreference="balanced";}var r,o,s,a;if(null!==(i=u._encoderConfig)&&void 0!==i&&i.bitrateMax)t.maxBitrate=1e3*(null===(r=u._encoderConfig)||void 0===r?void 0:r.bitrateMax);if(u._hints.includes(lS.LOW_STREAM))null!==(o=u._encoderConfig)&&void 0!==o&&o.frameRate&&(t.maxFramerate=FI(u._encoderConfig.frameRate)),null!==(s=u._encoderConfig)&&void 0!==s&&s.scaleResolutionDownBy&&(null===(a=u._encoderConfig)||void 0===a?void 0:a.scaleResolutionDownBy)>1&&(t.scaleResolutionDownBy=u._encoderConfig.scaleResolutionDownBy);if(GE("DSCP_TYPE")&&rp()){const e=GE("DSCP_TYPE");["very-low","low","medium","high"].includes(e)&&(t.networkPriority=e);}const c=d.sender.getParameters(),l=null===(n=c.encodings)||void 0===n?void 0:n[0];Kh()&&!l&&(e.encodings=[t]),l&&Object.assign(l,t),Object.assign(c,e),await d.sender.setParameters(c);}}}catch(e){OE.debug("Apply RTPSendEncodings failed.");}}mungSendOfferSDP(e,t,i){const n=UO.exports.parse(e);return t.forEach((e,t)=>{const r=i[t],o=n.mediaDescriptions.find(e=>e.attributes.mid===r);o&&(HO(o,e),XO(o,e,this.store.codec));}),UO.exports.print(n)}mungReceiveAnswerSDP(e,t,i){const n=UO.exports.parse(e),r=n.mediaDescriptions.find(e=>e.attributes.mid===t);return r&&i===AS.AUDIO&&"audio"===r.media.mediaType&&$O(r),UO.exports.print(n)}bindStatsEvents(){this.statsFilter.onFirstAudioReceived=e=>{var t;null===(t=this.onFirstAudioReceived)||void 0===t||t.call(this,e);},this.statsFilter.onFirstVideoReceived=e=>{var t;null===(t=this.onFirstVideoReceived)||void 0===t||t.call(this,e);},this.statsFilter.onFirstAudioDecoded=e=>{var t;null===(t=this.onFirstAudioDecoded)||void 0===t||t.call(this,e);},this.statsFilter.onFirstVideoDecoded=(e,t,i)=>{var n;null===(n=this.onFirstVideoDecoded)||void 0===n||n.call(this,e,t,i);},this.statsFilter.onSelectedLocalCandidateChanged=(e,t)=>{var i;null===(i=this.onSelectedLocalCandidateChanged)||void 0===i||i.call(this,e,t);},this.statsFilter.onSelectedRemoteCandidateChanged=(e,t)=>{var i;null===(i=this.onSelectedRemoteCandidateChanged)||void 0===i||i.call(this,e,t);},this.statsFilter.onFirstVideoDecodedTimeout=e=>{var t;null===(t=this.onFirstVideoDecodedTimeout)||void 0===t||t.call(this,e);};}unbindStatsEvents(){this.statsFilter.onFirstAudioReceived=void 0,this.statsFilter.onFirstVideoReceived=void 0,this.statsFilter.onFirstAudioDecoded=void 0,this.statsFilter.onFirstVideoDecoded=void 0,this.statsFilter.onSelectedLocalCandidateChanged=void 0,this.statsFilter.onSelectedRemoteCandidateChanged=void 0,this.statsFilter.onFirstVideoDecodedTimeout=void 0;}async applySimulcastForFirefox(e,t){if(e.length===t.length)for(let s=0;s<e.length;s++){var i,n,r,o;const a=e[s],c=t[s];if(c instanceof Cy&&!c._hints.includes(lS.LOW_STREAM)&&null!==(i=c._encoderConfig)&&void 0!==i&&i.bitrateMax&&(null===(n=c._encoderConfig)||void 0===n?void 0:n.bitrateMax)>200&&null!==(r=c._scalabiltyMode)&&void 0!==r&&r.numSpatialLayers&&(null===(o=c._scalabiltyMode)||void 0===o?void 0:o.numSpatialLayers)>1&&"vp8"===this.store.codec){const e={},t={high:1e3*(c._encoderConfig.bitrateMax-50),medium:5e4};e.encodings=[{rid:"m",active:!0,maxBitrate:t.medium,scaleResolutionDownBy:4},{rid:"h",active:!0,maxBitrate:t.high}];const i=a.sender.getParameters();await a.sender.setParameters(Object.assign(i,e));}}}async applySimulcastEncodings(e,t){if(!Kh()&&e.length===t.length)for(let i=0;i<e.length;i++){const n=t[i];if(n instanceof Cy&&this.isVP8Simulcast(n)){const t=e[i],r={},o={high:1e3*(n._encoderConfig.bitrateMax-50),medium:5e4};r.encodings=[{active:!0,adaptivePtime:!1,networkPriority:"high",priority:"high",maxBitrate:o.high},{active:!0,adaptivePtime:!1,networkPriority:"low",priority:"low",maxBitrate:o.medium,scaleResolutionDownBy:4}];const s=t.sender.getParameters();await t.sender.setParameters(Object.assign(s,r));}}}isVP8Simulcast(e){var t,i,n,r;return !!(e instanceof Cy&&GE("SIMULCAST")&&"vp8"===this.store.codec&&!e._hints.includes(lS.LOW_STREAM)&&null!==(t=e._encoderConfig)&&void 0!==t&&t.bitrateMax&&(null===(i=e._encoderConfig)||void 0===i?void 0:i.bitrateMax)>200&&null!==(n=e._scalabiltyMode)&&void 0!==n&&n.numSpatialLayers&&(null===(r=e._scalabiltyMode)||void 0===r?void 0:r.numSpatialLayers)>1)}logSDPExchange(e,t,i,n){if(GE("SDP_LOGGING"))return OE.upload("exchanging ".concat(i," ").concat(t," SDP during NVExtentionsConnection.").concat(n,"\n"),e),"offer"===t?e=>{this.logSDPExchange(e,"answer","local"===i?"remote":"local",n);}:void 0}async getRemoteSSRC(e){if(!this.remoteSDP)return;const t=this.remoteSDP.getSSRC(e);return null==t?void 0:t[0].ssrcId}setConfiguration(t){if(JS().supportPCSetConfiguration){const i=e.resolvePCConfiguration(t);this.peerConnection.setConfiguration(i);}}}).prototype,"connect",[Sb],Object.getOwnPropertyDescriptor(_b.prototype,"connect"),_b.prototype),ag(_b.prototype,"updateRemoteConnect",[Sb],Object.getOwnPropertyDescriptor(_b.prototype,"updateRemoteConnect"),_b.prototype),ag(_b.prototype,"receive",[Sb],Object.getOwnPropertyDescriptor(_b.prototype,"receive"),_b.prototype),ag(_b.prototype,"batchReceive",[Sb],Object.getOwnPropertyDescriptor(_b.prototype,"batchReceive"),_b.prototype),ag(_b.prototype,"stopReceiving",[Sb],Object.getOwnPropertyDescriptor(_b.prototype,"stopReceiving"),_b.prototype),ag(_b.prototype,"muteRemote",[Sb],Object.getOwnPropertyDescriptor(_b.prototype,"muteRemote"),_b.prototype),ag(_b.prototype,"unmuteRemote",[Sb],Object.getOwnPropertyDescriptor(_b.prototype,"unmuteRemote"),_b.prototype),ag(_b.prototype,"muteLocal",[Sb],Object.getOwnPropertyDescriptor(_b.prototype,"muteLocal"),_b.prototype),ag(_b.prototype,"unmuteLocal",[Sb],Object.getOwnPropertyDescriptor(_b.prototype,"unmuteLocal"),_b.prototype),ag(_b.prototype,"close",[Sb],Object.getOwnPropertyDescriptor(_b.prototype,"close"),_b.prototype),ag(_b.prototype,"updateEncoderConfig",[Sb],Object.getOwnPropertyDescriptor(_b.prototype,"updateEncoderConfig"),_b.prototype),ag(_b.prototype,"updateSendParameters",[Sb],Object.getOwnPropertyDescriptor(_b.prototype,"updateSendParameters"),_b.prototype),ag(_b.prototype,"replaceTrack",[Sb],Object.getOwnPropertyDescriptor(_b.prototype,"replaceTrack"),_b.prototype),ag(_b.prototype,"getRemoteSSRC",[Sb],Object.getOwnPropertyDescriptor(_b.prototype,"getRemoteSSRC"),_b.prototype),_b);function Sb(e,t,i){const n=e[t];if("function"!=typeof n)throw new Error("Cannot use mutex on object property.");return i.value=async function(){const e=this.mutex,i=await e.lock("From NVExtentionsConnection.".concat(t));try{for(var r=arguments.length,o=new Array(r),s=0;s<r;s++)o[s]=arguments[s];return await n.apply(this,o)}finally{i();}},i}var Tb;function gb(e){var t,i,n,r=2;for("undefined"!=typeof Symbol&&(i=MO,n=Symbol.iterator);r--;){if(i&&null!=(t=e[i]))return t.call(e);if(n&&null!=(t=e[n]))return new Rb(t.call(e));i="@@asyncIterator",n="@@iterator";}throw new TypeError("Object is not async iterable")}function Rb(e){function t(e){if(Object(e)!==e)return Sl.reject(new TypeError(e+" is not an object."));var t=e.done;return Sl.resolve(e.value).then((function(e){return {value:e,done:t}}))}return (Rb=function(e){this.s=e,this.n=e.next;}).prototype={s:null,n:null,next:function(){return t(this.n.apply(this.s,arguments))},return:function(e){var i=this.s.return;return void 0===i?Sl.resolve({value:e,done:!0}):t(i.apply(this.s,arguments))},throw:function(e){var i=this.s.return;return void 0===i?Sl.reject(e):t(i.apply(this.s,arguments))}},new Rb(e)}let Ib=(ag((Tb=class e extends YS{get currentLocalDescription(){return this.peerConnection.currentLocalDescription}get currentRemoteDescription(){return this.peerConnection.currentRemoteDescription}get peerConnectionState(){return this.peerConnection.connectionState}get iceConnectionState(){return this.peerConnection.iceConnectionState}constructor(t,i){super(t,i),_p(this,"store",void 0),_p(this,"peerConnection",void 0),_p(this,"cname",void 0),_p(this,"mutex",new Ug("DataChannelConnection-mutex")),_p(this,"dataChannel",void 0),_p(this,"_p2pConnection",void 0),_p(this,"establishPromise",void 0),_p(this,"_nvMedia",void 0),this.store=i,this.store.dcId=this.store.dcId+1,this.peerConnection=new RTCPeerConnection(e.resolvePCConfiguration(t),{optional:[{googDscp:!0}]}),this.dataChannel=this.peerConnection.createDataChannel("agora-signal",{ordered:!1,maxPacketLifeTime:50}),this.dataChannel.binaryType="arraybuffer",this._p2pConnection=new fb(t,i,this.peerConnection),this.bindPCEvents(),this.establishPromise=this._p2pConnection.establishPromise;}async establish(){var e;const t=null===(e=this._nvMedia)||void 0===e?void 0:e.getLocalRtpCapabilities();return await this._p2pConnection.establish(t)}getP2PConnectionParams(){return this._p2pConnection.getP2PConnectionParams()}async connect(e,t,i,n,r,o){return this.cname=o,await this._p2pConnection.connect(e,t,i,n,r,o),await new Sl((e,t)=>{const n=setTimeout(()=>{this.closeSignal(),t(new SE(fE.DATACHANNEL_CONNECTION_TIMEOUT,"Datachannel connection timed out, candidates: ".concat(JSON.stringify(i))));},2e3);this.dataChannel.onopen=()=>{if("open"===this.dataChannel.readyState)return clearTimeout(n),void e()},this.dataChannel.onerror=e=>{this.closeSignal(),t(e);};}),{transmitter:this.dataChannel,close:this.closeSignal.bind(this)}}send(e,t,i){var n=this;return DO((function*(){const r=yield PO(n.mutex.lock("From DataChannelConnection.send"));try{return yield*kO(gb(n._p2pConnection.send(e,t,i)),PO)}finally{r();}}))()}async stopSending(e,t){return this._p2pConnection.stopSending(e,t)}async receive(e,t,i,n){return this._nvMedia?(OE.debug("[DataChannelConnection] receive ".concat(e," by DataChannel.")),await this._nvMedia.reveiveByRTCMedia(e,t,this.cname)):(OE.debug("[DataChannelConnection] receive ".concat(e," by WebRTC.")),await this._p2pConnection.receive(e,t,i,n))}async batchReceive(e){return [...await this._p2pConnection.batchReceive(e)]}async stopReceiving(e){return await this._p2pConnection.stopReceiving(e)}async muteRemote(e){return await this._p2pConnection.muteRemote(e)}async unmuteRemote(e){return await this._p2pConnection.unmuteRemote(e)}async muteLocal(e){return await this._p2pConnection.muteLocal(e)}async unmuteLocal(e){return await this._p2pConnection.unmuteLocal(e)}restartICE(e){var t=this;return DO((function*(){return yield*kO(gb(t._p2pConnection.restartICE(e)),PO)}))()}close(){var e;null===(e=this._nvMedia)||void 0===e||e.close(),this._p2pConnection.close(),this.unbindConnectionEvents(this._p2pConnection);}getStats(){return this._p2pConnection.getStats()}getRemoteVideoIsReady(e){return this._p2pConnection.getRemoteVideoIsReady(e)}updateRemoteConnect(e){var t;null===(t=this._nvMedia)||void 0===t||t.setRemoteRtpCapabilities(e),this._p2pConnection.updateRemoteConnect(e);}async updateEncoderConfig(e,t){return await this._p2pConnection.updateEncoderConfig(e,t)}async updateSendParameters(e,t){return await this._p2pConnection.updateSendParameters(e,t)}setStatsRemoteVideoIsReady(e,t){this._p2pConnection.setStatsRemoteVideoIsReady(e,t);}async replaceTrack(e,t){return await this._p2pConnection.replaceTrack(e,t)}async getRemoteSSRC(e){return this._p2pConnection.getRemoteSSRC(e)}logSDPExchange(e,t,i,n){if(GE("SDP_LOGGING"))return OE.upload("exchanging ".concat(i," ").concat(t," SDP during DataChannelConnection.").concat(n,"\n"),e),"offer"===t?e=>{this.logSDPExchange(e,"answer","local"===i?"remote":"local",n);}:void 0}static resolvePCConfiguration(t){const i={iceServers:[]};return t.iceServers?i.iceServers=t.iceServers:t.turnServer&&"off"!==t.turnServer.mode&&(Uf(t.turnServer.servers)?i.iceServers=t.turnServer.servers:(i.iceServers&&i.iceServers.push(...e.turnServerConfigToIceServers(t.turnServer.servers)),GE("USE_TURN_SERVER_OF_GATEWAY")&&i.iceServers&&t.turnServer.serversFromGateway&&i.iceServers.push(...e.turnServerConfigToIceServers(t.turnServer.serversFromGateway)),GE("FORCE_TURN_TCP")?i.iceTransportPolicy="relay":t.turnServer.servers.concat(t.turnServer.serversFromGateway||[]).forEach(e=>{e.forceturn&&(i.iceTransportPolicy="relay");}))),i}static turnServerConfigToIceServers(e){const t=[];return e.forEach(e=>{e.security?e.tcpport&&t.push({username:e.username,credential:e.password,credentialType:"password",urls:"turns:".concat(VI(e.turnServerURL),":").concat(e.tcpport,"?transport=tcp")}):(e.udpport&&!GE("FORCE_TURN_TCP")&&t.push({username:e.username,credential:e.password,credentialType:"password",urls:"turn:".concat(e.turnServerURL,":").concat(e.udpport,"?transport=udp")}),e.tcpport&&t.push({username:e.username,credential:e.password,credentialType:"password",urls:"turn:".concat(e.turnServerURL,":").concat(e.tcpport,"?transport=tcp")}));}),t}bindPCEvents(){this._p2pConnection.onICEConnectionStateChange=e=>{var t;return null===(t=this.onICEConnectionStateChange)||void 0===t?void 0:t.call(this,e)},this._p2pConnection.onConnectionStateChange=e=>{var t;return null===(t=this.onConnectionStateChange)||void 0===t?void 0:t.call(this,e)},this._p2pConnection.onDTLSTransportStateChange=e=>{var t;return null===(t=this.onDTLSTransportStateChange)||void 0===t?void 0:t.call(this,e)},this._p2pConnection.onDTLSTransportError=e=>{var t;return null===(t=this.onDTLSTransportError)||void 0===t?void 0:t.call(this,e)},this._p2pConnection.onICETransportStateChange=e=>{var t;return null===(t=this.onICETransportStateChange)||void 0===t?void 0:t.call(this,e)},this._p2pConnection.onFirstAudioReceived=e=>{var t;return null===(t=this.onFirstAudioReceived)||void 0===t?void 0:t.call(this,e)},this._p2pConnection.onFirstVideoReceived=e=>{var t;return null===(t=this.onFirstVideoReceived)||void 0===t?void 0:t.call(this,e)},this._p2pConnection.onFirstAudioDecoded=e=>{var t;return null===(t=this.onFirstAudioDecoded)||void 0===t?void 0:t.call(this,e)},this._p2pConnection.onFirstVideoDecoded=(e,t,i)=>{var n;return null===(n=this.onFirstVideoDecoded)||void 0===n?void 0:n.call(this,e,t,i)},this._p2pConnection.onFirstVideoDecodedTimeout=e=>{var t;return null===(t=this.onFirstVideoDecodedTimeout)||void 0===t?void 0:t.call(this,e)},this._p2pConnection.onSelectedLocalCandidateChanged=(e,t)=>{var i;return null===(i=this.onSelectedLocalCandidateChanged)||void 0===i?void 0:i.call(this,e,t)},this._p2pConnection.onSelectedRemoteCandidateChanged=(e,t)=>{var i;return null===(i=this.onSelectedRemoteCandidateChanged)||void 0===i?void 0:i.call(this,e,t)};}closeSignal(){this.dataChannel.close(),this.peerConnection.close();}unbindConnectionEvents(e){e.onConnectionStateChange=void 0,e.onICEConnectionStateChange=void 0,e.onICETransportStateChange=void 0,e.onDTLSTransportStateChange=void 0,e.onDTLSTransportError=void 0,e.onFirstAudioDecoded=void 0,e.onFirstAudioReceived=void 0,e.onFirstVideoDecoded=void 0,e.onFirstVideoReceived=void 0,e.onSelectedLocalCandidateChanged=void 0,e.onSelectedRemoteCandidateChanged=void 0,e.onFirstVideoDecodedTimeout=void 0;}setConfiguration(e){this._p2pConnection.setConfiguration(e);}}).prototype,"connect",[Cb],Object.getOwnPropertyDescriptor(Tb.prototype,"connect"),Tb.prototype),ag(Tb.prototype,"receive",[Cb],Object.getOwnPropertyDescriptor(Tb.prototype,"receive"),Tb.prototype),ag(Tb.prototype,"stopReceiving",[Cb],Object.getOwnPropertyDescriptor(Tb.prototype,"stopReceiving"),Tb.prototype),ag(Tb.prototype,"muteRemote",[Cb],Object.getOwnPropertyDescriptor(Tb.prototype,"muteRemote"),Tb.prototype),ag(Tb.prototype,"unmuteRemote",[Cb],Object.getOwnPropertyDescriptor(Tb.prototype,"unmuteRemote"),Tb.prototype),ag(Tb.prototype,"muteLocal",[Cb],Object.getOwnPropertyDescriptor(Tb.prototype,"muteLocal"),Tb.prototype),ag(Tb.prototype,"unmuteLocal",[Cb],Object.getOwnPropertyDescriptor(Tb.prototype,"unmuteLocal"),Tb.prototype),ag(Tb.prototype,"close",[Cb],Object.getOwnPropertyDescriptor(Tb.prototype,"close"),Tb.prototype),ag(Tb.prototype,"updateEncoderConfig",[Cb],Object.getOwnPropertyDescriptor(Tb.prototype,"updateEncoderConfig"),Tb.prototype),ag(Tb.prototype,"updateSendParameters",[Cb],Object.getOwnPropertyDescriptor(Tb.prototype,"updateSendParameters"),Tb.prototype),ag(Tb.prototype,"replaceTrack",[Cb],Object.getOwnPropertyDescriptor(Tb.prototype,"replaceTrack"),Tb.prototype),ag(Tb.prototype,"getRemoteSSRC",[Cb],Object.getOwnPropertyDescriptor(Tb.prototype,"getRemoteSSRC"),Tb.prototype),Tb);function Cb(e,t,i){const n=e[t];if("function"!=typeof n)throw new Error("Cannot use mutex on object property.");return i.value=async function(){const e=this.mutex,i=await e.lock("From DataChannelConnection.".concat(t));try{for(var r=arguments.length,o=new Array(r),s=0;s<r;s++)o[s]=arguments[s];return await n.apply(this,o)}finally{i();}},i}var vb;function yb(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n);}return i}function Ab(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?yb(Object(i),!0).forEach((function(t){_p(e,t,i[t]);})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):yb(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t));}));}return e}function Ob(e){var t,i,n,r=2;for("undefined"!=typeof Symbol&&(i=MO,n=Symbol.iterator);r--;){if(i&&null!=(t=e[i]))return t.call(e);if(n&&null!=(t=e[n]))return new Nb(t.call(e));i="@@asyncIterator",n="@@iterator";}throw new TypeError("Object is not async iterable")}function Nb(e){function t(e){if(Object(e)!==e)return Sl.reject(new TypeError(e+" is not an object."));var t=e.done;return Sl.resolve(e.value).then((function(e){return {value:e,done:t}}))}return (Nb=function(e){this.s=e,this.n=e.next;}).prototype={s:null,n:null,next:function(){return t(this.n.apply(this.s,arguments))},return:function(e){var i=this.s.return;return void 0===i?Sl.resolve({value:e,done:!0}):t(i.apply(this.s,arguments))},throw:function(e){var i=this.s.return;return void 0===i?Sl.reject(e):t(i.apply(this.s,arguments))}},new Nb(e)}let bb=(ag((vb=class extends EE{get state(){return this._state}set state(e){const t=this._state;this._state=e,this.emit(DS.StateChange,t,this._state);}constructor(e,t){super(),_p(this,"store",void 0),_p(this,"statsUploader",void 0),_p(this,"connection",void 0),_p(this,"localTrackMap",new Map),_p(this,"remoteUserMap",new Map),_p(this,"pendingLocalTracks",[]),_p(this,"pendingRemoteTracks",[]),_p(this,"statsCollector",void 0),_p(this,"isPlanB",!1),_p(this,"shouldForwardP2PCreation",void 0),_p(this,"iceFailedCount",0),_p(this,"dtlsFailedCount",0),_p(this,"mutex",new Ug("P2PChannel-mutex")),_p(this,"_state",wS.Disconnected),_p(this,"_pcStatsUploadType",GE("NEW_ICE_RESTART")?NS.FIRST_CONNECTION:NS.OLD_FIRST_CONNECTION),_p(this,"_isInRestartIce",!1),_p(this,"_isStartRestartIce",!1),_p(this,"_restartStates",["disconnected","failed"]),_p(this,"_restartTimer",void 0),_p(this,"_isFirstConnected",!0),_p(this,"handleMuteLocalTrack",async(e,t,i)=>{const n=await this.mutex.lock("Locking from P2PChannel.handleMuteLocalTrack");try{if(!this.connection||this.state!==wS.Connected)return void i(new SE(fE.INVALID_OPERATION,"Cannot call P2PChannel.handleMuteLocalTrack before connection established."));const r=this.filterTobeMutedTracks(e);if(0===r.length)return void t();const o=r.find(e=>"videoLowTrack"===e[0]);if(o){o[1].track._originMediaStreamTrack.stop();}await this.connection.muteLocal(r.map(e=>{let[,{id:t}]=e;return t}));const s=this.createMuteMessage(r);await rC(this,DS.RequestMuteLocal,s),t();}catch(e){i(e);}finally{n();}}),_p(this,"handleUnmuteLocalTrack",async(e,t,i)=>{const n=await this.mutex.lock("Locking from P2PChannel.handleUnmuteLocalTrack");try{if(!this.connection||this.state!==wS.Connected)return void i(new SE(fE.INVALID_OPERATION,"Cannot call P2PChannel.handleUnmuteLocalTrack before connection established."));const r=this.filterTobeUnmutedTracks(e);if(0===r.length)return void t();const o=r.find(e=>"videoLowTrack"===e[0]);if(o){const t=o[1];if(t.track._originMediaStreamTrack.stop(),JS().supportDualStreamEncoding){const i=e._mediaStreamTrack.clone();t.track._mediaStreamTrack=i,t.track._originMediaStreamTrack=i;}else {const i=FN(e,sC(this,DS.RequestLowStreamParameter));t.track._mediaStreamTrack=i,t.track._originMediaStreamTrack=i;}await new Sl((e,i)=>{this.handleReplaceTrack(t.track,e,i,!0);});}await this.connection.unmuteLocal(r.map(e=>{let[,{id:t}]=e;return t}));const s=this.createUnmuteMessage(r);await rC(this,DS.RequestUnmuteLocal,s),t();}catch(e){i(e);}finally{n();}}),_p(this,"handleUpdateVideoEncoder",async(e,t,i)=>{const n=await this.mutex.lock("Locking from P2PChannel.handleSetVideoEncoder");try{const i=this.localTrackMap.get(bS.LocalVideoTrack);if(!this.connection||!i||i.track!==e||this.state!==wS.Connected)return void t();const{id:r,track:o}=i;await this.connection.updateSendParameters(r,o),await this.connection.updateEncoderConfig(r,o),this.emit(DS.UpdateVideoEncoder,o),t();}catch(e){i(e);}finally{n();}}),_p(this,"handleSetOptimizationMode",async(e,t,i)=>{const n=await this.mutex.lock("Locking from P2PChannel.handleSetOptimizationMode");try{const i=this.localTrackMap.get(bS.LocalVideoTrack);if(!this.connection||!i||i.track!==e||this.state!==wS.Connected)return;const{id:r,track:o}=i;await this.connection.updateSendParameters(r,o),t();}catch(e){i(e);}finally{n();}}),_p(this,"handleReplaceTrack",async(e,t,i,n)=>{let r;OE.debug("[".concat(this.store.clientId,"] P2PChannel handleReplaceTrack for [track-id-").concat(e.getTrackId(),"]")),"boolean"==typeof n&&n||(r=await this.mutex.lock("From P2PChannel.handleReplaceTrack"));try{var o;const i=Array.from(this.localTrackMap.entries()).find(t=>{let[,{track:i}]=t;return e===i});if(!this.connection||!i||this.state!==wS.Connected)return void t();if(await(null===(o=this.connection)||void 0===o?void 0:o.replaceTrack(e,i[1].id)),this.isPlanB){const t=i[1];t.id=e._mediaStreamTrack.id,this.localTrackMap.set(i[0],t);}if(i[0]===bS.LocalVideoTrack&&JS().supportDualStreamEncoding){const t=this.localTrackMap.get(bS.LocalVideoLowTrack);if(t){const i=e._mediaStreamTrack.clone();t.track._originMediaStreamTrack.stop(),t.track._mediaStreamTrack=i,t.track._originMediaStreamTrack=i,await new Sl((e,i)=>{this.handleReplaceTrack(t.track,e,i,!0);});}}t();}catch(e){i(e);}finally{var s;null===(s=r)||void 0===s||s();}}),_p(this,"handleGetLocalVideoStats",e=>{e(this.statsCollector.getLocalVideoTrackStats());}),_p(this,"handleGetLocalAudioStats",e=>{e(this.statsCollector.getLocalAudioTrackStats());}),_p(this,"handleGetRemoteVideoStats",e=>this.statsCollector.getRemoteVideoTrackStats(e.uid)[e.uid]),_p(this,"handleGetRemoteAudioStats",e=>this.statsCollector.getRemoteAudioTrackStats(e.uid)[e.uid]),this.store=e,this.statsCollector=t,this.statsCollector.addP2PChannel(this),this.statsUploader=new sb,this.bindStatsUploaderEvents(),this.isPlanB=!JS().supportUnifiedPlan||GE("CHROME_FORCE_PLAN_B")&&rp(),this.shouldForwardP2PCreation=GE("FORWARD_P2P_CREATION")&&JS().supportPCSetConfiguration,this.shouldForwardP2PCreation&&(this.connection=this.store.useDataChannel?new Ib({},this.store):this.isPlanB?new NN({},this.store):new VN({},this.store),this.bindConnectionEvents(this.connection));}async startP2PConnection(e,t){var i;this.state=wS.New;const n=this.shouldForwardP2PCreation&&"closed"===(null===(i=this.connection)||void 0===i?void 0:i.peerConnectionState);if(this.shouldForwardP2PCreation&&!n||(n&&this.connection&&(OE.warning("[".concat(this.store.clientId,"] P2PChannel.startP2PConnection ForwardP2P closed.")),this.connection.close(),this.unbindConnectionEvents(this.connection)),this.connection=this.store.useDataChannel?new Ib(e,this.store):this.isPlanB?new NN(e,this.store):new VN(e,this.store),this.bindConnectionEvents(this.connection)),!this.connection)throw new SE(fE.UNEXPECTED_ERROR,"Cannot P2PChannel.startConnection before P2PConnection initialization .");return this._pcStatsUploadType=GE("NEW_ICE_RESTART")?NS.FIRST_CONNECTION:NS.OLD_FIRST_CONNECTION,this._isFirstConnected=!0,this._isInRestartIce=!1,this._isStartRestartIce=!1,this.connection.setConfiguration(e),this.connection.establishPromise}async connect(e,t,i,n,r,o){if(!this.connection)throw new SE(fE.UNEXPECTED_ERROR,"Cannot P2PChannel.connect before P2PChannel.startP2PConnection .");this.connection instanceof Ib?this.connection.updateRemoteConnect(n):(this.store.peerConnectionStart(),await this.connection.connect(e,t,i,n,r,o),this.statsUploader.startUploadTransportStats(),this.statsUploader.startUploadExtensionUsageStats(),this.state=wS.Connected);}async preConnect(e,t,i,n,r,o){if(!this.connection)throw new SE(fE.UNEXPECTED_ERROR,"Cannot P2PChannel.connect before P2PChannel.startP2PConnection .");this.store.peerConnectionStart();const s=await this.connection.connect(e,t,i,n,r,o);return this.statsUploader.startUploadTransportStats(),this.statsUploader.startUploadExtensionUsageStats(),this.state=wS.Connected,s}getEstablishParams(){if(this.connection instanceof Ib)return this.connection.getP2PConnectionParams();throw new Error("Only DataChannelConnection needs to obtain establishParams")}publish(e,t,i){var n=this;return DO((function*(){const r=yield PO(n.mutex.lock("From P2PChannel.publish"));try{if(!n.connection||n.state!==wS.Connected){if(n.state===wS.Disconnected)throw new SE(fE.UNEXPECTED_ERROR,"PeerConnection already disconnected.");n.throwIfTrackTypeNotMatch(e);const t=e.filter(e=>-1===n.pendingLocalTracks.indexOf(e));return void(n.pendingLocalTracks=n.pendingLocalTracks.concat(t))}n.store.pubId=n.store.pubId+1,DI.markPublishStart(n.store.clientId,n.store.pubId);const o=n.filterTobePublishedTracks(e,t,i);if(0===o.length)return void(yield PO(n.tryToUnmuteAudio(e)));yield*kO(Ob(n.doPublish(n.connection,o)),PO);}finally{r();}}))()}doPublish(e,t){var i=this;return DO((function*(){t.forEach(e=>{let{track:t,type:n}=e;const r=Date.now();i.store.publish(t.getTrackId(),n===bS.LocalAudioTrack?"audio":"video",r);}),i.bindLocalTrackEvents(t);const n=yield PO(e.send(t.map(e=>{let{track:t}=e;return t}),i.store.codec,i.store.audioCodec)),r=(yield PO(n.next())).value,o=i.createGatewayPublishMessage(t,r);let s;try{s=yield o;}catch(e){throw n.throw(e),(null==e?void 0:e.code)===fE.WS_ABORT&&t.forEach(e=>{let{track:t}=e;-1===i.pendingLocalTracks.indexOf(t)&&i.pendingLocalTracks.push(t);}),i.unbindLocalTrackEvents(t),e}const a=i.mapPubResToRemoteConfig(o,s),c=(yield PO(n.next(a))).value;t.forEach(e=>{let{type:t}=e;i.statsCollector.addLocalStats(t);}),i.assignLocalTracks(t,c),i.statsUploader.startUploadUplinkStats(),t.forEach(e=>{let{track:t,type:n}=e;const r=Date.now();i.store.publish(t.getTrackId(),n===bS.LocalAudioTrack?"audio":"video",void 0,r);});}))()}publishLowStream(e){var t=this;return DO((function*(){if(!t.connection||t.state!==wS.Connected)return;const i=yield PO(t.mutex.lock("Locking from P2PChannel.publishLowStream"));try{const r=t.localTrackMap.get(bS.LocalVideoTrack);if(!r)throw new SE(fE.UNEXPECTED_ERROR,"Could not find high stream");if(t.localTrackMap.has(bS.LocalVideoLowTrack))throw new SE(fE.UNEXPECTED_ERROR,"[".concat(t.store.clientId,"] Can't publish low stream when stream already publish"));const o=[{track:t.getLowVideoTrack(r.track,e),type:bS.LocalVideoLowTrack}];if(yield*kO(Ob(t.doPublish(t.connection,o)),PO),r.track.muted||!r.track.enabled){var n;const e=null===(n=t.localTrackMap.get(bS.LocalVideoLowTrack))||void 0===n?void 0:n.id;void 0!==e&&(yield PO(t.connection.muteLocal([e])));}}finally{i();}}))()}async republish(){this.pendingLocalTracks.length>0&&(OE.debug("[".concat(this.store.clientId,"] Emit P2PChannelEvents.RequestRePublish to republish tracks.")),await nC(this,DS.RequestRePublish,this.pendingLocalTracks),this.emit(DS.MediaReconnectEnd,this.store.uid),this.pendingLocalTracks=[]);}async reSubscribe(e){for(let e=this.pendingRemoteTracks.length-1;e>=0;e--){const{user:t,kind:i}=this.pendingRemoteTracks[e];(i!==AS.AUDIO||t._audio_added_&&t._audioSSRC)&&(i!==AS.VIDEO||t._video_added_&&t._videoSSRC)||this.pendingRemoteTracks.splice(e,1);}if(e)await nC(this,DS.RequestReSubscribe,this.pendingRemoteTracks);else for(const{user:e,kind:t}of this.pendingRemoteTracks)await this.subscribe(e,t,t===AS.VIDEO?e._videoSSRC:e._audioSSRC);this.pendingRemoteTracks.forEach(e=>{let{user:t}=e;this.emit(DS.MediaReconnectEnd,t.uid);}),this.pendingRemoteTracks=[];}async unpublish(e){if(!this.connection||this.state!==wS.Connected)return void e.forEach(e=>{const t=this.pendingLocalTracks.indexOf(e);-1!==t&&this.pendingLocalTracks.splice(t,1);});const t=this.filterTobeUnpublishedTracks(e);if(0===t.length)return;const i=t.find(e=>"videoLowTrack"===e[0]);if(i){i[1].track.close();}return this.doUnpublish(this.connection,t)}async unpublishLowStream(){if(!this.connection||this.state!==wS.Connected)return;const e=this.localTrackMap.get(bS.LocalVideoLowTrack);if(!e)return;e.track.close();const t=[[bS.LocalVideoLowTrack,e]];return this.doUnpublish(this.connection,t)}async doUnpublish(e,t){const i=this.createGatewayUnpublishMessage(t);return await e.stopSending(t.map(e=>{let[,{id:t}]=e;return t})),this.withdrawLocalTracks(t),this.unbindLocalTrackEvents(t.map(e=>{let[t,{track:i}]=e;return {type:t,track:i}})),t.forEach(e=>{let[t]=e;this.statsCollector.removeLocalStats(t);}),0===this.localTrackMap.size&&this.statsUploader.stopUploadUplinkStats(),i}async subscribe(e,t,i,n,r){var o;if(!this.connection||this.state!==wS.Connected)throw new SE(fE.INVALID_OPERATION,"Cannot subscribe remote user when peerConnection disconnected.");if(null!==(o=this.remoteUserMap.get(e))&&void 0!==o&&o.has(t))return;let s,a,c=void 0;if(r){const i=r.find(e=>{let{stream_type:i}=e;return i===t});if(!i)throw new SE(fE.UNEXPECTED_ERROR,"Cannot subscribe to remote ".concat(t," for user: ").concat(e.uid," because subscribe answer from gateway does not contain stream_type: ").concat(t,"."));const n=await this.connection.receive(t,i.ssrcs,String(e._uintid),i.attributes);this.connection instanceof VN&&(c=n.transceiver),s=n.track,a=n.id;}else {const r=await this.connection.receive(t,[{ssrcId:i,rtx:n}],String(e._uintid),void 0);this.connection instanceof VN&&(c=r.transceiver),s=r.track,a=r.id;}t===AS.AUDIO?(e._audioTrack?e._audioTrack._updateOriginMediaStreamTrack(s):(e._audioTrack=new nb(s,e.uid,e._uintid,this.store),OE.info("[".concat(this.store.clientId,"] [").concat(this.store.p2pId,"] create remote audio track: ").concat(e._audioTrack.getTrackId()))),c&&e._audioTrack._updateRtpTransceiver(c),this.bindRemoteTrackEvents(e,e._audioTrack)):(e._videoTrack?e._videoTrack._updateOriginMediaStreamTrack(s):(e._videoTrack=new ib(s,e.uid,e._uintid,this.store),OE.info("[".concat(this.store.clientId,"] [").concat(this.store.p2pId,"] create remote video track: ").concat(e._videoTrack.getTrackId()))),c&&e._videoTrack._updateRtpTransceiver(c),this.bindRemoteTrackEvents(e,e._videoTrack));const d=this.remoteUserMap.get(e);d?d.set(t,a):this.remoteUserMap.set(e,new Map([[t,a]])),this.statsCollector.addRemoteStats(e.uid),this.statsUploader.startUploadDownlinkStats();const u=this.pendingRemoteTracks.findIndex(i=>{let{user:n,kind:r}=i;return n.uid===e.uid&&t===r});-1!==u&&(this.pendingRemoteTracks.splice(u,1),this.emit(DS.MediaReconnectEnd,e.uid));}async massSubscribe(e){return this.massSubscribeNoLock(e)}async massSubscribeNoLock(e){if(!this.connection||this.state!==wS.Connected)throw new SE(fE.INVALID_OPERATION,"Cannot subscribeAll remote users when peerConnection disconnected.");e=e.filter(e=>{var t;let{user:i,mediaType:n}=e;return !(null!==(t=this.remoteUserMap.get(i))&&void 0!==t&&t.has(n))});const t=await this.connection.batchReceive(e.map(e=>{let{user:t,mediaType:i,ssrcId:n,rtxSsrcId:r}=e;return {kind:i,ssrcMsg:[{ssrcId:n,rtx:r}],mslabel:String(t._uintid)}}));e.forEach((e,i)=>{let{user:n,mediaType:r}=e;const{track:o,id:s,transceiver:a}=t[i];r===AS.AUDIO?(n._audioTrack?n._audioTrack._updateOriginMediaStreamTrack(o):(n._audioTrack=new nb(o,n.uid,n._uintid,this.store),OE.info("[".concat(this.store.clientId,"] [").concat(this.store.p2pId,"] create remote audio track: ").concat(n._audioTrack.getTrackId()))),a&&n._audioTrack._updateRtpTransceiver(a),this.bindRemoteTrackEvents(n,n._audioTrack)):(n._videoTrack?n._videoTrack._updateOriginMediaStreamTrack(o):(n._videoTrack=new ib(o,n.uid,n._uintid,this.store),OE.info("[".concat(this.store.clientId,"] [").concat(this.store.p2pId,"] create remote video track: ").concat(n._videoTrack.getTrackId()))),a&&n._videoTrack._updateRtpTransceiver(a),this.bindRemoteTrackEvents(n,n._videoTrack));const c=this.remoteUserMap.get(n);c?c.set(r,s):this.remoteUserMap.set(n,new Map([[r,s]])),this.statsCollector.addRemoteStats(n.uid),this.statsUploader.startUploadDownlinkStats();const d=this.pendingRemoteTracks.findIndex(e=>{let{user:t,kind:i}=e;return t.uid===n.uid&&r===i});-1!==d&&(this.pendingRemoteTracks.splice(d,1),this.emit(DS.MediaReconnectEnd,n.uid));});}async unsubscribe(e,t,i){const n=this.pendingRemoteTracks.filter(i=>{let{user:n,kind:r}=i;return void 0!==t?n.uid===e.uid&&t===r:n.uid===e.uid});if(n.forEach(e=>{const t=this.pendingRemoteTracks.indexOf(e);this.pendingRemoteTracks.splice(t,1);}),this.connection&&this.state===wS.Connected||i||n.forEach(t=>{let{kind:i}=t;var n;if(i===AS.AUDIO)null===(n=e._audioTrack)||void 0===n||n._destroy(),e._audioTrack=void 0;else if(i===AS.VIDEO){var r;null===(r=e._videoTrack)||void 0===r||r._destroy(),e._videoTrack=void 0;}}),!this.connection||this.state!==wS.Connected)return;const r=this.filterTobeUnSubscribedTracks(e,t);if(0===r.length)return;await this.connection.stopReceiving(r.map(e=>{let[,{id:t}]=e;return t}));const o=this.createUnsubscribeMessage(r);return this.withdrawRemoteTracks(r),0===this.remoteUserMap.size&&this.statsUploader.stopUploadDownlinkStats(),r.forEach(e=>{let[t,{kind:n}]=e;var r,o;n===AS.VIDEO&&t._videoSSRC&&(null===(r=this.connection)||void 0===r||r.setStatsRemoteVideoIsReady(t._videoSSRC,!1));if(n===AS.VIDEO)this.unbindRemoteTrackEvents(t._videoTrack),i||(null===(o=t._videoTrack)||void 0===o||o._destroy(),t._videoTrack=void 0);else if(n===AS.AUDIO){var s;if(this.unbindRemoteTrackEvents(t._audioTrack),!i)null===(s=t._audioTrack)||void 0===s||s._destroy(),t._audioTrack=void 0;}}),o}async massUnsubscribe(e){return this.massUnsubscribeNoLock(e)}async massUnsubscribeNoLock(e){let t=[];for(const{user:i,mediaType:n}of e){const e=this.pendingRemoteTracks.filter(e=>{let{user:t,kind:r}=e;return void 0!==n?t.uid===i.uid&&n===r:t.uid===i.uid});e.forEach(e=>{const t=this.pendingRemoteTracks.indexOf(e);this.pendingRemoteTracks.splice(t,1);}),t=t.concat(e);}if(!this.connection||this.state!==wS.Connected)return void t.forEach(e=>{let{user:t,kind:i}=e;var n;if(i===AS.AUDIO)null===(n=t._audioTrack)||void 0===n||n._destroy(),t._audioTrack=void 0;else if(i===AS.VIDEO){var r;null===(r=t._videoTrack)||void 0===r||r._destroy(),t._videoTrack=void 0;}});const i=zi(e).call(e,(e,t)=>{let{user:i,mediaType:n}=t;const r=this.filterTobeUnSubscribedTracks(i,n);return e.concat(r)},[]);if(0===i.length)return;await this.connection.stopReceiving(i.map(e=>{let[,{id:t}]=e;return t}));const n=this.createUnsubscribeAllMessage(i);return this.withdrawRemoteTracks(i),0===this.remoteUserMap.size&&this.statsUploader.stopUploadDownlinkStats(),i.forEach(e=>{let[t,{kind:i}]=e;var n,r;i===AS.VIDEO&&t._videoSSRC&&(null===(n=this.connection)||void 0===n||n.setStatsRemoteVideoIsReady(t._videoSSRC,!1));if(i===AS.VIDEO)this.unbindRemoteTrackEvents(t._videoTrack),null===(r=t._videoTrack)||void 0===r||r._destroy(),t._videoTrack=void 0;else if(i===AS.AUDIO){var o;this.unbindRemoteTrackEvents(t._audioTrack),null===(o=t._audioTrack)||void 0===o||o._destroy(),t._audioTrack=void 0;}}),n}async muteRemote(e,t){if(!this.connection)return;const i=this.remoteUserMap.get(e);if(!i)return void OE.warning("[".concat(this.store.clientId,"] P2PChannel.muteRemote has no remote user ").concat(e.uid,"."));if(!i.get(t))return void OE.warning("[".concat(this.store.clientId,"] P2PChannel.muteRemote has no remote user ").concat(e.uid," media type ").concat(t,"."));const n=t===AS.VIDEO?e._videoSSRC:e._audioSSRC;void 0!==n&&this.connection.setStatsRemoteVideoIsReady(n,!1);}async unmuteRemote(e,t){return this.unmuteRemoteNoLock(e,t)}async unmuteRemoteNoLock(e,t){if(!this.connection)return;const i=this.remoteUserMap.get(e);if(!i)return void OE.warning("[".concat(this.store.clientId,"] P2PChannel.unmuteRemote has no remote user ").concat(e.uid,"."));i.get(t)||OE.warning("[".concat(this.store.clientId,"] P2PChannel.unmuteRemote has no remote user ").concat(e.uid," media type ").concat(t,"."));}getAllTracks(e){const t=this.localTrackMap.get(bS.LocalAudioTrack);if((null==t?void 0:t.track)instanceof NI){const i=t.track;return Array.from(this.localTrackMap.entries()).filter(e=>{let[t]=e;return t!==bS.LocalAudioTrack}).filter(t=>{let[i]=t;return !(e&&i===bS.LocalVideoLowTrack)}).map(e=>{let[,{track:t}]=e;return t}).concat(i.trackList)}return Array.from(this.localTrackMap.entries()).filter(t=>{let[i]=t;return !(e&&i===bS.LocalVideoLowTrack)}).map(e=>{let[,{track:t}]=e;return t})}reportPublishEvent(e,t,i,n,r){if(e){const i=this.localTrackMap.get(bS.LocalAudioTrack),o=n?this.localTrackMap.get(bS.LocalVideoLowTrack):this.localTrackMap.get(bS.LocalVideoTrack);Pg.publish(this.store.sessionId,{eventElapse:DI.measureFromPublishStart(this.store.clientId,this.store.pubId),succ:e,ec:t,audioName:null==i?void 0:i.track.getTrackLabel(),videoName:null==o?void 0:o.track.getTrackLabel(),screenshare:-1!==(null==o?void 0:o.track._hints.indexOf(lS.SCREEN_TRACK)),audio:!!i,video:!!o,p2pid:this.store.p2pId,publishRequestid:this.store.pubId,extend:r});}else {var o;i||(i=[]);const s=i.find(e=>e instanceof yI),a=n?null===(o=this.localTrackMap.get(bS.LocalVideoTrack))||void 0===o?void 0:o.track:i.find(e=>e instanceof Cy);Pg.publish(this.store.sessionId,{eventElapse:DI.measureFromPublishStart(this.store.clientId,this.store.pubId),succ:e,ec:t,audioName:null==s?void 0:s.getTrackLabel(),videoName:null==a?void 0:a.getTrackLabel(),screenshare:-1!==(null==a?void 0:a._hints.indexOf(lS.SCREEN_TRACK)),audio:!!s,video:!!a,p2pid:this.store.p2pId,publishRequestid:this.store.pubId,extend:r});}}reportSubscribeEvent(e,t,i,n){const r=n===AS.VIDEO?i._videoSSRC:i._audioSSRC;r&&Pg.subscribe(this.store.sessionId,{succ:e,ec:t,video:n===AS.VIDEO,audio:n===AS.AUDIO,peerid:i.uid,subscribeRequestid:n===AS.VIDEO?i._videoSSRC:i._audioSSRC,p2pid:this.store.p2pId,eventElapse:DI.measureFromSubscribeStart(this.store.clientId,r)});}reset(){OE.debug("[".concat(this.store.clientId,"] P2PChannel.reset")),this.mutex=new Ug("P2PChannel-mutex"),this.connection&&(this.connection.close(),this.unbindConnectionEvents(this.connection),this.connection=void 0),this.shouldForwardP2PCreation&&(this.connection=this.store.useDataChannel?new Ib({},this.store):this.isPlanB?new NN({},this.store):new VN({},this.store),this.bindConnectionEvents(this.connection)),this.statsUploader.stopUploadUplinkStats(),this.statsUploader.stopUploadDownlinkStats(),this.statsUploader.stopUploadTransportStats(),this.statsUploader.stopUploadExtensionUsageStats(),this.unbindLocalTrackEvents(),this.unbindAllRemoteTrackEvents(),this.unbindRtpTransceiver();const e=this.localTrackMap.get(bS.LocalAudioTrack);if((null==e?void 0:e.track)instanceof NI){if(e.track.trackList.length>0){const t=e.track;e.track.trackList.forEach(e=>{t.removeAudioTrack(e);});}e.track.close();}this.localTrackMap.clear(),this.remoteUserMap.clear(),this.statsCollector.removeRemoteStats(),this.statsCollector.removeLocalStats(),this.iceFailedCount=0,this.dtlsFailedCount=0,this.pendingLocalTracks=[],this.pendingRemoteTracks=[],this.state=wS.Disconnected;}getStats(){var e;return null===(e=this.connection)||void 0===e?void 0:e.getStats()}getRemoteVideoIsReady(e){var t;return (null===(t=this.connection)||void 0===t?void 0:t.getRemoteVideoIsReady(e))||!1}getLocalAudioVolume(){const e=this.localTrackMap.get(bS.LocalAudioTrack);if(e)return e.track.getVolumeLevel()}getLocalVideoSize(){const e=this.localTrackMap.get(bS.LocalVideoTrack);if(e)return {width:e.track._videoWidth||0,height:e.track._videoHeight||0}}getEncoderConfig(e){const t=this.localTrackMap.get(e);return t&&t.track instanceof Cy||t&&t.track instanceof yI?t.track._encoderConfig:void 0}getLocalMedia(e){return this.localTrackMap.get(e)}hasLocalMedia(){return this.localTrackMap.size>0}hasRemoteMedia(e,t){if(!e)return this.remoteUserMap.size>0;const i=this.remoteUserMap.get(e);return !!i&&(!t||i.has(t))}async hasRemoteMediaWithLock(e,t){if(!e)return this.remoteUserMap.size>0;const i=this.remoteUserMap.get(e);return !!i&&(!t||i.has(t))}getRemoteMedia(e){var t;const i=Array.from(Eg(t=this.remoteUserMap).call(t)).find(t=>t.uid===e);return i?{audioTrack:i.audioTrack,audioSSRC:i._audioSSRC,videoTrack:i.videoTrack,videoSSRC:i._videoSSRC}:{}}getAudioLevels(){let e=Array.from(this.remoteUserMap.entries()).map(e=>{let[t]=e;return {uid:t.uid,level:t.audioTrack?100*t.audioTrack._source.getAccurateVolumeLevel():0}});const t=this.localTrackMap.get(bS.LocalAudioTrack);return t&&e.push({level:100*t.track._source.getAccurateVolumeLevel(),uid:this.store.uid}),e=Hm(e).call(e,(e,t)=>e.level-t.level),e}async disconnectForReconnect(){this.connection&&(OE.debug("[".concat(this.store.clientId,"] P2PChannel.disconnectForReconnect closing P2PConnection")),this.state=wS.Reconnecting,GE("KEEP_LAST_FRAME")&&0!==this.remoteUserMap.size&&Array.from(this.remoteUserMap.entries()).forEach(e=>{let[t]=e;var i;t._videoTrack&&t._videoTrack._player&&(null===(i=t._videoTrack._player.getVideoElement())||void 0===i||i.pause(),t._videoTrack._player.isKeepLastFrame=!0,t._videoTrack._originMediaStreamTrack.stop());}),this.connection.close(),this.unbindConnectionEvents(this.connection),this.connection=void 0,this.shouldForwardP2PCreation&&(this.connection=this.store.useDataChannel?new Ib({},this.store):this.isPlanB?new NN({},this.store):new VN({},this.store),this.bindConnectionEvents(this.connection)),0!==this.localTrackMap.size&&(Array.from(this.localTrackMap.entries()).forEach(e=>{let[t,{track:i}]=e;switch(t){case bS.LocalVideoTrack:i._hints.includes(lS.LOW_STREAM)?i.close():this.pendingLocalTracks.push(i);break;case bS.LocalAudioTrack:i instanceof NI?this.pendingLocalTracks=this.pendingLocalTracks.concat(i.trackList):this.pendingLocalTracks.push(i);break;case bS.LocalVideoLowTrack:}}),this.emit(DS.MediaReconnectStart,this.store.uid)),this.unbindLocalTrackEvents(),this.localTrackMap.clear(),0!==this.remoteUserMap.size&&Array.from(this.remoteUserMap.entries()).forEach(e=>{let[t,i]=e;Array.from(Eg(i).call(i)).forEach(e=>{this.setPendingRemoteMedia(t,e);}),this.emit(DS.MediaReconnectStart,t.uid);}),this.unbindAllRemoteTrackEvents(),this.remoteUserMap.clear(),this.statsUploader.stopUploadUplinkStats(),this.statsUploader.stopUploadDownlinkStats(),this.statsUploader.stopUploadTransportStats(),OE.debug("[".concat(this.store.clientId,"] P2PChannel disconnected, waiting to reconnect.")));}hasPendingRemoteMedia(e,t){for(const i of this.pendingRemoteTracks){const{user:n,kind:r}=i;if((e instanceof yy?e.uid:e)===n.uid&&t===r)return !0}return !1}setPendingRemoteMedia(e,t){this.hasPendingRemoteMedia(e,t)||this.pendingRemoteTracks.push({user:e,kind:t});}restartICE(e){var t=this;return DO((function*(){if(!t.connection||t.state!==wS.Connected||t.connection instanceof Ib)return;const i=yield PO(t.mutex.lock("From P2PChannel.restartICE"));let n;try{n=yield PO(t.connection.restartICE(e));const r=yield PO(n.next());if(r.done)return;const o=r.value,s=yield o;switch(t.reportPCDisconnectedOrFailed(e),e){case OS.TCP:t._pcStatsUploadType=NS.TCP_RESTART;break;case OS.RELAY:t._pcStatsUploadType=NS.RELAY_RESTART;break;default:t._pcStatsUploadType=NS.OLD_RESTART;}t._isInRestartIce=!0,n.next(s);}catch(e){var r;null===(r=n)||void 0===r||r.throw(e);}finally{i();}}))()}getUplinkNetworkQuality(){if(!this.connection)return 0;const e=this.connection.getStats(),t=this.localTrackMap.get(bS.LocalVideoTrack),i=this.localTrackMap.get(bS.LocalAudioTrack),n=e.videoSend.find(e=>e.ssrc===(null==t?void 0:t.ssrcs[0].ssrcId)),r=e.audioSend.find(e=>e.ssrc===(null==i?void 0:i.ssrcs[0].ssrcId));if(!n||!r)return 1;const o=oC(this,DS.NeedSignalRTT),s=n?n.rttMs:void 0,a=r?r.rttMs:void 0,c=s&&a?(s+a)/2:s||a,d=(c&&o?(c+o)/2:c||o)||0,u=100*e.sendPacketLossRate*.7/50+.3*d/1500,l=u<.17?1:u<.36?2:u<.59?3:u<.1?4:5,h=null==t?void 0:t.track;if(h&&h._encoderConfig&&-1===h._hints.indexOf(lS.SCREEN_TRACK)){const t=h._encoderConfig.bitrateMax,i=e.bitrate.actualEncoded;if(t&&i){const e=(1e3*t-i)/(1e3*t);return XE[e<.15?0:e<.3?1:e<.45?2:e<.6?3:4][l]}}return l}getDownlinkNetworkQuality(){if(!this.connection)return 0;const e=this.connection.getStats();let t=0;return Array.from(this.remoteUserMap.entries()).forEach(i=>{let[n]=i;const r=n._audioSSRC,o=n._videoSSRC,s=e.audioRecv.find(e=>e.ssrc===r),a=e.videoRecv.find(e=>e.ssrc===o);if(!s&&!a)return void(t+=1);const c=oC(this,DS.NeedSignalRTT),d=e.rtt,u=(d&&c?(d+c)/2:d||c)||0,l=s?s.jitterMs:void 0,h=e.recvPacketLossRate;let p=.7*h*100/50+.3*u/1500;l&&(p=.6*h*100/50+.2*u/1500+.2*l/400);t+=p<.1?1:p<.17?2:p<.36?3:p<.59?4:5;}),this.remoteUserMap.size>0?Math.round(t/this.remoteUserMap.size):t}async muteLocalTrack(e){return new Sl((t,i)=>{this.handleMuteLocalTrack(e,t,i);})}filterTobePublishedTracks(e,t,i){const n=[],r=JS(),o=this.getAllTracks();e=cC(e=e.filter(e=>-1===o.indexOf(e)));let s=!1,a=!1;for(const o of e){if(o instanceof Cy&&(this.localTrackMap.has(bS.LocalVideoTrack)||s?new SE(fE.CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS).throw():(n.push({track:o,type:bS.LocalVideoTrack}),s=!0),t)){const e=this.getLowVideoTrack(o,i);n.push({track:e,type:bS.LocalVideoLowTrack});}if(o instanceof yI){const e=this.localTrackMap.get(bS.LocalAudioTrack);if(e){if(!(e.track instanceof NI))throw new SE(fE.NOT_SUPPORTED,"cannot publish multiple tracks which one of them configured with bypassWebAudio or your browser does not support audio mixing");if(o._bypassWebAudio)throw new SE(fE.NOT_SUPPORTED,"cannot publish multiple tracks which one of them configured with bypassWebAudio");e.track.addAudioTrack(o),this.bindLocalAudioTrackEvents(o,!0);}else if(a){const e=n.find(e=>{let{type:t}=e;return t===bS.LocalAudioTrack});if(!(e.track instanceof NI))throw new SE(fE.NOT_SUPPORTED,"cannot publish multiple tracks which one of them configured with bypassWebAudio or your browser does not support audio mixing");if(o._bypassWebAudio)throw new SE(fE.NOT_SUPPORTED,"cannot publish multiple tracks which one of them configured with bypassWebAudio");e.track.addAudioTrack(o);}else {if(!r.webAudioMediaStreamDest||o instanceof NI||o._bypassWebAudio)n.push({track:o,type:bS.LocalAudioTrack});else {const e=new NI;e.addAudioTrack(o),n.push({track:e,type:bS.LocalAudioTrack});}a=!0;}}}return n}filterTobeUnpublishedTracks(e){const t=[],i=this.getAllTracks();e=cC(e=e.filter(e=>-1!==i.indexOf(e)));for(const i of e){if(i instanceof yI){const e=this.localTrackMap.get(bS.LocalAudioTrack);if(!e)continue;e.track instanceof NI?(e.track.removeAudioTrack(i),this.unbindLocalAudioTrackEvents(i),0===e.track.trackList.length&&(t.push([bS.LocalAudioTrack,e]),e.track.close())):t.push([bS.LocalAudioTrack,e]);}if(i instanceof Cy){const e=this.localTrackMap.get(bS.LocalVideoTrack);if(!e)continue;t.push([bS.LocalVideoTrack,e]);const i=this.localTrackMap.get(bS.LocalVideoLowTrack);i&&t.push([bS.LocalVideoLowTrack,i]);}}return t}bindLocalTrackEvents(e){e.forEach(e=>{let{track:t,type:i}=e;switch(i){case bS.LocalVideoTrack:t.addListener(uS.GET_STATS,this.handleGetLocalVideoStats),t.addListener(uS.NEED_DISABLE_TRACK,this.handleMuteLocalTrack),t.addListener(uS.NEED_ENABLE_TRACK,this.handleUnmuteLocalTrack),t.addListener(uS.NEED_UPDATE_VIDEO_ENCODER,this.handleUpdateVideoEncoder),t.addListener(uS.SET_OPTIMIZATION_MODE,this.handleSetOptimizationMode),t.addListener(uS.NEED_REPLACE_TRACK,this.handleReplaceTrack),t.addListener(uS.NEED_MUTE_TRACK,this.handleMuteLocalTrack),t.addListener(uS.NEED_UNMUTE_TRACK,this.handleUnmuteLocalTrack);break;case bS.LocalAudioTrack:this.bindLocalAudioTrackEvents(t);break;case bS.LocalVideoLowTrack:}});}bindLocalAudioTrackEvents(e,t){e instanceof NI?e.trackList.forEach(e=>{e.addListener(uS.NEED_DISABLE_TRACK,this.handleMuteLocalTrack),e.addListener(uS.NEED_ENABLE_TRACK,this.handleUnmuteLocalTrack),e.addListener(uS.GET_STATS,this.handleGetLocalAudioStats),e.addListener(uS.NEED_MUTE_TRACK,this.handleMuteLocalTrack),e.addListener(uS.NEED_UNMUTE_TRACK,this.handleUnmuteLocalTrack);}):(e.addListener(uS.GET_STATS,this.handleGetLocalAudioStats),e.addListener(uS.NEED_DISABLE_TRACK,this.handleMuteLocalTrack),e.addListener(uS.NEED_ENABLE_TRACK,this.handleUnmuteLocalTrack),e.addListener(uS.NEED_MUTE_TRACK,this.handleMuteLocalTrack),e.addListener(uS.NEED_UNMUTE_TRACK,this.handleUnmuteLocalTrack),t||e.addListener(uS.NEED_REPLACE_TRACK,this.handleReplaceTrack));}unbindLocalTrackEvents(e){e||(e=Array.from(this.localTrackMap.entries()).map(e=>{let[t,{track:i}]=e;return {track:i,type:t}})),e.forEach(e=>{let{track:t,type:i}=e;switch(i){case bS.LocalVideoTrack:t.off(uS.GET_STATS,this.handleGetLocalVideoStats),t.off(uS.NEED_DISABLE_TRACK,this.handleMuteLocalTrack),t.off(uS.NEED_ENABLE_TRACK,this.handleUnmuteLocalTrack),t.off(uS.NEED_UPDATE_VIDEO_ENCODER,this.handleUpdateVideoEncoder),t.off(uS.SET_OPTIMIZATION_MODE,this.handleSetOptimizationMode),t.off(uS.NEED_REPLACE_TRACK,this.handleReplaceTrack),t.off(uS.NEED_MUTE_TRACK,this.handleMuteLocalTrack),t.off(uS.NEED_UNMUTE_TRACK,this.handleUnmuteLocalTrack);break;case bS.LocalAudioTrack:this.unbindLocalAudioTrackEvents(t);break;case bS.LocalVideoLowTrack:}});}unbindLocalAudioTrackEvents(e){e instanceof NI?e.trackList.forEach(e=>{e.off(uS.NEED_DISABLE_TRACK,this.handleMuteLocalTrack),e.off(uS.NEED_ENABLE_TRACK,this.handleUnmuteLocalTrack),e.off(uS.GET_STATS,this.handleGetLocalAudioStats),e.off(uS.NEED_MUTE_TRACK,this.handleMuteLocalTrack),e.off(uS.NEED_UNMUTE_TRACK,this.handleUnmuteLocalTrack);}):(e.off(uS.GET_STATS,this.handleGetLocalAudioStats),e.off(uS.NEED_DISABLE_TRACK,this.handleMuteLocalTrack),e.off(uS.NEED_ENABLE_TRACK,this.handleUnmuteLocalTrack),e.off(uS.NEED_REPLACE_TRACK,this.handleReplaceTrack),e.off(uS.NEED_MUTE_TRACK,this.handleMuteLocalTrack),e.off(uS.NEED_UNMUTE_TRACK,this.handleUnmuteLocalTrack));}bindRemoteTrackEvents(e,t){t instanceof ib&&t.addListener(uS.GET_STATS,t=>{t(this.handleGetRemoteVideoStats(e));}),t instanceof nb&&t.addListener(uS.GET_STATS,t=>{t(this.handleGetRemoteAudioStats(e));});}unbindRemoteTrackEvents(e){e&&e.removeAllListeners(uS.GET_STATS);}unbindAllRemoteTrackEvents(){Array.from(this.remoteUserMap.entries()).forEach(e=>{let[t,i]=e;i.has(AS.AUDIO)&&this.unbindRemoteTrackEvents(t._audioTrack),i.has(AS.VIDEO)&&this.unbindRemoteTrackEvents(t._videoTrack);});}createGatewayPublishMessage(e,t){return e.map((e,i)=>{let n,r,{track:o,type:s}=e;switch(s){case bS.LocalAudioTrack:n=sS.Audio,r={dtx:o instanceof AI&&o._config.DTX,hq:!1,lq:!1,stereo:!1,speech:!1};break;case bS.LocalVideoTrack:n=o._hints.includes(lS.SCREEN_TRACK)?sS.Screen:sS.High,r=Ab(Ab({},BI(o)),{},{codec:this.store.codec});break;case bS.LocalVideoLowTrack:n=sS.Low,r=Ab(Ab({},BI(o)),{},{codec:this.store.codec});}return {stream_type:n,attributes:r,ssrcs:t[i]}})}createGatewayUnpublishMessage(e){return e.map(e=>{let t,[i,{track:n,ssrcs:r,id:o}]=e;switch(i){case bS.LocalVideoTrack:t=n._hints.includes(lS.SCREEN_TRACK)?sS.Screen:sS.High;break;case bS.LocalAudioTrack:t=sS.Audio;break;case bS.LocalVideoLowTrack:t=sS.Low;}return {stream_type:t,ssrcs:r,mid:o}})}assignLocalTracks(e,t){e.forEach((e,i)=>{let{track:n,type:r}=e;this.localTrackMap.set(r,{track:n,id:t[i].id,ssrcs:t[i].localSSRC});});}withdrawLocalTracks(e){e.forEach(e=>{let[t]=e;this.localTrackMap.delete(t);});}bindConnectionEvents(e){e.onConnectionStateChange=async t=>{if(OE.info("[".concat(this.store.clientId,"] [p2pId: ").concat(this.store.p2pId,"]: P2PConnection.onConnectionStateChange(").concat(t,")")),this.emit(DS.PeerConnectionStateChange,t),"connected"!==t||this.store.keyMetrics.peerConnectionEnd||this.store.peerConnectionEnd(),"connected"===t&&(this._restartTimer&&(clearTimeout(this._restartTimer),this._restartTimer=void 0),(this._isFirstConnected||this._isInRestartIce)&&this.reportPCStats(Date.now(),!0,this._pcStatsUploadType),this._isInRestartIce=!1,this._isFirstConnected=!1,this._isStartRestartIce=!1),GE("NEW_ICE_RESTART")){if(this._restartStates.includes(t)){if(this._isStartRestartIce)return;this._isStartRestartIce=!0;const t=t=>{if("disconnected"===e.iceConnectionState||"checking"===e.iceConnectionState||"failed"===e.iceConnectionState){OE.debug("[".concat(this.store.clientId,"] [P2PChannel] start use restartICE, type is ").concat(t));"CONNECTED"===oC(this,DS.QueryClientConnectionState)&&this.emit(DS.RequestRestartICE,t);}},i=()=>{"disconnected"!==e.iceConnectionState&&"checking"!==e.iceConnectionState&&"failed"!==e.iceConnectionState||(this.reportPCStats(Date.now(),!1,this._pcStatsUploadType),OE.debug("[".concat(this.store.clientId,"] P2PConnection disconnected timeout, force reconnect")),setTimeout(()=>this.emit(DS.P2PLost),0),this.iceFailedCount+=1,this.requestReconnect());},n=GE("ICE_RESTART_INTERVAL");return void(this._restartTimer=window.setTimeout(()=>{if(GE("JOIN_WITH_FALLBACK_MEDIA_PROXY_FORCE")&&JS().supportPCSetConfiguration)t(OS.RELAY),this._restartTimer=window.setTimeout(i,n);else if(Kh())t(OS.UDP),this._restartTimer=window.setTimeout(i,4e3);else {if(t(OS.TCP),JS().supportPCSetConfiguration)return void(this._restartTimer=window.setTimeout(()=>{t(OS.RELAY),this._restartTimer=window.setTimeout(i,n);},n));this._restartTimer=window.setTimeout(i,n);}},800))}}else {if("disconnected"===t&&"disconnected"===e.iceConnectionState)return setTimeout(()=>{if("disconnected"===e.iceConnectionState&&GE("ICE_RESTART")){"CONNECTED"===oC(this,DS.QueryClientConnectionState)&&this.emit(DS.RequestRestartICE);}},800),void setTimeout(()=>{"disconnected"===e.peerConnectionState&&(OE.debug("[".concat(this.store.clientId,"] [p2pId: ").concat(this.store.p2pId,"]: P2PConnection disconnected timeout 4000ms, force reconnect")),this.reportPCStats(Date.now(),!1,this._pcStatsUploadType),this._isInRestartIce=!1,setTimeout(()=>this.emit(DS.P2PLost),0),this.iceFailedCount+=1,this.requestReconnect());},4e3);"failed"===t&&(OE.debug("[".concat(this.store.clientId,"] [p2pId: ").concat(this.store.p2pId,"]: P2PConnection state failed, force reconnect")),this.reportPCDisconnectedOrFailed(),setTimeout(()=>this.emit(DS.P2PLost),0),this.iceFailedCount+=1,await this.requestReconnect());}},e.onICEConnectionStateChange=e=>{"connected"!==e||this.store.keyMetrics.iceConnectionEnd||this.store.iceConnectionEnd(),OE.info("[".concat(this.store.clientId,"] [p2pId: ").concat(this.store.p2pId,"]: P2PConnection.onICEConnectionStateChange(").concat(e,")")),Pg.reportApiInvoke(this.store.sessionId,{name:"ICEConnectionStateChange",options:e,tag:Ef.TRACER}).onSuccess(),this.emit(DS.IceConnectionStateChange,e);},e.onICETransportStateChange=e=>{OE.info("[".concat(this.store.clientId,"] [p2pId: ").concat(this.store.p2pId,"]: P2PConnection.onICETransportStateChange(").concat(e,")"));},e.onDTLSTransportStateChange=e=>{OE.info("[".concat(this.store.clientId,"] [p2pId: ").concat(this.store.p2pId,"]: P2PConnection.onDTLSTransportStateChange(").concat(e,")"));},e.onDTLSTransportError=e=>{OE.info("[".concat(this.store.clientId,"] [p2pId: ").concat(this.store.p2pId,"]: P2PConnection.onDTLSTransportError(").concat(e,")"));},e.onFirstAudioDecoded=e=>{var t;const i=Array.from(Eg(t=this.remoteUserMap).call(t)).find(t=>t._audioSSRC===e);var n;i&&(this.store.subscribe(i.uid,"audio",void 0,void 0,void 0,Date.now()),null===(n=i.audioTrack)||void 0===n||n.emit(fS.FIRST_FRAME_DECODED),Pg.firstRemoteFrame(this.store.sessionId,uf.FIRST_AUDIO_DECODE,lf.FIRST_AUDIO_DECODE,{peer:i._uintid,subscribeElapse:DI.measureFromSubscribeStart(this.store.clientId,e),subscribeRequestid:e,p2pid:this.store.p2pId}));},e.onFirstAudioReceived=e=>{var t;const i=Array.from(Eg(t=this.remoteUserMap).call(t)).find(t=>t._audioSSRC===e);i&&Pg.firstRemoteFrame(this.store.sessionId,uf.FIRST_AUDIO_RECEIVED,lf.FIRST_AUDIO_RECEIVED,{peer:i._uintid,subscribeElapse:DI.measureFromSubscribeStart(this.store.clientId,e),subscribeRequestid:e,p2pid:this.store.p2pId});},e.onFirstVideoDecoded=(e,t,i)=>{this.reportVideoFirstFrameDecoded(e,t,i);},e.onFirstVideoReceived=e=>{var t;const i=Array.from(Eg(t=this.remoteUserMap).call(t)).find(t=>t._videoSSRC===e);i&&Pg.firstRemoteFrame(this.store.sessionId,uf.FIRST_VIDEO_RECEIVED,lf.FIRST_VIDEO_RECEIVED,{peer:i._uintid,subscribeElapse:DI.measureFromSubscribeStart(this.store.clientId,e),subscribeRequestid:e,p2pid:this.store.p2pId});},e.onSelectedLocalCandidateChanged=(e,t)=>{const i="relay"===e.candidateType,n="relay"===t.candidateType;"unknown"!==t.candidateType&&i===n||this.emit(DS.ConnectionTypeChange,i),OE.info("[".concat(this.store.clientId,"] [p2pId: ").concat(this.store.p2pId,"]: P2PConnection.SelectedLocalCandidateChanged(").concat(JSON.stringify(YI(t))," -> ").concat(JSON.stringify(YI(e)),")"));},e.onSelectedRemoteCandidateChanged=(e,t)=>{OE.info("[".concat(this.store.clientId,"] [p2pId: ").concat(this.store.p2pId,"]: P2PConnection.SelectedRemoteCandidateChanged(").concat(JSON.stringify(YI(t))," -> ").concat(JSON.stringify(YI(e)),")"));},e.onFirstVideoDecodedTimeout=e=>{this.reportVideoFirstFrameDecoded(e,void 0,void 0,!0);};}unbindConnectionEvents(e){e.onConnectionStateChange=void 0,e.onICEConnectionStateChange=void 0,e.onICETransportStateChange=void 0,e.onDTLSTransportStateChange=void 0,e.onDTLSTransportError=void 0,e.onFirstAudioDecoded=void 0,e.onFirstAudioReceived=void 0,e.onFirstVideoDecoded=void 0,e.onFirstVideoReceived=void 0,e.onSelectedLocalCandidateChanged=void 0,e.onSelectedRemoteCandidateChanged=void 0,e.onFirstVideoDecodedTimeout=void 0;}filterTobeMutedTracks(e){const t=[];if(-1===this.getAllTracks().indexOf(e))return t;const i=this.localTrackMap.get(bS.LocalAudioTrack);if(e instanceof yI&&(null==i?void 0:i.track)instanceof NI)return i.track.isActive||t.push([bS.LocalAudioTrack,i]),t;const n=Array.from(this.localTrackMap.entries()).find(t=>{let[,{track:i}]=t;return e===i});if(n&&(t.push(n),n[0]===bS.LocalVideoTrack)){const e=this.localTrackMap.get(bS.LocalVideoLowTrack);e&&t.push([bS.LocalVideoLowTrack,e]);}return t}filterTobeUnmutedTracks(e){const t=[],i=this.localTrackMap.get(bS.LocalAudioTrack);if(e instanceof yI&&(null==i?void 0:i.track)instanceof NI)return i.track.isActive&&t.push([bS.LocalAudioTrack,i]),t;const n=Array.from(this.localTrackMap.entries()).find(t=>{let[,{track:i}]=t;return e===i});if(n)if(n[0]===bS.LocalVideoTrack){t.push(n);const e=this.localTrackMap.get(bS.LocalVideoLowTrack);e&&t.push([bS.LocalVideoLowTrack,e]);}else t.push(n);return t}createMuteMessage(e){return e.map(e=>{let t,[i,{track:n,ssrcs:r,id:o}]=e;switch(i){case bS.LocalAudioTrack:t=sS.Audio;break;case bS.LocalVideoTrack:t=n._hints.includes(lS.SCREEN_TRACK)?sS.Screen:sS.High;break;case bS.LocalVideoLowTrack:t=sS.Low;}return {stream_type:t,ssrcs:r,mid:o}})}createUnmuteMessage(e){return e.map(e=>{let t,[i,{track:n,ssrcs:r,id:o}]=e;switch(i){case bS.LocalAudioTrack:t=sS.Audio;break;case bS.LocalVideoTrack:t=n._hints.includes(lS.SCREEN_TRACK)?sS.Screen:sS.High;break;case bS.LocalVideoLowTrack:t=sS.Low;}return {stream_type:t,ssrcs:r,mid:o}})}filterTobeUnSubscribedTracks(e,t){const i=[],n=this.remoteUserMap.get(e);if(!n)return i;if(t){const r=n.get(t);if(!r)return i;i.push([e,{kind:t,id:r}]);}else Array.from(n.entries()).forEach(t=>{let[n,r]=t;i.push([e,{kind:n,id:r}]);});return i}createUnsubscribeMessage(e){const t=[];return e.forEach(e=>{let[i,{kind:n,id:r}]=e;switch(n){case AS.VIDEO:return void(i._videoSSRC&&t.push({stream_type:AS.VIDEO,ssrcId:i._videoSSRC}));case AS.AUDIO:return void(i._audioSSRC&&t.push({stream_type:AS.AUDIO,ssrcId:i._audioSSRC}))}}),t}createUnsubscribeAllMessage(e){const t=new Map;return e.forEach(e=>{let[i,{kind:n}]=e;if(t.has(i)){let e=t.get(i);n===AS.VIDEO?e|=cS.Video:e|=cS.Audio,t.set(i,e);}else n===AS.VIDEO?t.set(i,cS.Video):t.set(i,cS.Audio);}),{users:Array.from(t.entries()).map(e=>{let[t,i]=e;return {stream_id:t.uid,stream_type:i}})}}withdrawRemoteTracks(e){e.forEach(e=>{let[t,{kind:i}]=e;const n=this.remoteUserMap.get(t);n&&(n.delete(i),0===Array.from(n.entries()).length&&this.remoteUserMap.delete(t));});}async updateBitrateLimit(e){const t=this.localTrackMap.get(bS.LocalVideoTrack),i=this.localTrackMap.get(bS.LocalVideoLowTrack);t&&await t.track.setBitrateLimit(e.uplink),i&&e.low_stream_uplink&&await i.track.setBitrateLimit({max_bitrate:e.low_stream_uplink.bitrate,min_bitrate:e.low_stream_uplink.bitrate||0});}isP2PDisconnected(){if(this.connection){return "connected"!==this.connection.peerConnectionState}return !0}mapPubResToRemoteConfig(e,t){return e.map((e,i)=>{var n;let{stream_type:r}=e;return null===(n=t.find(e=>{let{stream_type:t}=e;return r===t}))||void 0===n?void 0:n.attributes})}async tryToUnmuteAudio(e){for(let i=0;i<e.length;i++)if(e[i]instanceof yI){var t;const n=this.filterTobeUnmutedTracks(e[i]);if(0===n.length)continue;await(null===(t=this.connection)||void 0===t?void 0:t.unmuteLocal(n.map(e=>{let[,{id:t}]=e;return t})));const r=this.createUnmuteMessage(n);return void await rC(this,DS.RequestUnmuteLocal,r)}}bindStatsUploaderEvents(){this.statsUploader.requestStats=()=>this.getStats(),this.statsUploader.requestLocalMedia=()=>Array.from(this.localTrackMap.entries()),this.statsUploader.requestRemoteMedia=()=>Array.from(this.remoteUserMap.entries()),this.statsUploader.requestVideoIsReady=e=>{var t;return !(null===(t=this.connection)||void 0===t||!t.getRemoteVideoIsReady(e))},this.statsUploader.requestUpload=(e,t)=>this.emit(DS.RequestUploadStats,e,t),this.statsUploader.requestAllTracks=()=>this.getAllTracks();}unbindStatsUploaderEvents(){this.statsUploader.requestStats=void 0,this.statsUploader.requestLocalMedia=void 0,this.statsUploader.requestRemoteMedia=void 0,this.statsUploader.requestVideoIsReady=void 0;}async requestReconnect(){this.dtlsFailedCount+=1,await zI(gE(this.dtlsFailedCount,TE)),this.emit(DS.RequestReconnect);}async reconnectP2P(){const e=Array.from(this.localTrackMap.entries()),t=this.createGatewayUnpublishMessage(e);Array.from(this.remoteUserMap.entries()),t.length>0&&await nC(this,DS.RequestUnpublishForReconnectPC,t),this.disconnectForReconnect(),this.emit(DS.RequestReconnectPC);}canPublishLowStream(){return this.localTrackMap.has(bS.LocalVideoTrack)||this.pendingLocalTracks.some(e=>e instanceof Cy)}throwIfTrackTypeNotMatch(e){if(e.filter(e=>e instanceof Cy).length>1)throw new SE(fE.CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS);if(e.filter(e=>e instanceof yI).length>1&&(e.some(e=>e instanceof yI&&e._bypassWebAudio)||!JS().webAudioMediaStreamDest))throw new SE(fE.NOT_SUPPORTED,"cannot publish multiple tracks which one of them configured with bypassWebAudio or your browser doesn't support MediaStreamDestNode");for(const t of e){if(t instanceof Cy&&this.pendingLocalTracks.some(e=>e instanceof Cy))throw new SE(fE.CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS);if(t instanceof yI&&this.pendingLocalTracks.some(e=>e instanceof yI)&&(!JS().webAudioMediaStreamDest||t._bypassWebAudio||this.pendingLocalTracks.some(e=>e instanceof yI&&e._bypassWebAudio)))throw new SE(fE.NOT_SUPPORTED,"cannot publish multiple tracks which one of them configured with bypassWebAudio or your browser doesn't support MediaStreamDestNode")}}getLowVideoTrack(e,t){const i=JS().supportDualStreamEncoding,n=Ab(Ab({},{width:160,height:120,framerate:15,bitrate:50}),t);let r;r=i?e._mediaStreamTrack.clone():FN(e,n);const o=ZI(8,"track-low-"),s=new Cy(r,Ab(Ab({},i&&{scaleResolutionDownBy:KI(n,e)}),{},{frameRate:n.framerate,bitrateMax:n.bitrate,bitrateMin:n.bitrate}),void 0,void 0,o);return s.on(ES.TRANSCEIVER_UPDATED,t=>{e._updateRtpTransceiver(t,hS.LOW_STREAM);}),s._hints.push(lS.LOW_STREAM),e.addListener(uS.NEED_CLOSE,()=>{s.close();}),s}async globalLock(){return this.mutex.lock("From P2PChannel.globalLock")}async reportPCStats(e,t,i){let n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;if(this.connection&&this.connection instanceof VN){var r,o,s,a;const c=this.store.keyMetrics.descriptionStart||0,{iceConnectionState:d,dtlsTransportState:u,peerConnectionState:l}=this.connection,{local:h,remote:p}=await this.connection.getSelectedCandidatePair();Pg.pcStats(this.store.sessionId,{startTime:c,eventElapse:e-c||0,iceconnectionsate:d,dtlsstate:u,connectionstate:l,intSucc:t?1:2,error:n,selectedLocalCandidateProtocol:null!==(r=null==h?void 0:h.protocol)&&void 0!==r?r:"",selectedLocalCandidateType:null!==(o=h.candidateType)&&void 0!==o?o:"",selectedLocalCandidateAddress:"".concat(h.address,":").concat(h.port),selectedRemoteCandidateProtocol:null!==(s=p.protocol)&&void 0!==s?s:"",selectedRemoteCandidateType:null!==(a=p.candidateType)&&void 0!==a?a:"",selectedRemoteCandidateAddress:"".concat(p.address,":").concat(p.port),restartCnt:i});}}reportVideoFirstFrameDecoded(e,t,i,n){var r;const o=Array.from(Eg(r=this.remoteUserMap).call(r)).find(t=>t._videoSSRC===e);if(o){n||this.store.subscribe(o.uid,"video",void 0,void 0,void 0,void 0,Date.now());const r=this.store.keyMetrics,s=r.subscribe.find(e=>e.userId===o.uid&&"video"===e.type);Pg.firstRemoteVideoDecode(this.store.sessionId,uf.FIRST_VIDEO_DECODE,lf.FIRST_VIDEO_DECODE,{peer:o._uintid,videowidth:t,videoheight:i,subscribeElapse:DI.measureFromSubscribeStart(this.store.clientId,e),subscribeRequestid:e,p2pid:this.store.p2pId,apEnd:r.requestAPEnd||0,apStart:r.requestAPStart||0,joinGwEnd:r.joinGatewayEnd||0,joinGwStart:r.joinGatewayStart||0,pcEnd:r.peerConnectionEnd||0,pcStart:r.peerConnectionStart||0,subscriberEnd:(null==s?void 0:s.subscribeEnd)||0,subscriberStart:(null==s?void 0:s.subscribeStart)||0,videoAddNotify:(null==s?void 0:s.streamAdded)||0,state:n?1:0});}}async remoteMediaSsrcChanged(e,t,i){if(!this.connection)return !1;const n=this.remoteUserMap.get(e);if(!n)return !1;const r=n.get(t);if(!r)return !1;const o=await this.connection.getRemoteSSRC(r);return void 0!==o&&o!==i}resetConnection(e){OE.debug("[".concat(this.store.clientId,"] [P2PChannel] reset connection to ").concat(e)),this.state===wS.Connected?(OE.debug("[".concat(this.store.clientId,"] [P2PChannel] fallback to websocket but P2PChannel state still connected, disconnect first")),this.disconnectForReconnect()):(this.connection&&(this.connection.close(),this.unbindConnectionEvents(this.connection),this.connection=void 0),this.shouldForwardP2PCreation&&(this.connection=e===dS.datachannel?new Ib({},this.store):this.isPlanB?new NN({},this.store):new VN({},this.store),this.bindConnectionEvents(this.connection)));}unbindRtpTransceiver(){0!==this.localTrackMap.size&&Array.from(this.localTrackMap.entries()).forEach(e=>{let[t,{track:i}]=e;t===bS.LocalVideoLowTrack?i._updateRtpTransceiver(void 0,hS.LOW_STREAM):i._updateRtpTransceiver(void 0);});}reportPCDisconnectedOrFailed(e){this.connection&&this.connection instanceof VN&&("disconnected"!==this.connection.iceConnectionState&&"checking"!==this.connection.iceConnectionState&&"failed"!==this.connection.iceConnectionState||(this._isFirstConnected?(this.reportPCStats(Date.now(),!1,this._pcStatsUploadType),this._isFirstConnected=!1):this._pcStatsUploadType===NS.TCP_RESTART&&e===OS.RELAY?this.reportPCStats(Date.now(),!1,this._pcStatsUploadType):this.reportPCStats(Date.now(),!1,NS.DISCONNECTED_OR_FAILED)));}}).prototype,"startP2PConnection",[wb],Object.getOwnPropertyDescriptor(vb.prototype,"startP2PConnection"),vb.prototype),ag(vb.prototype,"connect",[wb],Object.getOwnPropertyDescriptor(vb.prototype,"connect"),vb.prototype),ag(vb.prototype,"preConnect",[wb],Object.getOwnPropertyDescriptor(vb.prototype,"preConnect"),vb.prototype),ag(vb.prototype,"unpublish",[wb],Object.getOwnPropertyDescriptor(vb.prototype,"unpublish"),vb.prototype),ag(vb.prototype,"unpublishLowStream",[wb],Object.getOwnPropertyDescriptor(vb.prototype,"unpublishLowStream"),vb.prototype),ag(vb.prototype,"subscribe",[wb],Object.getOwnPropertyDescriptor(vb.prototype,"subscribe"),vb.prototype),ag(vb.prototype,"massSubscribe",[wb],Object.getOwnPropertyDescriptor(vb.prototype,"massSubscribe"),vb.prototype),ag(vb.prototype,"unsubscribe",[wb],Object.getOwnPropertyDescriptor(vb.prototype,"unsubscribe"),vb.prototype),ag(vb.prototype,"massUnsubscribe",[wb],Object.getOwnPropertyDescriptor(vb.prototype,"massUnsubscribe"),vb.prototype),ag(vb.prototype,"muteRemote",[wb],Object.getOwnPropertyDescriptor(vb.prototype,"muteRemote"),vb.prototype),ag(vb.prototype,"unmuteRemote",[wb],Object.getOwnPropertyDescriptor(vb.prototype,"unmuteRemote"),vb.prototype),ag(vb.prototype,"hasRemoteMediaWithLock",[wb],Object.getOwnPropertyDescriptor(vb.prototype,"hasRemoteMediaWithLock"),vb.prototype),ag(vb.prototype,"disconnectForReconnect",[wb],Object.getOwnPropertyDescriptor(vb.prototype,"disconnectForReconnect"),vb.prototype),ag(vb.prototype,"updateBitrateLimit",[wb],Object.getOwnPropertyDescriptor(vb.prototype,"updateBitrateLimit"),vb.prototype),ag(vb.prototype,"remoteMediaSsrcChanged",[wb],Object.getOwnPropertyDescriptor(vb.prototype,"remoteMediaSsrcChanged"),vb.prototype),vb);function wb(e,t,i){const n=e[t];if("function"!=typeof n)throw new Error("Cannot use mutex on object property.");return i.value=async function(){const e=this.mutex,i=await e.lock("From P2PChannel.".concat(t));try{for(var r=arguments.length,o=new Array(r),s=0;s<r;s++)o[s]=arguments[s];return await n.apply(this,o)}finally{i();}},i}function Db(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n);}return i}function Pb(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?Db(Object(i),!0).forEach((function(t){_p(e,t,i[t]);})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):Db(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t));}));}return e}var Lb;!function(e){e.SET_SESSION_ID="SET_SESSION_ID",e.SET_P2P_ID="SET_P2P_id",e.SET_DC_ID="SET_DC_id",e.SET_UID="SET_UID",e.SET_PUB_ID="SET_PUB_ID",e.SET_CLOUD_PROXY_SERVER_MODE="SET_CLOUD_PROXY_SERVER_MODE",e.KEY_METRIC_CLIENT_CREATED="KEY_METRIC_CLIENT_CREATED",e.KEY_METRIC_JOIN_START="KEY_METRIC_JOIN_START",e.AVOID_JOIN_START="AVOID_JOIN_START",e.KEY_METRIC_JOIN_END="KEY_METRIC_JOIN_END",e.KEY_METRIC_REQUEST_AP_START="KEY_METRIC_REQUEST_AP_START",e.KEY_METRIC_REQUEST_AP_END="KEY_METRIC_REQUEST_AP_END",e.KEY_METRIC_JOIN_GATEWAY_START="KEY_METRIC_JOIN_GATEWAY_START",e.KEY_METRIC_JOIN_GATEWAY_END="KEY_METRIC_JOIN_GATEWAY_END",e.KEY_METRIC_PEER_CONNECTION_START="KEY_METRIC_PEER_CONNECTION_START",e.KEY_METRIC_PEER_CONNECTION_END="KEY_METRIC_PEER_CONNECTION_END",e.KEY_METRIC_DESCRIPTION_START="KEY_METRIC_DESCRIPTION_START",e.KEY_METRIC_ICE_CONNECTION_END="KEY_METRIC_ICE_CONNECTION_END",e.KEY_METRIC_SIGNAL_CHANNEL_OPEN="KEY_METRIC_SIGNAL_CHANNEL_OPEN",e.KEY_METRIC_PUBLISH="KEY_METRIC_PUBLISH",e.KEY_METRIC_SUBSCRIBE="KEY_METRIC_SUBSCRIBE",e.RECORD_JOIN_CHANNEL_SERVICE="RECORD_JOIN_CHANNEL_SERVICE",e.RESET_JOIN_CHANNEL_SERVICE_RECORDS="RESET_JOIN_CHANNEL_SERVICE_RECORDS",e.RESET_KEY_METRICS="RESET_KEY_METRICS",e.SET_USE_DATACHANNEL="SET_USE_DATACHANNEL";}(Lb||(Lb={}));class kb{constructor(e,t,i,n){_p(this,"state",void 0),this.state={codec:e,audioCodec:t,mode:i,clientId:n,sessionId:null,p2pId:0,dcId:0,pubId:0,subId:0,avoidJoinStart:0,keyMetrics:{publish:[],subscribe:[]},joinChannelServiceRecords:[],cloudProxyServerMode:"disabled",useDataChannel:!1};}dispatch(e){this.state=function(e,t){switch(t.type){case Lb.SET_SESSION_ID:return Pb(Pb({},e),{},{sessionId:t.sessionId});case Lb.SET_P2P_ID:return Pb(Pb({},e),{},{p2pId:t.p2pId});case Lb.SET_UID:return Pb(Pb({},e),{},{uid:t.uid});case Lb.SET_PUB_ID:return Pb(Pb({},e),{},{pubId:t.pubId});case Lb.KEY_METRIC_CLIENT_CREATED:return Pb(Pb({},e),{},{keyMetrics:Pb(Pb({},e.keyMetrics),{},{clientCreated:t.metric})});case Lb.KEY_METRIC_JOIN_START:return Pb(Pb({},e),{},{keyMetrics:Pb(Pb({},e.keyMetrics),{},{joinStart:t.metric})});case Lb.AVOID_JOIN_START:return Pb(Pb({},e),{},{avoidJoinStart:t.avoidJoinStart});case Lb.KEY_METRIC_JOIN_END:return Pb(Pb({},e),{},{keyMetrics:Pb(Pb({},e.keyMetrics),{},{joinEnd:t.metric})});case Lb.KEY_METRIC_REQUEST_AP_START:return Pb(Pb({},e),{},{keyMetrics:Pb(Pb({},e.keyMetrics),{},{requestAPStart:t.metric})});case Lb.KEY_METRIC_REQUEST_AP_END:return Pb(Pb({},e),{},{keyMetrics:Pb(Pb({},e.keyMetrics),{},{requestAPEnd:t.metric})});case Lb.KEY_METRIC_JOIN_GATEWAY_START:return Pb(Pb({},e),{},{keyMetrics:Pb(Pb({},e.keyMetrics),{},{joinGatewayStart:t.metric})});case Lb.KEY_METRIC_JOIN_GATEWAY_END:return Pb(Pb({},e),{},{keyMetrics:Pb(Pb({},e.keyMetrics),{},{joinGatewayEnd:t.metric})});case Lb.KEY_METRIC_PEER_CONNECTION_START:return Pb(Pb({},e),{},{keyMetrics:Pb(Pb({},e.keyMetrics),{},{peerConnectionStart:t.metric})});case Lb.KEY_METRIC_PEER_CONNECTION_END:return Pb(Pb({},e),{},{keyMetrics:Pb(Pb({},e.keyMetrics),{},{peerConnectionEnd:t.metric})});case Lb.KEY_METRIC_DESCRIPTION_START:return Pb(Pb({},e),{},{keyMetrics:Pb(Pb({},e.keyMetrics),{},{descriptionStart:t.metric})});case Lb.KEY_METRIC_SIGNAL_CHANNEL_OPEN:return Pb(Pb({},e),{},{keyMetrics:Pb(Pb({},e.keyMetrics),{},{signalChannelOpen:t.metric})});case Lb.KEY_METRIC_ICE_CONNECTION_END:return Pb(Pb({},e),{},{keyMetrics:Pb(Pb({},e.keyMetrics),{},{iceConnectionEnd:t.metric})});case Lb.KEY_METRIC_PUBLISH:{const i=e.keyMetrics.publish,n=i.findIndex(e=>e.trackId===t.metric.trackId);return -1!==n?(i[n]=Pb(Pb({},i[n]),t.metric),Pb(Pb({},e),{},{keyMetrics:Pb(Pb({},e.keyMetrics),{},{publish:[...i]})})):Pb(Pb({},e),{},{keyMetrics:Pb(Pb({},e.keyMetrics),{},{publish:[...e.keyMetrics.publish,t.metric]})})}case Lb.KEY_METRIC_SUBSCRIBE:{const i=e.keyMetrics.subscribe,n=i.findIndex(e=>e.userId===t.metric.userId&&e.type===t.metric.type);return -1!==n?(i[n]=Pb(Pb({},i[n]),t.metric),Pb(Pb({},e),{},{keyMetrics:Pb(Pb({},e.keyMetrics),{},{subscribe:[...i]})})):Pb(Pb({},e),{},{keyMetrics:Pb(Pb({},e.keyMetrics),{},{subscribe:[...e.keyMetrics.subscribe,t.metric]})})}case Lb.SET_CLOUD_PROXY_SERVER_MODE:return e.cloudProxyServerMode=t.mode,e;case Lb.RECORD_JOIN_CHANNEL_SERVICE:return "number"!=typeof t.index?e.joinChannelServiceRecords=[...e.joinChannelServiceRecords,t.record]:(e.joinChannelServiceRecords[t.index]=Pb(Pb({},e.joinChannelServiceRecords[t.index]),t.record),e.joinChannelServiceRecords=[...e.joinChannelServiceRecords]),e;case Lb.RESET_JOIN_CHANNEL_SERVICE_RECORDS:return e.joinChannelServiceRecords=[],e;case Lb.RESET_KEY_METRICS:return e.keyMetrics={publish:[],subscribe:[]},e;case Lb.SET_USE_DATACHANNEL:return Pb(Pb({},e),{},{useDataChannel:t.val});default:return e}}(this.state,e);}set sessionId(e){this.dispatch({type:Lb.SET_SESSION_ID,sessionId:e});}get sessionId(){return this.state.sessionId}get codec(){return this.state.codec}get audioCodec(){return this.state.audioCodec}get clientId(){return this.state.clientId}set p2pId(e){this.dispatch({type:Lb.SET_P2P_ID,p2pId:e});}get p2pId(){return this.state.p2pId}set dcId(e){this.dispatch({type:Lb.SET_DC_ID,dcId:e});}get dcId(){return this.state.dcId}set uid(e){this.dispatch({type:Lb.SET_UID,uid:e});}get uid(){return this.state.uid}set pubId(e){this.dispatch({type:Lb.SET_PUB_ID,pubId:e});}get pubId(){return this.state.pubId}set cloudProxyServerMode(e){this.dispatch({type:Lb.SET_CLOUD_PROXY_SERVER_MODE,mode:e});}get cloudProxyServerMode(){return this.state.cloudProxyServerMode}set useDataChannel(e){this.dispatch({type:Lb.SET_USE_DATACHANNEL,val:e});}get useDataChannel(){return this.state.useDataChannel}clientCreated(){this.dispatch({type:Lb.KEY_METRIC_CLIENT_CREATED,metric:Date.now()});}joinStart(){this.dispatch({type:Lb.KEY_METRIC_JOIN_START,metric:Date.now()});}joinEnd(){this.dispatch({type:Lb.KEY_METRIC_JOIN_END,metric:Date.now()});}requestAPStart(){this.dispatch({type:Lb.KEY_METRIC_REQUEST_AP_START,metric:Date.now()});}requestAPEnd(){this.dispatch({type:Lb.KEY_METRIC_REQUEST_AP_END,metric:Date.now()});}joinGatewayStart(){this.dispatch({type:Lb.KEY_METRIC_JOIN_GATEWAY_START,metric:Date.now()});}joinGatewayEnd(){this.dispatch({type:Lb.KEY_METRIC_JOIN_GATEWAY_END,metric:Date.now()});}peerConnectionStart(){this.dispatch({type:Lb.KEY_METRIC_PEER_CONNECTION_START,metric:Date.now()});}peerConnectionEnd(){this.dispatch({type:Lb.KEY_METRIC_PEER_CONNECTION_END,metric:Date.now()});}descriptionStart(){this.dispatch({type:Lb.KEY_METRIC_DESCRIPTION_START,metric:Date.now()});}signalChannelOpen(){this.dispatch({type:Lb.KEY_METRIC_SIGNAL_CHANNEL_OPEN,metric:Date.now()});}iceConnectionEnd(){this.dispatch({type:Lb.KEY_METRIC_ICE_CONNECTION_END,metric:Date.now()});}publish(e,t,i,n){this.dispatch({type:Lb.KEY_METRIC_PUBLISH,metric:Pb(Pb({trackId:e,type:t},i&&{publishStart:i}),n&&{publishEnd:n})});}subscribe(e,t,i,n,r,o,s){this.dispatch({type:Lb.KEY_METRIC_SUBSCRIBE,metric:Pb(Pb(Pb(Pb(Pb({userId:e,type:t},i&&{subscribeStart:i}),n&&{subscribeEnd:n}),r&&{firstFrame:r}),o&&{streamAdded:o}),s&&{firstDecoded:s})});}massSubscribe(e,t,i,n){e.forEach(e=>{this.dispatch({type:Lb.KEY_METRIC_SUBSCRIBE,metric:Pb(Pb(Pb({userId:e.userId,type:e.type},t&&{subscribeStart:t}),i&&{subscribeEnd:i}),n&&{firstFrame:n})});});}get keyMetrics(){return this.state.keyMetrics}recordJoinChannelService(e,t){"gateway"===e.service&&Array.isArray(e.urls)&&(e.urls=e.urls.map(e=>e.replace(/(\d+)-\d+-\d+-(\d+)/,"$1-*-*-$2")));try{return "number"!=typeof t?(this.dispatch({type:Lb.RECORD_JOIN_CHANNEL_SERVICE,record:Pb(Pb({},e),{},{sessionId:this.sessionId,cloudProxyMode:this.cloudProxyServerMode,uid:this.uid})}),this.state.joinChannelServiceRecords.length-1):(t<0||t>=this.state.joinChannelServiceRecords.length||this.dispatch({type:Lb.RECORD_JOIN_CHANNEL_SERVICE,record:e,index:t}),t)}catch(e){return 0}}resetJoinChannelServiceRecords(){this.dispatch({type:Lb.RESET_JOIN_CHANNEL_SERVICE_RECORDS});}resetKeyMetrics(){this.dispatch({type:Lb.RESET_KEY_METRICS});}get joinChannelServiceRecords(){try{return this.state.joinChannelServiceRecords}catch(e){return []}}get avoidJoinStart(){return this.state.avoidJoinStart}set avoidJoinStart(e){this.dispatch({type:Lb.AVOID_JOIN_START,avoidJoinStart:e});}}let Mb;const Ub=()=>"HTTPS"===(Mb||Mb||(Mb=(window.location.protocol.split(":")[0]||"").toUpperCase(),Mb)),xb=()=>void 0!==window.isSecureContext;function Vb(e){let t=Xb();return function(e,t){let i=e.appId;void 0!==i&&(dw(t,10),iw(t,i));let n=e.cid;void 0!==n&&(dw(t,16),dw(t,n));let r=e.cname;void 0!==r&&(dw(t,26),iw(t,r));let o=e.deviceId;void 0!==o&&(dw(t,34),iw(t,o));let s=e.elapse;void 0!==s&&(dw(t,40),uw(t,s));let a=e.fileSize;void 0!==a&&(dw(t,48),uw(t,qb(a)));let c=e.height;void 0!==c&&(dw(t,56),uw(t,qb(c)));let d=e.jpg;void 0!==d&&(dw(t,66),dw(t,d.length),function(e,t){let i=$b(e,t.length);e.bytes.set(t,i);}(t,d));let u=e.networkType;void 0!==u&&(dw(t,72),uw(t,qb(u)));let l=e.osType;void 0!==l&&(dw(t,80),uw(t,qb(l)));let h=e.requestId;void 0!==h&&(dw(t,90),iw(t,h));let p=e.sdkVersion;void 0!==p&&(dw(t,98),iw(t,p));let _=e.sequence;void 0!==_&&(dw(t,104),uw(t,qb(_)));let E=e.sid;void 0!==E&&(dw(t,114),iw(t,E));let m=e.timestamp;void 0!==m&&(dw(t,120),uw(t,m));let f=e.uid;void 0!==f&&(dw(t,128),dw(t,f));let S=e.vid;void 0!==S&&(dw(t,136),dw(t,S));let T=e.width;void 0!==T&&(dw(t,144),uw(t,qb(T)));let g=e.service;void 0!==g&&(dw(t,152),dw(t,g));let R=e.callbackData;void 0!==R&&(dw(t,162),iw(t,R));let I=e.jpgEncryption;void 0!==I&&(dw(t,168),dw(t,I));let C=e.requestType;void 0!==C&&(dw(t,176),dw(t,C));let v=e.scorePorn;void 0!==v&&(dw(t,185),aw(t,v));let y=e.scoreSexy;void 0!==y&&(dw(t,193),aw(t,y));let A=e.scoreNeutral;void 0!==A&&(dw(t,201),aw(t,A));let O=e.scene;void 0!==O&&(dw(t,208),dw(t,O));let N=e.ossFilePrefix;void 0!==N&&(dw(t,218),iw(t,N));let b=e.serviceVendor;if(void 0!==b)for(let e of b){dw(t,226);let i=Xb();Bb(e,i),dw(t,i.limit),nw(t,i),zb(i);}}(e,t),function(e){let t=e.bytes,i=e.limit;return t.length===i?t:t.subarray(0,i)}(t)}function jb(e){return function(e){let t={};e:for(;!Zb(e);){let i=cw(e);switch(i>>>3){case 0:break e;case 1:t.code=cw(e);break;case 2:t.msg=tw(e,cw(e));break;case 3:{let i=Gb(e);t.data=Fb(e),e.limit=i;break}default:Wb(e,7&i);}}return t}({bytes:t=e,offset:0,limit:t.length});var t;}function Fb(e){let t={};e:for(;!Zb(e);){let i=cw(e);switch(i>>>3){case 0:break e;case 1:t.requestId=tw(e,cw(e));break;case 2:t.requestType=cw(e)>>>0;break;case 3:t.scorePorn=sw(e);break;case 4:t.scoreSexy=sw(e);break;case 5:t.scoreNeutral=sw(e);break;case 6:t.requestScene=cw(e)>>>0;break;case 7:t.scene=cw(e)>>>0;break;default:Wb(e,7&i);}}return t}function Bb(e,t){let i=e.service;void 0!==i&&(dw(t,8),dw(t,i));let n=e.vendor;void 0!==n&&(dw(t,16),dw(t,n));let r=e.token;void 0!==r&&(dw(t,26),iw(t,r));let o=e.callbackUrl;void 0!==o&&(dw(t,34),iw(t,o));}function Gb(e){let t=cw(e),i=e.limit;return e.limit=e.offset+t,i}function Wb(e,t){switch(t){case 0:for(;128&rw(e););break;case 2:Qb(e,cw(e));break;case 5:Qb(e,4);break;case 1:Qb(e,8);break;default:throw new Error("Unimplemented type: "+t)}}let Hb=new Float32Array(1);new Uint8Array(Hb.buffer);let Kb=new Float64Array(1),Yb=new Uint8Array(Kb.buffer);function qb(e){return {low:e|=0,high:e>>31,unsigned:e>=0}}let Jb=[];function Xb(){const e=Jb.pop();return e?(e.offset=e.limit=0,e):{bytes:new Uint8Array(64),offset:0,limit:0}}function zb(e){Jb.push(e);}function Qb(e,t){if(e.offset+t>e.limit)throw new Error("Skip past limit");e.offset+=t;}function Zb(e){return e.offset>=e.limit}function $b(e,t){let i=e.bytes,n=e.offset,r=e.limit,o=n+t;if(o>i.length){let t=new Uint8Array(2*o);t.set(i),e.bytes=t;}return e.offset=o,o>r&&(e.limit=o),n}function ew(e,t){let i=e.offset;if(i+t>e.limit)throw new Error("Read past limit");return e.offset+=t,i}function tw(e,t){let i=ew(e,t),n=String.fromCharCode,r=e.bytes,o="�",s="";for(let e=0;e<t;e++){let a,c,d,u,l=r[e+i];0==(128&l)?s+=n(l):192==(224&l)?e+1>=t?s+=o:(a=r[e+i+1],128!=(192&a)?s+=o:(u=(31&l)<<6|63&a,u<128?s+=o:(s+=n(u),e++))):224==(240&l)?e+2>=t?s+=o:(a=r[e+i+1],c=r[e+i+2],32896!=(49344&(a|c<<8))?s+=o:(u=(15&l)<<12|(63&a)<<6|63&c,u<2048||u>=55296&&u<=57343?s+=o:(s+=n(u),e+=2))):240==(248&l)?e+3>=t?s+=o:(a=r[e+i+1],c=r[e+i+2],d=r[e+i+3],8421504!=(12632256&(a|c<<8|d<<16))?s+=o:(u=(7&l)<<18|(63&a)<<12|(63&c)<<6|63&d,u<65536||u>1114111?s+=o:(u-=65536,s+=n(55296+(u>>10),56320+(1023&u)),e+=3))):s+=o;}return s}function iw(e,t){let i=t.length,n=0;for(let e=0;e<i;e++){let r=t.charCodeAt(e);r>=55296&&r<=56319&&e+1<i&&(r=(r<<10)+t.charCodeAt(++e)-56613888),n+=r<128?1:r<2048?2:r<65536?3:4;}dw(e,n);let r=$b(e,n),o=e.bytes;for(let e=0;e<i;e++){let n=t.charCodeAt(e);n>=55296&&n<=56319&&e+1<i&&(n=(n<<10)+t.charCodeAt(++e)-56613888),n<128?o[r++]=n:(n<2048?o[r++]=n>>6&31|192:(n<65536?o[r++]=n>>12&15|224:(o[r++]=n>>18&7|240,o[r++]=n>>12&63|128),o[r++]=n>>6&63|128),o[r++]=63&n|128);}}function nw(e,t){let i=$b(e,t.limit),n=e.bytes,r=t.bytes;for(let e=0,o=t.limit;e<o;e++)n[e+i]=r[e];}function rw(e){return e.bytes[ew(e,1)]}function ow(e,t){let i=$b(e,1);e.bytes[i]=t;}function sw(e){let t=ew(e,8),i=e.bytes;return Yb[0]=i[t++],Yb[1]=i[t++],Yb[2]=i[t++],Yb[3]=i[t++],Yb[4]=i[t++],Yb[5]=i[t++],Yb[6]=i[t++],Yb[7]=i[t++],Kb[0]}function aw(e,t){let i=$b(e,8),n=e.bytes;Kb[0]=t,n[i++]=Yb[0],n[i++]=Yb[1],n[i++]=Yb[2],n[i++]=Yb[3],n[i++]=Yb[4],n[i++]=Yb[5],n[i++]=Yb[6],n[i++]=Yb[7];}function cw(e){let t,i=0,n=0;do{t=rw(e),i<32&&(n|=(127&t)<<i),i+=7;}while(128&t);return n}function dw(e,t){for(t>>>=0;t>=128;)ow(e,127&t|128),t>>>=7;ow(e,t);}function uw(e,t){let i=t.low>>>0,n=(t.low>>>28|t.high<<4)>>>0,r=t.high>>>24,o=0===r?0===n?i<16384?i<128?1:2:i<1<<21?3:4:n<16384?n<128?5:6:n<1<<21?7:8:r<128?9:10,s=$b(e,o),a=e.bytes;switch(o){case 10:a[s+9]=r>>>7&1;case 9:a[s+8]=9!==o?128|r:127&r;case 8:a[s+7]=8!==o?n>>>21|128:n>>>21&127;case 7:a[s+6]=7!==o?n>>>14|128:n>>>14&127;case 6:a[s+5]=6!==o?n>>>7|128:n>>>7&127;case 5:a[s+4]=5!==o?128|n:127&n;case 4:a[s+3]=4!==o?i>>>21|128:i>>>21&127;case 3:a[s+2]=3!==o?i>>>14|128:i>>>14&127;case 2:a[s+1]=2!==o?i>>>7|128:i>>>7&127;case 1:a[s]=1!==o?128|i:127&i;}}const lw=async(e,t,i)=>{const n=function(e){const t=[];for(let i=0;i<e.length;i+=2)t.push(parseInt(e.slice(i,i+2),16));return Uint8Array.from(t)}(function(e){const t="0123456789abcdef";function i(e){let i,n="";for(i=0;i<=3;i++)n+=t.charAt(e>>8*i+4&15)+t.charAt(e>>8*i&15);return n}function n(e,t){const i=(65535&e)+(65535&t);return (e>>16)+(t>>16)+(i>>16)<<16|65535&i}function r(e,t,i,r,o,s){return n(function(e,t){return e<<t|e>>>32-t}(n(n(t,e),n(r,s)),o),i)}function o(e,t,i,n,o,s,a){return r(t&i|~t&n,e,t,o,s,a)}function s(e,t,i,n,o,s,a){return r(t&n|i&~n,e,t,o,s,a)}function a(e,t,i,n,o,s,a){return r(t^i^n,e,t,o,s,a)}function c(e,t,i,n,o,s,a){return r(i^(t|~n),e,t,o,s,a)}const d=function(e){let t;const i=1+(e.length+8>>6),n=new Array(16*i);for(t=0;t<16*i;t++)n[t]=0;for(t=0;t<e.length;t++)n[t>>2]|=e.charCodeAt(t)<<t%4*8;return n[t>>2]|=128<<t%4*8,n[16*i-2]=8*e.length,n}(e);let u,l,h,p,_,E=1732584193,m=-271733879,f=-1732584194,S=271733878;for(u=0;u<d.length;u+=16)l=E,h=m,p=f,_=S,E=o(E,m,f,S,d[u+0],7,-680876936),S=o(S,E,m,f,d[u+1],12,-389564586),f=o(f,S,E,m,d[u+2],17,606105819),m=o(m,f,S,E,d[u+3],22,-1044525330),E=o(E,m,f,S,d[u+4],7,-176418897),S=o(S,E,m,f,d[u+5],12,1200080426),f=o(f,S,E,m,d[u+6],17,-1473231341),m=o(m,f,S,E,d[u+7],22,-45705983),E=o(E,m,f,S,d[u+8],7,1770035416),S=o(S,E,m,f,d[u+9],12,-1958414417),f=o(f,S,E,m,d[u+10],17,-42063),m=o(m,f,S,E,d[u+11],22,-1990404162),E=o(E,m,f,S,d[u+12],7,1804603682),S=o(S,E,m,f,d[u+13],12,-40341101),f=o(f,S,E,m,d[u+14],17,-1502002290),m=o(m,f,S,E,d[u+15],22,1236535329),E=s(E,m,f,S,d[u+1],5,-165796510),S=s(S,E,m,f,d[u+6],9,-1069501632),f=s(f,S,E,m,d[u+11],14,643717713),m=s(m,f,S,E,d[u+0],20,-373897302),E=s(E,m,f,S,d[u+5],5,-701558691),S=s(S,E,m,f,d[u+10],9,38016083),f=s(f,S,E,m,d[u+15],14,-660478335),m=s(m,f,S,E,d[u+4],20,-405537848),E=s(E,m,f,S,d[u+9],5,568446438),S=s(S,E,m,f,d[u+14],9,-1019803690),f=s(f,S,E,m,d[u+3],14,-187363961),m=s(m,f,S,E,d[u+8],20,1163531501),E=s(E,m,f,S,d[u+13],5,-1444681467),S=s(S,E,m,f,d[u+2],9,-51403784),f=s(f,S,E,m,d[u+7],14,1735328473),m=s(m,f,S,E,d[u+12],20,-1926607734),E=a(E,m,f,S,d[u+5],4,-378558),S=a(S,E,m,f,d[u+8],11,-2022574463),f=a(f,S,E,m,d[u+11],16,1839030562),m=a(m,f,S,E,d[u+14],23,-35309556),E=a(E,m,f,S,d[u+1],4,-1530992060),S=a(S,E,m,f,d[u+4],11,1272893353),f=a(f,S,E,m,d[u+7],16,-155497632),m=a(m,f,S,E,d[u+10],23,-1094730640),E=a(E,m,f,S,d[u+13],4,681279174),S=a(S,E,m,f,d[u+0],11,-358537222),f=a(f,S,E,m,d[u+3],16,-722521979),m=a(m,f,S,E,d[u+6],23,76029189),E=a(E,m,f,S,d[u+9],4,-640364487),S=a(S,E,m,f,d[u+12],11,-421815835),f=a(f,S,E,m,d[u+15],16,530742520),m=a(m,f,S,E,d[u+2],23,-995338651),E=c(E,m,f,S,d[u+0],6,-198630844),S=c(S,E,m,f,d[u+7],10,1126891415),f=c(f,S,E,m,d[u+14],15,-1416354905),m=c(m,f,S,E,d[u+5],21,-57434055),E=c(E,m,f,S,d[u+12],6,1700485571),S=c(S,E,m,f,d[u+3],10,-1894986606),f=c(f,S,E,m,d[u+10],15,-1051523),m=c(m,f,S,E,d[u+1],21,-2054922799),E=c(E,m,f,S,d[u+8],6,1873313359),S=c(S,E,m,f,d[u+15],10,-30611744),f=c(f,S,E,m,d[u+6],15,-1560198380),m=c(m,f,S,E,d[u+13],21,1309151649),E=c(E,m,f,S,d[u+4],6,-145523070),S=c(S,E,m,f,d[u+11],10,-1120210379),f=c(f,S,E,m,d[u+2],15,718787259),m=c(m,f,S,E,d[u+9],21,-343485551),E=n(E,l),m=n(m,h),f=n(f,p),S=n(S,_);return i(E)+i(m)+i(f)+i(S)}(""+t+i)).slice(0,16),r=n.slice(0,12),o=await window.crypto.subtle.importKey("raw",n,"AES-GCM",!0,["encrypt"]);return new Uint8Array(await window.crypto.subtle.encrypt({name:"AES-GCM",iv:r},o,e))},hw=async(e,t,i)=>await lw(e.buffer,t,i);function pw(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n);}return i}const _w=new Map([["moderation",1],["supervise",2]]);class Ew extends EE{get connectionState(){return this._connectionState}set connectionState(e){if(this._connectionState===e)return;const t=this._connectionState;this._connectionState=e,this.emit(VS.CONNECTION_STATE_CHANGE,t,e);}get inspectType(){return this._inspectType}set inspectType(e){var t;this._inspectMode=zi(t=e.map(e=>_w.get(e)||0)).call(t,(e,t)=>e+t),this._inspectType=e;}get quality(){return this._quality}set quality(e){this._quality=e>1?1:e<.1?.1:e,this.qualityTimer&&(window.clearTimeout(this.qualityTimer),this.qualityTimer=null),this._quality>=1||(this.qualityTimer=window.setTimeout(()=>{this.quality=this._quality/this.qualityRatio;},6e4));}constructor(e){super(),_p(this,"name","AgoraRTCVideoContentInspect"),_p(this,"_connectionState",US.CONNECTING),_p(this,"_innerConnectionState",void 0),_p(this,"sequence",0),_p(this,"inspectStartTime",void 0),_p(this,"workerManagerConnection",void 0),_p(this,"workerConnection",void 0),_p(this,"workerMessageLengthLimit",void 0),_p(this,"inspectIntervalMinimum",void 0),_p(this,"qualityRatio",void 0),_p(this,"_connectInfo",void 0),_p(this,"_cancelTokenSource",pE.CancelToken.source()),_p(this,"_retryConfig",void 0),_p(this,"wmSequence",0),_p(this,"inspectInterval",void 0),_p(this,"inspectTimer",null),_p(this,"ossFilePrefix",void 0),_p(this,"extraInfo",void 0),_p(this,"_inspectType",void 0),_p(this,"_inspectMode",void 0),_p(this,"_quality",1),_p(this,"qualityTimer",null),_p(this,"_inspectId",void 0),_p(this,"_needWorkUrlOnly",!1),_p(this,"inspectImage",()=>{if(this.connectionState!==US.CONNECTED)throw new SE(fE.OPERATION_ABORTED,"content inspect service connection status is ".concat(this.connectionState));this.inspectTimer&&(window.clearInterval(this.inspectTimer),this.inspectTimer=null),this.inspectTimer=window.setInterval(()=>{this.connectionState===US.CONNECTED?this.requestToInspectImage():OE.debug("[".concat(this._inspectId,"] Inspect State is not connected , "),this.connectionState);},this.inspectInterval<this.inspectIntervalMinimum?this.inspectIntervalMinimum:this.inspectInterval),this.requestToInspectImage();}),this._inspectId=ZI(5,"inspect-"),this.workerMessageLengthLimit=GE("VIDEO_INSPECT_WORKER_MESSAGE_LENGTH_LIMIT"),this.inspectIntervalMinimum=GE("VIDEO_INSPECT_INTERVAL_MINIMUM"),this.qualityRatio=GE("VIDEO_INSPECT_QUALITY_RATIO"),this.inspectInterval=e.interval,this.ossFilePrefix=e.ossFilePrefix,this.extraInfo=e.extraInfo,this.inspectType=e.inspectType,this.inspectStartTime=Number(Date.now()),this.workerManagerConnection=new vC("worker-manager-"+this._inspectId,TE),this.on(VS.STATE_CHANGE,(e,t)=>{this._innerConnectionState=e,OE.debug("[".concat(this._inspectId,"] Inspect operation :").concat(xS[e]," ").concat(t||""));}),this.handleWorkerManagerEvents(),this.workerConnection=new vC("worker-"+this._inspectId,TE),this.handleWorkerEvents();}async init(e,t){this.emit(VS.STATE_CHANGE,xS.CONNECT_AP),this._connectInfo=e;const i=this._cancelTokenSource.token;return this._retryConfig=t,new Sl((n,r)=>{this.on(VS.CONNECTION_STATE_CHANGE,(e,t)=>{t===US.CONNECTED&&n();}),this.requestAP(e,i,t).then(e=>{this.connectWorkerManager(e);}).catch(e=>{r(e);});})}async requestAP(e,t,i){const n=GE("WEBCS_DOMAIN").map(e=>"https://".concat(e,"/api/v1")),r=await function(e,t,i,n){let{appId:r,areaCode:o,cname:s,sid:a,token:c,uid:d}=t;sv++;const u="image_moderation_api",l={service_name:u,json_body:JSON.stringify({appId:r,areaCode:o,cname:s,command:"allocateEdge",requestId:sv,seq:sv,sid:a,token:c,ts:Date.now(),uid:d+""})};let h,p,_=e[0];return RE(async()=>{h=Date.now();const e=await gg(_,{data:l,cancelToken:i,headers:{"X-Packet-Service-Type":"0","X-Packet-URI":"61"},params:{action:"wrtc_gateway"}});if(p=Date.now()-h,0!==e.code){const t=new SE(fE.UNEXPECTED_RESPONSE,"image inspect ap error, code"+e.code,{retry:!0,responseTime:p});throw OE.error(t.toString()),t}const t=JSON.parse(e.json_body);if(200!==t.code){const e=new SE(fE.UNEXPECTED_RESPONSE,"image inspect ap error, code: ".concat(t.code,", reason: ").concat(t.reason),{code:t.code,responseTime:p});throw OE.error(e.toString()),e}if(!t.servers||!Array.isArray(t.servers)||0===t.servers.length){const e=new SE(fE.UNEXPECTED_RESPONSE,"image inspect ap empty server",{code:t.code,responseTime:p});throw OE.error(e.toString()),e}const n=GE("VIDEO_INSPECT_WORKER_MANAGER_HOST"),r=GE("VIDEO_INSPECT_WORKER_MANAGER_PORT");return {addressList:t.servers.map(e=>{let{address:t,wss:i}=e;if(t&&i)return "wss://".concat(t.replace(/\./g,"-"),".").concat(n,":").concat(r||i)}).filter(e=>!!e),workerToken:t.workerToken,vid:t.vid,responseTime:p}},(t,i)=>(Pg.apworkerEvent(a,{success:!0,sc:200,serviceName:u,responseDetail:JSON.stringify(t.addressList),firstSuccess:0===i,responseTime:p,serverIp:e[i%e.length]}),!1),(t,i)=>(Pg.apworkerEvent(a,{success:!1,sc:t.data&&t.data.code||200,serviceName:u,responseTime:p,serverIp:e[i%e.length]}),!!(t.code!==fE.OPERATION_ABORTED&&t.code!==fE.UNEXPECTED_RESPONSE||t.data&&t.data.retry)&&(_=e[(i+1)%e.length],!0)),n)}(n,e,t,i);this.emit(VS.STATE_CHANGE,xS.AP_CONNECTED);const{addressList:o}=r;return this.wmSequence++,o}async connectWorkerManager(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];this._needWorkUrlOnly=t,this.emit(VS.STATE_CHANGE,xS.CONNECT_WORKER_MANAGER),await this.workerManagerConnection.init(e,1e4);}async connectWorker(e){await this.workerConnection.init([e]);}handleWorkerManagerEvents(){this.workerManagerConnection.on(Hf.CONNECTED,async()=>{this.emit(VS.STATE_CHANGE,xS.WORKER_MANAGER_CONNECTED,this.workerManagerConnection.url),this.workerManagerConnection.sendMessage({appId:this._connectInfo.appId,cname:this._connectInfo.cname,uid:this._connectInfo.uid+"",sdkVersion:"4.18.2",sid:this._connectInfo.sid,seq:this.wmSequence,ts:Number(Date.now()),requestId:Math.floor(1e12*Math.random()),allocate:!0,clientRequest:{command:"join"}},!0);}),this.workerManagerConnection.on(Hf.CLOSED,()=>{this._innerConnectionState<xS.GET_WORKER_MANAGER_RESPONSE&&OE.debug("[".concat(this._inspectId,"] Inspect worker manager is closed before connecting worker"));}),this.workerManagerConnection.on(Hf.FAILED,()=>{this._innerConnectionState<xS.GET_WORKER_MANAGER_RESPONSE&&OE.debug("[".concat(this._inspectId,"] Connecting inspect worker manager is failed before connecting worker"));}),this.workerManagerConnection.on(Hf.RECONNECTING,()=>{this._innerConnectionState<xS.GET_WORKER_MANAGER_RESPONSE&&OE.debug("[".concat(this._inspectId,"] Inspect worker manager is reconnecting before connecting worker"));}),this.workerManagerConnection.on(Hf.ON_MESSAGE,async e=>{this.emit(VS.STATE_CHANGE,xS.GET_WORKER_MANAGER_RESPONSE);const t=this.workerManagerConnection.url;this.workerManagerConnection.close();const i=JSON.parse(e.data);if(200!==i.code)throw OE.error("[".concat(this._inspectId,"] Unexpected code ").concat(i.code," from worker manager")),new SE(fE.UNEXPECTED_RESPONSE,"response code of worker is unexpected",i);if(!(i.serverResponse&&i.serverResponse.portWss&&t))throw OE.error("[".concat(this._inspectId,"] Unexpected content from worker manager : ").concat(JSON.stringify(i))),new SE(fE.UNEXPECTED_RESPONSE,"response content of worker is unexpected",i);{const e=GE("VIDEO_INSPECT_WORKER_PORT")||i.serverResponse.portWss,n=t.replace(/:\d+\/?$/,":".concat(e));this.emit(VS.STATE_CHANGE,xS.CONNECT_WORKER,n),this._needWorkUrlOnly?this.emit(VS.REQUEST_NEW_WORKER_URL,n):await this.connectWorker(n);}}),this.workerManagerConnection.on(Hf.WILL_RECONNECT,(e,t)=>{t(e);}),this.workerManagerConnection.on(Hf.REQUEST_NEW_URLS,(e,t)=>{this.requestAP(this._connectInfo,this._cancelTokenSource.token,this._retryConfig).then(e).catch(t);});}handleWorkerEvents(){this.workerConnection.on(Hf.CONNECTED,async()=>{this.emit(VS.STATE_CHANGE,xS.WORKER_CONNECTED,this.workerConnection.url),this.connectionState=US.CONNECTED;}),this.workerConnection.on(Hf.ON_MESSAGE,async e=>{if(e.data instanceof ArrayBuffer){const i=jb(new Uint8Array(e.data));if(GE("SHOW_VIDEO_INSPECT_WORKER_MESSAGE")&&OE.debug("[".concat(this._inspectId,"] Response message for worker of inspect content "),JSON.stringify(i)),200===i.code){if(Array.isArray(this.inspectType)&&1===this.inspectType.length&&"supervise"===this.inspectType[0])return void this.emit(VS.INSPECT_RESULT,void 0,void 0);if(i.data&&i.data.scorePorn&&i.data.scoreSexy&&i.data.scoreNeutral){var t;const e={porn:i.data.scorePorn,sexy:i.data.scoreSexy,neutral:i.data.scoreNeutral},n=zi(t=Object.keys(e)).call(t,(t,i)=>e[t]>e[i]?t:i,"porn"),r=Object.keys(e).find(e=>e===n);this.emit(VS.INSPECT_RESULT,r);}else this.emit(VS.INSPECT_RESULT,void 0,new SE(fE.UNEXPECTED_RESPONSE,i.code+"","There is an unexpected data on message"));}else this.emit(VS.INSPECT_RESULT,void 0,new SE(fE.UNEXPECTED_RESPONSE,i.code+"",i.msg));}else OE.error("[".concat(this._inspectId,"] Unexpected message type from worker")),this.emit(VS.INSPECT_RESULT,void 0,new SE(fE.UNEXPECTED_RESPONSE,"invalid worker message type"));}),this.workerConnection.on(Hf.CLOSED,()=>{this.connectionState=US.CLOSED;}),this.workerConnection.on(Hf.FAILED,()=>{this.connectionState=US.CLOSED;}),this.workerConnection.on(Hf.RECONNECTING,()=>{this.connectionState=this.connectionState===US.CONNECTED?US.RECONNECTING:US.CONNECTING;}),this.workerConnection.on(Hf.WILL_RECONNECT,(e,t)=>{"recover"===e&&t(e),t("tryNext");}),this.workerConnection.on(Hf.REQUEST_NEW_URLS,(e,t)=>{this.workerManagerConnection.close(),this.once(VS.REQUEST_NEW_WORKER_URL,t=>{e([t]);}),this.requestAP(this._connectInfo,this._cancelTokenSource.token,this._retryConfig).then(e=>{this.connectWorkerManager(e,!0);}).catch(e=>{t(e);});});}static intToLong(e){return {low:e|=0,high:e>>31,unsigned:e>=0}}async requestToInspectImage(){this.sequence++;const e=oC(this,VS.CLIENT_LOCAL_VIDEO_TRACK),t={appId:this._connectInfo.appId,cname:this._connectInfo.cname,cid:this._connectInfo.cid,sid:this._connectInfo.sid,uid:this._connectInfo.uid,vid:this._connectInfo.vid};if(e){if(!e.isPlaying)return void this.emit(VS.INSPECT_RESULT,void 0,new SE(fE.INVALID_OPERATION,"Only the track being played can be inspected"));const i=await this.generateRequestData(e,t);this.workerConnection.sendMessage(i,!0,!0);}else this.emit(VS.INSPECT_RESULT,void 0,new SE(fE.INVALID_OPERATION,"Only the track being published can be inspected"));}async generateRequestData(e,t){let{appId:i,cname:n,cid:r,vid:o,sid:s,uid:a}=t;const c=Date.now(),d=await e.getCurrentFrameImage("image/jpeg",this.quality),u=await hw(d,i,n),l=this.sequence+"-"+r+"-"+a+"-"+c+"-"+ZI(12,""),h={appId:i,cid:r,cname:n,deviceId:"",elapse:Ew.intToLong(Number(c-this.inspectStartTime)),fileSize:u.byteLength,jpgEncryption:2,height:d.height,width:d.width,jpg:u,networkType:6,osType:7,requestId:l,sdkVersion:"4.18.2",sequence:this.sequence,sid:s,timestamp:Ew.intToLong(c),uid:a,vid:o,service:this._inspectMode,callbackData:this.extraInfo,ossFilePrefix:this.ossFilePrefix};void 0===this.extraInfo&&delete h.callbackData,void 0===this.ossFilePrefix&&delete h.ossFilePrefix;const p=Vb(h);if(p.byteLength<this.workerMessageLengthLimit){if(GE("SHOW_VIDEO_INSPECT_WORKER_MESSAGE")){const e=function(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?pw(Object(i),!0).forEach((function(t){_p(e,t,i[t]);})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):pw(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t));}));}return e}({},h);delete e.jpg,OE.debug("[".concat(this._inspectId,"] Request message for worker of inspect content "),JSON.stringify(e));}return p}{const t=this.quality*this.qualityRatio;return this.quality=t,await this.generateRequestData(e,{appId:i,cname:n,cid:r,vid:o,sid:s,uid:a})}}close(){this._cancelTokenSource.cancel(),this._cancelTokenSource=pE.CancelToken.source(),this.workerManagerConnection&&this.workerManagerConnection.close(),this.workerConnection&&this.workerConnection.close(),this.inspectTimer&&window.clearInterval(this.inspectTimer),this.inspectTimer=null,this.connectionState=US.CLOSED,this.emit(VS.STATE_CHANGE,xS.CLOSED);}}function mw(e){let t=function(){const e=gw.pop();return e?(e.offset=e.limit=0,e):{bytes:new Uint8Array(64),offset:0,limit:0}}();return function(e,t){let i=e.appId;void 0!==i&&(Dw(t,10),Ow(t,i));let n=e.cid;void 0!==n&&(Dw(t,16),Dw(t,n));let r=e.cname;void 0!==r&&(Dw(t,26),Ow(t,r));let o=e.deviceId;void 0!==o&&(Dw(t,34),Ow(t,o));let s=e.elapse;void 0!==s&&(Dw(t,40),Lw(t,s));let a=e.fileSize;void 0!==a&&(Dw(t,48),Lw(t,Tw(a)));let c=e.height;void 0!==c&&(Dw(t,56),Lw(t,Tw(c)));let d=e.jpg;void 0!==d&&(Dw(t,66),Dw(t,d.length),yw(t,d));let u=e.networkType;void 0!==u&&(Dw(t,72),Lw(t,Tw(u)));let l=e.osType;void 0!==l&&(Dw(t,80),Lw(t,Tw(l)));let h=e.requestId;void 0!==h&&(Dw(t,90),Ow(t,h));let p=e.sdkVersion;void 0!==p&&(Dw(t,98),Ow(t,p));let _=e.sequence;void 0!==_&&(Dw(t,104),Lw(t,Tw(_)));let E=e.sid;void 0!==E&&(Dw(t,114),Ow(t,E));let m=e.timestamp;void 0!==m&&(Dw(t,120),Lw(t,m));let f=e.uid;void 0!==f&&(Dw(t,128),Dw(t,f));let S=e.vid;void 0!==S&&(Dw(t,136),Dw(t,S));let T=e.width;void 0!==T&&(Dw(t,144),Lw(t,Tw(T)));let g=e.service;void 0!==g&&(Dw(t,152),Dw(t,g));let R=e.callbackData;void 0!==R&&(Dw(t,162),Dw(t,R.length),yw(t,R));let I=e.ticket;void 0!==I&&(Dw(t,170),Ow(t,I));}(e,t),function(e){let t=e.bytes,i=e.limit;return t.length===i?t:t.subarray(0,i)}(t)}function fw(e){return function(e){let t={};e:for(;!Iw(e);){let i=ww(e);switch(i>>>3){case 0:break e;case 1:t.code=ww(e);break;case 2:t.msg=Aw(e,ww(e));break;case 3:t.requestId=Aw(e,ww(e));break;case 4:t.timestamp=Pw(e,!1);break;default:Sw(e,7&i);}}return t}({bytes:t=e,offset:0,limit:t.length});var t;}function Sw(e,t){switch(t){case 0:for(;128&Nw(e););break;case 2:Rw(e,ww(e));break;case 5:Rw(e,4);break;case 1:Rw(e,8);break;default:throw new Error("Unimplemented type: "+t)}}function Tw(e){return {low:e|=0,high:e>>31,unsigned:e>=0}}let gw=[];function Rw(e,t){if(e.offset+t>e.limit)throw new Error("Skip past limit");e.offset+=t;}function Iw(e){return e.offset>=e.limit}function Cw(e,t){let i=e.bytes,n=e.offset,r=e.limit,o=n+t;if(o>i.length){let t=new Uint8Array(2*o);t.set(i),e.bytes=t;}return e.offset=o,o>r&&(e.limit=o),n}function vw(e,t){let i=e.offset;if(i+t>e.limit)throw new Error("Read past limit");return e.offset+=t,i}function yw(e,t){let i=Cw(e,t.length);e.bytes.set(t,i);}function Aw(e,t){let i=vw(e,t),n=String.fromCharCode,r=e.bytes,o="�",s="";for(let e=0;e<t;e++){let a,c,d,u,l=r[e+i];0==(128&l)?s+=n(l):192==(224&l)?e+1>=t?s+=o:(a=r[e+i+1],128!=(192&a)?s+=o:(u=(31&l)<<6|63&a,u<128?s+=o:(s+=n(u),e++))):224==(240&l)?e+2>=t?s+=o:(a=r[e+i+1],c=r[e+i+2],32896!=(49344&(a|c<<8))?s+=o:(u=(15&l)<<12|(63&a)<<6|63&c,u<2048||u>=55296&&u<=57343?s+=o:(s+=n(u),e+=2))):240==(248&l)?e+3>=t?s+=o:(a=r[e+i+1],c=r[e+i+2],d=r[e+i+3],8421504!=(12632256&(a|c<<8|d<<16))?s+=o:(u=(7&l)<<18|(63&a)<<12|(63&c)<<6|63&d,u<65536||u>1114111?s+=o:(u-=65536,s+=n(55296+(u>>10),56320+(1023&u)),e+=3))):s+=o;}return s}function Ow(e,t){let i=t.length,n=0;for(let e=0;e<i;e++){let r=t.charCodeAt(e);r>=55296&&r<=56319&&e+1<i&&(r=(r<<10)+t.charCodeAt(++e)-56613888),n+=r<128?1:r<2048?2:r<65536?3:4;}Dw(e,n);let r=Cw(e,n),o=e.bytes;for(let e=0;e<i;e++){let n=t.charCodeAt(e);n>=55296&&n<=56319&&e+1<i&&(n=(n<<10)+t.charCodeAt(++e)-56613888),n<128?o[r++]=n:(n<2048?o[r++]=n>>6&31|192:(n<65536?o[r++]=n>>12&15|224:(o[r++]=n>>18&7|240,o[r++]=n>>12&63|128),o[r++]=n>>6&63|128),o[r++]=63&n|128);}}function Nw(e){return e.bytes[vw(e,1)]}function bw(e,t){let i=Cw(e,1);e.bytes[i]=t;}function ww(e){let t,i=0,n=0;do{t=Nw(e),i<32&&(n|=(127&t)<<i),i+=7;}while(128&t);return n}function Dw(e,t){for(t>>>=0;t>=128;)bw(e,127&t|128),t>>>=7;bw(e,t);}function Pw(e,t){let i,n=0,r=0,o=0;return i=Nw(e),n=127&i,128&i&&(i=Nw(e),n|=(127&i)<<7,128&i&&(i=Nw(e),n|=(127&i)<<14,128&i&&(i=Nw(e),n|=(127&i)<<21,128&i&&(i=Nw(e),r=127&i,128&i&&(i=Nw(e),r|=(127&i)<<7,128&i&&(i=Nw(e),r|=(127&i)<<14,128&i&&(i=Nw(e),r|=(127&i)<<21,128&i&&(i=Nw(e),o=127&i,128&i&&(i=Nw(e),o|=(127&i)<<7))))))))),{low:n|r<<28,high:r>>>4|o<<24,unsigned:t}}function Lw(e,t){let i=t.low>>>0,n=(t.low>>>28|t.high<<4)>>>0,r=t.high>>>24,o=0===r?0===n?i<16384?i<128?1:2:i<1<<21?3:4:n<16384?n<128?5:6:n<1<<21?7:8:r<128?9:10,s=Cw(e,o),a=e.bytes;switch(o){case 10:a[s+9]=r>>>7&1;case 9:a[s+8]=9!==o?128|r:127&r;case 8:a[s+7]=8!==o?n>>>21|128:n>>>21&127;case 7:a[s+6]=7!==o?n>>>14|128:n>>>14&127;case 6:a[s+5]=6!==o?n>>>7|128:n>>>7&127;case 5:a[s+4]=5!==o?128|n:127&n;case 4:a[s+3]=4!==o?i>>>21|128:i>>>21&127;case 3:a[s+2]=3!==o?i>>>14|128:i>>>14&127;case 2:a[s+1]=2!==o?i>>>7|128:i>>>7&127;case 1:a[s]=1!==o?128|i:127&i;}}const kw={},Mw={},Uw=4294967296,xw=0x10000000000000000,Vw=xw/2,jw=Hw(0,!0),Fw=Hw(0),Bw=Kw(0,-2147483648,!1),Gw=Kw(-1,2147483647,!1),Ww=Kw(-1,-1,!0);function Hw(e,t){let i,n,r;return t?(r=0<=(e>>>=0)&&e<256)&&(n=Mw[e],n)?n:(i=Kw(e,0,!0),r&&(Mw[e]=i),i):(r=-128<=(e|=0)&&e<128)&&(n=kw[e],n)?n:(i=Kw(e,e<0?-1:0,!1),r&&(kw[e]=i),i)}function Kw(e,t,i){return {low:0|e,high:0|t,unsigned:!!i}}function Yw(e,t){if(isNaN(e))return t?jw:Fw;if(t){if(e<0)return jw;if(e>=xw)return Ww}else {if(e<=-Vw)return Bw;if(e+1>=Vw)return Gw}return e<0?t?jw:Fw:Kw(e%Uw|0,e/Uw|0,t)}function qw(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n);}return i}class Jw extends EE{get connectionState(){return this._connectionState}set connectionState(e){if(this._connectionState===e)return;const t=this._connectionState;this._connectionState=e,this.emit(HS.CONNECTION_STATE_CHANGE,e,t);}get quality(){return this._quality}set quality(e){this._quality=e>1?1:e<.1?.1:e,this._qualityTimer&&(window.clearTimeout(this._qualityTimer),this._qualityTimer=null),this._quality>=1||(this._qualityTimer=window.setTimeout(()=>{this.quality=this._quality/this._qualityRatio;},6e4));}constructor(e){var t;super(),_p(this,"name","AgoraRTCImageModeration"),_p(this,"_connectionState",WS.CONNECTING),_p(this,"_sequence",0),_p(this,"_moderationStartTime",void 0),_p(this,"_workerConnection",void 0),_p(this,"_workerMessageLengthLimit",void 0),_p(this,"_qualityRatio",void 0),_p(this,"_connectInfo",void 0),_p(this,"_cancelTokenSource",pE.CancelToken.source()),_p(this,"_retryConfig",void 0),_p(this,"_moderationInterval",void 0),_p(this,"_moderationTimer",null),_p(this,"_moderationMode",1),_p(this,"_quality",1),_p(this,"_qualityTimer",null),_p(this,"_ticket",void 0),_p(this,"_moderationIntervalMinimum",void 0),_p(this,"_uploadFailedNum",0),_p(this,"_uploadNum",0),_p(this,"_uploadTimer",null),_p(this,"_moderationId",void 0),_p(this,"inspectImage",()=>{if(this.connectionState!==WS.CONNECTED)throw new SE(fE.OPERATION_ABORTED,"image moderation service connection status is ".concat(this.connectionState));this._moderationTimer&&(window.clearInterval(this._moderationTimer),this._moderationTimer=null),this._moderationTimer=window.setInterval(()=>{this.connectionState===WS.CONNECTED?this.requestToInspectImage():OE.debug("[".concat(this._moderationId,"] Moderation State is not connected , "),this.connectionState);},this._moderationInterval<this._moderationIntervalMinimum?this._moderationIntervalMinimum:this._moderationInterval),this.requestToInspectImage();}),this._moderationId=ZI(5,"image-moderation-"),this._workerMessageLengthLimit=GE("IMAGE_MODERATION_WORKER_MESSAGE_LENGTH_LIMIT"),this._moderationIntervalMinimum=GE("IMAGE_MODERATION_INTERVAL_MINIMUM"),this._moderationInterval=null!==(t=e.interval)&&void 0!==t?t:1e3,this._qualityRatio=GE("IMAGE_MODERATION_QUALITY_RATIO"),this._moderationStartTime=Number(Date.now()),this._workerConnection=new vC("worker-"+this._moderationId,TE),this.on(HS.STATE_CHANGE,(e,t)=>{OE.debug("[".concat(this._moderationId,"] Moderation operation :").concat(KS[e]," ").concat(t||""));}),this.handleWorkerEvents();}async init(e,t){this.emit(HS.STATE_CHANGE,KS.CONNECT_AP),this._connectInfo=e;const i=this._cancelTokenSource.token;return this._retryConfig=t,new Sl((n,r)=>{this.on(HS.CONNECTION_STATE_CHANGE,(e,t)=>{e===WS.CONNECTED&&n();}),this.requestAP(e,i,t).then(e=>{this.connectWorker(e);}).catch(e=>{r(e);});})}updateConfig(e){var t;this._moderationInterval=null!==(t=e.interval)&&void 0!==t?t:1e3,OE.debug("[".concat(this._moderationId,"] updateConfig: ").concat(JSON.stringify(e))),this.connectionState===WS.CONNECTED&&this.inspectImage();}async requestAP(e,t,i){const n=GE("WEBCS_DOMAIN").map(e=>"https://".concat(e,"/api/v1")),r=await function(e,t,i,n){let{appId:r,areaCode:o,cname:s,sid:a,token:c,uid:d}=t;sv++;const u="moderation_plugin",l={service_name:u,json_body:JSON.stringify({appId:r,areaCode:o,cname:s,command:"allocateEdge",requestId:sv,seq:sv,sid:a,appToken:c,ts:Date.now(),uid:d+""})};let h,p,_=e[0];return RE(async()=>{h=Date.now();const e=await gg(_,{data:l,cancelToken:i,headers:{"X-Packet-Service-Type":"0","X-Packet-URI":"61"},params:{action:"wrtc_gateway"}});if(p=Date.now()-h,0!==e.code){const t=new SE(fE.UNEXPECTED_RESPONSE,"moderation plugin ap error, code"+e.code,{retry:!0,responseTime:p});throw OE.error(t.toString()),t}const t=JSON.parse(e.json_body);if(200!==t.code){const e=new SE(fE.UNEXPECTED_RESPONSE,"moderation plugin ap error, code: ".concat(t.code,", reason: ").concat(t.reason),{code:t.code,responseTime:p});throw OE.error(e.toString()),e}if(!t.servers||!Array.isArray(t.servers)||0===t.servers.length){const e=new SE(fE.UNEXPECTED_RESPONSE,"moderation plugin ap empty server",{code:t.code,responseTime:p});throw OE.error(e.toString()),e}if(!t.servers.some(e=>!!e.wss)){const e=new SE(fE.UNEXPECTED_RESPONSE,"moderation plugin ap empty port",{code:t.code,responseTime:p});throw OE.error(e.toString()),e}const n=GE("IMAGE_MODERATION_WORKER_HOST");return {addressList:t.servers.map(e=>{let{address:t,wss:i}=e;if(t&&i)return "wss://".concat(t.replace(/\./g,"-"),".").concat(n,":").concat(i,"/moderation")}).filter(e=>!!e),workerToken:t.workerToken,vid:t.vid,ticket:t.appTicket,responseTime:p}},(t,i)=>(Pg.apworkerEvent(a,{success:!0,sc:200,serviceName:u,responseDetail:JSON.stringify(t.addressList),firstSuccess:0===i,responseTime:p,serverIp:e[i%e.length]}),!1),(t,i)=>(Pg.apworkerEvent(a,{success:!1,sc:t.data&&t.data.code||200,serviceName:u,responseTime:p,serverIp:e[i%e.length]}),!!(t.code!==fE.OPERATION_ABORTED&&t.code!==fE.UNEXPECTED_RESPONSE||t.data&&t.data.retry)&&(_=e[(i+1)%e.length],!0)),n)}(n,e,t,i);this.emit(HS.STATE_CHANGE,KS.AP_CONNECTED);const{addressList:o,ticket:s}=r;return this._ticket=s,o}async connectWorker(e){this.emit(HS.STATE_CHANGE,KS.CONNECT_WORKER),await this._workerConnection.init(e,1e4);}handleWorkerEvents(){this._workerConnection.on(Hf.CONNECTED,async()=>{this.emit(HS.STATE_CHANGE,KS.WORKER_CONNECTED,this._workerConnection.url),this.connectionState=WS.CONNECTED;}),this._workerConnection.on(Hf.CLOSED,()=>{this.connectionState=WS.CLOSED;}),this._workerConnection.on(Hf.FAILED,()=>{this.connectionState=WS.CLOSED;}),this._workerConnection.on(Hf.RECONNECTING,()=>{this.connectionState=this.connectionState===WS.CONNECTED?WS.RECONNECTING:WS.CONNECTING;}),this._workerConnection.on(Hf.ON_MESSAGE,async e=>{if(e.data instanceof ArrayBuffer){const t=fw(new Uint8Array(e.data));GE("SHOW_IMAGE_MODERATION_WORKER_MESSAGE")&&OE.debug("[".concat(this._moderationId,"] Response message for worker of image moderation "),JSON.stringify(t)),this._uploadNum++,void 0===t.code||0===t.code||(this._uploadFailedNum++,OE.error("[".concat(this._moderationId,"] Error response from worke, code is ").concat(t.code,", msg is ").concat(t.msg)),this._uploadTimer||(this._uploadTimer=window.setTimeout(()=>{Pg.reportApiInvoke(this._connectInfo.sid||null,{name:_f.IMAGE_MODERATION_UPLOAD,options:[this._uploadFailedNum,this._uploadNum,t.code],tag:Ef.TRACER}).onError(new SE(fE.IMAGE_MODERATION_UPLOAD_FAILED,t.msg)),this._uploadTimer=null;},GE("IMAGE_MODERATION_UPLOAD_REPORT_INTERVAL"))));}else OE.error("[".concat(this._moderationId,"] Unexpected message type from worker"));}),this._workerConnection.on(Hf.WILL_RECONNECT,(e,t)=>{"recover"===e&&t(e),t("tryNext");}),this._workerConnection.on(Hf.REQUEST_NEW_URLS,(e,t)=>{this.requestAP(this._connectInfo,this._cancelTokenSource.token,this._retryConfig).then(e).catch(t);});}static intToLong(e){return {low:e|=0,high:e>>31,unsigned:e>=0}}async requestToInspectImage(){const e=oC(this,HS.CLIENT_LOCAL_VIDEO_TRACK),t={appId:this._connectInfo.appId,cname:this._connectInfo.cname,cid:this._connectInfo.cid,sid:this._connectInfo.sid,uid:this._connectInfo.uid,vid:this._connectInfo.vid};if(e){if(!e.isPlaying)return void(GE("SHOW_IMAGE_MODERATION_WORKER_MESSAGE")&&OE.debug("Only the track being played can be inspected"));this._sequence++;const i=await this.generateRequestData(e,t);this._workerConnection.sendMessage(i,!0,!0);}else GE("SHOW_IMAGE_MODERATION_WORKER_MESSAGE")&&OE.debug("Only the track being published can be inspected");}async generateRequestData(e,t){let{appId:i,cname:n,cid:r,vid:o,sid:s,uid:a}=t;const c=Date.now(),d=await e.getCurrentFrameImage("image/jpeg",this.quality),u=await hw(d,i,n),l=this._sequence+"-"+r+"-"+a+"-"+c+"-"+ZI(12,""),h={appId:i,cid:r,cname:n,deviceId:"",elapse:Jw.intToLong(Number(c-this._moderationStartTime)),fileSize:d.buffer.byteLength,height:d.height,width:d.width,jpg:u,networkType:6,osType:7,requestId:l,sdkVersion:"4.18.2",sequence:this._sequence,sid:s,timestamp:Yw(c),uid:a,vid:o,service:this._moderationMode,ticket:this._ticket},p=mw(h);if(p.byteLength<this._workerMessageLengthLimit){if(GE("SHOW_IMAGE_MODERATION_WORKER_MESSAGE")){const e=function(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?qw(Object(i),!0).forEach((function(t){_p(e,t,i[t]);})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):qw(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t));}));}return e}({},h);delete e.jpg,OE.debug("[".concat(this._moderationId,"] Request message for worker of image moderation service: "),JSON.stringify(e));}return p}{const t=this.quality*this._qualityRatio;return this.quality=t,await this.generateRequestData(e,{appId:i,cname:n,cid:r,vid:o,sid:s,uid:a})}}close(){this._cancelTokenSource.cancel(),this._cancelTokenSource=pE.CancelToken.source(),this._workerConnection&&this._workerConnection.close(),this._moderationTimer&&window.clearInterval(this._moderationTimer),this._moderationTimer=null,this._uploadTimer&&window.clearTimeout(this._uploadTimer),this._uploadTimer=null,this.connectionState=WS.CLOSED,this.emit(HS.STATE_CHANGE,KS.CLOSED);}}var Xw,zw,Qw,Zw,$w,eD,tD,iD,nD,rD,oD,sD,aD,cD,dD,uD,lD,hD,pD,_D,ED,mD,fD,SD,TD,gD,RD,ID,CD,vD,yD,AD,OD,ND,bD,wD,DD,PD,LD,kD;function MD(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n);}return i}function UD(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?MD(Object(i),!0).forEach((function(t){_p(e,t,i[t]);})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):MD(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t));}));}return e}let xD=(Xw=Dg(),zw=Dg({argsMap:(e,t)=>(Array.isArray(t)||(t=[t]),t.map(e=>e?Object(e).toString():"null"))}),Qw=Dg({argsMap:(e,t)=>(t||(t=[]),Array.isArray(t)||(t=[t]),t.map(e=>e.getTrackId()))}),Zw=Dg({argsMap:(e,t,i)=>[t.uid,i]}),$w=Dg({argsMap:(e,t)=>t.map(e=>{let{user:t,mediaType:i}=e;return [null==t?void 0:t.uid,i]})}),eD=Dg({argsMap:(e,t,i)=>[t.uid,i]}),tD=Dg({argsMap:(e,t)=>t.map(e=>{let{user:t,mediaType:i}=e;return {uid:null==t?void 0:t.uid,mediaType:i}})}),iD=Dg(),nD=Dg(),rD=Dg(),oD=Dg(),sD=Dg(),aD=Dg(),cD=Dg(),dD=Dg(),uD=Dg(),lD=Dg(),hD=Dg(),pD=Dg(),_D=Dg(),ED=Dg(),mD=Dg({argsMap:(e,t)=>[t]}),fD=Dg(),SD=Dg(),TD=Dg(),gD=Dg(),RD=Dg(),ID=Dg(),CD=Dg(),vD=Dg(),yD=Dg(),AD=Dg(),OD=Dg({argsMap:(e,t)=>(Array.isArray(t)||(t=[t]),[JSON.stringify(t)])}),ND=Dg(),bD=Dg(),wD=Dg(),DD=Dg(),PD=Dg({reportResult:!0}),LD=Dg(),ag((kD=class extends EE{get connectionState(){return this._gateway.state}get remoteUsers(){return this._users}get localTracks(){return this._p2pChannel.getAllTracks(!0)}get uid(){return this._uid}get channelName(){return this._channelName}get mode(){return this._config.mode}get role(){var e;return (null===(e=this._config)||void 0===e?void 0:e.role)||"audience"}get codec(){return this._config.codec}get audioCodec(){return this._config.audioCodec||"opus"}get isStringUID(){return !!this._joinInfo&&!!this._joinInfo.stringUid}get __className__(){return "Client"}constructor(e){let t;if(super(),_p(this,"store",void 0),_p(this,"_uid",void 0),_p(this,"_channelName",void 0),_p(this,"_uintUid",void 0),_p(this,"_users",[]),_p(this,"_config",void 0),_p(this,"_clientId",void 0),_p(this,"_appId",void 0),_p(this,"_sessionId",null),_p(this,"_key",void 0),_p(this,"_joinInfo",void 0),_p(this,"_gateway",void 0),_p(this,"_statsCollector",void 0),_p(this,"_configDistribute",void 0),_p(this,"_leaveMutex",new Ug("client-leave")),_p(this,"_publishMutex",new Ug("client-publish")),_p(this,"_renewTokenMutex",new Ug("client-renewtoken")),_p(this,"_subscribeMutex",new Ug("client-subscribe")),_p(this,"_encryptionMode","none"),_p(this,"_encryptionSecret",null),_p(this,"_encryptionSalt",null),_p(this,"_proxyServer",void 0),_p(this,"_turnServer",{servers:[],mode:"auto"}),_p(this,"_cloudProxyServerMode","disabled"),_p(this,"_isDualStreamEnabled",!1),_p(this,"_defaultStreamFallbackType",void 0),_p(this,"_lowStreamParameter",void 0),_p(this,"_streamFallbackTypeCacheMap",new Map),_p(this,"_remoteStreamTypeCacheMap",new Map),_p(this,"_axiosCancelSource",pE.CancelToken.source()),_p(this,"_audioVolumeIndicationInterval",void 0),_p(this,"_networkQualityInterval",void 0),_p(this,"_userOfflineTimeout",void 0),_p(this,"_streamRemovedTimeout",void 0),_p(this,"_injectStreamingClient",void 0),_p(this,"_liveTranscodeStreamingClient",void 0),_p(this,"_liveRawStreamingClient",void 0),_p(this,"_channelMediaRelayClient",void 0),_p(this,"_networkQualitySensitivity","normal"),_p(this,"_p2pChannel",void 0),_p(this,"_useLocalAccessPoint",!1),_p(this,"_setLocalAPVersion",void 0),_p(this,"_joinAndNotLeaveYet",!1),_p(this,"_numberOfJoinCount",0),_p(this,"_remoteDefaultVideoStreamType",void 0),_p(this,"_inspect",void 0),_p(this,"_moderation",void 0),_p(this,"_license",void 0),_p(this,"_handleLocalTrackEnable",(e,t,i)=>{this.publish(e,!1).then(t).catch(i);}),_p(this,"_handleLocalTrackDisable",(e,t,i)=>{this.unpublish(e).then(t).catch(i);}),_p(this,"_handleUserOnline",e=>{if(GE("BLOCK_LOCAL_CLIENT")&&ZE(e.uid,this.channelName))return void OE.debug("[".concat(e.uid,"] will be ignored in local"));this.isStringUID&&"string"!=typeof e.uid&&OE.error("[".concat(this._clientId,"] StringUID is Mixed with UintUID"));const t=this._users.find(t=>t.uid===e.uid);if(t)t._trust_in_room_=!0;else {const t=new yy(e.uid,e.uint_id||e.uid);this._users.push(t),OE.debug("[".concat(this._clientId,"] user online"),e.uid),this.safeEmit(yf.USER_JOINED,t);}}),_p(this,"_handleUserOffline",e=>{if(GE("BLOCK_LOCAL_CLIENT")&&ZE(e.uid,this.channelName))return;const t=this._users.find(t=>t.uid===e.uid);t&&(this._handleRemoveStream(e),aC(this._users,t),this._remoteStreamTypeCacheMap.delete(t.uid),this._streamFallbackTypeCacheMap.delete(t.uid),OE.debug("[".concat(this._clientId,"] user offline"),e.uid,"reason:",e.reason),this.safeEmit(yf.USER_LEAVED,t,e.reason));}),_p(this,"_handleAddAudioOrVideoStream",(e,t,i,n,r,o,s)=>{if(GE("BLOCK_LOCAL_CLIENT")&&ZE(t,this.channelName))return;const a=this._users.find(e=>e.uid===t);if(!a)return void OE.error("[".concat(this._clientId,"] can not find target user!(on_add_stream)"));OE.debug("[".concat(this._clientId,"] stream added with uid ").concat(t,", type ").concat(e)),this.store.subscribe(a.uid,e,void 0,void 0,void 0,Date.now());const c="audio"===e?a.hasAudio:a.hasVideo;a._uintid||(a._uintid=r||t),"audio"===e?a._trust_audio_stream_added_state_=!0:a._trust_video_stream_added_state_=!0,"audio"===e?(a._audio_added_=!0,void 0!==i&&(a._audioSSRC=i),void 0!==n&&(a._cname=n),o&&(a._audioOrtc=o)):(a._video_added_=!0,void 0!==i&&(a._videoSSRC=i),void 0!==n&&(a._cname=n),void 0!==s&&(a._rtxSsrcId=s),o&&(a._videoOrtc=o)),("audio"===e?a.hasAudio:a.hasVideo)&&!c&&(OE.info("[".concat(this._clientId,"] remote user ").concat(a.uid," published ").concat(e)),this.safeEmit(yf.USER_PUBLISHED,a,e)),"video"===e?Pg.onGatewayStream(this._sessionId,uf.ON_ADD_VIDEO_STREAM,lf.ON_ADD_VIDEO_STREAM,{peer:r||t}):Pg.onGatewayStream(this._sessionId,uf.ON_ADD_AUDIO_STREAM,lf.ON_ADD_AUDIO_STREAM,{peer:r||t}),this._p2pChannel.remoteMediaSsrcChanged(a,e,i).then(t=>{if(t)return OE.debug("[".concat(this._clientId,"] resubscribe ").concat(e," for user ").concat(a.uid," after rejoin because SSRC id changed.")),this._p2pChannel.unsubscribe(a,e,!0).then(()=>this._subscribe(a,e,!0).catch(e=>{OE.error("[".concat(this._clientId,"] resubscribe error"),e.toString());}))}),this._p2pChannel.hasPendingRemoteMedia(a,e)&&(OE.debug("[".concat(this._clientId,"] resubscribe ").concat(e," for user ").concat(a.uid," after reconnect.")),this._subscribe(a,e,!0).catch(e=>{OE.error("[".concat(this._clientId,"] resubscribe error"),e.toString());}));}),_p(this,"_handleRemoveStream",e=>{if(GE("BLOCK_LOCAL_CLIENT")&&ZE(e.uid,this.channelName))return;const t=this._users.find(t=>t.uid===e.uid);if(!t)return void OE.warning("[".concat(this._clientId,"] can not find target user!(on_remove_stream)"));OE.debug("[".concat(this._clientId,"] stream removed with uid ").concat(e.uid));let i=()=>{};t.hasAudio&&t.hasVideo?i=()=>{OE.info("[".concat(this._clientId,"] remote user ").concat(t.uid," unpublished audio track")),this.safeEmit(yf.USER_UNPUBLISHED,t,"audio"),OE.info("[".concat(this._clientId,"] remote user ").concat(t.uid," unpublished video track")),this.safeEmit(yf.USER_UNPUBLISHED,t,"video");}:t.hasVideo?i=()=>{OE.info("[".concat(this._clientId,"] remote user ").concat(t.uid," unpublished video track")),this.safeEmit(yf.USER_UNPUBLISHED,t,"video");}:t.hasAudio&&(i=()=>{OE.info("[".concat(this._clientId,"] remote user ").concat(t.uid," unpublished audio track")),this.safeEmit(yf.USER_UNPUBLISHED,t,"audio");}),t._trust_audio_stream_added_state_=!0,t._trust_video_stream_added_state_=!0,t._audio_added_=!1,t._video_added_=!1,this._p2pChannel.unsubscribe(t).then(e=>{if(e)return this._gateway.unsubscribe(e,t.uid)}),t._audioSSRC=void 0,t._videoSSRC=void 0,t._audioOrtc=void 0,t._videoOrtc=void 0,t._rtxSsrcId=void 0,Pg.onGatewayStream(this._sessionId,uf.ON_REMOVE_STREAM,lf.ON_REMOVE_STREAM,{peer:e.uint_id||e.uid}),i();}),_p(this,"_handleSetStreamLocalEnable",(e,t,i)=>{if(GE("BLOCK_LOCAL_CLIENT")&&ZE(t,this.channelName))return;const n=this._users.find(e=>e.uid===t);if(!n)return void OE.error("[".concat(this._clientId,"] can not find target user!(disable_local)"));OE.debug("[".concat(this._clientId,"] local ").concat(e," ").concat(i?"enabled":"disabled"," with uid ").concat(t));const r="audio"===e?n.hasAudio:n.hasVideo;if("audio"===e){n._trust_audio_enabled_state_=!0;const e=n._audio_enabled_;if(n._audio_enabled_=i,n._audio_enabled_===e)return;{const e=n._audio_enabled_?"enable-local-audio":"disable-local-audio";OE.debug("[".concat(this._clientId,"] user-info-updated, uid: ").concat(t,", msg: ").concat(e)),this.safeEmit(yf.USER_INFO_UPDATED,t,e);}}else {n._trust_video_enabled_state_=!0;const e=n._video_enabled_;if(n._video_enabled_=i,n._video_enabled_===e)return;{const e=n._video_enabled_?"enable-local-video":"disable-local-video";OE.debug("[".concat(this._clientId,"] user-info-update, uid: ").concat(t,", msg: ").concat(e)),this.safeEmit(yf.USER_INFO_UPDATED,t,e);}}const o="audio"===e?n.hasAudio:n.hasVideo;return r!==o?!r&&o?(OE.info("[".concat(this._clientId,"] remote user ").concat(t," published ").concat(e)),void this.safeEmit(yf.USER_PUBLISHED,n,e)):("video"===e&&n._videoTrack&&n._videoTrack._destroy(),"audio"===e&&n._audioTrack,this._p2pChannel.muteRemote(n,e),OE.info("[".concat(this._clientId,"] remote user ").concat(t," unpublished ").concat(e)),void this.safeEmit(yf.USER_UNPUBLISHED,n,e)):void 0}),_p(this,"_handleMuteStream",(e,t,i)=>{if(GE("BLOCK_LOCAL_CLIENT")&&ZE(e,this.channelName))return;OE.debug("[".concat(this._clientId,"] receive mute message"),e,t,i);const n=this._users.find(t=>t.uid===e);if(!n)return void OE.warning("[".concat(this._clientId,"] can not find remote user, ignore mute event, uid: ").concat(e));const r="audio"===t?n.hasAudio:n.hasVideo;if("audio"===t){n._trust_audio_mute_state_=!0;const t=n._audio_muted_;if(n._audio_muted_=i,n._audio_muted_===t)return;{const t=n._audio_muted_?"mute-audio":"unmute-audio";OE.debug("[".concat(this._clientId,"] user-info-update, uid: ").concat(e,", msg: ").concat(t)),this.safeEmit(yf.USER_INFO_UPDATED,e,t);}}else {n._trust_video_mute_state_=!0;const t=n._video_muted_;if(n._video_muted_=i,n._video_muted_===t)return;{const t=n._video_muted_?"mute-video":"unmute-video";OE.debug("[".concat(this._clientId,"] user-info-update, uid: ").concat(e,", msg: ").concat(t)),this.safeEmit(yf.USER_INFO_UPDATED,e,t);}}const o="audio"===t?n.hasAudio:n.hasVideo;if(r!==o){if(!r&&o){return ("audio"===t?n._audioSSRC:n._videoSSRC)?(OE.info("[".concat(this._clientId,"] remote user ").concat(e," published ").concat(t)),void this.safeEmit(yf.USER_PUBLISHED,n,t)):void OE.warning("[".concat(this._clientId,"] remote user ").concat(e," receive ").concat(t," unmute message  before add stream message, ").concat(t," SSRC doesn't exist yet."))}"video"===t&&n._videoTrack&&n._videoTrack._destroy(),"audio"===t&&n._audioTrack,this._p2pChannel.muteRemote(n,t),OE.info("[".concat(this._clientId,"] remote user ").concat(e," unpublished ").concat(t)),this.safeEmit(yf.USER_UNPUBLISHED,n,t);}}),_p(this,"_handleP2PLost",async e=>{OE.debug("[".concat(this._clientId,"] receive p2p lost"),e),parseInt(e.p2pid,10)===this.store.p2pId?await this._p2pChannel.requestReconnect():OE.warning("[".concat(this._clientId,"] P2PLost stream not found"),e);}),_p(this,"_handleTokenWillExpire",()=>{OE.debug("[".concat(this._clientId,"] received message onTokenPrivilegeWillExpire")),this.safeEmit(yf.ON_TOKEN_PRIVILEGE_WILL_EXPIRE);}),_p(this,"_handleBeforeUnload",e=>{"beforeunload"===e.type&&void 0!==e.returnValue&&""!==e.returnValue||(this.leave(),OE.info("[".concat(this._clientId,"] auto leave onbeforeunload or pagehide")));}),_p(this,"_handleUpdateNetworkQuality",()=>{if("normal"===this._networkQualitySensitivity)return;if(navigator&&void 0!==navigator.onLine&&!navigator.onLine)return void this.safeEmit(yf.NETWORK_QUALITY,{downlinkNetworkQuality:6,uplinkNetworkQuality:6});const e={downlinkNetworkQuality:0,uplinkNetworkQuality:0};e.uplinkNetworkQuality=this._p2pChannel.getUplinkNetworkQuality(),e.downlinkNetworkQuality=this._p2pChannel.getDownlinkNetworkQuality(),this.safeEmit(yf.NETWORK_QUALITY,e);}),this._config=e,this._clientId=ZI(5,"client-"),this.store=new kb(e.codec,e.audioCodec,e.mode,this._clientId),this.store.clientCreated(),e.proxyServer&&this.setProxyServer(e.proxyServer,!0),e.turnServer&&this.setTurnServer(e.turnServer,!0),OE.info("[".concat(this._clientId,"] Initializing AgoraRTC client v").concat(bE," build: ").concat(NE,", mode: ").concat(this.mode,", codec: ").concat(this.codec)),e.clientRoleOptions)try{Vf(e.clientRoleOptions),t=Object.assign({},e.clientRoleOptions);}catch(e){OE.warning("[".concat(this._clientId,"] ").concat(e.toString()));}this._statsCollector=new kI(this.store),this._statsCollector.onStatsException=(e,t,i)=>{OE.debug("[".concat(this._clientId,"] receive exception msg, code: ").concat(e,", msg: ").concat(t,", uid: ").concat(i)),this.safeEmit(yf.EXCEPTION,{code:e,msg:t,uid:i});},this._statsCollector.onUploadPublishDuration=(e,t,i,n)=>{const r=this._users.find(t=>t.uid===e);r&&Pg.peerPublishStatus(this._sessionId,{subscribeElapse:n,audioPublishDuration:t,videoPublishDuration:i,peer:r._uintid});},this.store.useDataChannel=JS().supportDataChannel&&GE("SIGNAL_CHANNEL"),this._gateway=new VC(this.store,{clientId:this._clientId,mode:this.mode,codec:this.codec,websocketRetryConfig:e.websocketRetryConfig||TE,httpRetryConfig:e.httpRetryConfig||TE,forceWaitGatewayResponse:void 0===e.forceWaitGatewayResponse||e.forceWaitGatewayResponse,statsCollector:this._statsCollector,role:e.role,clientRoleOptions:t}),this._configDistribute=new fv,this._p2pChannel=new bb(this.store,this._statsCollector),this._handleP2PChannelEvents(),this._handleGatewayEvents(),this._handleGatewaySignalEvents();}async join(e,t,i,n,r){const o=++this._numberOfJoinCount;this.store.joinStart(),n&&(this.store.uid=n);const s=Ub(),a=xb()?window.isSecureContext:"Browser Not Support";if(!xb()&&!s||!window.isSecureContext){const e="The website must be running in a secure context (About secure context: https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts ), otherwise the media collection will be restricted by the browser";OE.warning(e);}const c=$I();"DISCONNECTED"===this.connectionState&&(this.store.avoidJoinStart=Math.round(Date.now()),OE.debug("[".concat(this._clientId,"] set avoidJoinStart to ").concat(this.store.avoidJoinStart)));const d=Pg.reportApiInvoke(c,{name:_f.JOIN,options:[e,t,i,n],states:{isHttps:s,isSecureContext:a},tag:Ef.TRACER});Pg.setAppId(e);try{if(!i&&null!==i)throw new SE(fE.INVALID_PARAMS,"Invalid token: ".concat(i,". If you don not use token, set it to null"));i&&Xm(i,"token",1,2047),Xm(e,"appid",1,2047),Qm(t),n&&Zm(n),r&&Xm(r,"optionalInfo",1,2047);}catch(e){throw d.onError(e),e}if(OE.info("[".concat(this._clientId,"] start join channel ").concat(t,", join number: ").concat(o)),this._leaveMutex.isLocked){OE.debug("[".concat(this._clientId,"] join: waiting leave operation"));(await this._leaveMutex.lock())(),OE.debug("[".concat(this._clientId,"] join: continue"));}if(this._joinAndNotLeaveYet=!0,"DISCONNECTED"!==this.connectionState){const e=new SE(fE.INVALID_OPERATION,"[".concat(this._clientId,"] Client already in connecting/connected state"));throw d.onError(e),e}this._sessionId||(this._sessionId=c,this.store.sessionId=this._sessionId),this._gateway.state="CONNECTING";const u=UD({clientId:this._clientId,appId:e,sid:this._sessionId,cname:t,uid:"string"!=typeof n?n:null,turnServer:this._turnServer,proxyServer:this._proxyServer,token:i||e,cloudProxyServer:this._cloudProxyServerMode,optionalInfo:r,license:this._license,useLocalAccessPoint:this._useLocalAccessPoint},void 0!==this._remoteDefaultVideoStreamType&&{defaultVideoStream:this._remoteDefaultVideoStreamType});if(this._useLocalAccessPoint&&(u.setLocalAPVersion=this._setLocalAPVersion),"string"==typeof n&&(u.stringUid=n,this._uintUid?(u.uid=this._uintUid,this._uintUid=void 0):u.uid=0),"none"!==this._encryptionMode&&this._encryptionSecret){if(u.aesmode=this._encryptionMode,u.aespassword=await(async e=>{const t=pC("MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDCMnXAHkKIGAM+x4N22gCI+Wyu\nSTM9ztkT3uYslTT2PuKmZfPzhH6kVdO7PTjGCOZnAsyb3oTtWat0KcxQ4jxvqQV+\nHvYl3iI1Yd4vl2c3qRMJPLtRDfNxa2Mcxgq7e9aEUibzdd0st+OJAy3tOj/Y0aVy\nxQiYDz3vqa6bP29adwIDAQAB"),i=await window.crypto.subtle.importKey("spki",t,{name:"RSA-OAEP",hash:"SHA-256"},!0,["encrypt"]),n=Ag(e),r=await window.crypto.subtle.encrypt({name:"RSA-OAEP"},i,n);return _C(new Uint8Array(r))})(this._encryptionSecret),!this._joinAndNotLeaveYet)throw new SE(fE.INVALID_OPERATION,"[".concat(this._clientId,"] Client already left"));this._encryptionSalt&&(u.aessalt=this._encryptionSalt);}this._startSession(this._sessionId,{channel:t,appId:e});const l=this._sessionId;setTimeout(()=>{"CONNECTING"===this.connectionState&&l===this._sessionId&&Pg.joinChannelTimeout(this._sessionId,5);},5e3);try{let n;const r=u.cloudProxyServer;if(["proxy3","proxy4","proxy5"].includes(r)){const e=GE("PROXY_SERVER_TYPE3");Array.isArray(e)?u.proxyServer=e[0]:u.proxyServer=e;}if(Pg.setProxyServer(u.proxyServer),OE.setProxyServer(u.proxyServer),this.store.requestAPStart(),u.stringUid&&!u.uid){const e=await dv(u.stringUid,u,this._axiosCancelSource.token,this._config.httpRetryConfig||TE,this.store);OE.debug("[".concat(this._clientId,"] getUserAccount Success ").concat(u.stringUid," => ").concat(e)),u.uid=e,n=await cv(u,this._axiosCancelSource.token,this._config.httpRetryConfig||TE,!0,this.store);}else n=await cv(u,this._axiosCancelSource.token,this._config.httpRetryConfig||TE,!0,this.store);if(!this._joinAndNotLeaveYet)throw new SE(fE.INVALID_OPERATION,"[".concat(this._clientId,"] Client already left"));this.store.requestAPEnd(),setTimeout(()=>{this._configDistribute.startGetConfigDistribute(u,this._axiosCancelSource.token),this._configDistribute.on(vS.UPDATE_BITRATE_LIMIT,e=>{this._p2pChannel.updateBitrateLimit(e);});},0),this._key=i||e;const o=n.gatewayInfo;this._joinInfo=UD(UD({},u),{},{cid:o.cid,uid:u.uid?u.uid:o.uid,vid:o.vid,apResponse:o.res,uni_lbs_ip:o.uni_lbs_ip,gatewayAddrs:o.gatewayAddrs});const s=await this._joinGateway();if(!this._joinAndNotLeaveYet)throw new SE(fE.INVALID_OPERATION,"[".concat(this._clientId,"] Client already left"));d.onSuccess(s),this._appId=e,this._channelName=u.cname,this._uid=s,this.store.uid=s,setTimeout(()=>{this._networkQualityInterval&&window.clearInterval(this._networkQualityInterval),this._networkQualityInterval=window.setInterval(this._handleUpdateNetworkQuality,2e3),window.addEventListener(Hh()?"beforeunload":"pagehide",this._handleBeforeUnload);},0);const a=u.stringUid?"string uid: ".concat(u.stringUid,",uid: ").concat(u.uid):"uid: ".concat(this._uid);return OE.info("[".concat(this._clientId,"] Joining channel success: channel: ").concat(t,",").concat(a)),setTimeout(()=>{OE.startUpload();},5e3),this.store.joinEnd(),h=this,zE.includes(h)||zE.push(h),s}catch(e){const t=Array.isArray(e)?e[0]:e;throw t&&t.code===fE.OPERATION_ABORTED?OE.warning("[".concat(this._clientId,"] join number: ").concat(o,", Joining channel failed, rollback"),t):OE.error("[".concat(this._clientId,"] join number: ").concat(o,", Joining channel failed, rollback"),t),t.code!==fE.OPERATION_ABORTED&&this._numberOfJoinCount===o&&(this._gateway.state="DISCONNECTED",this._reset()),d.onError(t),t}var h;}_joinGateway(){if(!this._joinInfo||!this._key)throw new SE(fE.INVALID_OPERATION);return this._gateway.join(this._joinInfo,this._key,!("disabled"!==this._joinInfo.cloudProxyServer||this._joinInfo.proxyServer||!GE("JOIN_WITH_FALLBACK_SIGNAL_PROXY"))).then(e=>e).catch(e=>{if(e.code===fE.INIT_WEBSOCKET_TIMEOUT)return this._gateway.leave(!0,vf.FALLBACK),e;if(e.code===fE.INIT_DATACHANNEL_TIMEOUT)return this._gateway.leave(!0,vf.FALLBACK),e;throw e}).then(e=>{if(e instanceof SE){if(e.code===fE.INIT_WEBSOCKET_TIMEOUT){if(OE.info("[".concat(this._clientId,"] join timeout, fallback to proxy")),!this._joinInfo||!this._key)throw new SE(fE.INVALID_OPERATION);this._joinInfo.cloudProxyServer="fallback",this._cloudProxyServerMode="fallback",this.store.cloudProxyServerMode="fallback";const e=GE("PROXY_SERVER_TYPE3");if(Array.isArray(e))if(this._joinInfo.apUrl){const t=/^https?:\/\/(.+?)(\/.*)?$/.exec(this._joinInfo.apUrl)[1].split("."),i=t.slice(t.length-2).join(".");e.forEach(e=>{this._joinInfo&&e.includes(i)&&(this._joinInfo.proxyServer=e);}),this._joinInfo.proxyServer||(this._joinInfo.proxyServer=e[0]);}else this._joinInfo.proxyServer=e[0];else this._joinInfo.proxyServer=e;const t=GE("LOG_UPLOAD_SERVER").match(/.+:(\d{1,5})$/);t&&t[1]&&"443"!==t[1]&&OE.setProxyServer(this._joinInfo.proxyServer),"443"!==GE("STATS_COLLECTOR_PORT").toString()&&Pg.setProxyServer(this._joinInfo.proxyServer);return Pg.reportApiInvoke(this._sessionId,{name:_f.JOIN_FALLBACK_TO_PROXY,options:[this._joinInfo.proxyServer],tag:Ef.TRACER}).onSuccess(),this.safeEmit(yf.JOIN_FALLBACK_TO_PROXY,this._joinInfo.proxyServer),GE("JOIN_WITH_FALLBACK_MEDIA_PROXY_FORCE")&&this._joinInfo.turnServer.servers.forEach(e=>{"forceturn"in e&&(e.forceturn=!0);}),this._gateway.join(this._joinInfo,this._key)}if(OE.info("[".concat(this._clientId,"] join by datachannel timeout, fallback to websocket")),!this._joinInfo||!this._key)throw new SE(fE.INVALID_OPERATION);return Pg.reportApiInvoke(this._sessionId,{name:_f.DATACHANNEL_FAILBACK,options:[this.store.clientId],tag:Ef.TRACER}).onSuccess(),this._joinGateway()}return e}).then(e=>e)}async leave(){OE.info("[".concat(this._clientId,"] Leaving channel")),window.removeEventListener(Hh()?"beforeunload":"pagehide",this._handleBeforeUnload),this._reset(),function(e){const t=zE.indexOf(e);-1!==t&&zE.splice(t,1);}(this);const e=await this._leaveMutex.lock();if("DISCONNECTED"===this.connectionState)return OE.info("[".concat(this._clientId,"] Leaving channel repeated, success")),void e();await this._gateway.leave("CONNECTED"!==this.connectionState),OE.info("[".concat(this._clientId,"] Leaving channel success")),this._joinAndNotLeaveYet=!1,this.store.resetJoinChannelServiceRecords(),e();}async publish(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];if(Array.isArray(e)||(e=[e]),0===e.length)throw new SE(fE.INVALID_PARAMS,"track list is empty");if("audience"===this._gateway.role)throw new SE(fE.INVALID_OPERATION,"audience can not publish stream");for(const i of e){if(!(i instanceof Vg))throw new SE(fE.INVALID_PARAMS,"parameter is not local track");if(!i._enabled&&t)throw new SE(fE.TRACK_IS_DISABLED,"can not publish a disabled track: ".concat(i.getTrackId()))}OE.info("[".concat(this._clientId,"] Publishing tracks, id ").concat(e.map(e=>"".concat(e.getTrackId()," "))));const i=await this._publishMutex.lock();await this._configDistribute.awaitConfigDistributeComplete(),t&&e.forEach(e=>{const t=this._configDistribute.getBitrateLimit();e instanceof Cy&&t&&e.setBitrateLimit(t.uplink);});try{await this._publishHighStream(e),OE.info("[".concat(this._clientId,"] Publish success, id ").concat(e.map(e=>"".concat(e.getTrackId()," "))));}catch(e){throw OE.error("[".concat(this._clientId,"] publish error"),e.toString()),e}finally{i();}}async unpublish(e){if(!this._joinInfo||void 0===this._uid)throw new SE(fE.INVALID_OPERATION,"Can't unpublish stream, haven't joined yet!");e?Array.isArray(e)||(e=[e]):e=this._p2pChannel.getAllTracks(!0),OE.info("[".concat(this._clientId,"] Unpublish tracks, tracks ").concat(e.map(e=>"".concat(e.getTrackId()," "))," "));const t=await this._publishMutex.lock();try{const i=await this._p2pChannel.unpublish(e);i&&await this._gateway.unpublish(i,this._uid),OE.info("[".concat(this._clientId,"] Unpublish success,tracks ").concat(e.map(e=>"".concat(e.getTrackId()))));}catch(e){throw OE.error("[".concat(this._clientId,"] unpublish error"),e.toString()),e}finally{t&&t();}}async subscribe(e,t){return this._subscribe(e,t)}async _subscribe(e,t,i){if(Ym(t,"mediaType",["audio","video"]),!this._joinInfo)throw new SE(fE.INVALID_OPERATION,"Can't subscribe stream, not joined");if("CONNECTED"!==this.connectionState&&"RECONNECTING"!==this.connectionState)throw new SE(fE.INVALID_OPERATION,"Can't subscribe stream in ".concat(this.connectionState," state"));if(!this._users.find(t=>t===e)){const t=new SE(fE.INVALID_REMOTE_USER,"user is not in the channel");throw OE.error("[".concat(this._clientId,"] can not subscribe ").concat(e.uid,", this user is not in the channel")),t}if(!e.hasAudio&&!e.hasVideo){const t=new SE(fE.INVALID_REMOTE_USER,"user is not published");throw OE.error("[".concat(this._clientId,"] can not subscribe ").concat(e.uid,", user is not published")),t}if(!(i||("audio"!==t||e.hasAudio&&void 0!==e._audioSSRC)&&("video"!==t||e.hasVideo&&void 0!==e._videoSSRC))){const i=new SE(fE.REMOTE_USER_IS_NOT_PUBLISHED);throw OE.error("[".concat(this._clientId,"] can not subscribe ").concat(e.uid," with mediaType ").concat(t,", remote track is not published")),i}const n="audio"===t?e._audioSSRC:e._videoSSRC,r="audio"===t?e._audioOrtc:e._videoOrtc,o="video"===t?e._rtxSsrcId:void 0,s={stream_type:"audio"===t?AS.AUDIO:AS.VIDEO,ssrcId:n},a=await this._subscribeMutex.lock();OE.info("[".concat(this._clientId,"] subscribe user ").concat(e.uid,", mediaType: ").concat(t));try{if(await this._p2pChannel.hasRemoteMediaWithLock(e,t))await this._p2pChannel.unmuteRemote(e,t);else try{DI.markSubscribeStart(this.store.clientId,n),this.store.subscribe(e.uid,t,Date.now()),await this._p2pChannel.subscribe(e,t,n,o,r);try{await this._gateway.subscribe(e.uid,s,!0);}catch(i){if((null==i?void 0:i.code)!==fE.WS_ABORT)throw await this._p2pChannel.unsubscribe(e,t),i;await this._p2pChannel.unsubscribe(e,t,!0),this._p2pChannel.setPendingRemoteMedia(e,t);}this.store.subscribe(e.uid,t,void 0,Date.now()),this._p2pChannel.reportSubscribeEvent(!0,null,e,t);}catch(i){throw this._p2pChannel.reportSubscribeEvent(!1,null==i?void 0:i.code,e,t),i}OE.info("[".concat(this._clientId,"] subscribe success user ").concat(e.uid,", mediaType: ").concat(t)),this._defaultStreamFallbackType&&this.setStreamFallbackOption(e.uid,this._defaultStreamFallbackType).catch(e=>{OE.warning("[".concat(this._clientId,"] auto set fallback failed"),e);});const i="audio"===t?e._audioTrack:e._videoTrack;if(!i)throw new SE(fE.UNEXPECTED_ERROR,"can not find remote track in user object");return i}catch(t){throw OE.error("[".concat(this._clientId,"] subscribe user ").concat(e.uid," error"),t),t}finally{a();}}async massSubscribe(e){if(zm(e,"subscribeList"),!this._joinInfo)throw new SE(fE.INVALID_OPERATION,"Can't subscribe stream, not joined");if("CONNECTED"!==this.connectionState&&"RECONNECTING"!==this.connectionState)throw new SE(fE.INVALID_OPERATION,"Can't subscribe stream in ".concat(this.connectionState," state"));const t=Date.now(),i=new Map,n=await this._subscribeMutex.lock();OE.info("[".concat(this._clientId,"]start massSubscribe user ").concat(e.map(e=>{let{user:t,mediaType:i}=e;return "user: ".concat(null==t?void 0:t.uid,", mediaType: ").concat(i)}).join("; ")));const r=(e=[...e]).map(e=>{let{user:t,mediaType:i}=e;return {user:t,mediaType:i}}),o=await this._p2pChannel.globalLock();try{var s;for(let t=e.length-1;t>=0;t--){const n=e[t],{user:o,mediaType:s}=n;if(Ym(s,"mediaType",["audio","video"]),!o){const e=new SE(fE.INVALID_PARAMS,"user property does not exist in subscribeList item");throw OE.error("[".concat(this._clientId,"] user property does not exist in subscribeList item")),e}if(!this._users.find(e=>e===o)){const i=new SE(fE.INVALID_REMOTE_USER,"user is not in the channel");OE.error("[".concat(this._clientId,"] can not massSubscribe ").concat(o.uid,", this user is not in the channel")),r[t].error=i,e.splice(t,1);continue}if("audio"===s&&(!o.hasAudio||void 0===o._audioSSRC)||"video"===s&&(!o.hasVideo||void 0===o._videoSSRC)){const i=new SE(fE.REMOTE_USER_IS_NOT_PUBLISHED);OE.error("[".concat(this._clientId,"] can not subscribe ").concat(o.uid," with mediaType ").concat(s,", remote user is not published")),r[t].error=i,e.splice(t,1);continue}const a=cS.Video|cS.LwoVideo,c=i.get(o);if(c){if("video"===s?c&a:c&cS.Audio){e.splice(t,1),OE.warning("[".concat(this._clientId,"] repeat massSubscribe user:").concat(o.uid,", mediaType:").concat(s," twice"));continue}i.set(o,c|("video"===s?a:cS.Audio));}else i.set(o,"video"===s?a:cS.Audio);}for(let t=e.length-1;t>=0;t--){const n=e[t],{user:r,mediaType:o}=n,s=cS.Video|cS.LwoVideo;if(this._p2pChannel.hasRemoteMedia(r,o)){await this._p2pChannel.unmuteRemoteNoLock(r,o);const n=i.get(r);i.set(r,"video"===o?n^s:n^cS.Audio),e.splice(t,1);}}this.store.massSubscribe(e.map(e=>({userId:e.user.uid,type:e.mediaType})),t);const a=zi(s=Array.from(i.entries())).call(s,(e,t)=>{let[i,n]=t;if(0===n)return e;const r={stream_id:i.uid,stream_type:n};return n&cS.Audio&&(r.audio_ssrc=i._audioSSRC),n&cS.Video&&(r.video_ssrc=i._videoSSRC),e.push(r),e},[]);try{e.length>0&&await this._p2pChannel.massSubscribeNoLock(e.map(e=>{let{user:t,mediaType:i}=e;return {user:t,mediaType:i,ssrcId:i===AS.VIDEO?t._videoSSRC:t._audioSSRC,rtxSsrcId:i===AS.VIDEO?t._rtxSsrcId:void 0}}));const i=new Map;if(a.length>0){const e=await this._gateway.subscribeAll(a,!0);((null==e?void 0:e.users)||[]).forEach(e=>{let{stream_id:t,video_error_code:n,audio_error_code:r,error_code:o}=e;(n||r||o)&&i.set(t,{video_error_code:n,audio_error_code:r,error_code:o});});}if(Array.from(i.entries()).length>0){const e=Array.from(i.entries()).map(e=>{let t,[i,n]=e;n.error_code||n.video_error_code&&n.audio_error_code?t=void 0:n.video_error_code?t=AS.VIDEO:n.audio_error_code&&(t=AS.AUDIO);return {user:this.remoteUsers.find(e=>e.uid===i),mediaType:t}});await this._p2pChannel.massUnsubscribeNoLock(e);}for(const e of r){const t=i.get(e.user.uid);if(t){const i=t.error_code||"audio"===e.mediaType&&t.audio_error_code||"video"===e.mediaType&&t.video_error_code;if(i){const t=IC(i);OE.error("user:".concat(e.user.uid," mediaType:").concat(e.mediaType," has massSubscribe error ").concat(t.desc)),e.error=new SE(fE.SUBSCRIBE_FAILED,"code ".concat(i,": ").concat(t.desc));}}e.error||("video"===e.mediaType?e.track=e.user.videoTrack:e.track=e.user.audioTrack);}return this.store.massSubscribe(r.filter(e=>!e.error).map(e=>({userId:e.user.uid,type:e.mediaType})),void 0,Date.now()),r.forEach(e=>{var i;Pg.subscribe(this.store.sessionId,{succ:!!e.error,ec:(null===(i=e.error)||void 0===i?void 0:i.code)||null,video:e.mediaType===AS.VIDEO,audio:e.mediaType===AS.AUDIO,peerid:e.user.uid,subscribeRequestid:e.mediaType===AS.VIDEO?e.user._videoSSRC:e.user._audioSSRC,p2pid:this.store.p2pId,eventElapse:Math.floor(performance.now()-t)},!0);}),OE.info("[".concat(this._clientId,"] massSubscribe success ").concat(e.map(e=>{let{user:t,mediaType:i}=e;return "user: ".concat(null==t?void 0:t.uid,", mediaType: ").concat(i)}).join("; "))),r}catch(t){throw await this._p2pChannel.massUnsubscribeNoLock(e),t}}finally{o(),n();}}async unsubscribe(e,t){if(t&&Ym(t,"mediaType",["audio","video"]),!this._joinInfo)throw new SE(fE.INVALID_OPERATION,"Can't unsubscribe stream, haven't joined yet!");if(!this._users.find(t=>t===e)){const t=new SE(fE.INVALID_REMOTE_USER,"user is not in the channel");throw OE.error("[".concat(this._clientId,"] can not unsubscribe ").concat(e.uid,", user is not in the channel")),t}OE.info("[".concat(this._clientId,"] unsubscribe uid: ").concat(e.uid,", mediaType: ").concat(t));const i=await this._subscribeMutex.lock();try{const n=await this._p2pChannel.unsubscribe(e,t);n&&await this._gateway.unsubscribe(n,e.uid),OE.info("[".concat(this._clientId,"] unsubscribe success uid: ").concat(e.uid,", mediaType: ").concat(t));}catch(t){if(t.code===fE.DISCONNECT_P2P)return void OE.warning("disconnecting p2p, abort unsubscribe request.");throw OE.error("[".concat(this._clientId,"] unsubscribe user ").concat(e.uid," error"),t.toString()),t}finally{i();}}async massUnsubscribe(e){if(zm(e,"unsubscribeList"),!this._joinInfo)throw new SE(fE.INVALID_OPERATION,"Can't unsubscribeAll stream, haven't joined yet!");OE.info("[".concat(this._clientId,"] start massUnsubscribe ").concat(e.map(e=>{let{user:t,mediaType:i}=e;return "user: ".concat(null==t?void 0:t.uid,", mediaType: ").concat(i,";")}).join())),e=[...e];const t=new Map;for(let i=e.length-1;i>=0;i--){const{user:n,mediaType:r}=e[i];if(!n){const e=new SE(fE.INVALID_PARAMS,"user property does not exist in unsubscribeList item");throw OE.error("[".concat(this._clientId,"] user property does not exist in unsubscribeList item")),e}Ym(r,"mediaType",["video","audio",void 0]);if(!this._users.find(e=>e===n)){OE.warning("[".concat(this._clientId,"] can not unsubscribe ").concat(n.uid,", user is not in the channel")),e.splice(i,1);continue}const o=cS.Video|cS.LwoVideo;if(t.has(n)){const s=t.get(n);let a;switch(r){case"video":a=s&o;break;case"audio":a=s&cS.Audio;break;default:a=s&(cS.Audio|o);}if(a){OE.warning("[".concat(this._clientId,"] repeat massUnsubscribe user:").concat(n.uid,",mediaType:").concat(r," twice.")),e.splice(i,1);continue}r?"audio"===r?t.set(n,s|cS.Audio):"video"===r&&t.set(n,s|o):t.set(n,s|cS.Audio|o);}else r?"audio"===r?t.set(n,cS.Audio):"video"===r&&t.set(n,o):t.set(n,cS.Audio|o);}try{const t=await this._p2pChannel.massUnsubscribe(e);t&&await this._gateway.massUnsubscribe(t),OE.info("[".concat(this._clientId,"] massUnsubscribe success ").concat(e.map(e=>{let{user:t,mediaType:i}=e;return "user: ".concat(null==t?void 0:t.uid,", mediaType: ").concat(i,";")}).join()));}catch(e){if(e.code===fE.DISCONNECT_P2P)return void OE.warning("[".concat(this._clientId,"] disconnecting p2p, abort unsubscribe request."));throw OE.error("[".concat(this._clientId,"] massUnsubscribe error"),e.toString()),e}}setLowStreamParameter(e){!function(e){if(!e)throw new SE(fE.INVALID_PARAMS);$m(e.width)||Jm(e.width,"streamParameter.width"),$m(e.height)||Jm(e.height,"streamParameter.height"),$m(e.framerate)||Jm(e.framerate,"streamParameter.framerate"),$m(e.bitrate)||qm(e.bitrate,"streamParameter.bitrate");}(e),(!e.width&&e.height||e.width&&!e.height)&&OE.warning("[".concat(this._clientId,"] The width and height parameters take effect only when both are set")),OE.info("[".concat(this._clientId,"] set low stream parameter to"),JSON.stringify(e));const t=this._configDistribute.getLowStreamConfigDistribute();t&&t.bitrate&&e.bitrate&&t.bitrate<e.bitrate&&(e.bitrate=t.bitrate),this._lowStreamParameter=e;}async enableDualStream(){if(!JS().supportDualStream)throw Pg.streamSwitch(this._sessionId,{lts:Date.now(),isdual:!0,succ:!1}),new SE(fE.NOT_SUPPORTED,"Your browser is not support dual stream");if(this._isDualStreamEnabled)throw new SE(fE.INVALID_OPERATION,"Dual stream is already enabled");if(this._p2pChannel.canPublishLowStream())try{await this._publishLowStream();}catch(e){throw Pg.streamSwitch(this._sessionId,{lts:Date.now(),isdual:!0,succ:!1}),e}this._isDualStreamEnabled=!0,Pg.streamSwitch(this._sessionId,{lts:Date.now(),isdual:!0,succ:!0}),OE.info("[".concat(this._clientId,"] enable dual stream"));}async disableDualStream(){if(this._isDualStreamEnabled){if(!this._joinInfo)throw new SE(fE.INVALID_OPERATION,"Can't publish stream, haven't joined yet!");if(this._p2pChannel.getLocalMedia(bS.LocalVideoLowTrack))try{const e=await this._p2pChannel.unpublishLowStream();e&&await this._gateway.unpublish(e,this._joinInfo.stringUid||this._joinInfo.uid);}catch(e){throw Pg.streamSwitch(this._sessionId,{lts:Date.now(),isdual:!1,succ:!1}),e}this._isDualStreamEnabled=!1,Pg.streamSwitch(this._sessionId,{lts:Date.now(),isdual:!1,succ:!0}),OE.info("[".concat(this._clientId,"] disable dual stream"));}}async setClientRole(e,t){if(function(e){Ym(e,"role",["audience","host"]);}(e),t&&Vf(t),"rtc"===this.mode)throw OE.warning("[".concat(this._clientId,"]rtc mode can not use setClientRole")),new SE(fE.INVALID_OPERATION,"rtc mode can not use setClientRole");if(t&&t.level&&"host"===e)throw new SE(fE.INVALID_OPERATION,"host mode can not set audience latency level");if("audience"===e&&this._p2pChannel.hasLocalMedia())throw new SE(fE.INVALID_OPERATION,"can not set client role to audience when publishing stream");await this._gateway.setClientRole(e,t),this._config.role=e,OE.info("[".concat(this._clientId,"] set client role to ").concat(e,", level: ").concat(t&&t.level));}setProxyServer(e,t){if(Xm(e,"proxyServer"),!t){if("DISCONNECTED"!==this.connectionState)throw new SE(fE.INVALID_OPERATION,"Set proxy server before join channel");if("disabled"!==this._cloudProxyServerMode||this._useLocalAccessPoint)throw new SE(fE.INVALID_OPERATION,"You have already set the proxy")}this._proxyServer=e,Pg.setProxyServer(this._proxyServer),OE.setProxyServer(this._proxyServer),OE.info("[".concat(this._clientId,"] Set proxy server ").concat(t?"by initialize call":""," success."));}setTurnServer(e,t){if(Array.isArray(e)||(e=[e]),!t){if("DISCONNECTED"!==this.connectionState)throw new SE(fE.INVALID_OPERATION,"Set turn server before join channel");if("disabled"!==this._cloudProxyServerMode||this._useLocalAccessPoint)throw new SE(fE.INVALID_OPERATION,"You have already set the proxy")}if(Uf(e))return this._turnServer={servers:e,mode:"original-manual"},void OE.info("[".concat(this._clientId,"] Set original turnserver ").concat(t?"by initialize call":""," success: ").concat(e.map(e=>e.urls).join(","),"."));e.forEach(e=>xf(e)),this._turnServer={servers:e,mode:"manual"},OE.info("[".concat(this._clientId,"] Set turnserver ").concat(t?"by initialize call":""," success."));}setLicense(e){if("DISCONNECTED"!==this.connectionState){throw new SE(fE.INVALID_OPERATION,"you should set license before join channel")}if(Xm(e,"license",32,32),!/^[A-Za-z\d]+$/.test(e))throw new SE(fE.INVALID_PARAMS,"license should only contains characters from A-Z a-z 0-9");this._license=e,OE.info("[".concat(this._clientId,"] set license success"),e);}startProxyServer(e){if("DISCONNECTED"!==this.connectionState)throw new SE(fE.INVALID_OPERATION,"Start proxy server before join channel");if(this._proxyServer||"manual"===this._turnServer.mode||this._useLocalAccessPoint)throw new SE(fE.INVALID_OPERATION,"You have already set the proxy");const t=[3,4,5];let i;switch(void 0===e&&(e=3),e){case 1:case 2:throw new SE(fE.NOT_SUPPORTED,"proxy mode 1/2 has been deprecated and not supported.");case 3:i="proxy3";break;case 4:i="proxy4";break;case 5:i="proxy5";break;default:throw new SE(fE.INVALID_PARAMS,"proxy server mode must be ".concat(t.join("|")))}this._cloudProxyServerMode=i,this.store.cloudProxyServerMode=i,OE.info("[".concat(this._clientId,"] set cloud proxy server mode to"),this._cloudProxyServerMode);}stopProxyServer(){if("DISCONNECTED"!==this.connectionState)throw new SE(fE.INVALID_OPERATION,"Stop proxy server after leave channel");Pg.setProxyServer(),OE.setProxyServer(),this._cloudProxyServerMode="disabled",this.store.cloudProxyServerMode="disabled",OE.info("[".concat(this._clientId,"] set cloud proxy server mode to"),this._cloudProxyServerMode),this._proxyServer=void 0,this._turnServer={mode:"auto",servers:[]};}setLocalAccessPointsV2(e){if(!e.accessPoints)throw new SE(fE.INVALID_PARAMS,"accessPoints is required.");zm(e.accessPoints.serverList,"accessPoints.serverList"),Xm(e.accessPoints.domain,"accessPoints.domain");const t=(e,t)=>{qm(e,t,0,65535,!0);};let i=443;if(e.accessPoints.port&&(t(e.accessPoints.port,"accessPoints.port"),i=e.accessPoints.port),this._proxyServer||"disabled"!==this._cloudProxyServerMode)throw new SE(fE.INVALID_OPERATION,"set local access point failed, You have already set the cloud proxy");GE("CLOSE_AFB_FOR_LOCAL_AP")&&(BE("JOIN_WITH_FALLBACK_SIGNAL_PROXY",!1),BE("JOIN_WITH_FALLBACK_MEDIA_PROXY",!1));const n=/^((\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.){3}(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])$/,r=e.accessPoints.domain,o=e.accessPoints.serverList.map(e=>n.test(e)?"".concat(e.replace(/\./g,"-"),".").concat(r):e),s=o.map(e=>"".concat(e,":").concat(i));this._useLocalAccessPoint=!0,this._setLocalAPVersion=2,BE("WEBCS_DOMAIN",s),BE("WEBCS_DOMAIN_BACKUP_LIST",s),BE("GATEWAY_DOMAINS",[r]),e.report&&e.report.hostname&&Array.isArray(e.report.hostname)&&e.report.hostname.length?(zm(e.report.hostname,"report.hostname"),BE("EVENT_REPORT_DOMAIN",e.report.hostname[0]),BE("EVENT_REPORT_BACKUP_DOMAIN",e.report.hostname[1]||e.report.hostname[0])):(BE("EVENT_REPORT_DOMAIN",o[0]),BE("EVENT_REPORT_BACKUP_DOMAIN",o[1]||o[0]));let a=6443;e.report&&e.report.port&&(t(e.report.port,"report.port"),a=e.report.port),BE("STATS_COLLECTOR_PORT",a),e.report?BE("ENABLE_EVENT_REPORT",!0):BE("ENABLE_EVENT_REPORT",!1);let c="";e.log&&e.log.hostname&&Array.isArray(e.log.hostname)&&e.log.hostname.length?(zm(e.log.hostname,"log.hostname"),c=e.log.hostname[0]):c=o[0];let d=6444;e.log&&e.log.port&&(t(e.log.port,"log.port"),d=e.log.port),BE("LOG_UPLOAD_SERVER","".concat(c,":").concat(d));let u=[];e.cds&&e.cds.hostname&&Array.isArray(e.cds.hostname)&&e.cds.hostname.length?(zm(e.cds.hostname,"cds.hostname"),u=e.cds.hostname):u=o;let l=443;e.cds&&e.cds.port&&(t(e.cds.port,"cds.port"),l=e.cds.port),BE("CDS_AP",u.map(e=>"".concat(e,":").concat(l))),e.cds?BE("ENABLE_CONFIG_DISTRIBUTE",!0):BE("ENABLE_CONFIG_DISTRIBUTE",!1),OE.info("set local access point v2 success");}setLocalAccessPoints(e,t){if(zm(e,"serverList"),Xm(t,"domain"),this._proxyServer||"disabled"!==this._cloudProxyServerMode)throw new SE(fE.INVALID_OPERATION,"set local access point failed, You have already set the cloud proxy");const i=/^(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])$/;e=e.map(e=>i.test(e)?"".concat(e.replace(/\./g,"-"),".").concat(t):e),this._useLocalAccessPoint=!0,this._setLocalAPVersion=1,BE("WEBCS_DOMAIN",e),BE("WEBCS_DOMAIN_BACKUP_LIST",e),BE("GATEWAY_DOMAINS",[t]),BE("EVENT_REPORT_DOMAIN",e[0]),BE("EVENT_REPORT_BACKUP_DOMAIN",e[1]||e[0]),BE("LOG_UPLOAD_SERVER","".concat(e[0],":6444")),OE.info("[".concat(this._clientId,"] set local access point success"));}async setRemoteDefaultVideoStreamType(e){if(Ym(e,"streamType",[0,1]),this._remoteDefaultVideoStreamType=e,this._joinInfo)try{await this._gateway.setDefaultRemoteVideoStreamType(e),this._joinInfo.defaultVideoStream=this._remoteDefaultVideoStreamType;}catch(e){throw OE.error("[".concat(this._clientId,"] set default remote video stream type error"),e.toString()),e}else OE.debug("[".concat(this._clientId,"] haven't joined yet, cache remoteDefaultVideoStreamType ").concat(e));}async setRemoteVideoStreamType(e,t){Ym(t,"streamType",[0,1]);try{await this._gateway.setRemoteVideoStreamType(e,t),setTimeout(()=>{const t=this._users.find(t=>t.uid===e);t&&t.videoTrack&&t.videoTrack.updateMediaStreamTrackResolution();},2e3);}catch(e){throw OE.error("[".concat(this._clientId,"] set remote video stream type error"),e.toString()),e}OE.info("[".concat(this._clientId,"] set remote ").concat(e," video stream type to ").concat(t)),this._remoteStreamTypeCacheMap.set(e,t);}async setStreamFallbackOption(e,t){Ym(t,"fallbackType",[0,1,2]);try{await this._gateway.setStreamFallbackOption(e,t);}catch(e){throw OE.error("[".concat(this._clientId,"] set stream fallback option"),e.toString()),e}OE.info("[".concat(this._clientId,"] set remote ").concat(e," stream fallback type to ").concat(t)),this._streamFallbackTypeCacheMap.set(e,t);}setEncryptionConfig(e,t,i){!function(e){Ym(e,"encryptionMode",["aes-128-xts","aes-256-xts","aes-128-ecb","sm4-128-ecb","aes-128-gcm","aes-256-gcm","aes-128-gcm2","aes-256-gcm2","none"]);}(e),Xm(t,"secret");if(["aes-128-gcm2","aes-256-gcm2"].includes(e)){if(!i||!(i instanceof Uint8Array&&32===i.length))throw new SE(fE.INVALID_PARAMS,"salt must be an Uint8Array and exactly equal to 32 bytes")}else if(i)throw new SE(fE.INVALID_PARAMS,"current encrypt mode does not need salt");new RegExp("^(?=.*[a-z])(?=.*[A-Z])(?=.*[0-9])(?=.*[!@#$%^&*,.<>?/:;'\"|{}\\[\\]])(?=.{8,})").test(t)||OE.warning("The secret is not strong:\n      The secret must contain at least 1 lowercase alphabetical character,\n      The secret must contain at least 1 uppercase alphabetical character,\n      The secret must contain at least 1 numeric character,\n      The secret must contain at least one special character,\n      The secret must be eight characters or longer.\n      "),this._encryptionMode=e,this._encryptionSecret=t,i&&(this._encryptionSalt=_C(i));}async renewToken(e){if(Xm(e,"token",1,2047),!this._key||!this._joinInfo)throw new SE(fE.INVALID_OPERATION,"renewToken should not be called before user join");const t=this._key;this._key=e,this._joinInfo&&(this._joinInfo.token=e);const i=await this._renewTokenMutex.lock();try{if(GE("USE_NEW_TOKEN")){OE.debug("[".concat(this._clientId,"] start renew token with ticket from unilbs"));const t=await _v(this._joinInfo,this._axiosCancelSource.token,this._config.httpRetryConfig||TE);OE.debug("[".concat(this._clientId,"] get ticket from unilbs success")),await this._gateway.renewToken({token:e,ticket:t});}else OE.debug("[".concat(this._clientId,"] start renew token without ticket")),await this._gateway.renewToken({token:e});OE.debug("[".concat(this._clientId,"] renewToken success"));}catch(e){throw this._key=t,this._joinInfo.token=t,OE.error("[".concat(this._clientId,"] renewToken failed"),e.toString()),e}finally{i();}}enableAudioVolumeIndicator(){this._audioVolumeIndicationInterval?OE.warning("you have already enabled audio volume indicator!"):this._audioVolumeIndicationInterval=window.setInterval(()=>{const e=this._p2pChannel.getAudioLevels();this.safeEmit(yf.VOLUME_INDICATOR,e);},GE("AUDIO_VOLUME_INDICATION_INTERVAL")||2e3);}getRTCStats(){const e=this._statsCollector.getRTCStats(),t=this._gateway.getInChannelInfo();return e.Duration=Math.round(t.duration/1e3),e}async startLiveStreaming(e,t){if(!t){if("h264"!==this.codec)throw new SE(fE.LIVE_STREAMING_INVALID_RAW_STREAM,"raw streaming is only support h264");if(!this._p2pChannel.hasLocalMedia())throw new SE(fE.LIVE_STREAMING_INVALID_RAW_STREAM,"can not find stream to raw streaming")}if(this._liveRawStreamingClient&&this._liveRawStreamingClient.hasUrl(e)||this._liveTranscodeStreamingClient&&this._liveTranscodeStreamingClient.hasUrl(e))throw new SE(fE.LIVE_STREAMING_TASK_CONFLICT);const i=t?Kf.TRANSCODE:Kf.RAW;return this._createLiveStreamingClient(i).startLiveStreamingTask(e,i)}setLiveTranscoding(e){return this._createLiveStreamingClient(Kf.TRANSCODE).setTranscodingConfig(e)}async stopLiveStreaming(e){const t=[this._liveRawStreamingClient,this._liveTranscodeStreamingClient].filter(t=>t&&t.hasUrl(e));if(!t.length)throw new SE(fE.INVALID_PARAMS,"can not find live streaming url to stop");await Sl.all(t.map(t=>t&&t.stopLiveStreamingTask(e)));}async addInjectStreamUrl(e,t){if(!this._joinInfo)throw new SE(fE.INVALID_OPERATION,"can not addInjectStreamUrl, no joininfo");const i=this._createLiveStreamingClient(Kf.INJECT);i.setInjectStreamConfig(t,0),await i.startLiveStreamingTask(e,Kf.INJECT);}async removeInjectStreamUrl(){var e;const t=this._createLiveStreamingClient(Kf.INJECT),i=Array.from(IR(e=t.streamingTasks).call(e)).find(e=>e.mode===Kf.INJECT);if(!this._joinInfo||!i)throw new SE(fE.INVALID_OPERATION,"can remove addInjectStreamUrl, no joininfo or inject task");await t.stopLiveStreamingTask(i.url);}async startChannelMediaRelay(e){yv(e);const t=this._createChannelMediaRelayClient();await t.startChannelMediaRelay(e);}async updateChannelMediaRelay(e){yv(e);const t=this._createChannelMediaRelayClient();await t.updateChannelMediaRelay(e);}async stopChannelMediaRelay(){const e=this._createChannelMediaRelayClient();await e.stopChannelMediaRelay(),this._statsCollector.onStatsChanged&&(this._statsCollector.onStatsChanged=void 0);}sendStreamMessage(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];if(!this._joinInfo)throw new SE(fE.INVALID_OPERATION,"can not send data stream, not joined");if("string"==typeof e){e=(new TextEncoder).encode(e);}if(new Blob([e]).size>1024)throw new SE(fE.INVALID_PARAMS,"stream message out of range.");return this._gateway.signal.request(bf.DATA_STREAM,{payload:_C(e)},!t)}sendMetadata(e){if(!this._joinInfo)throw new SE(fE.INVALID_OPERATION,"can not send metadata, not joined");if(new Blob([e]).size>1024)throw new SE(fE.METADATA_OUT_OF_RANGE);return this._gateway.signal.request(bf.SEND_METADATA,{session_id:this._joinInfo.sid,metadata:_C(e)})}async sendCustomReportMessage(e){if(Array.isArray(e)||(e=[e]),e.forEach(cf),!this._joinInfo)throw new SE(fE.INVALID_OPERATION,"can not send custom report, not joined");await Pg.sendCustomReportMessage(this._joinInfo.sid,e);}getLocalAudioStats(){return this._statsCollector.getLocalAudioTrackStats()}getRemoteAudioStats(){return this._statsCollector.getRemoteAudioTrackStats()}getLocalVideoStats(){return this._statsCollector.getLocalVideoTrackStats()}getRemoteVideoStats(){return this._statsCollector.getRemoteVideoTrackStats()}getRemoteNetworkQuality(){return this._statsCollector.getRemoteNetworkQualityStats()}async pickSVCLayer(e,t){Ym(t.spatialLayer,"spatialLayer",[0,1,2,3]),Ym(t.temporalLayer,"temporalLayer",[0,1,2,3]);try{await this._gateway.pickSVCLayer(e,t);}catch(e){throw OE.error("[".concat(this._clientId,"] pick SVC layer failed"),e.toString()),e}}_reset(){if(OE.debug("[".concat(this._clientId,"] reset client")),this._axiosCancelSource.cancel(),this._axiosCancelSource=pE.CancelToken.source(),this._streamFallbackTypeCacheMap=new Map,this._remoteStreamTypeCacheMap=new Map,this._configDistribute.stopGetConfigDistribute(),this._joinInfo=void 0,this._proxyServer=void 0,this._defaultStreamFallbackType=void 0,this._sessionId=null,this.store.sessionId=null,this._statsCollector.reset(),this._key=void 0,this._appId=void 0,this._uid=void 0,this.store.uid=void 0,this._channelName=void 0,this._encryptionMode="none",this._encryptionSecret=null,this._encryptionSalt=null,this._users.forEach(e=>{e._audioTrack&&e._audioTrack._destroy(),e._videoTrack&&e._videoTrack._destroy();}),this._users=[],this._audioVolumeIndicationInterval&&(window.clearInterval(this._audioVolumeIndicationInterval),this._audioVolumeIndicationInterval=void 0),"fallback"===this._cloudProxyServerMode&&(this._cloudProxyServerMode="disabled",this.store.cloudProxyServerMode="disabled"),this._p2pChannel.reset(),this._publishMutex=new Ug("client-publish"),this._subscribeMutex=new Ug("client-subscribe"),this._networkQualityInterval&&(window.clearInterval(this._networkQualityInterval),this._networkQualityInterval=void 0),this._injectStreamingClient&&(this._injectStreamingClient.terminate(),this._injectStreamingClient.removeAllListeners(),this._injectStreamingClient=void 0),this._liveRawStreamingClient&&(this._liveRawStreamingClient.terminate(),this._liveRawStreamingClient.removeAllListeners(),this._liveRawStreamingClient=void 0),this._liveTranscodeStreamingClient&&(this._liveTranscodeStreamingClient.terminate(),this._liveTranscodeStreamingClient.removeAllListeners(),this._liveTranscodeStreamingClient=void 0),this._channelMediaRelayClient&&(this._channelMediaRelayClient.dispose(),this._channelMediaRelayClient=void 0),this._inspect)try{this._inspect.close(),this._inspect=void 0;}catch(e){}if(this._moderation)try{this.setImageModeration(!1);}catch(e){}}_startSession(e,t){const i=e||$I();e?OE.debug("[".concat(this._clientId,"] new Session ").concat(i)):OE.debug("[".concat(this._clientId,"] renewSession ").concat(this._sessionId," => ").concat(i)),this._sessionId=i,this.store.sessionId=i,t?Pg.sessionInit(this._sessionId,{lts:(new Date).getTime(),cname:t.channel,appid:t.appId,mode:this.mode}):this._joinInfo?Pg.sessionInit(this._sessionId,{lts:(new Date).getTime(),cname:this._joinInfo.cname,appid:this._joinInfo.appId,mode:this.mode}):this._gateway.joinInfo&&Pg.sessionInit(this._sessionId,{lts:(new Date).getTime(),cname:this._gateway.joinInfo.cname,appid:this._gateway.joinInfo.appId,mode:this.mode}),this._joinInfo&&(this._joinInfo.sid=i),this._gateway.joinInfo&&(this._gateway.joinInfo.sid=i);}async _publishHighStream(e){if(!this._joinInfo||void 0===this._uid)throw new SE(fE.INVALID_OPERATION,"Can't publish stream, haven't joined yet!");if("CONNECTED"!==this.connectionState&&"RECONNECTING"!==this.connectionState)throw new SE(fE.INVALID_OPERATION,"can not publish stream in ".concat(this.connectionState," state"));if("auto"===this._turnServer.mode&&GE("FORCE_TURN")&&!GE("TURN_ENABLE_TCP")&&!GE("TURN_ENABLE_UDP"))throw new SE(fE.UNEXPECTED_ERROR,"force TURN With No TURN Configuration");OE.debug("[".concat(this._clientId,"] publish high stream"));try{const i=await this._p2pChannel.publish(e,this._isDualStreamEnabled,this._lowStreamParameter),n=(await i.next()).value;if(n){var t;let e;try{e=await this._gateway.publish(this._uid,n,!0);}catch(e){if(e.code!==fE.DISCONNECT_P2P)throw i.throw(e),e}await i.next((null===(t=e)||void 0===t?void 0:t.ortc)||[]);}this._p2pChannel.reportPublishEvent(!0,null);for(const t of e)t instanceof Cy&&t._encoderConfig&&this._gateway.setVideoProfile(t._encoderConfig),!t.muted&&t.enabled||await this._p2pChannel.muteLocalTrack(t);}catch(t){if(this._p2pChannel.reportPublishEvent(!1,null==t?void 0:t.code,e),(null==t?void 0:t.code)===fE.WS_ABORT)return;throw t}}async _publishLowStream(){if(!this._joinInfo||void 0===this._uid)throw new SE(fE.INVALID_OPERATION,"Can't publish stream, haven't joined yet!");if("CONNECTED"!==this.connectionState&&"RECONNECTING"!==this.connectionState)throw new SE(fE.INVALID_OPERATION,"can not publish stream in ".concat(this.connectionState," state"));OE.debug("[".concat(this._clientId,"] publish low stream"));const e=this._configDistribute.getLowStreamConfigDistribute();e&&e.bitrate&&(this._lowStreamParameter||(this._lowStreamParameter={width:160,height:120,framerate:15,bitrate:50}),this._lowStreamParameter&&this._lowStreamParameter.bitrate&&e.bitrate<this._lowStreamParameter.bitrate&&(this._lowStreamParameter.bitrate=e.bitrate));try{const e=await this._p2pChannel.publishLowStream(this._lowStreamParameter),i=(await e.next()).value;if(i){var t;let n;try{n=await this._gateway.publish(this._uid,i,!0);}catch(t){if(t.code!==fE.DISCONNECT_P2P)throw e.throw(t),t}e.next((null===(t=n)||void 0===t?void 0:t.ortc)||[]),this._p2pChannel.reportPublishEvent(!0,null,void 0,!0);}}catch(e){if(this._p2pChannel.reportPublishEvent(!1,null==e?void 0:e.code,void 0,!0),(null==e?void 0:e.code)===fE.WS_ABORT)return;throw e}}_createLiveStreamingClient(e){if(!this._joinInfo||!this._appId){return new SE(fE.INVALID_OPERATION,"can not create live streaming client, please join channel first").throw()}const t=()=>new Cv(this._joinInfo,this._config.websocketRetryConfig||TE,this._config.httpRetryConfig||TE),i=e=>{e.onLiveStreamError=(e,t)=>{Pg.reportApiInvoke(this._sessionId,{name:_f.ON_LIVE_STREAM_ERROR,options:[e,t],tag:Ef.TRACER}).onSuccess(),this.safeEmit(yf.LIVE_STREAMING_ERROR,e,t);},e.onLiveStreamWarning=(e,t)=>{Pg.reportApiInvoke(this._sessionId,{name:_f.ON_LIVE_STREAM_WARNING,options:[e,t],tag:Ef.TRACER}).onSuccess(),this.safeEmit(yf.LIVE_STREAMING_WARNING,e,t);},e.on($f.REQUEST_WORKER_MANAGER_LIST,(e,t,i)=>{if(!this._joinInfo)return i(new SE(fE.INVALID_OPERATION,"can not find join info to get worker manager"));hv(e,this._joinInfo,this._axiosCancelSource.token,TE).then(t).catch(i);});};switch(e){case Kf.RAW:return this._liveRawStreamingClient||(this._liveRawStreamingClient=t(),i(this._liveRawStreamingClient)),this._liveRawStreamingClient;case Kf.TRANSCODE:return this._liveTranscodeStreamingClient||(this._liveTranscodeStreamingClient=t(),i(this._liveTranscodeStreamingClient)),this._liveTranscodeStreamingClient;case Kf.INJECT:return this._injectStreamingClient||(this._injectStreamingClient=t(),this._injectStreamingClient.on($f.REQUEST_WORKER_MANAGER_LIST,(e,t,i)=>{if(!this._joinInfo)return i(new SE(fE.INVALID_OPERATION,"can not find join info to get worker manager"));hv(e,this._joinInfo,this._axiosCancelSource.token,TE).then(t).catch(i);}),this._injectStreamingClient.onInjectStatusChange=(e,t,i)=>{this.emit(yf.INJECT_STREAM_STATUS,e,t,i);}),this._injectStreamingClient}}_createChannelMediaRelayClient(){if(!this._joinInfo){return new SE(fE.INVALID_OPERATION,"can not create channel media relay client, please join channel first").throw()}if(!this._channelMediaRelayClient){const{sendResolutionWidth:e,sendResolutionHeight:t}=this.getLocalVideoStats(),i={width:e,height:t};this._channelMediaRelayClient=new Ov(this._joinInfo,this._clientId,this._config.websocketRetryConfig||TE,this._config.httpRetryConfig||TE,i),this._channelMediaRelayClient.on("state",e=>{e===rS.RELAY_STATE_FAILURE&&this._channelMediaRelayClient&&this._channelMediaRelayClient.dispose(),this.safeEmit(yf.CHANNEL_MEDIA_RELAY_STATE,e);}),this._channelMediaRelayClient.on("event",e=>{this.safeEmit(yf.CHANNEL_MEDIA_RELAY_EVENT,e);}),this._statsCollector.onStatsChanged=(e,t)=>{var i;"resolution"===e&&(null===(i=this._channelMediaRelayClient)||void 0===i||i.setVideoProfile(t));};}return this._channelMediaRelayClient}_handleGatewayEvents(){this._gateway.on(aS.DISCONNECT_P2P,async()=>{await this._p2pChannel.disconnectForReconnect();}),this._gateway.on(aS.CONNECTION_STATE_CHANGE,(e,t,i)=>{var n;if(i===vf.FALLBACK)return;const r=()=>{this.safeEmit(yf.CONNECTION_STATE_CHANGE,e,t,i);};if(Pg.reportApiInvoke(this._sessionId||(null===(n=this._gateway.joinInfo)||void 0===n?void 0:n.sid)||null,{name:_f.CONNECTION_STATE_CHANGE,options:[e,t,i],tag:Ef.TRACER}).onSuccess(JSON.stringify({cur:e,prev:t,reason:i})),OE.info("[".concat(this._clientId,"] connection state change: ").concat(t," -> ").concat(e)),"DISCONNECTED"===e)return this._reset(),void r();if("RECONNECTING"===e)this._users.forEach(e=>{e._trust_in_room_=!1,e._trust_audio_enabled_state_=!1,e._trust_video_enabled_state_=!1,e._trust_audio_mute_state_=!1,e._trust_video_mute_state_=!1,e._trust_audio_stream_added_state_=!1,e._trust_video_stream_added_state_=!1,e._audioSSRC=void 0,e._videoSSRC=void 0,e._videoOrtc=void 0,e._audioOrtc=void 0,e._cname=void 0,e._rtxSsrcId=void 0;}),this._userOfflineTimeout&&window.clearTimeout(this._userOfflineTimeout),this._streamRemovedTimeout&&window.clearTimeout(this._streamRemovedTimeout),this._userOfflineTimeout=void 0,this._streamRemovedTimeout=void 0;else if("CONNECTED"===e){var o;this._streamFallbackTypeCacheMap.forEach((e,t)=>{this._gateway.setStreamFallbackOption(t,e).catch(e=>{OE.warning("[".concat(this._clientId,"] auto set stream fallback option failed"),e);});}),this._remoteStreamTypeCacheMap.forEach((e,t)=>{this._gateway.setRemoteVideoStreamType(t,e).catch(e=>{OE.warning("[".concat(this._clientId,"] auto set remote stream type failed"),e);});}),void 0!==this._remoteDefaultVideoStreamType&&void 0===(null===(o=this._joinInfo)||void 0===o?void 0:o.defaultVideoStream)&&this.setRemoteDefaultVideoStreamType(this._remoteDefaultVideoStreamType).then(()=>{OE.debug("[".concat(this._clientId,"] setRemoteDefaultVideoStreamType after gateway connected"));}).catch(e=>{OE.error("[".concat(this._clientId,"] setRemoteDefaultVideoStreamType after gateway failed, ").concat(e));}),this._p2pChannel.republish(),this._userOfflineTimeout=window.setTimeout(()=>{if("CONNECTED"!==this.connectionState)return;this._userOfflineTimeout=void 0;this._users.filter(e=>!e._trust_in_room_).forEach(e=>{OE.debug("[".concat(this._clientId,"] user offline timeout, emit user offline ").concat(e.uid)),this._handleUserOffline({uid:e.uid});});},3e3),this._streamRemovedTimeout=window.setTimeout(()=>{"CONNECTED"===this.connectionState&&(this._streamRemovedTimeout=void 0,this._users.forEach(e=>{e._trust_audio_mute_state_||(OE.debug("[".concat(this._clientId,"] auto dispatch audio unmute event ").concat(e.uid)),this._handleMuteStream(e.uid,"audio",!1)),e._trust_video_mute_state_||(OE.debug("[".concat(this._clientId,"] auto dispatch video unmute event ").concat(e.uid)),this._handleMuteStream(e.uid,"video",!1)),e._trust_audio_enabled_state_||(OE.debug("[".concat(this._clientId,"] auto dispatch enable local audio ").concat(e.uid)),this._handleSetStreamLocalEnable("audio",e.uid,!0)),e._trust_video_enabled_state_||(OE.debug("[".concat(this._clientId,"] auto dispatch enable local video ").concat(e.uid)),this._handleSetStreamLocalEnable("video",e.uid,!0)),e._trust_video_stream_added_state_||(OE.debug("[".concat(this._clientId,"] auto dispatch reset video stream added ").concat(e.uid)),this._handleResetAddStream(e,"video")),e._trust_audio_stream_added_state_||(OE.debug("[".concat(this._clientId,"] auto dispatch reset audio stream added ").concat(e.uid)),this._handleResetAddStream(e,"audio")),e._video_added_||e._audio_added_||(OE.debug("[".concat(this._clientId,"] auto dispatch stream remove ").concat(e.uid)),this._handleRemoveStream({uid:e.uid,uint_id:e._uintid}));}));},1e3);}r();}),this._gateway.on(aS.REQUEST_NEW_GATEWAY_LIST,(e,t)=>{if(!this._joinInfo)return t(new SE(fE.UNEXPECTED_ERROR,"can not recover, no join info"));av(this._joinInfo,this._axiosCancelSource.token,this._config.httpRetryConfig||TE,this.store).then(t=>{this._joinInfo&&(this._joinInfo.apResponse=t.gatewayInfo.res,this._joinInfo.gatewayAddrs=t.gatewayInfo.gatewayAddrs,this._joinInfo.uni_lbs_ip=t.gatewayInfo.uni_lbs_ip),e(t.gatewayInfo.gatewayAddrs.map(e=>{if(this._joinInfo&&this._joinInfo.proxyServer){const t=e.address.split(":");return "wss://".concat(this._joinInfo.proxyServer,"/ws/?h=").concat(t[0],"&p=").concat(t[1])}return "wss://".concat(e.address)}));}).catch(t);}),this._gateway.on(aS.NETWORK_QUALITY,e=>{"normal"===this._networkQualitySensitivity&&this.safeEmit(yf.NETWORK_QUALITY,e);}),this._gateway.on(aS.STREAM_TYPE_CHANGE,(e,t)=>{this.safeEmit(yf.STREAM_TYPE_CHANGED,e,t);Pg.reportApiInvoke(this._sessionId,{name:_f.STREAM_TYPE_CHANGE,options:[e,t],tag:Ef.TRACER}).onSuccess(JSON.stringify({uid:e,streamType:t}));}),this._gateway.on(aS.IS_P2P_DISCONNECTED,e=>{this._p2pChannel.isP2PDisconnected()?e(!0):this._p2pChannel.hasLocalMedia()||this._p2pChannel.hasRemoteMedia()?e(!1):e(!0);}),this._gateway.on(aS.NEED_RENEW_SESSION,()=>{this._startSession();}),this._gateway.on(aS.REQUEST_P2P_CONNECTION_PARAMS,async(e,t,i)=>{try{t(await this._p2pChannel.startP2PConnection(e));}catch(e){i(e);}}),this._gateway.on(aS.JOIN_RESPONSE,(e,t)=>{const{dtlsParameters:i,iceParameters:n,candidates:r,rtpCapabilities:o,setup:s,cname:a}=GO(e.ortc,t);this._p2pChannel.connect(n,i,r,o,s,a);}),this._gateway.on(aS.REQUEST_DC_CONNECTION_PARAMS,e=>{e(this._p2pChannel.getEstablishParams());}),this._gateway.on(aS.RESET_SIGNAL,e=>{this._p2pChannel.resetConnection(e),this._handleGatewaySignalEvents();}),this._gateway.on(aS.DATACHANNEL_FAILBACK,()=>{this._joinGateway();}),this._gateway.on(aS.DATACHANNEL_PRECONNECT,async(e,t,i,n)=>{var r,o,s,a,c,d;await this._p2pChannel.startP2PConnection({turnServer:null===(r=this._joinInfo)||void 0===r?void 0:r.turnServer},!0);const u=function(e,t){let i;return t&&t.ip&&"number"==typeof t.port?(i=[{foundation:"udpcandidate",componentId:"1",transport:"udp",priority:"2103266323",connectionAddress:t.ip,port:t.port.toString(),type:"host",extension:{}}],OE.debug("Using remote candidate from AP ".concat(t.ip,":").concat(t.port)),t.ip6&&(i.push({foundation:"udpcandidate",componentId:"1",transport:"udp",priority:"2103266323",connectionAddress:t.ip6,port:t.port.toString(),type:"host",extension:{}}),OE.debug("Using IPV6 remote candidate from AP ".concat(t.ip6,":").concat(t.port)))):i=[{foundation:"udpcandidate",componentId:"1",transport:"udp",priority:"2103266323",connectionAddress:e.ip,port:e.port.toString(),type:"host",extension:{}}],i}(e,t);return this._p2pChannel.preConnect({iceUfrag:"".concat(null===(o=this._joinInfo)||void 0===o?void 0:o.apResponse.cid,"_").concat(null===(s=this._joinInfo)||void 0===s?void 0:s.apResponse.cert),icePwd:"".concat(null===(a=this._joinInfo)||void 0===a?void 0:a.apResponse.cid,"_").concat(null===(c=this._joinInfo)||void 0===c?void 0:c.apResponse.cert)},{fingerprints:[{hashFunction:"sha-256",fingerprint:null!==(d=GE("FINGERPRINT"))&&void 0!==d?d:e.fingerprint}]},u,{send:{audioCodecs:[],videoCodecs:[],audioExtensions:[],videoExtensions:[]},recv:{audioCodecs:[],videoCodecs:[],audioExtensions:[],videoExtensions:[]}},"active","o/i14u9pJrxRKAsu").then(i).catch(n)});}_handleGatewaySignalEvents(){this._gateway.signal.on(Df.ON_USER_ONLINE,this._handleUserOnline),this._gateway.signal.on(Df.ON_USER_OFFLINE,this._handleUserOffline),this._gateway.signal.on(Df.ON_ADD_AUDIO_STREAM,e=>this._handleAddAudioOrVideoStream("audio",e.uid,e.ssrcId,e.cname,e.uint_id,e.ortc)),this._gateway.signal.on(Df.ON_ADD_VIDEO_STREAM,e=>this._handleAddAudioOrVideoStream("video",e.uid,e.ssrcId,e.cname,e.uint_id,e.ortc,e.rtxSsrcId)),this._gateway.signal.on(Df.ON_REMOVE_STREAM,this._handleRemoveStream),this._gateway.signal.on(Df.ON_P2P_LOST,this._handleP2PLost),this._gateway.signal.on(Df.MUTE_AUDIO,e=>this._handleMuteStream(e.uid,"audio",!0)),this._gateway.signal.on(Df.UNMUTE_AUDIO,e=>this._handleMuteStream(e.uid,"audio",!1)),this._gateway.signal.on(Df.MUTE_VIDEO,e=>this._handleMuteStream(e.uid,"video",!0)),this._gateway.signal.on(Df.UNMUTE_VIDEO,e=>this._handleMuteStream(e.uid,"video",!1)),this._gateway.signal.on(Df.RECEIVE_METADATA,e=>{const t=pC(e.metadata);this.safeEmit(yf.RECEIVE_METADATA,e.uid,t);}),this._gateway.signal.on(Df.ON_DATA_STREAM,e=>{e.seq&&delete e.seq,e.payload=pC(e.payload),this.safeEmit(yf.STREAM_MESSAGE,e.uid,e.payload),this.onStreamMessage&&this.onStreamMessage(e);}),this._gateway.signal.on(Df.ON_CRYPT_ERROR,()=>{hC(()=>{OE.warning("[".concat(this._clientId,"] on crypt error")),this.safeEmit(yf.CRYPT_ERROR);},this._sessionId);}),this._gateway.signal.on(Df.ON_TOKEN_PRIVILEGE_WILL_EXPIRE,this._handleTokenWillExpire),this._gateway.signal.on(Df.ON_TOKEN_PRIVILEGE_DID_EXPIRE,()=>{OE.warning("[".concat(this._clientId,"] received message onTokenPrivilegeDidExpire, please get new token and join again")),this._gateway.leave(!0),this.safeEmit(yf.ON_TOKEN_PRIVILEGE_DID_EXPIRE),this._reset();}),this._gateway.signal.on(Df.ON_STREAM_FALLBACK_UPDATE,e=>{OE.debug("[".concat(this._clientId,"] stream fallback peerId: ").concat(e.stream_id,", attr: ").concat(e.stream_type)),this.safeEmit(yf.STREAM_FALLBACK,e.stream_id,1===e.stream_type?"fallback":"recover");}),this._gateway.signal.on(Df.ON_PUBLISH_STREAM,e=>{this.uid===this._uid&&(this._p2pChannel.reportPublishEvent(!0,null,void 0,!1,JSON.stringify({proxy:e.proxy})),OE.info("[".concat(this._clientId,"] on publish stream, ").concat(JSON.stringify(e))));}),this._gateway.signal.on(Df.ENABLE_LOCAL_VIDEO,e=>{this._handleSetStreamLocalEnable("video",e.uid,!0);}),this._gateway.signal.on(Df.DISABLE_LOCAL_VIDEO,e=>{this._handleSetStreamLocalEnable("video",e.uid,!1);}),this._gateway.signal.on(Nf.REQUEST_TIMEOUT,(e,t)=>{if(this._joinInfo)switch(e){case bf.PUBLISH:{if(!t)return;const e=(t=t).ortc;if(e){var i,n,r,o;const s=e.some(e=>{let{stream_type:t}=e;return t===sS.Audio}),a=e.some(e=>{let{stream_type:t}=e;return t!==sS.Audio}),c=e.some(e=>{let{stream_type:t}=e;return t===sS.Screen||t===sS.ScreenLow});"offer"===t.state&&Pg.publish(this._joinInfo.sid,{eventElapse:DI.measureFromPublishStart(this.store.clientId,this.store.pubId),succ:!1,ec:fE.TIMEOUT,audio:s,video:a,p2pid:t.p2p_id,publishRequestid:this.store.pubId,screenshare:c,audioName:s?null===(i=e.find(e=>{let{stream_type:t}=e;return t===sS.Audio}))||void 0===i||null===(n=i.ssrcs[0])||void 0===n?void 0:n.ssrcId.toString():void 0,videoName:a?null===(r=e.find(e=>{let{stream_type:t}=e;return t!==sS.Audio}))||void 0===r||null===(o=r.ssrcs[0])||void 0===o?void 0:o.ssrcId.toString():void 0});}break}case bf.SUBSCRIBE:(t=t)&&Pg.subscribe(this._joinInfo.sid,{succ:!1,ec:fE.TIMEOUT,audio:t.stream_type===AS.AUDIO,video:t.stream_type===AS.VIDEO,peerid:t.stream_id,subscribeRequestid:t.ssrcId,p2pid:this.store.p2pId,eventElapse:DI.measureFromSubscribeStart(this.store.clientId,t.ssrcId)});}}),this._gateway.signal.on(Df.ON_P2P_OK,e=>{this.uid,this._uid;}),this._gateway.signal.on(Df.ON_PUBLISHED_USER_LIST,e=>{if(null==e||!e.users)return;GE("BLOCK_LOCAL_CLIENT")&&(e.users=e.users.filter(e=>!ZE(e.audio_ssrc,this.channelName)));const t=[],i=[];for(const n of e.users){let e=this._users.find(e=>e.uid===n.stream_id);e?e._trust_in_room_=!0:(e=new yy(n.stream_id,n.stream_id),this._users.push(e),0===this.getListeners(yf.PUBLISHED_USER_LIST).length&&(OE.debug("[".concat(this._clientId,"] user online"),n.stream_id),this.safeEmit(yf.USER_JOINED,e)));const r=cS.Audio&n.stream_type,o=(cS.Video|cS.LwoVideo)&n.stream_type,s=r&&e.hasAudio,a=o&&e.hasVideo;o&&(e._trust_video_stream_added_state_=!0,e._video_added_=!0,e._videoSSRC=n.video_ssrc,e._rtxSsrcId=n.video_rtx),r&&(e._trust_audio_stream_added_state_=!0,e._audio_added_=!0,e._audioSSRC=n.audio_ssrc),r&&!s&&0===this.getListeners(yf.PUBLISHED_USER_LIST).length&&(OE.info("[".concat(this._clientId,"] remote user ").concat(e.uid," published audio")),this.safeEmit(yf.USER_PUBLISHED,e,"audio")),o&&!a&&0===this.getListeners(yf.PUBLISHED_USER_LIST).length&&(OE.info("[".concat(this._clientId,"] remote user ").concat(e.uid," published video")),this.safeEmit(yf.USER_PUBLISHED,e,"video")),(r&&!s||o&&!a)&&t.push(e),o&&this._p2pChannel.hasPendingRemoteMedia(e,"video")&&i.push({user:e,mediaType:"video"}),r&&this._p2pChannel.hasPendingRemoteMedia(e,"audio")&&i.push({user:e,mediaType:"audio"});}i.length>0&&(OE.debug("[".concat(this._clientId,"] RE massSubscribe after reconnect ").concat(i.map(e=>"user: ".concat(e.user.uid,", mediaType: ").concat(e.mediaType)).join("; ")," ")),this.massSubscribe(i).catch(e=>{OE.error("[".concat(this._clientId,"] mass resubscribe error"),e.toString());})),this.getListeners(yf.PUBLISHED_USER_LIST).length>0?(OE.info("[".concat(this._clientId,"] client emit user-list event, users: ").concat(t.map(e=>e.uid).join(", "))),this.safeEmit(yf.PUBLISHED_USER_LIST,t)):OE.info("[".concat(this._clientId,"] client not emit user-list event case there is no user-list listener, users: ").concat(t.map(e=>e.uid).join(", ")));});}_handleP2PChannelEvents(){this._p2pChannel.on(DS.RequestMuteLocal,async(e,t,i)=>{if(this._joinInfo)try{await this._gateway.muteLocal(e,this._joinInfo.stringUid||this._joinInfo.uid),t();}catch(e){e.code===fE.DISCONNECT_P2P?t():i(e);}else t();}),this._p2pChannel.on(DS.RequestUnmuteLocal,async(e,t,i)=>{if(this._joinInfo)try{await this._gateway.unmuteLocal(e,this._joinInfo.stringUid||this._joinInfo.uid),t();}catch(e){e.code===fE.DISCONNECT_P2P?t():i(e);}else t();}),this._p2pChannel.on(DS.RequestRePublish,(e,t,i)=>{this.publish(e,!1).then(t).catch(i);}),this._p2pChannel.on(DS.RequestReSubscribe,async(e,t,i)=>{try{for(const{user:t,kind:i}of e)i===AS.VIDEO?await this.subscribe(t,"video"):await this.subscribe(t,"audio");t();}catch(e){i(e);}}),this._p2pChannel.on(DS.RequestUploadStats,(e,t)=>{this._gateway.uploadStats(e,t);}),this._p2pChannel.on(DS.MediaReconnectStart,e=>{this.safeEmit(yf.MEDIA_RECONNECT_START,e);}),this._p2pChannel.on(DS.MediaReconnectEnd,e=>{this.safeEmit(yf.MEDIA_RECONNECT_END,e);}),this._p2pChannel.on(DS.NeedSignalRTT,e=>{e(this._gateway.getSignalRTT());}),this._p2pChannel.on(DS.RequestRestartICE,async e=>{const t=await this._p2pChannel.restartICE(e),i=await t.next();if(i.done)return;const n=i.value;let r;try{r=await this._gateway.restartICE({iceParameters:n});}catch(e){return void t.throw(e)}const{iceParameters:o}=function(e){const t=e.iceParameters;return {iceParameters:{iceUfrag:t.iceUfrag,icePwd:t.icePwd}}}(r);await t.next({remoteIceParameters:o});}),this._p2pChannel.on(DS.RequestReconnect,async()=>{this._gateway.reconnect();}),this._p2pChannel.on(DS.RequestReconnectPC,async()=>{var e;const{iceParameters:t,dtlsParameters:i,rtpCapabilities:n}=await this._p2pChannel.startP2PConnection({turnServer:null===(e=this._joinInfo)||void 0===e?void 0:e.turnServer}),{gatewayEstablishParams:r,gatewayAddress:o}=await this._gateway.reconnectPC({iceParameters:t,dtlsParameters:i,rtpCapabilities:n}),{dtlsParameters:s,iceParameters:a,candidates:c,rtpCapabilities:d,setup:u,cname:l}=GO(r,o);await this._p2pChannel.connect(a,s,c,d,u,l),await this._p2pChannel.republish(),await this._p2pChannel.reSubscribe();}),this._p2pChannel.on(DS.RequestUnpublishForReconnectPC,async(e,t,i)=>{this._joinInfo&&void 0!==this._uid?(await this._gateway.unpublish(e,this._uid),t()):i();}),this._p2pChannel.on(DS.P2PLost,()=>{this.safeEmit(yf.P2P_LOST,this.store.uid);}),this._p2pChannel.on(DS.UpdateVideoEncoder,e=>{e._encoderConfig&&this._gateway.setVideoProfile(e._encoderConfig);}),this._p2pChannel.on(DS.ConnectionTypeChange,e=>{this.safeEmit(yf.IS_USING_CLOUD_PROXY,e);}),this._p2pChannel.on(DS.RequestLowStreamParameter,e=>{e(this._lowStreamParameter||{width:160,height:120,framerate:15,bitrate:50});}),this._p2pChannel.on(DS.QueryClientConnectionState,e=>{e(this.connectionState);});}getKeyMetrics(){return this.store.keyMetrics}async enableContentInspect(e){if("CONNECTED"!==this.connectionState||!this._joinInfo)throw new SE(fE.INVALID_OPERATION,"[".concat(this._clientId,"] Client did not join channel"));if(this._inspect)throw new SE(fE.INVALID_OPERATION,"[".concat(this._clientId,"] Inspect content service already in connecting/connected state"));if(!e)throw new SE(fE.INVALID_PARAMS,"[".concat(this._clientId,"] inspectConfig is necessary"));if(!e.inspectType||!Array.isArray(e.inspectType))throw new SE(fE.INVALID_PARAMS,"[".concat(this._clientId,"] inspectConfig.inspectType is necessary and is an instance of Array."));{const t=[...new Set(e.inspectType)];t.forEach(e=>{if(!["supervise","moderation"].includes(e))throw new SE(fE.INVALID_PARAMS,"[".concat(this._clientId,"] ").concat(e," is not a valid inspect type."))}),e.inspectType=t;}if(e&&e.extraInfo&&e.extraInfo.length>1024)throw new SE(fE.INVALID_PARAMS,"[".concat(this._clientId,"] inspectConfig.extraInfo length cannot exceed 1024 bytes"));try{const t=new Ew(e);this._inspect=t,this.handleVideoInspectEvents(this._inspect),await t.init({appId:this._joinInfo.appId,areaCode:"",cname:this._joinInfo.cname,sid:this._joinInfo.sid,token:this._joinInfo.token,uid:this._joinInfo.uid,cid:this._joinInfo.cid,vid:this._joinInfo.vid?Number(this._joinInfo.vid):0},TE);}catch(e){throw Array.isArray(e)?e[0]:e}}async disableContentInspect(){if(!this._inspect)throw new SE(fE.INVALID_OPERATION,"[".concat(this._clientId,"] inspectVideoContent not started"));try{this._inspect.close(),this._inspect=void 0;}catch(e){throw Array.isArray(e)?e[0]:e}}async setImageModeration(e,t){if(Km(e,"enabled"),e){if(!t)throw new SE(fE.INVALID_PARAMS,"[".concat(this._clientId,"] config is necessary"));if(qm(t.interval,"interval",1e3,1/0),"CONNECTED"!==this.connectionState||!this._joinInfo)throw new SE(fE.INVALID_OPERATION,"[".concat(this._clientId,'] can not enable image moderation, not joined"'));try{if(this._moderation)return void this._moderation.updateConfig(t);const e=new Jw(t);this._moderation=e,this.handleImageModerationEvents(this._moderation),await e.init({appId:this._joinInfo.appId,areaCode:"",cname:this._joinInfo.cname,sid:this._joinInfo.sid,token:this._joinInfo.token,uid:this._joinInfo.uid,cid:this._joinInfo.cid,vid:this._joinInfo.vid?Number(this._joinInfo.vid):0},TE);}catch(e){throw Array.isArray(e)?e[0]:e}}else {if(!this._moderation)throw new SE(fE.INVALID_OPERATION,"[".concat(this._clientId,"] image moderation not started"));try{this._moderation.close(),this._moderation.removeAllListeners(),this._moderation=void 0;}catch(e){throw Array.isArray(e)?e[0]:e}}}handleImageModerationEvents(e){e.on(HS.CONNECTION_STATE_CHANGE,(t,i)=>{switch(this.emit(yf.IMAGE_MODERATION_CONNECTION_STATE_CHANGE,t,i),t){case WS.CONNECTED:if("CONNECTED"!==this.connectionState)throw this.setImageModeration(!1),new SE(fE.OPERATION_ABORTED,"Image moderation was cancelled because it left the channel");e.inspectImage();}}),e.on(HS.CLIENT_LOCAL_VIDEO_TRACK,e=>{e(this.localTracks.filter(e=>"video"===e.trackMediaType)[0]);});}handleVideoInspectEvents(e){e.on(VS.CONNECTION_STATE_CHANGE,(t,i)=>{switch(this.emit(yf.CONTENT_INSPECT_CONNECTION_STATE_CHANGE,t,i),i){case US.CONNECTED:if("CONNECTED"!==this.connectionState)return void this.emit(yf.CONTENT_INSPECT_ERROR,new SE(fE.OPERATION_ABORTED,"Content inspect was cancelled because it left the channel"));e.inspectImage();}}),e.on(VS.INSPECT_RESULT,(e,t)=>{var i;if((null==t?void 0:t.code)===fE.INVALID_OPERATION&&"DISCONNECTED"===this.connectionState)return OE.debug("Stop inspect content because that has left channel"),null==this||null===(i=this._inspect)||void 0===i||i.close(),void(this._inspect=void 0);this.emit(yf.CONTENT_INSPECT_RESULT,e,t);}),e.on(VS.CLIENT_LOCAL_VIDEO_TRACK,e=>{e(this.localTracks.filter(e=>"video"===e.trackMediaType)[0]);});}getJoinChannelServiceRecords(){return OE.debug("getJoinChannelServiceRecords"),this.store.joinChannelServiceRecords}async setPublishAudioFilterEnabled(e){Km(e,"enabled"),BE("ENABLE_PUBLISH_AUDIO_FILTER",e),this._joinInfo&&await this._gateway.setPublishAudioFilterEnabled(e);}_handleResetAddStream(e,t){switch(t){case"audio":e._audio_added_=!1,e._trust_audio_stream_added_state_=!0;break;case"video":e._video_added_=!1,e._trust_video_stream_added_state_=!0;}}}).prototype,"leave",[Xw],Object.getOwnPropertyDescriptor(kD.prototype,"leave"),kD.prototype),ag(kD.prototype,"publish",[zw],Object.getOwnPropertyDescriptor(kD.prototype,"publish"),kD.prototype),ag(kD.prototype,"unpublish",[Qw],Object.getOwnPropertyDescriptor(kD.prototype,"unpublish"),kD.prototype),ag(kD.prototype,"subscribe",[Zw],Object.getOwnPropertyDescriptor(kD.prototype,"subscribe"),kD.prototype),ag(kD.prototype,"massSubscribe",[$w],Object.getOwnPropertyDescriptor(kD.prototype,"massSubscribe"),kD.prototype),ag(kD.prototype,"unsubscribe",[eD],Object.getOwnPropertyDescriptor(kD.prototype,"unsubscribe"),kD.prototype),ag(kD.prototype,"massUnsubscribe",[tD],Object.getOwnPropertyDescriptor(kD.prototype,"massUnsubscribe"),kD.prototype),ag(kD.prototype,"setLowStreamParameter",[iD],Object.getOwnPropertyDescriptor(kD.prototype,"setLowStreamParameter"),kD.prototype),ag(kD.prototype,"enableDualStream",[nD],Object.getOwnPropertyDescriptor(kD.prototype,"enableDualStream"),kD.prototype),ag(kD.prototype,"disableDualStream",[rD],Object.getOwnPropertyDescriptor(kD.prototype,"disableDualStream"),kD.prototype),ag(kD.prototype,"setClientRole",[oD],Object.getOwnPropertyDescriptor(kD.prototype,"setClientRole"),kD.prototype),ag(kD.prototype,"setProxyServer",[sD],Object.getOwnPropertyDescriptor(kD.prototype,"setProxyServer"),kD.prototype),ag(kD.prototype,"setTurnServer",[aD],Object.getOwnPropertyDescriptor(kD.prototype,"setTurnServer"),kD.prototype),ag(kD.prototype,"setLicense",[cD],Object.getOwnPropertyDescriptor(kD.prototype,"setLicense"),kD.prototype),ag(kD.prototype,"startProxyServer",[dD],Object.getOwnPropertyDescriptor(kD.prototype,"startProxyServer"),kD.prototype),ag(kD.prototype,"stopProxyServer",[uD],Object.getOwnPropertyDescriptor(kD.prototype,"stopProxyServer"),kD.prototype),ag(kD.prototype,"setLocalAccessPointsV2",[lD],Object.getOwnPropertyDescriptor(kD.prototype,"setLocalAccessPointsV2"),kD.prototype),ag(kD.prototype,"setLocalAccessPoints",[hD],Object.getOwnPropertyDescriptor(kD.prototype,"setLocalAccessPoints"),kD.prototype),ag(kD.prototype,"setRemoteDefaultVideoStreamType",[pD],Object.getOwnPropertyDescriptor(kD.prototype,"setRemoteDefaultVideoStreamType"),kD.prototype),ag(kD.prototype,"setRemoteVideoStreamType",[_D],Object.getOwnPropertyDescriptor(kD.prototype,"setRemoteVideoStreamType"),kD.prototype),ag(kD.prototype,"setStreamFallbackOption",[ED],Object.getOwnPropertyDescriptor(kD.prototype,"setStreamFallbackOption"),kD.prototype),ag(kD.prototype,"setEncryptionConfig",[mD],Object.getOwnPropertyDescriptor(kD.prototype,"setEncryptionConfig"),kD.prototype),ag(kD.prototype,"renewToken",[fD],Object.getOwnPropertyDescriptor(kD.prototype,"renewToken"),kD.prototype),ag(kD.prototype,"enableAudioVolumeIndicator",[SD],Object.getOwnPropertyDescriptor(kD.prototype,"enableAudioVolumeIndicator"),kD.prototype),ag(kD.prototype,"startLiveStreaming",[TD],Object.getOwnPropertyDescriptor(kD.prototype,"startLiveStreaming"),kD.prototype),ag(kD.prototype,"setLiveTranscoding",[gD],Object.getOwnPropertyDescriptor(kD.prototype,"setLiveTranscoding"),kD.prototype),ag(kD.prototype,"stopLiveStreaming",[RD],Object.getOwnPropertyDescriptor(kD.prototype,"stopLiveStreaming"),kD.prototype),ag(kD.prototype,"addInjectStreamUrl",[ID],Object.getOwnPropertyDescriptor(kD.prototype,"addInjectStreamUrl"),kD.prototype),ag(kD.prototype,"removeInjectStreamUrl",[CD],Object.getOwnPropertyDescriptor(kD.prototype,"removeInjectStreamUrl"),kD.prototype),ag(kD.prototype,"startChannelMediaRelay",[vD],Object.getOwnPropertyDescriptor(kD.prototype,"startChannelMediaRelay"),kD.prototype),ag(kD.prototype,"updateChannelMediaRelay",[yD],Object.getOwnPropertyDescriptor(kD.prototype,"updateChannelMediaRelay"),kD.prototype),ag(kD.prototype,"stopChannelMediaRelay",[AD],Object.getOwnPropertyDescriptor(kD.prototype,"stopChannelMediaRelay"),kD.prototype),ag(kD.prototype,"sendCustomReportMessage",[OD],Object.getOwnPropertyDescriptor(kD.prototype,"sendCustomReportMessage"),kD.prototype),ag(kD.prototype,"pickSVCLayer",[ND],Object.getOwnPropertyDescriptor(kD.prototype,"pickSVCLayer"),kD.prototype),ag(kD.prototype,"enableContentInspect",[bD],Object.getOwnPropertyDescriptor(kD.prototype,"enableContentInspect"),kD.prototype),ag(kD.prototype,"disableContentInspect",[wD],Object.getOwnPropertyDescriptor(kD.prototype,"disableContentInspect"),kD.prototype),ag(kD.prototype,"setImageModeration",[DD],Object.getOwnPropertyDescriptor(kD.prototype,"setImageModeration"),kD.prototype),ag(kD.prototype,"getJoinChannelServiceRecords",[PD],Object.getOwnPropertyDescriptor(kD.prototype,"getJoinChannelServiceRecords"),kD.prototype),ag(kD.prototype,"setPublishAudioFilterEnabled",[LD],Object.getOwnPropertyDescriptor(kD.prototype,"setPublishAudioFilterEnabled"),kD.prototype),kD);class VD extends zg{set currentState(e){e!==this._currentState&&(this._currentState=e,this.safeEmit(Lf.AUDIO_SOURCE_STATE_CHANGE,this._currentState));}get currentState(){return this._currentState}constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};super(),_p(this,"audioBuffer",void 0),_p(this,"sourceNode",void 0),_p(this,"startPlayTime",0),_p(this,"startPlayOffset",0),_p(this,"pausePlayTime",0),_p(this,"options",void 0),_p(this,"currentLoopCount",0),_p(this,"currentPlaybackSpeed",100),_p(this,"_currentState","stopped"),this.audioBuffer=e,this.options=t,this.startPlayOffset=this.options.startPlayTime||0;}createWebAudioDiagram(){return this.context.createGain()}get duration(){return this.audioBuffer.duration}get playbackSpeed(){return this.currentPlaybackSpeed}get currentTime(){return "stopped"===this.currentState?0:"paused"===this.currentState?this.pausePlayTime:((this.context.currentTime-this.startPlayTime)*(this.playbackSpeed/100)+this.startPlayOffset)%this.audioBuffer.duration}updateOptions(e){"stopped"===this.currentState?(this.options=e,this.startPlayOffset=this.options.startPlayTime||0):OE.warning("can not set audio source options");}startProcessAudioBuffer(){this.sourceNode&&this.stopProcessAudioBuffer(),this.sourceNode=this.createSourceNode(),this.startSourceNode(),this.currentState="playing";}pauseProcessAudioBuffer(){this.sourceNode&&"playing"===this.currentState&&(this.pausePlayTime=this.currentTime,this.sourceNode.onended=null,this.sourceNode.stop(),this.sourceNode.buffer=null,this.sourceNode=this.createSourceNode(),this.currentState="paused");}seekAudioBuffer(e){this.sourceNode&&(this.sourceNode.onended=null,"playing"===this.currentState&&this.sourceNode.stop(),this.sourceNode=this.createSourceNode(),"playing"===this.currentState?(this.startPlayOffset=e,this.startSourceNode()):"paused"===this.currentState&&(this.pausePlayTime=e));}resumeProcessAudioBuffer(){"paused"===this.currentState&&this.sourceNode&&(this.startPlayOffset=this.pausePlayTime,this.pausePlayTime=0,this.startSourceNode(),this.currentState="playing");}stopProcessAudioBuffer(){if(this.sourceNode){this.sourceNode.onended=null;try{this.sourceNode.stop();}catch(e){}this.reset();}}setAudioBufferPlaybackSpeed(e){this.sourceNode&&("playing"===this.currentState&&(this.startPlayOffset=this.currentTime,this.startPlayTime=this.context.currentTime),this.sourceNode.playbackRate.value=e/100),this.currentPlaybackSpeed=e;}startSourceNode(){this.sourceNode&&this.sourceNode.buffer&&(this.sourceNode.start(0,this.startPlayOffset),this.startPlayTime=this.context.currentTime,this.sourceNode.onended=this.handleSourceNodeEnded.bind(this));}createSourceNode(){const e=this.context.createBufferSource();return e.buffer=this.audioBuffer,e.loop=!!this.options.loop,e.connect(this.outputNode),e.playbackRate.value=this.currentPlaybackSpeed/100,e}handleSourceNodeEnded(){if(this.currentLoopCount+=1,this.options.cycle&&this.options.cycle>this.currentLoopCount)return this.startPlayOffset=0,this.sourceNode=void 0,void this.startProcessAudioBuffer();this.reset();}reset(){this.startPlayOffset=this.options.startPlayTime||0,this.currentState="stopped",this.sourceNode&&(this.sourceNode.disconnect(),this.sourceNode=void 0),this.currentLoopCount=0;}}const jD=new Map;async function FD(e,t){let i=null;if("string"==typeof e){const t=jD.get(e);if(t)return OE.debug("use cached audio resource: ",e),t;try{i=(await RE(()=>pE.get(e,{responseType:"arraybuffer"}),void 0,void 0,{maxRetryCount:3})).data;}catch(e){throw new SE(fE.FETCH_AUDIO_FILE_FAILED,e.toString())}}else {const t=new Sl((t,i)=>{const n=new FileReader;n.onload=e=>{e.target?t(e.target.result):i(new SE(fE.READ_LOCAL_AUDIO_FILE_ERROR));},n.onerror=()=>{i(new SE(fE.READ_LOCAL_AUDIO_FILE_ERROR));},n.readAsArrayBuffer(e);});i=await t;}const n=await function(e){const t=Hg();return new Sl((i,n)=>{t.decodeAudioData(e,e=>{i(e);},e=>{n(new SE(fE.DECODE_AUDIO_FILE_FAILED,e.toString()));});})}(i);return "string"==typeof e&&t&&jD.set(e,n),n}function BD(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n);}return i}function GD(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?BD(Object(i),!0).forEach((function(t){_p(e,t,i[t]);})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):BD(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t));}));}return e}function WD(e,t,i,n){i.optimizationMode&&(n&&n.width&&n.height?(i.encoderConfig=GD(GD({},n),{},{bitrateMin:n.bitrateMin,bitrateMax:n.bitrateMax}),"motion"!==i.optimizationMode&&"detail"!==i.optimizationMode||(t.contentHint=i.optimizationMode,t.contentHint===i.optimizationMode?OE.debug("[".concat(e,"] set content hint to"),i.optimizationMode):OE.debug("[".concat(e,"] set content hint failed")))):OE.warning("[".concat(e,"] can not apply optimization mode bitrate config, no encoderConfig")));}const HD=xh().name;function KD(e,t,i,n){let r,o=0,s=null;return new Sl((a,c)=>{setTimeout(()=>{r&&(r(),a(o));},t),r=Jg(()=>{!function(){o>n&&r&&(r(),a(o));const t=i.getContext("2d");if(!t){const e=new SE(fE.UNEXPECTED_ERROR,"can not get canvas 2d context.");return OE.error(e.toString()),void c(e)}t.drawImage(e,0,0,160,120);const d=t.getImageData(0,0,i.width,i.height),u=Math.floor(d.data.length/3);if(s){for(let e=0;e<u;e+=3)if(d.data[e]!==s[e])return o+=1,void(s=d.data);s=d.data;}else s=d.data;}();},30);})}class YD{constructor(e,t){_p(this,"id",0),_p(this,"element",void 0),_p(this,"peerPair",void 0),_p(this,"context",void 0),_p(this,"audioPlayerElement",void 0),_p(this,"audioTrack",void 0),YD.count+=1,this.id=YD.count,this.element=e,this.context=t;}initPeers(){this.peerPair=[new RTCPeerConnection,new RTCPeerConnection],this.peerPair[1].ontrack=e=>{const t=document.createElement("audio");t.srcObject=new MediaStream([e.track]),t.play(),this.audioPlayerElement=t;};}async switchSdp(){if(!this.peerPair)return;const e=async(e,t)=>{const i="offer"===t?await e.createOffer():await e.createAnswer();return await e.setLocalDescription(i),"complete"===e.iceGatheringState?e.localDescription:new Sl(t=>{e.onicegatheringstatechange=()=>{"complete"===e.iceGatheringState&&t(e.localDescription);};})},t=async(e,t)=>await e.setRemoteDescription(t);try{const i=await e(this.peerPair[0],"offer");await t(this.peerPair[1],i);const n=await e(this.peerPair[1],"answer");await t(this.peerPair[0],n);}catch(e){throw new SE(fE.LOCAL_AEC_ERROR,e.toString()).print()}}async getTracksFromMediaElement(e){if(this.audioTrack)return this.audioTrack;let t;try{e instanceof HTMLVideoElement&&(e.captureStream?e.captureStream():e.mozCaptureStream()),t=this.context.createMediaStreamDestination();this.context.createMediaElementSource(e).connect(t);}catch(e){throw new SE(fE.LOCAL_AEC_ERROR,e.toString()).print()}if(!t){throw new SE(fE.LOCAL_AEC_ERROR,"no dest node when local aec").print()}const i=t.stream.getAudioTracks()[0];return this.audioTrack=i,i}getElement(){return this.element}async startEchoCancellation(){this.context.resume(),this.peerPair&&this.close(),this.initPeers();const e=this.element,t=await this.getTracksFromMediaElement(e);this.peerPair&&this.peerPair[0].addTrack(t),await this.switchSdp();}close(){OE.debug("close echo cancellation unit, id is",this.id),this.audioPlayerElement&&this.audioPlayerElement.pause(),this.peerPair&&this.peerPair.forEach(e=>{e.close();}),this.peerPair=void 0,this.audioPlayerElement=void 0;}}var qD,JD;_p(YD,"count",0);const XD=window.AudioContext||window.webkitAudioContext;const zD=new(qD=Dg({report:Pg}),ag((JD=class{constructor(){_p(this,"units",[]),_p(this,"context",void 0);}processExternalMediaAEC(e){if(!this._doesEnvironmentNeedAEC())return OE.debug("the system does not need to process local aec"),-1;this.context||(this.context=new XD);let t=this.units.find(t=>t&&t.getElement()===e);return t||(t=new YD(e,this.context),this.units.push(t)),t.startEchoCancellation(),OE.debug("start processing local audio echo cancellation, id is",t.id),t.id}_doesEnvironmentNeedAEC(){return xh().name!==wh.SAFARI}}).prototype,"processExternalMediaAEC",[qD],Object.getOwnPropertyDescriptor(JD.prototype,"processExternalMediaAEC"),JD.prototype),JD);function QD(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n);}return i}function ZD(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?QD(Object(i),!0).forEach((function(t){_p(e,t,i[t]);})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):QD(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t));}));}return e}const $D=window||document;function eP(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(!$D)return;const i=tP._cspEventHandlerPointer;if(i&&t)return void console.error(i,t);const n=e=>{if(!(e&&e.blockedURI&&(tP.onSecurityPolicyViolation||tP.getListeners(BS.SECURITY_POLICY_VIOLATION).length>0)))return;const t=e.blockedURI;GE("CSP_DETECTED_HOSTNAME_LIST").some(e=>t.includes(e))&&(tP.onSecurityPolicyViolation&&"function"==typeof tP.onSecurityPolicyViolation&&tP.onSecurityPolicyViolation(e),tP.getListeners(BS.SECURITY_POLICY_VIOLATION).length>0&&tP.safeEmit(BS.SECURITY_POLICY_VIOLATION,e));};i&&$D.removeEventListener("securitypolicyviolation",i),(t||e&&"function"==typeof e||tP.getListeners(BS.SECURITY_POLICY_VIOLATION).length>0)&&$D.addEventListener("securitypolicyviolation",n),tP._cspEventHandlerPointer=n;}BE("PROCESS_ID","process-".concat(ZI(8,""),"-").concat(ZI(4,""),"-").concat(ZI(4,""),"-").concat(ZI(4,""),"-").concat(ZI(12,""))),function(){const e=xh();qS.getDisplayMedia=function(e){if(navigator.mediaDevices&&navigator.mediaDevices.getDisplayMedia)return !0;return !1}(),qS.getStreamFromExtension=e.name===wh.CHROME&&Number(e.version)>34,qS.supportUnifiedPlan=function(){if(!window.RTCRtpTransceiver)return !1;if(!("currentDirection"in RTCRtpTransceiver.prototype))return !1;const e=new RTCPeerConnection;let t=!1;try{e.addTransceiver("audio"),t=!0;}catch(e){}return e.close(),t}(),qS.supportMinBitrate=e.name===wh.CHROME||e.name===wh.EDGE,qS.supportSetRtpSenderParameters=function(){const e=xh();if(!window.RTCRtpSender||!window.RTCRtpSender.prototype.setParameters||!window.RTCRtpSender.prototype.getParameters)return !1;return !!rp()||(!(!Hh()&&!Fh())||e.name===wh.FIREFOX&&Number(e.version)>=64)}(),e.name===wh.SAFARI&&(Number(e.version)>=14?qS.supportDualStream=!0:qS.supportDualStream=!1),qS.webAudioMediaStreamDest=function(){const e=xh();if(e.name===wh.SAFARI&&Number(e.version)<12)return !1;return !0}(),qS.supportReplaceTrack=function(){if(!window.RTCRtpSender)return !1;if("function"==typeof RTCRtpSender.prototype.replaceTrack)return !0;return !1}(),qS.supportWebGL="undefined"!=typeof WebGLRenderingContext,qS.supportRequestFrame=!!window.CanvasCaptureMediaStreamTrack,rp()||(qS.webAudioWithAEC=!0),qS.supportShareAudio=function(){const e=xh();if((e.os===bh.WIN_10||e.os===bh.WIN_81||e.os===bh.WIN_7||e.os===bh.LINUX||e.os===bh.MAC_OS)&&e.name===wh.CHROME&&Number(e.version)>=74)return !0;return !1}(),qS.supportDualStreamEncoding=function(){const e=xh();if(GE("DISABLE_WEBAUDIO"))return !0;return "Safari"===e.name&&Number(e.version)>=14||!!("Chrome"===e.name&&/Windows/i.test(e.os||"")&&Number(e.version)>=100&&GE("CHROME_DUAL_STREAM_USE_ENCODING"))}(),qS.supportDataChannel=function(){if(qh(76)||function(e){const t=xh();return !(t.name!==wh.FIREFOX||!t.osVersion)&&Number(t.version)>=e}(68)||function(e){const t=xh();return !(t.name!==wh.SAFARI||!t.osVersion)&&Number(t.version)>=e}(14))return !0;return !1}(),qS.supportPCSetConfiguration=function(){const e=window.RTCPeerConnection;return !Kh()&&!!e&&e.prototype.setConfiguration instanceof Function}(),qS.supportWebRTCEncodedTransform=function(){const e=xh();return "Chrome"===e.name&&Number(e.version)>=86}(),OE.info("browser compatibility",JSON.stringify(qS),JSON.stringify(e));}(),function(){let e;try{e=window.localStorage.getItem("websdk_ng_global_parameter");}catch(e){return void OE.error("Error loading sdk config",e.message)}if(e)try{const t=JSON.parse(window.atob(e)),i=Date.now();OE.debug("Loading global parameters from cache",t),Object.keys(t).forEach(e=>{if(Object.prototype.hasOwnProperty.call(WE,e)){const{value:n,expires:r}=t[e];if(r&&r<=i)return;HE[e]=n,WE[e]=n;}});}catch(t){OE.error("Error loading mutableParamsCache: ".concat(e),t.message);}}(),Array.isArray(HE.AREAS)&&HE.AREAS.length>0&&qC(HE.AREAS,!0);const tP=function(e){const t=new EE,i=e,n={getListeners:t.getListeners.bind(t),on:(e,i)=>(function(e,t){e===BS.SECURITY_POLICY_VIOLATION&&eP(t,!0);}(e,i),t.on.bind(t)(e,i)),addListener:t.addListener.bind(t),once:t.once.bind(t),off:t.off.bind(t),removeAllListeners:t.removeAllListeners.bind(t),emit:t.emit.bind(t),safeEmit:t.safeEmit.bind(t)};return ZD(ZD({},i),n)}({__CLIENT_LIST__:zE,__TRACK_LIST__:QE,VERSION:bE,BUILD:NE,setParameter:(e,t,i)=>{OE.debug("setParameter key:".concat(e,", value:").concat(JSON.stringify(t))),BE(e,t,i);},getParameter:GE,getSupportedCodec:async function(){let e={audio:[],video:[]};try{let t=new RTCPeerConnection;t.addTransceiver("video",{direction:"recvonly"}),t.addTransceiver("audio",{direction:"recvonly"});const i=(await t.createOffer()).sdp;if(!i)return e;t.close(),t=null,e=function(e){const t={video:[],audio:[]};return e.match(/ VP8/i)&&t.video.push("VP8"),e.match(/ VP9/i)&&t.video.push("VP9"),e.match(/ AV1/i)&&t.video.push("AV1"),e.match(/ H264/i)&&t.video.push("H264"),e.match(/ H265/i)&&t.video.push("H265"),e.match(/ opus/i)&&t.audio.push("OPUS"),e.match(/ PCMU/i)&&t.audio.push("PCMU"),e.match(/ PCMA/i)&&t.audio.push("PCMA"),e.match(/ G722/i)&&t.audio.push("G722"),t}(i);}catch(e){throw new SE(fE.CREATE_OFFER_FAILED,e.toString&&e.toString()).print()}return e},checkSystemRequirements:function(){const e=Pg.reportApiInvoke(null,{name:_f.CHECK_SYSTEM_REQUIREMENTS,options:[],tag:Ef.TRACER});let t=!1;try{const e=window.RTCPeerConnection,i=navigator.mediaDevices&&navigator.mediaDevices.getUserMedia,n=window.WebSocket;t=!!(e&&i&&n);}catch(e){return OE.error("check system requirement failed: ",e),!1}let i=!1;const n=xh();n.name===wh.CHROME&&Number(n.version)>=58&&(!Gh()||Bh())&&(i=!0),n.name===wh.FIREFOX&&Number(n.version)>=56&&(i=!0),n.name===wh.OPERA&&Number(n.version)>=45&&(i=!0),n.name===wh.SAFARI&&Number(n.version)>=11&&(i=!0),(ip()||xh().name===wh.QQ)&&(i=!0),OE.debug("checkSystemRequirements, api:",t,"browser",i);const r=t&&i;return e.onSuccess(r),r},getDevices:function(e){return lR.enumerateDevices(!0,!0,e)},getMicrophones:function(e){return lR.getRecordingDevices(e)},getCameras:function(e){return lR.getCamerasDevices(e)},getElectronScreenSources:eR,getPlaybackDevices:function(e){return lR.getSpeakers(e)},createClient:function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{codec:"vp8",audioCodec:"opus",mode:"rtc"};const t=Pg.reportApiInvoke(null,{name:_f.CREATE_CLIENT,options:[e],tag:Ef.TRACER});try{Mf(e);}catch(e){throw t.onError(e),e}return void 0===e.audioCodec&&(e.audioCodec="opus"),t.onSuccess(),new xD(UD(UD({forceWaitGatewayResponse:!0},e),{},{role:"rtc"===e.mode?"host":e.role||"audience"}))},createCameraVideoTrack:async function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const t=Pg.reportApiInvoke(null,{tag:Ef.TRACER,name:_f.CREATE_CAM_VIDEO_TRACK,options:[GD({},e)]}),i=Mv(e),n=ZI(8,"track-cam-");let r=null;OE.info("start create camera video track with config",JSON.stringify(e),"trackId",n);try{r=(await aR({video:i},n)).getVideoTracks()[0]||null;}catch(e){throw t.onError(e),e}if(!r){const e=new SE(fE.UNEXPECTED_ERROR,"can not find track in media stream");return t.onError(e),e.throw()}e.optimizationMode&&WD(n,r,e,UE(e.encoderConfig));const o=new vy(r,e,i,e.scalabiltyMode?VE(e.scalabiltyMode):{numSpatialLayers:1,numTemporalLayers:1},e.optimizationMode,n);return t.onSuccess(o.getTrackId()),OE.info("create camera video success, trackId:",n),o},createCustomVideoTrack:function(e){const t=Pg.reportApiInvoke(null,{tag:Ef.TRACER,name:_f.CREATE_CUSTOM_VIDEO_TRACK,options:[e]}),i=new Cy(e.mediaStreamTrack,{width:e.width,height:e.height,frameRate:e.frameRate,bitrateMax:e.bitrateMax,bitrateMin:e.bitrateMin},e.scalabiltyMode?VE(e.scalabiltyMode):{numSpatialLayers:1,numTemporalLayers:1},e.optimizationMode,ZI(8,"track-cus-"),[lS.CUSTOM_TRACK]);return t.onSuccess(i.getTrackId()),OE.info("create custom video track success with config",e,"trackId",i.getTrackId()),i},createScreenVideoTrack:async function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"disable";const i=Pg.reportApiInvoke(null,{tag:Ef.TRACER,name:_f.CREATE_SCREEN_VIDEO_TRACK,options:[GD({},e),t]});e.encoderConfig?"string"==typeof e.encoderConfig||e.encoderConfig.width&&e.encoderConfig.height||(e.encoderConfig.width={max:1920},e.encoderConfig.height={max:1080}):e.encoderConfig="1080p_2";const n=Uv(e),r=ZI(8,"track-scr-v-");let o=null,s=null;const a=JS();if(!a.supportShareAudio&&"enable"===t){const e=new SE(fE.NOT_SUPPORTED,"your browser or platform is not support share-screen with audio");return i.onError(e),e.throw()}OE.info("start create screen video track with config",e,"withAudio",t,"trackId",r);try{const e=await aR({screen:n,screenAudio:"auto"===t?a.supportShareAudio:"enable"===t},r);o=e.getVideoTracks()[0]||null,s=e.getAudioTracks()[0]||null;}catch(e){throw i.onError(e),e}if(!o){const e=new SE(fE.UNEXPECTED_ERROR,"can not find track in media stream");return i.onError(e),e.throw()}if(!s&&"enable"===t){o&&o.stop();const e=new SE(fE.SHARE_AUDIO_NOT_ALLOWED);return i.onError(e),e.throw()}e.optimizationMode||(e.optimizationMode="detail"),e.optimizationMode&&(WD(r,o,e,e.encoderConfig&&xE(e.encoderConfig)),e.encoderConfig&&"string"!=typeof e.encoderConfig&&(e.encoderConfig.bitrateMin=e.encoderConfig.bitrateMax));const c=new Cy(o,e.encoderConfig?xE(e.encoderConfig):{},e.scalabiltyMode?VE(e.scalabiltyMode):{numSpatialLayers:1,numTemporalLayers:1},e.optimizationMode,r,[lS.SCREEN_TRACK]);if(!s)return i.onSuccess(c.getTrackId()),OE.info("create screen video track success","video:",c.getTrackId()),c;const d=new yI(s,void 0,ZI(8,"track-scr-a-"),!1,!0);return i.onSuccess([c.getTrackId(),d.getTrackId()]),OE.info("create screen video track success","video:",c.getTrackId(),"audio:",d.getTrackId()),[c,d]},createMicrophoneAndCameraTracks:async function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const i=Pg.reportApiInvoke(null,{tag:Ef.TRACER,name:_f.CREATE_MIC_AND_CAM_TRACKS,options:[e,t]}),n=Mv(t),r=xv(e),o=ZI(8,"track-mic-"),s=ZI(8,"track-cam-");let a=null,c=null;OE.info("start create camera video track(".concat(s,") and microphone audio track(").concat(o,") with config, audio: ").concat(JSON.stringify(e),", video: ").concat(JSON.stringify(t)));try{const e=await aR({audio:r,video:n},"".concat(o,"-").concat(s));a=e.getAudioTracks()[0],c=e.getVideoTracks()[0];}catch(e){throw i.onError(e),e}if(!a||!c){const e=new SE(fE.UNEXPECTED_ERROR,"can not find tracks in media stream");return i.onError(e),e.throw()}t.optimizationMode&&WD(s,c,t,UE(t.encoderConfig));const d=new AI(a,e,r,o),u=new vy(c,t,n,t.scalabiltyMode?VE(t.scalabiltyMode):{numSpatialLayers:1,numTemporalLayers:1},t.optimizationMode,s);return i.onSuccess([d.getTrackId(),u.getTrackId()]),OE.info("create camera video track(".concat(s,") and microphone audio track(").concat(o,") success")),[d,u]},createMicrophoneAudioTrack:async function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const t=Pg.reportApiInvoke(null,{tag:Ef.TRACER,name:_f.CREATE_MIC_AUDIO_TRACK,options:[e]}),i=xv(e),n=ZI(8,"track-mic-");let r=null;OE.info("start create microphone audio track with config",JSON.stringify(e),"trackId",n);try{r=(await aR({audio:i},n)).getAudioTracks()[0]||null;}catch(e){throw t.onError(e),e}if(!r){const e=new SE(fE.UNEXPECTED_ERROR,"can not find track in media stream");return t.onError(e),e.throw()}const o=new AI(r,e,i,n);return t.onSuccess(o.getTrackId()),OE.info("create microphone audio track success, trackId:",n),o},createCustomAudioTrack:function(e){const t=Pg.reportApiInvoke(null,{tag:Ef.TRACER,name:_f.CREATE_CUSTOM_AUDIO_TRACK,options:[e]}),i=new yI(e.mediaStreamTrack,e.encoderConfig?FE(e.encoderConfig):{},ZI(8,"track-cus-"),!1,!0);return OE.info("create custom audio track success with config",e,"trackId",i.getTrackId()),t.onSuccess(i.getTrackId()),i},createBufferSourceAudioTrack:async function(e){const t=Pg.reportApiInvoke(null,{tag:Ef.TRACER,name:_f.CREATE_BUFFER_AUDIO_TRACK,options:[e]});if(GE("DISABLE_WEBAUDIO"))throw new SE(fE.NOT_SUPPORTED,"can not create BufferSourceAudioTrack when WebAudio disabled");const i=ZI(8,"track-buf-");OE.info("start create buffer source audio track with config",JSON.stringify(e),"trackId",i);const n=e.source;if(!(e.source instanceof AudioBuffer))try{e.source=await FD(e.source,e.cacheOnlineFile);}catch(e){return t.onError(e),e.throw()}const r=new VD(e.source),o=new OI(n,r,e.encoderConfig?FE(e.encoderConfig):{},i);return OE.info("create buffer source audio track success, trackId:",i),t.onSuccess(o.getTrackId()),o},setAppType:function(e){if(OE.debug("setAppType: ".concat(e)),!(Number.isInteger(e)&&e>=0))throw OE.debug("Invalid appType"),new SE(fE.INVALID_PARAMS,"invalid app type",e);BE("APP_TYPE",Math.floor(e));},setLogLevel:function(e){OE.setLogLevel(e);},enableLogUpload:function(){GE("USE_NEW_LOG")?BE("UPLOAD_LOG",!0):OE.enableLogUpload();},disableLogUpload:function(){GE("USE_NEW_LOG")?BE("UPLOAD_LOG",!1):OE.disableLogUpload();},createChannelMediaRelayConfiguration:function(){return new vv},checkAudioTrackIsActive:async function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:5e3;const i=Pg.reportApiInvoke(null,{tag:Ef.TRACER,name:_f.CHECK_AUDIO_TRACK_IS_ACTIVE,options:[t]});if(!(e instanceof yI||e instanceof nb)){const e=new SE(fE.INVALID_TRACK,"the parameter is not a audio track");return i.onError(e),e.throw()}t&&t<1e3&&(t=1e3);const n=e instanceof yI?e.getTrackLabel():"remote_track",r=e.getVolumeLevel();let o=r,s=r;const a=Date.now();return new Sl(r=>{const c=setInterval(()=>{const d=e.getVolumeLevel();o=d>o?d:o,s=d<s?d:s;const u=o-s>1e-4,l=Date.now()-a;if(u||l>t){clearInterval(c);const t=u,s={duration:l,deviceLabel:n,maxVolumeLevel:o,result:t};OE.info("[track-".concat(e.getTrackId(),"] check audio track active completed. ").concat(JSON.stringify(s))),i.onSuccess(s),r(t);}},200);})},checkVideoTrackIsActive:async function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:5e3;const i=Pg.reportApiInvoke(null,{tag:Ef.TRACER,name:_f.CHECK_VIDEO_TRACK_IS_ACTIVE,options:[t]});if(!(e instanceof Cy||e instanceof ib)){const e=new SE(fE.INVALID_TRACK,"the parameter is not a video track");return i.onError(e),e.throw()}const n=4;t&&t<1e3&&(t=1e3);const r=e instanceof Cy?e.getTrackLabel():"remote_track",o=e.getMediaStreamTrack(!0),s=document.createElement("video");s.style.width="1px",s.style.height="1px",s.setAttribute("muted",""),s.muted=!0,s.setAttribute("playsinline",""),s.controls=!1,(Hh()||Fh())&&(s.style.opacity="0.01",s.style.position="fixed",s.style.left="0",s.style.top="0",document.body.appendChild(s)),s.srcObject=new MediaStream([o]),s.play();const a=document.createElement("canvas");a.width=160,a.height=120;let c=0,d=0;try{const e=Date.now();c=await KD(s,t,a,n),d=Date.now()-e;}catch(e){throw i.onError(e),e}HD===wh.SAFARI&&(s.pause(),s.remove()),s.srcObject=null;const u=c>n,l={duration:d,changedPicNum:c,deviceLabel:r,result:u};return OE.info("[track-".concat(e.getTrackId(),"] check video track active completed. ").concat(JSON.stringify(l))),i.onSuccess(l),u},setArea:qC,audioElementPlayCenter:pR,processExternalMediaAEC:function(e){zD.processExternalMediaAEC(e);},registerExtensions:function(e){e.forEach(e=>{const t=e;t.__registered__=!0,t.logger.hookLog=OE.extLog,t.reporter.hookApiInvoke=Pg.extApiInvoke,t.parameters&&Object.keys(t.parameters).forEach(e=>{t.parameters[e]=GE(e);});});},ChannelMediaRelayError:oS,ChannelMediaRelayEvent:nS,ChannelMediaRelayState:rS,RemoteStreamFallbackType:_S,RemoteStreamType:pS,ConnectionDisconnectedReason:vf,AudienceLatencyLevelType:Cf,AREAS:SS});return Object.defineProperties(tP,{onAudioAutoplayFailed:{get:()=>vg.onAudioAutoplayFailed,set:e=>{vg.onAudioAutoplayFailed=e;}},onAutoplayFailed:{get:()=>vg.onAutoplayFailed,set:e=>{vg.onAutoplayFailed=e;}},_onSecurityPolicyViolation:{value:void 0,writable:!0},_cspEventHandlerPointer:{value:void 0,writable:!0},onSecurityPolicyViolation:{get:()=>tP._onSecurityPolicyViolation,set(e){tP._onSecurityPolicyViolation=e,eP(e);}}}),lR.on(ff.CAMERA_DEVICE_CHANGED,e=>{OE.info("camera device changed",JSON.stringify(e)),tP.onCameraChanged&&tP.onCameraChanged(e),tP.safeEmit(BS.CAMERA_CHANGED,e);}),lR.on(ff.RECORDING_DEVICE_CHANGED,e=>{OE.info("microphone device changed",JSON.stringify(e)),tP.onMicrophoneChanged&&tP.onMicrophoneChanged(e),tP.safeEmit(BS.MICROPHONE_CHANGED,e);}),lR.on(ff.PLAYOUT_DEVICE_CHANGED,e=>{OE.debug("playout device changed",JSON.stringify(e)),tP.onPlaybackDeviceChanged&&tP.onPlaybackDeviceChanged(e),tP.safeEmit(BS.PLAYBACK_DEVICE_CHANGED,e);}),pR.onAutoplayFailed=()=>{OE.info("detect audio element autoplay failed"),vg.onAudioAutoplayFailed&&vg.onAudioAutoplayFailed();},Gg.on("autoplay-failed",()=>{OE.info("detect webaudio autoplay failed"),vg.onAudioAutoplayFailed&&vg.onAudioAutoplayFailed(),tP.safeEmit(BS.AUTOPLAY_FAILED);}),window&&(window.__ARTC__=tP),tP}));
}(AgoraRTC_NProduction));

var AgoraRTC$1 = /*@__PURE__*/getDefaultExportFromCjs(AgoraRTC_NProduction.exports);const DevicePlatform = {
  Unknown: 'unknown',
  IOS: 'ios',
  Android: 'android',
  WindowsPhone: 'windowsPhone',
  VRHeadset: 'vrHeadset'
};
class DeviceService {
  static get platform() {
    if (!this.platform_) {
      this.platform_ = this.getDevicePlatform();
    }
    return this.platform_;
  }
  static get isIOS() {
    return ['iPad Simulator', 'iPhone Simulator', 'iPod Simulator', 'iPad', 'iPhone', 'iPod'].indexOf(navigator.platform) !== -1
    // iPad on iOS 13 detection
    || navigator.userAgent.indexOf('Mac') !== -1 && 'ontouchend' in document;
  }
  static get isVRHeadset() {
    return navigator.userAgent.indexOf('VR') !== -1 || navigator.userAgent.indexOf('Quest') !== -1 || navigator.userAgent.indexOf('Oculus') !== -1;
  }
  static getDevicePlatform() {
    const userAgent = navigator.userAgent || navigator.vendor || window.opera;
    // Windows Phone must come first because its UA also contains 'Android'
    if (/windows phone/i.test(userAgent)) {
      return DevicePlatform.WindowsPhone;
    }
    if (/android/i.test(userAgent)) {
      return DevicePlatform.Android;
    }
    // iOS detection from: http://stackoverflow.com/a/9039885/177710
    // if (/iPad|iPhone|iPod/.test(userAgent) && !window.MSStream) {
    if (this.isIOS) {
      return DevicePlatform.IOS;
    }
    if (this.isVRHeadset) {
      return DevicePlatform.VRHeadset;
    }
    return DevicePlatform.Unknown;
  }
}class Emittable$1 {
  constructor() {
    this.events = {};
  }
  on(type, callback) {
    const event = this.events[type] = this.events[type] || [];
    event.push(callback);
    return () => {
      this.events[type] = event.filter(x => x !== callback);
    };
  }
  off(type, callback) {
    const event = this.events[type];
    if (event) {
      this.events[type] = event.filter(x => x !== callback);
    }
  }
  once(type, callback) {
    const once = data => {
      callback(data);
      this.off(type, once);
    };
    this.on(type, once);
  }
  emit(type, data) {
    const event = this.events[type];
    if (event) {
      event.forEach(callback => {
        // callback.call(this, data);
        callback(data);
      });
    }
    const broadcast = this.events.broadcast;
    if (broadcast) {
      broadcast.forEach(callback => {
        callback(type, data);
      });
    }
  }
  has(type) {
    const callbacks = this.events[type];
    return callbacks && callbacks.length;
  }
}const LoggerLevel = {
  NONE: 0,
  ERROR: 1,
  WARN: 2,
  INFO: 3,
  LOG: 4,
  ALL: 5
};
class Logger {
  static setLevel(level) {
    this.level_ = level;
  }
  static getLevel() {
    if (environment.flags.production) {
      return LoggerLevel.ERROR;
    } else {
      return this.level_;
    }
  }
  static error() {
    if (this.getLevel() >= LoggerLevel.ERROR) {
      console.error(...arguments);
    }
  }
  static warn() {
    if (this.getLevel() >= LoggerLevel.WARN) {
      console.warn(...arguments);
    }
  }
  static info() {
    if (this.getLevel() >= LoggerLevel.INFO) {
      console.info(...arguments);
    }
  }
  static log() {
    if (this.getLevel() >= LoggerLevel.LOG) {
      console.log(...arguments);
    }
  }
}
Logger.level_ = LoggerLevel.ALL;class SessionStorageService {
  static delete(name) {
    if (this.isSessionStorageSupported()) {
      window.sessionStorage.removeItem(name);
    }
  }
  static exist(name) {
    if (this.isSessionStorageSupported()) {
      return window.sessionStorage[name] !== undefined;
    }
  }
  static get(name) {
    let value = null;
    if (this.isSessionStorageSupported() && window.sessionStorage[name] !== undefined) {
      try {
        value = JSON.parse(window.sessionStorage[name]);
      } catch (e) {
        console.log('SessionStorageService.get.error parsing', name, e);
      }
    }
    return value;
  }
  static set(name, value) {
    if (this.isSessionStorageSupported()) {
      try {
        const cache = [];
        const json = JSON.stringify(value, function (key, value) {
          if (typeof value === 'object' && value !== null) {
            if (cache.indexOf(value) !== -1) {
              // Circular reference found, discard key
              return;
            }
            cache.push(value);
          }
          return value;
        });
        window.sessionStorage.setItem(name, json);
      } catch (e) {
        console.log('SessionStorageService.set.error serializing', name, value, e);
      }
    }
  }
  static isSessionStorageSupported() {
    if (this.supported) {
      return true;
    }
    let supported = false;
    try {
      supported = 'sessionStorage' in window && window.sessionStorage !== null;
      if (supported) {
        window.sessionStorage.setItem('test', '1');
        window.sessionStorage.removeItem('test');
      } else {
        supported = false;
      }
    } catch (e) {
      supported = false;
    }
    this.supported = supported;
    return supported;
  }
}class Stream {
  /**
   *
   * @param {IAgoraRTCRemoteUser} user
   * @param {'audio' | 'video'} mediaType
   * @param {boolean} isLocal
   */
  constructor(user, mediaType, isLocal) {
    if (isLocal === void 0) {
      isLocal = false;
    }
    this.user = user;
    this.mediaType = mediaType;
    this.isLocal = isLocal;
    this.clientInfo = null;
    this.texture = null;
    this.element = null;
    this.parentNode = null;
  }
  get streamId() {
    return this.user?.uid.toString();
  }
  get hasVideo() {
    return this.user?.hasVideo;
  }
  get hasAudio() {
    return this.user?.hasAudio;
  }
  get videoTrack() {
    return this.user?.videoTrack;
  }
  get audioTrack() {
    return this.user?.audioTrack;
  }
  get video() {
    return this.videoTrack ? true : false;
  }
  get audio() {
    return this.audioTrack ? true : false;
  }
  get userMuteVideo() {
    // return this.videoTrack ? !this.videoTrack.enabled : false;
    return this.videoTrack ? this.videoTrack.muted : false;
  }
  get userMuteAudio() {
    // return this.audioTrack ? !this.audioTrack.enabled : false;
    return this.audioTrack ? this.audioTrack.muted : false;
  }
  getTracks() {
    const tracks = [];
    if (this.user.hasVideo) {
      tracks.push(this.videoTrack);
    }
    if (this.user.hasAudio) {
      tracks.push(this.audioTrack);
    }
    return tracks;
  }
  async muteVideo() {
    if (this.videoTrack) {
      // await this.videoTrack.setEnabled(true);
      await this.videoTrack.setMuted(true);
    }
  }
  async unmuteVideo() {
    if (this.videoTrack) {
      // await this.videoTrack.setEnabled(false);
      await this.videoTrack.setMuted(false);
    }
  }
  async muteAudio() {
    if (this.audioTrack) {
      // await this.audioTrack.setEnabled(true);
      await this.audioTrack.setMuted(true);
    }
  }
  async unmuteAudio() {
    if (this.audioTrack) {
      // await this.audioTrack.setEnabled(false);
      await this.audioTrack.setMuted(false);
    }
  }

  /*
  getIsSpeakingUser() {
  	return this.getAudioLevel() > 0.6 ? 1 : 0;
  }
  */

  getAudioLevel() {
    return this.audioTrack ? this.audioTrack.getVolumeLevel() : 0;
  }
  isPlaying() {
    return this.videoTrack?.isPlaying || this.audioTrack?.isPlaying;
  }
  play(parentNode) {
    while (parentNode.childElementCount > 0) {
      parentNode.removeChild(parentNode.firstElementChild);
    }
    this.parentNode = parentNode;
    if (this.mediaType === 'video') {
      this.videoTrack.play(parentNode, {
        fit: 'cover',
        mirror: undefined
      });
      this.element = parentNode.firstElementChild;
      Logger.log('Stream.play.videoTrack', parentNode, this.element);
    } else if (this.audioTrack && !this.isLocal) {
      this.audioTrack.play();
    }
  }
  stop() {
    if (this.videoTrack && this.videoTrack.isPlaying) {
      this.videoTrack.stop();
    }
    if (this.audioTrack && this.audioTrack.isPlaying) {
      this.audioTrack.stop();
    }
  }
  close() {
    if (this.videoTrack) {
      this.videoTrack.close();
    }
    if (this.audioTrack) {
      this.audioTrack.close();
    }
  }
  update(stream) {
    this.user = stream.user;
    this.mediaType = stream.mediaType;
    /*
    if (this.parentNode) {
    	this.play(this.parentNode);
    }
    */
  }

  resume(parentNode) {
    Logger.log('Stream.resume', parentNode, this.element);
    if (this.element) {
      parentNode.appendChild(this.element);
    }
  }
}const StreamServiceMode = {
  Client: 'client',
  Editor: 'editor'
};
class StreamService {
  static set editorStreams(editorStreams) {
    this.editorStreams$.next(editorStreams);
  }
  static get editorStreams() {
    return this.editorStreams$.getValue();
  }
  static set editorScreens(editorScreens) {
    this.editorScreens$.next(editorScreens);
  }
  static get editorScreens() {
    return this.editorScreens$.getValue();
  }

  /** @type {BehaviorSubject<Stream | null>} */

  static set local(local) {
    this.local$.next(local);
  }
  static get local() {
    return this.local$.getValue();
  }

  /** @type {BehaviorSubject<Stream | null>} */

  static set screen(screen) {
    this.screen$.next(screen);
  }
  static get screen() {
    return this.screen$.getValue();
  }

  /** @type {BehaviorSubject<Stream[]>} */

  static set remotes(remotes) {
    this.remotes$.next(remotes);
  }
  static get remotes() {
    return this.remotes$.getValue();
  }

  /** @type {BehaviorSubject<{ uid: string }[]>} */

  static set peers(peers) {
    this.peers$.next(peers);
  }
  static get peers() {
    return this.peers$.getValue();
  }
  static orderedRemotes$() {
    return rxjs.combineLatest([StreamService.remotes$, rxjs.interval(1000)]).pipe(operators.map(datas => {
      const orderedRemotes = [];
      const remotes = datas[0];
      remotes.forEach(remote => {
        let role = null,
          uid = null,
          screenUid = null,
          audioLevel = 0,
          peekAudioLevel = 0,
          order = 0;
        if (remote.clientInfo) {
          audioLevel = remote.clientInfo.audioLevel = remote.getAudioLevel();
          peekAudioLevel = remote.clientInfo.peekAudioLevel = Math.max(remote.clientInfo.audioLevel, 0.2);
          order = remote.clientInfo.order;
          role = remote.clientInfo.role || null;
          uid = remote.clientInfo.uid || null;
          screenUid = remote.clientInfo.screenUid || null;
        }
        orderedRemotes.push({
          role,
          uid,
          screenUid,
          audioLevel,
          peekAudioLevel,
          order,
          remote
        });
      });
      orderedRemotes.sort((a, b) => {
        const av = a.role === RoleType.Publisher ? 2 : a.role === RoleType.Attendee ? 1 : 0;
        const bv = b.role === RoleType.Publisher ? 2 : b.role === RoleType.Attendee ? 1 : 0;
        return bv - av || b.peekAudioLevel - a.peekAudioLevel || (a.order || 0) - (b.order || 0);
      });
      orderedRemotes.forEach((x, i) => {
        if (x.remote.clientInfo) {
          x.remote.clientInfo.order = i;
        }
      });
      return orderedRemotes;
    }), operators.distinctUntilChanged((a, b) => {
      const auid = a.map(x => `${x.uid}-${x.screenUid}`).join('|');
      const buid = b.map(x => `${x.uid}-${x.screenUid}`).join('|');
      // console.log('StreamService.orderedRemotes$', auid, buid);
      return auid === buid;
    }), operators.map(remotes => remotes.map(x => x.remote)));
  }
  static getEditorStreams$() {
    return rxjs.of(null).pipe(operators.switchMap(() => {
      if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia && this.mode === StreamServiceMode.Editor) {
        const body = document.querySelector('body');
        const media = document.createElement('div');
        const video = document.createElement('video');
        media.setAttribute('id', 'stream-editor');
        media.setAttribute('style', 'position:absolute; top: 5000px; line-height: 0;');
        media.appendChild(video);
        body.appendChild(media);
        navigator.mediaDevices.getUserMedia({
          video: {
            width: 800,
            height: 450
          }
        }).then(stream => {
          // console.log(stream);
          if ('srcObject' in video) {
            video.srcObject = stream;
          } else {
            video.src = window.URL.createObjectURL(stream);
          }
          video.oncanplay = () => {
            const fakePublisherStream = {
              streamId: 'editor',
              clientInfo: {
                role: RoleType.Publisher,
                uid: 'editor'
              }
            };
            const fakeAttendeeStream = {
              streamId: 'editor',
              clientInfo: {
                role: RoleType.Attendee,
                uid: 'editor'
              }
            };
            const fakeSmartDeviceStream = {
              streamId: 'editor',
              clientInfo: {
                role: RoleType.SmartDevice,
                uid: 'editor'
              }
            };
            this.editorStreams$.next([fakePublisherStream, fakeAttendeeStream, fakeAttendeeStream, fakeAttendeeStream, fakeAttendeeStream, fakeSmartDeviceStream]);
            // StreamService.editorStreams = [fakePublisherStream, fakeAttendeeStream, fakeAttendeeStream, fakeAttendeeStream, fakeAttendeeStream];
          };

          video.play();
        }).catch(error => {
          console.log('EditorComponent.getUserMedia.error', error.name, error.message);
        });
      }
      return this.editorStreams$;
    }), operators.shareReplay(1));
  }
  static getEditorScreens$() {
    return rxjs.of(null).pipe(operators.switchMap(() => {
      if (navigator.mediaDevices && navigator.mediaDevices.getDisplayMedia && this.mode === StreamServiceMode.Editor) {
        const body = document.querySelector('body');
        const media = document.createElement('div');
        const video = document.createElement('video');
        media.setAttribute('id', 'stream-editor-screen');
        media.setAttribute('style', 'position:absolute; top: 5000px; line-height: 0;');
        media.appendChild(video);
        body.appendChild(media);
        navigator.mediaDevices.getDisplayMedia({
          screen: {
            width: 800,
            height: 450
          }
        }).then(stream => {
          // console.log(stream);
          if ('srcObject' in video) {
            video.srcObject = stream;
          } else {
            video.src = window.URL.createObjectURL(stream);
          }
          video.oncanplay = () => {
            const fakePublisherScreen = {
              streamId: 'editor-screen',
              clientInfo: {
                role: RoleType.Publisher,
                uid: 'editor',
                screenUid: 'editor-screen'
              }
            };
            const fakeAttendeeScreen = {
              streamId: 'editor-screen',
              clientInfo: {
                role: RoleType.Attendee,
                uid: 'editor',
                screenUid: 'editor-screen'
              }
            };
            this.editorScreens$.next([fakePublisherScreen, fakeAttendeeScreen]);
          };
          video.play();
        }).catch(error => {
          console.log('EditorComponent.getUserMedia.error', error.name, error.message);
        });
      }
      return this.editorScreens$;
    }), operators.shareReplay(1));
  }
  static get publisherStreamId() {
    const streams = this.remotes.slice();
    const local = this.local;
    if (local) {
      streams.unshift(local);
    }
    const publisherStream = streams.find(x => x.clientInfo && x.clientInfo.role === RoleType.Publisher && x.clientInfo.uid === x.streamId);
    if (publisherStream) {
      return publisherStream.streamId;
    }
    return null;
  }
  static getPublisherStreamId$() {
    const publisherStreamId = this.publisherStreamId;
    if (publisherStreamId) {
      return rxjs.of(publisherStreamId);
    } else {
      return this.streams$.pipe(operators.map(() => this.publisherStreamId), operators.filter(x => x));
    }
  }
  static get attendeeStreamId() {
    const streams = this.remotes.slice();
    const local = this.local;
    if (local) {
      streams.unshift(local);
    }
    const attendeeStream = streams.find(x => x.clientInfo && x.clientInfo.role === RoleType.Attendee && x.clientInfo.uid === x.streamId);
    if (attendeeStream) {
      return attendeeStream.streamId;
    }
    return null;
  }
  static getAttendeeStreamId$() {
    const attendeeStreamId = this.attendeeStreamId;
    if (attendeeStreamId) {
      return rxjs.of(attendeeStreamId);
    } else {
      return this.streams$.pipe(operators.map(() => this.attendeeStreamId), operators.filter(x => x));
    }
  }
  static getRemoteById(streamId) {
    // console.log('StreamService.getRemoteById', streamId);
    const remotes = StreamService.remotes;
    const remote = remotes.find(x => x.streamId === streamId);
    if (remote) {
      return remote;
    }
  }
  static remoteAdd(stream) {
    const remotes = this.remotes.slice();
    const remote = remotes.find(x => x.streamId === stream.streamId);
    if (remote) {
      remote.update(stream);
    } else {
      remotes.push(stream);
    }
    this.remotes = remotes;
  }
  static remoteRemove(streamId) {
    const remotes = this.remotes.slice();
    const remote = remotes.find(x => x.streamId === streamId);
    // console.log('StreamService.remoteRemove', streamId, remote);
    if (remote) {
      remote.stop();
      remotes.splice(remotes.indexOf(remote), 1);
      this.remotes = remotes;
    }
    return remote;
  }
  static remoteSetClientInfo(remoteId, clientInfo) {
    const remotes = this.remotes;
    const remote = remotes.find(x => x.streamId === remoteId);
    if (remote) {
      remote.clientInfo = clientInfo;
    }
    this.remotes = remotes;
  }
}
StreamService.mode = StreamServiceMode.Client;
StreamService.editorStreams$ = new rxjs.BehaviorSubject(null);
StreamService.editorScreens$ = new rxjs.BehaviorSubject(null);
StreamService.local$ = new rxjs.BehaviorSubject(null);
StreamService.screen$ = new rxjs.BehaviorSubject(null);
StreamService.remotes$ = new rxjs.BehaviorSubject([]);
StreamService.peers$ = new rxjs.BehaviorSubject([]);
StreamService.streams$ = rxjs.combineLatest([StreamService.local$, StreamService.screen$, StreamService.remotes$, StreamService.getEditorStreams$(), StreamService.getEditorScreens$()]).pipe(operators.map(data => {
  const local = data[0];
  const screen = data[1];
  const remotes = data[2];
  const editorStreams = data[3];
  const editorScreens = data[4];
  let streams = remotes;
  if (local) {
    // my stream
    streams = streams.slice();
    streams.push(local);
  }
  if (screen) {
    // my screen
    streams = streams.slice();
    streams.push(screen);
  }
  if (editorStreams) {
    // editor streams
    streams.push(...editorStreams);
  }
  if (editorScreens) {
    // editor screens
    streams.push(...editorScreens);
  }
  return streams;
}), operators.shareReplay(1));class AgoraService extends Emittable$1 {
  static getSingleton(defaultDevices) {
    if (DEBUG) {
      return;
    }
    if (!this.AGORA) {
      this.AGORA = new AgoraService(defaultDevices);
    }
    return this.AGORA;
  }
  constructor(defaultDevices) {
    if (AgoraService.AGORA) {
      throw 'AgoraService is a singleton';
    }
    super();
    this.previousMuteAudio_ = false;
    this.channelState = {};
    this.channelSnapshot = {};
    this.onException = this.onException.bind(this);
    this.onUserJoined = this.onUserJoined.bind(this);
    this.onUserLeft = this.onUserLeft.bind(this);
    this.onUserPublished = this.onUserPublished.bind(this);
    this.onUserUnpublished = this.onUserUnpublished.bind(this);
    this.onUserInfoUpdated = this.onUserInfoUpdated.bind(this);
    /*
    this.onStreamAdded = this.onStreamAdded.bind(this);
    this.onStreamRemoved = this.onStreamRemoved.bind(this);
    this.onStreamSubscribed = this.onStreamSubscribed.bind(this);
    this.onMuteVideo = this.onMuteVideo.bind(this);
    this.onUnmuteVideo = this.onUnmuteVideo.bind(this);
    this.onMuteAudio = this.onMuteAudio.bind(this);
    this.onUnmuteAudio = this.onUnmuteAudio.bind(this);
    */
    this.onVolumeIndicator = this.onVolumeIndicator.bind(this);
    this.onConnectionStateChange = this.onConnectionStateChange.bind(this);
    this.onTokenPrivilegeWillExpire = this.onTokenPrivilegeWillExpire.bind(this);
    this.onTokenPrivilegeDidExpire = this.onTokenPrivilegeDidExpire.bind(this);
    this.onMessage = this.onMessage.bind(this);
    const state = StateService.state;
    StateService.patchState({
      devices: state.role !== RoleType.Attendee && defaultDevices ? defaultDevices : {
        videos: [],
        audios: []
      },
      quality: getStreamQuality(state),
      membersCount: 0
    });
  }
  get isHostRole() {
    return StateService.state.role === RoleType.Publisher || StateService.state.role === RoleType.Attendee;
  }
  get isAudienceRole() {
    return StateService.state.role === RoleType.Viewer || StateService.state.role === RoleType.SelfService;
  }
  addStreamDevice(src) {
    this.removeStreamDevice();
    const video = {
      deviceId: 'video-stream',
      label: 'videostream',
      kind: 'videostream',
      src: src
    };
    const audio = {
      deviceId: 'audio-stream',
      label: 'videostream',
      kind: 'videostream',
      src: src
    };
    const devices = StateService.state.devices;
    devices.videos.push(video);
    devices.audios.push(audio);
    StateService.patchState({
      devices: devices
    });
  }
  removeStreamDevice() {
    const devices = StateService.state.devices;
    devices.videos = devices.videos.filter(x => x.kind !== 'videostream');
    devices.audios = devices.audios.filter(x => x.kind !== 'videostream');
    StateService.patchState({
      devices: devices
    });
  }
  devices$() {
    const inputs = StateService.state.devices;
    const defaultVideos = this.defaultVideos = this.defaultVideos || inputs.videos.slice();
    const defaultAudios = this.defaultAudios = this.defaultAudios || inputs.videos.slice();
    inputs.videos = defaultVideos.slice();
    inputs.audios = defaultAudios.slice();
    const devices = async () => {
      const videoTrack = await AgoraRTC$1.createCameraVideoTrack();
      const audioTrack = await AgoraRTC$1.createMicrophoneAudioTrack();
      const devices = await AgoraService.getDevices();
      // Logger.log('AgoraService.devices$.getDevices', devices);
      videoTrack.close();
      audioTrack.close();
      for (let i = 0; i < devices.length; i++) {
        const device = devices[i];
        // Logger.log('AgoraService.devices$', device.deviceId);
        if (device.kind === 'videoinput' && device.deviceId) {
          inputs.videos.push({
            label: device.label || 'camera-' + inputs.videos.length,
            deviceId: device.deviceId,
            kind: device.kind
          });
        }
        if (device.kind === 'audioinput' && device.deviceId) {
          inputs.audios.push({
            label: device.label || 'microphone-' + inputs.audios.length,
            deviceId: device.deviceId,
            kind: device.kind
          });
        }
      }
      if (inputs.videos.length > 0 || inputs.audios.length > 0) {
        return inputs;
      } else {
        throw inputs;
      }
    };
    return rxjs.from(devices());
  }
  async connect(preferences) {
    if (!StateService.state.connecting) {
      const devices = StateService.state.devices;
      if (preferences) {
        devices.video = preferences.video;
        devices.audio = preferences.audio;
      }
      // Logger.log('AgoraService.connect', preferences, devices);
      StateService.patchState({
        status: AgoraStatus.Connecting,
        connecting: true,
        devices
      });
      setTimeout(async () => {
        await this.createClient();
        const channelNameLink = this.getChannelNameLink();
        AgoraService.rtcToken$(channelNameLink).subscribe(async token => {
          Logger.log('AgoraService.rtcToken$', token);
          await this.join(token.token, channelNameLink);
        });
      }, 250);
    }
    return StateService.state$;
  }
  connect$(preferences) {
    return rxjs.from(this.connect(preferences)).pipe(operators.switchMap(() => StateService.state$));
  }
  membersCount$(channelId) {
    const messageClient = this.messageClient;
    return rxjs.interval(3000).pipe(operators.switchMap(() => rxjs.from(messageClient.getChannelMemberCount([channelId]))), operators.map(counters => counters[channelId]), operators.catchError(error => {
      Logger.error('AgoraService.membersCount$.error', error);
      return rxjs.of(0);
    }), operators.distinctUntilChanged());
  }
  observeMemberCount() {
    this.unobserveMemberCount();
    // !!! perf
    // only host roles collect membersCount to reduce call/sec.
    if (this.isHostRole) {
      this.membersCountSubscription = this.membersCount$(StateService.state.channelNameLink).subscribe(membersCount => {
        StateService.patchState({
          membersCount: membersCount
        });
      });
    }
  }
  unobserveMemberCount() {
    if (this.membersCountSubscription) {
      this.membersCountSubscription.unsubscribe();
      this.membersCountSubscription = null;
      StateService.patchState({
        membersCount: 0
      });
    }
  }
  async createClient() {
    if (this.client) {
      return this.client;
    }
    try {
      /*
      0: DEBUG. Output all API logs.
      1: INFO. Output logs of the INFO, WARNING and ERROR level.
      2: WARNING. Output logs of the WARNING and ERROR level.
      3: ERROR. Output logs of the ERROR level.
      4: NONE. Do not output any log.
      */
      AgoraRTC$1.setLogLevel(2);
      const client = this.client = AgoraRTC$1.createClient({
        mode: 'live',
        codec: 'h264'
      }); // rtc, vp8
      client.on('exception', this.onException);
      client.on('user-joined', this.onUserJoined);
      client.on('user-left', this.onUserLeft);
      client.on('user-published', this.onUserPublished);
      client.on('user-unpublished', this.onUserUnpublished);
      client.on('user-info-updated', this.onUserInfoUpdated);
      /*
      client.on('stream-added', this.onStreamAdded);
      client.on('stream-removed', this.onStreamRemoved);
      client.on('stream-subscribed', this.onStreamSubscribed);
      client.on('mute-video', this.onMuteVideo);
      client.on('unmute-video', this.onUnmuteVideo);
      client.on('mute-audio', this.onMuteAudio);
      client.on('unmute-audio', this.onUnmuteAudio);
      */
      if (USE_VOLUME_INDICATOR) ;
      // client.on('connection-state-change', this.onConnectionStateChange);
      client.on('onTokenPrivilegeWillExpire', this.onTokenPrivilegeWillExpire);
      client.on('onTokenPrivilegeDidExpire', this.onTokenPrivilegeDidExpire);
      // Logger.log('AgoraService.createClient', 'agora rtm sdk version: ' + AgoraRTM.VERSION + ' compatible');
      if (USE_RTM) {
        /*
        AgoraRTM.LOG_FILTER_OFF
        AgoraRTM.LOG_FILTER_ERROR
        AgoraRTM.LOG_FILTER_INFO (Default)
        AgoraRTM.LOG_FILTER_WARNING
        */
        const messageClient = this.messageClient = AgoraRTM.createInstance(environment.appKey, {
          logFilter: AgoraRTM.LOG_FILTER_OFF
        }); // LOG_FILTER_DEBUG
        messageClient.setParameters({
          logFilter: AgoraRTM.LOG_FILTER_OFF
        });
        Logger.log('AgoraService.createClient', 'client initialized');
        // messageClient.on('ConnectionStateChanged', Logger.warn);
        // messageClient.on('MessageFromPeer', Logger.log);
      }

      await client.setClientRole(this.isAudienceRole ? 'audience' : 'host'); // 'audience' | 'host', AUDIENCE_LEVEL_LOW_LATENCY = 1
      if (environment.flags.useProxy) {
        client.startProxyServer(3);
        /*
        3: The cloud proxy for the UDP protocol, that is, the Force UDP cloud proxy mode. In this mode, the SDK always transmits data over UDP.
        5: The cloud proxy for the TCP (encryption) protocol, that is, the Force TCP cloud proxy mode. In this mode, the SDK always transmits data over TLS 443.
        Note: As of v4.15.0, the default value of mode is 3.
        */
        Logger.log('AgoraService.createClient.startProxyServer');
      }
    } catch (error) {
      Logger.error('AgoraService.createClient.error', error);
      this.client = null;
    }
    return this.client;
  }
  getChannelNameLink() {
    let link = StateService.state.link || '';
    const match = link.match(/(\d{9})-(\d{4})-(\d{13})/);
    if (match) {
      link = `${match[1]}-${match[3]}`;
    }
    const channelName = StateService.state.channelName;
    const channelNameLink = `${channelName}-${link}`;
    // Logger.log('AgoraService.getChannelNameLink', channelNameLink);
    return channelNameLink;
  }
  static getUniqueUserId() {
    // max safe integer 9007199254740991 length 16
    // max allowed integer 4294967296 2^32
    // const m = 9007199254740991;
    const mult = 10000000000000;
    const a = (1 + Math.floor(Math.random() * 8)) * 100;
    const b = (1 + Math.floor(Math.random() * 8)) * 10;
    const c = (1 + Math.floor(Math.random() * 8)) * 1;
    const combo = a + b + c;
    const date = Date.now();
    const uid = combo * mult + date;
    // Logger.log('AgoraService.getUniqueUserId', combo);
    // Logger.log('AgoraService.getUniqueUserId', date);
    // Logger.log('AgoraService.getUniqueUserId', m);
    // Logger.log('AgoraService.getUniqueUserId', uid);
    return uid.toString();
  }
  async join(token, channelNameLink) {
    this.channel = null;
    const client = this.client;
    const clientId = SessionStorageService.get('bHereClientId') || AgoraService.getUniqueUserId();
    Logger.log('AgoraService.join', {
      token,
      channelNameLink,
      clientId
    });
    try {
      const uid = await client.join(environment.appKey, channelNameLink, token, clientId);
      // Logger.log('AgoraService.join', uid);
      StateService.patchState({
        status: AgoraStatus.Connected,
        channelNameLink,
        connected: true,
        uid: uid
      });
      SessionStorageService.set('bHereClientId', uid);
      if (USE_RTM) {
        AgoraService.rtmToken$(uid).subscribe(async token => {
          // Logger.log('AgoraService.join.rtmToken$', token);
          try {
            await this.joinMessageChannel(token.token, uid);
            // Logger.log('AgoraService.join.joinMessageChannel.success', success);
            if (!this.isAudienceRole) {
              const devices = await this.autoDetectDevice();
              await this.createMediaStream(uid, devices.video, devices.audio);
            }
            this.observeMemberCount();
          } catch (error) {
            Logger.error('AgoraService.join.joinMessageChannel.error', error);
          }
        });
      }
    } catch (error) {
      Logger.error('AgoraService.join.error', error);
      if (error === 'DYNAMIC_KEY_EXPIRED') {
        AgoraService.rtcToken$(channelNameLink).subscribe(async token => {
          await this.join(token.token, channelNameLink);
        });
      }
    }
  }
  joinMessageChannel(token, uid) {
    let channel;
    return new Promise((resolve, reject) => {
      const messageClient = this.messageClient;
      Logger.log('AgoraService.joinMessageChannel', messageClient);
      messageClient.login({
        token: token,
        uid: uid.toString()
      }).then(() => {
        Logger.log('AgoraService.joinMessageChannel.login.success');
        channel = messageClient.createChannel(StateService.state.channelNameLink);
        return channel.join();
      }).then(() => {
        this.channel = channel;
        channel.on('ChannelMessage', this.onMessage);
        this.emit('channel', channel);
        // Logger.log('AgoraService.joinMessageChannel.success');
        resolve(uid);
        Logger.log('AgoraService.joinMessageChannel.join.success');
        channel.getMembers().then(members => {
          members = members.filter(x => x !== uid.toString());
          const message = {
            type: MessageType.ChannelMembers,
            members
          };
          this.broadcastMessage(message);
          Logger.log('AgoraService.joinMessageChannel.members', message);
        });
        Logger.log('AgoraService.joinMessageChannel', StateService.state.channelNameLink);
      }).catch(error => {
        Logger.error('AgoraService.joinMessageChannel.error', error);
        reject(error);
      });
    });
  }
  detectDevices(next) {
    AgoraService.getDevices().then(devices => {
      const videos = [];
      const audios = [];
      for (let i = 0; i < devices.length; i++) {
        const device = devices[i];
        if ('videoinput' == device.kind) {
          videos.push({
            label: device.label || 'camera-' + videos.length,
            deviceId: device.deviceId,
            kind: device.kind
          });
        }
        if ('audioinput' == device.kind) {
          audios.push({
            label: device.label || 'microphone-' + videos.length,
            deviceId: device.deviceId,
            kind: device.kind
          });
        }
      }
      next({
        videos: videos,
        audios: audios
      });
    }).catch(error => {
      Logger.error('AgoraService.detectDevices', error);
    });
  }
  getVideoOptions(options, video) {
    return new Promise((resolve, reject) => {
      if (video) {
        if (video.kind === 'videostream') {
          const element = document.querySelector('#' + video.deviceId);
          element.crossOrigin = 'anonymous';
          var hls = new Hls();
          hls.attachMedia(element);
          hls.on(Hls.Events.MEDIA_ATTACHED, () => {
            hls.loadSource(video.src);
            hls.on(Hls.Events.MANIFEST_PARSED, (event, data) => {
              // Logger.log('AgoraService.getVideoOptions.hls', data.levels);
              element.play().then(success => {
                const stream = element.captureStream();
                options.videoSource = stream.getVideoTracks()[0];
                // Logger.log('AgoraService.getVideoOptions', element, stream, stream.getVideoTracks());
                resolve(options);
              }, error => {
                Logger.error('AgoraService.getVideoOptions.error', error);
              });
            });
          });
        } else if (video.kind === 'videoplayer' || video.kind === 'videostream') {
          const element = document.querySelector('#' + video.deviceId);
          element.crossOrigin = 'anonymous';
          // element.oncanplay = () => {
          const stream = element.captureStream();
          options.videoSource = stream.getVideoTracks()[0];
          // Logger.log('getVideoOptions', element, stream, stream.getVideoTracks());
          resolve(options);
          // };
          /*
          element.play().then(success => {
          	const stream = element.captureStream();
          	options.videoSource = stream.getVideoTracks()[0];
          	// Logger.log('getVideoOptions', element, stream, stream.getVideoTracks());
          	resolve(options);
          }, error => {
          	// Logger.error('AgoraService.getVideoOptions.error', error);
          });
          */
        } else {
          options.cameraId = video.deviceId;
          resolve(options);
        }
      } else {
        resolve(options);
      }
    });
  }
  getAudioOptions(options, audio) {
    return new Promise((resolve, reject) => {
      if (audio) {
        if (audio.kind === 'videostream') {
          const element = document.querySelector('#' + audio.deviceId);
          element.crossOrigin = 'anonymous';
          // !!! try hls.service;
          var hls = new Hls();
          hls.attachMedia(element);
          hls.on(Hls.Events.MEDIA_ATTACHED, () => {
            hls.loadSource(audio.src);
            hls.on(Hls.Events.MANIFEST_PARSED, (event, data) => {
              // Logger.log('AgoraService.getAudioOptions.hls', data.levels);
              hls.loadLevel = data.levels.length - 1;
              element.play().then(success => {
                const stream = element.captureStream();
                options.audioSource = stream.getAudioTracks()[0];
                // Logger.log('AgoraService.getAudioOptions', element, stream, stream.getAudioTracks());
                resolve(options);
              }, error => {
                Logger.error('AgoraService.getAudioOptions.error', error);
              });
            });
          });
        } else if (audio.kind === 'videoplayer' || audio.kind === 'videostream') {
          const element = document.querySelector('#' + audio.deviceId);
          element.crossOrigin = 'anonymous';
          // element.oncanplay = () => {
          const stream = element.captureStream();
          options.audioSource = stream.getAudioTracks()[0];
          // Logger.log('AgoraService.getAudioOptions', element, stream, stream.getAudioTracks());
          resolve(options);
          // };
          /*
          element.play().then(success => {
          	const stream = element.captureStream();
          	options.audioSource = stream.getAudioTracks()[0];
          	// Logger.log('AgoraService.getAudioOptions', element, stream, stream.getAudioTracks());
          	resolve(options);
          }, error => {
          	// Logger.error('AgoraService.getAudioOptions.error', error);
          });
          */
        } else {
          options.microphoneId = audio.deviceId;
          resolve(options);
        }
      } else {
        resolve(options);
      }
    });
  }
  async autoDetectDevice() {
    const state = StateService.state;
    if (state.role === RoleType.SmartDevice || USE_AUTODETECT) {
      const inputDevices = await AgoraService.getDevices();
      const devices = {
        videos: [],
        audios: [],
        video: null,
        audio: null
      };
      inputDevices.forEach(x => {
        if (x.kind === 'videoinput') {
          devices.videos.push(x);
        } else if (x.kind === 'audioinput') {
          devices.audios.push(x);
        }
      });
      devices.video = devices.videos[0] || null;
      devices.audio = devices.audios[0] || null;
      StateService.patchState({
        devices
      });
      return devices;
    }
    return state.devices;
  }
  async createMediaStream(uid, video, audio) {
    // this.releaseStream('_mediaVideoStream')
    const options = {
      streamID: uid,
      video: Boolean(video),
      audio: Boolean(audio),
      screen: false
    };
    await this.getVideoOptions(options, video);
    await this.getAudioOptions(options, audio);
    const quality = Object.assign({}, StateService.state.quality);
    await this.createLocalStreamWithOptions(options, quality);
  }

  // If you prefer video smoothness to sharpness, use setVideoProfile
  // to set the video resolution and Agora self-adapts the video bitrate according to the network condition.
  // If you prefer video sharpness to smoothness, use setVideoEncoderConfiguration,
  // and set min in bitrate as 0.4 - 0.5 times the bitrate value in the video profile table.
  async createLocalStreamWithOptions(options, quality) {
    try {
      Logger.log('AgoraService.createLocalStreamWithOptions', options, quality);
      let videoTrack = undefined;
      let audioTrack = undefined;
      if (options.video) {
        videoTrack = await AgoraRTC$1.createCameraVideoTrack({
          cameraId: options.cameraId,
          encoderConfig: quality.profile
        });
      }
      if (options.audio) {
        audioTrack = await AgoraRTC$1.createMicrophoneAudioTrack({
          microphoneId: options.microphoneId
        });
      }
      const user = {
        uid: options.streamID,
        videoTrack,
        audioTrack,
        hasVideo: videoTrack !== undefined,
        hasAudio: audioTrack !== undefined
      };
      const stream = new Stream(user, options.video ? 'video' : 'audio', true);
      StreamService.local = stream;
      setTimeout(async () => {
        await this.publishLocalStream();
      }, 1);
      Logger.log('AgoraService.createLocalStreamWithOptions.success', stream);
    } catch (error) {
      Logger.error('AgoraService.createLocalStreamWithOptions.error', error);
      // throw error;
    }
  }

  async publishLocalStream() {
    try {
      Logger.log('AgoraService.publishLocalStream');
      const clientInfo = await this.setUserState();
      const local = StreamService.local;
      const client = this.client;
      await client.publish(local.getTracks());
      local.clientInfo = clientInfo;
      StreamService.local = local;
    } catch (error) {
      Logger.error('AgoraService.publishLocalStream.error', error);
      throw error;
    }
  }
  async unpublishLocalStream() {
    try {
      Logger.log('AgoraService.unpublishLocalStream');
      const client = this.client;
      const local = StreamService.local;
      if (local) {
        await client.unpublish(local.getTracks());
      }
      await this.clearLocalUserAttributes();
      StreamService.local = null;
    } catch (error) {
      Logger.error('AgoraService.unpublishLocalStream.error', error);
      throw error;
    }
  }
  async closeLocalStream() {
    try {
      const local = StreamService.local;
      if (local) {
        await local.close();
      }
      await this.clearLocalUserAttributes();
      StreamService.local = null;
      Logger.log('AgoraService.closeLocalStream', local);
    } catch (error) {
      Logger.error('AgoraService.closeLocalStream.error', error);
      throw error;
    }
  }
  async leaveChannel() {
    try {
      StateService.patchState({
        connecting: false
      });
      await this.closeLocalStream();
      await this.closeScreenStream();
      StreamService.remotes = [];
      StreamService.peers = [];
      await this.leaveMessageChannel();
      await this.leaveClient();
      await this.leaveScreenClient();
    } catch (error) {
      Logger.error('AgoraService.leaveChannel.error', error);
      throw error;
    }
  }
  leaveClient() {
    return new Promise((resolve, reject) => {
      const client = this.client;
      if (client) {
        client.leave(() => {
          this.client = null;
          // Logger.log('AgoraService.leaveClient', 'Leave channel successfully');
          if (environment.flags.useProxy) {
            client.stopProxyServer();
            Logger.log('AgoraService.leaveClient.stopProxyServer');
          }
          resolve();
        }, error => {
          Logger.error('AgoraService.leaveClient.error', error);
          reject(error);
        });
      } else {
        resolve();
      }
    });
  }
  leaveMessageChannel() {
    return new Promise((resolve, reject) => {
      {
        this.unobserveMemberCount();
        const channel = this.channel;
        if (!channel) {
          return resolve();
        }
        const messageClient = this.messageClient;
        channel.leave().then(() => {
          this.channel = null;
          messageClient.logout().then(() => {
            this.messageClient = null;
            resolve();
          }, reject);
        }, reject);
      }
    });
  }
  async toggleCamera() {
    const local = StreamService.local;
    // Logger.log('AgoraService.toggleCamera', local);
    if (local && local.video) {
      if (local.userMuteVideo) {
        await local.unmuteVideo();
        StateService.patchState({
          cameraMuted: false
        });
        this.broadcastEvent(new AgoraUnmuteVideoEvent({
          streamId: local.streamId
        }));
        this.setUserState();
      } else {
        await local.muteVideo();
        StateService.patchState({
          cameraMuted: true
        });
        this.broadcastEvent(new AgoraMuteVideoEvent({
          streamId: local.streamId
        }));
        this.setUserState();
      }
    }
  }
  async toggleAudio() {
    const local = StreamService.local;
    // Logger.log('AgoraService.toggleAudio', local);
    if (local && local.audio) {
      if (local.userMuteAudio) {
        await local.unmuteAudio();
        StateService.patchState({
          audioMuted: false
        });
        this.broadcastEvent(new AgoraUnmuteAudioEvent({
          streamId: local.streamId
        }));
        this.setUserState();
      } else {
        await local.muteAudio();
        StateService.patchState({
          audioMuted: true
        });
        this.broadcastEvent(new AgoraMuteAudioEvent({
          streamId: local.streamId
        }));
        this.setUserState();
      }
    }
  }
  setAudio(audioMuted) {
    const local = StreamService.local;
    if (local && local.audio) {
      if (audioMuted) {
        this.previousMuteAudio_ = local.userMuteAudio;
        if (!local.userMuteAudio) {
          local.muteAudio();
          StateService.patchState({
            audioMuted: true
          });
          this.broadcastEvent(new AgoraMuteAudioEvent({
            streamId: local.streamId
          }));
          this.setUserState();
        }
      } else {
        if (local.userMuteAudio && !this.previousMuteAudio_) {
          local.unmuteAudio();
          StateService.patchState({
            audioMuted: false
          });
          this.broadcastEvent(new AgoraUnmuteAudioEvent({
            streamId: local.streamId
          }));
          this.setUserState();
        }
      }
    }
  }
  toggleMode() {
    const mode = StateService.state.mode === UIMode.VirtualTour ? UIMode.LiveMeeting : UIMode.VirtualTour;
    StateService.patchState({
      mode
    });
    MessageService.send({
      type: MessageType.Mode,
      mode: mode
    });
    this.setChannelState({
      mode
    });
  }
  toggleNavInfo() {
    const showNavInfo = !StateService.state.showNavInfo;
    StateService.patchState({
      showNavInfo
    });
    MessageService.send({
      type: MessageType.NavInfo,
      showNavInfo: showNavInfo
    });
  }

  /**
   * controllingId is the uid of the controller user.
   */
  requestControl(controllingId) {
    return new Promise((resolve, _) => {
      this.sendRequestControl(controllingId).then(controllingId => {
        StateService.patchState({
          controlling: controllingId,
          spying: false
        });
        resolve(controllingId);
        this.setChannelState({
          controlling: controllingId,
          spying: ''
        });
      });
    });
  }
  requestSpy(spyingId) {
    return new Promise((resolve, _) => {
      this.sendRequestSpy(spyingId).then(spyingId => {
        StateService.patchState({
          spying: spyingId,
          controlling: false
        });
        resolve(spyingId);
        this.setChannelState({
          spying: spyingId,
          controlling: ''
        });
      });
    });
  }

  /**
   * controllingId is the uid of the controller user.
   */
  dismissControl(skipAttributes) {
    if (skipAttributes === void 0) {
      skipAttributes = false;
    }
    return new Promise((resolve, _) => {
      const controllingId = StateService.state.controlling;
      if (controllingId) {
        this.sendRequestControlDismiss(controllingId).then(() => {
          StateService.patchState({
            controlling: false
          });
          resolve(controllingId);
          if (!skipAttributes) {
            this.setChannelState({
              controlling: ''
            });
          }
        });
      } else {
        resolve(false);
      }
    });
  }
  dismissSpy(skipAttributes) {
    if (skipAttributes === void 0) {
      skipAttributes = false;
    }
    return new Promise((resolve, _) => {
      const spyingId = StateService.state.spying;
      if (spyingId) {
        this.sendRequestSpyDismiss(spyingId).then(() => {
          StateService.patchState({
            spying: false
          });
          resolve(spyingId);
          if (!skipAttributes) {
            this.setChannelState({
              spying: ''
            });
          }
        });
      } else {
        resolve(false);
      }
    });
  }

  /**
   * controllingId is the uid of the controller user.
   */
  toggleControl(controllingId) {
    this.dismissSpy(true).then(() => {
      this.dismissControl(true).then(dismissedControllingId => {
        if (dismissedControllingId !== controllingId) {
          this.requestControl(controllingId).then(controllingId => {
            Logger.log('AgoraService.toggleControl', controllingId);
          });
        } else {
          this.setChannelState({
            controlling: ''
          });
        }
      });
    });
  }
  toggleSpy(spyingId) {
    this.dismissControl(true).then(() => {
      this.dismissSpy(true).then(dismissedSpyingId => {
        if (dismissedSpyingId !== spyingId) {
          this.requestSpy(spyingId).then(spyingId => {
            Logger.log('AgoraService.toggleSpy', spyingId);
          });
        } else {
          this.setChannelState({
            spying: ''
          });
        }
      });
    });
  }
  sendRequestControl(controllingId) {
    return new Promise((resolve, _) => {
      this.sendMessage({
        type: MessageType.RequestControl,
        controllingId: controllingId
      }).then(() => {
        resolve(controllingId);
      });
    });
  }
  sendRequestSpy(spyingId) {
    return new Promise((resolve, _) => {
      this.sendMessage({
        type: MessageType.RequestSpy,
        spyingId: spyingId
      }).then(() => {
        resolve(spyingId);
      });
    });
  }
  sendRequestControlDismiss(controllingId) {
    return new Promise((resolve, _) => {
      this.sendMessage({
        type: MessageType.RequestControlDismiss,
        controllingId: controllingId
      }).then(() => {
        resolve(controllingId);
      });
    });
  }
  sendRequestSpyDismiss(spyingId) {
    return new Promise((resolve, _) => {
      this.sendMessage({
        type: MessageType.RequestSpyDismiss,
        spyingId: spyingId
      }).then(() => {
        resolve(spyingId);
      });
    });
  }
  toggleSilence() {
    const silencing = !StateService.state.silencing;
    this.sendMessage({
      type: MessageType.RemoteSilencing,
      silencing: silencing
    });
    StateService.patchState({
      silencing
    });
    // !!! todo silencing
    // this.setChannelState({ silencing });
  }

  newMessageId() {
    return `${StateService.state.uid}-${Date.now().toString()}`;
  }
  navToView(viewId, keepOrientation, useLastOrientation) {
    if (keepOrientation === void 0) {
      keepOrientation = false;
    }
    if (useLastOrientation === void 0) {
      useLastOrientation = false;
    }
    if (StateService.state.controlling === StateService.state.uid || StateService.state.spying === StateService.state.uid) {
      this.sendMessage({
        type: MessageType.NavToView,
        viewId: viewId,
        keepOrientation: keepOrientation,
        useLastOrientation: useLastOrientation
      });
    }
  }
  getSessionStats() {
    const client = this.client;
    client.getSessionStats(stats => {
      Logger.log(`
AgoraService.getSessionStats
	Duration: ${stats.Duration}
	UserCount: ${stats.UserCount}
	SendBytes: ${stats.SendBytes}
	RecvBytes: ${stats.RecvBytes}
	SendBitrate: ${stats.SendBitrate}
	RecvBitrate: ${stats.RecvBitrate}
`);
    });
  }
  getSystemStats() {
    const client = this.client;
    client.getSystemStats(stats => {
      Logger.log(`
AgoraService.getSystemStats
			BatteryLevel: ${stats.BatteryLevel}
`);
    });
  }
  sendMessage(message) {
    return new Promise((resolve, reject) => {
      if (StateService.state.connected) {
        message.clientId = StateService.state.uid;
        // Logger.log('AgoraService.sendMessage');
        switch (message.type) {
          case MessageType.ControlInfo:
          case MessageType.CurrentTimeMedia:
          case MessageType.MenuToggle:
          case MessageType.Mode:
          case MessageType.NavInfo:
          case MessageType.NavLink:
          case MessageType.NavLinkClose:
          case MessageType.NavToGrid:
          case MessageType.NavToView:
          case MessageType.PlayMedia:
          case MessageType.PlayModel:
          case MessageType.SelectItem:
          case MessageType.ShowPanel:
          case MessageType.SlideChange:
          case MessageType.VREnded:
          case MessageType.VRStarted:
          case MessageType.VRState:
          case MessageType.ZoomMedia:
          case MessageType.SetSnapshot:
            // Logger.log('AgoraService.sendMessage', StateService.state.uid, StateService.state.controlling, StateService.state.spying, StateService.state.controlling !== StateService.state.uid && StateService.state.spying !== StateService.state.uid);
            if (StateService.state.controlling !== StateService.state.uid && StateService.state.spying !== StateService.state.uid) {
              return;
            }
            break;
        }
        // message.wrc_version = 'beta';
        // message.uid = StateService.state.uid;
        const onMessageSent = message => {
          resolve(message);
          // rewire inner messages
          switch (message.type) {
            case MessageType.RequestControl:
              // !!! rewire inner message
              this.broadcastMessage(message);
              break;
            case MessageType.SetSnapshot:
              // !!! saving channel snapshot
              this.setChannelSnapshot(message);
              break;
          }
        };
        const send = (message, channel) => {
          Logger.log('AgoraService.sendMessage', message);
          try {
            const text = JSON.stringify(message);
            if (message.messageId) {
              this.once(`message-${message.messageId}`, message => {
                onMessageSent(message);
              });
            }
            // Logger.log('AgoraService.sendMessage.sending', message.type);
            channel.sendMessage({
              text: text
            }).then(() => {
              // Logger.log('AgoraService.sendMessage', text);
              if (!message.messageId) {
                onMessageSent(message);
              }
            }).catch(error => {
              Logger.error('AgoraService.sendMessage.error', error);
            });
          } catch (error) {
            Logger.error('AgoraService.sendMessage.error', error);
            // reject(error);
          }
        };

        const channel = this.channel;
        if (channel) {
          send(message, channel);
        } else {
          try {
            this.once('channel', channel => {
              send(message, channel);
            });
          } catch (error) {
            Logger.error('AgoraService.sendMessage.error', error);
            reject(error);
          }
        }
      } else {
        Logger.error('AgoraService.sendMessage.error', 'not connected');
        // reject();
      }
    });
  }

  /**
   * @description getChannelAttributes
   * @returns Record<string, { lastUpdateTs: number, value: string }>
   */
  getChannelAttributes() {
    Logger.log('AgoraService.getChannelAttributes');
    return new Promise((resolve, reject) => {
      const messageClient = this.messageClient;
      if (messageClient) {
        const promise = messageClient.getChannelAttributes(StateService.state.channelNameLink);
        promise.then(attributes => {
          Logger.log('AgoraService.getChannelAttributes', attributes);
          resolve(attributes);
        }).catch(error => {
          Logger.error('AgoraService.getChannelAttributes.error', error);
          resolve({});
        });
      } else {
        Logger.error('AgoraService.getChannelAttributes.noop');
        resolve({});
      }
    });
  }

  /**
   * @description getChannelAttributesByKeys
   * @params string[]
   * @returns Record<string, string>
   */
  getChannelAttributesByKeys() {
    for (var _len = arguments.length, keys = new Array(_len), _key = 0; _key < _len; _key++) {
      keys[_key] = arguments[_key];
    }
    Logger.log('AgoraService.getChannelAttributesByKeys', keys);
    return new Promise((resolve, reject) => {
      const messageClient = this.messageClient;
      if (messageClient) {
        const promise = messageClient.getChannelAttributes(StateService.state.channelNameLink, keys);
        promise.then(attributes => {
          Logger.log('AgoraService.getChannelAttributesByKeys', attributes);
          const mappedAttributes = {};
          Object.keys(attributes).forEach(key => {
            mappedAttributes[key] = attributes[key].value;
          });
          resolve(mappedAttributes);
        }).catch(error => {
          Logger.error('AgoraService.getChannelAttributesByKeys.error', error);
          resolve({});
        });
      } else {
        Logger.error('AgoraService.getChannelAttributesByKeys.noop', keys);
        resolve({});
      }
    });
  }

  /**
   * @description getChannelMessages
   * @returns { date: number, clientId: string, name: string, message: string }[]
   */
  getChannelMessages() {
    Logger.log('AgoraService.getChannelMessages');
    return rxjs.from(this.getChannelAttributes()).pipe(operators.map(attributes => Object.keys(attributes).filter(key => key.indexOf('message-') === 0).map(key => attributes[key])), operators.map(attributes => {
      attributes.sort((a, b) => {
        return a.lastUpdateTs - b.lastUpdateTs;
      });
      const messages = attributes.map(attribute => {
        const message = JSON.parse(attribute.value);
        return message;
      });
      Logger.log('AgoraService.getChannelMessages', messages);
      return messages;
    }), operators.catchError(error => {
      Logger.error('AgoraService.getChannelMessages.error', error);
      return rxjs.of([]);
    }));
  }

  /**
   * @description addOrUpdateChannelAttributes
   * @params attributes: Record<string, string>
   */
  addOrUpdateChannelAttributes(attributes) {
    Logger.log('AgoraService.addOrUpdateChannelAttributes', attributes);
    return new Promise((resolve, reject) => {
      const messageClient = this.messageClient;
      if (messageClient && Object.keys(attributes).length > 0) {
        const promise = messageClient.addOrUpdateChannelAttributes(StateService.state.channelNameLink, attributes, {
          enableNotificationToChannelMembers: false
        });
        promise.then(() => {
          Logger.log('AgoraService.addOrUpdateChannelAttributes', attributes);
        }).catch(error => {
          Logger.error('AgoraService.addOrUpdateChannelAttributes.error', error);
        }).finally(() => {
          resolve();
        });
      } else {
        Logger.error('AgoraService.addOrUpdateChannelAttributes.noop', attributes);
        resolve();
      }
    });
  }

  /**
   * this method is called after remote stream of the publisher has been added.
   */
  getInitialSession() {
    this.getChannelSession().then(session => {
      StateService.patchState(session.state);
      if (session.state.controlling && session.snapshot) {
        // !!! rewire inner message to update view snapshot
        this.broadcastMessage(session.snapshot);
      }
      // handle window mode changes
      window.dispatchEvent(new Event('resize'));
    });
  }

  /**
   * @description getChannelSession
   * @returns { state: State, snapshot: Snapshot }
   */
  getChannelSession() {
    Logger.log('AgoraService.getChannelSession');
    return new Promise((resolve, reject) => {
      this.getChannelAttributesByKeys('channelState', 'channelSnapshot').then(attributes => {
        const channelSession = {
          state: {},
          snapshot: {}
        };
        if (attributes.channelState) {
          const channelState = JSON.parse(attributes.channelState);
          this.channelState = channelState;
          channelSession.state = channelState;
        }
        if (attributes.channelSnapshot) {
          const channelSnapshot = JSON.parse(attributes.channelSnapshot);
          this.channelSnapshot = channelSnapshot;
          channelSession.snapshot = channelSnapshot;
        }
        Logger.log('AgoraService.getChannelSession', channelSession);
        resolve(channelSession);
      }).catch(error => {
        Logger.error('AgoraService.getChannelSession.error', error);
        resolve({});
      });
    });
  }

  /**
   * @description getChannelState
   * @returns State
   */
  getChannelState() {
    Logger.log('AgoraService.getChannelState');
    return new Promise((resolve, reject) => {
      this.getChannelAttributesByKeys('channelState').then(attributes => {
        if (attributes.channelState) {
          const channelState = JSON.parse(attributes.channelState);
          this.channelState = channelState;
          /*
          const channelState = {
          	role: StateService.state.role,
          	name: StateService.state.name,
          	uid: StateService.state.uid,
          	screenUid: StateService.state.screenUid,
          	controlling: StateService.state.controlling,
          	spying: StateService.state.spying,
          	mode: StateService.state.mode,
          };
          */
          Logger.log('AgoraService.getChannelState', channelState);
          resolve(channelState);
        } else {
          resolve({});
        }
      }).catch(error => {
        Logger.error('AgoraService.getChannelState.error', error);
        resolve({});
      });
    });
  }

  /**
   * @description setChannelState
   * @params partialState: Record<string, string>
   */
  setChannelState(partialState) {
    const channelState = _objectSpread2(_objectSpread2({}, this.channelState || {}), partialState);
    Logger.log('AgoraService.setChannelState', partialState, channelState);
    return this.addOrUpdateChannelAttributes({
      channelState: JSON.stringify(channelState)
    });
  }

  /**
   * @description getChannelSnapshot
   * @returns Snapshot
   */
  getChannelSnapshot() {
    Logger.log('AgoraService.getChannelSnapshot');
    return new Promise((resolve, reject) => {
      this.getChannelAttributesByKeys('channelSnapshot').then(attributes => {
        if (attributes.channelSnapshot) {
          const channelSnapshot = JSON.parse(attributes.channelSnapshot);
          this.channelSnapshot = channelSnapshot;
          Logger.log('AgoraService.getChannelSnapshot', channelSnapshot);
          resolve(channelSnapshot);
        } else {
          resolve({});
        }
      }).catch(error => {
        Logger.error('AgoraService.getChannelSnapshot.error', error);
        resolve({});
      });
    });
  }

  /**
   * @description setChannelSnapshot
   * @params partialSnapshot: Record<string, string>
   */
  setChannelSnapshot(partialSnapshot) {
    const channelSnapshot = _objectSpread2(_objectSpread2({}, this.channelSnapshot || {}), partialSnapshot);
    Logger.log('AgoraService.setChannelSnapshot', partialSnapshot, channelSnapshot);
    return this.addOrUpdateChannelAttributes({
      channelSnapshot: JSON.stringify(channelSnapshot)
    });
  }
  padStart(num, count, char) {
    if (count === void 0) {
      count = 5;
    }
    if (char === void 0) {
      char = '0';
    }
    const s = String(num);
    return s.length >= count ? s : new Array(count - s.length + 1).join(char) + s;
  }

  /**
   * @description addOrUpdateChannelMessages
   * @params messages: { date: number, clientId: string, name: string, message: string }[]
   */
  addOrUpdateChannelMessages(messages) {
    const attributes = {};
    messages.forEach(message => {
      const num = Math.floor(Math.random() * 10000);
      const key = `message-${message.date}-${this.padStart(num)}`;
      attributes[key] = JSON.stringify(message);
    });
    return this.addOrUpdateChannelAttributes(attributes);
  }
  deleteChannelAttributesByKeys(keys) {
    Logger.log('AgoraService.deleteChannelAttributesByKeys', keys);
    return new Promise((resolve, reject) => {
      const messageClient = this.messageClient;
      if (messageClient && keys.length > 0) {
        const promise = messageClient.deleteChannelAttributesByKeys(StateService.state.channelNameLink, keys, {
          enableNotificationToChannelMembers: false
        });
        promise.then(() => {
          Logger.log('AgoraService.deleteChannelAttributesByKeys', keys);
          resolve();
        }).catch(error => {
          Logger.error('AgoraService.deleteChannelAttributesByKeys.error', error);
          reject(error);
        });
      } else {
        Logger.error('AgoraService.deleteChannelAttributesByKeys.noop', keys);
        reject('missing rtm client or keys');
      }
    });
  }
  setUserState() {
    const clientInfo = {
      role: StateService.state.role,
      name: StateService.state.name,
      uid: StateService.state.uid,
      screenUid: StateService.state.screenUid,
      cameraMuted: StateService.state.cameraMuted,
      audioMuted: StateService.state.audioMuted
    };
    Logger.log('AgoraService.setUserState', clientInfo);
    return this.addOrUpdateLocalUserAttributes({
      clientInfo: JSON.stringify(clientInfo)
    }).then(() => {
      return clientInfo;
    });
  }
  getUserState(remoteId) {
    return this.getUserAttributes(remoteId).then(attributes => {
      const clientInfo = JSON.parse(attributes.clientInfo || '');
      Logger.log('AgoraService.getUserState', clientInfo);
      return clientInfo;
    });
  }
  addOrUpdateLocalUserAttributes(attributes) {
    Logger.log('AgoraService.addOrUpdateLocalUserAttributes', attributes);
    return new Promise((resolve, reject) => {
      const messageClient = this.messageClient;
      if (messageClient && Object.keys(attributes).length > 0) {
        const promise = messageClient.addOrUpdateLocalUserAttributes(attributes);
        promise.then(() => {
          Logger.log('AgoraService.addOrUpdateLocalUserAttributes', attributes);
          resolve();
        }).catch(error => {
          Logger.error('AgoraService.addOrUpdateLocalUserAttributes.error', error);
          reject(error);
        });
      } else {
        Logger.error('AgoraService.addOrUpdateLocalUserAttributes.noop', attributes);
        reject('missing rtm client or attributes');
      }
    });
  }
  getUserAttributes(userId) {
    Logger.log('AgoraService.getUserAttributes', userId);
    return new Promise((resolve, reject) => {
      const messageClient = this.messageClient;
      if (messageClient) {
        const promise = messageClient.getUserAttributes(userId);
        promise.then(attributes => {
          Logger.log('AgoraService.getUserAttributes', attributes);
          resolve(attributes);
        }).catch(error => {
          Logger.error('AgoraService.getUserAttributes.error', error);
          reject(error);
        });
      } else {
        Logger.error('AgoraService.getUserAttributes', 'missing rtm client');
        reject('missing rtm client');
      }
    });
  }
  clearLocalUserAttributes() {
    Logger.log('AgoraService.clearLocalUserAttributes');
    return new Promise((resolve, reject) => {
      const messageClient = this.messageClient;
      if (messageClient) {
        const promise = messageClient.clearLocalUserAttributes();
        promise.then(() => {
          Logger.log('AgoraService.clearLocalUserAttributes');
          resolve();
        }).catch(error => {
          Logger.error('AgoraService.clearLocalUserAttributes.error', error);
          resolve();
        });
      } else {
        resolve();
      }
    });
  }
  checkBroadcastMessage(message) {
    // filter for broadcast
    // !!! filter events here
    switch (message.type) {
      case MessageType.RequestControlDismiss:
        StateService.patchState({
          controlling: false
        });
        if (message.controllingId === StateService.state.uid) {
          this.closeScreenStream();
        }
        break;
      case MessageType.RequestSpyDismiss:
        StateService.patchState({
          spying: false
        });
        break;
      case MessageType.SetSnapshot:
        // Logger.log('AgoraService.checkBroadcastMessage.SetSnapshot', message);
        if (StateService.state.role === RoleType.Publisher) {
          this.broadcastMessage(message);
        } else if (StateService.state.controlling && StateService.state.controlling !== StateService.state.uid) {
          this.broadcastMessage(message);
        }
        break;
      case MessageType.RemoteSilencing:
        // only streamers can be silenced
        if (StateService.state.role === RoleType.Streamer) {
          this.broadcastMessage(message);
        }
        break;
      case MessageType.ControlInfo:
      case MessageType.CurrentTimeMedia:
      case MessageType.MenuToggle:
      case MessageType.Mode:
      case MessageType.NavInfo:
      case MessageType.NavLink:
      case MessageType.NavLinkClose:
      case MessageType.NavToGrid:
      case MessageType.NavToView:
      case MessageType.PlayMedia:
      case MessageType.PlayModel:
      case MessageType.SelectItem:
      case MessageType.ShowPanel:
      case MessageType.SlideChange:
      case MessageType.VREnded:
      case MessageType.VRStarted:
      case MessageType.VRState:
      case MessageType.ZoomMedia:
        if (StateService.state.controlling && StateService.state.controlling !== StateService.state.uid || StateService.state.spying && StateService.state.spying !== StateService.state.uid) {
          this.broadcastMessage(message);
        }
        break;
      default:
        this.broadcastMessage(message);
    }
  }
  broadcastMessage(message) {
    MessageService.out(message);
  }
  broadcastEvent(event) {
    MessageService.out({
      type: MessageType.AgoraEvent,
      event
    });
  }
  peerAdd(remoteId) {
    Logger.log('AgoraService.peerAdd', remoteId);
    const peer = {
      uid: remoteId
    };
    const peers = StreamService.peers;
    peers.push(peer);
    StreamService.peers = peers;
    this.broadcastEvent(new AgoraPeerEvent({
      peer
    }));
  }
  peerRemove(remoteId) {
    Logger.log('AgoraService.peerRemove', remoteId);
    const peers = StreamService.peers;
    const peer = peers.find(x => x.uid === remoteId);
    if (peer) {
      peers.splice(peers.indexOf(peer), 1);
      StreamService.peers = peers;
    }
  }
  onMessage(data, uid) {
    // Logger.log('AgoraService.onMessage', data.text, uid, StateService.state.uid);
    // discard message delivered by current state uid;
    if (uid !== StateService.state.uid) {
      Logger.log('AgoraService.onMessage', data.text, uid);
      const message = JSON.parse(data.text);
      if (message.messageId && this.has(`message-${message.messageId}`)) {
        // !!! removed return
        this.emit(`message-${message.messageId}`, message);
      }
      // discard message delivered to specific remoteId when differs from current state uid;
      if (message.remoteId && message.remoteId !== StateService.state.uid && message.remoteId !== StateService.state.screenUid) {
        return;
      }
      // !!! check position !!!
      if (message.type === MessageType.VRStarted) {
        const container = document.createElement('div');
        container.classList.add('player__vr');
        message.container = container;
      }
      /*
      if (message.type === MessageType.VRStarted || message.type === MessageType.VREnded) {
      	// Logger.log('AgoraService.onMessage', message.type, message);
      }
      */
      this.checkBroadcastMessage(message);
    } else {
      Logger.log('AgoraService.onMessage', data.text);
    }
  }
  onException(event) {
    Logger.error('AgoraService.onException', event);
  }
  async onUserJoined(user) {
    Logger.log('AgoraService.onUserJoined', user);
    this.peerAdd(user.uid);
  }
  async onUserLeft(user, reason) {
    Logger.log('AgoraService.onUserLeft', user, reason);
    const remoteId = user.uid.toString();
    if (remoteId !== StateService.state.uid) {
      // Logger.log('AgoraService.onUserLeft', user.uid);
      const remote = this.remoteRemove(remoteId);
      if (remote && remote.clientInfo) {
        // !!! remove screenRemote?
        if (remote.clientInfo.role === RoleType.Publisher) {
          if (StateService.state.role === RoleType.SelfService) {
            StateService.patchState({
              hosted: true,
              controlling: false,
              spying: false,
              silencing: false
            });
          } else {
            StateService.patchState({
              hosted: false,
              controlling: false,
              spying: false,
              silencing: false
            });
          }
        } else {
          if (StateService.state.controlling === remoteId) {
            StateService.patchState({
              controlling: false
            });
          }
          if (StateService.state.spying === remoteId) {
            StateService.patchState({
              spying: false
            });
          }
        }
      }
    }
    this.peerRemove(remoteId);
  }

  /**
   *
   * @param {IAgoraRTCRemoteUser} user
   * @param {'audio' | 'video'} mediaType
   */
  async onUserPublished(user, mediaType) {
    const uid = user.uid.toString();
    Logger.log('AgoraService.onUserPublished', uid, user, mediaType);
    if (uid !== StateService.state.uid && uid !== StateService.state.screenUid) {
      await this.client.subscribe(user, mediaType);
      const stream = new Stream(user, mediaType);
      await this.remoteAdd(stream);
      /*
      if (mediaType === 'video') {
      	const stream = new Stream(user, mediaType);
      	await this.remoteAdd(stream);
      } else if (mediaType === 'audio') {
      	user.audioTrack?.play();
      }
      */
    } else {
      const clientInfo = {
        role: StateService.state.role,
        name: StateService.state.name,
        uid: StateService.state.uid,
        screenUid: StateService.state.screenUid
      };
      const local = StreamService.local;
      local.clientInfo = clientInfo;
      StreamService.local = local;
    }
  }
  async remoteAdd(stream) {
    Logger.log('AgoraService.remoteAdd', stream);
    StreamService.remoteAdd(stream);
    this.broadcastEvent(new AgoraRemoteEvent({
      stream
    }));
    const remoteId = stream.streamId;
    setTimeout(async () => {
      const clientInfo = await this.getUserState(remoteId);
      Logger.log('AgoraService.remoteAdd.getUserState', clientInfo);
      StreamService.remoteSetClientInfo(remoteId, clientInfo);
      if (clientInfo.cameraMuted) {
        this.broadcastEvent(new AgoraMuteVideoEvent({
          streamId: remoteId
        }));
      }
      if (clientInfo.audioMuted) {
        this.broadcastEvent(new AgoraMuteAudioEvent({
          streamId: remoteId
        }));
      }
      if (clientInfo.role === RoleType.Publisher) {
        const state = {
          hosted: true
        };
        StateService.patchState(state);
        this.getInitialSession();
      }
    }, 100);
  }

  /**
   *
   * @param {IAgoraRTCRemoteUser} user
   * @param {'audio' | 'video'} mediaType
   */
  async onUserUnpublished(user, mediaType) {
    const uid = user.uid.toString();
    Logger.log('AgoraService.onUserUnpublished', uid, user, mediaType);
    if (uid === StateService.state.uid) {
      StreamService.local = null;
    } else if (uid === StateService.state.screenUid) {
      StreamService.screen = null;
    } else if (mediaType === 'video') {
      // !!! this happen on oculus removed timeout
      this.remoteRemove(uid);
    } else if (mediaType === 'audio') {
      user.audioTrack?.stop();
    }
  }
  remoteRemove(streamId) {
    // Logger.log('AgoraService.remoteRemove', streamId);
    const remote = StreamService.remoteRemove(streamId);
    if (remote && remote.clientInfo && remote.clientInfo.role === RoleType.Publisher && remote.clientInfo.screenUid !== streamId) {
      StateService.patchState({
        hosted: false
      });
    }
    return remote;
  }
  onUserInfoUpdated(event) {
    Logger.log('AgoraService.onUserInfoUpdated', event);
    switch (event.msg) {
      case 'mute-audio':
        this.broadcastEvent(new AgoraMuteAudioEvent({
          streamId: event.uid
        }));
        break;
      case 'unmute-audio':
        this.broadcastEvent(new AgoraUnmuteAudioEvent({
          streamId: event.uid
        }));
        break;
      case 'mute-video':
        this.broadcastEvent(new AgoraMuteVideoEvent({
          streamId: event.uid
        }));
        break;
      case 'unmute-video':
        this.broadcastEvent(new AgoraUnmuteVideoEvent({
          streamId: event.uid
        }));
        break;
      /*
      case 'disable-local-video':
      this.broadcastEvent(new AgoraDisableVideoEvent({ streamId: event.uid }));
      break;
      case 'enable-local-video':
      this.broadcastEvent(new AgoraEnableVideoEvent({ streamId: event.uid }));
      break;
      */
    }

    this.broadcastEvent(new AgoraUserInfoUpdateEvent({
      streamId: event.uid,
      message: event.msg
    }));
  }

  /*
  onMuteVideo(event) {
  	// Logger.log('AgoraService.onMuteVideo', event);
  	this.broadcastEvent(new AgoraMuteVideoEvent({ streamId: event.uid }));
  }
  
  onUnmuteVideo(event) {
  	// Logger.log('AgoraService.onUnmuteVideo', event);
  	this.broadcastEvent(new AgoraUnmuteVideoEvent({ streamId: event.uid }));
  }
  
  onMuteAudio(event) {
  	// Logger.log('AgoraService.onMuteAudio', event);
  	this.broadcastEvent(new AgoraMuteAudioEvent({ streamId: event.uid }));
  }
  
  onUnmuteAudio(event) {
  	// Logger.log('AgoraService.onUnmuteAudio', event);
  	this.broadcastEvent(new AgoraUnmuteAudioEvent({ streamId: event.uid }));
  }
  */

  onVolumeIndicator(event) {
    // Logger.log('AgoraService.onVolumeIndicator', event);
    const streams = event.attr.map(x => {
      return {
        streamId: x.uid,
        level: x.level
      };
    });
    this.broadcastEvent(new AgoraVolumeLevelsEvent({
      streams: streams
    }));
  }
  onConnectionStateChange(event) {
    Logger.log('AgoraService.onConnectionStateChange', event);
  }
  onTokenPrivilegeWillExpire(event) {
    Logger.log('AgoraService.onTokenPrivilegeWillExpire');
    const client = this.client;
    const channelNameLink = this.getChannelNameLink();
    AgoraService.rtcToken$(channelNameLink).subscribe(async token => {
      if (token.token) {
        await client.renewToken(token.token);
        Logger.log('AgoraService.onTokenPrivilegeWillExpire.renewed');
      }
    });
  }
  onTokenPrivilegeDidExpire(event) {
    Logger.log('AgoraService.onTokenPrivilegeDidExpire');
    const client = this.client;
    const channelNameLink = this.getChannelNameLink();
    AgoraService.rtcToken$(channelNameLink).subscribe(async token => {
      if (token.token) {
        await client.renewToken(token.token);
        Logger.log('AgoraService.onTokenPrivilegeDidExpire.renewed');
      }
    });
  }

  // screen

  toggleScreen() {
    const screen = StreamService.screen;
    if (screen) {
      this.closeScreenStream();
    } else {
      if (this.screenClient) {
        this.createScreenStream(StateService.state.screenUid);
      } else {
        this.createScreenClient().then(() => {
          const channelNameLink = this.getChannelNameLink();
          AgoraService.rtcToken$(channelNameLink).subscribe(async token => {
            Logger.log('AgoraService.toggleScreen.rtcToken$', token);
            await this.screenJoin(token.token, channelNameLink);
          });
        });
      }
    }
  }
  async createScreenClient() {
    if (this.screenClient) {
      return this.screenClient;
    }
    try {
      const screenClient = this.screenClient = AgoraRTC$1.createClient({
        mode: 'live',
        codec: 'h264'
      }); // rtc, vp8
      screenClient.on('error', this.onScreenError);
      screenClient.on('stream-published', this.onScreenStreamPublished);
      screenClient.on('stream-unpublished', this.onScreenStreamUnpublished);
      // only for remotes
      // screenClient.on('stream-added', this.onScreenStreamAdded);
      // screenClient.on('stream-removed', this.onScreenStreamRemoved);
      // screenClient.on('stream-subscribed', this.onScreenStreamSubscribed);
      // screenClient.on('peer-online', this.onScreenPeerConnect);
      // screenClient.on('peer-leave', this.onScreenPeerLeaved);
      // screenClient.on('onTokenPrivilegeWillExpire', this.onScreenTokenPrivilegeWillExpire);
      // screenClient.on('onTokenPrivilegeDidExpire', this.onScreenTokenPrivilegeDidExpire);
      if (environment.flags.useProxy) {
        screenClient.startProxyServer(3);
        /*
        3: The cloud proxy for the UDP protocol, that is, the Force UDP cloud proxy mode. In this mode, the SDK always transmits data over UDP.
        5: The cloud proxy for the TCP (encryption) protocol, that is, the Force TCP cloud proxy mode. In this mode, the SDK always transmits data over TLS 443.
        Note: As of v4.15.0, the default value of mode is 3.
        */
        Logger.log('AgoraService.createScreenClient.startProxyServer');
      }
    } catch (error) {
      Logger.error('AgoraService.createScreenClient.error', error);
      this.screenClient = null;
    }
    return this.screenClient;
  }
  async screenJoin(token, channelNameLink) {
    const screenClient = this.screenClient;
    const screenClientId = AgoraService.getUniqueUserId();
    try {
      const screenUid = await screenClient.join(environment.appKey, channelNameLink, token, screenClientId);
      Logger.log('AgoraService.screenJoin', screenUid);
      StateService.patchState({
        screenUid
      });
      this.createScreenStream(screenUid);
    } catch (error) {
      Logger.error('AgoraService.screenJoin.error', error);
      if (error === 'DYNAMIC_KEY_EXPIRED') {
        AgoraService.rtcToken$(channelNameLink).subscribe(async token => {
          await this.screenJoin(token.token, channelNameLink);
        });
      }
    }
  }
  createScreenStream(screenUid) {
    const options = {
      streamID: screenUid,
      audio: false,
      video: false,
      screen: true
      // extensionId: 'minllpmhdgpndnkomcoccfekfegnlikg', // Google Chrome:
      // mediaSource:  'screen', // Firefox: 'screen', 'application', 'window' (select one)
    };
    // !!! todo
    const stream = AgoraRTC$1.createStream(options);
    stream.setScreenProfile(environment.profiles.screen);
    Logger.log('AgoraService.createScreenStream', options);
    const onStopScreenSharing = () => {
      this.closeScreenStream();
    };
    // Initialize the stream.
    stream.init(() => {
      StreamService.screen = stream;
      stream.on('stopScreenSharing', onStopScreenSharing);
      stream.muteAudio();
      setTimeout(() => {
        this.publishScreenStream();
      }, 1);
    }, function (error) {
      Logger.error('AgoraService.createScreenStream.screen.init.error', error);
    });
  }
  async publishScreenStream() {
    try {
      Logger.log('AgoraService.publishScreenStream');
      const clientInfo = await this.setUserState();
      const screen = StreamService.screen;
      const screenClient = this.screenClient;
      await screenClient.publish(screen.getTracks());
      screen.clientInfo = clientInfo;
      StreamService.screen = screen;
    } catch (error) {
      Logger.error('AgoraService.publishScreenStream.error', error);
      throw error;
    }
  }
  async unpublishScreenStream() {
    try {
      const screenClient = this.screenClient;
      const screen = StreamService.screen;
      if (screenClient && screen) {
        await screenClient.unpublish(screen.getTracks());
      }
      StreamService.screen = null;
      Logger.log('AgoraService.unpublishScreenStream', screen);
    } catch (error) {
      Logger.error('AgoraService.unpublishScreenStream.error', error);
      throw error;
    }
  }
  async closeScreenStream() {
    try {
      const screen = StreamService.screen;
      if (screen) {
        await screen.close();
      }
      StreamService.screen = null;
      Logger.log('AgoraService.closeScreenStream', screen);
    } catch (error) {
      Logger.error('AgoraService.closeScreenStream.error', error);
      throw error;
    }
  }
  leaveScreenClient() {
    return new Promise((resolve, reject) => {
      const screenClient = this.screenClient;
      if (screenClient) {
        screenClient.leave(() => {
          this.screenClient = null;
          // Logger.log(AgoraService.leaveScreenClient');
          if (environment.flags.useProxy) {
            screenClient.stopProxyServer();
            Logger.log('AgoraService.leaveScreenClient.stopProxyServer');
          }
          resolve();
        }, error => {
          Logger.error('AgoraService.leaveScreenClient.error', error);
          reject(error);
        });
      } else {
        resolve();
      }
    });
  }
  onScreenError(error) {
    Logger.error('AgoraService.onScreenError', error);
  }
  onScreenStreamPublished(event) {
    // Logger.log('AgoraService.onScreenStreamPublished');
    const screen = StreamService.screen;
    screen.clientInfo = {
      role: StateService.state.role,
      name: StateService.state.name,
      uid: StateService.state.uid,
      screenUid: StateService.state.screenUid
    };
    StreamService.screen = screen;
  }
  onScreenStreamUnpublished(event) {
    // Logger.log('AgoraService.onScreenStreamUnpublished');
    StreamService.screen = null;
  }

  // tokens

  static rtcToken$(channelNameLink) {
    if (environment.flags.useToken) {
      return HttpService.post$('/api/token/rtc', {
        channelName: channelNameLink,
        uid: null
      });
    } else {
      return rxjs.of({
        token: null
      });
    }
  }
  static rtmToken$(uid) {
    if (environment.flags.useToken) {
      return HttpService.post$('/api/token/rtm', {
        uid: uid
      });
    } else {
      return rxjs.of({
        token: null
      });
    }
  }

  // checks

  static checkRtcConnection() {
    return new Promise((resolve, reject) => {
      try {
        const client = AgoraRTC$1.createClient({
          mode: 'live',
          codec: 'h264'
        }); // rtc, vp8
        if (environment.flags.useProxy) {
          client.startProxyServer(3);
        }
        AgoraService.checkRtcTryJoin(client).then(uid => {
          resolve(uid);
        }).catch(error => {
          reject(error);
        }).finally(() => {
          // clear
          client.leave(() => {
            if (environment.flags.useProxy) {
              client.stopProxyServer();
            }
          }, () => {});
        });
      } catch (error) {
        reject(error);
      }
    });
  }
  static checkRtcTryJoin(client) {
    return new Promise((resolve, reject) => {
      const channelName = 'checkRtcConnection';
      AgoraService.rtcToken$(channelName).subscribe(async token => {
        try {
          const uid = await client.join(environment.appKey, channelName, token.token, null);
          // await this.createMediaStream(uid, StateService.state.devices.video, StateService.state.devices.audio);
          resolve(uid);
        } catch (error) {
          if (error === 'DYNAMIC_KEY_EXPIRED') {
            return AgoraService.checkRtcTryJoin(client);
          } else {
            Logger.error('AgoraService.checkRtcConnection.error', error);
            reject(error);
          }
        }
      }, error => reject(error));
    });
  }
  static checkRtmConnection(uid) {
    return new Promise((resolve, reject) => {
      try {
        let client = AgoraRTM.createInstance(environment.appKey, {
          logFilter: AgoraRTM.LOG_FILTER_OFF
        });
        client.setParameters({
          logFilter: AgoraRTM.LOG_FILTER_OFF
        });
        let channel;
        AgoraService.rtmToken$(uid).subscribe(token => {
          // Logger.log('AgoraService.rtmToken$', token);
          const channelName = 'checkRtcConnection';
          client.login({
            token: token.token,
            uid: uid.toString()
          }).then(() => {
            channel = client.createChannel(channelName);
            channel.join().then(() => {
              resolve(uid);
              channel.leave();
            }).catch(error => {
              reject(error);
            }).finally(() => {
              // clear
              channel.leave().then(() => {
                channel = null;
                client.logout().then(() => {
                  client = null;
                }).catch(() => {});
              }).catch(() => {});
            });
          }).catch(error => {
            Logger.error('checkRtmConnection.error', error);
            reject(error);
          }).finally(() => {
            // clear
            if (client) {
              client.logout().then(() => {
                client = null;
              }).catch(() => {});
            }
          });
        }, error => reject(error));
      } catch (error) {
        reject(error);
      }
    });
  }
  static async getDevices() {
    let devices_ = AgoraService.devices_;
    if (devices_) {
      return devices_;
    } else {
      devices_ = AgoraService.devices_ = [];
      const constraints = {
        audio: true,
        video: true
      };
      if (DeviceService.platform === DevicePlatform.IOS) {
        constraints.video = {
          facingMode: 'user'
        };
      }
      if (DeviceService.platform === DevicePlatform.VRHeadset) {
        constraints.video = false;
      }
      if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
        const stream = await navigator.mediaDevices.getUserMedia(constraints);
        const devices = await navigator.mediaDevices.enumerateDevices();
        stream.getTracks().forEach(track => {
          track.stop();
        });
        devices.forEach(device => {
          devices_.push(device);
        });
        return devices_;
      } else {
        throw 'Media device not available';
      }
    }
  }
  static fixLegacy() {
    const prefixes = ['moz', 'webkit'];
    prefixes.forEach(prefix => {
      Logger.log('AgoraService.fixLegacy', `${prefix}RTC`);
      Object.getOwnPropertyNames(window).filter(key => key.indexOf('RTC') === 0).map(key => {
        const legacyKey = `${prefix}${key}`;
        if (typeof window[key] !== 'undefined' && typeof window[legacyKey] === 'undefined') {
          window[legacyKey] = window[key];
        }
      });
    });
  }
}const USE_RANDOM_MESSAGE = false;
class ChatMessage {
  constructor(message, clientId, name) {
    this.type = MessageType.ChatMessage;
    this.clientId_ = clientId;
    if (typeof message === 'string') {
      this.date = Date.now();
      this.clientId = clientId;
      this.name = name;
      this.message = message;
    } else if (typeof message === 'object') {
      this.date = message.date;
      this.clientId = message.clientId;
      this.name = message.name;
      this.message = message.message;
    }
    const names = this.name.split(' ');
    this.shortName = names[0].substr(0, 1).toUpperCase() + (names.length > 1 ? names[1] : names[0]).substr(0, 1).toUpperCase();
  }
  get me() {
    return this.clientId === this.clientId_;
  }
  getPayload() {
    return {
      date: this.date,
      clientId: this.clientId,
      name: this.name,
      message: this.message
    };
  }
  getCopy() {
    return new ChatMessage({
      date: this.date,
      clientId: this.clientId,
      name: this.name,
      message: this.message
    }, this.clientId_);
  }
}
class AgoraChatComponent extends rxcomp.Component {
  constructor() {
    super(...arguments);
    this.typings_ = false;
  }
  onInit() {
    this.rows = 1;
    this.showEmoji = false;
    this.demo = window.location.pathname.indexOf('layout') !== -1;
    const form = this.form = new rxcompForm.FormGroup({
      message: null
    });
    this.controls = form.controls;
    form.changes$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(changes => {
      // console.log('AgoraChatComponent.changes$', form.value);
      this.checkTypings(changes);
      this.pushChanges();
    });
    StateService.state$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(state => {
      // console.log('AgoraChatComponent.state', state);
    });
    MessageService.out$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(message => {
      // console.log('AgoraChatComponent.MessageService', message);
      switch (message.type) {
        case MessageType.ChatMessage:
          this.pushMessage(new ChatMessage(message, StateService.state.uid, StateService.state.name));
          break;
        case MessageType.ChatTypingBegin:
          this.typingBegin(message);
          break;
        case MessageType.ChatTypingEnd:
          this.typingEnd(message);
          break;
      }
    });
    this.messages = [];
    this.groupedMessages = [];
    if (this.demo) {
      // !!! only for demo
      const messages = AgoraChatComponent.getFakeList().map(x => new ChatMessage(x, StateService.state.uid, StateService.state.name));
      this.updateMessages(messages.slice(0, 5));
      MessageService.in$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(message => {
        message.clientId = message.clientId || StateService.state.uid;
        // console.log('AgoraChatComponent.MessageService.in$', message);
        switch (message.type) {
          case MessageType.ChatMessage:
            break;
          case MessageType.ChatTypingBegin:
            MessageService.out(message);
            break;
          case MessageType.ChatTypingEnd:
            MessageService.out(message);
            break;
        }
      });
      // !!! only for demo
    } else {
      const agora = this.agora = AgoraService.getSingleton();
      if (agora) {
        agora.getChannelMessages().pipe(operators.first()).subscribe(messages => {
          messages = messages.map(x => new ChatMessage(x, StateService.state.uid, StateService.state.name));
          // console.log('AgoraChatComponent.getChannelAttributes.messages', messages);
          this.updateMessages(messages);
        });
      }
    }
  }
  onView() {
    // this.scrollToBottom();
  }
  onChanges() {
    // this.scrollToBottom();
  }
  onDestroy() {
    if (AgoraChatComponent.to) {
      clearTimeout(AgoraChatComponent.to);
      AgoraChatComponent.to = null;
    }
  }
  onSubmit() {
    const secureMessage = this.secureText(this.form.value.message);
    // console.log('secureMessage', secureMessage);
    const message = this.createMessage(secureMessage);
    this.sendMessage(message);
    this.form.get('message').value = null;
    if (this.demo && USE_RANDOM_MESSAGE) {
      this.randomMessage();
    }
  }
  onKeyDown(event) {
    // console.log('onKeyDown', event);
    if (event.key === 'Enter') {
      if (event.shiftKey) {
        this.rows = Math.min(4, this.rows + 1);
        this.pushChanges();
      } else {
        event.preventDefault();
        this.onSubmit();
        this.rows = 1;
      }
      const {
        node
      } = rxcomp.getContext(this);
      const textareaNode = node.querySelector('textarea');
      textareaNode.setAttribute('rows', this.rows);
    }
  }
  onToggleEmoji() {
    this.showEmoji = !this.showEmoji;
    this.pushChanges();
  }
  onSelectEmoji(emoji) {
    this.showEmoji = false;
    this.form.get('message').value = (this.form.get('message').value || '') + emoji.char;
    // this.pushChanges();
  }

  secureText(unsecureText) {
    let newDocument = new DOMParser().parseFromString(unsecureText, 'text/html');
    return newDocument.body.textContent || '';
  }
  createMessage(text) {
    const message = new ChatMessage(text, StateService.state.uid, StateService.state.name);
    return message;
  }
  sendMessage(message) {
    this.pushMessage(message);
    const agora = this.agora;
    if (agora) {
      agora.addOrUpdateChannelMessages([message.getPayload()]);
    }
    MessageService.send(message);
  }
  onClose(event) {
    this.close.next();
  }
  scrollToBottom() {
    const {
      node
    } = rxcomp.getContext(this);
    const scrollView = node.querySelector('.group--scrollview');
    scrollView.scrollTop = scrollView.scrollHeight;
  }
  pushMessage(message) {
    const messages = this.messages ? this.messages.slice() : [];
    this.removeTyping({
      type: MessageType.ChatTypingBegin,
      clientId: message.clientId
    }, this.messages);
    messages.push(message);
    this.updateMessages(messages);
  }
  typingBegin(message) {
    // console.log('AgoraChatComponent.typingBegin', message);
    const messages = this.messages ? this.messages.slice() : [];
    messages.push(message);
    this.updateMessages(messages);
  }
  typingEnd(message) {
    // console.log('AgoraChatComponent.typingEnd', message);
    const messages = this.messages ? this.messages.slice() : [];
    this.removeTyping({
      type: MessageType.ChatTypingBegin,
      clientId: message.clientId
    }, messages);
    this.updateMessages(messages);
  }
  removeTyping(message, messages, recursive) {
    if (recursive === void 0) {
      recursive = true;
    }
    const index = messages.reduce((p, c, i) => {
      return c.type === message.type && c.clientId === message.clientId ? i : p;
    }, -1);
    if (index !== -1) {
      messages.splice(index, 1);
      if (recursive === true) {
        this.removeTyping(message, messages, true);
      }
    }
    return index;
  }
  checkTypings(changes) {
    const typings = changes.message && changes.message.length > 0 || false;
    // console.log('AgoraChatComponent.checkTypings', typings, this.typings_);
    if (this.typings_ !== typings) {
      this.typings_ = typings;
      if (typings) {
        MessageService.send({
          type: MessageType.ChatTypingBegin
        });
      } else {
        MessageService.send({
          type: MessageType.ChatTypingEnd
        });
      }
    }
  }
  updateMessages(messages) {
    this.messages = messages;
    {
      this.groupedMessages = [];
      this.pushChanges();
    }
    const groupedMessages = [];
    messages.forEach(message => {
      if (message.type === MessageType.ChatMessage) {
        // ChatMessage
        const lastMessage = groupedMessages.length ? groupedMessages[groupedMessages.length - 1] : null;
        if (lastMessage && lastMessage.clientId === message.clientId) {
          lastMessage.message += `<p>${message.message}</p>`;
        } else {
          groupedMessages.push(message.getCopy());
        }
      } else if (message.type === MessageType.ChatTypingBegin) {
        // ChatTypingBegin
        const lastMessage = groupedMessages.reduce((p, c, i) => {
          return c.clientId === message.clientId ? c : p;
        }, null);
        if (lastMessage) {
          lastMessage.typing = true;
        }
        // console.log('MessageType.ChatTypingBegin', lastMessage, message);
      }
    });
    // setTimeout(() => {
    this.groupedMessages = groupedMessages;
    this.pushChanges();
    // console.log('AgoraChatComponent.updateMessages', messages, groupedMessages);
    setTimeout(() => {
      this.scrollToBottom();
    }, 1);
    // }, 1);
  }

  isValid() {
    const isValid = this.form.valid;
    return isValid && this.form.value.message && this.form.value.message.length > 0;
  }

  // demo

  randomMessage() {
    if (AgoraChatComponent.to) {
      clearTimeout(AgoraChatComponent.to);
      AgoraChatComponent.to = null;
    }
    AgoraChatComponent.to = setTimeout(() => {
      const message = AgoraChatComponent.createRandomMessage();
      this.sendMessage(message);
    }, (2 + Math.random() * 6) * 1000);
  }
}
AgoraChatComponent.meta = {
  selector: '[agora-chat]',
  outputs: ['close'],
  template: /* html */`
		<div class="group--scrollview" [class]="'rows--' + rows">
			<div class="group--virtual" *virtual="let item of groupedMessages" [mode]="4" [width]="350" [gutter]="0" [reverse]="true">
				<!-- serve un nodo figlio -->
				<div class="listing__item message" [class]="{ me: item.me, typing: item.typing }">
					<div class="message__avatar" [title]="item.name"><span [innerHTML]="item.shortName"></span></div>
					<div class="message__content">
						<div [innerHTML]="item.message | message"></div>
						<div class="typing-indicator">
							<span></span>
							<span></span>
							<span></span>
						</div>
					</div>
				</div>
			</div>
		</div>
		<div class="group--message" [class]="'rows--' + rows">
			<form class="form" [formGroup]="form" (submit)="isValid() && onSubmit($event)" name="form" role="form" novalidate autocomplete="off">
				<div class="group--form group--form--addon" [class]="{ required: controls.message.validators.length, 'addon': controls.message.valid }">
					<!-- <input type="text" class="control--text" [formControl]="controls.message" [placeholder]="'bhere_write_a_message' | label" /> -->
					<button type="button" class="control--pre" (click)="onToggleEmoji()">
						<svg class="emoji" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#emoji"></use></svg>
					</button>
					<textarea class="control--text" [formControl]="controls.message" [placeholder]="'bhere_write_a_message' | label" rows="1" (keydown)="onKeyDown($event)"></textarea>
					<button type="submit" class="control--addon">
						<svg class="copy" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#send"></use></svg>
					</button>
				</div>
			</form>
		</div>
		<div class="group--close">
			<button type="button" class="btn--close" [title]="'title_close' | label" (click)="onClose($event)">
				<svg class="copy" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#close"></use></svg>
			</button>
		</div>
		<div class="group--emoji" [class]="'rows--' + rows" agora-chat-emoji (emoji)="onSelectEmoji($event)" (close)="onToggleEmoji()" *if="showEmoji">
			<div class="group--virtual" *virtual="let item of items" [mode]="1" [width]="40" [gutter]="10" [reverse]="true">
				<!-- serve un nodo figlio -->
				<div class="listing__item emoji">
					<button type="button" class="btn--emoji" (click)="onSelect(item)"><span [innerHTML]="item.char"></span></button>
				</div>
			</div>
			<div class="group--close">
				<button type="button" class="btn--close" [title]="'title_close' | label" (click)="onClose($event)">
					<svg class="copy" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#close"></use></svg>
				</button>
			</div>
		</div>
	`
};
AgoraChatComponent.getFakeList = () => {
  let messages = [{
    'date': 1614592230000,
    'name': 'Jhon Appleseed',
    'message': 'Function-based web-enabled benchmark',
    'clientId': '7341614597544882'
  }, {
    'date': 1614592240000,
    'name': 'Jhon Appleseed',
    'message': 'Customizable exuding superstructure',
    'clientId': '7341614597544882'
  }, {
    'date': 1614592250000,
    'name': 'Gilles Pitkins',
    'message': 'Synergistic interactive archive',
    'clientId': 'cfe9ff5b-f7da-449d-bf5a-3184b5eba6ea'
  }, {
    'date': 1614592260000,
    'name': 'Jhon Appleseed',
    'message': 'Digitized client-server initiative',
    'clientId': '7341614597544882'
  }, {
    'date': 1614592270000,
    'name': 'Jhon Appleseed',
    'message': 'Quality-focused tertiary open system',
    'clientId': '7341614597544882'
  }, {
    'date': 1614592280000,
    'name': 'Jhon Appleseed',
    'message': 'Exclusive uniform middleware',
    'clientId': '7341614597544882'
  }, {
    'date': 1614592290000,
    'name': 'John Pruckner',
    'message': 'Decentralized disintermediate extranet',
    'clientId': 'ae51e846-d043-41e9-bb5c-3189181e5b43'
  }, {
    'date': 1614592300000,
    'name': 'Lamont Georgievski',
    'message': 'Enhanced static approach',
    'clientId': '1961cd9e-93aa-4bd0-b96a-89fcbd36b257'
  }, {
    'date': 1614592310000,
    'name': 'Jhon Appleseed',
    'message': 'Ergonomic clear-thinking info-mediaries',
    'clientId': '7341614597544882'
  }, {
    'date': 1614592320000,
    'name': 'Jeri Pedroni',
    'message': 'Grass-roots dynamic encryption',
    'clientId': '13d69bba-3656-449b-8fe3-d7a87062b044'
  }, {
    'date': 1614592330000,
    'name': 'Frederik Dechelle',
    'message': 'Compatible disintermediate policy',
    'clientId': '9151ebe0-efa8-40b4-a341-b8fd489e9c88'
  }, {
    'date': 1614592340000,
    'name': 'Jhon Appleseed',
    'message': 'Inverse user-facing adapter',
    'clientId': '7341614597544882'
  }, {
    'date': 1614592350000,
    'name': 'Jhon Appleseed',
    'message': 'Future-proofed even-keeled application',
    'clientId': '7341614597544882'
  }, {
    'date': 1614592360000,
    'name': 'Cassie Jonathon',
    'message': 'Profit-focused content-based budgetary management',
    'clientId': '5b3dc6f3-2a3d-493d-aac5-66ddfce2d709'
  }, {
    'date': 1614592370000,
    'name': 'Jhon Appleseed',
    'message': 'Managed intermediate monitoring',
    'clientId': '7341614597544882'
  }, {
    'date': 1614592380000,
    'name': 'Jhon Appleseed',
    'message': 'Exclusive client-server encoding',
    'clientId': '7341614597544882'
  }, {
    'date': 1614592390000,
    'name': 'Jhon Appleseed',
    'message': 'Cross-group system-worthy matrices',
    'clientId': '7341614597544882'
  }, {
    'date': 1614592400000,
    'name': 'Jhon Appleseed',
    'message': 'Upgradable encompassing benchmark',
    'clientId': '7341614597544882'
  }, {
    'date': 1614592410000,
    'name': 'Emelen Beevors',
    'message': 'Function-based full-range knowledge base',
    'clientId': 'c93aea47-ebd8-4e5e-88fd-52053dd35cd1'
  }, {
    'date': 1614592420000,
    'name': 'Jhon Appleseed',
    'message': 'Synergistic system-worthy capability',
    'clientId': '7341614597544882'
  }];
  while (messages.length < 100) {
    messages = messages.concat(messages);
  }
  return messages;
  // return messages.slice(0, 5);
};

AgoraChatComponent.createRandomMessage = text => {
  const message = new ChatMessage({
    date: Date.now(),
    clientId: '9fe0e1b9-6a6b-418b-b916-4bbff3eeb123',
    name: 'Herman frederick',
    message: 'Lorem ipsum dolor'
  }, StateService.state.uid, StateService.state.name);
  return message;
};
AgoraChatComponent.randomMessage = (instance, messages) => {
  const getRandomMessage = function () {
    const others = messages.filter(x => x.id !== '7341614597544882');
    let message = others[Math.floor(others.length * Math.random())];
    message = new ChatMessage({
      date: Date.now(),
      clientId: '9fe0e1b9-6a6b-418b-b916-4bbff3eeb123',
      name: message.name,
      message: message.message
    }, StateService.state.uid, StateService.state.name);
    return message;
  };
  if (AgoraChatComponent.to) {
    clearTimeout(AgoraChatComponent.to);
    AgoraChatComponent.to = null;
  }
  AgoraChatComponent.to = setTimeout(() => {
    const message = getRandomMessage();
    instance.sendMessage(message);
    AgoraChatComponent.randomMessage(instance, messages);
  }, (2 + Math.random() * 6) * 1000);
};class AgoraCheckComponent extends rxcomp.Component {}
AgoraCheckComponent.meta = {
  selector: '[agora-check]',
  inputs: ['value'],
  template: /* html */`
		<svg *if="value == null" class="checkmark idle" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 52 52">
			<circle class="checkmark__circle" cx="26" cy="26" r="25" fill="none"/>
		</svg>
		<svg *if="value === true" class="checkmark success" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 52 52">
			<circle class="checkmark__circle" cx="26" cy="26" r="25" fill="none"/>
			<path class="checkmark__icon" fill="none" d="M14.1 27.2l7.1 7.2 16.7-16.8" stroke-linecap="round"/>
		</svg>
		<svg *if="value === false" class="checkmark error" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 52 52">
			<circle class="checkmark__circle" cx="26" cy="26" r="25" fill="none"/>
			<path class="checkmark__icon" stroke-linecap="round" fill="none" d="M16 16 36 36 M36 16 16 36"/>
		</svg>
	`
};class ModalEvent {
  constructor(data) {
    this.data = data;
  }
}
class ModalResolveEvent extends ModalEvent {}
class ModalRejectEvent extends ModalEvent {}
class ModalService {
  static get hasModal() {
    return this.hasModal_;
  }
  static set hasModal(hasModal) {
    if (this.hasModal_ !== hasModal) {
      this.hasModal_ = hasModal;
      const body = document.querySelector('body');
      hasModal ? body.classList.add('modal-open') : body.classList.remove('modal-open');
    }
  }
  static open$(modal) {
    this.busy$.next(true);
    return (modal.iframe ? rxjs.of( /* html */`<div class="iframe-modal" iframe-modal src="${modal.iframe}"></div>`) : this.getTemplate$(modal)).pipe(
    // startWith(new ModalLoadEvent(Object.assign({}, modal.data, { $src: modal.src }))),
    operators.map(template => {
      return {
        node: this.getNode(template),
        data: modal.data,
        modal: modal
      };
    }), operators.tap(node => {
      this.modal$.next(node);
      this.hasModal = true;
      this.busy$.next(false);
      // this.events$.next(new ModalLoadedEvent(Object.assign({}, modal.data, { $src: modal.src })));
    }), operators.switchMap(node => this.events$), operators.tap(_ => this.hasModal = false));
  }
  static getTemplate$(modal) {
    if (modal.src) {
      return rxjs.from(fetch(modal.src).then(response => {
        return response.text();
      }));
    } else if (modal.template) {
      return rxjs.of(modal.template);
    } else {
      return rxjs.EMPTY;
    }
  }
  static getNode(template) {
    const div = document.createElement('div');
    div.innerHTML = template;
    const node = div.firstElementChild;
    return node;
  }
  static reject(data) {
    this.modal$.next(null);
    this.events$.next(new ModalRejectEvent(data));
  }
  static resolve(data) {
    this.modal$.next(null);
    this.events$.next(new ModalResolveEvent(data));
  }
}
ModalService.modal$ = new rxjs.Subject();
ModalService.events$ = new rxjs.Subject();
ModalService.busy$ = new rxjs.Subject();class LocalStorageService {
  static delete(name) {
    if (this.isLocalStorageSupported()) {
      window.localStorage.removeItem(name);
    }
  }
  static exist(name) {
    if (this.isLocalStorageSupported()) {
      return window.localStorage[name] !== undefined;
    }
  }
  static get(name) {
    let value = null;
    if (this.isLocalStorageSupported() && window.localStorage[name] !== undefined) {
      try {
        value = JSON.parse(window.localStorage[name]);
      } catch (e) {
        console.log('LocalStorageService.get.error parsing', name, e);
      }
    }
    return value;
  }
  static set(name, value) {
    if (this.isLocalStorageSupported()) {
      try {
        const cache = [];
        const json = JSON.stringify(value, function (key, value) {
          if (typeof value === 'object' && value !== null) {
            if (cache.indexOf(value) !== -1) {
              // Circular reference found, discard key
              return;
            }
            cache.push(value);
          }
          return value;
        });
        window.localStorage.setItem(name, json);
      } catch (e) {
        console.log('LocalStorageService.set.error serializing', name, value, e);
      }
    }
  }
  static isLocalStorageSupported() {
    if (this.supported) {
      return true;
    }
    let supported = false;
    try {
      supported = 'localStorage' in window && window.localStorage !== null;
      if (supported) {
        window.localStorage.setItem('test', '1');
        window.localStorage.removeItem('test');
      } else {
        supported = false;
      }
    } catch (e) {
      supported = false;
    }
    this.supported = supported;
    return supported;
  }
}const TIMEOUT = 100;
class AgoraChecklistService {
  static checklist$() {
    return StateService.state$.pipe(operators.first(), operators.map(state => {
      const event = {
        shouldCheckAudio: true,
        shouldCheckVideo: true,
        key: 'checklist_audio_video',
        uid: null,
        checklist: {
          browser: null,
          https: null,
          video: null,
          audio: null,
          rtc: null,
          rtm: null
        },
        errors: {}
      };
      if (state.role === RoleType.Viewer) {
        event.shouldCheckAudio = false;
        event.shouldCheckVideo = false;
      }
      if (DeviceService.platform === DevicePlatform.VRHeadset) {
        event.shouldCheckAudio = true;
        event.shouldCheckVideo = false;
      }
      event.key = `checklist${event.shouldCheckAudio ? '_audio' : ''}${event.shouldCheckVideo ? '_video' : ''}`;
      return event;
    }), operators.switchMap(event => {
      const checklist = LocalStorageService.get(event.key);
      if (checklist === true) {
        Object.keys(event.checklist).forEach(key => {
          event.checklist[key] = true;
        });
      }
      return rxjs.of(event);
    }));
  }
  static isChecked(event) {
    const isChecked = Object.keys(event.checklist).reduce((p, c, i) => {
      const checked = p && event.checklist[c];
      switch (c) {
        case 'audio':
          return checked || !event.shouldCheckAudio;
        case 'video':
          return checked || !event.shouldCheckVideo;
        default:
          return checked;
      }
    }, true);
    return isChecked;
  }
  static isChecked$() {
    return this.checklist$().pipe(operators.map(event => this.isChecked(event)));
  }
  static checkEvent$() {
    return this.checklist$().pipe(operators.switchMap(event => {
      const checklist = Object.keys(event.checklist).reduce((p, c, i) => {
        return p && event.checklist[c];
      }, true);
      if (checklist === true) {
        return rxjs.of(event);
      } else {
        LocalStorageService.set(event.key, false);
        const event$ = new rxjs.Subject();
        const check$ = rxjs.of(event).pipe(operators.delay(1000), operators.switchMap(event => {
          event$.next(event);
          return this.checkBrowserEvent$(event);
        }), operators.switchMap(event => {
          event$.next(event);
          return this.checkHttpsEvent$(event);
        }), operators.switchMap(event => {
          event$.next(event);
          return this.checkAudioEvent$(event);
        }), operators.switchMap(event => {
          event$.next(event);
          return this.checkVideoEvent$(event);
        }), operators.switchMap(event => {
          event$.next(event);
          return this.checkRtcEvent$(event);
        }), operators.switchMap(event => {
          event$.next(event);
          return this.checkRtmEvent$(event);
        }), operators.tap(event => {
          // console.log('AgoraChecklistService', event);
          LocalStorageService.set(event.key, true);
        }));
        return rxjs.merge(event$, check$);
      }
    }));
  }
  static check$() {
    return this.checklist$().pipe(operators.switchMap(event => {
      const checklist = Object.keys(event.checklist).reduce((p, c, i) => {
        return p && event.checklist[c];
      }, true);
      if (checklist === true) {
        return rxjs.of(event);
      } else {
        LocalStorageService.set(event.key, false);
        return rxjs.of(event).pipe(operators.delay(1000), operators.switchMap(event => this.checkBrowserEvent$(event)), operators.switchMap(event => this.checkHttpsEvent$(event)), operators.switchMap(event => this.checkAudioEvent$(event)), operators.switchMap(event => this.checkVideoEvent$(event)), operators.switchMap(event => this.checkRtcEvent$(event)), operators.switchMap(event => this.checkRtmEvent$(event)), operators.tap(event => {
          // console.log('AgoraChecklistService', event);
          LocalStorageService.set(event.key, true);
        }));
      }
    }));
  }
  static checkBrowser$() {
    const browser = AgoraRTC.checkSystemRequirements();
    return rxjs.of(browser);
  }
  static checkBrowserEvent$(event) {
    return this.checkBrowser$().pipe(operators.switchMap(browser => {
      event.checklist.browser = browser;
      if (browser) {
        return rxjs.of(event).pipe(operators.delay(TIMEOUT));
      } else {
        event.errors.browser = LabelPipe.transform('bhere_browser_error');
        return this.checkHttpsEvent$(event).pipe(operators.switchMap(event => {
          {
            return rxjs.throwError(event);
          }
        }));
      }
    }), operators.catchError(error => {
      console.log('checkBrowserEvent$.error', error);
      event.checklist.browser = false;
      event.errors.browser = LabelPipe.transform('bhere_browser_error');
      return rxjs.throwError(event);
    }));
  }
  static checkHttps$() {
    const https = window.location.protocol === 'https:';
    return rxjs.of(https);
  }
  static checkHttpsEvent$(event) {
    return this.checkHttps$().pipe(operators.switchMap(https => {
      event.checklist.https = https;
      if (https) {
        return rxjs.of(event).pipe(operators.delay(TIMEOUT));
      } else {
        event.errors.https = LabelPipe.transform('bhere_https_error');
        {
          return rxjs.throwError(event);
        }
      }
    }), operators.catchError(error => {
      console.log('checkHttpsEvent$.error', error);
      event.checklist.https = false;
      event.errors.https = LabelPipe.transform('bhere_https_error');
      return rxjs.throwError(event);
    }));
  }
  static checkAudio$() {
    return rxjs.from(AgoraService.getDevices()).pipe(operators.map(devices => {
      const audioinput = devices.find(x => x.kind === 'audioinput' && x.deviceId);
      return audioinput != null;
    }));
  }
  static checkAudioEvent$(event) {
    // console.log('checkAudioEvent$', event);
    if (event.shouldCheckAudio) {
      return this.checkAudio$().pipe(operators.switchMap(audio => {
        event.checklist.audio = audio;
        if (audio) {
          return rxjs.of(event).pipe(operators.delay(TIMEOUT));
        } else {
          event.errors.audio = LabelPipe.transform('bhere_audio_error');
          // console.log('checkAudioEvent$.error', event);
          {
            return rxjs.throwError(event);
          }
        }
      }), operators.catchError(error => {
        console.log('checkAudioEvent$.error', error);
        event.checklist.audio = false;
        event.errors.audio = LabelPipe.transform('bhere_audio_error');
        return rxjs.throwError(event);
      }));
    } else {
      return rxjs.of(event);
    }
  }
  static checkVideo$() {
    return rxjs.from(AgoraService.getDevices()).pipe(operators.map(devices => {
      const videoinput = devices.find(x => x.kind === 'videoinput' && x.deviceId);
      return videoinput != null;
    }));
  }
  static checkVideoEvent$(event) {
    if (event.shouldCheckVideo) {
      return this.checkVideo$().pipe(operators.switchMap(video => {
        event.checklist.video = video;
        if (video) {
          return rxjs.of(event).pipe(operators.delay(TIMEOUT));
        } else {
          event.errors.video = LabelPipe.transform('bhere_video_error');
          {
            return rxjs.throwError(event);
          }
        }
      }), operators.catchError(error => {
        console.log('checkVideoEvent$.error', error);
        event.checklist.video = false;
        event.errors.video = LabelPipe.transform('bhere_video_error');
        return rxjs.throwError(event);
      }));
    } else {
      return rxjs.of(event);
    }
  }
  static checkRtc$() {
    return rxjs.from(AgoraService.checkRtcConnection());
  }
  static checkRtcEvent$(event) {
    return this.checkRtc$().pipe(operators.switchMap(uid => {
      event.uid = uid;
      event.checklist.rtc = uid !== false;
      if (uid) {
        return rxjs.of(event).pipe(operators.delay(TIMEOUT));
      } else {
        event.errors.rtc = LabelPipe.transform('bhere_rtc_error');
        {
          return rxjs.throwError(event);
        }
      }
    }), operators.catchError(error => {
      console.log('checkRtcEvent$.error', error);
      event.checklist.rtc = false;
      event.errors.rtc = LabelPipe.transform('bhere_rtc_error');
      return rxjs.throwError(event);
    }));
  }
  static checkRtm$(uid) {
    return rxjs.from(AgoraService.checkRtmConnection(uid));
  }
  static checkRtmEvent$(event) {
    return this.checkRtm$(event.uid).pipe(operators.switchMap(uid => {
      event.checklist.rtm = uid !== false;
      if (uid) {
        return rxjs.of(event);
      } else {
        event.errors.rtm = LabelPipe.transform('bhere_rtm_error');
        return rxjs.throwError(event);
      }
    }), operators.catchError(error => {
      console.log('checkRtmEvent$.error', error);
      event.checklist.rtm = false;
      event.errors.rtm = LabelPipe.transform('bhere_rtm_error');
      return rxjs.throwError(event);
    }));
  }
}class AgoraConfigureFirewallModalComponent extends rxcomp.Component {
  onClose() {
    ModalService.resolve();
  }
}
AgoraConfigureFirewallModalComponent.meta = {
  selector: '[agora-configure-firewall-modal]',
  template: /* html */`
		<div class="modal__header">
			<button type="button" class="btn--close" (click)="onClose()">
				<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#close"></use></svg>
			</button>
		</div>
		<div class="container">
			<div class="form" [innerHTML]="'bhere_configure_firewall' | label"></div>
			<div class="group--cta">
				<button type="button" class="btn--accept" (click)="onClose()">
					<span>Chiudi</span>
				</button>
			</div>
		</div>
	`
};
AgoraConfigureFirewallModalComponent.chunk = () => /* html */'<div class="configure-firewall-modal" agora-configure-firewall-modal></div>';class AgoraChecklistComponent extends rxcomp.Component {
  onInit() {
    this.platform = DeviceService.platform;
    this.checklist = {};
    this.errors = {};
    this.state = {};
    this.busy = true;
    this.shouldCheckAudio = false;
    this.shouldCheckVideo = false;
    AgoraChecklistService.checkEvent$().pipe(operators.takeUntil(this.unsubscribe$)).subscribe(event => {
      // console.log('AgoraChecklistService', event, event.errors);
      this.shouldCheckAudio = event.shouldCheckAudio;
      this.shouldCheckVideo = event.shouldCheckVideo;
      this.checklist = event.checklist;
      this.errors = event.errors || {};
      // console.log(JSON.stringify(event.errors));
      const success = AgoraChecklistService.isChecked(event);
      if (success) {
        this.checklist.success = success;
        this.busy = false;
        this.pushChanges();
        if (this.state.role === RoleType.SmartDevice) {
          this.onNext();
        }
      } else {
        this.pushChanges();
      }
      // console.log(event);
    }, error => {
      // console.log('AgoraChecklistService.error', error);
      this.errors = error.errors || {};
      this.checklist.error = true;
      this.busy = false;
      this.pushChanges();
    });
  }
  onNext() {
    this.checked.next(this.checklist);
  }
  openHttps() {
    window.location.href = window.location.href.replace('http://', 'https://').replace(':5000', ':6443');
  }
  showFirewallConfiguration() {
    ModalService.open$({
      template: AgoraConfigureFirewallModalComponent.chunk()
    }).pipe(operators.first()).subscribe();
  }
}
AgoraChecklistComponent.meta = {
  selector: '[agora-checklist]',
  outputs: ['checked'],
  template: /* html */`
	<div class="group--info">
		<div class="group--info__content stagger--childs">
			<div class="title" *if="busy" [innerHTML]="'bhere_checklist_busy' | label"></div>
			<div class="title" *if="checklist.success" [innerHTML]="'bhere_checklist_success' | label"></div>
			<div class="title" *if="checklist.error" [innerHTML]="'bhere_checklist_error' | label"></div>
			<ul class="group--checklist stagger--childs">
				<li class="checklist__item check"><span>Browser</span> <span agora-check [value]="checklist.browser"></span></li>
				<li class="checklist__item error" *if="errors.browser"><a class="btn--link" href="https://browsehappy.com/" target="_blank" rel="noopener" [innerHTML]="errors.browser"></a></li>
				<li class="checklist__item check"><span>Https</span> <span agora-check [value]="checklist.https"></span></li>
				<li class="checklist__item error" *if="errors.https"><a class="btn--link" (click)="openHttps()" [innerHTML]="errors.https"></a></li>
				<li class="checklist__item check" *if="shouldCheckAudio"><span>Audio</span> <span agora-check [value]="checklist.audio"></span></li>
				<li class="checklist__item error" *if="errors.audio"><span [innerHTML]="errors.audio"></span></li>
				<li class="checklist__item check" *if="shouldCheckVideo"><span>Video</span> <span agora-check [value]="checklist.video"></span></li>
				<li class="checklist__item error" *if="errors.video"><span [innerHTML]="errors.video"></span></li>
				<li class="checklist__item check"><span>Realtime Communication</span> <span agora-check [value]="checklist.rtc"></span></li>
				<li class="checklist__item error" *if="errors.rtc"><a class="btn--link" (click)="showFirewallConfiguration()" [innerHTML]="errors.rtc"></a></li>
				<li class="checklist__item check"><span>Realtime Messaging</span> <span agora-check [value]="checklist.rtm"></span></li>
				<li class="checklist__item error" *if="errors.rtm"><a class="btn--link" (click)="showFirewallConfiguration()" [innerHTML]="errors.rtm"></a></li>
			</ul>
			<button type="submit" class="btn--next" [class]="{ disabled: !checklist.success, ready: checklist.success }" (click)="onNext()">
				<span [innerHTML]="'bhere_proceed' | label"></span>
			</button>
		</div>
	</div>
	`
};class AudioStreamService {
  static get context() {
    if (!this.context_ && 'AudioContext' in window) {
      this.context_ = new AudioContext();
    }
    return this.context_;
  }

  /*
  static get processorNode() {
  	if (!this.processorNode_) {
  		this.processorNode_ = this.context.createScriptProcessor(BUFF_SIZE, 1, 1);
  	}
  	return this.processorNode_;
  }
  */

  /*
  static get gain() {
  	if (!this.gain_) {
  		this.gain_ = this.context.createGain();
  	}
  	return this.gain_;
  }
  */

  static get analyser() {
    if (!this.analyser_) {
      try {
        this.analyser_ = this.context.createAnalyser();
      } catch (error) {
        console.log('AudioStreamService.analyser', error);
      }
    }
    return this.analyser_;
  }
  static addSource(streamOrElement) {
    const key = streamOrElement instanceof MediaStream ? streamOrElement.id : streamOrElement;
    if (!this.sources_[key]) {
      if (streamOrElement instanceof MediaStream) {
        this.sources_[key] = this.context.createMediaStreamSource(streamOrElement.clone());
      } else {
        this.sources_[key] = this.context.createMediaElementSource(streamOrElement);
      }
      // this.sources_[key] = streamOrElement instanceof MediaStream ? this.context.createMediaStreamSource(streamOrElement) : this.context.createMediaElementSource(streamOrElement);
    }

    return this.sources_[key];
  }
  static removeSource(streamOrElement) {
    const key = streamOrElement instanceof MediaStream ? streamOrElement.id : streamOrElement;
    return this.removeSourceKey(key);
  }
  static removeSourceKey(key) {
    // console.log('AudioStreamService.removeSourceKey', key);
    let source;
    if (this.sources_[key]) {
      source = this.sources_[key];
      /*
      if (source.mediaStream) {
      	source.mediaStream.stop();
      }
      source.stop();
      */
      if (this.analyser) {
        source.disconnect(this.analyser);
      }
      source.disconnect();
      delete this.sources_[key];
    }
    return source;
  }
  static frequency$(streamOrElement, fftSize) {
    if (fftSize === void 0) {
      fftSize = 64;
    }
    if (fftSize % 2 === 1) {
      throw fftSize;
    }
    const state = new Uint8Array(fftSize / 2);
    const context = this.context;
    if (context) {
      const analyser = this.analyser;
      if (analyser) {
        // Connect the output of the analyser to the destination
        // analyser.connect(context.destination); // no audio !
        // console.log(analyser.fftSize); // 2048 by default
        // console.log(analyser.frequencyBinCount); // will give us 1024 data points
        analyser.fftSize = fftSize; // 64
        // console.log(analyser.frequencyBinCount); // fftSize/2 = 32 data points
        const source = this.addSource(streamOrElement);
        // source.connect(context.destination); // no audio!
        // Connect the output of the source to the input of the analyser
        source.connect(analyser);
      }
      const state$ = new rxjs.BehaviorSubject(state);
      return AudioStreamService.frame$.pipe(operators.withLatestFrom(state$), operators.map(_ref => {
        let [deltaTime, state] = _ref;
        if (analyser) {
          // Get the new frequency data
          analyser.getByteFrequencyData(state);
          /*
          const max = state.reduce((p, c, i) => {
          	return Math.max(c, p);
          }, 0);
          if (max > 0) {
          	// console.log(max);
          }
          */
          // Update the visualisation
        }

        return state;
      }), operators.tap(state => state$.next(state)), operators.finalize(() => {
        this.removeSource(streamOrElement);
      }));
    } else {
      return rxjs.of(state);
    }
  }

  // unused
  static volume$(streamOrElement) {
    const state = {
      volume: 0,
      clipped: false
    };
    const context = this.context;
    // console.log('AudioStreamService.volume$', context, state);
    if (context) {
      const source = this.addSource(streamOrElement);
      const meter = AudioStreamService.audioMeterCreate();
      source.connect(meter);
      const state$ = new rxjs.BehaviorSubject(state);
      return AudioStreamService.frame$.pipe(operators.withLatestFrom(state$), operators.map(_ref2 => {
        let [deltaTime, state] = _ref2;
        state.clipped = meter.checkClipping();
        state.volume = meter.volume;
        return state;
      }), operators.tap(state => state$.next(state)), operators.finalize(() => {
        this.removeSource(streamOrElement);
      }));
    } else {
      return rxjs.of(state);
    }
  }

  // unused
  static audioMeterCreate(clipLevel, averaging, clipLag) {
    if (clipLevel === void 0) {
      clipLevel = 0.98;
    }
    if (averaging === void 0) {
      averaging = 0.95;
    }
    if (clipLag === void 0) {
      clipLag = 750;
    }
    const context = this.context;
    if (context) {
      const processor = context.createScriptProcessor(512);
      processor.onaudioprocess = this.audioMeterProcess;
      processor.checkClipping = this.audioMeterClip;
      processor.dispose = this.audioMeterDispose;
      processor.clipping = false;
      processor.lastClip = 0;
      processor.volume = 0;
      processor.clipLevel = clipLevel;
      processor.averaging = averaging;
      processor.clipLag = clipLag;
      // this will have no effect, since we don't copy the input to the output,
      // but works around a current Chrome bug.
      processor.connect(context.destination);
      return processor;
    }
  }
  static audioMeterProcess(event) {
    const buffer = event.inputBuffer.getChannelData(0);
    const bufferLength = buffer.length;
    let sum = 0;
    let x;

    // Do a root-mean-square on the samples: sum up the squares...
    for (let i = 0; i < bufferLength; i++) {
      x = buffer[i];
      if (Math.abs(x) >= this.clipLevel) {
        this.clipping = true;
        this.lastClip = window.performance.now();
      }
      sum += x * x;
    }

    // ... then take the square root of the sum.
    const rms = Math.sqrt(sum / bufferLength);

    // Now smooth this out with the averaging factor applied
    // to the previous sample - take the max here because we
    // want 'fast attack, slow release.'
    this.volume = Math.max(rms, this.volume * this.averaging);
  }
  static audioMeterClip() {
    if (!this.clipping) {
      return false;
    }
    if (this.lastClip + this.clipLag < window.performance.now()) {
      this.clipping = false;
    }
    return this.clipping;
  }
  static audioMeterDispose() {
    this.disconnect();
    this.onaudioprocess = null;
  }
  static step$(previous) {
    /**
     * This function returns an observable that will emit the next frame once the
     * browser has returned an animation frame step. Given the previous frame it calculates
     * the delta time, and we also clamp it to 30FPS in case we get long frames.
     */
    return rxjs.Observable.create(observer => {
      requestAnimationFrame(startTime => {
        // Millis to seconds
        const deltaTime = previous ? (startTime - previous.startTime) / 1000 : 0;
        observer.next({
          startTime,
          deltaTime
        });
      });
    }).pipe(operators.map(frame => {
      if (frame.deltaTime > 1 / 30) {
        frame.deltaTime = 1 / 30;
      }
      return frame;
    }));
  }
  static dispose() {
    Object.keys(this.sources_).forEach(key => {
      this.removeSourceKey(key);
    });
    const analyser = this.analyser;
    if (analyser) {
      analyser.disconnect();
    }
    this.sources_ = {};
    // this.context_.close().then(() => console.log('AudioStreamService.dispose'));
    // this.context_ = null;
  }
}

AudioStreamService.sources_ = {};
AudioStreamService.frame$ = rxjs.of(undefined).pipe(operators.expand(value => AudioStreamService.step$(value)),
// Expand emits the first value provided to it, and in this
//  case we just want to ignore the undefined input frame
operators.filter(frame => frame !== undefined), operators.map(frame => frame.deltaTime), operators.share());class AgoraDevicePreviewComponent extends rxcomp.Component {
  get video() {
    return this.video_;
  }
  set video(video) {
    if (this.video_ !== video) {
      this.video_ = video;
      if (this.change) {
        this.change.next();
        this.init();
        this.initStream();
      }
    }
  }
  get audio() {
    return this.audio_;
  }
  set audio(audio) {
    if (this.audio_ !== audio) {
      this.audio_ = audio;
      if (this.change) {
        this.change.next();
        this.init();
        this.initStream();
      }
    }
  }
  get hasPreview() {
    return this.platform !== DevicePlatform.IOS && this.platform !== DevicePlatform.VRHeadset;
  }
  onInit() {
    this.init();
  }
  init() {
    if (this.initialized_) {
      return;
    }
    this.initialized_ = true;
    this.platform = DeviceService.platform;
    const {
      node
    } = rxcomp.getContext(this);
    this.onLoadedMetadata = this.onLoadedMetadata.bind(this);
    const preview = this.preview = node.querySelector('video');
    preview.addEventListener('loadedmetadata', this.onLoadedMetadata);
    const audio = node.querySelector('.audio');
    if (this.hasPreview) {
      this.bars = new Array(32).fill(0).map(x => {
        const bar = document.createElement('div');
        bar.classList.add('bar');
        audio.appendChild(bar);
        return bar;
      });
    }
  }
  onDestroy() {
    const preview = this.preview;
    preview.removeEventListener('loadedmetadata', this.onLoadedMetadata);
    if (this.hasPreview) {
      AudioStreamService.dispose();
    }
  }
  initStream() {
    const preview = this.preview;
    if (!this.preview) {
      return;
    }
    // console.log(this.video_, this.audio_);
    const {
      node
    } = rxcomp.getContext(this);
    if (this.video_ || this.audio_) {
      node.classList.add('ready');
      if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
        const state = StateService.state;
        const quality = getStreamQuality(state);
        const options = {
          video: this.video_ ? {
            deviceId: this.video_,
            width: {
              ideal: quality.resolution.width
            },
            height: {
              ideal: quality.resolution.height
            },
            frameRate: {
              ideal: quality.frameRate.min,
              max: quality.frameRate.max
            }
          } : false,
          audio: this.audio_ ? {
            deviceId: this.audio_
          } : false
        };
        if (this.platform === DevicePlatform.IOS) {
          options.video.facingMode = 'user';
        }
        // console.log('AgoraDevicePreviewComponent.initStream.getUserMedia', options);
        navigator.mediaDevices.getUserMedia(options).then(stream => {
          if (this.hasPreview) {
            if ('srcObject' in preview) {
              preview.srcObject = stream;
            } else {
              preview.src = window.URL.createObjectURL(stream);
            }
            if (this.audio_) {
              this.analyzeData(stream);
            }
            this.loadingStream_ = stream;
          } else {
            this.stream.next(stream);
          }
        }).catch(error => {
          console.log('AgoraDevicePreviewComponent.initStream.error', error.name, error.message);
          this.stream.next(null);
        });
      }
    } else {
      node.classList.remove('ready');
      if (this.hasPreview) {
        if ('srcObject' in preview) {
          preview.srcObject = null;
        } else {
          preview.src = null;
        }
        this.analyzeData(null);
      }
      this.stream.next(null);
    }
  }
  onLoadedMetadata(event) {
    // console.log('AgoraDevicePreview.onLoadedMetadata', event);
    const {
      node
    } = rxcomp.getContext(this);
    node.classList.add('loaded');
    this.preview.play();
    this.stream.next(this.loadingStream_);
  }
  analyzeData(stream) {
    if (this.frequencySubscription) {
      this.frequencySubscription.unsubscribe();
    }
    // console.log('AgoraDevicePreviewComponent.analyzeData', stream);
    if (stream) {
      this.frequencySubscription = AudioStreamService.frequency$(stream, 64).pipe(operators.takeUntil(this.unsubscribe$)).subscribe(frequency => {
        // 32 data points
        // console.log(frequency);
        const spacing = 100 / 32;
        const bars = this.bars;
        bars.forEach((bar, i) => {
          const pow = Math.min(100, 5 + frequency[i]) / 100;
          bar.style.left = i * spacing + '%';
          bar.style.transform = `scale(1,${pow})`;
          bar.style.opacity = pow;
        });
      });
    }
  }
}
AgoraDevicePreviewComponent.meta = {
  selector: '[agora-device-preview]',
  outputs: ['stream', 'change'],
  inputs: ['video', 'audio']
};class AgoraDeviceComponent extends rxcomp.Component {
  get hasPreview() {
    return this.platform !== DevicePlatform.IOS && this.platform !== DevicePlatform.VRHeadset; // && this.form && this.form.value.video;
  }

  onInit() {
    this.platform = DeviceService.platform;
    this.isHttps = window.location.protocol === 'https:';
    this.state = {};
    this.devices = {
      videos: [],
      audios: []
    };
    this.stream = null;
    this.form = null;
    if (this.isHttps) {
      const agora = this.agora = AgoraService.getSingleton();
      StateService.state$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(state => {
        // console.log('AgoraDeviceComponent.state', state);
        this.state = state;
        this.pushChanges();
      });
      if (agora) {
        agora.devices$().subscribe(devices => {
          // console.log(devices);
          this.devices = devices;
          this.initForm(devices);
          this.pushChanges();
        }, error => {
          console.log('AgoraDeviceComponent.devices$.error', error);
          // alert('AgoraDeviceComponent ' + error); // !!!
        });
      }
    }
  }

  openHttps(event) {
    window.location.href = window.location.href.replace('http://', 'https://').replace(':5000', ':6443');
  }
  initForm(devices) {
    const form = this.form = new rxcompForm.FormGroup({
      video: new rxcompForm.FormControl(null, devices.videos.length ? rxcompForm.Validators.RequiredValidator() : undefined),
      audio: new rxcompForm.FormControl(null, devices.audios.length ? rxcompForm.Validators.RequiredValidator() : undefined)
    });
    const controls = this.controls = form.controls;
    const videoOptions = devices.videos.map(x => {
      return {
        id: x.deviceId,
        name: x.label
      };
    });
    if (videoOptions.length > 0) {
      videoOptions.unshift({
        id: null,
        name: 'bhere_select_video' // LabelPipe.transform('bhere_select_video')
      });
    }

    controls.video.options = videoOptions;
    const audioOptions = devices.audios.map(x => {
      return {
        id: x.deviceId,
        name: x.label
      };
    });
    if (audioOptions.length > 0) {
      audioOptions.unshift({
        id: null,
        name: 'bhere_select_audio' // LabelPipe.transform('bhere_select_audio')
      });
    }

    controls.audio.options = audioOptions;
    form.changes$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(changes => {
      // console.log('AgoraDeviceComponent.changes$', form.value);
      this.pushChanges();
    });
  }
  onStreamDidChange(event) {
    this.stream = null;
    this.pushChanges();
  }
  onStream(stream) {
    this.stream = stream;
    this.pushChanges();
  }
  isValid() {
    const isValid = this.form.valid && (this.stream || !this.hasPreview);
    return isValid;
  }
  onEnter(event) {
    const preferences = this.form.value;
    const devices = this.devices;
    devices.video = devices.videos.find(x => x.deviceId === preferences.video);
    devices.audio = devices.audios.find(x => x.deviceId === preferences.audio);
    this.enter.next(devices);
  }
}
AgoraDeviceComponent.meta = {
  selector: '[agora-device]',
  outputs: ['enter'],
  template: /* html */`
	<div class="group--info" *if="!isHttps">
		<div class="group--info__content stagger--childs">
			<div class="title" [innerHTML]="'bhere_invalid_protocol' | label"></div>
			<div class="info" [innerHTML]="'bhere_reload_in_https' | label"></div>
			<button type="button" class="btn--connect" (click)="openHttps($event)">
				<span [innerHTML]="'bhere_reload' | label"></span>
			</button>
		</div>
	</div>
	<div class="group--info" *if="form">
		<form class="form" [formGroup]="form" (submit)="isValid() && onEnter($event)" name="form" role="form" novalidate autocomplete="off">
			<!-- PREVIEW -->
			<div class="agora-device-preview" agora-device-preview [video]="controls.video.value" [audio]="controls.audio.value" (stream)="onStream($event)" (change)="onStreamDidChange($event)" *if="this.hasPreview">
				<video class="video" muted></video>
				<div class="audio"></div>
			</div>
			<div class="group--info__content stagger--childs">
				<!-- VIDEO -->
				<div control-custom-select [control]="controls.video" label="Video" *if="devices.videos.length"></div>
				<!-- AUDIO -->
				<div control-custom-select [control]="controls.audio" label="Audio" *if="devices.audios.length"></div>
				<div class="info" *if="!isValid()" [innerHTML]="'bhere_select_video_audio' | label"></div>
				<div class="info" *if="isValid()" [innerHTML]="'bhere_video_audio_connected' | label"></div>
				<button type="submit" class="btn--connect" [class]="{ disabled: !isValid() }">
					<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#call"></use></svg>
					<span *if="!state.connecting" [innerHTML]="'bhere_enter' | label"></span>
					<span *if="state.connecting" [innerHTML]="'bhere_connecting' | label"></span>
				</button>
			</div>
		</form>
	</div>
	`
};const ViewType = {
  WaitingRoom: {
    id: 1,
    name: 'waiting-room'
  },
  Panorama: {
    id: 2,
    name: 'panorama'
  },
  PanoramaGrid: {
    id: 3,
    name: 'panorama-grid'
  },
  Room3d: {
    id: 4,
    name: 'room-3d'
  },
  Model: {
    id: 5,
    name: 'model'
  },
  Media: {
    id: 6,
    name: 'media'
  }
};
const ViewItemType = {
  Nav: {
    id: 1,
    name: 'nav'
  },
  Plane: {
    id: 2,
    name: 'plane'
  },
  CurvedPlane: {
    id: 3,
    name: 'curved-plane'
  },
  Model: {
    id: 4,
    name: 'model'
  },
  Texture: {
    id: 5,
    name: 'texture'
  }
};
class View {
  // 'liked'

  constructor(options) {
    if (options) {
      Object.assign(this, options);
      this.updateIndices(options.items);
    }
    this.items = (this.items || []).filter(item => filterViewItem(item)).map(item => mapViewItem(item));
    if (this.tiles) {
      this.tiles = this.tiles.map(tile => mapViewTile(tile));
    }
    this.originalItems = this.items.slice();
    this.lastOrientation = {
      latitude: 0,
      longitude: 0
    };
    this.path = true;
  }
  get payload() {
    const payload = {};
    Object.keys(this).forEach(key => {
      if (View.allowedProps.indexOf(key) !== -1) {
        switch (key) {
          case 'items':
            payload[key] = this[key].map(item => mapViewItem(item).payload);
            break;
          case 'tiles':
            payload[key] = this[key].map(tile => mapViewTile(tile).payload);
            break;
          default:
            payload[key] = this[key];
        }
      }
    });
    return payload;
  }
  get pathItems() {
    return this.items.filter(x => x.path);
  }
  get shortType() {
    return this.type ? this.type.split('-').map(x => x.substring(0, 1).toUpperCase()).join('') : '??';
  }
  updateIndices(items) {
    if (items) {
      let publisherStreamIndex = 0;
      let attendeeStreamIndex = 0;
      let smartDeviceStream = 0;
      let publisherScreenIndex = 0;
      let attendeeScreenIndex = 0;
      items.forEach((item, index) => {
        item.index = index;
        if (item.asset) {
          switch (item.asset.file) {
            case 'publisherStream':
              item.asset.index = publisherStreamIndex++;
              break;
            case 'nextAttendeeStream':
              item.asset.index = attendeeStreamIndex++;
              break;
            case 'smartDeviceStream':
              item.asset.index = smartDeviceStream++;
              break;
            case 'publisherScreen':
              item.asset.index = publisherScreenIndex++;
              break;
            case 'attendeeScreen':
              item.asset.index = attendeeScreenIndex++;
              break;
          }
        }
        /*
        if (item.asset && item.asset.file === 'publisherStream') {
        	item.asset.index = publisherStreamIndex++;
        }
        if (item.asset && item.asset.file === 'nextAttendeeStream') {
        	item.asset.index = attendeeStreamIndex++;
        }
        */
      });
    }
  }
}
View.allowedProps = ['id', 'type', 'name', 'hidden', 'likes', 'asset', 'items', 'orientation', 'zoom', 'ar', 'tiles', 'invertAxes', 'flipAxes'];
class PanoramaView extends View {
  constructor(options) {
    super(options);
  }
}
class PanoramaGridView extends View {
  static mapTiles(tiles, flipAxes, invertAxes, folder) {
    if (tiles === void 0) {
      tiles = [];
    }
    if (flipAxes === void 0) {
      flipAxes = false;
    }
    if (invertAxes === void 0) {
      invertAxes = false;
    }
    if (folder === void 0) {
      folder = '';
    }
    const axes = flipAxes ? -1 : 1;
    return tiles.map((tile, i) => {
      const indices = new THREE.Vector2();
      tile = typeof tile === 'string' ? {
        id: i + 1,
        asset: {
          folder: folder,
          file: tile
        },
        navs: []
      } : tile;
      tile.asset.file.replace(/_x([-|\d]+)_y([-|\d]+)/g, (a, b, c) => {
        if (invertAxes) {
          indices.y = parseInt(b);
          indices.x = parseInt(c) * axes;
        } else {
          indices.x = parseInt(b);
          indices.y = parseInt(c) * axes;
        }
      });
      return {
        id: tile.id,
        type: Object.assign({}, ViewType.PanoramaGrid),
        asset: tile.asset,
        navs: tile.navs || [],
        indices
      };
    });
  }
  set index(index) {
    if (this.index_ !== index) {
      this.index_ = index;
      this.tiles.forEach((tile, i) => tile.selected = i === index);
      this.updateCurrentItems();
      // console.log('PanoramaGridView.index.set', index, this.items);
      this.index$.next(index);
    }
  }
  get index() {
    return this.index_;
  }
  constructor(options) {
    options.tiles = PanoramaGridView.mapTiles(options.tiles, options.flipAxes, options.invertAxes, options.asset ? options.asset.folder : '');
    super(options);
    /*
    if (!this.tiles.length) {
    	throw new Error('PanoramaGridView.constructor tile list is empty!');
    }
    */
    this.index_ = 0;
    this.index$ = new rxjs.Subject();
    this.tiles.forEach((tile, i) => tile.selected = i === 0);
    if (this.tiles.length) {
      this.items = this.originalItems.concat(this.tiles[0].navs);
      this.asset = this.tiles[0].asset;
    }
  }
  updateCurrentItems() {
    this.items = this.originalItems.concat(this.tiles[this.index_].navs);
  }
  getTileIndex(x, y) {
    return this.tiles.reduce((p, c, i) => {
      if (c.indices.x === x && c.indices.y === y) {
        return i;
      } else {
        return p;
      }
    }, -1);
  }
  hasTile(x, y) {
    return this.getTileIndex(x, y) !== -1;
  }
  getTile(x, y) {
    const index = this.getTileIndex(x, y);
    if (index !== -1) {
      this.index = index;
      return this.tiles[index];
    }
  }
}
class Room3DView extends View {
  constructor(options) {
    super(options);
  }
}
class ModelView extends View {
  constructor(options) {
    super(options);
  }
}
class MediaView extends View {
  constructor(options) {
    super(options);
  }
}
class ViewItem {
  constructor(options) {
    if (options) {
      Object.assign(this, options);
    }
    this.path = true;
    const links = this.links || (this.link ? [this.link] : []);
    this.links = links;
  }
  get firstLink() {
    return this.links && this.links.length ? this.links[0] : null;
  }
  get payload() {
    const payload = {};
    Object.keys(this).forEach(key => {
      if (ViewItem.allowedProps.indexOf(key) !== -1) {
        payload[key] = this[key];
      }
    });
    if (payload.link && (!payload.link.title || !payload.link.href)) {
      delete payload.link;
    }
    return payload;
  }
  get hasPanel() {
    return this.type.name === ViewItemType.Nav.name && (this.title && this.title !== '' || this.abstract && this.abstract !== '' || this.asset || this.link);
  }
}
ViewItem.allowedProps = ['id', 'type', 'title', 'abstract', 'asset', 'link', 'links', 'viewId', 'hook', 'hookExtra', 'keepOrientation', 'important', 'transparent', 'position', 'rotation', 'scale', 'radius', 'height', 'arc'];
class NavViewItem extends ViewItem {}
class ViewTile {
  constructor(options) {
    if (options) {
      Object.assign(this, options);
    }
    this.navs = (this.navs || []).map(nav => mapViewItem(nav));
    this.originalItems = this.navs.slice();
  }
  get payload() {
    const payload = {};
    Object.keys(this).forEach(key => {
      if (ViewTile.allowedProps.indexOf(key) !== -1) {
        switch (key) {
          case 'navs':
            payload[key] = this[key].map(nav => mapViewItem(nav).payload);
            break;
          default:
            payload[key] = this[key];
        }
      }
    });
    return payload;
  }
}
ViewTile.allowedProps = ['id', 'asset', 'navs'];
function mapView(view) {
  switch (view.type.name) {
    case ViewType.Panorama.name:
      view = new PanoramaView(view);
      break;
    case ViewType.PanoramaGrid.name:
      view = new PanoramaGridView(view);
      break;
    case ViewType.Room3d.name:
      view = new Room3DView(view);
      break;
    case ViewType.Model.name:
      view = new ModelView(view);
      break;
    case ViewType.Media.name:
      view = new MediaView(view);
      break;
    default:
      view = new View(view);
  }
  return view;
}
function filterViewItem(item) {
  let flag;
  switch (item.type.name) {
    case ViewItemType.Nav.name:
      flag = item.viewId == null || isNavMove(item) || StateService.state.navigable;
      break;
    default:
      flag = true;
  }
  return flag;
}
function mapViewItem(item) {
  switch (item.type.name) {
    case ViewItemType.Nav.name:
      item = new NavViewItem(item);
      break;
    default:
      item = new ViewItem(item);
  }
  return item;
}
function mapViewTile(tile) {
  return new ViewTile(tile);
}
function isNavMove(item) {
  return !isValidText(item.title) && !isValidText(item.abstract);
}
function isValidText(text) {
  return text && text.length > 0;
}class Path {
  constructor(options) {
    if (options) {
      Object.assign(this, options);
    }
    this.items = this.items || [];
    this.originalItems = this.items.slice();
  }
  get payload() {
    const payload = {};
    Object.keys(this).forEach(key => {
      if (View.allowedProps.indexOf(key) !== -1) {
        switch (key) {
          default:
            payload[key] = this[key];
        }
      }
    });
    return payload;
  }
}
Path.allowedProps = ['id', 'name', 'items'];
function mapPath(map) {
  map = new Path(map);
  return map;
}const DEFAULT_PATH = {
  id: null,
  name: 'Principale',
  items: []
};
class PathService {
  static set paths(paths) {
    this.paths$.next(paths);
  }
  static get paths() {
    return this.paths$.getValue();
  }
  static set path(path) {
    this.path$.next(path);
  }
  static get path() {
    return this.path$.getValue();
  }
  static getCurrentPath$(pathId) {
    if (pathId === void 0) {
      pathId = null;
    }
    return this.pathGet$().pipe(operators.switchMap(paths => {
      this.paths = paths;
      let path = DEFAULT_PATH;
      if (pathId) {
        const selectedPath = paths.find(x => x.id === pathId);
        if (selectedPath) {
          path = selectedPath;
        }
      }
      this.path = path;
      return this.path$;
    }));
  }
  static pathGet$() {
    if (environment.flags.usePaths) {
      return HttpService.get$('/api/path').pipe(operators.map(data => {
        data.paths = data.paths.map(path => mapPath(path));
        data.paths.unshift(DEFAULT_PATH);
        return data.paths;
      }));
    } else {
      return rxjs.of([]);
    }
  }
  static addPath(path) {
    const paths = this.paths.slice();
    paths.push(path);
    this.paths = paths;
    this.path = path;
  }
  static editPath(path) {
    // console.log('PathService.editPath', path);
    const paths = this.paths.slice();
    const index = paths.reduce((p, c, i) => {
      return c.id === path.id ? i : p;
    }, -1);
    // console.log('PathService.editPath', paths, index);
    if (index > 0) {
      let currentPath = this.path;
      if (currentPath.id === path.id) {
        currentPath = path;
      }
      // console.log('PathService.editPath', currentPath);
      paths.splice(index, 1, path);
      this.paths = paths;
      this.path = currentPath;
    }
  }
  static deletePath(path) {
    const paths = this.paths.slice();
    const index = paths.indexOf(path);
    if (index > 0) {
      paths.splice(index, 1);
      this.paths = paths;
      let currentPath = this.path;
      if (currentPath.id === path.id) {
        currentPath = paths[0];
      }
      this.path = currentPath;
    }
  }
  static pathCreate$(path) {
    return HttpService.post$('/api/path', path).pipe(operators.map(path => mapPath(path)));
  }
  static pathUpdate$(path) {
    return HttpService.put$(`/api/path/${path.id}`, path).pipe(operators.map(x => mapPath(x)));
  }
  static pathDelete$(path) {
    return HttpService.delete$(`/api/path/${path.id}`);
  }

  /*
  static itemCreate$(path, item) {
  	return HttpService.post$(`/api/path/${path.id}/item`, item).pipe(
  		map(item => mapViewItem(item)),
  	);
  }
  
  static itemUpdate$(path, item) {
  	item = mapViewItem(item); // !!! ??
  	return HttpService.put$(`/api/path/${path.id}/item/${item.id}`, item.payload).pipe(
  		map(item => mapViewItem(item)),
  	);
  }
  
  static itemDelete$(path, item) {
  	return HttpService.delete$(`/api/path/${path.id}/item/${item.id}`);
  }
  */
}
PathService.paths$ = new rxjs.BehaviorSubject([DEFAULT_PATH]);
PathService.path$ = new rxjs.BehaviorSubject(DEFAULT_PATH);class AgoraLinkComponent extends rxcomp.Component {
  get selfServiceTourRoute() {
    const pathId = this.form.get('path').value;
    const route = [RoutePipe.transform(':lang.selfServiceTour')];
    if (pathId) {
      route.push(MeetingUrl.validateParams({
        pathId
      }));
    }
    return route;
  }
  onInit() {
    this.state = {};
    this.paths = [];
    this.pathId = null;
    this.form = null;
    StateService.state$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(state => {
      // console.log('AgoraLinkComponent.state', state);
      this.state = state;
      this.pushChanges();
    });
    if (environment.flags.usePaths) {
      PathService.getCurrentPath$().pipe(operators.first(), operators.tap(), operators.takeUntil(this.unsubscribe$)).subscribe(path => {
        this.paths = PathService.paths;
        this.pathId = path.id || '';
        this.onLoad();
      });
    } else {
      this.onLoad();
    }
  }
  onLoad() {
    const form = this.form = new rxcompForm.FormGroup({
      path: this.pathId,
      id: new rxcompForm.FormControl(null, [rxcompForm.Validators.PatternValidator(MEETING_ID_VALIDATOR), rxcompForm.Validators.RequiredValidator()]),
      idAttendee: null,
      idStreamer: null,
      idViewer: null,
      idSmartDevice: null
      // id: new FormControl(null),
    });

    const controls = this.controls = form.controls;
    const pathOptions = this.paths.map(x => {
      return {
        id: x.id || '',
        name: x.name
      };
    });
    if (pathOptions.length > 0) {
      pathOptions.unshift({
        id: null,
        name: 'bhere_select_path' // LabelPipe.transform('bhere_select_path')
      });
    }

    controls.path.options = pathOptions;
    form.changes$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(changes => {
      // console.log('AgoraLinkComponent.changes$', form.value);
      // console.log(changes.path, changes.id);
      if (this.pathId !== changes.path && changes.id !== null) {
        this.pathId = changes.path;
        this.onGenerateMeetingId();
      }
      this.pushChanges();
    });
  }
  onGenerateMeetingId($event) {
    let pathId = this.pathId ? String(this.pathId) : null;
    pathId = pathId && pathId.length ? pathId : null;
    // console.log('onGenerateMeetingId', this.pathId, pathId);
    const meetingId = new MeetingId({
      pathId
    });
    const meetingIdRoles = meetingId.toRoles();
    this.form.patch(meetingIdRoles);
  }
  onInputDidChange($event) {
    // console.log('onInputDidChange', this.form.get('id').value, this.form.get('id').valid);
    if (this.state.role !== 'publisher') {
      return;
    }
    setTimeout(() => {
      if (this.form.get('id').valid) {
        const value = this.form.get('id').value;
        const meetingId = new MeetingId(value);
        const meetingIdRoles = meetingId.toRoles();
        this.form.patch(meetingIdRoles);
      } else {
        this.form.get('idAttendee').reset();
        this.form.get('idStreamer').reset();
        this.form.get('idViewer').reset();
        this.form.get('idSmartDevice').reset();
      }
    }, 1);
  }
  onCopyToClipBoard(id, asAccessCode) {
    if (asAccessCode === void 0) {
      asAccessCode = false;
    }
    const meetingUrl = new MeetingUrl({
      link: id
    });
    meetingUrl.copyToClipBoard(asAccessCode);
  }
  onNext(event) {
    let meetingId = this.controls.id.value;
    MeetingUrl.replaceWithLink(meetingId);
    this.link.next(meetingId);
  }
  isValid() {
    const isValid = this.form.valid;
    return isValid;
  }
}
AgoraLinkComponent.meta = {
  selector: '[agora-link]',
  outputs: ['link'],
  template: /* html */`
	<div class="group--info" *if="form">
		<form class="form" [formGroup]="form" (submit)="isValid() && onNext($event)" name="form" role="form" novalidate autocomplete="off">
			<div class="group--info__content stagger--childs">
				<div class="stagger--childs" *if="state.role !== 'publisher'">
					<div class="group--form group--form--addon" [class]="{ required: controls.id.validators.length, 'addon': controls.id.valid }">
						<label [innerHTML]="'bhere_insert_meeting_id' | label"></label>
						<input type="text" class="control--text" [formControl]="controls.id" [placeholder]="'bhere_meeting_id' | label" />
						<div class="control--addon" (click)="onCopyToClipBoard(controls.id.value)" *if="controls.id.valid">
							<svg class="copy" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#copy"></use></svg>
						</div>
					</div>
				</div>
				<div class="stagger--childs" *if="state.role === 'publisher'">
					<!-- PATH -->
					<div control-custom-select [control]="controls.path" [label]="'bhere_path' | label" *if="('usePaths' | flag) && paths.length"></div>
					<!--IDS -->
					<div class="group--form group--form--addon" [class]="{ required: controls.id.validators.length, 'addon': controls.id.valid }">
						<label><svg class="lock" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#lock"></use></svg> <span [innerHTML]="'bhere_insert_meeting_id' | label"></span></label>
						<input type="text" class="control--text" [formControl]="controls.id" [placeholder]="'bhere_meeting_id' | label" (change)="onInputDidChange($event)" />
						<div class="control--addon" (click)="onCopyToClipBoard(controls.id.value)" *if="controls.id.valid">
							<svg class="copy" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#copy"></use></svg>
						</div>
					</div>
					<div class="group--form group--form--addon addon" *if="('attendee' | flag) && controls.idAttendee.valid && controls.idAttendee.value !== null">
						<label><svg class="lock" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#lock"></use></svg> <span [innerHTML]="'bhere_attendee_meeting_id' | label"></span></label>
						<input type="text" class="control--text" [formControl]="controls.idAttendee" [placeholder]="'bhere_attendee_meeting_id' | label" readonly />
						<div class="control--addon" (click)="onCopyToClipBoard(controls.idAttendee.value)" *if="controls.idAttendee.valid">
							<svg class="copy" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#copy"></use></svg>
						</div>
					</div>
					<div class="group--form group--form--addon addon" *if="('streamer' | flag) && controls.idStreamer.valid && controls.idStreamer.value !== null">
						<label [innerHTML]="'bhere_streamer_meeting_id' | label"></label>
						<input type="text" class="control--text" [formControl]="controls.idStreamer" [placeholder]="'bhere_streamer_meeting_id' | label" readonly />
						<div class="control--addon" (click)="onCopyToClipBoard(controls.idStreamer.value)" *if="controls.idStreamer.valid">
							<svg class="copy" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#copy"></use></svg>
						</div>
					</div>
					<div class="group--form group--form--addon addon" *if="('viewer' | flag) && controls.idViewer.valid && controls.idViewer.value !== null">
						<label [innerHTML]="'bhere_viewer_meeting_id' | label"></label>
						<input type="text" class="control--text" [formControl]="controls.idViewer" [placeholder]="'bhere_viewer_meeting_id' | label" readonly />
						<div class="control--addon" (click)="onCopyToClipBoard(controls.idViewer.value)" *if="controls.idViewer.valid">
							<svg class="copy" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#copy"></use></svg>
						</div>
					</div>
					<div class="group--form group--form--addon addon" *if="('smartDevice' | flag) && controls.idSmartDevice.valid && controls.idSmartDevice.value !== null">
						<label [innerHTML]="'bhere_smart_device_meeting_id' | label"></label>
						<input type="text" class="control--text" [formControl]="controls.idSmartDevice" [placeholder]="'bhere_smart_device_meeting_id' | label" readonly />
						<div class="control--addon" (click)="onCopyToClipBoard(controls.idSmartDevice.value, true)" *if="controls.idSmartDevice.valid">
							<svg class="copy" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#copy"></use></svg>
						</div>
					</div>
				</div>
				<div class="info" *if="controls.id.errors.required" [innerHTML]="'bhere_insert_meeting_id' | label"></div>
				<div class="info" *if="controls.id.errors.pattern" [innerHTML]="'bhere_invalid_meeting_id' | label"></div>
				<div class="info" *if="isValid()" [innerHTML]="'bhere_take_part_meeting' | label"></div>
				<button type="button" class="btn--generate" *if="state.role == 'publisher'" (click)="onGenerateMeetingId($event)">
					<span [innerHTML]="'bhere_generate_meeting_id' | label"></span>
				</button>
				<button type="submit" class="btn--next" [class]="{ disabled: !isValid() }">
					<span [innerHTML]="'bhere_take_part' | label"></span>
				</button>
				<a [routerLink]="selfServiceTourRoute" class="btn--secondary" *if="state.role === 'publisher'">
					<span [innerHTML]="'bhere_self_service' | label"></span>
				</a>
			</div>
		</form>
	</div>
	`
};class AgoraLoginComponent extends rxcomp.Component {
  onInit() {
    const form = this.form = new rxcompForm.FormGroup({
      username: new rxcompForm.FormControl(null, rxcompForm.Validators.RequiredValidator()),
      password: new rxcompForm.FormControl(null, rxcompForm.Validators.RequiredValidator()),
      checkRequest: window.antiforgery || '',
      checkField: ''
    });
    this.controls = form.controls;
    form.changes$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(changes => {
      this.pushChanges();
    });
    this.error = null;
  }
  test() {
    this.form.patch({
      username: 'publisher',
      password: 'publisher',
      checkRequest: window.antiforgery || '',
      checkField: ''
    });
  }
  reset() {
    this.form.reset();
  }
  onSubmit() {
    if (this.form.valid) {
      const payload = this.form.value;
      this.form.submitted = true;
      this.error = null;
      this.pushChanges();
      UserService.login$(payload).pipe(operators.first()).subscribe(user => {
        if (StateService.state.role === user.type) {
          // this.login.next(user);
          this.onNext(user);
          this.form.reset();
        } else {
          this.error = {
            friendlyMessage: LabelPipe.transform('error_credentials')
          };
          this.pushChanges();
        }
      }, error => {
        console.log('AccessComponent.error', error);
        this.error = error;
        this.pushChanges();
      });
    } else {
      this.form.touched = true;
    }
  }
  isValid() {
    const isValid = this.form.valid;
    return isValid;
  }
  onNext(user) {
    MeetingUrl.replaceWithUser(user);
    this.login.next(user);
  }
}
AgoraLoginComponent.meta = {
  selector: '[agora-login]',
  outputs: ['login'],
  template: /* html */`
	<div class="group--info">
		<form class="form" [formGroup]="form" (submit)="isValid() && onSubmit()" name="form" role="form" novalidate autocomplete="off">
			<div class="group--info__content stagger--childs">
				<div class="title" [innerHTML]="'bhere_login' | label"></div>
				<input name="checkField" [formControl]="controls.checkField" value="" type="text" style="display:none !important;" />
				<div control-text [control]="controls.username" [label]="'bhere_username' | label"></div>
				<div control-password [control]="controls.password" [label]="'bhere_password' | label"></div>
				<div class="group--error" *if="error">
					<span class="status-code" [innerHTML]="error.statusCode"></span>
					<span class="status-message" [innerHTML]="error.statusMessage"></span>
					<span class="friendly-message" [innerHTML]="error.friendlyMessage"></span>
				</div>
				<div class="info" *if="isValid()" [innerHTML]="'bhere_cta' | label"></div>
				<button type="submit" class="btn--next" [class]="{ disabled: !isValid() }">
					<span [innerHTML]="'bhere_cta' | label"></span>
				</button>
				<test-component [form]="form" (test)="test($event)" (reset)="reset($event)"></test-component>
			</div>
		</form>
	</div>
	`
};class AgoraNameComponent extends rxcomp.Component {
  onInit() {
    const meetingUrl = new MeetingUrl();
    this.state = {};
    const fields = this.fields = [];
    if (environment.flags.useExtendedUserInfo) {
      const firstName = meetingUrl.firstName;
      const lastName = meetingUrl.lastName;
      const email = meetingUrl.email;
      fields.push({
        type: 'text',
        name: 'firstName',
        label: 'access_first_name',
        required: true,
        value: firstName,
        test: 'Jhon'
      }, {
        type: 'text',
        name: 'lastName',
        label: 'access_last_name',
        required: true,
        value: lastName,
        test: 'Appleseed'
      }, {
        type: 'email',
        name: 'email',
        label: 'access_email',
        required: true,
        value: email,
        test: 'jhonappleseed@gmail.com'
      });
    } else {
      const name = meetingUrl.name;
      fields.push({
        type: 'text',
        name: 'name',
        label: 'bhere_name_and_surname',
        pattern: /^\w{2,}\s\w{2,}/,
        required: true,
        value: name,
        test: 'Jhon Appleseed'
      });
    }
    fields.push({
      type: 'checkbox',
      name: 'privacy',
      label: 'access_privacy_disclaimer',
      required: true,
      test: true
    }, {
      type: 'hidden',
      name: 'checkField',
      value: '',
      test: ''
    }, {
      type: 'none',
      name: 'checkRequest',
      value: environment.antiforgery || '',
      test: environment.antiforgery || ''
    });
    const form = this.form = fieldsToFormGroup(fields);

    /*
    const form = this.form = new FormGroup({
    	name: new FormControl(name, [Validators.PatternValidator(/^\w{2,}\s\w{2,}/), Validators.RequiredValidator()]),
    });
    */

    this.controls = form.controls;
    form.changes$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(changes => {
      // console.log('AgoraNameComponent.changes$', form.value);
      this.pushChanges();
    });
    StateService.state$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(state => {
      // console.log('AgoraNameComponent.state', state);
      this.state = state;
      this.pushChanges();
    });
  }
  test() {
    patchFields(this.fields, this.form);
  }
  isValid() {
    const isValid = this.form.valid;
    return isValid;
  }
  onNext(event) {
    let name;
    let options;
    if (environment.flags.useExtendedUserInfo) {
      options = {
        firstName: this.controls.firstName.value,
        lastName: this.controls.lastName.value,
        email: this.controls.email.value
      };
      name = `${options.firstName} ${options.lastName}`;
    } else {
      options = {
        name: this.controls.name.value
      };
      name = options.name;
    }
    MeetingUrl.replaceWithOptions(options);
    this.name.next(name);
  }
}
AgoraNameComponent.meta = {
  selector: '[agora-name]',
  outputs: ['name'],
  template: /* html */`
	<div class="group--info" *if="form">
		<form class="form" [formGroup]="form" (submit)="isValid() && onNext($event)" name="form" role="form" novalidate autocomplete="off">
			<div class="group--info__content stagger--childs">
				<!-- controls -->
				<div controls [formGroup]="form" [fields]="fields"></div>
				<!-- NAME -->
				<!--
				<div class="group--form group--form--addon" [class]="{ required: controls.name.validators.length }">
					<label [innerHTML]="'bhere_fill_fullname' | label"></label>
					<input type="text" class="control--text" [formControl]="controls.name" [placeholder]="'bhere_name_and_surname' | label" />
				</div>
				<div class="info" *if="!controls.name.valid" [innerHTML]="'bhere_fill_name_and_surname' | label"></div>
				-->
				<div class="info" *if="!isValid()"><span [innerHTML]="'bhere_fill_name_and_surname' | label"></span></div>
				<div class="info" *if="isValid()"><span [innerHTML]="'bhere_proceed_as' | label"></span> <span [innerHTML]="controls.name.value"></span></div>
				<button type="submit" class="btn--next" [class]="{ disabled: !isValid() }">
					<span [innerHTML]="'bhere_proceed' | label"></span>
				</button>
				<test-component [form]="form" (test)="test($event)" (reset)="reset($event)"></test-component>
			</div>
		</form>
	</div>
	`
};class AgoraStreamComponent extends rxcomp.Component {
  set videoMuted(videoMuted) {
    if (this.videoMuted_ !== videoMuted) {
      this.videoMuted_ = videoMuted;
      const {
        node
      } = rxcomp.getContext(this);
      videoMuted ? node.classList.add('video--muted') : node.classList.remove('video--muted');
    }
  }
  set audioMuted(audioMuted) {
    if (this.audioMuted_ !== audioMuted) {
      this.audioMuted_ = audioMuted;
      const {
        node
      } = rxcomp.getContext(this);
      audioMuted ? node.classList.add('audio--muted') : node.classList.remove('audio--muted');
    }
  }
  get streamId() {
    return this.streamId_;
  }
  set streamId(streamId) {
    this.streamId_ = streamId;
  }

  /** @type {Stream} */
  get stream() {
    return this.stream_;
  }

  /**
   * @param stream {Stream}
   * */
  set stream(stream) {
    try {
      if (this.stream_ !== stream) {
        console.log('AgoraStreamComponent set stream', stream);
        const {
          node
        } = rxcomp.getContext(this);
        const player = this.player = node.querySelector('.agora-stream__player');
        /*
        while (player.childElementCount > 0) {
        	player.removeChild(player.firstElementChild);
        }
        if (this.stream_ && this.stream_.isPlaying() && this.stream_.player.div.parentNode === player) {
        	Logger.log('AgoraStreamComponent', 'stopping stream', this.stream_.streamId);
        	this.stream_.stop();
        }
        */
        this.stream_ = stream;
        if (stream) {
          this.videoMuted = stream.userMuteVideo;
          this.audioMuted = stream.userMuteAudio;
        }
        const streamId = stream ? stream.streamId : null;
        this.streamId = streamId;
        if (streamId) {
          const playerId = `stream-${streamId}`;
          player.setAttribute('id', playerId);
          const self = this;
          // Logger.log('AgoraStreamComponent', streamId);
          if (stream.isPlaying()) {
            stream.resume(player);
          } else {
            this.shouldUseResumeGesture = false;
            try {
              stream.play(player);
            } catch (error) {
              Logger.error('Stream.videoTrack.play.error', error);
              if (error && error.status !== 'aborted') {
                // The playback fails, probably due to browser policy. You can resume the playback by user gesture.
                self.shouldUseResumeGesture = true;
                self.pushChanges();
              }
            }
          }
        } else {
          player.removeAttribute('id');
        }
      }
    } catch (error) {
      Logger.error('AgoraStreamComponent.stream.set.error', error);
    }
  }
  set vrContainer(vrContainer) {
    if (this.vrContainer_ !== vrContainer) {
      this.vrContainer_ = vrContainer;
      if (vrContainer) {
        this.stream_.vrContainer = vrContainer;
        this.player.appendChild(vrContainer);
      } else if (this.stream_.vrContainer && this.stream_.vrContainer.parentNode) {
        this.stream_.vrContainer.parentNode.removeChild(this.stream_.vrContainer);
        this.stream_.vrContainer = null;
      }
    }
  }
  get videoNode() {
    let videoNode = this.videoNode_;
    if (!videoNode) {
      const player = rxcomp.getContext(this).node.querySelector('.agora-stream__player');
      videoNode = document.createElement('video');
      this.onLoadedMetadata = this.onLoadedMetadata.bind(this);
      videoNode.addEventListener('loadedmetadata', this.onLoadedMetadata);
      player.appendChild(videoNode);
      this.videoNode_ = videoNode;
    }
    return videoNode;
  }
  onInit() {
    this.videoMuted = false;
    this.audioMuted = false;
    this.shouldUseResumeGesture = false;
    this.state = {};
    StateService.state$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(state => {
      this.state = state;
      this.pushChanges();
      // console.log('AgoraStreamComponent.StateService.state$', this.streamId, state);
    });

    MessageService.out$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(message => {
      // console.log('AgoraStreamComponent.MessageService.out$', this.streamId, message);
      switch (message.type) {
        case MessageType.AgoraEvent:
          {
            const event = message.event;
            // console.log('AgoraStreamComponent.AgoraEvent', message.event);
            if (this.streamId && event.streamId === this.streamId) {
              if (event instanceof AgoraMuteVideoEvent) {
                this.videoMuted = true;
              }
              if (event instanceof AgoraUnmuteVideoEvent) {
                this.videoMuted = false;
              }
              if (event instanceof AgoraMuteAudioEvent) {
                this.audioMuted = true;
              }
              if (event instanceof AgoraUnmuteAudioEvent) {
                this.audioMuted = false;
              }
            }
            break;
          }
        case MessageType.VRStarted:
          // console.log('AgoraStreamComponent.VRStarted', this.streamId, message.clientId, message.container);
          if (this.streamId === message.clientId) {
            this.vrContainer = message.container;
          }
          break;
        case MessageType.VREnded:
          // console.log('AgoraStreamComponent.VREnded', this.streamId, message.clientId);
          if (this.streamId === message.clientId) {
            this.vrContainer = null;
          }
          break;
      }
    });
  }
  setMediaStream(mediaStream) {
    const videoNode = this.videoNode;
    if ('srcObject' in videoNode) {
      videoNode.srcObject = mediaStream;
    } else {
      videoNode.src = mediaStream ? window.URL.createObjectURL(mediaStream) : null;
    }
  }
  onLoadedMetadata(event) {
    // console.log('AgoraStreamComponent.onLoadedMetadata', event);
    this.videoNode.play().then(success => {
      // console.log('AgoraStreamComponent.play.success', success);
    }, error => {
      console.log('AgoraStreamComponent.play.error', error);
    });
  }
  onToggleControl($event) {
    this.toggleControl.next($event);
  }
  onToggleSpy($event) {
    this.toggleSpy.next($event);
  }
}
AgoraStreamComponent.meta = {
  selector: '[agora-stream]',
  outputs: ['toggleControl', 'toggleSpy'],
  inputs: ['stream']
};class Navmap {
  constructor(options) {
    if (options) {
      Object.assign(this, options);
    }
    this.items = (this.items || []).map(item => mapViewItem(item));
    this.originalItems = this.items.slice();
  }
  get payload() {
    const payload = {};
    Object.keys(this).forEach(key => {
      if (View.allowedProps.indexOf(key) !== -1) {
        switch (key) {
          case 'items':
            payload[key] = this[key].map(item => mapViewItem(item).payload);
            break;
          default:
            payload[key] = this[key];
        }
      }
    });
    return payload;
  }
}
Navmap.allowedProps = ['id', 'name', 'asset', 'items'];
function mapNavmap(map) {
  map = new Navmap(map);
  return map;
}class NavmapService {
  static set active(active) {
    this.active$.next(active);
  }
  static get active() {
    return this.active$.getValue();
  }
  static navmapGet$() {
    return HttpService.get$('/api/navmap').pipe(operators.map(data => {
      data.navmaps.map(navmap => mapNavmap(navmap));
      return data.navmaps;
    }));
  }
  static navmapCreate$(navmap) {
    return HttpService.post$('/api/navmap', navmap).pipe(operators.map(navmap => mapNavmap(navmap)));
  }
  static navmapUpdate$(navmap) {
    return HttpService.put$(`/api/navmap/${navmap.id}`, navmap).pipe(operators.map(x => mapNavmap(x)));
  }
  static navmapDelete$(navmap) {
    return HttpService.delete$(`/api/navmap/${navmap.id}`);
  }
  static itemCreate$(navmap, item) {
    return HttpService.post$(`/api/navmap/${navmap.id}/item`, item).pipe(operators.map(item => mapViewItem(item)));
  }
  static itemUpdate$(navmap, item) {
    item = mapViewItem(item); // !!! ??
    return HttpService.put$(`/api/navmap/${navmap.id}/item/${item.id}`, item.payload).pipe(operators.map(item => mapViewItem(item)));
  }
  static itemDelete$(navmap, item) {
    return HttpService.delete$(`/api/navmap/${navmap.id}/item/${item.id}`);
  }
}
NavmapService.active$ = new rxjs.BehaviorSubject(false);function push_(event) {
  const dataLayer = window.dataLayer || [];
  dataLayer.push(event);
  console.log('GtmService.dataLayer', event);
}
class GtmService {
  static push(event) {
    return push_(event);
  }
}const ToastType = {
  Info: 'info',
  Alert: 'alert',
  Dialog: 'dialog'
};
const ToastPosition = {
  Centered: 'centered',
  TopLeft: 'top-left',
  Top: 'top',
  TopRight: 'top-right',
  Right: 'right',
  BottomRight: 'bottom-right',
  Bottom: 'bottom',
  BottomLeft: 'bottom-left',
  Left: 'left'
};
class ToastEvent {
  constructor(toast) {
    this.toast = toast;
  }
}
class ToastResolveEvent extends ToastEvent {}
class ToastRejectEvent extends ToastEvent {}
class ToastService {
  static open$(toast) {
    toast.id = new Date().getTime();
    toast.type = toast.type || ToastType.Info;
    toast.position = toast.position || ToastPosition.Centered;
    switch (toast.type) {
      case ToastType.Alert:
        toast.acceptMessage = toast.acceptMessage || 'Ok';
        break;
      case ToastType.Dialog:
        toast.acceptMessage = toast.acceptMessage || 'Accept';
        toast.rejectMessage = toast.rejectMessage || 'Reject';
        break;
    }
    this.toast$.next(toast);
    if (toast.type === ToastType.Info) {
      setTimeout(() => {
        this.resolve(toast);
      }, toast.duration || 4000);
    }
    return this.events$;
    /*
    return of(toast).pipe(
    	tap(toast => this.toast$.next(toast)),
    	switchMap(toast => this.events$),
    );
    */
  }

  static resolve(toast) {
    this.toast$.next(null);
    this.events$.next(new ToastResolveEvent(toast));
  }
  static reject(toast) {
    this.toast$.next(null);
    this.events$.next(new ToastRejectEvent(toast));
  }
}
ToastService.toast$ = new rxjs.Subject();
ToastService.events$ = new rxjs.Subject();class ModalOutletComponent extends rxcomp.Component {
  get modal() {
    return this.modal_;
  }
  set modal(modal) {
    // console.log('ModalOutletComponent set modal', modal, this);
    const {
      module
    } = rxcomp.getContext(this);
    if (this.modal_ && this.modal_.node) {
      module.remove(this.modal_.node, this);
      this.modalNode.removeChild(this.modal_.node);
    }
    if (modal && modal.node) {
      this.modal_ = modal;
      this.modalNode.appendChild(modal.node);
      module.compile(modal.node);
    }
    this.modal_ = modal;
    this.pushChanges();
  }
  get busy() {
    return this.busy_;
  }
  set busy(busy) {
    // console.log('ModalOutletComponent set busy', busy, this);
    if (this.busy_ !== busy) {
      this.busy_ = busy;
      this.pushChanges();
    }
  }
  onInit() {
    this.busy_ = false;
    const {
      node
    } = rxcomp.getContext(this);
    this.modalNode = node.querySelector('.modal-outlet__modal');
    ModalService.modal$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(modal => this.modal = modal);
    ModalService.busy$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(busy => this.busy = busy);
  }
  reject(event) {
    ModalService.reject();
  }
}
ModalOutletComponent.meta = {
  selector: '[modal-outlet]',
  template: /* html */`
	<div class="modal-outlet__container" [class]="{ active: modal, busy: busy }">
		<div class="modal-outlet__background" (click)="reject($event)"></div>
		<div class="modal-outlet__modal"></div>
		<!-- spinner -->
		<div class="spinner spinner--contrasted" *if="busy"></div>
	</div>
	`
};class TryInARModalComponent extends rxcomp.Component {
  onInit() {
    super.onInit();
    const {
      parentInstance,
      node
    } = rxcomp.getContext(this);
    if (parentInstance instanceof ModalOutletComponent) {
      const data = this.data = parentInstance.modal.data;
      // console.log('data', data);
      if (data && data.ar) {
        const url = TryInARModalComponent.getUrl(data);
        new QRious({
          element: node.querySelector('.qrcode'),
          value: url,
          size: 256
        });
      }
    }
  }
  onClose() {
    ModalService.reject();
  }
  static getUrl(data) {
    const path = RouterService.buildUrl(RoutePipe.transform(':lang.tryInAr'), {
      viewId: data.id
    });
    const url = window.location.origin + path;
    console.log('TryInARModalComponent.getUrl', url);
    return url;
  }
  static openInAR(data) {
    const url = this.getUrl(data);
    window.open(url, '_blank');
  }
}
TryInARModalComponent.meta = {
  selector: '[try-in-ar-modal]',
  template: /* html */`
		<div class="modal__header">
			<button type="button" class="btn--close" (click)="onClose()">
				<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#close"></use></svg>
			</button>
		</div>
		<div class="container">
			<div class="form">
				<div class="title" [innerHTML]="'bhere_ar' | label"></div>
				<div class="picture">
					<canvas class="qrcode"></canvas>
				</div>
				<div class="group--cta">
					<button type="button" class="btn--accept" (click)="onClose()">
						<span [innerHTML]="'close' | label"></span>
					</button>
				</div>
			</div>
		</div>
	`
};
TryInARModalComponent.chunk = () => /* html */'<div class="try-in-ar-modal" try-in-ar-modal></div>';const EXT_IMAGE = ['jpeg', 'jpg', 'png', 'hdr'];
const EXT_VIDEO = ['mp4', 'webm'];
const EXT_MODEL = ['fbx', 'gltf', 'glb', 'usdz'];
const AssetType = {
  Image: {
    id: 1,
    name: 'image'
  },
  // jpg, png, ...
  Video: {
    id: 2,
    name: 'video'
  },
  // mp4, webm, ...
  Model: {
    id: 3,
    name: 'model'
  },
  // fbx, gltf, glb, usdz ...
  PublisherStream: {
    id: 4,
    name: 'publisher-stream',
    file: 'publisherStream'
  },
  // valore fisso di file a ‘publisherStream’ e folder string.empty
  AttendeeStream: {
    id: 5,
    name: 'next-attendee-stream',
    file: 'nextAttendeeStream'
  },
  // valore fisso di file a ‘nextAttendeeStream’ e folder string.empty
  PublisherScreen: {
    id: 6,
    name: 'publisher-screen',
    file: 'publisherScreen'
  },
  // valore fisso di file a ‘publisherScreen’ e folder string.empty
  AttendeeScreen: {
    id: 7,
    name: 'attendee-screen',
    file: 'attendeeScreen'
  },
  // valore fisso di file a ‘attendeeScreen’ e folder string.empty
  SmartDeviceStream: {
    id: 8,
    name: 'smart-device-stream',
    file: 'smartDeviceStream'
  } // valore fisso di file a smartDeviceStream e folder string.empty
};

const AssetGroupType = {
  ImageOrVideo: {
    id: 1,
    name: 'Image or Video',
    ids: [1, 2]
  },
  // Model: { id: 2, name: 'Model 3D', ids: [3] },
  Publisher: {
    id: 3,
    name: 'Publisher',
    ids: [4]
  },
  Attendee: {
    id: 4,
    name: 'Attendee',
    ids: [5]
  }
  // PublisherScreen: { id: 5, name: 'PublisherScreen', ids: [6] },
  // AttendeeScreen: { id: 6, name: 'AttendeeScreen', ids: [7] },
};

function AssetGroupTypeInit() {
  // console.log('environment.flags.editorAssetScreen', environment.flags.editorAssetScreen, environment);
  if (environment.flags.editorAssetScreen) {
    AssetGroupType.PublisherScreen = {
      id: 5,
      name: 'PublisherScreen',
      ids: [6]
    };
    AssetGroupType.AttendeeScreen = {
      id: 6,
      name: 'AttendeeScreen',
      ids: [7]
    };
  }
  AssetGroupType.SmartDevice = {
    id: 7,
    name: 'Smart Device',
    ids: [8]
  };
}
const STREAM_TYPES = [AssetType.PublisherStream.name, AssetType.AttendeeStream.name, AssetType.PublisherScreen.name, AssetType.AttendeeScreen.name, AssetType.SmartDeviceStream.name];
function assetIsStream(asset) {
  // console.log('assetIsStream', asset.type.name, STREAM_TYPES);
  return asset && STREAM_TYPES.indexOf(asset.type.name) !== -1;
}
function assetTypeById(id) {
  const type = Object.keys(AssetType).reduce((p, key) => {
    const type = AssetType[key];
    return type.id === id ? type : p;
  }, null);
  return type;
  // return Object.keys(AssetType).map(x => AssetType[x]).find(x => x.id === id);
}

function assetGroupTypeById(id) {
  const type = Object.keys(AssetGroupType).reduce((p, key) => {
    const type = AssetGroupType[key];
    return type.id === id ? type : p;
  }, null);
  return type;
  // return Object.keys(AssetGroupType).map(x => AssetGroupType[x]).find(x => x.id === id);
}

function assetGroupTypeFromItem(item) {
  let key;
  if (item && item.asset) {
    key = Object.keys(AssetGroupType).find(key => {
      // console.log(key, AssetGroupType[key].ids, item.asset.type.id);
      return AssetGroupType[key].ids.indexOf(item.asset.type.id) !== -1;
    });
  }
  return AssetGroupType[key || 'ImageOrVideo'];
}
function assetPayloadFromGroupTypeId(groupTypeId) {
  const groupType = assetGroupTypeById(groupTypeId);
  const type = assetTypeById(groupType.ids[0]);
  const file = type.file;
  const asset = {
    type: type,
    folder: '',
    file: file
  };
  // console.log('assetPayloadFromGroupTypeId', asset);
  return new Asset(asset);
}
function assetTypeFromPath(path) {
  const extension = path.split('.').pop().toLowerCase();
  if (EXT_IMAGE.indexOf(extension) !== -1) {
    return AssetType.Image;
  } else if (EXT_VIDEO.indexOf(extension) !== -1) {
    return AssetType.Video;
  } else if (EXT_MODEL.indexOf(extension) !== -1) {
    return AssetType.Model;
  }
}
class Asset {
  constructor(options) {
    if (options) {
      Object.assign(this, options);
    }
  }
  get payload() {
    const payload = {};
    Object.keys(this).forEach(key => {
      if (Asset.allowedProps.indexOf(key) !== -1) {
        payload[key] = this[key];
      }
    });
    return payload;
  }
  static fromUrl(url) {
    const segments = url.split('/');
    const file = segments.pop();
    const folder = segments.join('/') + '/';
    const type = assetTypeFromPath(file);
    return new Asset({
      type: type,
      folder: folder,
      file: file
    });
  }
  static get defaultMediaAsset() {
    const asset = {
      id: -1,
      type: {
        id: AssetType.Image,
        name: 'image'
      },
      folder: '/textures/grid/',
      file: 'grid.jpg'
    };
    return asset;
  }
}
Asset.allowedProps = ['id', 'type', 'folder', 'file', 'linkedPlayId', 'chromaKeyColor', 'autoplay', 'loop'];
function mapAsset(asset) {
  switch (asset.type.name) {
    default:
      asset = new Asset(asset);
  }
  return asset;
}const DEFAULT_WAITING_ROOM = {
  id: 'waiting-room',
  type: {
    id: 1,
    name: 'waiting-room'
  },
  name: 'Waiting Room',
  likes: 0,
  liked: false,
  asset: {
    type: {
      id: 1,
      name: 'image'
    },
    folder: '/textures/waiting-room/',
    file: 'waiting-room.jpg'
  },
  items: [],
  orientation: {
    latitude: 0,
    longitude: 0
  }
};
class ViewService {
  static get dataViews() {
    return this.data ? this.data.views : [];
  }
  static get validViews() {
    return this.data ? this.data.views.filter(x => x.type.name !== ViewType.WaitingRoom.name) : [];
  }
  static get pathViews() {
    const views = this.validViews;
    return views.filter(x => x.path);
  }
  static get validPathViews() {
    const views = this.editor ? this.data.views : this.validViews;
    return views.filter(x => x.path);
  }

  // action: { viewId:number, keepOrientation:boolean, useLastOrientation:boolean };

  static set action(action) {
    this.action$_.next(action);
  }
  static get action() {
    return this.action$_.getValue();
  }

  // static viewId$_ = new BehaviorSubject(null);
  static set viewId(viewId) {
    this.action$_.next({
      viewId,
      keepOrientation: false,
      useLastOrientation: false
    });
  }
  static get viewId() {
    const action = this.action$_.getValue();
    return action ? action.viewId : null;
  }
  static getDataView(viewId) {
    const views = this.dataViews;
    return views.find(x => x.id === viewId) || null;
  }
  static get currentView() {
    const viewId = this.viewId;
    if (viewId !== null) {
      return this.getDataView(viewId);
    }
    return null;
  }
  static getValidPathId(viewId) {
    if (!viewId) {
      return null;
    }
    const views = this.validPathViews;
    if (views.find(x => x.id === viewId) == null) {
      return null;
    }
    return viewId;
  }
  static getFirstPathId() {
    const views = this.editor && this.path.id === null ? this.dataViews : this.pathViews;
    // console.log('ViewService.getFirstPathId', this.editor, this.path, views);
    return views.length ? views[0].id : null;
  }
  static data$() {
    if (!this.data$_) {
      const dataUrl = (environment.flags.production ? '/api/view' : `${environment.assets}api/data.json`) + '?lang=' + LanguageService.lang;
      this.data$_ = HttpService.get$(dataUrl).pipe(operators.map(data => {
        data.views = data.views.map(view => mapView(view));
        this.data = data;
        return data;
      }), operators.shareReplay(1));
    }
    return this.data$_;
  }
  static view$() {
    // const editor = this.editor;
    const meetingUrl = new MeetingUrl();
    // const pathId = meetingUrl.pathId;
    const viewId = this.getValidPathId(meetingUrl.viewId);
    const embedViewId = this.getValidPathId(meetingUrl.embedViewId);
    const initialViewId = embedViewId || viewId || this.getFirstPathId();
    // console.log('ViewService.view$', viewId, embedViewId, initialViewId);
    this.action$_.next({
      viewId: initialViewId
    });
    return this.action$_.pipe(operators.distinctUntilChanged((a, b) => a.viewId === b.viewId), operators.map(action => {
      // const view = data.views.find(view => view.id === action.viewId);
      // console.log('ViewService.view$', 'path', path);
      // filter path
      let view = this.dataViews.find(view => view.id === action.viewId);
      /*
      if (path && !editor) {
      	if (path.items.indexOf(view.id) === -1) {
      		const newView = Object.assign({}, view);
      		newView.items = view.items.filter(x => {
      			if (x.type.name === ViewItemType.Nav.name) {
      				return path.items.indexOf(x.viewId) === -1;
      			} else {
      				return true;
      			}
      		});
      		view = mapView(newView);
      	} else {
      		view = null;
      	}
      }
      // console.log('ViewService.view$', view, path);
      */
      if (view) {
        view.keepOrientation = action.keepOrientation || false;
        view.useLastOrientation = action.useLastOrientation || false;
      }
      // console.log('ViewService.view$', action.viewId, action.keepOrientation, action.useLastOrientation);
      return view || this.getWaitingRoom();
    }));
  }
  static setDataAndPath(data, path) {
    this.data = data;
    data.views.forEach(view => {
      view.path = !path || path.items.indexOf(view.id) === -1;
      view.items.forEach(item => {
        let valid = true;
        if (path) {
          if (item.type.name === ViewItemType.Nav.name) {
            valid = path.items.indexOf(item.viewId) === -1;
          }
          item.path = valid;
        }
      });
    });
    this.path = path;
  }
  static hostedView$(data, path) {
    this.setDataAndPath(data, path);
    this.editor = false;
    const waitingRoom = this.getWaitingRoom();
    return rxjs.combineLatest([this.view$(), this.hosted$()]).pipe(operators.map(datas => {
      const view = datas[0];
      const hosted = datas[1];
      return hosted ? view : waitingRoom;
    }), operators.distinctUntilChanged((a, b) => {
      return a.id === b.id;
    }), operators.tap(view => {
      if (view.id !== waitingRoom.id) {
        MeetingUrl.replaceWithOptions({
          viewId: view.id
        });
        const prefetchAssets = ViewService.getPrefetchAssets(view);
        view.prefetchAssets = prefetchAssets;
      }
    }));
  }
  static editorView$(data, path) {
    this.setDataAndPath(data, path);
    this.editor = true;
    const waitingRoom = this.getWaitingRoom();
    return this.view$().pipe(operators.map(view => {
      // console.log('ViewService.editorView$.view', view.updateIndices);
      const options = {
        pathId: null
      };
      if (view.id !== waitingRoom.id) {
        options.viewId = view.id;
      }
      if (path && path.id !== null) {
        options.pathId = path.id;
      }
      MeetingUrl.replaceWithOptions(options);
      return view;
    }));
  }
  static hosted$() {
    return StateService.state$.pipe(operators.map(state => state.hosted), operators.distinctUntilChanged());
  }
  static viewById$(viewId) {
    return this.data$().pipe(operators.map(data => this.dataViews.find(x => x.id === viewId)));
  }
  static viewLike$(view) {
    if (!view.liked) {
      view.liked = true;
      if (environment.flags.production) {
        return HttpService.get$(`/api/view/${view.id}/like`);
      } else {
        view.likes = view.likes || 0;
        view.likes++;
        return rxjs.of(view);
      }
    } else {
      return rxjs.of(null);
    }
  }
  static setViewLike$(message) {
    return this.viewById$(message.viewId).pipe(operators.tap(view => {
      if (view) {
        view.likes = message.likes;
      }
    }));
  }
  static getWaitingRoom() {
    return this.dataViews.find(x => x.type.name === ViewType.WaitingRoom.name) || DEFAULT_WAITING_ROOM;
  }
  static getPrefetchAssets(view) {
    const views = this.validPathViews;
    const assets = view.items
    // filter nav items
    .filter(x => x.type.name === ViewItemType.Nav.name && x.viewId != null)
    // map to view
    .map(x => views.find(v => v.id === x.viewId))
    // filter view with image
    .filter(v => v && v.asset && v.asset.type.name === AssetType.Image.name)
    // map to asset
    .map(v => environment.getPath(v.asset.folder + v.asset.file));
    // console.log('ViewService.getPrefetchAssets', assets);
    return assets;
  }
  static addView(view) {
    const data = this.data;
    const views = data.views.slice();
    views.push(view);
    data.views = views;
    this.viewId = view.id;
  }
  static deleteView(view) {
    const data = this.data;
    const views = data.views.slice();
    const index = views.reduce((p, c, i) => {
      return c.id === view.id ? i : p;
    }, -1);
    if (index > 0) {
      views.splice(index, 1);
      data.views = views;
      const dataViews = this.dataViews;
      if (dataViews.length > 0) {
        this.viewId = dataViews[0].id;
      }
    }
    // this.pushChanges();
  }
}
ViewService.action$_ = new rxjs.BehaviorSubject(null);let items$_ = null;
class WishlistService {
  static get items$() {
    if (!items$_) {
      const items = LocalStorageService.get('wishlist') || [];
      items$_ = new rxjs.BehaviorSubject(items);
    }
    return items$_;
  }
  static getItems() {
    return this.items$.getValue();
  }
  static indexOf(item) {
    const items = this.getItems();
    return items.reduce((p, c, i) => {
      return p === -1 && c.viewId === item.viewId && c.itemId === item.itemId ? i : p;
    }, -1);
  }
  static has(item) {
    return this.indexOf(item) !== -1;
  }
  static add$(item) {
    const items = this.getItems();
    if (!this.has(item)) {
      items.push(item);
      LocalStorageService.set('wishlist', items);
      this.items$.next(items);
    }
    return this.items$;
  }
  static remove$(item) {
    const items = this.getItems();
    const index = this.indexOf(item);
    if (index !== -1) {
      items.splice(index, 1);
      LocalStorageService.set('wishlist', items);
      this.items$.next(items);
    }
    return this.items$;
  }
  static toggle$(item) {
    const items = this.getItems();
    const index = this.indexOf(item);
    if (index !== -1) {
      items.splice(index, 1);
      LocalStorageService.set('wishlist', items);
      this.items$.next(items);
    } else {
      items.push(item);
      LocalStorageService.set('wishlist', items);
      this.items$.next(items);
    }
    return this.items$;
  }
}class MediaLoaderEvent {
  constructor(loader) {
    this.loader = loader;
  }
}
class MediaLoaderPlayEvent extends MediaLoaderEvent {}
class MediaLoaderPauseEvent extends MediaLoaderEvent {}
class MediaLoaderDisposeEvent extends MediaLoaderEvent {}
class MediaLoaderTimeUpdateEvent extends MediaLoaderEvent {}
class MediaLoaderTimeSetEvent extends MediaLoaderEvent {}
class MediaLoader {
  static getLoader() {
    return MediaLoader.loader || (MediaLoader.loader = new THREE.TextureLoader());
  }
  static getPath(item) {
    return environment.getPath(item.asset.folder + item.asset.file);
  }
  static loadTexture(item, callback) {
    const path = MediaLoader.getPath(item);
    return MediaLoader.getLoader().load(path, callback);
  }
  static isVideo(item) {
    return item.asset && item.asset.file && (item.asset.file.indexOf('.mp4') !== -1 || item.asset.file.indexOf('.webm') !== -1);
  }
  static isStream(item) {
    return assetIsStream(item.asset);
  }
  static isMutedStream(item) {
    let isMutedStream = false;
    switch (item.asset.type.name) {
      case AssetType.PublisherStream.name:
        isMutedStream = StateService.state.role === RoleType.Publisher;
        break;
      case AssetType.AttendeeStream.name:
        isMutedStream = StateService.state.role === RoleType.Attendee;
        break;
      case AssetType.PublisherScreen.name:
        isMutedStream = true;
        break;
      case AssetType.AttendeeScreen.name:
        isMutedStream = true;
        break;
      case AssetType.SmartDeviceStream.name:
        isMutedStream = StateService.state.role === RoleType.SmartDevice;
        break;
    }
    // console.log('isMutedStream', isMutedStream, item.asset.type.name, AssetType.PublisherStream.name, StateService.state.role, RoleType.Publisher);
    return isMutedStream;
  }
  static isPublisherStream(item) {
    return item.asset && item.asset.type.name === AssetType.PublisherStream.name;
  }
  static isAttendeeStream(item) {
    return item.asset && item.asset.type.name === AssetType.AttendeeStream.name;
  }
  static isSmartDeviceStream(item) {
    return item.asset && item.asset.type.name === AssetType.SmartDeviceStream.name;
  }
  static isPublisherScreen(item) {
    return item.asset && item.asset.type.name === AssetType.PublisherScreen.name;
  }
  static isAttendeeScreen(item) {
    return item.asset && item.asset.type.name === AssetType.AttendeeScreen.name;
  }
  get isVideo() {
    return MediaLoader.isVideo(this.item);
  }
  get isStream() {
    return MediaLoader.isStream(this.item);
  }
  get isMutedStream() {
    return MediaLoader.isMutedStream(this.item);
  }
  get isPublisherStream() {
    return MediaLoader.isPublisherStream(this.item);
  }
  get isAttendeeStream() {
    return MediaLoader.isAttendeeStream(this.item);
  }
  get isSmartDeviceStream() {
    return MediaLoader.isSmartDeviceStream(this.item);
  }
  get isPublisherScreen() {
    return MediaLoader.isPublisherScreen(this.item);
  }
  get isAttendeeScreen() {
    return MediaLoader.isAttendeeScreen(this.item);
  }
  get isPlayableVideo() {
    return this.isVideo; // && !this.item.asset.autoplay;
  }

  get isAutoplayVideo() {
    return this.isStream; // || (this.isVideo && (this.item.asset.autoplay != null));
  }

  get muted() {
    return this.muted_;
  }
  set muted(muted) {
    this.muted_ = muted;
    // console.log('MediaLoader.muted', muted, this.video);
    if (this.video && this.isVideo) {
      this.video.muted = muted === true;
    }
  }
  constructor(item) {
    this.item = item;
    this.toggle = this.toggle.bind(this);
    this.muted_ = false;
    this.subscription = StateService.state$.subscribe(state => this.muted = state.volumeMuted);
  }
  load(callback) {
    const item = this.item;
    let texture;
    // console.log('MediaLoader.load', item, this.isStream);
    if (this.isStream && item.streamId) {
      const streamId = item.streamId;
      const video = document.querySelector(`#stream-${streamId} video`); // document.querySelector(`#stream-remote-${streamId} video`) || document.querySelector(`#stream-local-${streamId} video`);
      if (!video) {
        return;
      }
      const onCanPlay = () => {
        if (this.disposed) {
          return;
        }
        video.removeEventListener('canplay', onCanPlay);
        texture = this.texture = new THREE.VideoTexture(video);
        texture.minFilter = THREE.LinearFilter;
        texture.magFilter = THREE.LinearFilter;
        texture.mapping = THREE.UVMapping;
        // texture.format = THREE.RGBAFormat;
        // texture.image.width = video.videoWidth;
        // texture.image.height = video.videoHeight;
        texture.needsUpdate = true;
        if (typeof callback === 'function') {
          callback(texture, this);
        }
      };
      const isMutedStream = this.isMutedStream;
      video.crossOrigin = 'anonymous';
      video.volume = isMutedStream ? 0 : 1;
      video.muted = isMutedStream;
      if (video.readyState >= video.HAVE_FUTURE_DATA) {
        onCanPlay();
      } else {
        video.addEventListener('canplay', onCanPlay);
      }
    } else if (this.isVideo) {
      // create the video element
      const autoplay = item.asset && item.asset.autoplay || false;
      const loop = item.asset && item.asset.loop || false;
      const video = this.video = document.createElement('video');
      video.crossOrigin = 'anonymous';
      video.preload = 'metadata';
      video.volume = 0.8;
      video.muted = autoplay;
      video.playsInline = true;
      video.loop = loop;
      const onCanPlay = () => {
        if (this.disposed) {
          return;
        }
        // console.log('MediaLoader', 'onCanPlay');
        video.oncanplay = null;
        texture = new THREE.VideoTexture(video);
        texture.minFilter = THREE.LinearFilter;
        texture.magFilter = THREE.LinearFilter;
        texture.mapping = THREE.UVMapping;
        // texture.encoding = THREE.sRGBEncoding;
        // texture.format = THREE.RGBAFormat;
        // texture.image.width = video.videoWidth;
        // texture.image.height = video.videoHeight;
        texture.needsUpdate = true;
        if (typeof callback === 'function') {
          callback(texture, this);
        }
        if (autoplay) {
          this.play(item.silent);
        } else {
          video.pause();
        }
      };
      const onTimeUpdate = () => {
        if (this.disposed) {
          return;
        }
        MediaLoader.events$.next(new MediaLoaderTimeUpdateEvent(this));
      };
      const onEnded = () => {
        if (this.disposed) {
          return;
        }
        if (!loop) {
          MediaLoader.events$.next(new MediaLoaderPauseEvent(this));
        }
      };
      video.oncanplay = onCanPlay;
      video.ontimeupdate = onTimeUpdate;
      video.onended = onEnded;
      video.src = MediaLoader.getPath(item);
      video.load(); // must call after setting/changing source
    } else if (item.asset) {
      MediaLoader.loadTexture(item, texture => {
        if (this.disposed) {
          return;
        }
        texture.minFilter = THREE.LinearFilter;
        texture.magFilter = THREE.LinearFilter;
        texture.mapping = THREE.UVMapping;
        // texture.format = THREE.RGBAFormat;
        texture.wrapS = THREE.RepeatWrapping;
        texture.wrapT = THREE.RepeatWrapping;
        if (typeof callback === 'function') {
          callback(texture, this);
        }
      });
    } else {
      callback(null, this);
    }
    return this;
  }
  get progress() {
    if (this.video) {
      return this.video.currentTime / this.video.duration;
    } else {
      return 0;
    }
  }
  set progress(progress) {
    if (this.video) {
      const currentTime = this.video.duration * progress;
      if (this.video.seekable.length > progress && this.video.currentTime !== currentTime) {
        // console.log('MediaLoader', 'progress', progress, 'currentTime', currentTime, 'duration', this.video.duration, 'seekable', this.video.seekable);
        this.video.currentTime = currentTime;
        MediaLoader.events$.next(new MediaLoaderTimeSetEvent(this));
      }
    }
  }
  play(silent) {
    // console.log('MediaLoader.play');
    if (this.video) {
      this.video.muted = this.muted_;
      this.video.play().then(() => {
        // console.log('MediaLoader.play.success', this.item.asset.file);
        if (!silent) {
          MediaLoader.events$.next(new MediaLoaderPlayEvent(this));
        }
      }, error => {
        console.log('MediaLoader.play.error', this.item.asset.file, error);
      });
    }
  }
  pause(silent) {
    // console.log('MediaLoader.pause');
    if (this.video && this.isVideo) {
      this.video.muted = true;
      this.video.pause();
      if (!silent) {
        MediaLoader.events$.next(new MediaLoaderPauseEvent(this));
      }
    }
  }
  toggle() {
    // console.log('MediaLoader.toggle', this.video);
    if (this.video && this.isVideo) {
      if (this.video.paused) {
        this.video.muted = this.muted_;
        this.play();
        return true;
      } else {
        this.pause();
        return false;
      }
    }
  }
  dispose() {
    // console.log('MediaLoader.dispose');
    this.subscription.unsubscribe();
    this.pause(true);
    if (this.isVideo && this.video) {
      this.video.ontimeupdate = null;
      this.video.onended = null;
      MediaLoader.events$.next(new MediaLoaderDisposeEvent(this));
    }
    this.disposed = true;
    delete this.video;
  }
}
MediaLoader.events$ = new rxjs.ReplaySubject(1);const PANORAMA_RADIUS = 101;
class Geometry {
  static get defaultGeometry() {
    return Geometry.defaultGeometry_ || (Geometry.defaultGeometry_ = new THREE.BoxBufferGeometry(1, 1, 1));
  }
  static get planeGeometry() {
    return Geometry.planeGeometry_ || (Geometry.planeGeometry_ = new THREE.PlaneBufferGeometry(1, 1, 2, 2));
  }
  static get sphereGeometry() {
    return Geometry.sphereGeometry_ || (Geometry.sphereGeometry_ = new THREE.SphereBufferGeometry(3, 12, 12));
  }
  static get panoramaGeometry() {
    return Geometry.panoramaGeometry_ || (Geometry.panoramaGeometry_ = new THREE.SphereBufferGeometry(PANORAMA_RADIUS, 36, 36)); // 101, 44, 30
    // return Geometry.panoramaGeometry_ || (Geometry.panoramaGeometry_ = new THREE.IcosahedronBufferGeometry(PANORAMA_RADIUS, 4)); // 101, 44, 30
    // return Geometry.panoramaGeometry_ || (Geometry.panoramaGeometry_ = new THREE.SphereBufferGeometry(PANORAMA_RADIUS, 40, 40)); // 101, 44, 30
  }
}new THREE.Vector3();
class Host {
  static get origin() {
    const host = this.host;
    if (host) {
      const origin = this.origin_;
      origin.set(0, 0, 0);
      const camera = host.renderer.xr.isPresenting ? host.renderer.xr.getCamera(host.camera) : host.camera;
      camera.localToWorld(origin);
      // return host.cameraGroup.position;
    }

    return this.origin_;
  }
  static getDistanceToCamera(camera, fov, aspect, size, fitOffset) {
    if (fitOffset === void 0) {
      fitOffset = 0.88;
    }
    const factor = 2 * Math.atan(Math.PI * fov / 360);
    const heightDistance = size.y * camera.zoom / factor;
    const widthDistance = size.x * camera.zoom / factor / aspect;
    const distance = fitOffset * Math.max(heightDistance, widthDistance);
    return distance;
  }
}
Host.origin_ = new THREE.Vector3();// import DebugService from '../debug.service';
class Interactive {}
Interactive.items = [];
Interactive.hittest = interactiveHittest.bind(Interactive);
Interactive.dispose = interactiveDispose.bind(Interactive);
function interactiveHittest(raycaster, down, event) {
  if (down === void 0) {
    down = false;
  }
  // const debugService = DebugService.getService();
  let dirty = false;
  if (this.down !== down) {
    this.down = down;
    this.lock = false;
    dirty = true;
  }
  const items = this.items.filter(x => x.parent && !x.freezed);
  const intersections = raycaster.intersectObjects(items);
  let key, hit;
  const hash = {};
  intersections.forEach((intersection, i) => {
    const object = intersection.object;
    key = object.uuid;
    if (i === 0) {
      if (this.lastIntersectedObject !== object || dirty) {
        this.lastIntersectedObject = object;
        hit = object;
        // debugService.setMessage(hit.name || hit.id);
        // haptic feedback
      } else if (object.intersection && (Math.abs(object.intersection.point.x - intersection.point.x) > 0.01 || Math.abs(object.intersection.point.y - intersection.point.y) > 0.01)) {
        object.intersection = intersection;
        object.emit('move', object);
      }
    }
    hash[key] = intersection;
  });
  if (intersections.length === 0) {
    this.lastIntersectedObject = null;
  }
  items.forEach(x => {
    x.intersection = hash[x.uuid];
    x.over = x === this.lastIntersectedObject || x.intersection && !x.depthTest && (!this.lastIntersectedObject || this.lastIntersectedObject.depthTest);
    x.down = down && x.over && !this.lock;
    if (x.down) {
      this.lock = true;
    }
  });
  return hit;
}
function interactiveDispose(object) {
  if (object) {
    const index = this.items.indexOf(object);
    if (index !== -1) {
      this.items.splice(index, 1);
    }
  }
}class FreezableMesh extends three.Mesh {
  get freezed() {
    return this.freezed_;
  }
  set freezed(freezed) {
    // !!! cycle through freezable and not freezable
    this.freezed_ = freezed;
    this.children.filter(x => x.__lookupGetter__('freezed')).forEach(x => x.freezed = freezed);
  }
  constructor(geometry, material) {
    geometry = geometry || Geometry.defaultGeometry;
    material = material || new THREE.MeshBasicMaterial({
      color: 0xff00ff
      // opacity: 1,
      // transparent: true,
    });

    super(geometry, material);
    this.freezed = false;
  }
  freeze() {
    this.freezed = true;
  }
  unfreeze() {
    this.freezed = false;
  }
}class EmittableMesh extends FreezableMesh {
  constructor(geometry, material) {
    geometry = geometry || Geometry.defaultGeometry;
    material = material || new THREE.MeshBasicMaterial({
      color: 0xff00ff
      // opacity: 1,
      // transparent: true,
    });

    super(geometry, material);
    this.events = {};
  }
  on(type, callback) {
    const event = this.events[type] = this.events[type] || [];
    event.push(callback);
    return () => {
      this.events[type] = event.filter(x => x !== callback);
    };
  }
  off(type, callback) {
    const event = this.events[type];
    if (event) {
      this.events[type] = event.filter(x => x !== callback);
    }
  }
  emit(type, data) {
    const event = this.events[type];
    if (event) {
      event.forEach(callback => {
        // callback.call(this, data);
        callback(data);
      });
    }
    const broadcast = this.events.broadcast;
    if (broadcast) {
      broadcast.forEach(callback => {
        callback(type, data);
      });
    }
  }
}class InteractiveMesh extends EmittableMesh {
  constructor(geometry, material) {
    super(geometry, material);
    this.depthTest = true;
    this.over_ = false;
    this.down_ = false;
    Interactive.items.push(this);
  }
  get isInteractiveMesh() {
    return true;
  }
  get over() {
    return this.over_;
  }
  set over(over) {
    if (this.over_ != over) {
      this.over_ = over;
      /*
      if (over) {
      	this.emit('hit', this);
      }
      */
      if (over) {
        this.emit('over', this);
      } else {
        this.emit('out', this);
      }
    }
  }
  get down() {
    return this.down_;
  }
  set down(down) {
    down = down && this.over;
    if (this.down_ != down) {
      this.down_ = down;
      if (down) {
        this.emit('down', this);
      } else {
        this.emit('up', this);
      }
    }
  }
}// https://github.com/mrdoob/three.js/issues/5552
// http://en.wikipedia.org/wiki/RGBE_image_format

class RGBELoader extends three.DataTextureLoader {

	constructor( manager ) {

		super( manager );

		this.type = three.HalfFloatType;

	}

	// adapted from http://www.graphics.cornell.edu/~bjw/rgbe.html

	parse( buffer ) {

		const
			/* return codes for rgbe routines */
			//RGBE_RETURN_SUCCESS = 0,
			RGBE_RETURN_FAILURE = - 1,

			/* default error routine.  change this to change error handling */
			rgbe_read_error = 1,
			rgbe_write_error = 2,
			rgbe_format_error = 3,
			rgbe_memory_error = 4,
			rgbe_error = function ( rgbe_error_code, msg ) {

				switch ( rgbe_error_code ) {

					case rgbe_read_error: console.error( 'THREE.RGBELoader Read Error: ' + ( msg || '' ) );
						break;
					case rgbe_write_error: console.error( 'THREE.RGBELoader Write Error: ' + ( msg || '' ) );
						break;
					case rgbe_format_error: console.error( 'THREE.RGBELoader Bad File Format: ' + ( msg || '' ) );
						break;
					default:
					case rgbe_memory_error: console.error( 'THREE.RGBELoader: Error: ' + ( msg || '' ) );

				}

				return RGBE_RETURN_FAILURE;

			},

			/* offsets to red, green, and blue components in a data (float) pixel */
			//RGBE_DATA_RED = 0,
			//RGBE_DATA_GREEN = 1,
			//RGBE_DATA_BLUE = 2,

			/* number of floats per pixel, use 4 since stored in rgba image format */
			//RGBE_DATA_SIZE = 4,

			/* flags indicating which fields in an rgbe_header_info are valid */
			RGBE_VALID_PROGRAMTYPE = 1,
			RGBE_VALID_FORMAT = 2,
			RGBE_VALID_DIMENSIONS = 4,

			NEWLINE = '\n',

			fgets = function ( buffer, lineLimit, consume ) {

				const chunkSize = 128;

				lineLimit = ! lineLimit ? 1024 : lineLimit;
				let p = buffer.pos,
					i = - 1, len = 0, s = '',
					chunk = String.fromCharCode.apply( null, new Uint16Array( buffer.subarray( p, p + chunkSize ) ) );

				while ( ( 0 > ( i = chunk.indexOf( NEWLINE ) ) ) && ( len < lineLimit ) && ( p < buffer.byteLength ) ) {

					s += chunk; len += chunk.length;
					p += chunkSize;
					chunk += String.fromCharCode.apply( null, new Uint16Array( buffer.subarray( p, p + chunkSize ) ) );

				}

				if ( - 1 < i ) {

					/*for (i=l-1; i>=0; i--) {
						byteCode = m.charCodeAt(i);
						if (byteCode > 0x7f && byteCode <= 0x7ff) byteLen++;
						else if (byteCode > 0x7ff && byteCode <= 0xffff) byteLen += 2;
						if (byteCode >= 0xDC00 && byteCode <= 0xDFFF) i--; //trail surrogate
					}*/
					if ( false !== consume ) buffer.pos += len + i + 1;
					return s + chunk.slice( 0, i );

				}

				return false;

			},

			/* minimal header reading.  modify if you want to parse more information */
			RGBE_ReadHeader = function ( buffer ) {


				// regexes to parse header info fields
				const magic_token_re = /^#\?(\S+)/,
					gamma_re = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,
					exposure_re = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,
					format_re = /^\s*FORMAT=(\S+)\s*$/,
					dimensions_re = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,

					// RGBE format header struct
					header = {

						valid: 0, /* indicate which fields are valid */

						string: '', /* the actual header string */

						comments: '', /* comments found in header */

						programtype: 'RGBE', /* listed at beginning of file to identify it after "#?". defaults to "RGBE" */

						format: '', /* RGBE format, default 32-bit_rle_rgbe */

						gamma: 1.0, /* image has already been gamma corrected with given gamma. defaults to 1.0 (no correction) */

						exposure: 1.0, /* a value of 1.0 in an image corresponds to <exposure> watts/steradian/m^2. defaults to 1.0 */

						width: 0, height: 0 /* image dimensions, width/height */

					};

				let line, match;

				if ( buffer.pos >= buffer.byteLength || ! ( line = fgets( buffer ) ) ) {

					return rgbe_error( rgbe_read_error, 'no header found' );

				}

				/* if you want to require the magic token then uncomment the next line */
				if ( ! ( match = line.match( magic_token_re ) ) ) {

					return rgbe_error( rgbe_format_error, 'bad initial token' );

				}

				header.valid |= RGBE_VALID_PROGRAMTYPE;
				header.programtype = match[ 1 ];
				header.string += line + '\n';

				while ( true ) {

					line = fgets( buffer );
					if ( false === line ) break;
					header.string += line + '\n';

					if ( '#' === line.charAt( 0 ) ) {

						header.comments += line + '\n';
						continue; // comment line

					}

					if ( match = line.match( gamma_re ) ) {

						header.gamma = parseFloat( match[ 1 ] );

					}

					if ( match = line.match( exposure_re ) ) {

						header.exposure = parseFloat( match[ 1 ] );

					}

					if ( match = line.match( format_re ) ) {

						header.valid |= RGBE_VALID_FORMAT;
						header.format = match[ 1 ];//'32-bit_rle_rgbe';

					}

					if ( match = line.match( dimensions_re ) ) {

						header.valid |= RGBE_VALID_DIMENSIONS;
						header.height = parseInt( match[ 1 ], 10 );
						header.width = parseInt( match[ 2 ], 10 );

					}

					if ( ( header.valid & RGBE_VALID_FORMAT ) && ( header.valid & RGBE_VALID_DIMENSIONS ) ) break;

				}

				if ( ! ( header.valid & RGBE_VALID_FORMAT ) ) {

					return rgbe_error( rgbe_format_error, 'missing format specifier' );

				}

				if ( ! ( header.valid & RGBE_VALID_DIMENSIONS ) ) {

					return rgbe_error( rgbe_format_error, 'missing image size specifier' );

				}

				return header;

			},

			RGBE_ReadPixels_RLE = function ( buffer, w, h ) {

				const scanline_width = w;

				if (
					// run length encoding is not allowed so read flat
					( ( scanline_width < 8 ) || ( scanline_width > 0x7fff ) ) ||
					// this file is not run length encoded
					( ( 2 !== buffer[ 0 ] ) || ( 2 !== buffer[ 1 ] ) || ( buffer[ 2 ] & 0x80 ) )
				) {

					// return the flat buffer
					return new Uint8Array( buffer );

				}

				if ( scanline_width !== ( ( buffer[ 2 ] << 8 ) | buffer[ 3 ] ) ) {

					return rgbe_error( rgbe_format_error, 'wrong scanline width' );

				}

				const data_rgba = new Uint8Array( 4 * w * h );

				if ( ! data_rgba.length ) {

					return rgbe_error( rgbe_memory_error, 'unable to allocate buffer space' );

				}

				let offset = 0, pos = 0;

				const ptr_end = 4 * scanline_width;
				const rgbeStart = new Uint8Array( 4 );
				const scanline_buffer = new Uint8Array( ptr_end );
				let num_scanlines = h;

				// read in each successive scanline
				while ( ( num_scanlines > 0 ) && ( pos < buffer.byteLength ) ) {

					if ( pos + 4 > buffer.byteLength ) {

						return rgbe_error( rgbe_read_error );

					}

					rgbeStart[ 0 ] = buffer[ pos ++ ];
					rgbeStart[ 1 ] = buffer[ pos ++ ];
					rgbeStart[ 2 ] = buffer[ pos ++ ];
					rgbeStart[ 3 ] = buffer[ pos ++ ];

					if ( ( 2 != rgbeStart[ 0 ] ) || ( 2 != rgbeStart[ 1 ] ) || ( ( ( rgbeStart[ 2 ] << 8 ) | rgbeStart[ 3 ] ) != scanline_width ) ) {

						return rgbe_error( rgbe_format_error, 'bad rgbe scanline format' );

					}

					// read each of the four channels for the scanline into the buffer
					// first red, then green, then blue, then exponent
					let ptr = 0, count;

					while ( ( ptr < ptr_end ) && ( pos < buffer.byteLength ) ) {

						count = buffer[ pos ++ ];
						const isEncodedRun = count > 128;
						if ( isEncodedRun ) count -= 128;

						if ( ( 0 === count ) || ( ptr + count > ptr_end ) ) {

							return rgbe_error( rgbe_format_error, 'bad scanline data' );

						}

						if ( isEncodedRun ) {

							// a (encoded) run of the same value
							const byteValue = buffer[ pos ++ ];
							for ( let i = 0; i < count; i ++ ) {

								scanline_buffer[ ptr ++ ] = byteValue;

							}
							//ptr += count;

						} else {

							// a literal-run
							scanline_buffer.set( buffer.subarray( pos, pos + count ), ptr );
							ptr += count; pos += count;

						}

					}


					// now convert data from buffer into rgba
					// first red, then green, then blue, then exponent (alpha)
					const l = scanline_width; //scanline_buffer.byteLength;
					for ( let i = 0; i < l; i ++ ) {

						let off = 0;
						data_rgba[ offset ] = scanline_buffer[ i + off ];
						off += scanline_width; //1;
						data_rgba[ offset + 1 ] = scanline_buffer[ i + off ];
						off += scanline_width; //1;
						data_rgba[ offset + 2 ] = scanline_buffer[ i + off ];
						off += scanline_width; //1;
						data_rgba[ offset + 3 ] = scanline_buffer[ i + off ];
						offset += 4;

					}

					num_scanlines --;

				}

				return data_rgba;

			};

		const RGBEByteToRGBFloat = function ( sourceArray, sourceOffset, destArray, destOffset ) {

			const e = sourceArray[ sourceOffset + 3 ];
			const scale = Math.pow( 2.0, e - 128.0 ) / 255.0;

			destArray[ destOffset + 0 ] = sourceArray[ sourceOffset + 0 ] * scale;
			destArray[ destOffset + 1 ] = sourceArray[ sourceOffset + 1 ] * scale;
			destArray[ destOffset + 2 ] = sourceArray[ sourceOffset + 2 ] * scale;
			destArray[ destOffset + 3 ] = 1;

		};

		const RGBEByteToRGBHalf = function ( sourceArray, sourceOffset, destArray, destOffset ) {

			const e = sourceArray[ sourceOffset + 3 ];
			const scale = Math.pow( 2.0, e - 128.0 ) / 255.0;

			// clamping to 65504, the maximum representable value in float16
			destArray[ destOffset + 0 ] = three.DataUtils.toHalfFloat( Math.min( sourceArray[ sourceOffset + 0 ] * scale, 65504 ) );
			destArray[ destOffset + 1 ] = three.DataUtils.toHalfFloat( Math.min( sourceArray[ sourceOffset + 1 ] * scale, 65504 ) );
			destArray[ destOffset + 2 ] = three.DataUtils.toHalfFloat( Math.min( sourceArray[ sourceOffset + 2 ] * scale, 65504 ) );
			destArray[ destOffset + 3 ] = three.DataUtils.toHalfFloat( 1 );

		};

		const byteArray = new Uint8Array( buffer );
		byteArray.pos = 0;
		const rgbe_header_info = RGBE_ReadHeader( byteArray );

		if ( RGBE_RETURN_FAILURE !== rgbe_header_info ) {

			const w = rgbe_header_info.width,
				h = rgbe_header_info.height,
				image_rgba_data = RGBE_ReadPixels_RLE( byteArray.subarray( byteArray.pos ), w, h );

			if ( RGBE_RETURN_FAILURE !== image_rgba_data ) {

				let data, format, type;
				let numElements;

				switch ( this.type ) {

					case three.FloatType:

						numElements = image_rgba_data.length / 4;
						const floatArray = new Float32Array( numElements * 4 );

						for ( let j = 0; j < numElements; j ++ ) {

							RGBEByteToRGBFloat( image_rgba_data, j * 4, floatArray, j * 4 );

						}

						data = floatArray;
						type = three.FloatType;
						break;

					case three.HalfFloatType:

						numElements = image_rgba_data.length / 4;
						const halfArray = new Uint16Array( numElements * 4 );

						for ( let j = 0; j < numElements; j ++ ) {

							RGBEByteToRGBHalf( image_rgba_data, j * 4, halfArray, j * 4 );

						}

						data = halfArray;
						type = three.HalfFloatType;
						break;

					default:

						console.error( 'THREE.RGBELoader: unsupported type: ', this.type );
						break;

				}

				return {
					width: w, height: h,
					data: data,
					header: rgbe_header_info.string,
					gamma: rgbe_header_info.gamma,
					exposure: rgbe_header_info.exposure,
					format: format,
					type: type
				};

			}

		}

		return null;

	}

	setDataType( value ) {

		this.type = value;
		return this;

	}

	load( url, onLoad, onProgress, onError ) {

		function onLoadCallback( texture, texData ) {

			switch ( texture.type ) {

				case three.FloatType:

					texture.encoding = three.LinearEncoding;
					texture.minFilter = three.LinearFilter;
					texture.magFilter = three.LinearFilter;
					texture.generateMipmaps = false;
					texture.flipY = true;
					break;

				case three.HalfFloatType:

					texture.encoding = three.LinearEncoding;
					texture.minFilter = three.LinearFilter;
					texture.magFilter = three.LinearFilter;
					texture.generateMipmaps = false;
					texture.flipY = true;
					break;

			}

			if ( onLoad ) onLoad( texture, texData );

		}

		return super.load( url, onLoadCallback, onProgress, onError );

	}

}class KeyboardService {
  static keydown$() {
    if (!this.keydown$_) {
      this.keydown$_ = rxjs.fromEvent(window, 'keydown').pipe(operators.shareReplay(1));
    }
    return this.keydown$_;
  }
  static keyup$() {
    if (!this.keyup$_) {
      this.keyup$_ = rxjs.fromEvent(window, 'keyup').pipe(operators.shareReplay(1));
    }
    return this.keyup$_;
  }
  static keys$() {
    if (!this.keys$_) {
      this.keys$_ = rxjs.merge(this.keydown$(), this.keyup$()).pipe(operators.map(event => {
        const keys = this.keys;
        if (event.type === 'keydown') {
          keys[event.key] = true;
        } else {
          delete keys[event.key];
        }
        return this.keys;
      }), operators.startWith(this.keys), operators.shareReplay(1));
    }
    return this.keys$_;
  }
  static key$() {
    if (!this.key$_) {
      const regexp = /\w/;
      this.key$_ = this.keydown$().pipe(operators.filter(event => event.key && event.key.match(regexp)), operators.map(event => event.key), operators.shareReplay(1));
    }
    return this.key$_;
  }
  static typing$() {
    if (!this.typing$_) {
      let typing = '',
        to;
      this.typing$_ = this.key$().pipe(operators.map(key => {
        if (to) {
          clearTimeout(to);
        }
        typing += key;
        to = setTimeout(() => {
          typing = '';
        }, 1500);
        return typing;
      }), operators.shareReplay(1));
    }
    return this.typing$_;
  }
}
KeyboardService.keys = {};let LOADER_UID = 0;
class LoaderService {
  // merge(this.statusSubject, this.validatorsSubject)

  static switchLoaders() {
    const items = Object.keys(this.items).map(key => this.items[key]);
    const items$ = items.length ? rxjs.combineLatest(items) : rxjs.of(items);
    this.progress$.next(items$);
  }
  static getRef() {
    const ref = ++LOADER_UID;
    this.items[ref] = new rxjs.BehaviorSubject({
      loaded: 0,
      total: 1
    });
    this.switchLoaders();
    return ref;
  }
  static setProgress(ref, loaded, total) {
    if (total === void 0) {
      total = 1;
    }
    // console.log('LoaderService.setProgress');
    const item = this.items[ref];
    if (item) {
      item.next({
        loaded,
        total
      });
    }
    if (loaded >= total) {
      setTimeout(() => {
        delete this.items[ref];
        this.switchLoaders();
      }, 300);
    }
    this.switchLoaders();
  }
}
LoaderService.progress = {
  value: 0,
  loaded: 0,
  total: 0,
  count: 0,
  title: ''
};
LoaderService.items = {};
LoaderService.progress$ = new rxjs.ReplaySubject(1).pipe(operators.switchAll(), operators.map(() => {
  const items = Object.keys(LoaderService.items).map(key => LoaderService.items[key]);
  const progress = items.reduce((progress, subject, i, items) => {
    const item = subject.getValue();
    const loaded = item.loaded || 0;
    const total = item.total || 1;
    const value = loaded / total;
    progress.value += value;
    progress.loaded += loaded;
    progress.total += total;
    return progress;
  }, {
    value: 0,
    loaded: 0,
    total: 0
  });
  progress.count = items.length;
  if (items.length) {
    progress.value /= progress.count;
  }
  progress.title = `${Math.round(progress.value * 100)}%`;
  LoaderService.progress = progress;
  return progress;
}));let UID$1 = 0;
const PrefetchServiceEvent = {
  Progress: 'progress',
  Complete: 'complete'
};
class PrefetchService {
  static worker() {
    if (!this.worker_) {
      this.worker_ = new Worker(environment.workers.prefetch);
    }
    return this.worker_;
  }
  static events$(assets) {
    if (!('Worker' in window)) {
      return rxjs.of({
        type: PrefetchServiceEvent.Complete,
        data: assets
      });
    }
    const worker = this.worker();
    worker.postMessage({
      id: UID$1
    });
    const id = ++UID$1;
    worker.postMessage({
      id,
      assets
    });
    return rxjs.fromEvent(worker, 'message').pipe(operators.map(event => event.data), operators.filter(event => event.assets === assets), operators.tap(event => {
    }), operators.takeWhile(event => event.type !== PrefetchServiceEvent.Complete, true), operators.finalize(() => {
      // console.log('PrefetchService.finalize', lastEvent);
      worker.postMessage({
        id
      });
    }));
  }
  static load$(assets) {
    return this.events$(assets).pipe(operators.filter(event => event.type === PrefetchServiceEvent.Complete), operators.map(event => event.data));
  }
  static prefetch(assets) {
    if (environment.flags.usePrefetch) {
      this.load$(assets).pipe(operators.first()).subscribe(event => {
        // console.log('PrefetchService.prefetch', event);
      });
    }
  }
  static cancel() {
    if (!('Worker' in window)) {
      return null;
    }
    const worker = this.worker();
    worker.postMessage({
      id: UID$1
    });
    return worker;
  }
}class Rect {
  constructor(rect) {
    this.x = 0;
    this.y = 0;
    this.top = 0;
    this.right = 0;
    this.bottom = 0;
    this.left = 0;
    this.width = 0;
    this.height = 0;
    this.set(rect);
  }
  static contains(rect, left, top) {
    return rect.top <= top && top <= rect.bottom && rect.left <= left && left <= rect.right;
  }
  static intersectRect(r1, r2) {
    return !(r2.left > r1.right || r2.right < r1.left || r2.top > r1.bottom || r2.bottom < r1.top);
  }
  static fromNode(node) {
    if (!node) {
      return;
    }
    const rect = node.rect_ || (node.rect_ = new Rect());
    const rects = node.getClientRects();
    if (!rects.length) {
      // console.log(rects, node);
      return rect;
    }
    const boundingRect = node.getBoundingClientRect();
    // rect.top: boundingRect.top + defaultView.pageYOffset,
    // rect.left: boundingRect.left + defaultView.pageXOffset,
    rect.x = boundingRect.left;
    rect.y = boundingRect.top;
    rect.top = boundingRect.top;
    rect.left = boundingRect.left;
    rect.width = boundingRect.width;
    rect.height = boundingRect.height;
    rect.right = rect.left + rect.width;
    rect.bottom = rect.top + rect.height;
    rect.setCenter();
    return rect;
  }
  set(rect) {
    if (rect) {
      Object.assign(this, rect);
      this.right = this.left + this.width;
      this.bottom = this.top + this.height;
    }
    this.setCenter();
  }
  setSize(w, h) {
    this.width = w;
    this.height = h;
    this.right = this.left + this.width;
    this.bottom = this.top + this.height;
    this.setCenter();
    // console.log(w, h);
  }

  setCenter() {
    const center = this.center || (this.center = {});
    center.top = this.top + this.height / 2;
    center.left = this.left + this.width / 2;
    center.x = center.left;
    center.y = center.top;
  }
  contains(left, top) {
    return Rect.contains(this, left, top);
  }
  intersect(rect) {
    return Rect.intersectRect(this, rect);
  }
  intersection(rect) {
    const intersection = this.intersection_ || (this.intersection_ = {
      left: 0,
      top: 0,
      width: 0,
      height: 0,
      x: 0,
      y: 0,
      pow: {
        x: -1,
        y: -1
      },
      offset: function (offset) {
        offset = offset || 0;
        const pow = (this.top - this.rect.height / 2 + offset) / -this.height;
        return pow;
      },
      scroll: function (offset) {
        offset = offset || 0;
        const pow = (this.top - this.rect.height / 2 + offset) / -this.height;
        return pow;
      }
    });
    intersection.left = this.left;
    intersection.top = this.top;
    intersection.width = this.width;
    intersection.height = this.height;
    intersection.x = this.left + this.width / 2;
    intersection.y = this.top + this.height / 2;
    intersection.rect = rect;
    const pow = intersection.offset(0);
    intersection.pow.y = pow;
    return intersection;
  }
}const W$1 = 320;
const H$1 = 240;
const COLORS$1 = [0xffcc00, 0x00ffcc, 0x00ccff, 0xccff00, 0xcc00ff, 0xffffff];
class AvatarElement {
  static get headGeometry() {
    if (!this.headGeometry_) {
      this.headGeometry_ = new THREE.SphereBufferGeometry(0.2, 36, 24);
    }
    return this.headGeometry_;
  }
  constructor(message) {
    const clientId = this.clientId = message.clientId;
    const container = this.container = message.container;
    const renderer = this.renderer = new THREE.WebGLRenderer({
      antialias: true,
      alpha: false,
      premultipliedAlpha: true
      // physicallyCorrectLights: true,
    });

    renderer.setClearColor(0x000000, 1);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(W$1, H$1);
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 0.8;
    renderer.outputEncoding = THREE.sRGBEncoding;
    container.appendChild(renderer.domElement);
    const camera = this.camera = new THREE.PerspectiveCamera(70, W$1 / H$1, 0.01, 1000);
    camera.position.set(0, 0, -0.5);
    camera.target = new THREE.Vector3();
    camera.lookAt(camera.target);
    const scene = this.scene = new THREE.Scene();

    /*
    const ambient = this.ambient = new THREE.AmbientLight(0x202020);
    scene.add(ambient);
    */

    const light = this.light = new THREE.PointLight(0xffffff, 1, 100);
    light.position.set(0, 2, -2);
    scene.add(light);
    const head = this.head = this.addHead();
    scene.add(head);
    this.remote = StreamService.getRemoteById(clientId);
    /*
    if (remote) {
    	this.subscription = AudioStreamService.volume$(remote.stream).pipe(
    		auditTime(Math.floor(1000 / 15)),
    		tap(meter => {
    			this.chalk(meter.volume);
    		})
    	);
    }
    */
  }

  addHead() {
    const geometry = AvatarElement.headGeometry;
    const canvas = this.canvas = document.createElement('canvas');
    canvas.width = 1024;
    canvas.height = 512;
    this.ctx = this.canvas.getContext('2d');
    const map = this.map = new THREE.CanvasTexture(canvas);
    map.offset.x = -0.25;
    const color = COLORS$1[this.clientId % COLORS$1.length];
    const material = new THREE.MeshStandardMaterial({
      map: map,
      color: color
    });
    this.chalk(0);
    return new THREE.Mesh(geometry, material);
  }
  render() {
    this.tick_ ? ++this.tick_ : this.tick_ = 1;
    // if (tick % 2 === 1) {
    if (this.remote) {
      const audioLevel = this.remote.getAudioLevel() * 12;
      this.chalk(audioLevel);
    }
    const renderer = this.renderer,
      scene = this.scene,
      camera = this.camera;
    renderer.render(scene, camera);
    // }
  }

  update(message) {
    const camera = message.camera;
    const head = this.head;
    head.quaternion.set(camera[3], camera[4], camera[5], camera[6]);
    /*
    head.position.set(camera[0], camera[1], camera[2]);
    */
  }

  dispose() {
    // !!! dispose threejs
    if (this.subscription) {
      this.subscription.unsubscribe();
    }
  }
  chalk(i) {
    i = (i + Math.PI * 0.5) % (Math.PI * 2);
    const vol = Math.sin(i) * 30;
    const smile = Math.cos(i) * 10;
    const x = 512;
    const y = 256;
    const ctx = this.ctx;
    ctx.fillStyle = '#888888';
    ctx.fillRect(0, 0, 1024, 512);
    ctx.fillStyle = 'white';
    ctx.beginPath();
    ctx.arc(x - 40, y - 50, 7, 0, 2 * Math.PI);
    ctx.arc(x + 40, y - 50, 7, 0, 2 * Math.PI);
    ctx.closePath();
    ctx.fill();
    ctx.beginPath();
    // ctx.quadraticCurveTo(x - 30, y + 30, x - 30, y + 30);
    // ctx.quadraticCurveTo(x - 30, y + 60, x, y + 60);
    // ctx.quadraticCurveTo(x + 30, y + 60, x + 30, y + 30);
    // ctx.quadraticCurveTo(x + 30, y, x, y);
    ctx.moveTo(x - 40 - smile, y + 30);
    ctx.bezierCurveTo(x - 40 - smile, y + 60, x + 40 + smile, y + 60, x + 40 + smile, y + 30);
    ctx.bezierCurveTo(x + 40 + smile, y + vol, x - 40 - smile, y + vol, x - 40 - smile, y + 30);
    // ctx.arc(x, 256 + 50, 50, 0, 2 * Math.PI);
    ctx.closePath();
    ctx.fill();
    this.map.needsUpdate = true;
  }
}class Texture {
  static get defaultTexture() {
    return Texture.defaultTexture_ || (Texture.defaultTexture_ = new THREE.TextureLoader().load('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyNpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDYuMC1jMDA2IDc5LjE2NDc1MywgMjAyMS8wMi8xNS0xMTo1MjoxMyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIDIyLjMgKFdpbmRvd3MpIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjcyODFGQkE0QUMxODExRUJBQkRBQTEyMzUzMjUxRjg2IiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOjcyODFGQkE1QUMxODExRUJBQkRBQTEyMzUzMjUxRjg2Ij4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6NzI4MUZCQTJBQzE4MTFFQkFCREFBMTIzNTMyNTFGODYiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6NzI4MUZCQTNBQzE4MTFFQkFCREFBMTIzNTMyNTFGODYiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz55AlN+AAAAZUlEQVR42uzQAQEAAAQDMPTvfD3YIqyT1GdTzwkQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAgAtWgAEAVbYDfaostxgAAAAASUVORK5CYII='));
  }
  static get gridTexture() {
    return Texture.gridTexture_ || (Texture.gridTexture_ = new THREE.TextureLoader().load(environment.getPath(environment.textures.grid)));
  }
}class MediaPlayMesh extends InteractiveMesh {
  static getLoader() {
    return MediaPlayMesh.loader || (MediaPlayMesh.loader = new THREE.TextureLoader());
  }
  static getTextureOff() {
    return MediaPlayMesh.textureOff || (MediaPlayMesh.textureOff = MediaPlayMesh.getLoader().load(environment.getPath('textures/ui/play-off.png')));
  }
  static getTextureOn() {
    return MediaPlayMesh.textureOn || (MediaPlayMesh.textureOn = MediaPlayMesh.getLoader().load(environment.getPath('textures/ui/play-on.png')));
  }
  static getMaterial() {
    const material = new THREE.MeshBasicMaterial({
      map: MediaPlayMesh.getTextureOff(),
      color: 0xffffff,
      opacity: 1,
      transparent: true
    });
    return material;
  }
  get playing() {
    return this.playing_;
  }
  set playing(playing) {
    if (this.playing_ !== playing) {
      this.playing_ = playing;
      const material = this.material;
      material.map = playing ? MediaPlayMesh.getTextureOn() : MediaPlayMesh.getTextureOff();
      this.onOut();
      // material.needsUpdate = true;
      // this.emit('playing', playing);
      // console.log('MediaPlayMesh.playing', playing);
    }
  }

  constructor(host) {
    const geometry = Geometry.planeGeometry;
    const material = MediaPlayMesh.getMaterial();
    super(geometry, material);
    this.playing_ = false;
    this.material = material;
    this.host = host;
    // this.color = new THREE.Color(material.color.getHex());
    this.colorOff = new THREE.Color(material.color.getHex());
    this.colorOn = new THREE.Color('#888888'); // new THREE.Color('#0099ff');
    this.addEventListener();
  }
  update(parent) {
    const scale = this.scale;
    const parentRatio = parent.scale.x / parent.scale.y;
    const size = 0.3;
    scale.set(size / parentRatio, size, 1);
    // console.log('MediaPlayMesh.setParentScale', parent.scale, scale, position);
  }

  disposeMaterial() {
    if (this.material) {
      if (this.material.map && this.material.map.disposable !== false) {
        this.material.map.dispose();
      }
      this.material.dispose();
      // this.material = null;
    }
  }

  dispose() {
    this.removeEventListener();
    this.disposeMaterial();
  }
  onOver() {
    const color = this.material.color;
    const target = this.colorOn;
    const material = this.material;
    // console.log('MediaPlayMesh.onOver');
    gsap.to(color, {
      r: target.r,
      g: target.g,
      b: target.b,
      duration: 0.2,
      ease: Power2.easeInOut
    });
    gsap.to(material, {
      opacity: 1,
      duration: 0.2,
      ease: Power2.easeInOut
    });
  }
  onOut() {
    const color = this.material.color;
    const target = this.colorOff;
    const material = this.material;
    // console.log('MediaPlayMesh.onOut');
    gsap.to(color, {
      r: target.r,
      g: target.g,
      b: target.b,
      duration: 0.2,
      ease: Power2.easeInOut
    });
    gsap.to(material, {
      opacity: this.playing ? 0 : 1,
      duration: 0.2,
      ease: Power2.easeInOut
    });
  }
  addEventListener() {
    this.onOver = this.onOver.bind(this);
    this.onOut = this.onOut.bind(this);
    this.on('over', this.onOver);
    this.on('out', this.onOut);
  }
  removeEventListener() {
    this.off('over', this.onOver);
    this.off('out', this.onOut);
  }
}class MediaZoomMesh extends InteractiveMesh {
  static getLoader() {
    return MediaZoomMesh.loader || (MediaZoomMesh.loader = new THREE.TextureLoader());
  }
  static getTextureOff() {
    return MediaZoomMesh.textureOff || (MediaZoomMesh.textureOff = MediaZoomMesh.getLoader().load(environment.getPath('textures/ui/zoom-off.png')));
  }
  static getTextureOn() {
    return MediaZoomMesh.textureOn || (MediaZoomMesh.textureOn = MediaZoomMesh.getLoader().load(environment.getPath('textures/ui/zoom-on.png')));
  }
  static getMaterial() {
    const material = new THREE.MeshBasicMaterial({
      map: MediaZoomMesh.getTextureOff(),
      color: 0xffffff,
      opacity: 1,
      transparent: true
    });
    return material;
  }
  get zoomed() {
    return this.zoomed_;
  }
  set zoomed(zoomed) {
    if (this.zoomed_ !== zoomed) {
      this.zoomed_ = zoomed;
      const material = this.material;
      material.map = zoomed ? MediaZoomMesh.getTextureOn() : MediaZoomMesh.getTextureOff();
      // material.needsUpdate = true;
      /*
      if (zoomed) {
      	// this.originalPosition = this.parent.position.clone();
      	// this.originalQuaternion = this.parent.rotation.clone();
      	// this.originalScale = this.parent.scale.clone();
      } else {
      	this.object.position.copy(this.originalPosition);
      	this.object.scale.copy(this.originalScale);
      	this.object.quaternion.copy(this.originalQuaternion);
      }
      this.updateObjectMatrix();
      */
      // console.log('MediaZoomMesh.zoomed', zoomed);
    }
  }

  constructor(host) {
    const geometry = Geometry.planeGeometry;
    const material = MediaZoomMesh.getMaterial();
    super(geometry, material);
    this.zoomed_ = false;
    this.material = material;
    this.host = host;
    // this.color = new THREE.Color(material.color.getHex());
    this.colorOff = new THREE.Color(material.color.getHex());
    this.colorOn = new THREE.Color('#888888'); // new THREE.Color('#0099ff');
    this.object = new THREE.Object3D();
    this.addEventListener();
  }
  disposeMaterial() {
    if (this.material) {
      if (this.material.map && this.material.map.disposable !== false) {
        this.material.map.dispose();
      }
      this.material.dispose();
      // this.material = null;
    }
  }

  dispose() {
    this.removeEventListener();
    this.disposeMaterial();
  }
  onOver() {
    const color = this.material.color;
    const target = this.colorOn;
    this.material;
    // console.log('MediaZoomMesh.onOver');
    gsap.to(color, {
      r: target.r,
      g: target.g,
      b: target.b,
      duration: 0.2,
      ease: Power2.easeInOut
      /*
      onUpdate: () => {
      	material.needsUpdate = true;
      },
      */
    });
    // this.innerVisible = true;
  }

  onOut() {
    const color = this.material.color;
    const target = this.colorOff;
    this.material;
    // console.log('MediaZoomMesh.onOut');
    gsap.to(color, {
      r: target.r,
      g: target.g,
      b: target.b,
      duration: 0.2,
      ease: Power2.easeInOut
      /*
      onUpdate: () => {
      	material.needsUpdate = true;
      },
      */
    });
    // this.innerVisible = false;
  }

  onToggle() {
    // console.log('MediaZoomMesh.onToggle', !this.zoomed);
    // this.zoomed = !this.zoomed;
    this.emit('zoomed', !this.zoomed);
  }
  addEventListener() {
    this.onOver = this.onOver.bind(this);
    this.onOut = this.onOut.bind(this);
    this.onToggle = this.onToggle.bind(this);
    this.on('over', this.onOver);
    this.on('out', this.onOut);
    this.on('down', this.onToggle);
  }
  removeEventListener() {
    this.off('over', this.onOver);
    this.off('out', this.onOut);
    this.off('down', this.onToggle);
  }
}const VERTEX_SHADER$1 = `
varying vec2 vUvShader;

#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {
	vUvShader = uv;

	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}
`;
const FRAGMENT_SHADER$1 = `
#define USE_MAP

varying vec2 vUvShader;

uniform vec3 diffuse;
uniform float opacity;

#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif

#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

// uniform sampler2D map;
uniform sampler2D playMap;
uniform vec2 mapResolution;
uniform vec2 playMapResolution;
uniform float mapTween;
uniform float playMapTween;
uniform vec3 playMapColor;
uniform bool isVideo;

void main() {
	#include <clipping_planes_fragment>

	vec4 diffuseColor = vec4(vec3(1.0), opacity);

	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>

	// main
	vec4 mapRgba = texture2D(map, vUvShader);
	if (isVideo) {
		vec4 playMapRgba = texture2D(playMap, vUvShader);
		diffuseColor = vec4(mapRgba.rgb + (playMapColor * playMapTween * 0.2) + (playMapRgba.rgb * mapTween * playMapRgba.a), opacity);
	} else {
		diffuseColor = vec4(mapRgba.rgb + (playMapColor * playMapTween * 0.2), opacity);
	}

	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>

	ReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));

	// accumulation (baked indirect lighting only)
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif

	// modulation
	#include <aomap_fragment>

	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;

	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}
`;
const FRAGMENT_CHROMA_KEY_SHADER = `
#define USE_MAP
#define threshold 0.55
#define padding 0.05
varying vec2 vUvShader;

uniform vec3 diffuse;
uniform float opacity;

#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif

#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

// uniform sampler2D map;
uniform sampler2D playMap;
uniform vec2 mapResolution;
uniform vec2 playMapResolution;
uniform float mapTween;
uniform float playMapTween;
uniform vec3 playMapColor;
uniform vec3 chromaKeyColor;
uniform bool isVideo;

void main() {
	#include <clipping_planes_fragment>

	vec4 diffuseColor = vec4( diffuse, opacity );

	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>

	// main
	vec4 mapRgba = texture2D(map, vUvShader);
	vec4 chromaKey = vec4(chromaKeyColor, 1.0);
    vec3 chromaKeyDiff = mapRgba.rgb - chromaKey.rgb;
    float chromaKeyValue = smoothstep(threshold - padding, threshold + padding, dot(chromaKeyDiff, chromaKeyDiff));
	/*
	if (isVideo) {
		vec4 playMapRgba = texture2D(playMap, vUvShader);
		diffuseColor = vec4(mapRgba.rgb + (playMapColor * playMapTween * 0.2) + (playMapRgba.rgb * mapTween * playMapRgba.a), opacity * chromaKeyValue);
	} else {
		diffuseColor = vec4(mapRgba.rgb + (playMapColor * playMapTween * 0.2), opacity * chromaKeyValue);
	}
	*/
	// diffuseColor = vec4(mapRgba.rgb + (playMapColor * playMapTween * 0.2), opacity * chromaKeyValue);
	diffuseColor = vec4(mapRgba.rgb, opacity * chromaKeyValue);

	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>

	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	// accumulation (baked indirect lighting only)
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	// modulation
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;

	#include <envmap_fragment>

	gl_FragColor = vec4(outgoingLight, diffuseColor.a);

	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}
`;
class MediaMesh extends InteractiveMesh {
  static getMaterial(useChromaKey) {
    const material = new THREE.ShaderMaterial({
      depthTest: true,
      // !!!
      depthWrite: true,
      transparent: true,
      toneMapped: false,
      // side: THREE.DoubleSide,
      // blending: THREE.AdditiveBlending,
      vertexShader: VERTEX_SHADER$1,
      fragmentShader: useChromaKey ? FRAGMENT_CHROMA_KEY_SHADER : FRAGMENT_SHADER$1,
      uniforms: {
        map: {
          type: 't',
          value: Texture.defaultTexture
        },
        mapResolution: {
          value: new THREE.Vector2()
        },
        mapTween: {
          value: 1
        },
        color: {
          value: new THREE.Color('#FFFFFF')
        },
        playMap: {
          type: 't',
          value: Texture.defaultTexture
        },
        playMapResolution: {
          value: new THREE.Vector2()
        },
        playMapTween: {
          value: 0
        },
        playMapColor: {
          value: new THREE.Color('#000000')
        },
        opacity: {
          value: 0
        },
        isVideo: {
          value: false
        }
      },
      extensions: {
        fragDepth: true
      }
    });
    return material;
  }
  static getChromaKeyMaterial(chromaKeyColor) {
    if (chromaKeyColor === void 0) {
      chromaKeyColor = [0.0, 1.0, 0.0];
    }
    const material = new THREE.ShaderMaterial({
      depthTest: true,
      // !!!
      depthWrite: true,
      transparent: true,
      toneMapped: false,
      // side: THREE.DoubleSide,
      // blending: THREE.AdditiveBlending,
      vertexShader: VERTEX_SHADER$1,
      fragmentShader: FRAGMENT_CHROMA_KEY_SHADER,
      uniforms: {
        map: {
          type: 't',
          value: null
        },
        // Texture.defaultTexture
        mapResolution: {
          value: new THREE.Vector2()
        },
        mapTween: {
          value: 1
        },
        color: {
          value: new THREE.Color('#FFFFFF')
        },
        chromaKeyColor: {
          value: new THREE.Color(chromaKeyColor[0], chromaKeyColor[1], chromaKeyColor[2])
        },
        playMap: {
          type: 't',
          value: Texture.defaultTexture
        },
        playMapResolution: {
          value: new THREE.Vector2()
        },
        playMapTween: {
          value: 0
        },
        playMapColor: {
          value: new THREE.Color('#000000')
        },
        opacity: {
          value: 0
        },
        isVideo: {
          value: false
        }
      },
      extensions: {
        fragDepth: true
      }
    });
    material.map = true;
    return material;
  }
  static isPublisherStream(stream) {
    return stream.clientInfo && stream.clientInfo.role === RoleType.Publisher && stream.clientInfo.uid === stream.streamId;
  }
  static isAttendeeStream(stream) {
    return stream.clientInfo && stream.clientInfo.role === RoleType.Attendee && stream.clientInfo.uid === stream.streamId;
  }
  static isSmartDeviceStream(stream) {
    return stream.clientInfo && stream.clientInfo.role === RoleType.SmartDevice && stream.clientInfo.uid === stream.streamId;
  }
  static isPublisherScreen(stream) {
    // console.log(stream.clientInfo, stream.clientInfo ? [stream.clientInfo.role, stream.clientInfo.screenUid, stream.streamId] : null);
    return stream.clientInfo && stream.clientInfo.role === RoleType.Publisher && stream.clientInfo.screenUid === stream.streamId;
  }
  static isAttendeeScreen(stream) {
    return stream.clientInfo && stream.clientInfo.role === RoleType.Attendee && stream.clientInfo.screenUid === stream.streamId;
  }
  static getTypeMatcher(assetType) {
    let matcher;
    switch (assetType.name) {
      case AssetType.PublisherStream.name:
        matcher = this.isPublisherStream;
        break;
      case AssetType.AttendeeStream.name:
        matcher = this.isAttendeeStream;
        break;
      case AssetType.SmartDeviceStream.name:
        matcher = this.isSmartDeviceStream;
        break;
      case AssetType.PublisherScreen.name:
        matcher = this.isPublisherScreen;
        break;
      case AssetType.AttendeeScreen.name:
        matcher = this.isAttendeeScreen;
        break;
      default:
        matcher = stream => {
          return false;
        };
    }
    return matcher;
  }
  static getStreamId$(item) {
    if (!item.asset) {
      return rxjs.of(null);
    }
    const assetType = item.asset.type;
    const file = item.asset.file;
    // console.log(item.asset, assetIsStream(item.asset));
    if (assetIsStream(item.asset)) {
      // console.log('MediaMesh.getStreamId$', item.asset.type.name);
      return StreamService.streams$.pipe(operators.map(streams => {
        let stream;
        let i = 0;
        const matchType = this.getTypeMatcher(assetType);
        streams.forEach(x => {
          // console.log('MediaMesh.getStreamId$', x.clientInfo, x.clientInfo ? [x.clientInfo.screenUid, x.streamId] : null);
          if (matchType(x)) {
            if (i === item.asset.index) {
              stream = x;
            }
            i++;
          }
        });
        if (stream) {
          // console.log('MediaMesh.getStreamId$', assetType.name, stream.clientInfo.role, stream.streamId);
          return stream.streamId;
        } else {
          // console.log('MediaMesh.getStreamId$.notfound', assetType.name);
          return null;
        }
      }));
    } else {
      return rxjs.of(file);
    }
  }
  static getMaterialByItem(item) {
    let material;
    if (item.asset && item.asset.chromaKeyColor) {
      material = MediaMesh.getChromaKeyMaterial(item.asset.chromaKeyColor);
    } else if (item.asset) {
      // material = new THREE.MeshBasicMaterial({ color: 0x888888 });
      // material = new THREE.MeshBasicMaterial({ color: 0xffffff, toneMapped: false });
      material = new THREE.MeshBasicMaterial({
        color: 0xffffff,
        toneMapped: false
      });
      // material = new THREE.MeshPhysicalMaterial({ clearcoat: 1, clearcoatRoughness: 0, toneMapped: false, encoding: THREE.sRGBEncoding });
    } else {
      material = new THREE.MeshBasicMaterial({
        color: 0xffffff,
        toneMapped: false
      });
    }
    return material;
  }
  static getUniformsByItem(item) {
    let uniforms = null;
    if (item.asset) {
      uniforms = {
        mapTween: 1,
        playMapTween: 0,
        opacity: 0
      };
    }
    return uniforms;
  }
  get editing() {
    return this.editing_;
  }
  set editing(editing) {
    if (this.editing_ !== editing) {
      this.editing_ = editing;
      // this.zoomed = editing ? false : (this.view.type.name === 'media' ? true : this.zoomed);
      this.zoomed = this.view.type.name === 'media' ? true : editing ? false : this.zoomed;
    }
  }
  constructor(item, view, geometry, host) {
    const material = MediaMesh.getMaterialByItem(item);
    super(geometry, material);
    // this.renderOrder = environment.renderOrder.plane;
    this.zoomed_ = false;
    this.item = item;
    this.view = view;
    this.items = view.items;
    this.host = host;
    this.uniforms = MediaMesh.getUniformsByItem(item);
    this.object = new THREE.Object3D();
    this.tempPosition = new THREE.Vector3();
    this.tempRotation = new THREE.Vector3();
    item.silent = this.isAutoplayLoop; // !!!
    this.mediaLoader = new MediaLoader(item);
    this.onOver = this.onOver.bind(this);
    this.onOut = this.onOut.bind(this);
    this.onToggle = this.onToggle.bind(this);
    this.onZoomed = this.onZoomed.bind(this);
    this.addPlayBtn();
    this.addZoomBtn();
    this.userData.render = (time, tick) => {
      this.render(this, time, tick);
    };
  }
  load(callback) {
    if (this.playBtn) {
      this.remove(this.playBtn);
    }
    if (this.zoomBtn) {
      this.remove(this.zoomBtn);
    }
    if (!this.item.asset) {
      this.onAppear();
      if (typeof callback === 'function') {
        callback(this);
      }
      return;
    }
    const material = this.material;
    const mediaLoader = this.mediaLoader;
    const onMediaLoaderLoaded = texture => {
      // console.log('MediaMesh.texture', texture);
      const loader = this.mediaLoader;
      if (!loader) {
        return;
      }
      if (texture) {
        // texture.encoding = THREE.sRGBEncoding;
        material.map = texture; // !!! Enables USE_MAP
        if (material.uniforms) {
          material.uniforms.map.value = texture;
          // material.uniforms.mapResolution.value.x = texture.image.width;
          // material.uniforms.mapResolution.value.y = texture.image.height;
          material.uniforms.mapResolution.value = new THREE.Vector2(texture.image.width || texture.image.videoWidth, texture.image.height || texture.image.videoHeight);
          if (loader.isPlayableVideo) {
            this.makePlayMap(texture, playMap => {
              // console.log('MediaMesh.playMap', playMap);
              playMap.minFilter = THREE.LinearFilter;
              playMap.magFilter = THREE.LinearFilter;
              playMap.mapping = THREE.UVMapping;
              // playMap.format = THREE.RGBAFormat;
              playMap.wrapS = THREE.RepeatWrapping;
              playMap.wrapT = THREE.RepeatWrapping;
              material.uniforms.playMap.value = playMap;
              // material.uniforms.playMapResolution.value.x = playMap.image.width;
              // material.uniforms.playMapResolution.value.y = playMap.image.height;
              material.uniforms.playMapResolution.value = new THREE.Vector2(playMap.image.width, playMap.image.height);
              // console.log(material.uniforms.playMapResolution.value, playMap);
              material.needsUpdate = true;
            });
          }
        }
      }
      material.needsUpdate = true;
      this.onAppear();
      if (loader.isPlayableVideo && this.playBtn) {
        if (material.uniforms) {
          material.uniforms.isVideo.value = true;
        }
        this.on('over', this.onOver);
        this.on('out', this.onOut);
        this.on('down', this.onToggle);
        this.add(this.playBtn);
      }
      if (this.zoomBtn) {
        this.add(this.zoomBtn);
      }
      if (typeof callback === 'function') {
        callback(this);
      }
    };
    /*
    setTimeout(() => {
    	mediaLoader.load(onMediaLoaderLoaded);
    }, 5000);
    */
    mediaLoader.load(onMediaLoaderLoaded);
  }
  makePlayMap(texture, callback) {
    const aw = texture.image.width || texture.image.videoWidth;
    const ah = texture.image.height || texture.image.videoHeight;
    const ar = aw / ah;
    const scale = 0.32;
    const canvas = document.createElement('canvas');
    // document.querySelector('body').appendChild(canvas);
    canvas.width = aw;
    canvas.height = ah;
    const ctx = canvas.getContext('2d');
    ctx.imageSmoothingEnabled = true;
    ctx.imageSmoothingQuality = 'high';
    const image = new Image();
    image.onload = function () {
      const bw = image.width;
      const bh = image.height;
      const br = bw / bh;
      let w;
      let h;
      if (ar > br) {
        w = ah * scale;
        h = w / br;
      } else {
        h = aw * scale;
        w = h * br;
      }
      ctx.drawImage(image, aw / 2 - w / 2, ah / 2 - h / 2, w, h);
      const playMap = new THREE.CanvasTexture(canvas);
      if (typeof callback === 'function') {
        callback(playMap);
      }
    };
    image.crossOrigin = 'anonymous';
    image.src = environment.getPath('textures/ui/play.png');
  }
  events$() {
    const item = this.item;
    const items = this.items;
    if (item.asset && item.asset.linkedPlayId) {
      this.freeze();
    }
    return MediaLoader.events$.pipe(operators.filter(event => event.loader.item && event.loader.item.id === item.id), operators.map(event => {
      if (event instanceof MediaLoaderPlayEvent) {
        this.playing = true;
        if (!this.isAutoplayLoop) {
          if (this.playBtn) {
            this.playBtn.playing = true;
          }
          this.emit('playing', true);
        }
        this.onOut();
      } else if (event instanceof MediaLoaderPauseEvent) {
        this.playing = false;
        if (this.playBtn) {
          this.playBtn.playing = false;
        }
        this.emit('playing', false);
        this.onOut();
      } else if (event instanceof MediaLoaderTimeSetEvent) {
        this.emit('currentTime', event.loader.video.currentTime);
      }
      // console.log('MediaMesh', this.playing);
      if (item.asset && item.asset.linkedPlayId) {
        const eventItem = items.find(x => x.asset && event.src.indexOf(x.asset.file) !== -1 && event.id === item.asset.linkedPlayId);
        if (eventItem) {
          // console.log('MediaLoader.events$.eventItem', event, eventItem);
          if (event instanceof MediaLoaderPlayEvent) {
            this.play();
          } else if (event instanceof MediaLoaderPauseEvent) {
            this.pause();
          }
        }
      }
      return event;
    }));
  }
  onAppear() {
    const uniforms = this.uniforms;
    const material = this.material;
    if (material.uniforms) {
      gsap.to(uniforms, {
        duration: 0.4,
        opacity: 1,
        ease: Power2.easeInOut,
        onUpdate: () => {
          material.uniforms.opacity.value = uniforms.opacity;
          // material.needsUpdate = true;
        }
      });
    }

    this.zoomed = this.view.type.name === 'media' ? true : this.editing ? false : this.zoomed;
  }
  onDisappear() {
    const uniforms = this.uniforms;
    const material = this.material;
    if (material.uniforms) {
      gsap.to(uniforms, {
        duration: 0.4,
        opacity: 0,
        ease: Power2.easeInOut,
        onUpdate: () => {
          material.uniforms.opacity.value = uniforms.opacity;
          // material.needsUpdate = true;
        }
      });
    }
  }

  onOver() {
    const uniforms = this.uniforms;
    const material = this.material;
    if (material.uniforms) {
      gsap.to(uniforms, {
        duration: 0.4,
        mapTween: this.playing ? 0 : 1,
        playMapTween: 1,
        opacity: 1,
        ease: Power2.easeInOut,
        overwrite: true,
        onUpdate: () => {
          material.uniforms.mapTween.value = uniforms.mapTween;
          material.uniforms.playMapTween.value = uniforms.playMapTween;
          material.uniforms.opacity.value = uniforms.opacity;
          // material.needsUpdate = true;
        }
      });
    }

    if (this.playBtn) {
      this.playBtn.onOver();
    }
  }
  onOut() {
    const uniforms = this.uniforms;
    const material = this.material;
    if (material.uniforms) {
      gsap.to(uniforms, {
        duration: 0.4,
        mapTween: this.playing ? 0 : 1,
        playMapTween: 0,
        opacity: 1,
        ease: Power2.easeInOut,
        overwrite: true,
        onUpdate: () => {
          material.uniforms.mapTween.value = uniforms.mapTween;
          material.uniforms.playMapTween.value = uniforms.playMapTween;
          material.uniforms.opacity.value = uniforms.opacity;
          // material.needsUpdate = true;
        }
      });
    }

    if (this.playBtn) {
      this.playBtn.onOut();
    }
  }
  onToggle() {
    this.playing = this.mediaLoader.toggle();
    if (this.playBtn) {
      this.playBtn.playing = this.playing;
    }
    this.emit('playing', this.playing);
    this.onOut();
  }
  play() {
    this.mediaLoader.play();
  }
  pause() {
    this.mediaLoader.pause();
  }
  setPlayingState(playing) {
    if (this.playing !== playing) {
      this.playing = playing;
      playing ? this.mediaLoader.play() : this.mediaLoader.pause();
      this.onOut();
      if (this.playBtn) {
        this.playBtn.playing = playing;
      }
    }
  }
  setZoomedState(zoomed) {
    this.zoomed = zoomed;
  }
  setCurrentTime(currentTime) {
    // !!!
    if (this.mediaLoader.video) {
      this.mediaLoader.video.currentTime = currentTime;
    }
  }
  disposeMaterial() {
    if (this.material) {
      if (this.material.map && this.material.map.disposable !== false) {
        this.material.map.dispose();
      }
      this.material.dispose();
      // this.material = null;
    }
  }

  disposeMediaLoader() {
    const mediaLoader = this.mediaLoader;
    if (mediaLoader) {
      if (mediaLoader.isPlayableVideo) {
        this.off('over', this.onOver);
        this.off('out', this.onOut);
        this.off('down', this.onToggle);
      }
      mediaLoader.dispose();
      this.mediaLoader = null;
    }
  }
  dispose() {
    // console.log('MediaMesh.dispose');
    this.removePlayBtn();
    this.removeZoomBtn();
    this.disposeMediaLoader();
  }
  get isAutoplayLoop() {
    const isAutoplayLoop = this.view.type.name !== 'media' && this.item.asset && this.item.asset.autoplay && this.item.asset.loop;
    // console.log('MediaMesh', isAutoplayLoop);
    return isAutoplayLoop;
  }
  addPlayBtn() {
    this.removePlayBtn();
    if (!this.isAutoplayLoop) {
      const playBtn = this.playBtn = new MediaPlayMesh(this.host);
      playBtn.on('over', this.onOver);
      playBtn.on('out', this.onOut);
      playBtn.on('down', this.onToggle);
      playBtn.position.z = 0.01;
    }
  }
  removePlayBtn() {
    if (this.playBtn) {
      this.remove(this.playBtn);
      this.playBtn.off('over', this.onOver);
      this.playBtn.off('out', this.onOut);
      this.playBtn.off('down', this.onToggle);
      this.playBtn.dispose();
      delete this.playBtn;
    }
  }
  onZoomed(zoomed) {
    this.zoomed = zoomed;
    this.emit('zoomed', zoomed);
  }
  addZoomBtn() {
    this.removeZoomBtn();
    if (this.view.type.name !== 'media' && (!this.item.asset || !this.item.asset.chromaKeyColor)) {
      const zoomBtn = this.zoomBtn = new MediaZoomMesh(this.host);
      zoomBtn.on('zoomed', this.onZoomed);
    }
  }
  removeZoomBtn() {
    if (this.zoomBtn) {
      this.remove(this.zoomBtn);
      this.zoomBtn.off('zoomed', this.onZoomed);
      this.zoomBtn.dispose();
      this.zoomBtn = null;
      delete this.zoomBtn;
    }
  }
  updateByItem(item) {
    this.disposeMaterial();
    this.disposeMediaLoader();
    this.material = MediaMesh.getMaterialByItem(item);
    this.uniforms = MediaMesh.getUniformsByItem(item);
    this.addPlayBtn();
    this.addZoomBtn();
    item.silent = this.isAutoplayLoop; // !!!
    this.mediaLoader = new MediaLoader(item);
  }
  updateFromItem(item) {
    // console.log('MediaMesh.updateFromItem', item);
    if (item.position) {
      this.position.fromArray(item.position);
    }
    if (item.rotation) {
      this.rotation.fromArray(item.rotation);
    }
    if (item.scale) {
      this.scale.fromArray(item.scale);
    }
    if (this.playBtn) {
      this.playBtn.update(this);
    }
    /*
    if (this.zoomBtn) {
    	this.zoomBtn.update(this);
    }
    */
    this.updateZoom();
  }
  updateZoom() {
    this.originalPosition = this.position.clone();
    this.originalScale = this.scale.clone();
    this.originalQuaternion = this.quaternion.clone();
    this.object.position.copy(this.originalPosition);
    this.object.scale.copy(this.originalScale);
    this.object.quaternion.copy(this.originalQuaternion);
    if (this.zoomBtn) {
      const scale = this.zoomBtn.scale;
      const position = this.zoomBtn.position;
      const ratio = this.scale.x / this.scale.y;
      const size = 0.1;
      scale.set(size / ratio, size, 1);
      position.x = 0.5 - size / ratio / 2;
      position.y = size / 2 - 0.5;
      position.z = 0.01;
    }
    // console.log('MediaMesh.updateZoom', this.scale);
  }

  // zoom

  render(time, tick) {
    /*
    if (this.zoomBtn && !this.editing) {
    	this.zoomBtn.render(time, tick);
    }
    */
    if (!this.editing) {
      const object = this.object;
      /*
      parent.position.lerp(object.position, 0.2);
      parent.scale.lerp(object.scale, 0.2);
      parent.quaternion.slerp(object.quaternion, 0.2);
      */
      if (this.zoomed && !this.host.renderer.xr.isPresenting) {
        this.updateObjectMatrix();
      }
      this.position.copy(object.position);
      this.scale.copy(object.scale);
      this.quaternion.copy(object.quaternion);
    }
  }
  updateObjectMatrix() {
    const object = this.object;
    const host = this.host;
    if (this.zoomed) {
      // const cameraGroup = host.cameraGroup;
      const originalScale = this.originalScale;
      let camera = host.camera,
        fov = camera.fov,
        aspect = camera.aspect,
        scale;
      const position = this.tempPosition;
      const rotation = this.tempRotation;
      // const aspect = originalScale.x / originalScale.y;
      scale = 0.01; // 0.01;
      const xr = host.renderer.xr;
      if (xr.isPresenting) {
        camera = xr.getCamera(camera);
        const mat = camera.projectionMatrix.elements;
        const a = mat[0];
        const b = mat[5];
        // const c = mat[10];
        // const d = mat[14];
        aspect = b / a;
        // const k = (c - 1) / (c + 1);
        // const clip_min = (d * (1 - k)) / (2 * k);
        // const clip_max = k * clip_min;
        // const RAD2DEG = 180 / 3.14159265358979323846;
        const RAD2DEG = 180 / 3.141592653589793;
        fov = RAD2DEG * (2 * Math.atan(1 / b));
        scale = 1;
      }
      object.scale.copy(originalScale).multiplyScalar(scale);
      const distance = Host.getDistanceToCamera(camera, fov, aspect, object.scale);
      camera.getWorldDirection(rotation);
      rotation.multiplyScalar(distance);
      position.set(0, 0, 0);
      camera.localToWorld(position);
      position.add(rotation);
      object.position.copy(position);
      object.lookAt(Host.origin);
      if (xr.isPresenting) {
        object.position.y -= object.scale.y / 2;
      }
    }
  }
  get zoomed() {
    return this.zoomed_;
  }
  set zoomed(zoomed) {
    if (this.zoomed_ !== zoomed) {
      this.zoomed_ = zoomed;
      if (zoomed) {
        this.renderOrder = environment.renderOrder.panel + 5;
        this.material.depthTest = true; // !!! false
        // this.originalPosition = this.position.clone();
        // this.originalQuaternion = this.rotation.clone();
        // this.originalScale = this.scale.clone();
      } else {
        this.renderOrder = 0;
        this.material.depthTest = true;
        this.object.position.copy(this.originalPosition);
        this.object.scale.copy(this.originalScale);
        this.object.quaternion.copy(this.originalQuaternion);
      }
      this.material.needsUpdate = true;
      this.updateObjectMatrix();
      if (this.zoomBtn) {
        this.zoomBtn.zoomed = zoomed;
      }
    }
  }
}class DragPoint {
  constructor() {
    this.x = 0;
    this.y = 0;
  }
}
class DragEvent {
  constructor(options) {
    if (options) {
      Object.assign(this, options);
    }
  }
}
class DragDownEvent extends DragEvent {
  constructor(options) {
    super(options);
    this.distance = new DragPoint();
    this.strength = new DragPoint();
    this.speed = new DragPoint();
  }
}
class DragMoveEvent extends DragEvent {
  constructor(options) {
    super(options);
    this.distance = new DragPoint();
    this.strength = new DragPoint();
    this.speed = new DragPoint();
  }
}
class DragUpEvent extends DragEvent {
  constructor(options) {
    super(options);
  }
}
let upEvent;
class DragService {
  static getPosition(event, point) {
    if (event instanceof MouseEvent) {
      point ? (point.x = event.clientX, point.y = event.clientY) : point = {
        x: event.clientX,
        y: event.clientY
      };
    } else if (window.TouchEvent && event instanceof TouchEvent) {
      if (event.touches.length > 0) {
        point ? (point.x = event.touches[0].pageX, point.y = event.touches[0].pageY) : point = {
          x: event.touches[0].pageX,
          y: event.touches[0].pageY
        };
      }
    }
    return point;
  }
  static down$(target, events$) {
    let downEvent;
    return rxjs.merge(rxjs.fromEvent(target, 'mousedown').pipe(operators.filter(event => event.button === 0)), rxjs.fromEvent(target, 'touchstart')).pipe(operators.map(event => {
      downEvent = downEvent || new DragDownEvent();
      downEvent.node = target;
      downEvent.target = event.target;
      downEvent.originalEvent = event;
      downEvent.down = this.getPosition(event, downEvent.down);
      if (downEvent.down) {
        downEvent.distance = new DragPoint();
        downEvent.strength = new DragPoint();
        downEvent.speed = new DragPoint();
        events$.next(downEvent);
        return downEvent;
      }
    }), operators.filter(event => event !== undefined));
  }
  static move$(target, events$, dismiss$, downEvent) {
    let moveEvent;
    return rxjs.fromEvent(document, downEvent.originalEvent instanceof MouseEvent ? 'mousemove' : 'touchmove').pipe(operators.startWith(downEvent), operators.map(event => {
      moveEvent = moveEvent || new DragMoveEvent();
      moveEvent.node = target;
      moveEvent.target = event.target;
      moveEvent.originalEvent = event;
      moveEvent.position = this.getPosition(event, moveEvent.position);
      const dragging = downEvent.down !== undefined && moveEvent.position !== undefined;
      if (dragging) {
        moveEvent.distance.x = moveEvent.position.x - downEvent.down.x;
        moveEvent.distance.y = moveEvent.position.y - downEvent.down.y;
        moveEvent.strength.x = moveEvent.distance.x / window.innerWidth * 2;
        moveEvent.strength.y = moveEvent.distance.y / window.innerHeight * 2;
        moveEvent.speed.x = downEvent.speed.x + (moveEvent.strength.x - downEvent.strength.x) * 0.1;
        moveEvent.speed.y = downEvent.speed.y + (moveEvent.strength.y - downEvent.strength.y) * 0.1;
        downEvent.distance.x = moveEvent.distance.x;
        downEvent.distance.y = moveEvent.distance.y;
        downEvent.speed.x = moveEvent.speed.x;
        downEvent.speed.y = moveEvent.speed.y;
        downEvent.strength.x = moveEvent.strength.x;
        downEvent.strength.y = moveEvent.strength.y;
        events$.next(moveEvent);
        return moveEvent;
      }
    }));
  }
  static dismissEvent(event, events$, dismiss$, downEvent) {
    // console.log('DragService.dismissEvent', event);
    upEvent = upEvent || new DragUpEvent();
    events$.next(upEvent);
    dismiss$.next();
    // console.log(downEvent.distance);
    if (downEvent && Math.abs(downEvent.distance.x) > 10) {
      event.preventDefault();
      event.stopImmediatePropagation();
    }
    return upEvent;
  }
  static up$(target, events$, dismiss$, downEvent) {
    return rxjs.fromEvent(document, downEvent.originalEvent instanceof MouseEvent ? 'mouseup' : 'touchend').pipe(operators.map(event => this.dismissEvent(event, events$, dismiss$, downEvent)));
  }
  static observe$(target) {
    target = target || document;
    const events$ = DragService.events$;
    const dismiss$ = DragService.dismiss$;
    return this.down$(target, events$).pipe(operators.switchMap(downEvent => {
      DragService.downEvent = downEvent;
      return rxjs.merge(this.move$(target, events$, dismiss$, downEvent), this.up$(target, events$, dismiss$, downEvent)).pipe(operators.takeUntil(dismiss$));
    }), operators.switchMap(() => events$));
  }
}
DragService.events$ = new rxjs.ReplaySubject(1);
DragService.dismiss$ = new rxjs.Subject();// https://github.com/google/model-viewer/blob/master/packages/model-viewer/src/three-components/SmoothControls.ts

const OrbitMode = {
  Panorama: 'panorama',
  PanoramaGrid: 'panorama-grid',
  Model: 'model'
};
class OrbitEvent {}
class OrbitDragEvent extends OrbitEvent {}
class OrbitResizeEvent extends OrbitEvent {}
class OrbitMoveEvent extends OrbitEvent {}
const orbitMoveEvent = new OrbitMoveEvent();
const orbitDragEvent = new OrbitDragEvent();
const orbitResizeEvent = new OrbitResizeEvent();
const DOLLY_MIN = 1; // 15;
const DOLLY_MAX = 75; // 115
const ZOOM_MIN = 1; // 15;
const ZOOM_MAX = 75;
class OrbitService {
  get dolly() {
    return this.dolly_;
  }
  set dolly(dolly) {
    const clampedDolly = THREE.Math.clamp(dolly, DOLLY_MIN, DOLLY_MAX);
    if (this.dolly_ !== clampedDolly) {
      this.dolly_ = clampedDolly;
      this.markAsDirty();
    }
  }
  getDollyValue() {
    return 1 - (this.dolly_ - DOLLY_MIN) / (DOLLY_MAX - DOLLY_MIN) - 0.5;
  }
  get zoom() {
    return this.zoom_;
  }
  set zoom(zoom) {
    const clampedDolly = THREE.Math.clamp(zoom, DOLLY_MIN, DOLLY_MAX);
    if (this.zoom_ !== clampedDolly) {
      this.zoom_ = clampedDolly;
      this.markAsDirty();
    }
  }
  getZoomValue() {
    return 1 + 1 - (this.zoom_ - ZOOM_MIN) / (ZOOM_MAX - ZOOM_MIN);
  }
  get mode() {
    return this.mode_;
  }
  set mode(mode) {
    if (this.mode_ !== mode) {
      this.mode_ = mode;
      OrbitService.mode = mode;
      this.markAsDirty();
    }
  }
  get controlled() {
    return StateService.state.controlling && StateService.state.controlling !== StateService.state.uid;
  }
  get controlling() {
    return StateService.state.controlling && StateService.state.controlling === StateService.state.uid;
  }
  get silencing() {
    return StateService.state.silencing;
  }
  get silenced() {
    return StateService.state.silencing && StateService.state.role === RoleType.Streamer;
  }
  get spyed() {
    return StateService.state.spying && StateService.state.spying === StateService.state.uid;
  }
  get spying() {
    return StateService.state.spying && StateService.state.spying !== StateService.state.uid;
  }
  get isMediaView() {
    const currentView = ViewService.currentView;
    return currentView && currentView.type.name === ViewType.Media.name;
  }
  get locked() {
    return this.controlled || this.spying || this.isMediaView;
  }
  constructor(camera) {
    this.mode_ = OrbitService.mode = OrbitMode.Panorama;
    this.dolly_ = 70;
    this.zoom_ = 70;
    this.longitude = 0;
    this.latitude = 0;
    this.direction = 1;
    this.radius = 101;
    this.position = new THREE.Vector3();
    // this.speed = 1;
    this.inertia = new THREE.Vector2();
    this.rotation = new THREE.Euler(0, 0, 0, 'XYZ');
    this.target = new THREE.Vector3();
    this.updatePosition = new THREE.Vector3();
    this.updateTarget = new THREE.Vector3();
    this.camera = camera;
    this.setLongitudeLatitude(0, 0);
    this.events$ = new rxjs.ReplaySubject(1);
  }
  setOrientation(orientation) {
    if (orientation) {
      this.setLongitudeLatitude(orientation.longitude, orientation.latitude);
      this.markAsDirty();
    }
  }
  getOrientation() {
    return {
      latitude: this.latitude,
      longitude: this.longitude
    };
  }
  setLongitudeLatitude(longitude, latitude) {
    latitude = Math.max(-80, Math.min(80, latitude));
    this.longitude = (longitude < 0 ? 360 + longitude : longitude) % 360;
    this.latitude = latitude;
    // console.log(this.longitude);
    const phi = THREE.Math.degToRad(90 - latitude);
    const theta = THREE.Math.degToRad(longitude);
    this.phi = phi;
    this.theta = theta;
  }
  observe$(node) {
    // const camera = this.camera;
    let latitude, longitude;
    return rxjs.combineLatest([KeyboardService.keys$(), DragService.observe$(node)]).pipe(operators.filter(event => !this.locked), operators.map(datas => {
      const keys = datas[0];
      const event = datas[1];
      // const group = this.objects.children[this.index];
      if (event instanceof DragDownEvent) {
        latitude = this.latitude;
        longitude = this.longitude;
      } else if (event instanceof DragMoveEvent) {
        if (keys.Shift) {
          this.events$.next(orbitDragEvent);
        } else if (keys.Control) {
          this.events$.next(orbitResizeEvent);
        } else {
          const flip = this.mode_ === OrbitMode.Model ? -1 : 1;
          this.setLongitudeLatitude(longitude - event.distance.x * 0.1 * flip, latitude + event.distance.y * 0.1);
        }
      } /* else if (event instanceof DragUpEvent) {
        }
        */
      return event;
    }), operators.filter(event => event instanceof DragMoveEvent), operators.startWith({
      latitude: this.latitude,
      longitude: this.longitude
    }), operators.tap(event => this.markAsDirty()), operators.switchMap(event => this.events$));
  }
  walk(position, callback) {
    let radius;
    switch (this.mode_) {
      case OrbitMode.Model:
        radius = 3;
        break;
      default:
        radius = this.radius;
    }
    const heading = new THREE.Vector2(position.x, position.y).normalize().multiplyScalar(radius);
    const headingTheta = Math.atan2(heading.y, heading.x);
    let headingLongitude = THREE.MathUtils.radToDeg(headingTheta);
    headingLongitude = (headingLongitude < 0 ? 360 + headingLongitude : headingLongitude) % 360;
    const headingLatitude = 0;
    const latitude = this.latitude;
    const longitude = this.longitude;
    let differenceLongitude = headingLongitude - longitude;
    differenceLongitude = Math.abs(differenceLongitude) > 180 ? differenceLongitude - 360 * (differenceLongitude / Math.abs(differenceLongitude)) : differenceLongitude;
    let differenceLatitude = headingLatitude - latitude;
    differenceLatitude = Math.abs(differenceLatitude) > 90 ? differenceLatitude - 90 * (differenceLatitude / Math.abs(differenceLatitude)) : differenceLatitude;
    // console.log('headingTheta', headingTheta, 'headingLongitude', headingLongitude, 'differenceLongitude', differenceLongitude);
    const from = {
      tween: 0
    };
    gsap.to(from, {
      duration: 0.7,
      tween: 1,
      delay: 0,
      ease: Power2.easeInOut,
      onUpdate: () => {
        this.setLongitudeLatitude(longitude + differenceLongitude * from.tween, latitude + differenceLatitude * from.tween);
        this.position.set(position.x * from.tween, 0, position.y * from.tween);
        this.markAsDirty();
      },
      onComplete: () => {
        // this.walkComplete(headingLongitude, headingLatitude);
        if (typeof callback === 'function') {
          callback(headingLongitude, headingLatitude);
        }
      }
    });
  }
  walkComplete(headingLongitude, headingLatitude) {
    this.setLongitudeLatitude(headingLongitude, headingLatitude);
    this.position.set(0, 0, 0);
    this.markAsDirty();
  }
  lookAt(object) {
    // console.log('OrbitService.lookAt', object);
    if (object) {
      let position = object.position.clone();
      const camera = this.camera;
      const cameraGroup = camera.parent;
      position = cameraGroup.worldToLocal(position);
      let radius;
      switch (this.mode_) {
        case OrbitMode.Model:
          radius = 3;
          break;
        default:
          radius = this.radius;
      }
      const heading = new THREE.Vector3(position.x, position.z, position.y).normalize().multiplyScalar(radius);
      const theta = Math.atan2(heading.y, heading.x);
      const phi = Math.acos(heading.z / radius);
      let longitude = THREE.MathUtils.radToDeg(theta);
      longitude = (longitude < 0 ? 360 + longitude : longitude) % 360;
      let latitude = 90 - THREE.MathUtils.radToDeg(phi);
      latitude = Math.max(-80, Math.min(80, latitude));
      this.setLongitudeLatitude(longitude, latitude);
      this.markAsDirty();
    }
  }
  setVRCamera(camera) {
    if (camera) {
      const radius = this.radius;
      const position = new THREE.Vector3(0, 0, -radius);
      const quaternion = new THREE.Quaternion(camera[3], camera[4], camera[5], camera[6]);
      position.applyQuaternion(quaternion);
      const heading = new THREE.Vector3(position.x, position.z, position.y).normalize().multiplyScalar(radius);
      const theta = Math.atan2(heading.y, heading.x);
      const phi = Math.acos(heading.z / radius);
      let longitude = THREE.MathUtils.radToDeg(theta);
      longitude = (longitude < 0 ? 360 + longitude : longitude) % 360;
      let latitude = 90 - THREE.MathUtils.radToDeg(phi);
      latitude = Math.max(-80, Math.min(80, latitude));
      this.setLongitudeLatitude(longitude, latitude);
      this.markAsDirty();
    }
  }
  render() {
    // slowly rotate scene when not hosted
    if (!StateService.state.hosted) {
      this.longitude += 0.025;
      this.isDirty = true;
    }
    if (this.isDirty) {
      this.isDirty = false;
      this.update();
    }
  }
  markAsDirty() {
    this.isDirty = true;
  }
  update() {
    let radius,
      position = this.updatePosition,
      target = this.updateTarget;
    const zoom = this.getZoomValue();
    this.getDollyValue();
    // console.log('dolly', dolly);
    const phi = THREE.MathUtils.degToRad(90 - this.latitude);
    const theta = THREE.MathUtils.degToRad(this.longitude);
    const camera = this.camera;
    const cameraGroup = camera.parent;
    switch (this.mode_) {
      case OrbitMode.Model:
        radius = 3;
        position.copy(this.position);
        target.x = this.position.x + radius * Math.sin(phi) * Math.cos(theta);
        target.y = this.position.y + radius * Math.cos(phi);
        target.z = this.position.z + radius * Math.sin(phi) * Math.sin(theta);
        // position = cameraGroup.worldToLocal(position);
        target = cameraGroup.worldToLocal(target);
        camera.target.copy(position);
        camera.position.copy(target);
        break;
      default:
        radius = this.radius;
        target.x = this.position.x + radius * Math.sin(phi) * Math.cos(theta);
        target.y = this.position.y + radius * Math.cos(phi);
        target.z = this.position.z + radius * Math.sin(phi) * Math.sin(theta);
        {
          position.copy(this.position);
        }
        // !!! position for walking panorama-grid
        // position = cameraGroup.worldToLocal(position);
        target = cameraGroup.worldToLocal(target);
        // camera.position.copy(position);
        camera.target.copy(target);
        camera.position.copy(position);
    }
    // console.log(camera.position.x, camera.position.y, camera.position.z);
    // console.log(camera.target.x, camera.target.y, camera.target.z);
    // console.log('phi', phi, 'theta', theta);
    // this.inverse();
    {
      camera.zoom = zoom;
    }
    camera.lookAt(camera.target);
    camera.updateProjectionMatrix();
    const currentView = ViewService.currentView;
    if (currentView) {
      currentView.lastOrientation.longitude = this.longitude;
      currentView.lastOrientation.latitude = this.latitude;
    }
    this.events$.next(orbitMoveEvent);
  }
}
OrbitService.orbitMoveEvent = orbitMoveEvent;let UID = 0;
const ImageServiceEvent = {
  Progress: 'progress',
  Complete: 'complete'
};
class ImageService {
  static worker() {
    if (!this.worker_) {
      this.worker_ = new Worker(environment.workers.image);
    }
    return this.worker_;
  }
  static events$(src, size) {
    if (!('Worker' in window) || this.isBlob(src) || this.isCors(src)) {
      return rxjs.of({
        type: ImageServiceEvent.Complete,
        data: src
      });
    }
    const id = ++UID;
    const worker = this.worker();
    worker.postMessage({
      src,
      id,
      size
    });
    return rxjs.fromEvent(worker, 'message').pipe(operators.map(event => event.data), operators.filter(event => event.src === src), operators.auditTime(100), operators.map(event => {
      // console.log('ImageService', event);
      if (event.type === ImageServiceEvent.Complete && event.data instanceof Blob) {
        const url = URL.createObjectURL(event.data);
        event.data = url;
      }
      return event;
    }), operators.takeWhile(event => event.type !== ImageServiceEvent.Complete, true), operators.finalize(() => {
      // console.log('ImageService.finalize', lastEvent);
      worker.postMessage({
        id
      });
      /*
      if (lastEvent && lastEvent.type === ImageServiceEvent.Complete && lastEvent.data) {
      	URL.revokeObjectURL(lastEvent.data);
      }
      */
    }));
  }

  static load$(src, size) {
    return this.events$(src, size).pipe(operators.filter(event => event.type === ImageServiceEvent.Complete), operators.map(event => event.data));
  }
  static isCors(src) {
    // !!! handle cors environment flag
    return false;
    // return src.indexOf('://') !== -1 && src.indexOf(window.location.host) === -1;
  }

  static isBlob(src) {
    return src.indexOf('blob:') === 0;
  }
}class PanoramaLoader {
  static get video() {
    return this.video_;
  }
  static set video(video) {
    if (this.video_) {
      this.video_.muted = true;
      this.video_.pause();
      if (this.video_.parentNode) {
        this.video_.parentNode.removeChild(this.video_);
      }
      this.video_ = null;
    }
    if (video) {
      const video = this.video_ = document.createElement('video');
      video.loop = true;
      video.playsInline = true;
      video.crossOrigin = 'anonymous';
      // document.querySelector('body').appendChild(video);
    }
  }

  static get muted() {
    return this.muted_;
  }
  static set muted(muted) {
    this.muted_ = muted;
    // console.log('PanoramaLoader.muted', muted, this.video);
    if (this.video) {
      this.video.muted = muted === true;
    }
  }
  static set cubeRenderTarget(cubeRenderTarget) {
    if (this.cubeRenderTarget_) {
      this.cubeRenderTarget_.texture.dispose();
      this.cubeRenderTarget_.dispose();
    }
    this.cubeRenderTarget_ = cubeRenderTarget;
  }
  static set texture(texture) {
    if (this.texture_) {
      this.texture_.dispose();
    }
    this.texture_ = texture;
  }
  static load(asset, renderer, callback) {
    MediaLoader.events$.next(new MediaLoaderDisposeEvent(this));
    this.video = null;
    if (!asset) {
      return;
    }
    // console.log('PanoramaLoader.load', asset.type.name, AssetType);
    if (asset.type.name === AssetType.PublisherStream.name) {
      return this.loadPublisherStreamBackground(renderer, callback);
    } else if (asset.type.name === AssetType.AttendeeStream.name) {
      return this.loadAttendeeStreamBackground(renderer, callback);
      /*} else if (assetIsStream(asset)) {
      	return this.loadStreamBackground(renderer, callback, asset);
      	*/
    } else if (asset.file.indexOf('.mp4') !== -1 || asset.file.indexOf('.webm') !== -1) {
      return this.loadVideoBackground(environment.getPath(asset.folder), asset.file, renderer, callback);
    } else if (asset.file.indexOf('.m3u8') !== -1) {
      return this.loadHlslVideoBackground(asset.file, renderer, callback);
    } else if (asset.file.indexOf('.hdr') !== -1) {
      return this.loadRgbeBackground(environment.getPath(asset.folder), asset.file, renderer, callback);
    } else {
      return this.loadBackgroundImageService(environment.getPath(asset.folder), asset.file, renderer, callback);
    }
  }
  static loadBackgroundImageService(folder, file, renderer, callback) {
    const progressRef = LoaderService.getRef();
    const image = new Image();
    ImageService.events$(folder + file).pipe(operators.tap(event => {
      if (event.type === ImageServiceEvent.Progress) {
        LoaderService.setProgress(progressRef, event.data.loaded, event.data.total);
      }
    }), operators.filter(event => event.type === ImageServiceEvent.Complete), operators.switchMap(event => {
      const load = rxjs.fromEvent(image, 'load');
      image.crossOrigin = 'anonymous';
      image.src = event.data;
      return load;
    }), operators.takeWhile(event => event.type !== ImageServiceEvent.Complete, true)).subscribe(event => {
      const texture = new THREE.Texture(image);
      texture.minFilter = THREE.LinearFilter;
      texture.magFilter = THREE.LinearFilter;
      texture.mapping = THREE.UVMapping;
      // console.log('texture', texture, THREE.RGBAFormat, THREE.LinearEncoding);
      // texture.format = THREE.RGBAFormat;
      // texture.encoding = THREE.LinearEncoding;
      texture.toneMapped = false;
      texture.needsUpdate = true;
      if (typeof callback === 'function') {
        callback(texture);
        URL.revokeObjectURL(event.data);
      }
      LoaderService.setProgress(progressRef, 1);
    });
  }
  static loadBackground(folder, file, renderer, callback) {
    const progressRef = LoaderService.getRef();
    const loader = new THREE.TextureLoader();
    loader.setPath(folder).load(file, texture => {
      texture.minFilter = THREE.LinearFilter;
      texture.magFilter = THREE.LinearFilter;
      texture.mapping = THREE.UVMapping;
      // texture.format = THREE.RGBAFormat;
      // texture.encoding = THREE.LinearEncoding;
      texture.needsUpdate = true;
      if (typeof callback === 'function') {
        callback(texture);
      }
      LoaderService.setProgress(progressRef, 1);
    }, request => {
      LoaderService.setProgress(progressRef, request.loaded, request.total);
    });
    return loader;
  }
  static loadRgbeBackground(folder, file, renderer, callback) {
    const progressRef = LoaderService.getRef();
    const loader = new RGBELoader();
    loader.setDataType(THREE.UnsignedByteType).setPath(folder).load(file, texture => {
      if (typeof callback === 'function') {
        callback(texture, true);
      }
      LoaderService.setProgress(progressRef, 1);
    }, request => {
      LoaderService.setProgress(progressRef, request.loaded, request.total);
    });
    return loader;
  }
  static loadHlslVideoBackground(src, renderer, callback) {
    const progressRef = LoaderService.getRef();
    const video = document.createElement('video');
    const onPlaying = () => {
      video.oncanplay = null;
      const texture = new THREE.VideoTexture(video);
      texture.minFilter = THREE.LinearFilter;
      texture.magFilter = THREE.LinearFilter;
      texture.mapping = THREE.UVMapping;
      // texture.format = THREE.RGBAFormat;
      // texture.encoding = THREE.LinearEncoding;
      texture.needsUpdate = true;
      if (typeof callback === 'function') {
        callback(texture);
      }
      LoaderService.setProgress(progressRef, 1);
    };
    video.oncanplay = () => {
      // console.log('videoReady', videoReady);
      onPlaying();
    };
    if (Hls.isSupported()) {
      var hls = new Hls();
      hls.attachMedia(video);
      hls.on(Hls.Events.MEDIA_ATTACHED, () => {
        hls.loadSource(src);
        hls.on(Hls.Events.MANIFEST_PARSED, (event, data) => {
          video.play();
        });
      });
    }
  }

  // !!! implementing medialoader interface
  // static get progress
  // static set progress
  // static play
  // static pause

  static get progress() {
    const video = this.video;
    if (video) {
      return video.currentTime / video.duration;
    } else {
      return 0;
    }
  }
  static set progress(progress) {
    const video = this.video;
    if (video) {
      const currentTime = video.duration * progress;
      if (video.seekable.length > progress && video.currentTime !== currentTime) {
        // console.log('PanoramaLoader', 'progress', progress, 'currentTime', currentTime, 'duration', this.video.duration, 'seekable', this.video.seekable);
        video.currentTime = currentTime;
        MediaLoader.events$.next(new MediaLoaderTimeSetEvent(this));
      }
    }
  }
  static play(silent) {
    // console.log('PanoramaLoader.play');
    const video = this.video;
    if (video) {
      video.muted = this.muted_;
      video.play().then(() => {
        // console.log('PanoramaLoader.play.success', this.video.src);
        if (!silent) {
          MediaLoader.events$.next(new MediaLoaderPlayEvent(this));
        }
      }, error => {
        console.log('PanoramaLoader.play.error', video.src, error);
      });
    }
  }
  static pause(silent) {
    // console.log('PanoramaLoader.pause');
    const video = this.video;
    if (video) {
      video.muted = true;
      video.pause();
      if (!silent) {
        MediaLoader.events$.next(new MediaLoaderPauseEvent(this));
      }
    }
  }
  static loadVideoBackground(folder, file, renderer, callback) {
    const progressRef = LoaderService.getRef();
    this.video = true;
    const video = this.video;
    const onCanPlay = () => {
      // console.log('PanoramaLoader', 'onPlaying');
      video.oncanplay = null;
      const texture = new THREE.VideoTexture(video);
      texture.minFilter = THREE.LinearFilter;
      texture.magFilter = THREE.LinearFilter;
      texture.mapping = THREE.UVMapping;
      // texture.format = THREE.RGBAFormat;
      // texture.encoding = THREE.LinearEncoding;
      texture.needsUpdate = true;
      if (typeof callback === 'function') {
        callback(texture);
      }
      // console.log('loadVideoBackground.loaded');
      LoaderService.setProgress(progressRef, 1);
      {
        this.play();
      }
    };
    const onTimeUpdate = () => {
      MediaLoader.events$.next(new MediaLoaderTimeUpdateEvent(this));
    };
    const onEnded = () => {
    };
    video.oncanplay = onCanPlay;
    video.ontimeupdate = onTimeUpdate;
    video.onended = onEnded;
    video.crossOrigin = 'anonymous';
    video.src = folder + file;
    video.load();
  }
  static loadPublisherStreamBackground(renderer, callback) {
    const onPublisherStreamId = publisherStreamId => {
      const video = document.querySelector(`#stream-${publisherStreamId} video`);
      if (!video) {
        return;
      }
      const onPlaying = () => {
        const texture = this.texture = new THREE.VideoTexture(video);
        texture.minFilter = THREE.LinearFilter;
        texture.magFilter = THREE.LinearFilter;
        texture.mapping = THREE.UVMapping;
        // texture.format = THREE.RGBAFormat;
        // texture.encoding = THREE.LinearEncoding;
        texture.needsUpdate = true;
        if (typeof callback === 'function') {
          callback(texture);
        }
      };
      video.crossOrigin = 'anonymous';
      if (video.readyState >= video.HAVE_FUTURE_DATA) {
        onPlaying();
      } else {
        video.oncanplay = () => {
          onPlaying();
        };
      }
    };
    StreamService.getPublisherStreamId$().pipe(operators.first()).subscribe(publisherStreamId => onPublisherStreamId(publisherStreamId));
  }
  static loadAttendeeStreamBackground(renderer, callback) {
    const onAttendeeStreamId = attendeeStreamId => {
      const video = document.querySelector(`#stream-${attendeeStreamId} video`);
      if (!video) {
        return;
      }
      const onPlaying = () => {
        const texture = this.texture = new THREE.VideoTexture(video);
        texture.minFilter = THREE.LinearFilter;
        texture.magFilter = THREE.LinearFilter;
        texture.mapping = THREE.UVMapping;
        // texture.format = THREE.RGBAFormat;
        // texture.encoding = THREE.LinearEncoding;
        texture.needsUpdate = true;
        if (typeof callback === 'function') {
          callback(texture);
        }
      };
      video.crossOrigin = 'anonymous';
      if (video.readyState >= video.HAVE_FUTURE_DATA) {
        onPlaying();
      } else {
        video.oncanplay = () => {
          onPlaying();
        };
      }
    };
    StreamService.getAttendeeStreamId$().pipe(operators.first()).subscribe(attendeeStreamId => onAttendeeStreamId(attendeeStreamId));
  }
  static loadStreamBackground(renderer, callback, asset) {
    const onStreamId = streamId => {
      const video = document.querySelector(`#stream-${streamId} video`);
      if (!video) {
        return;
      }
      const onPlaying = () => {
        const texture = this.texture = new THREE.VideoTexture(video);
        texture.minFilter = THREE.LinearFilter;
        texture.magFilter = THREE.LinearFilter;
        texture.mapping = THREE.UVMapping;
        // texture.format = THREE.RGBAFormat;
        // texture.encoding = THREE.LinearEncoding;
        texture.needsUpdate = true;
        if (typeof callback === 'function') {
          callback(texture);
        }
      };
      video.crossOrigin = 'anonymous';
      if (video.readyState >= video.HAVE_FUTURE_DATA) {
        onPlaying();
      } else {
        video.oncanplay = () => {
          onPlaying();
        };
      }
    };
    PanoramaLoader.getStreamId$(asset).pipe(operators.takeUntil(MediaLoader.events$.pipe(operators.filter(event => event instanceof MediaLoaderDisposeEvent)))).subscribe(streamId => {
      onStreamId(streamId);
    });
  }
  static getStreamId$(asset) {
    const assetType = asset.type;
    return StreamService.streams$.pipe(operators.map(streams => {
      // console.log('streams', streams);
      let stream;
      let i = 0;
      const matchType = MediaMesh.getTypeMatcher(assetType);
      streams.forEach(x => {
        // console.log('streams', matchType(x), x, asset);
        if (matchType(x)) {
          if (i === asset.index) {
            stream = x;
          }
          i++;
        }
      });
      if (stream) {
        return stream.streamId;
      } else {
        return null;
      }
    }));
  }
}class Panorama {
  constructor(renderer) {
    this.muted_ = false;
    this.subscription = StateService.state$.subscribe(state => PanoramaLoader.muted = state.volumeMuted);
    this.tween = 0;
    this.create(renderer);
  }
  create(renderer) {
    this.renderer = renderer;
    this.onCubeMapDispose = this.onCubeMapDispose.bind(this);
    const geometry = new THREE.BoxGeometry(202, 202, 202);
    const material = this.getBlackMaterial();
    const mesh = new InteractiveMesh(geometry, material);
    mesh.userData = {
      render: (time, tick, renderer, scene, camera) => {
        mesh.matrixWorld.copyPosition(camera.matrixWorld);
        const cubeMap = this.cubeMap;
        const texture = this.texture;
        if (cubeMap && texture && texture.isVideoTexture) {
          this.updateCubeMapEquirectangularTexture(cubeMap, renderer, texture);
        }
      }
    };
    mesh.name = '[panorama]';
    this.mesh = mesh;
  }
  getBlackMaterial() {
    return new THREE.MeshBasicMaterial({
      name: 'PanoramaStandardMaterial',
      color: 0x000000,
      side: THREE.BackSide,
      depthTest: false,
      depthWrite: false,
      fog: false
    });
  }
  getShaderMaterial(texture) {
    const material = new THREE.ShaderMaterial({
      name: 'PanoramaCubeMaterial',
      uniforms: this.cloneUniforms(THREE.ShaderLib.cube.uniforms),
      vertexShader: THREE.ShaderLib.cube.vertexShader,
      fragmentShader: THREE.ShaderLib.cube.fragmentShader,
      side: THREE.BackSide,
      depthTest: false,
      depthWrite: false,
      fog: false,
      toneMapped: false
    });
    texture.mapping = THREE.EquirectangularReflectionMapping;
    const cubeMap = this.toCubeMap(texture, this.renderer);
    material.map = cubeMap;
    material.uniforms.envMap.value = cubeMap;
    material.uniforms.flipEnvMap.value = cubeMap.isCubeTexture && cubeMap._needsFlipEnvMap ? -1 : 1;
    material.needsUpdate = true;
    this.mesh.geometry.deleteAttribute('normal');
    this.mesh.geometry.deleteAttribute('uv');
    Object.defineProperty(material, 'envMap', {
      get: function () {
        return this.uniforms.envMap.value;
      },
      configurable: true
    });
    return material;
  }
  makeEnvMap(texture) {
    let material = this.mesh.material;
    if (!material.uniforms) {
      material.dispose();
      material = this.getShaderMaterial(texture);
      this.mesh.material = material;
    } else {
      texture.mapping = THREE.EquirectangularReflectionMapping;
      const cubeMap = this.toCubeMap(texture, this.renderer);
      material.map = cubeMap;
      material.uniforms.envMap.value = cubeMap;
      material.uniforms.flipEnvMap.value = cubeMap.isCubeTexture && cubeMap._needsFlipEnvMap ? -1 : 1;
      material.needsUpdate = true;
    }
    // console.log('Panorama.makeEnvMap', this.texture, this.cubeMap);
  }

  toCubeMap(texture, renderer) {
    if (this.cubeMap) {
      this.cubeMap.dispose();
    }
    const image = texture.image;
    const height = image.height || image.videoHeight;
    const cubeMap = new THREE.WebGLCubeRenderTarget(height / 2, {
      generateMipmaps: true,
      type: THREE.HalfFloatType,
      encoding: THREE.LinearEncoding,
      // minFilter: THREE.LinearMipmapLinearFilter,
      minFilter: THREE.LinearFilter,
      magFilter: THREE.LinearFilter,
      // mapping: THREE.CubeReflectionMapping,
      // mapping: THREE.EquirectangularReflectionMapping,
      mapping: THREE.CubeUVReflectionMapping,
      // mapping: THREE.UVMapping,
      format: THREE.RGBAFormat
    });
    cubeMap.addEventListener('dispose', this.onCubeMapDispose);
    this.setCubeMapEquirectangularTexture(cubeMap, texture);
    this.updateCubeMapEquirectangularTexture(cubeMap, renderer, texture);
    this.cubeMap = cubeMap;
    this.texture = texture;
    return this.mapTextureMapping(cubeMap.texture, texture.mapping);
  }
  setCubeMapEquirectangularTexture(cubeMap, texture) {
    cubeMap.texture.type = texture.type;
    cubeMap.texture.format = THREE.RGBAFormat;
    cubeMap.texture.encoding = THREE.sRGBEncoding;
    cubeMap.texture.generateMipmaps = texture.generateMipmaps;
    cubeMap.texture.minFilter = texture.minFilter;
    cubeMap.texture.magFilter = texture.magFilter;
    cubeMap.texture.needsUpdate = true;
    const shader = {
      uniforms: {
        tEquirect: {
          value: null
        }
      },
      vertexShader: /* glsl */`
					varying vec3 vWorldDirection;
					vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
						return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
					}
					void main() {
						vWorldDirection = transformDirection( position, modelMatrix );
						#include <begin_vertex>
						#include <project_vertex>
					}
				`,
      fragmentShader: /* glsl */`
					uniform sampler2D tEquirect;
					varying vec3 vWorldDirection;
					#include <common>
					void main() {
						vec3 direction = normalize( vWorldDirection );
						vec2 sampleUV = equirectUv( direction );
						gl_FragColor = texture2D( tEquirect, sampleUV );
					}
				`
    };
    const geometry = new THREE.BoxGeometry(5, 5, 5);
    const material = new THREE.ShaderMaterial({
      name: 'CubemapFromEquirect',
      uniforms: this.cloneUniforms(shader.uniforms),
      vertexShader: shader.vertexShader,
      fragmentShader: shader.fragmentShader,
      side: THREE.BackSide,
      blending: THREE.NoBlending
    });
    material.uniforms.tEquirect.value = texture;
    const mesh = new THREE.Mesh(geometry, material);
    const camera = new THREE.CubeCamera(1, 10, cubeMap);
    cubeMap.camera = camera;
    cubeMap.mesh = mesh;
    return cubeMap;
  }
  updateCubeMapEquirectangularTexture(cubeMap, renderer, texture) {
    const previousMinFilter = texture.minFilter;
    // Avoid blurred poles
    if (texture.minFilter === THREE.LinearMipmapLinearFilter) {
      texture.minFilter = THREE.LinearFilter;
    }
    /*
    const outputEncoding = renderer.outputEncoding;
    const toneMapping = renderer.toneMapping;
    const toneMappingExposure = renderer.toneMappingExposure;
    renderer.toneMapping = THREE.NoToneMapping;
    renderer.outputEncoding = THREE.LinearEncoding;
    renderer.toneMappingExposure = 2;
    */
    cubeMap.camera.update(renderer, cubeMap.mesh);
    /*
    renderer.toneMapping = toneMapping;
    renderer.outputEncoding = outputEncoding;
    renderer.toneMappingExposure = toneMappingExposure;
    */
    texture.minFilter = previousMinFilter;
    // console.log('updateCubeMapEquirectangularTexture');
  }

  cloneUniforms(src) {
    const dst = {};
    for (const u in src) {
      dst[u] = {};
      for (const p in src[u]) {
        const property = src[u][p];
        if (property && (property.isColor || property.isMatrix3 || property.isMatrix4 || property.isVector2 || property.isVector3 || property.isVector4 || property.isTexture || property.isQuaternion)) {
          dst[u][p] = property.clone();
        } else if (Array.isArray(property)) {
          dst[u][p] = property.slice();
        } else {
          dst[u][p] = property;
        }
      }
    }
    return dst;
  }
  mapTextureMapping(texture, mapping) {
    if (mapping === THREE.EquirectangularReflectionMapping) {
      texture.mapping = THREE.CubeReflectionMapping;
    } else if (mapping === THREE.EquirectangularRefractionMapping) {
      texture.mapping = THREE.CubeRefractionMapping;
    }
    return texture;
  }
  onCubeMapDispose() {
    const cubeMap = this.cubeMap;
    if (cubeMap) {
      // console.log('Panorama.onCubeMapDispose', cubeMap);
      cubeMap.removeEventListener('dispose', this.onCubeMapDispose);
      cubeMap.texture.dispose();
      cubeMap.mesh.geometry.dispose();
      cubeMap.mesh.material.dispose();
      if (cubeMap !== undefined) {
        this.cubeMap = null;
      }
    }
  }
  change(view, renderer, callback, onexit) {
    const item = view instanceof PanoramaGridView ? view.tiles[view.index_] : view;
    const material = this.mesh.material;
    this.load(item, renderer, envMap => {
      if (typeof onexit === 'function') {
        onexit(view);
      }
      if (material.uniforms && material.uniforms.uTween) {
        material.uniforms.uTween.value = 1;
        material.needsUpdate = true;
      }
      if (typeof callback === 'function') {
        callback(envMap);
      }
    });
  }
  crossfade(item, renderer, callback) {
    const material = this.mesh.material;
    this.load(item, renderer, envMap => {
      if (material.uniforms && material.uniforms.uTween) {
        material.uniforms.uTween.value = 1;
        material.needsUpdate = true;
      }
      if (typeof callback === 'function') {
        callback(envMap);
      }
    });
  }
  getLocalizedAsset(asset) {
    if (asset && asset.locale) {
      const localizedAsset = asset.locale[LanguageService.lang];
      if (localizedAsset) {
        asset = localizedAsset;
      }
    }
    return asset;
  }
  load(item, renderer, callback) {
    const asset = item.type.name === ViewType.Media.name ? Asset.defaultMediaAsset : item.asset;
    if (!asset) {
      return;
    }
    if (asset.type.name === AssetType.Model.name) {
      if (typeof callback === 'function') {
        callback(null);
      }
      return;
    }
    const localizedAsset = this.getLocalizedAsset(asset);
    // console.log('Panorama.load.localizedAsset', localizedAsset, 'asset', asset);
    this.currentAsset = localizedAsset.folder + localizedAsset.file;
    PanoramaLoader.load(localizedAsset, renderer, (texture, rgbe) => {
      if (localizedAsset.folder + localizedAsset.file !== this.currentAsset) {
        texture.dispose();
        return;
      }
      const envMap = this.makeEnvMap(texture);
      if (typeof callback === 'function') {
        callback(envMap);
      }
    });
  }
  dispose() {
    this.subscription.unsubscribe();
    if (this.cubeMap) {
      this.cubeMap.dispose();
    }
  }
}const W = 12;
const H = 27;
const D = 0.5;
const R = 4 / 3;
const COLORS = [0xffffff, 0xffcc00, 0x00ffcc, 0x00ccff, 0xccff00, 0xcc00ff];
class PhoneStreamElement {
  static get geometry() {
    const geometry = new THREE.PlaneBufferGeometry(0.01 * W, 0.01 * W / R, 2, 2);
    return geometry;
  }
  setRemote(remote, i, total) {
    this.remote = remote;
    let s,
      c,
      r,
      w,
      h,
      sx,
      sy,
      sz = 0.01 * D; // !!! double distance
    if (total < 4) {
      s = 1;
      c = 0;
      r = i;
      w = 0.01 * W * s;
      h = w / R;
      sx = 0;
      sy = h / 2 - total * h / 2;
      this.plane.position.set(sx, sy + h * i, sz);
    } else {
      s = 0.5;
      c = i % 2;
      r = Math.floor(i / 2);
      w = 0.01 * W * s;
      h = w / R;
      sx = -w / 2;
      sy = h / 2 - Math.ceil(total / 2) * h / 2;
      this.plane.position.set(sx + c * w, sy + r * h, sz);
    }
    this.plane.scale.set(s, s, s);
    // console.log(this.plane.position);
    if (typeof remote === 'number') {
      this.plane.material.color.set(COLORS[i % COLORS.length]);
    } else {
      if (remote.texture) {
        this.plane.material.map = remote.texture;
        this.plane.material.needsUpdate = true;
      } else {
        this.addStreamTexture(remote.streamId, texture => {
          remote.texture = texture;
          this.plane.material.map = texture;
          this.plane.material.needsUpdate = true;
        });
      }
    }
  }
  addStreamTexture(streamId, callback) {
    const target = `#stream-${streamId}`; // `#stream-remote-${streamId}`;
    const video = document.querySelector(`${target} video`);
    if (!video) {
      return;
    }
    const onPlaying = () => {
      const texture = new THREE.VideoTexture(video);
      texture.minFilter = THREE.LinearFilter;
      texture.magFilter = THREE.LinearFilter;
      texture.mapping = THREE.UVMapping;
      // texture.format = THREE.RGBAFormat;
      // texture.encoding = THREE.sRGBEncoding;
      texture.needsUpdate = true;
      if (typeof callback === 'function') {
        callback(texture);
      }
    };
    video.crossOrigin = 'anonymous';
    if (video.readyState >= video.HAVE_FUTURE_DATA) {
      onPlaying();
    } else {
      video.oncanplay = () => {
        onPlaying();
      };
    }
  }
  constructor() {
    const geometry = PhoneStreamElement.geometry;
    const material = new THREE.MeshBasicMaterial({
      // depthTest: false,
      color: 0xffffff
      // side: THREE.DoubleSide,
    });

    this.plane = new THREE.Mesh(geometry, material);
  }
}
class PhoneElement {
  set remotes(remotes) {
    // console.log('PhoneElement', remotes);
    remotes.forEach((remote, i) => {
      let stream = this.streams[i];
      if (!stream) {
        stream = new PhoneStreamElement();
      }
      stream.setRemote(remote, i, remotes.length);
      this.phone.add(stream.plane);
      this.streams[i] = stream;
    });
    for (let i = remotes.length; i < this.streams.length; i++) {
      this.phone.remove(this.streams[i].plane);
    }
    this.streams.length = remotes.length;
  }
  constructor() {
    const mesh = this.mesh = new THREE.Group();
    const phone = this.phone = this.create();
    mesh.add(phone);
    this.streams = [];
    StreamService.remotes$.subscribe(remotes => {
      this.remotes = remotes;
    });
  }
  create() {
    const geometry = new THREE.BoxBufferGeometry(0.01 * W, 0.01 * H, 0.01 * D, 2, 2, 1);
    const material = new THREE.MeshStandardMaterial({
      // depthTest: false,
      color: 0x000000,
      transparent: true,
      opacity: 0.6
    });
    const phone = new THREE.Mesh(geometry, material);
    phone.rotation.set(-Math.PI / 4, 0, 0);
    return phone;
  }
}class PointerElement {
  constructor(color) {
    if (color === void 0) {
      color = '#ffffff';
    }
    this.position = new THREE.Vector3();
    // const targetPosition = this.targetPosition = new THREE.Vector3();
    const geometry = Geometry.planeGeometry; // new THREE.PlaneBufferGeometry(1.2, 1.2, 2, 2);
    const loader = new THREE.TextureLoader();
    const texture = loader.load(environment.getPath('textures/ui/nav-point.png'));
    const material = new THREE.MeshBasicMaterial({
      color: new THREE.Color(color),
      depthTest: false,
      depthWrite: false,
      map: texture,
      transparent: true,
      opacity: 0.9
    });
    const mesh = this.mesh = new THREE.Mesh(geometry, material);
    mesh.renderOrder = environment.renderOrder.pointer;
    mesh.position.set(-100000, -100000, -100000);
  }
  update(camera) {
    if (Interactive.lastIntersectedObject) {
      const position = this.position;
      position.copy(Interactive.lastIntersectedObject.intersection.point);
      position.multiplyScalar(0.99);
      const mesh = this.mesh;
      mesh.position.set(position.x, position.y, position.z);
      position.sub(camera.position);
      const s = position.length() / 80;
      mesh.scale.set(s, s, s);
      /*
      const targetPosition = this.targetPosition;
      targetPosition.set(0, 0, 0);
      camera.localToWorld(targetPosition);
      */
      mesh.lookAt(Host.origin);
    }
  }
  setPosition(x, y, z, camera) {
    const position = this.position;
    position.set(x, y, z).multiplyScalar(80);
    const mesh = this.mesh;
    mesh.position.copy(position);
    position.sub(camera.position);
    const s = position.length() / 80;
    mesh.scale.set(s, s, s);
    /*
    const targetPosition = this.targetPosition;
    targetPosition.set(0, 0, 0);
    camera.localToWorld(targetPosition);
    */
    mesh.lookAt(Host.origin);
  }
}const LINE_SEGMENTS = 10;
class TeleportElement {
  constructor() {
    this.gravity = new THREE.Vector3(0, -9.8, 0);
    this.controllerPosition = new THREE.Vector3();
    this.controllerDirection = new THREE.Vector3();
    this.currentPosition = new THREE.Vector3();
    this.targetPosition = new THREE.Vector3();
    const geometry = new THREE.BufferGeometry();
    const vertices = this.vertices = new Float32Array((LINE_SEGMENTS + 1) * 3);
    vertices.fill(0);
    const colors = new Float32Array((LINE_SEGMENTS + 1) * 3);
    colors.fill(0.5);
    geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
    const lineMaterial = new THREE.LineBasicMaterial({
      vertexColors: true,
      blending: THREE.AdditiveBlending
    });
    this.line = new THREE.Line(geometry, lineMaterial);
    // const light = this.light = new THREE.PointLight(0xffeeaa, 0, 2);
    const loader = new THREE.TextureLoader();
    const texture = loader.load(environment.getPath('textures/ui/nav-point.png'));
    const target = this.target = new THREE.Mesh(new THREE.PlaneBufferGeometry(0.3, 0.3, 1, 1), new THREE.MeshBasicMaterial({
      map: texture,
      blending: THREE.AdditiveBlending,
      color: 0x555555,
      transparent: true
    }));
    target.rotation.x = -Math.PI / 2;
  }
  addToController(controller, scene) {
    this.currentController = controller;
    // this.light.intensity = 1;
    controller.add(this.line);
    scene.add(this.target);
  }
  removeFromController(controller, scene, renderer, camera, cameraGroup) {
    const currentController = this.currentController;
    if (currentController === controller) {
      const gravity = this.gravity;
      const currentPosition = this.currentPosition;
      const controllerPosition = this.controllerPosition;
      const controllerDirection = this.controllerDirection;
      renderer.xr.getCamera(camera).getWorldPosition(currentPosition);
      currentPosition.y = 0;
      currentController.getWorldPosition(controllerPosition);
      currentController.getWorldDirection(controllerDirection);
      controllerDirection.multiplyScalar(6);
      const T = (-controllerDirection.y + Math.sqrt(controllerDirection.y ** 2 - 2 * controllerPosition.y * gravity.y)) / gravity.y;
      const targetPosition = this.getPositionT(this.targetPosition, T, controllerPosition, controllerDirection, gravity);
      targetPosition.addScaledVector(currentPosition, -1);
      cameraGroup.position.add(targetPosition);
      // this.teleport(targetPosition, cameraGroup);
      this.currentController = null;
      // this.light.intensity = 0;
      currentController.remove(this.line);
      scene.remove(this.target);
    }
  }
  update() {
    const currentController = this.currentController;
    if (currentController) {
      const gravity = this.gravity;
      const controllerPosition = this.controllerPosition;
      const controllerDirection = this.controllerDirection;
      const targetPosition = this.targetPosition;
      // Controller start position
      currentController.getWorldPosition(controllerPosition);
      // Set Vector V to the direction of the controller, at 1m/s
      currentController.getWorldDirection(controllerDirection);
      // Scale the initial velocity to 6m/s
      controllerDirection.multiplyScalar(6);
      // Time for tele ball to hit ground
      const T = (-controllerDirection.y + Math.sqrt(controllerDirection.y ** 2 - 2 * controllerPosition.y * gravity.y)) / gravity.y;
      const vertex = targetPosition.set(0, 0, 0);
      for (let i = 1; i <= LINE_SEGMENTS; i++) {
        // set vertex to current position of the virtual ball at time t
        this.getPositionT(vertex, i * T / LINE_SEGMENTS, controllerPosition, controllerDirection, gravity);
        currentController.worldToLocal(vertex);
        vertex.toArray(this.vertices, i * 3);
      }
      this.line.geometry.attributes.position.needsUpdate = true;
      // Place the light and sprite near the end of the poing
      // this.getPositionT(this.light.position, T * 0.98, controllerPosition, controllerDirection, gravity);
      this.getPositionT(this.target.position, T * 0.98, controllerPosition, controllerDirection, gravity);
    }
  }
  getPositionT(position, T, controllerPosition, controllerDirection, gravity) {
    position.copy(controllerPosition);
    position.addScaledVector(controllerDirection, T);
    position.addScaledVector(gravity, 0.5 * T ** 2);
    return position;
  }

  /*
  teleport(offsetPosition, cameraGroup) {
  	const position = new THREE.Vector3();
  	position.copy(cameraGroup.position);
  	position.add(offsetPosition);
  	// const distance = offsetPosition.length();
  	cameraGroup.position.copy(position);
  }
  */
}const XRStatus = {
  Waiting: 'waiting',
  Enabled: 'enabled',
  Ended: 'ended',
  Started: 'started',
  Disabled: 'disabled',
  NeedsHttps: 'needs-https',
  Unavailable: 'unavailable'
};
class VRService {
  static getService() {
    if (!this.service_) {
      this.service_ = new VRService();
    }
    return this.service_;
  }
  get status() {
    return this.status$.getValue();
  }
  get state() {
    return this.state$.getValue();
  }
  constructor() {
    if (VRService.service_) {
      throw 'VRService is a singleton class!';
    }
    const state = this.state_ = {
      camera: {
        position: new THREE.Vector3(),
        quaternion: new THREE.Quaternion(),
        scale: new THREE.Vector3(),
        array: new Array(3 + 4 + 3).fill(0)
      }
    };
    this.onSessionStarted = this.onSessionStarted.bind(this);
    this.onSessionEnded = this.onSessionEnded.bind(this);
    this.status$ = new rxjs.BehaviorSubject(XRStatus.Waiting);
    this.session$ = new rxjs.Subject();
    this.state$ = new rxjs.BehaviorSubject(state);
    this.currentSession = null;
    if ('xr' in navigator) {
      navigator.xr.isSessionSupported('immersive-vr').then(supported => {
        if (supported) {
          this.status$.next(XRStatus.Enabled);
        } else {
          this.status$.next(XRStatus.Disabled);
        }
      });
    } else {
      if (window.isSecureContext === false) {
        this.status$.next(XRStatus.NeedsHttps);
      } else {
        this.status$.next(XRStatus.Unavailable);
        // 'https://immersiveweb.dev/';
      }
    }
  }

  onSessionStarted(session) {
    session.addEventListener('end', this.onSessionEnded);
    this.currentSession = session;
    this.session$.next(session);
    this.status$.next(XRStatus.Started);
  }
  onSessionEnded( /*event*/
  ) {
    this.currentSession.removeEventListener('end', this.onSessionEnded);
    this.currentSession = null;
    this.session$.next(null);
    this.status$.next(XRStatus.Ended);
  }
  toggleVR(event) {
    if (this.currentSession === null) {
      // WebXR's requestReferenceSpace only works if the corresponding feature
      // was requested at session creation time. For simplicity, just ask for
      // the interesting ones as optional features, but be aware that the
      // requestReferenceSpace call will fail if it turns out to be unavailable.
      // ('local' is always available for immersive sessions and doesn't need to
      // be requested separately.)
      const sessionInit = {
        optionalFeatures: ['local-floor', 'bounded-floor']
      };
      navigator.xr.requestSession('immersive-vr', sessionInit).then(this.onSessionStarted);
    } else {
      this.currentSession.end();
    }
  }
  isDisabled() {
    const status = this.status$.getValue();
    switch (status) {
      case XRStatus.Waiting:
      case XRStatus.Disabled:
      case XRStatus.NeedsHttps:
      case XRStatus.Unavailable:
        return true;
      default:
        return false;
    }
  }
  getLabel() {
    let label;
    const status = this.status$.getValue();
    switch (status) {
      case XRStatus.Waiting:
        label = 'Waiting VR';
        break;
      case XRStatus.Enabled:
      case XRStatus.Ended:
        label = 'Enter VR';
        break;
      case XRStatus.Started:
        label = 'Exit VR';
        break;
      case XRStatus.Disabled:
        label = 'VR Disabled';
        break;
      case XRStatus.NeedsHttps:
        label = 'VR Needs Https';
        break;
      case XRStatus.Unavailable:
        label = 'VR Unavailable';
        break;
    }
    return label;
  }
  updateState(world) {
    if (this.status === XRStatus.Started) {
      world.renderer;
        world.scene;
        const camera = world.camera,
        state = this.state_;
      camera.matrixWorld.decompose(state.camera.position, state.camera.quaternion, state.camera.scale);
      state.camera.array[0] = state.camera.position.x;
      state.camera.array[1] = state.camera.position.y;
      state.camera.array[2] = state.camera.position.z;
      state.camera.array[3] = state.camera.quaternion.x;
      state.camera.array[4] = state.camera.quaternion.y;
      state.camera.array[5] = state.camera.quaternion.z;
      state.camera.array[6] = state.camera.quaternion.w;
      state.camera.array[7] = state.camera.scale.x;
      state.camera.array[8] = state.camera.scale.y;
      state.camera.array[9] = state.camera.scale.z;
      this.state$.next(state);
    }
  }
}class Emittable {
  constructor() {
    this.events = {};
  }
  on(type, callback) {
    const event = this.events[type] = this.events[type] || [];
    event.push(callback);
    return () => {
      this.events[type] = event.filter(x => x !== callback);
    };
  }
  off(type, callback) {
    const event = this.events[type];
    if (event) {
      this.events[type] = event.filter(x => x !== callback);
    }
  }
  emit(type, data) {
    const event = this.events[type];
    if (event) {
      event.forEach(callback => {
        // callback.call(this, data);
        callback(data);
      });
    }
    const broadcast = this.events.broadcast;
    if (broadcast) {
      broadcast.forEach(callback => {
        callback(type, data);
      });
    }
  }
}class Gamepad extends Emittable {
  constructor(gamepad) {
    super();
    this.gamepad = gamepad;
    this.buttons = {};
    this.axes = {};
  }
  update() {
    this.updateButtons();
    this.updateAxes();
  }
  updateButtons() {
    this.gamepad.buttons.forEach((x, i) => {
      const pressed = x.pressed;
      const button = this.buttons[i] || (this.buttons[i] = new GamepadButton(i, this));
      if (button.pressed !== pressed) {
        button.pressed = pressed;
        if (pressed) {
          this.emit('press', button);
        } else if (status !== undefined) {
          this.emit('release', button);
        }
      }
    });
  }
  updateAxes() {
    const axes = this.gamepad.axes;
    for (let i = 0; i < axes.length; i += 2) {
      const index = Math.floor(i / 2);
      const axis = this.axes[index] || (this.axes[index] = new GamepadAxis(index, this));
      const x = axes[i];
      const y = axes[i + 1];
      if (axis.x !== x || axis.y !== y) {
        axis.x = x;
        axis.y = y;
        if (Math.abs(x) > Math.abs(y)) {
          const left = x < -0.85;
          const right = x > 0.85;
          if (axis.left !== left) {
            axis.left = left;
            this.emit(left ? 'left' : 'none', axis);
            // console.log(`${axis.gamepad.hand} ${axis.gamepad.index} left ${left}`);
          }

          if (axis.right !== right) {
            axis.right = right;
            this.emit(right ? 'right' : 'none', axis);
            // console.log(`${axis.gamepad.hand} ${axis.gamepad.index} right ${right}`);
          }
        } else {
          const up = y < -0.85;
          const down = y > 0.85;
          if (axis.up !== up) {
            axis.up = up;
            this.emit(up ? 'up' : 'none', axis);
            // console.log(`${axis.gamepad.hand} ${axis.gamepad.index} up ${up}`);
          }

          if (axis.down !== down) {
            axis.down = down;
            this.emit(down ? 'down' : 'none', axis);
            // console.log(`${axis.gamepad.hand} ${axis.gamepad.index} down ${down}`);
          }
        }

        this.emit('axis', axis);
      }
    }
  }
  feedback(strength, duration) {
    if (strength === void 0) {
      strength = 0.1;
    }
    if (duration === void 0) {
      duration = 50;
    }
    // !!! care for battery
    const actuators = this.gamepad.hapticActuators;
    if (actuators && actuators.length) {
      return actuators[0].pulse(strength, duration);
    } else {
      return Promise.reject();
    }
  }
}
class GamepadButton {
  constructor(index, gamepad) {
    this.index = index;
    this.gamepad = gamepad;
    this.pressed = false;
  }
}
class GamepadAxis extends THREE.Vector2 {
  constructor(index, gamepad) {
    super();
    this.index = index;
    this.gamepad = gamepad;
    this.left = this.right = this.up = this.down = false;
  }
}class GLTFLoader extends three.Loader {

	constructor( manager ) {

		super( manager );

		this.dracoLoader = null;
		this.ktx2Loader = null;
		this.meshoptDecoder = null;

		this.pluginCallbacks = [];

		this.register( function ( parser ) {

			return new GLTFMaterialsClearcoatExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFTextureBasisUExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFTextureWebPExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFMaterialsSheenExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFMaterialsTransmissionExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFMaterialsVolumeExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFMaterialsIorExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFMaterialsSpecularExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFLightsExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFMeshoptCompression( parser );

		} );

	}

	load( url, onLoad, onProgress, onError ) {

		const scope = this;

		let resourcePath;

		if ( this.resourcePath !== '' ) {

			resourcePath = this.resourcePath;

		} else if ( this.path !== '' ) {

			resourcePath = this.path;

		} else {

			resourcePath = three.LoaderUtils.extractUrlBase( url );

		}

		// Tells the LoadingManager to track an extra item, which resolves after
		// the model is fully loaded. This means the count of items loaded will
		// be incorrect, but ensures manager.onLoad() does not fire early.
		this.manager.itemStart( url );

		const _onError = function ( e ) {

			if ( onError ) {

				onError( e );

			} else {

				console.error( e );

			}

			scope.manager.itemError( url );
			scope.manager.itemEnd( url );

		};

		const loader = new three.FileLoader( this.manager );

		loader.setPath( this.path );
		loader.setResponseType( 'arraybuffer' );
		loader.setRequestHeader( this.requestHeader );
		loader.setWithCredentials( this.withCredentials );

		loader.load( url, function ( data ) {

			try {

				scope.parse( data, resourcePath, function ( gltf ) {

					onLoad( gltf );

					scope.manager.itemEnd( url );

				}, _onError );

			} catch ( e ) {

				_onError( e );

			}

		}, onProgress, _onError );

	}

	setDRACOLoader( dracoLoader ) {

		this.dracoLoader = dracoLoader;
		return this;

	}

	setDDSLoader() {

		throw new Error(

			'THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".'

		);

	}

	setKTX2Loader( ktx2Loader ) {

		this.ktx2Loader = ktx2Loader;
		return this;

	}

	setMeshoptDecoder( meshoptDecoder ) {

		this.meshoptDecoder = meshoptDecoder;
		return this;

	}

	register( callback ) {

		if ( this.pluginCallbacks.indexOf( callback ) === - 1 ) {

			this.pluginCallbacks.push( callback );

		}

		return this;

	}

	unregister( callback ) {

		if ( this.pluginCallbacks.indexOf( callback ) !== - 1 ) {

			this.pluginCallbacks.splice( this.pluginCallbacks.indexOf( callback ), 1 );

		}

		return this;

	}

	parse( data, path, onLoad, onError ) {

		let content;
		const extensions = {};
		const plugins = {};

		if ( typeof data === 'string' ) {

			content = data;

		} else {

			const magic = three.LoaderUtils.decodeText( new Uint8Array( data, 0, 4 ) );

			if ( magic === BINARY_EXTENSION_HEADER_MAGIC ) {

				try {

					extensions[ EXTENSIONS.KHR_BINARY_GLTF ] = new GLTFBinaryExtension( data );

				} catch ( error ) {

					if ( onError ) onError( error );
					return;

				}

				content = extensions[ EXTENSIONS.KHR_BINARY_GLTF ].content;

			} else {

				content = three.LoaderUtils.decodeText( new Uint8Array( data ) );

			}

		}

		const json = JSON.parse( content );

		if ( json.asset === undefined || json.asset.version[ 0 ] < 2 ) {

			if ( onError ) onError( new Error( 'THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.' ) );
			return;

		}

		const parser = new GLTFParser( json, {

			path: path || this.resourcePath || '',
			crossOrigin: this.crossOrigin,
			requestHeader: this.requestHeader,
			manager: this.manager,
			ktx2Loader: this.ktx2Loader,
			meshoptDecoder: this.meshoptDecoder

		} );

		parser.fileLoader.setRequestHeader( this.requestHeader );

		for ( let i = 0; i < this.pluginCallbacks.length; i ++ ) {

			const plugin = this.pluginCallbacks[ i ]( parser );
			plugins[ plugin.name ] = plugin;

			// Workaround to avoid determining as unknown extension
			// in addUnknownExtensionsToUserData().
			// Remove this workaround if we move all the existing
			// extension handlers to plugin system
			extensions[ plugin.name ] = true;

		}

		if ( json.extensionsUsed ) {

			for ( let i = 0; i < json.extensionsUsed.length; ++ i ) {

				const extensionName = json.extensionsUsed[ i ];
				const extensionsRequired = json.extensionsRequired || [];

				switch ( extensionName ) {

					case EXTENSIONS.KHR_MATERIALS_UNLIT:
						extensions[ extensionName ] = new GLTFMaterialsUnlitExtension();
						break;

					case EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
						extensions[ extensionName ] = new GLTFMaterialsPbrSpecularGlossinessExtension();
						break;

					case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:
						extensions[ extensionName ] = new GLTFDracoMeshCompressionExtension( json, this.dracoLoader );
						break;

					case EXTENSIONS.KHR_TEXTURE_TRANSFORM:
						extensions[ extensionName ] = new GLTFTextureTransformExtension();
						break;

					case EXTENSIONS.KHR_MESH_QUANTIZATION:
						extensions[ extensionName ] = new GLTFMeshQuantizationExtension();
						break;

					default:

						if ( extensionsRequired.indexOf( extensionName ) >= 0 && plugins[ extensionName ] === undefined ) {

							console.warn( 'THREE.GLTFLoader: Unknown extension "' + extensionName + '".' );

						}

				}

			}

		}

		parser.setExtensions( extensions );
		parser.setPlugins( plugins );
		parser.parse( onLoad, onError );

	}

	parseAsync( data, path ) {

		const scope = this;

		return new Promise( function ( resolve, reject ) {

			scope.parse( data, path, resolve, reject );

		} );

	}

}

/* GLTFREGISTRY */

function GLTFRegistry() {

	let objects = {};

	return	{

		get: function ( key ) {

			return objects[ key ];

		},

		add: function ( key, object ) {

			objects[ key ] = object;

		},

		remove: function ( key ) {

			delete objects[ key ];

		},

		removeAll: function () {

			objects = {};

		}

	};

}

/*********************************/
/********** EXTENSIONS ***********/
/*********************************/

const EXTENSIONS = {
	KHR_BINARY_GLTF: 'KHR_binary_glTF',
	KHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',
	KHR_LIGHTS_PUNCTUAL: 'KHR_lights_punctual',
	KHR_MATERIALS_CLEARCOAT: 'KHR_materials_clearcoat',
	KHR_MATERIALS_IOR: 'KHR_materials_ior',
	KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: 'KHR_materials_pbrSpecularGlossiness',
	KHR_MATERIALS_SHEEN: 'KHR_materials_sheen',
	KHR_MATERIALS_SPECULAR: 'KHR_materials_specular',
	KHR_MATERIALS_TRANSMISSION: 'KHR_materials_transmission',
	KHR_MATERIALS_UNLIT: 'KHR_materials_unlit',
	KHR_MATERIALS_VOLUME: 'KHR_materials_volume',
	KHR_TEXTURE_BASISU: 'KHR_texture_basisu',
	KHR_TEXTURE_TRANSFORM: 'KHR_texture_transform',
	KHR_MESH_QUANTIZATION: 'KHR_mesh_quantization',
	EXT_TEXTURE_WEBP: 'EXT_texture_webp',
	EXT_MESHOPT_COMPRESSION: 'EXT_meshopt_compression'
};

/**
 * Punctual Lights Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual
 */
class GLTFLightsExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;

		// Object3D instance caches
		this.cache = { refs: {}, uses: {} };

	}

	_markDefs() {

		const parser = this.parser;
		const nodeDefs = this.parser.json.nodes || [];

		for ( let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex ++ ) {

			const nodeDef = nodeDefs[ nodeIndex ];

			if ( nodeDef.extensions
					&& nodeDef.extensions[ this.name ]
					&& nodeDef.extensions[ this.name ].light !== undefined ) {

				parser._addNodeRef( this.cache, nodeDef.extensions[ this.name ].light );

			}

		}

	}

	_loadLight( lightIndex ) {

		const parser = this.parser;
		const cacheKey = 'light:' + lightIndex;
		let dependency = parser.cache.get( cacheKey );

		if ( dependency ) return dependency;

		const json = parser.json;
		const extensions = ( json.extensions && json.extensions[ this.name ] ) || {};
		const lightDefs = extensions.lights || [];
		const lightDef = lightDefs[ lightIndex ];
		let lightNode;

		const color = new three.Color( 0xffffff );

		if ( lightDef.color !== undefined ) color.fromArray( lightDef.color );

		const range = lightDef.range !== undefined ? lightDef.range : 0;

		switch ( lightDef.type ) {

			case 'directional':
				lightNode = new three.DirectionalLight( color );
				lightNode.target.position.set( 0, 0, - 1 );
				lightNode.add( lightNode.target );
				break;

			case 'point':
				lightNode = new three.PointLight( color );
				lightNode.distance = range;
				break;

			case 'spot':
				lightNode = new three.SpotLight( color );
				lightNode.distance = range;
				// Handle spotlight properties.
				lightDef.spot = lightDef.spot || {};
				lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== undefined ? lightDef.spot.innerConeAngle : 0;
				lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== undefined ? lightDef.spot.outerConeAngle : Math.PI / 4.0;
				lightNode.angle = lightDef.spot.outerConeAngle;
				lightNode.penumbra = 1.0 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;
				lightNode.target.position.set( 0, 0, - 1 );
				lightNode.add( lightNode.target );
				break;

			default:
				throw new Error( 'THREE.GLTFLoader: Unexpected light type: ' + lightDef.type );

		}

		// Some lights (e.g. spot) default to a position other than the origin. Reset the position
		// here, because node-level parsing will only override position if explicitly specified.
		lightNode.position.set( 0, 0, 0 );

		lightNode.decay = 2;

		if ( lightDef.intensity !== undefined ) lightNode.intensity = lightDef.intensity;

		lightNode.name = parser.createUniqueName( lightDef.name || ( 'light_' + lightIndex ) );

		dependency = Promise.resolve( lightNode );

		parser.cache.add( cacheKey, dependency );

		return dependency;

	}

	createNodeAttachment( nodeIndex ) {

		const self = this;
		const parser = this.parser;
		const json = parser.json;
		const nodeDef = json.nodes[ nodeIndex ];
		const lightDef = ( nodeDef.extensions && nodeDef.extensions[ this.name ] ) || {};
		const lightIndex = lightDef.light;

		if ( lightIndex === undefined ) return null;

		return this._loadLight( lightIndex ).then( function ( light ) {

			return parser._getNodeRef( self.cache, lightIndex, light );

		} );

	}

}

/**
 * Unlit Materials Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit
 */
class GLTFMaterialsUnlitExtension {

	constructor() {

		this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;

	}

	getMaterialType() {

		return three.MeshBasicMaterial;

	}

	extendParams( materialParams, materialDef, parser ) {

		const pending = [];

		materialParams.color = new three.Color( 1.0, 1.0, 1.0 );
		materialParams.opacity = 1.0;

		const metallicRoughness = materialDef.pbrMetallicRoughness;

		if ( metallicRoughness ) {

			if ( Array.isArray( metallicRoughness.baseColorFactor ) ) {

				const array = metallicRoughness.baseColorFactor;

				materialParams.color.fromArray( array );
				materialParams.opacity = array[ 3 ];

			}

			if ( metallicRoughness.baseColorTexture !== undefined ) {

				pending.push( parser.assignTexture( materialParams, 'map', metallicRoughness.baseColorTexture ) );

			}

		}

		return Promise.all( pending );

	}

}

/**
 * Clearcoat Materials Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat
 */
class GLTFMaterialsClearcoatExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;

	}

	getMaterialType( materialIndex ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

		return three.MeshPhysicalMaterial;

	}

	extendMaterialParams( materialIndex, materialParams ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

			return Promise.resolve();

		}

		const pending = [];

		const extension = materialDef.extensions[ this.name ];

		if ( extension.clearcoatFactor !== undefined ) {

			materialParams.clearcoat = extension.clearcoatFactor;

		}

		if ( extension.clearcoatTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'clearcoatMap', extension.clearcoatTexture ) );

		}

		if ( extension.clearcoatRoughnessFactor !== undefined ) {

			materialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;

		}

		if ( extension.clearcoatRoughnessTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'clearcoatRoughnessMap', extension.clearcoatRoughnessTexture ) );

		}

		if ( extension.clearcoatNormalTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'clearcoatNormalMap', extension.clearcoatNormalTexture ) );

			if ( extension.clearcoatNormalTexture.scale !== undefined ) {

				const scale = extension.clearcoatNormalTexture.scale;

				materialParams.clearcoatNormalScale = new three.Vector2( scale, scale );

			}

		}

		return Promise.all( pending );

	}

}

/**
 * Sheen Materials Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_sheen
 */
class GLTFMaterialsSheenExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_MATERIALS_SHEEN;

	}

	getMaterialType( materialIndex ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

		return three.MeshPhysicalMaterial;

	}

	extendMaterialParams( materialIndex, materialParams ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

			return Promise.resolve();

		}

		const pending = [];

		materialParams.sheenColor = new three.Color( 0, 0, 0 );
		materialParams.sheenRoughness = 0;
		materialParams.sheen = 1;

		const extension = materialDef.extensions[ this.name ];

		if ( extension.sheenColorFactor !== undefined ) {

			materialParams.sheenColor.fromArray( extension.sheenColorFactor );

		}

		if ( extension.sheenRoughnessFactor !== undefined ) {

			materialParams.sheenRoughness = extension.sheenRoughnessFactor;

		}

		if ( extension.sheenColorTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'sheenColorMap', extension.sheenColorTexture ) );

		}

		if ( extension.sheenRoughnessTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'sheenRoughnessMap', extension.sheenRoughnessTexture ) );

		}

		return Promise.all( pending );

	}

}

/**
 * Transmission Materials Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission
 * Draft: https://github.com/KhronosGroup/glTF/pull/1698
 */
class GLTFMaterialsTransmissionExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION;

	}

	getMaterialType( materialIndex ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

		return three.MeshPhysicalMaterial;

	}

	extendMaterialParams( materialIndex, materialParams ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

			return Promise.resolve();

		}

		const pending = [];

		const extension = materialDef.extensions[ this.name ];

		if ( extension.transmissionFactor !== undefined ) {

			materialParams.transmission = extension.transmissionFactor;

		}

		if ( extension.transmissionTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'transmissionMap', extension.transmissionTexture ) );

		}

		return Promise.all( pending );

	}

}

/**
 * Materials Volume Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_volume
 */
class GLTFMaterialsVolumeExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_MATERIALS_VOLUME;

	}

	getMaterialType( materialIndex ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

		return three.MeshPhysicalMaterial;

	}

	extendMaterialParams( materialIndex, materialParams ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

			return Promise.resolve();

		}

		const pending = [];

		const extension = materialDef.extensions[ this.name ];

		materialParams.thickness = extension.thicknessFactor !== undefined ? extension.thicknessFactor : 0;

		if ( extension.thicknessTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'thicknessMap', extension.thicknessTexture ) );

		}

		materialParams.attenuationDistance = extension.attenuationDistance || 0;

		const colorArray = extension.attenuationColor || [ 1, 1, 1 ];
		materialParams.attenuationColor = new three.Color( colorArray[ 0 ], colorArray[ 1 ], colorArray[ 2 ] );

		return Promise.all( pending );

	}

}

/**
 * Materials ior Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_ior
 */
class GLTFMaterialsIorExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_MATERIALS_IOR;

	}

	getMaterialType( materialIndex ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

		return three.MeshPhysicalMaterial;

	}

	extendMaterialParams( materialIndex, materialParams ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

			return Promise.resolve();

		}

		const extension = materialDef.extensions[ this.name ];

		materialParams.ior = extension.ior !== undefined ? extension.ior : 1.5;

		return Promise.resolve();

	}

}

/**
 * Materials specular Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_specular
 */
class GLTFMaterialsSpecularExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_MATERIALS_SPECULAR;

	}

	getMaterialType( materialIndex ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

		return three.MeshPhysicalMaterial;

	}

	extendMaterialParams( materialIndex, materialParams ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

			return Promise.resolve();

		}

		const pending = [];

		const extension = materialDef.extensions[ this.name ];

		materialParams.specularIntensity = extension.specularFactor !== undefined ? extension.specularFactor : 1.0;

		if ( extension.specularTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'specularIntensityMap', extension.specularTexture ) );

		}

		const colorArray = extension.specularColorFactor || [ 1, 1, 1 ];
		materialParams.specularColor = new three.Color( colorArray[ 0 ], colorArray[ 1 ], colorArray[ 2 ] );

		if ( extension.specularColorTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'specularColorMap', extension.specularColorTexture ).then( function ( texture ) {

				texture.encoding = three.sRGBEncoding;

			} ) );

		}

		return Promise.all( pending );

	}

}

/**
 * BasisU Texture Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_basisu
 */
class GLTFTextureBasisUExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_TEXTURE_BASISU;

	}

	loadTexture( textureIndex ) {

		const parser = this.parser;
		const json = parser.json;

		const textureDef = json.textures[ textureIndex ];

		if ( ! textureDef.extensions || ! textureDef.extensions[ this.name ] ) {

			return null;

		}

		const extension = textureDef.extensions[ this.name ];
		const loader = parser.options.ktx2Loader;

		if ( ! loader ) {

			if ( json.extensionsRequired && json.extensionsRequired.indexOf( this.name ) >= 0 ) {

				throw new Error( 'THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures' );

			} else {

				// Assumes that the extension is optional and that a fallback texture is present
				return null;

			}

		}

		return parser.loadTextureImage( textureIndex, extension.source, loader );

	}

}

/**
 * WebP Texture Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_webp
 */
class GLTFTextureWebPExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.EXT_TEXTURE_WEBP;
		this.isSupported = null;

	}

	loadTexture( textureIndex ) {

		const name = this.name;
		const parser = this.parser;
		const json = parser.json;

		const textureDef = json.textures[ textureIndex ];

		if ( ! textureDef.extensions || ! textureDef.extensions[ name ] ) {

			return null;

		}

		const extension = textureDef.extensions[ name ];
		const source = json.images[ extension.source ];

		let loader = parser.textureLoader;
		if ( source.uri ) {

			const handler = parser.options.manager.getHandler( source.uri );
			if ( handler !== null ) loader = handler;

		}

		return this.detectSupport().then( function ( isSupported ) {

			if ( isSupported ) return parser.loadTextureImage( textureIndex, source, loader );

			if ( json.extensionsRequired && json.extensionsRequired.indexOf( name ) >= 0 ) {

				throw new Error( 'THREE.GLTFLoader: WebP required by asset but unsupported.' );

			}

			// Fall back to PNG or JPEG.
			return parser.loadTexture( textureIndex );

		} );

	}

	detectSupport() {

		if ( ! this.isSupported ) {

			this.isSupported = new Promise( function ( resolve ) {

				const image = new Image();

				// Lossy test image. Support for lossy images doesn't guarantee support for all
				// WebP images, unfortunately.
				image.src = 'data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA';

				image.onload = image.onerror = function () {

					resolve( image.height === 1 );

				};

			} );

		}

		return this.isSupported;

	}

}

/**
 * meshopt BufferView Compression Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_meshopt_compression
 */
class GLTFMeshoptCompression {

	constructor( parser ) {

		this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION;
		this.parser = parser;

	}

	loadBufferView( index ) {

		const json = this.parser.json;
		const bufferView = json.bufferViews[ index ];

		if ( bufferView.extensions && bufferView.extensions[ this.name ] ) {

			const extensionDef = bufferView.extensions[ this.name ];

			const buffer = this.parser.getDependency( 'buffer', extensionDef.buffer );
			const decoder = this.parser.options.meshoptDecoder;

			if ( ! decoder || ! decoder.supported ) {

				if ( json.extensionsRequired && json.extensionsRequired.indexOf( this.name ) >= 0 ) {

					throw new Error( 'THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files' );

				} else {

					// Assumes that the extension is optional and that fallback buffer data is present
					return null;

				}

			}

			return Promise.all( [ buffer, decoder.ready ] ).then( function ( res ) {

				const byteOffset = extensionDef.byteOffset || 0;
				const byteLength = extensionDef.byteLength || 0;

				const count = extensionDef.count;
				const stride = extensionDef.byteStride;

				const result = new ArrayBuffer( count * stride );
				const source = new Uint8Array( res[ 0 ], byteOffset, byteLength );

				decoder.decodeGltfBuffer( new Uint8Array( result ), count, stride, source, extensionDef.mode, extensionDef.filter );
				return result;

			} );

		} else {

			return null;

		}

	}

}

/* BINARY EXTENSION */
const BINARY_EXTENSION_HEADER_MAGIC = 'glTF';
const BINARY_EXTENSION_HEADER_LENGTH = 12;
const BINARY_EXTENSION_CHUNK_TYPES = { JSON: 0x4E4F534A, BIN: 0x004E4942 };

class GLTFBinaryExtension {

	constructor( data ) {

		this.name = EXTENSIONS.KHR_BINARY_GLTF;
		this.content = null;
		this.body = null;

		const headerView = new DataView( data, 0, BINARY_EXTENSION_HEADER_LENGTH );

		this.header = {
			magic: three.LoaderUtils.decodeText( new Uint8Array( data.slice( 0, 4 ) ) ),
			version: headerView.getUint32( 4, true ),
			length: headerView.getUint32( 8, true )
		};

		if ( this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC ) {

			throw new Error( 'THREE.GLTFLoader: Unsupported glTF-Binary header.' );

		} else if ( this.header.version < 2.0 ) {

			throw new Error( 'THREE.GLTFLoader: Legacy binary file detected.' );

		}

		const chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH;
		const chunkView = new DataView( data, BINARY_EXTENSION_HEADER_LENGTH );
		let chunkIndex = 0;

		while ( chunkIndex < chunkContentsLength ) {

			const chunkLength = chunkView.getUint32( chunkIndex, true );
			chunkIndex += 4;

			const chunkType = chunkView.getUint32( chunkIndex, true );
			chunkIndex += 4;

			if ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON ) {

				const contentArray = new Uint8Array( data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength );
				this.content = three.LoaderUtils.decodeText( contentArray );

			} else if ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN ) {

				const byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;
				this.body = data.slice( byteOffset, byteOffset + chunkLength );

			}

			// Clients must ignore chunks with unknown types.

			chunkIndex += chunkLength;

		}

		if ( this.content === null ) {

			throw new Error( 'THREE.GLTFLoader: JSON content not found.' );

		}

	}

}

/**
 * DRACO Mesh Compression Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression
 */
class GLTFDracoMeshCompressionExtension {

	constructor( json, dracoLoader ) {

		if ( ! dracoLoader ) {

			throw new Error( 'THREE.GLTFLoader: No DRACOLoader instance provided.' );

		}

		this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;
		this.json = json;
		this.dracoLoader = dracoLoader;
		this.dracoLoader.preload();

	}

	decodePrimitive( primitive, parser ) {

		const json = this.json;
		const dracoLoader = this.dracoLoader;
		const bufferViewIndex = primitive.extensions[ this.name ].bufferView;
		const gltfAttributeMap = primitive.extensions[ this.name ].attributes;
		const threeAttributeMap = {};
		const attributeNormalizedMap = {};
		const attributeTypeMap = {};

		for ( const attributeName in gltfAttributeMap ) {

			const threeAttributeName = ATTRIBUTES[ attributeName ] || attributeName.toLowerCase();

			threeAttributeMap[ threeAttributeName ] = gltfAttributeMap[ attributeName ];

		}

		for ( const attributeName in primitive.attributes ) {

			const threeAttributeName = ATTRIBUTES[ attributeName ] || attributeName.toLowerCase();

			if ( gltfAttributeMap[ attributeName ] !== undefined ) {

				const accessorDef = json.accessors[ primitive.attributes[ attributeName ] ];
				const componentType = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];

				attributeTypeMap[ threeAttributeName ] = componentType;
				attributeNormalizedMap[ threeAttributeName ] = accessorDef.normalized === true;

			}

		}

		return parser.getDependency( 'bufferView', bufferViewIndex ).then( function ( bufferView ) {

			return new Promise( function ( resolve ) {

				dracoLoader.decodeDracoFile( bufferView, function ( geometry ) {

					for ( const attributeName in geometry.attributes ) {

						const attribute = geometry.attributes[ attributeName ];
						const normalized = attributeNormalizedMap[ attributeName ];

						if ( normalized !== undefined ) attribute.normalized = normalized;

					}

					resolve( geometry );

				}, threeAttributeMap, attributeTypeMap );

			} );

		} );

	}

}

/**
 * Texture Transform Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_transform
 */
class GLTFTextureTransformExtension {

	constructor() {

		this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;

	}

	extendTexture( texture, transform ) {

		if ( transform.texCoord !== undefined ) {

			console.warn( 'THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.' );

		}

		if ( transform.offset === undefined && transform.rotation === undefined && transform.scale === undefined ) {

			// See https://github.com/mrdoob/three.js/issues/21819.
			return texture;

		}

		texture = texture.clone();

		if ( transform.offset !== undefined ) {

			texture.offset.fromArray( transform.offset );

		}

		if ( transform.rotation !== undefined ) {

			texture.rotation = transform.rotation;

		}

		if ( transform.scale !== undefined ) {

			texture.repeat.fromArray( transform.scale );

		}

		texture.needsUpdate = true;

		return texture;

	}

}

/**
 * Specular-Glossiness Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Archived/KHR_materials_pbrSpecularGlossiness
 */

/**
 * A sub class of StandardMaterial with some of the functionality
 * changed via the `onBeforeCompile` callback
 * @pailhead
 */
class GLTFMeshStandardSGMaterial extends three.MeshStandardMaterial {

	constructor( params ) {

		super();

		this.isGLTFSpecularGlossinessMaterial = true;

		//various chunks that need replacing
		const specularMapParsFragmentChunk = [
			'#ifdef USE_SPECULARMAP',
			'	uniform sampler2D specularMap;',
			'#endif'
		].join( '\n' );

		const glossinessMapParsFragmentChunk = [
			'#ifdef USE_GLOSSINESSMAP',
			'	uniform sampler2D glossinessMap;',
			'#endif'
		].join( '\n' );

		const specularMapFragmentChunk = [
			'vec3 specularFactor = specular;',
			'#ifdef USE_SPECULARMAP',
			'	vec4 texelSpecular = texture2D( specularMap, vUv );',
			'	// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture',
			'	specularFactor *= texelSpecular.rgb;',
			'#endif'
		].join( '\n' );

		const glossinessMapFragmentChunk = [
			'float glossinessFactor = glossiness;',
			'#ifdef USE_GLOSSINESSMAP',
			'	vec4 texelGlossiness = texture2D( glossinessMap, vUv );',
			'	// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture',
			'	glossinessFactor *= texelGlossiness.a;',
			'#endif'
		].join( '\n' );

		const lightPhysicalFragmentChunk = [
			'PhysicalMaterial material;',
			'material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );',
			'vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );',
			'float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );',
			'material.roughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.',
			'material.roughness += geometryRoughness;',
			'material.roughness = min( material.roughness, 1.0 );',
			'material.specularColor = specularFactor;',
		].join( '\n' );

		const uniforms = {
			specular: { value: new three.Color().setHex( 0xffffff ) },
			glossiness: { value: 1 },
			specularMap: { value: null },
			glossinessMap: { value: null }
		};

		this._extraUniforms = uniforms;

		this.onBeforeCompile = function ( shader ) {

			for ( const uniformName in uniforms ) {

				shader.uniforms[ uniformName ] = uniforms[ uniformName ];

			}

			shader.fragmentShader = shader.fragmentShader
				.replace( 'uniform float roughness;', 'uniform vec3 specular;' )
				.replace( 'uniform float metalness;', 'uniform float glossiness;' )
				.replace( '#include <roughnessmap_pars_fragment>', specularMapParsFragmentChunk )
				.replace( '#include <metalnessmap_pars_fragment>', glossinessMapParsFragmentChunk )
				.replace( '#include <roughnessmap_fragment>', specularMapFragmentChunk )
				.replace( '#include <metalnessmap_fragment>', glossinessMapFragmentChunk )
				.replace( '#include <lights_physical_fragment>', lightPhysicalFragmentChunk );

		};

		Object.defineProperties( this, {

			specular: {
				get: function () {

					return uniforms.specular.value;

				},
				set: function ( v ) {

					uniforms.specular.value = v;

				}
			},

			specularMap: {
				get: function () {

					return uniforms.specularMap.value;

				},
				set: function ( v ) {

					uniforms.specularMap.value = v;

					if ( v ) {

						this.defines.USE_SPECULARMAP = ''; // USE_UV is set by the renderer for specular maps

					} else {

						delete this.defines.USE_SPECULARMAP;

					}

				}
			},

			glossiness: {
				get: function () {

					return uniforms.glossiness.value;

				},
				set: function ( v ) {

					uniforms.glossiness.value = v;

				}
			},

			glossinessMap: {
				get: function () {

					return uniforms.glossinessMap.value;

				},
				set: function ( v ) {

					uniforms.glossinessMap.value = v;

					if ( v ) {

						this.defines.USE_GLOSSINESSMAP = '';
						this.defines.USE_UV = '';

					} else {

						delete this.defines.USE_GLOSSINESSMAP;
						delete this.defines.USE_UV;

					}

				}
			}

		} );

		delete this.metalness;
		delete this.roughness;
		delete this.metalnessMap;
		delete this.roughnessMap;

		this.setValues( params );

	}

	copy( source ) {

		super.copy( source );

		this.specularMap = source.specularMap;
		this.specular.copy( source.specular );
		this.glossinessMap = source.glossinessMap;
		this.glossiness = source.glossiness;
		delete this.metalness;
		delete this.roughness;
		delete this.metalnessMap;
		delete this.roughnessMap;
		return this;

	}

}


class GLTFMaterialsPbrSpecularGlossinessExtension {

	constructor() {

		this.name = EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS;

		this.specularGlossinessParams = [
			'color',
			'map',
			'lightMap',
			'lightMapIntensity',
			'aoMap',
			'aoMapIntensity',
			'emissive',
			'emissiveIntensity',
			'emissiveMap',
			'bumpMap',
			'bumpScale',
			'normalMap',
			'normalMapType',
			'displacementMap',
			'displacementScale',
			'displacementBias',
			'specularMap',
			'specular',
			'glossinessMap',
			'glossiness',
			'alphaMap',
			'envMap',
			'envMapIntensity',
			'refractionRatio',
		];

	}

	getMaterialType() {

		return GLTFMeshStandardSGMaterial;

	}

	extendParams( materialParams, materialDef, parser ) {

		const pbrSpecularGlossiness = materialDef.extensions[ this.name ];

		materialParams.color = new three.Color( 1.0, 1.0, 1.0 );
		materialParams.opacity = 1.0;

		const pending = [];

		if ( Array.isArray( pbrSpecularGlossiness.diffuseFactor ) ) {

			const array = pbrSpecularGlossiness.diffuseFactor;

			materialParams.color.fromArray( array );
			materialParams.opacity = array[ 3 ];

		}

		if ( pbrSpecularGlossiness.diffuseTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'map', pbrSpecularGlossiness.diffuseTexture ) );

		}

		materialParams.emissive = new three.Color( 0.0, 0.0, 0.0 );
		materialParams.glossiness = pbrSpecularGlossiness.glossinessFactor !== undefined ? pbrSpecularGlossiness.glossinessFactor : 1.0;
		materialParams.specular = new three.Color( 1.0, 1.0, 1.0 );

		if ( Array.isArray( pbrSpecularGlossiness.specularFactor ) ) {

			materialParams.specular.fromArray( pbrSpecularGlossiness.specularFactor );

		}

		if ( pbrSpecularGlossiness.specularGlossinessTexture !== undefined ) {

			const specGlossMapDef = pbrSpecularGlossiness.specularGlossinessTexture;
			pending.push( parser.assignTexture( materialParams, 'glossinessMap', specGlossMapDef ) );
			pending.push( parser.assignTexture( materialParams, 'specularMap', specGlossMapDef ) );

		}

		return Promise.all( pending );

	}

	createMaterial( materialParams ) {

		const material = new GLTFMeshStandardSGMaterial( materialParams );
		material.fog = true;

		material.color = materialParams.color;

		material.map = materialParams.map === undefined ? null : materialParams.map;

		material.lightMap = null;
		material.lightMapIntensity = 1.0;

		material.aoMap = materialParams.aoMap === undefined ? null : materialParams.aoMap;
		material.aoMapIntensity = 1.0;

		material.emissive = materialParams.emissive;
		material.emissiveIntensity = 1.0;
		material.emissiveMap = materialParams.emissiveMap === undefined ? null : materialParams.emissiveMap;

		material.bumpMap = materialParams.bumpMap === undefined ? null : materialParams.bumpMap;
		material.bumpScale = 1;

		material.normalMap = materialParams.normalMap === undefined ? null : materialParams.normalMap;
		material.normalMapType = three.TangentSpaceNormalMap;

		if ( materialParams.normalScale ) material.normalScale = materialParams.normalScale;

		material.displacementMap = null;
		material.displacementScale = 1;
		material.displacementBias = 0;

		material.specularMap = materialParams.specularMap === undefined ? null : materialParams.specularMap;
		material.specular = materialParams.specular;

		material.glossinessMap = materialParams.glossinessMap === undefined ? null : materialParams.glossinessMap;
		material.glossiness = materialParams.glossiness;

		material.alphaMap = null;

		material.envMap = materialParams.envMap === undefined ? null : materialParams.envMap;
		material.envMapIntensity = 1.0;

		material.refractionRatio = 0.98;

		return material;

	}

}

/**
 * Mesh Quantization Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization
 */
class GLTFMeshQuantizationExtension {

	constructor() {

		this.name = EXTENSIONS.KHR_MESH_QUANTIZATION;

	}

}

/*********************************/
/********** INTERPOLATION ********/
/*********************************/

// Spline Interpolation
// Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#appendix-c-spline-interpolation
class GLTFCubicSplineInterpolant extends three.Interpolant {

	constructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

		super( parameterPositions, sampleValues, sampleSize, resultBuffer );

	}

	copySampleValue_( index ) {

		// Copies a sample value to the result buffer. See description of glTF
		// CUBICSPLINE values layout in interpolate_() function below.

		const result = this.resultBuffer,
			values = this.sampleValues,
			valueSize = this.valueSize,
			offset = index * valueSize * 3 + valueSize;

		for ( let i = 0; i !== valueSize; i ++ ) {

			result[ i ] = values[ offset + i ];

		}

		return result;

	}

}

GLTFCubicSplineInterpolant.prototype.beforeStart_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;

GLTFCubicSplineInterpolant.prototype.afterEnd_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;

GLTFCubicSplineInterpolant.prototype.interpolate_ = function ( i1, t0, t, t1 ) {

	const result = this.resultBuffer;
	const values = this.sampleValues;
	const stride = this.valueSize;

	const stride2 = stride * 2;
	const stride3 = stride * 3;

	const td = t1 - t0;

	const p = ( t - t0 ) / td;
	const pp = p * p;
	const ppp = pp * p;

	const offset1 = i1 * stride3;
	const offset0 = offset1 - stride3;

	const s2 = - 2 * ppp + 3 * pp;
	const s3 = ppp - pp;
	const s0 = 1 - s2;
	const s1 = s3 - pp + p;

	// Layout of keyframe output values for CUBICSPLINE animations:
	//   [ inTangent_1, splineVertex_1, outTangent_1, inTangent_2, splineVertex_2, ... ]
	for ( let i = 0; i !== stride; i ++ ) {

		const p0 = values[ offset0 + i + stride ]; // splineVertex_k
		const m0 = values[ offset0 + i + stride2 ] * td; // outTangent_k * (t_k+1 - t_k)
		const p1 = values[ offset1 + i + stride ]; // splineVertex_k+1
		const m1 = values[ offset1 + i ] * td; // inTangent_k+1 * (t_k+1 - t_k)

		result[ i ] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;

	}

	return result;

};

const _q = new three.Quaternion();

class GLTFCubicSplineQuaternionInterpolant extends GLTFCubicSplineInterpolant {

	interpolate_( i1, t0, t, t1 ) {

		const result = super.interpolate_( i1, t0, t, t1 );

		_q.fromArray( result ).normalize().toArray( result );

		return result;

	}

}


/*********************************/
/********** INTERNALS ************/
/*********************************/

/* CONSTANTS */

const WEBGL_CONSTANTS = {
	FLOAT: 5126,
	//FLOAT_MAT2: 35674,
	FLOAT_MAT3: 35675,
	FLOAT_MAT4: 35676,
	FLOAT_VEC2: 35664,
	FLOAT_VEC3: 35665,
	FLOAT_VEC4: 35666,
	LINEAR: 9729,
	REPEAT: 10497,
	SAMPLER_2D: 35678,
	POINTS: 0,
	LINES: 1,
	LINE_LOOP: 2,
	LINE_STRIP: 3,
	TRIANGLES: 4,
	TRIANGLE_STRIP: 5,
	TRIANGLE_FAN: 6,
	UNSIGNED_BYTE: 5121,
	UNSIGNED_SHORT: 5123
};

const WEBGL_COMPONENT_TYPES = {
	5120: Int8Array,
	5121: Uint8Array,
	5122: Int16Array,
	5123: Uint16Array,
	5125: Uint32Array,
	5126: Float32Array
};

const WEBGL_FILTERS = {
	9728: three.NearestFilter,
	9729: three.LinearFilter,
	9984: three.NearestMipmapNearestFilter,
	9985: three.LinearMipmapNearestFilter,
	9986: three.NearestMipmapLinearFilter,
	9987: three.LinearMipmapLinearFilter
};

const WEBGL_WRAPPINGS = {
	33071: three.ClampToEdgeWrapping,
	33648: three.MirroredRepeatWrapping,
	10497: three.RepeatWrapping
};

const WEBGL_TYPE_SIZES = {
	'SCALAR': 1,
	'VEC2': 2,
	'VEC3': 3,
	'VEC4': 4,
	'MAT2': 4,
	'MAT3': 9,
	'MAT4': 16
};

const ATTRIBUTES = {
	POSITION: 'position',
	NORMAL: 'normal',
	TANGENT: 'tangent',
	TEXCOORD_0: 'uv',
	TEXCOORD_1: 'uv2',
	COLOR_0: 'color',
	WEIGHTS_0: 'skinWeight',
	JOINTS_0: 'skinIndex',
};

const PATH_PROPERTIES = {
	scale: 'scale',
	translation: 'position',
	rotation: 'quaternion',
	weights: 'morphTargetInfluences'
};

const INTERPOLATION = {
	CUBICSPLINE: undefined, // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each
		                        // keyframe track will be initialized with a default interpolation type, then modified.
	LINEAR: three.InterpolateLinear,
	STEP: three.InterpolateDiscrete
};

const ALPHA_MODES = {
	OPAQUE: 'OPAQUE',
	MASK: 'MASK',
	BLEND: 'BLEND'
};

/**
 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#default-material
 */
function createDefaultMaterial( cache ) {

	if ( cache[ 'DefaultMaterial' ] === undefined ) {

		cache[ 'DefaultMaterial' ] = new three.MeshStandardMaterial( {
			color: 0xFFFFFF,
			emissive: 0x000000,
			metalness: 1,
			roughness: 1,
			transparent: false,
			depthTest: true,
			side: three.FrontSide
		} );

	}

	return cache[ 'DefaultMaterial' ];

}

function addUnknownExtensionsToUserData( knownExtensions, object, objectDef ) {

	// Add unknown glTF extensions to an object's userData.

	for ( const name in objectDef.extensions ) {

		if ( knownExtensions[ name ] === undefined ) {

			object.userData.gltfExtensions = object.userData.gltfExtensions || {};
			object.userData.gltfExtensions[ name ] = objectDef.extensions[ name ];

		}

	}

}

/**
 * @param {Object3D|Material|BufferGeometry} object
 * @param {GLTF.definition} gltfDef
 */
function assignExtrasToUserData( object, gltfDef ) {

	if ( gltfDef.extras !== undefined ) {

		if ( typeof gltfDef.extras === 'object' ) {

			Object.assign( object.userData, gltfDef.extras );

		} else {

			console.warn( 'THREE.GLTFLoader: Ignoring primitive type .extras, ' + gltfDef.extras );

		}

	}

}

/**
 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#morph-targets
 *
 * @param {BufferGeometry} geometry
 * @param {Array<GLTF.Target>} targets
 * @param {GLTFParser} parser
 * @return {Promise<BufferGeometry>}
 */
function addMorphTargets( geometry, targets, parser ) {

	let hasMorphPosition = false;
	let hasMorphNormal = false;
	let hasMorphColor = false;

	for ( let i = 0, il = targets.length; i < il; i ++ ) {

		const target = targets[ i ];

		if ( target.POSITION !== undefined ) hasMorphPosition = true;
		if ( target.NORMAL !== undefined ) hasMorphNormal = true;
		if ( target.COLOR_0 !== undefined ) hasMorphColor = true;

		if ( hasMorphPosition && hasMorphNormal && hasMorphColor ) break;

	}

	if ( ! hasMorphPosition && ! hasMorphNormal && ! hasMorphColor ) return Promise.resolve( geometry );

	const pendingPositionAccessors = [];
	const pendingNormalAccessors = [];
	const pendingColorAccessors = [];

	for ( let i = 0, il = targets.length; i < il; i ++ ) {

		const target = targets[ i ];

		if ( hasMorphPosition ) {

			const pendingAccessor = target.POSITION !== undefined
				? parser.getDependency( 'accessor', target.POSITION )
				: geometry.attributes.position;

			pendingPositionAccessors.push( pendingAccessor );

		}

		if ( hasMorphNormal ) {

			const pendingAccessor = target.NORMAL !== undefined
				? parser.getDependency( 'accessor', target.NORMAL )
				: geometry.attributes.normal;

			pendingNormalAccessors.push( pendingAccessor );

		}

		if ( hasMorphColor ) {

			const pendingAccessor = target.COLOR_0 !== undefined
				? parser.getDependency( 'accessor', target.COLOR_0 )
				: geometry.attributes.color;

			pendingColorAccessors.push( pendingAccessor );

		}

	}

	return Promise.all( [
		Promise.all( pendingPositionAccessors ),
		Promise.all( pendingNormalAccessors ),
		Promise.all( pendingColorAccessors )
	] ).then( function ( accessors ) {

		const morphPositions = accessors[ 0 ];
		const morphNormals = accessors[ 1 ];
		const morphColors = accessors[ 2 ];

		if ( hasMorphPosition ) geometry.morphAttributes.position = morphPositions;
		if ( hasMorphNormal ) geometry.morphAttributes.normal = morphNormals;
		if ( hasMorphColor ) geometry.morphAttributes.color = morphColors;
		geometry.morphTargetsRelative = true;

		return geometry;

	} );

}

/**
 * @param {Mesh} mesh
 * @param {GLTF.Mesh} meshDef
 */
function updateMorphTargets( mesh, meshDef ) {

	mesh.updateMorphTargets();

	if ( meshDef.weights !== undefined ) {

		for ( let i = 0, il = meshDef.weights.length; i < il; i ++ ) {

			mesh.morphTargetInfluences[ i ] = meshDef.weights[ i ];

		}

	}

	// .extras has user-defined data, so check that .extras.targetNames is an array.
	if ( meshDef.extras && Array.isArray( meshDef.extras.targetNames ) ) {

		const targetNames = meshDef.extras.targetNames;

		if ( mesh.morphTargetInfluences.length === targetNames.length ) {

			mesh.morphTargetDictionary = {};

			for ( let i = 0, il = targetNames.length; i < il; i ++ ) {

				mesh.morphTargetDictionary[ targetNames[ i ] ] = i;

			}

		} else {

			console.warn( 'THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.' );

		}

	}

}

function createPrimitiveKey( primitiveDef ) {

	const dracoExtension = primitiveDef.extensions && primitiveDef.extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ];
	let geometryKey;

	if ( dracoExtension ) {

		geometryKey = 'draco:' + dracoExtension.bufferView
				+ ':' + dracoExtension.indices
				+ ':' + createAttributesKey( dracoExtension.attributes );

	} else {

		geometryKey = primitiveDef.indices + ':' + createAttributesKey( primitiveDef.attributes ) + ':' + primitiveDef.mode;

	}

	return geometryKey;

}

function createAttributesKey( attributes ) {

	let attributesKey = '';

	const keys = Object.keys( attributes ).sort();

	for ( let i = 0, il = keys.length; i < il; i ++ ) {

		attributesKey += keys[ i ] + ':' + attributes[ keys[ i ] ] + ';';

	}

	return attributesKey;

}

function getNormalizedComponentScale( constructor ) {

	// Reference:
	// https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization#encoding-quantized-data

	switch ( constructor ) {

		case Int8Array:
			return 1 / 127;

		case Uint8Array:
			return 1 / 255;

		case Int16Array:
			return 1 / 32767;

		case Uint16Array:
			return 1 / 65535;

		default:
			throw new Error( 'THREE.GLTFLoader: Unsupported normalized accessor component type.' );

	}

}

function getImageURIMimeType( uri ) {

	if ( uri.search( /\.jpe?g($|\?)/i ) > 0 || uri.search( /^data\:image\/jpeg/ ) === 0 ) return 'image/jpeg';
	if ( uri.search( /\.webp($|\?)/i ) > 0 || uri.search( /^data\:image\/webp/ ) === 0 ) return 'image/webp';

	return 'image/png';

}

/* GLTF PARSER */

class GLTFParser {

	constructor( json = {}, options = {} ) {

		this.json = json;
		this.extensions = {};
		this.plugins = {};
		this.options = options;

		// loader object cache
		this.cache = new GLTFRegistry();

		// associations between Three.js objects and glTF elements
		this.associations = new Map();

		// BufferGeometry caching
		this.primitiveCache = {};

		// Object3D instance caches
		this.meshCache = { refs: {}, uses: {} };
		this.cameraCache = { refs: {}, uses: {} };
		this.lightCache = { refs: {}, uses: {} };

		this.sourceCache = {};
		this.textureCache = {};

		// Track node names, to ensure no duplicates
		this.nodeNamesUsed = {};

		// Use an ImageBitmapLoader if imageBitmaps are supported. Moves much of the
		// expensive work of uploading a texture to the GPU off the main thread.
		if ( typeof createImageBitmap !== 'undefined' && /Firefox|^((?!chrome|android).)*safari/i.test( navigator.userAgent ) === false ) {

			this.textureLoader = new three.ImageBitmapLoader( this.options.manager );

		} else {

			this.textureLoader = new three.TextureLoader( this.options.manager );

		}

		this.textureLoader.setCrossOrigin( this.options.crossOrigin );
		this.textureLoader.setRequestHeader( this.options.requestHeader );

		this.fileLoader = new three.FileLoader( this.options.manager );
		this.fileLoader.setResponseType( 'arraybuffer' );

		if ( this.options.crossOrigin === 'use-credentials' ) {

			this.fileLoader.setWithCredentials( true );

		}

	}

	setExtensions( extensions ) {

		this.extensions = extensions;

	}

	setPlugins( plugins ) {

		this.plugins = plugins;

	}

	parse( onLoad, onError ) {

		const parser = this;
		const json = this.json;
		const extensions = this.extensions;

		// Clear the loader cache
		this.cache.removeAll();

		// Mark the special nodes/meshes in json for efficient parse
		this._invokeAll( function ( ext ) {

			return ext._markDefs && ext._markDefs();

		} );

		Promise.all( this._invokeAll( function ( ext ) {

			return ext.beforeRoot && ext.beforeRoot();

		} ) ).then( function () {

			return Promise.all( [

				parser.getDependencies( 'scene' ),
				parser.getDependencies( 'animation' ),
				parser.getDependencies( 'camera' ),

			] );

		} ).then( function ( dependencies ) {

			const result = {
				scene: dependencies[ 0 ][ json.scene || 0 ],
				scenes: dependencies[ 0 ],
				animations: dependencies[ 1 ],
				cameras: dependencies[ 2 ],
				asset: json.asset,
				parser: parser,
				userData: {}
			};

			addUnknownExtensionsToUserData( extensions, result, json );

			assignExtrasToUserData( result, json );

			Promise.all( parser._invokeAll( function ( ext ) {

				return ext.afterRoot && ext.afterRoot( result );

			} ) ).then( function () {

				onLoad( result );

			} );

		} ).catch( onError );

	}

	/**
	 * Marks the special nodes/meshes in json for efficient parse.
	 */
	_markDefs() {

		const nodeDefs = this.json.nodes || [];
		const skinDefs = this.json.skins || [];
		const meshDefs = this.json.meshes || [];

		// Nothing in the node definition indicates whether it is a Bone or an
		// Object3D. Use the skins' joint references to mark bones.
		for ( let skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex ++ ) {

			const joints = skinDefs[ skinIndex ].joints;

			for ( let i = 0, il = joints.length; i < il; i ++ ) {

				nodeDefs[ joints[ i ] ].isBone = true;

			}

		}

		// Iterate over all nodes, marking references to shared resources,
		// as well as skeleton joints.
		for ( let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex ++ ) {

			const nodeDef = nodeDefs[ nodeIndex ];

			if ( nodeDef.mesh !== undefined ) {

				this._addNodeRef( this.meshCache, nodeDef.mesh );

				// Nothing in the mesh definition indicates whether it is
				// a SkinnedMesh or Mesh. Use the node's mesh reference
				// to mark SkinnedMesh if node has skin.
				if ( nodeDef.skin !== undefined ) {

					meshDefs[ nodeDef.mesh ].isSkinnedMesh = true;

				}

			}

			if ( nodeDef.camera !== undefined ) {

				this._addNodeRef( this.cameraCache, nodeDef.camera );

			}

		}

	}

	/**
	 * Counts references to shared node / Object3D resources. These resources
	 * can be reused, or "instantiated", at multiple nodes in the scene
	 * hierarchy. Mesh, Camera, and Light instances are instantiated and must
	 * be marked. Non-scenegraph resources (like Materials, Geometries, and
	 * Textures) can be reused directly and are not marked here.
	 *
	 * Example: CesiumMilkTruck sample model reuses "Wheel" meshes.
	 */
	_addNodeRef( cache, index ) {

		if ( index === undefined ) return;

		if ( cache.refs[ index ] === undefined ) {

			cache.refs[ index ] = cache.uses[ index ] = 0;

		}

		cache.refs[ index ] ++;

	}

	/** Returns a reference to a shared resource, cloning it if necessary. */
	_getNodeRef( cache, index, object ) {

		if ( cache.refs[ index ] <= 1 ) return object;

		const ref = object.clone();

		// Propagates mappings to the cloned object, prevents mappings on the
		// original object from being lost.
		const updateMappings = ( original, clone ) => {

			const mappings = this.associations.get( original );
			if ( mappings != null ) {

				this.associations.set( clone, mappings );

			}

			for ( const [ i, child ] of original.children.entries() ) {

				updateMappings( child, clone.children[ i ] );

			}

		};

		updateMappings( object, ref );

		ref.name += '_instance_' + ( cache.uses[ index ] ++ );

		return ref;

	}

	_invokeOne( func ) {

		const extensions = Object.values( this.plugins );
		extensions.push( this );

		for ( let i = 0; i < extensions.length; i ++ ) {

			const result = func( extensions[ i ] );

			if ( result ) return result;

		}

		return null;

	}

	_invokeAll( func ) {

		const extensions = Object.values( this.plugins );
		extensions.unshift( this );

		const pending = [];

		for ( let i = 0; i < extensions.length; i ++ ) {

			const result = func( extensions[ i ] );

			if ( result ) pending.push( result );

		}

		return pending;

	}

	/**
	 * Requests the specified dependency asynchronously, with caching.
	 * @param {string} type
	 * @param {number} index
	 * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}
	 */
	getDependency( type, index ) {

		const cacheKey = type + ':' + index;
		let dependency = this.cache.get( cacheKey );

		if ( ! dependency ) {

			switch ( type ) {

				case 'scene':
					dependency = this.loadScene( index );
					break;

				case 'node':
					dependency = this.loadNode( index );
					break;

				case 'mesh':
					dependency = this._invokeOne( function ( ext ) {

						return ext.loadMesh && ext.loadMesh( index );

					} );
					break;

				case 'accessor':
					dependency = this.loadAccessor( index );
					break;

				case 'bufferView':
					dependency = this._invokeOne( function ( ext ) {

						return ext.loadBufferView && ext.loadBufferView( index );

					} );
					break;

				case 'buffer':
					dependency = this.loadBuffer( index );
					break;

				case 'material':
					dependency = this._invokeOne( function ( ext ) {

						return ext.loadMaterial && ext.loadMaterial( index );

					} );
					break;

				case 'texture':
					dependency = this._invokeOne( function ( ext ) {

						return ext.loadTexture && ext.loadTexture( index );

					} );
					break;

				case 'skin':
					dependency = this.loadSkin( index );
					break;

				case 'animation':
					dependency = this.loadAnimation( index );
					break;

				case 'camera':
					dependency = this.loadCamera( index );
					break;

				default:
					throw new Error( 'Unknown type: ' + type );

			}

			this.cache.add( cacheKey, dependency );

		}

		return dependency;

	}

	/**
	 * Requests all dependencies of the specified type asynchronously, with caching.
	 * @param {string} type
	 * @return {Promise<Array<Object>>}
	 */
	getDependencies( type ) {

		let dependencies = this.cache.get( type );

		if ( ! dependencies ) {

			const parser = this;
			const defs = this.json[ type + ( type === 'mesh' ? 'es' : 's' ) ] || [];

			dependencies = Promise.all( defs.map( function ( def, index ) {

				return parser.getDependency( type, index );

			} ) );

			this.cache.add( type, dependencies );

		}

		return dependencies;

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
	 * @param {number} bufferIndex
	 * @return {Promise<ArrayBuffer>}
	 */
	loadBuffer( bufferIndex ) {

		const bufferDef = this.json.buffers[ bufferIndex ];
		const loader = this.fileLoader;

		if ( bufferDef.type && bufferDef.type !== 'arraybuffer' ) {

			throw new Error( 'THREE.GLTFLoader: ' + bufferDef.type + ' buffer type is not supported.' );

		}

		// If present, GLB container is required to be the first buffer.
		if ( bufferDef.uri === undefined && bufferIndex === 0 ) {

			return Promise.resolve( this.extensions[ EXTENSIONS.KHR_BINARY_GLTF ].body );

		}

		const options = this.options;

		return new Promise( function ( resolve, reject ) {

			loader.load( three.LoaderUtils.resolveURL( bufferDef.uri, options.path ), resolve, undefined, function () {

				reject( new Error( 'THREE.GLTFLoader: Failed to load buffer "' + bufferDef.uri + '".' ) );

			} );

		} );

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
	 * @param {number} bufferViewIndex
	 * @return {Promise<ArrayBuffer>}
	 */
	loadBufferView( bufferViewIndex ) {

		const bufferViewDef = this.json.bufferViews[ bufferViewIndex ];

		return this.getDependency( 'buffer', bufferViewDef.buffer ).then( function ( buffer ) {

			const byteLength = bufferViewDef.byteLength || 0;
			const byteOffset = bufferViewDef.byteOffset || 0;
			return buffer.slice( byteOffset, byteOffset + byteLength );

		} );

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors
	 * @param {number} accessorIndex
	 * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}
	 */
	loadAccessor( accessorIndex ) {

		const parser = this;
		const json = this.json;

		const accessorDef = this.json.accessors[ accessorIndex ];

		if ( accessorDef.bufferView === undefined && accessorDef.sparse === undefined ) {

			// Ignore empty accessors, which may be used to declare runtime
			// information about attributes coming from another source (e.g. Draco
			// compression extension).
			return Promise.resolve( null );

		}

		const pendingBufferViews = [];

		if ( accessorDef.bufferView !== undefined ) {

			pendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.bufferView ) );

		} else {

			pendingBufferViews.push( null );

		}

		if ( accessorDef.sparse !== undefined ) {

			pendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.sparse.indices.bufferView ) );
			pendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.sparse.values.bufferView ) );

		}

		return Promise.all( pendingBufferViews ).then( function ( bufferViews ) {

			const bufferView = bufferViews[ 0 ];

			const itemSize = WEBGL_TYPE_SIZES[ accessorDef.type ];
			const TypedArray = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];

			// For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.
			const elementBytes = TypedArray.BYTES_PER_ELEMENT;
			const itemBytes = elementBytes * itemSize;
			const byteOffset = accessorDef.byteOffset || 0;
			const byteStride = accessorDef.bufferView !== undefined ? json.bufferViews[ accessorDef.bufferView ].byteStride : undefined;
			const normalized = accessorDef.normalized === true;
			let array, bufferAttribute;

			// The buffer is not interleaved if the stride is the item size in bytes.
			if ( byteStride && byteStride !== itemBytes ) {

				// Each "slice" of the buffer, as defined by 'count' elements of 'byteStride' bytes, gets its own InterleavedBuffer
				// This makes sure that IBA.count reflects accessor.count properly
				const ibSlice = Math.floor( byteOffset / byteStride );
				const ibCacheKey = 'InterleavedBuffer:' + accessorDef.bufferView + ':' + accessorDef.componentType + ':' + ibSlice + ':' + accessorDef.count;
				let ib = parser.cache.get( ibCacheKey );

				if ( ! ib ) {

					array = new TypedArray( bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes );

					// Integer parameters to IB/IBA are in array elements, not bytes.
					ib = new three.InterleavedBuffer( array, byteStride / elementBytes );

					parser.cache.add( ibCacheKey, ib );

				}

				bufferAttribute = new three.InterleavedBufferAttribute( ib, itemSize, ( byteOffset % byteStride ) / elementBytes, normalized );

			} else {

				if ( bufferView === null ) {

					array = new TypedArray( accessorDef.count * itemSize );

				} else {

					array = new TypedArray( bufferView, byteOffset, accessorDef.count * itemSize );

				}

				bufferAttribute = new three.BufferAttribute( array, itemSize, normalized );

			}

			// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#sparse-accessors
			if ( accessorDef.sparse !== undefined ) {

				const itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;
				const TypedArrayIndices = WEBGL_COMPONENT_TYPES[ accessorDef.sparse.indices.componentType ];

				const byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;
				const byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;

				const sparseIndices = new TypedArrayIndices( bufferViews[ 1 ], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices );
				const sparseValues = new TypedArray( bufferViews[ 2 ], byteOffsetValues, accessorDef.sparse.count * itemSize );

				if ( bufferView !== null ) {

					// Avoid modifying the original ArrayBuffer, if the bufferView wasn't initialized with zeroes.
					bufferAttribute = new three.BufferAttribute( bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized );

				}

				for ( let i = 0, il = sparseIndices.length; i < il; i ++ ) {

					const index = sparseIndices[ i ];

					bufferAttribute.setX( index, sparseValues[ i * itemSize ] );
					if ( itemSize >= 2 ) bufferAttribute.setY( index, sparseValues[ i * itemSize + 1 ] );
					if ( itemSize >= 3 ) bufferAttribute.setZ( index, sparseValues[ i * itemSize + 2 ] );
					if ( itemSize >= 4 ) bufferAttribute.setW( index, sparseValues[ i * itemSize + 3 ] );
					if ( itemSize >= 5 ) throw new Error( 'THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.' );

				}

			}

			return bufferAttribute;

		} );

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures
	 * @param {number} textureIndex
	 * @return {Promise<THREE.Texture>}
	 */
	loadTexture( textureIndex ) {

		const json = this.json;
		const options = this.options;
		const textureDef = json.textures[ textureIndex ];
		const sourceIndex = textureDef.source;
		const sourceDef = json.images[ sourceIndex ];

		let loader = this.textureLoader;

		if ( sourceDef.uri ) {

			const handler = options.manager.getHandler( sourceDef.uri );
			if ( handler !== null ) loader = handler;

		}

		return this.loadTextureImage( textureIndex, sourceIndex, loader );

	}

	loadTextureImage( textureIndex, sourceIndex, loader ) {

		const parser = this;
		const json = this.json;

		const textureDef = json.textures[ textureIndex ];
		const sourceDef = json.images[ sourceIndex ];

		const cacheKey = ( sourceDef.uri || sourceDef.bufferView ) + ':' + textureDef.sampler;

		if ( this.textureCache[ cacheKey ] ) {

			// See https://github.com/mrdoob/three.js/issues/21559.
			return this.textureCache[ cacheKey ];

		}

		const promise = this.loadImageSource( sourceIndex, loader ).then( function ( texture ) {

			texture.flipY = false;

			if ( textureDef.name ) texture.name = textureDef.name;

			const samplers = json.samplers || {};
			const sampler = samplers[ textureDef.sampler ] || {};

			texture.magFilter = WEBGL_FILTERS[ sampler.magFilter ] || three.LinearFilter;
			texture.minFilter = WEBGL_FILTERS[ sampler.minFilter ] || three.LinearMipmapLinearFilter;
			texture.wrapS = WEBGL_WRAPPINGS[ sampler.wrapS ] || three.RepeatWrapping;
			texture.wrapT = WEBGL_WRAPPINGS[ sampler.wrapT ] || three.RepeatWrapping;

			parser.associations.set( texture, { textures: textureIndex } );

			return texture;

		} ).catch( function () {

			return null;

		} );

		this.textureCache[ cacheKey ] = promise;

		return promise;

	}

	loadImageSource( sourceIndex, loader ) {

		const parser = this;
		const json = this.json;
		const options = this.options;

		if ( this.sourceCache[ sourceIndex ] !== undefined ) {

			return this.sourceCache[ sourceIndex ].then( function ( texture ) {

				return texture.clone();

			} ).catch( function ( error ) {

				throw error;

			} );

		}

		const sourceDef = json.images[ sourceIndex ];

		const URL = self.URL || self.webkitURL;

		let sourceURI = sourceDef.uri || '';
		let isObjectURL = false;

		if ( sourceDef.bufferView !== undefined ) {

			// Load binary image data from bufferView, if provided.

			sourceURI = parser.getDependency( 'bufferView', sourceDef.bufferView ).then( function ( bufferView ) {

				isObjectURL = true;
				const blob = new Blob( [ bufferView ], { type: sourceDef.mimeType } );
				sourceURI = URL.createObjectURL( blob );
				return sourceURI;

			} );

		} else if ( sourceDef.uri === undefined ) {

			throw new Error( 'THREE.GLTFLoader: Image ' + sourceIndex + ' is missing URI and bufferView' );

		}

		const promise = Promise.resolve( sourceURI ).then( function ( sourceURI ) {

			return new Promise( function ( resolve, reject ) {

				let onLoad = resolve;

				if ( loader.isImageBitmapLoader === true ) {

					onLoad = function ( imageBitmap ) {

						const texture = new three.Texture( imageBitmap );
						texture.needsUpdate = true;

						resolve( texture );

					};

				}

				loader.load( three.LoaderUtils.resolveURL( sourceURI, options.path ), onLoad, undefined, reject );

			} );

		} ).then( function ( texture ) {

			// Clean up resources and configure Texture.

			if ( isObjectURL === true ) {

				URL.revokeObjectURL( sourceURI );

			}

			texture.userData.mimeType = sourceDef.mimeType || getImageURIMimeType( sourceDef.uri );

			return texture;

		} ).catch( function ( error ) {

			console.error( 'THREE.GLTFLoader: Couldn\'t load texture', sourceURI );
			throw error;

		} );

		this.sourceCache[ sourceIndex ] = promise;
		return promise;

	}

	/**
	 * Asynchronously assigns a texture to the given material parameters.
	 * @param {Object} materialParams
	 * @param {string} mapName
	 * @param {Object} mapDef
	 * @return {Promise<Texture>}
	 */
	assignTexture( materialParams, mapName, mapDef ) {

		const parser = this;

		return this.getDependency( 'texture', mapDef.index ).then( function ( texture ) {

			// Materials sample aoMap from UV set 1 and other maps from UV set 0 - this can't be configured
			// However, we will copy UV set 0 to UV set 1 on demand for aoMap
			if ( mapDef.texCoord !== undefined && mapDef.texCoord != 0 && ! ( mapName === 'aoMap' && mapDef.texCoord == 1 ) ) {

				console.warn( 'THREE.GLTFLoader: Custom UV set ' + mapDef.texCoord + ' for texture ' + mapName + ' not yet supported.' );

			}

			if ( parser.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ] ) {

				const transform = mapDef.extensions !== undefined ? mapDef.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ] : undefined;

				if ( transform ) {

					const gltfReference = parser.associations.get( texture );
					texture = parser.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ].extendTexture( texture, transform );
					parser.associations.set( texture, gltfReference );

				}

			}

			materialParams[ mapName ] = texture;

			return texture;

		} );

	}

	/**
	 * Assigns final material to a Mesh, Line, or Points instance. The instance
	 * already has a material (generated from the glTF material options alone)
	 * but reuse of the same glTF material may require multiple threejs materials
	 * to accommodate different primitive types, defines, etc. New materials will
	 * be created if necessary, and reused from a cache.
	 * @param  {Object3D} mesh Mesh, Line, or Points instance.
	 */
	assignFinalMaterial( mesh ) {

		const geometry = mesh.geometry;
		let material = mesh.material;

		const useDerivativeTangents = geometry.attributes.tangent === undefined;
		const useVertexColors = geometry.attributes.color !== undefined;
		const useFlatShading = geometry.attributes.normal === undefined;

		if ( mesh.isPoints ) {

			const cacheKey = 'PointsMaterial:' + material.uuid;

			let pointsMaterial = this.cache.get( cacheKey );

			if ( ! pointsMaterial ) {

				pointsMaterial = new three.PointsMaterial();
				three.Material.prototype.copy.call( pointsMaterial, material );
				pointsMaterial.color.copy( material.color );
				pointsMaterial.map = material.map;
				pointsMaterial.sizeAttenuation = false; // glTF spec says points should be 1px

				this.cache.add( cacheKey, pointsMaterial );

			}

			material = pointsMaterial;

		} else if ( mesh.isLine ) {

			const cacheKey = 'LineBasicMaterial:' + material.uuid;

			let lineMaterial = this.cache.get( cacheKey );

			if ( ! lineMaterial ) {

				lineMaterial = new three.LineBasicMaterial();
				three.Material.prototype.copy.call( lineMaterial, material );
				lineMaterial.color.copy( material.color );

				this.cache.add( cacheKey, lineMaterial );

			}

			material = lineMaterial;

		}

		// Clone the material if it will be modified
		if ( useDerivativeTangents || useVertexColors || useFlatShading ) {

			let cacheKey = 'ClonedMaterial:' + material.uuid + ':';

			if ( material.isGLTFSpecularGlossinessMaterial ) cacheKey += 'specular-glossiness:';
			if ( useDerivativeTangents ) cacheKey += 'derivative-tangents:';
			if ( useVertexColors ) cacheKey += 'vertex-colors:';
			if ( useFlatShading ) cacheKey += 'flat-shading:';

			let cachedMaterial = this.cache.get( cacheKey );

			if ( ! cachedMaterial ) {

				cachedMaterial = material.clone();

				if ( useVertexColors ) cachedMaterial.vertexColors = true;
				if ( useFlatShading ) cachedMaterial.flatShading = true;

				if ( useDerivativeTangents ) {

					// https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995
					if ( cachedMaterial.normalScale ) cachedMaterial.normalScale.y *= - 1;
					if ( cachedMaterial.clearcoatNormalScale ) cachedMaterial.clearcoatNormalScale.y *= - 1;

				}

				this.cache.add( cacheKey, cachedMaterial );

				this.associations.set( cachedMaterial, this.associations.get( material ) );

			}

			material = cachedMaterial;

		}

		// workarounds for mesh and geometry

		if ( material.aoMap && geometry.attributes.uv2 === undefined && geometry.attributes.uv !== undefined ) {

			geometry.setAttribute( 'uv2', geometry.attributes.uv );

		}

		mesh.material = material;

	}

	getMaterialType( /* materialIndex */ ) {

		return three.MeshStandardMaterial;

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials
	 * @param {number} materialIndex
	 * @return {Promise<Material>}
	 */
	loadMaterial( materialIndex ) {

		const parser = this;
		const json = this.json;
		const extensions = this.extensions;
		const materialDef = json.materials[ materialIndex ];

		let materialType;
		const materialParams = {};
		const materialExtensions = materialDef.extensions || {};

		const pending = [];

		if ( materialExtensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ] ) {

			const sgExtension = extensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ];
			materialType = sgExtension.getMaterialType();
			pending.push( sgExtension.extendParams( materialParams, materialDef, parser ) );

		} else if ( materialExtensions[ EXTENSIONS.KHR_MATERIALS_UNLIT ] ) {

			const kmuExtension = extensions[ EXTENSIONS.KHR_MATERIALS_UNLIT ];
			materialType = kmuExtension.getMaterialType();
			pending.push( kmuExtension.extendParams( materialParams, materialDef, parser ) );

		} else {

			// Specification:
			// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#metallic-roughness-material

			const metallicRoughness = materialDef.pbrMetallicRoughness || {};

			materialParams.color = new three.Color( 1.0, 1.0, 1.0 );
			materialParams.opacity = 1.0;

			if ( Array.isArray( metallicRoughness.baseColorFactor ) ) {

				const array = metallicRoughness.baseColorFactor;

				materialParams.color.fromArray( array );
				materialParams.opacity = array[ 3 ];

			}

			if ( metallicRoughness.baseColorTexture !== undefined ) {

				pending.push( parser.assignTexture( materialParams, 'map', metallicRoughness.baseColorTexture ) );

			}

			materialParams.metalness = metallicRoughness.metallicFactor !== undefined ? metallicRoughness.metallicFactor : 1.0;
			materialParams.roughness = metallicRoughness.roughnessFactor !== undefined ? metallicRoughness.roughnessFactor : 1.0;

			if ( metallicRoughness.metallicRoughnessTexture !== undefined ) {

				pending.push( parser.assignTexture( materialParams, 'metalnessMap', metallicRoughness.metallicRoughnessTexture ) );
				pending.push( parser.assignTexture( materialParams, 'roughnessMap', metallicRoughness.metallicRoughnessTexture ) );

			}

			materialType = this._invokeOne( function ( ext ) {

				return ext.getMaterialType && ext.getMaterialType( materialIndex );

			} );

			pending.push( Promise.all( this._invokeAll( function ( ext ) {

				return ext.extendMaterialParams && ext.extendMaterialParams( materialIndex, materialParams );

			} ) ) );

		}

		if ( materialDef.doubleSided === true ) {

			materialParams.side = three.DoubleSide;

		}

		const alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;

		if ( alphaMode === ALPHA_MODES.BLEND ) {

			materialParams.transparent = true;

			// See: https://github.com/mrdoob/three.js/issues/17706
			materialParams.depthWrite = false;

		} else {

			materialParams.transparent = false;

			if ( alphaMode === ALPHA_MODES.MASK ) {

				materialParams.alphaTest = materialDef.alphaCutoff !== undefined ? materialDef.alphaCutoff : 0.5;

			}

		}

		if ( materialDef.normalTexture !== undefined && materialType !== three.MeshBasicMaterial ) {

			pending.push( parser.assignTexture( materialParams, 'normalMap', materialDef.normalTexture ) );

			materialParams.normalScale = new three.Vector2( 1, 1 );

			if ( materialDef.normalTexture.scale !== undefined ) {

				const scale = materialDef.normalTexture.scale;

				materialParams.normalScale.set( scale, scale );

			}

		}

		if ( materialDef.occlusionTexture !== undefined && materialType !== three.MeshBasicMaterial ) {

			pending.push( parser.assignTexture( materialParams, 'aoMap', materialDef.occlusionTexture ) );

			if ( materialDef.occlusionTexture.strength !== undefined ) {

				materialParams.aoMapIntensity = materialDef.occlusionTexture.strength;

			}

		}

		if ( materialDef.emissiveFactor !== undefined && materialType !== three.MeshBasicMaterial ) {

			materialParams.emissive = new three.Color().fromArray( materialDef.emissiveFactor );

		}

		if ( materialDef.emissiveTexture !== undefined && materialType !== three.MeshBasicMaterial ) {

			pending.push( parser.assignTexture( materialParams, 'emissiveMap', materialDef.emissiveTexture ) );

		}

		return Promise.all( pending ).then( function () {

			let material;

			if ( materialType === GLTFMeshStandardSGMaterial ) {

				material = extensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ].createMaterial( materialParams );

			} else {

				material = new materialType( materialParams );

			}

			if ( materialDef.name ) material.name = materialDef.name;

			// baseColorTexture, emissiveTexture, sheenColorMap, specularColorMap and specularGlossinessTexture use sRGB encoding.
			if ( material.map ) material.map.encoding = three.sRGBEncoding;
			if ( material.emissiveMap ) material.emissiveMap.encoding = three.sRGBEncoding;
			if ( material.sheenColorMap ) material.sheenColorMap.encoding = three.sRGBEncoding;
			if ( material.specularColorMap ) material.specularColorMap.encoding = three.sRGBEncoding;
			if ( material.specularMap ) material.specularMap.encoding = three.sRGBEncoding;

			assignExtrasToUserData( material, materialDef );

			parser.associations.set( material, { materials: materialIndex } );

			if ( materialDef.extensions ) addUnknownExtensionsToUserData( extensions, material, materialDef );

			return material;

		} );

	}

	/** When Object3D instances are targeted by animation, they need unique names. */
	createUniqueName( originalName ) {

		const sanitizedName = three.PropertyBinding.sanitizeNodeName( originalName || '' );

		let name = sanitizedName;

		for ( let i = 1; this.nodeNamesUsed[ name ]; ++ i ) {

			name = sanitizedName + '_' + i;

		}

		this.nodeNamesUsed[ name ] = true;

		return name;

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry
	 *
	 * Creates BufferGeometries from primitives.
	 *
	 * @param {Array<GLTF.Primitive>} primitives
	 * @return {Promise<Array<BufferGeometry>>}
	 */
	loadGeometries( primitives ) {

		const parser = this;
		const extensions = this.extensions;
		const cache = this.primitiveCache;

		function createDracoPrimitive( primitive ) {

			return extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ]
				.decodePrimitive( primitive, parser )
				.then( function ( geometry ) {

					return addPrimitiveAttributes( geometry, primitive, parser );

				} );

		}

		const pending = [];

		for ( let i = 0, il = primitives.length; i < il; i ++ ) {

			const primitive = primitives[ i ];
			const cacheKey = createPrimitiveKey( primitive );

			// See if we've already created this geometry
			const cached = cache[ cacheKey ];

			if ( cached ) {

				// Use the cached geometry if it exists
				pending.push( cached.promise );

			} else {

				let geometryPromise;

				if ( primitive.extensions && primitive.extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ] ) {

					// Use DRACO geometry if available
					geometryPromise = createDracoPrimitive( primitive );

				} else {

					// Otherwise create a new geometry
					geometryPromise = addPrimitiveAttributes( new three.BufferGeometry(), primitive, parser );

				}

				// Cache this geometry
				cache[ cacheKey ] = { primitive: primitive, promise: geometryPromise };

				pending.push( geometryPromise );

			}

		}

		return Promise.all( pending );

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes
	 * @param {number} meshIndex
	 * @return {Promise<Group|Mesh|SkinnedMesh>}
	 */
	loadMesh( meshIndex ) {

		const parser = this;
		const json = this.json;
		const extensions = this.extensions;

		const meshDef = json.meshes[ meshIndex ];
		const primitives = meshDef.primitives;

		const pending = [];

		for ( let i = 0, il = primitives.length; i < il; i ++ ) {

			const material = primitives[ i ].material === undefined
				? createDefaultMaterial( this.cache )
				: this.getDependency( 'material', primitives[ i ].material );

			pending.push( material );

		}

		pending.push( parser.loadGeometries( primitives ) );

		return Promise.all( pending ).then( function ( results ) {

			const materials = results.slice( 0, results.length - 1 );
			const geometries = results[ results.length - 1 ];

			const meshes = [];

			for ( let i = 0, il = geometries.length; i < il; i ++ ) {

				const geometry = geometries[ i ];
				const primitive = primitives[ i ];

				// 1. create Mesh

				let mesh;

				const material = materials[ i ];

				if ( primitive.mode === WEBGL_CONSTANTS.TRIANGLES ||
						primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ||
						primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ||
						primitive.mode === undefined ) {

					// .isSkinnedMesh isn't in glTF spec. See ._markDefs()
					mesh = meshDef.isSkinnedMesh === true
						? new three.SkinnedMesh( geometry, material )
						: new three.Mesh( geometry, material );

					if ( mesh.isSkinnedMesh === true && ! mesh.geometry.attributes.skinWeight.normalized ) {

						// we normalize floating point skin weight array to fix malformed assets (see #15319)
						// it's important to skip this for non-float32 data since normalizeSkinWeights assumes non-normalized inputs
						mesh.normalizeSkinWeights();

					}

					if ( primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ) {

						mesh.geometry = toTrianglesDrawMode( mesh.geometry, three.TriangleStripDrawMode );

					} else if ( primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ) {

						mesh.geometry = toTrianglesDrawMode( mesh.geometry, three.TriangleFanDrawMode );

					}

				} else if ( primitive.mode === WEBGL_CONSTANTS.LINES ) {

					mesh = new three.LineSegments( geometry, material );

				} else if ( primitive.mode === WEBGL_CONSTANTS.LINE_STRIP ) {

					mesh = new three.Line( geometry, material );

				} else if ( primitive.mode === WEBGL_CONSTANTS.LINE_LOOP ) {

					mesh = new three.LineLoop( geometry, material );

				} else if ( primitive.mode === WEBGL_CONSTANTS.POINTS ) {

					mesh = new three.Points( geometry, material );

				} else {

					throw new Error( 'THREE.GLTFLoader: Primitive mode unsupported: ' + primitive.mode );

				}

				if ( Object.keys( mesh.geometry.morphAttributes ).length > 0 ) {

					updateMorphTargets( mesh, meshDef );

				}

				mesh.name = parser.createUniqueName( meshDef.name || ( 'mesh_' + meshIndex ) );

				assignExtrasToUserData( mesh, meshDef );

				if ( primitive.extensions ) addUnknownExtensionsToUserData( extensions, mesh, primitive );

				parser.assignFinalMaterial( mesh );

				meshes.push( mesh );

			}

			for ( let i = 0, il = meshes.length; i < il; i ++ ) {

				parser.associations.set( meshes[ i ], {
					meshes: meshIndex,
					primitives: i
				} );

			}

			if ( meshes.length === 1 ) {

				return meshes[ 0 ];

			}

			const group = new three.Group();

			parser.associations.set( group, { meshes: meshIndex } );

			for ( let i = 0, il = meshes.length; i < il; i ++ ) {

				group.add( meshes[ i ] );

			}

			return group;

		} );

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras
	 * @param {number} cameraIndex
	 * @return {Promise<THREE.Camera>}
	 */
	loadCamera( cameraIndex ) {

		let camera;
		const cameraDef = this.json.cameras[ cameraIndex ];
		const params = cameraDef[ cameraDef.type ];

		if ( ! params ) {

			console.warn( 'THREE.GLTFLoader: Missing camera parameters.' );
			return;

		}

		if ( cameraDef.type === 'perspective' ) {

			camera = new three.PerspectiveCamera( three.MathUtils.radToDeg( params.yfov ), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6 );

		} else if ( cameraDef.type === 'orthographic' ) {

			camera = new three.OrthographicCamera( - params.xmag, params.xmag, params.ymag, - params.ymag, params.znear, params.zfar );

		}

		if ( cameraDef.name ) camera.name = this.createUniqueName( cameraDef.name );

		assignExtrasToUserData( camera, cameraDef );

		return Promise.resolve( camera );

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins
	 * @param {number} skinIndex
	 * @return {Promise<Object>}
	 */
	loadSkin( skinIndex ) {

		const skinDef = this.json.skins[ skinIndex ];

		const skinEntry = { joints: skinDef.joints };

		if ( skinDef.inverseBindMatrices === undefined ) {

			return Promise.resolve( skinEntry );

		}

		return this.getDependency( 'accessor', skinDef.inverseBindMatrices ).then( function ( accessor ) {

			skinEntry.inverseBindMatrices = accessor;

			return skinEntry;

		} );

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations
	 * @param {number} animationIndex
	 * @return {Promise<AnimationClip>}
	 */
	loadAnimation( animationIndex ) {

		const json = this.json;

		const animationDef = json.animations[ animationIndex ];

		const pendingNodes = [];
		const pendingInputAccessors = [];
		const pendingOutputAccessors = [];
		const pendingSamplers = [];
		const pendingTargets = [];

		for ( let i = 0, il = animationDef.channels.length; i < il; i ++ ) {

			const channel = animationDef.channels[ i ];
			const sampler = animationDef.samplers[ channel.sampler ];
			const target = channel.target;
			const name = target.node !== undefined ? target.node : target.id; // NOTE: target.id is deprecated.
			const input = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.input ] : sampler.input;
			const output = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.output ] : sampler.output;

			pendingNodes.push( this.getDependency( 'node', name ) );
			pendingInputAccessors.push( this.getDependency( 'accessor', input ) );
			pendingOutputAccessors.push( this.getDependency( 'accessor', output ) );
			pendingSamplers.push( sampler );
			pendingTargets.push( target );

		}

		return Promise.all( [

			Promise.all( pendingNodes ),
			Promise.all( pendingInputAccessors ),
			Promise.all( pendingOutputAccessors ),
			Promise.all( pendingSamplers ),
			Promise.all( pendingTargets )

		] ).then( function ( dependencies ) {

			const nodes = dependencies[ 0 ];
			const inputAccessors = dependencies[ 1 ];
			const outputAccessors = dependencies[ 2 ];
			const samplers = dependencies[ 3 ];
			const targets = dependencies[ 4 ];

			const tracks = [];

			for ( let i = 0, il = nodes.length; i < il; i ++ ) {

				const node = nodes[ i ];
				const inputAccessor = inputAccessors[ i ];
				const outputAccessor = outputAccessors[ i ];
				const sampler = samplers[ i ];
				const target = targets[ i ];

				if ( node === undefined ) continue;

				node.updateMatrix();
				node.matrixAutoUpdate = true;

				let TypedKeyframeTrack;

				switch ( PATH_PROPERTIES[ target.path ] ) {

					case PATH_PROPERTIES.weights:

						TypedKeyframeTrack = three.NumberKeyframeTrack;
						break;

					case PATH_PROPERTIES.rotation:

						TypedKeyframeTrack = three.QuaternionKeyframeTrack;
						break;

					case PATH_PROPERTIES.position:
					case PATH_PROPERTIES.scale:
					default:

						TypedKeyframeTrack = three.VectorKeyframeTrack;
						break;

				}

				const targetName = node.name ? node.name : node.uuid;

				const interpolation = sampler.interpolation !== undefined ? INTERPOLATION[ sampler.interpolation ] : three.InterpolateLinear;

				const targetNames = [];

				if ( PATH_PROPERTIES[ target.path ] === PATH_PROPERTIES.weights ) {

					node.traverse( function ( object ) {

						if ( object.morphTargetInfluences ) {

							targetNames.push( object.name ? object.name : object.uuid );

						}

					} );

				} else {

					targetNames.push( targetName );

				}

				let outputArray = outputAccessor.array;

				if ( outputAccessor.normalized ) {

					const scale = getNormalizedComponentScale( outputArray.constructor );
					const scaled = new Float32Array( outputArray.length );

					for ( let j = 0, jl = outputArray.length; j < jl; j ++ ) {

						scaled[ j ] = outputArray[ j ] * scale;

					}

					outputArray = scaled;

				}

				for ( let j = 0, jl = targetNames.length; j < jl; j ++ ) {

					const track = new TypedKeyframeTrack(
						targetNames[ j ] + '.' + PATH_PROPERTIES[ target.path ],
						inputAccessor.array,
						outputArray,
						interpolation
					);

					// Override interpolation with custom factory method.
					if ( sampler.interpolation === 'CUBICSPLINE' ) {

						track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline( result ) {

							// A CUBICSPLINE keyframe in glTF has three output values for each input value,
							// representing inTangent, splineVertex, and outTangent. As a result, track.getValueSize()
							// must be divided by three to get the interpolant's sampleSize argument.

							const interpolantType = ( this instanceof three.QuaternionKeyframeTrack ) ? GLTFCubicSplineQuaternionInterpolant : GLTFCubicSplineInterpolant;

							return new interpolantType( this.times, this.values, this.getValueSize() / 3, result );

						};

						// Mark as CUBICSPLINE. `track.getInterpolation()` doesn't support custom interpolants.
						track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;

					}

					tracks.push( track );

				}

			}

			const name = animationDef.name ? animationDef.name : 'animation_' + animationIndex;

			return new three.AnimationClip( name, undefined, tracks );

		} );

	}

	createNodeMesh( nodeIndex ) {

		const json = this.json;
		const parser = this;
		const nodeDef = json.nodes[ nodeIndex ];

		if ( nodeDef.mesh === undefined ) return null;

		return parser.getDependency( 'mesh', nodeDef.mesh ).then( function ( mesh ) {

			const node = parser._getNodeRef( parser.meshCache, nodeDef.mesh, mesh );

			// if weights are provided on the node, override weights on the mesh.
			if ( nodeDef.weights !== undefined ) {

				node.traverse( function ( o ) {

					if ( ! o.isMesh ) return;

					for ( let i = 0, il = nodeDef.weights.length; i < il; i ++ ) {

						o.morphTargetInfluences[ i ] = nodeDef.weights[ i ];

					}

				} );

			}

			return node;

		} );

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy
	 * @param {number} nodeIndex
	 * @return {Promise<Object3D>}
	 */
	loadNode( nodeIndex ) {

		const json = this.json;
		const extensions = this.extensions;
		const parser = this;

		const nodeDef = json.nodes[ nodeIndex ];

		// reserve node's name before its dependencies, so the root has the intended name.
		const nodeName = nodeDef.name ? parser.createUniqueName( nodeDef.name ) : '';

		return ( function () {

			const pending = [];

			const meshPromise = parser._invokeOne( function ( ext ) {

				return ext.createNodeMesh && ext.createNodeMesh( nodeIndex );

			} );

			if ( meshPromise ) {

				pending.push( meshPromise );

			}

			if ( nodeDef.camera !== undefined ) {

				pending.push( parser.getDependency( 'camera', nodeDef.camera ).then( function ( camera ) {

					return parser._getNodeRef( parser.cameraCache, nodeDef.camera, camera );

				} ) );

			}

			parser._invokeAll( function ( ext ) {

				return ext.createNodeAttachment && ext.createNodeAttachment( nodeIndex );

			} ).forEach( function ( promise ) {

				pending.push( promise );

			} );

			return Promise.all( pending );

		}() ).then( function ( objects ) {

			let node;

			// .isBone isn't in glTF spec. See ._markDefs
			if ( nodeDef.isBone === true ) {

				node = new three.Bone();

			} else if ( objects.length > 1 ) {

				node = new three.Group();

			} else if ( objects.length === 1 ) {

				node = objects[ 0 ];

			} else {

				node = new three.Object3D();

			}

			if ( node !== objects[ 0 ] ) {

				for ( let i = 0, il = objects.length; i < il; i ++ ) {

					node.add( objects[ i ] );

				}

			}

			if ( nodeDef.name ) {

				node.userData.name = nodeDef.name;
				node.name = nodeName;

			}

			assignExtrasToUserData( node, nodeDef );

			if ( nodeDef.extensions ) addUnknownExtensionsToUserData( extensions, node, nodeDef );

			if ( nodeDef.matrix !== undefined ) {

				const matrix = new three.Matrix4();
				matrix.fromArray( nodeDef.matrix );
				node.applyMatrix4( matrix );

			} else {

				if ( nodeDef.translation !== undefined ) {

					node.position.fromArray( nodeDef.translation );

				}

				if ( nodeDef.rotation !== undefined ) {

					node.quaternion.fromArray( nodeDef.rotation );

				}

				if ( nodeDef.scale !== undefined ) {

					node.scale.fromArray( nodeDef.scale );

				}

			}

			if ( ! parser.associations.has( node ) ) {

				parser.associations.set( node, {} );

			}

			parser.associations.get( node ).nodes = nodeIndex;

			return node;

		} );

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes
	 * @param {number} sceneIndex
	 * @return {Promise<Group>}
	 */
	loadScene( sceneIndex ) {

		const json = this.json;
		const extensions = this.extensions;
		const sceneDef = this.json.scenes[ sceneIndex ];
		const parser = this;

		// Loader returns Group, not Scene.
		// See: https://github.com/mrdoob/three.js/issues/18342#issuecomment-578981172
		const scene = new three.Group();
		if ( sceneDef.name ) scene.name = parser.createUniqueName( sceneDef.name );

		assignExtrasToUserData( scene, sceneDef );

		if ( sceneDef.extensions ) addUnknownExtensionsToUserData( extensions, scene, sceneDef );

		const nodeIds = sceneDef.nodes || [];

		const pending = [];

		for ( let i = 0, il = nodeIds.length; i < il; i ++ ) {

			pending.push( buildNodeHierarchy( nodeIds[ i ], scene, json, parser ) );

		}

		return Promise.all( pending ).then( function () {

			// Removes dangling associations, associations that reference a node that
			// didn't make it into the scene.
			const reduceAssociations = ( node ) => {

				const reducedAssociations = new Map();

				for ( const [ key, value ] of parser.associations ) {

					if ( key instanceof three.Material || key instanceof three.Texture ) {

						reducedAssociations.set( key, value );

					}

				}

				node.traverse( ( node ) => {

					const mappings = parser.associations.get( node );

					if ( mappings != null ) {

						reducedAssociations.set( node, mappings );

					}

				} );

				return reducedAssociations;

			};

			parser.associations = reduceAssociations( scene );

			return scene;

		} );

	}

}

function buildNodeHierarchy( nodeId, parentObject, json, parser ) {

	const nodeDef = json.nodes[ nodeId ];

	return parser.getDependency( 'node', nodeId ).then( function ( node ) {

		if ( nodeDef.skin === undefined ) return node;

		// build skeleton here as well

		let skinEntry;

		return parser.getDependency( 'skin', nodeDef.skin ).then( function ( skin ) {

			skinEntry = skin;

			const pendingJoints = [];

			for ( let i = 0, il = skinEntry.joints.length; i < il; i ++ ) {

				pendingJoints.push( parser.getDependency( 'node', skinEntry.joints[ i ] ) );

			}

			return Promise.all( pendingJoints );

		} ).then( function ( jointNodes ) {

			node.traverse( function ( mesh ) {

				if ( ! mesh.isMesh ) return;

				const bones = [];
				const boneInverses = [];

				for ( let j = 0, jl = jointNodes.length; j < jl; j ++ ) {

					const jointNode = jointNodes[ j ];

					if ( jointNode ) {

						bones.push( jointNode );

						const mat = new three.Matrix4();

						if ( skinEntry.inverseBindMatrices !== undefined ) {

							mat.fromArray( skinEntry.inverseBindMatrices.array, j * 16 );

						}

						boneInverses.push( mat );

					} else {

						console.warn( 'THREE.GLTFLoader: Joint "%s" could not be found.', skinEntry.joints[ j ] );

					}

				}

				mesh.bind( new three.Skeleton( bones, boneInverses ), mesh.matrixWorld );

			} );

			return node;

		} );

	} ).then( function ( node ) {

		// build node hierachy

		parentObject.add( node );

		const pending = [];

		if ( nodeDef.children ) {

			const children = nodeDef.children;

			for ( let i = 0, il = children.length; i < il; i ++ ) {

				const child = children[ i ];
				pending.push( buildNodeHierarchy( child, node, json, parser ) );

			}

		}

		return Promise.all( pending );

	} );

}

/**
 * @param {BufferGeometry} geometry
 * @param {GLTF.Primitive} primitiveDef
 * @param {GLTFParser} parser
 */
function computeBounds( geometry, primitiveDef, parser ) {

	const attributes = primitiveDef.attributes;

	const box = new three.Box3();

	if ( attributes.POSITION !== undefined ) {

		const accessor = parser.json.accessors[ attributes.POSITION ];

		const min = accessor.min;
		const max = accessor.max;

		// glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.

		if ( min !== undefined && max !== undefined ) {

			box.set(
				new three.Vector3( min[ 0 ], min[ 1 ], min[ 2 ] ),
				new three.Vector3( max[ 0 ], max[ 1 ], max[ 2 ] )
			);

			if ( accessor.normalized ) {

				const boxScale = getNormalizedComponentScale( WEBGL_COMPONENT_TYPES[ accessor.componentType ] );
				box.min.multiplyScalar( boxScale );
				box.max.multiplyScalar( boxScale );

			}

		} else {

			console.warn( 'THREE.GLTFLoader: Missing min/max properties for accessor POSITION.' );

			return;

		}

	} else {

		return;

	}

	const targets = primitiveDef.targets;

	if ( targets !== undefined ) {

		const maxDisplacement = new three.Vector3();
		const vector = new three.Vector3();

		for ( let i = 0, il = targets.length; i < il; i ++ ) {

			const target = targets[ i ];

			if ( target.POSITION !== undefined ) {

				const accessor = parser.json.accessors[ target.POSITION ];
				const min = accessor.min;
				const max = accessor.max;

				// glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.

				if ( min !== undefined && max !== undefined ) {

					// we need to get max of absolute components because target weight is [-1,1]
					vector.setX( Math.max( Math.abs( min[ 0 ] ), Math.abs( max[ 0 ] ) ) );
					vector.setY( Math.max( Math.abs( min[ 1 ] ), Math.abs( max[ 1 ] ) ) );
					vector.setZ( Math.max( Math.abs( min[ 2 ] ), Math.abs( max[ 2 ] ) ) );


					if ( accessor.normalized ) {

						const boxScale = getNormalizedComponentScale( WEBGL_COMPONENT_TYPES[ accessor.componentType ] );
						vector.multiplyScalar( boxScale );

					}

					// Note: this assumes that the sum of all weights is at most 1. This isn't quite correct - it's more conservative
					// to assume that each target can have a max weight of 1. However, for some use cases - notably, when morph targets
					// are used to implement key-frame animations and as such only two are active at a time - this results in very large
					// boxes. So for now we make a box that's sometimes a touch too small but is hopefully mostly of reasonable size.
					maxDisplacement.max( vector );

				} else {

					console.warn( 'THREE.GLTFLoader: Missing min/max properties for accessor POSITION.' );

				}

			}

		}

		// As per comment above this box isn't conservative, but has a reasonable size for a very large number of morph targets.
		box.expandByVector( maxDisplacement );

	}

	geometry.boundingBox = box;

	const sphere = new three.Sphere();

	box.getCenter( sphere.center );
	sphere.radius = box.min.distanceTo( box.max ) / 2;

	geometry.boundingSphere = sphere;

}

/**
 * @param {BufferGeometry} geometry
 * @param {GLTF.Primitive} primitiveDef
 * @param {GLTFParser} parser
 * @return {Promise<BufferGeometry>}
 */
function addPrimitiveAttributes( geometry, primitiveDef, parser ) {

	const attributes = primitiveDef.attributes;

	const pending = [];

	function assignAttributeAccessor( accessorIndex, attributeName ) {

		return parser.getDependency( 'accessor', accessorIndex )
			.then( function ( accessor ) {

				geometry.setAttribute( attributeName, accessor );

			} );

	}

	for ( const gltfAttributeName in attributes ) {

		const threeAttributeName = ATTRIBUTES[ gltfAttributeName ] || gltfAttributeName.toLowerCase();

		// Skip attributes already provided by e.g. Draco extension.
		if ( threeAttributeName in geometry.attributes ) continue;

		pending.push( assignAttributeAccessor( attributes[ gltfAttributeName ], threeAttributeName ) );

	}

	if ( primitiveDef.indices !== undefined && ! geometry.index ) {

		const accessor = parser.getDependency( 'accessor', primitiveDef.indices ).then( function ( accessor ) {

			geometry.setIndex( accessor );

		} );

		pending.push( accessor );

	}

	assignExtrasToUserData( geometry, primitiveDef );

	computeBounds( geometry, primitiveDef, parser );

	return Promise.all( pending ).then( function () {

		return primitiveDef.targets !== undefined
			? addMorphTargets( geometry, primitiveDef.targets, parser )
			: geometry;

	} );

}

/**
 * @param {BufferGeometry} geometry
 * @param {Number} drawMode
 * @return {BufferGeometry}
 */
function toTrianglesDrawMode( geometry, drawMode ) {

	let index = geometry.getIndex();

	// generate index if not present

	if ( index === null ) {

		const indices = [];

		const position = geometry.getAttribute( 'position' );

		if ( position !== undefined ) {

			for ( let i = 0; i < position.count; i ++ ) {

				indices.push( i );

			}

			geometry.setIndex( indices );
			index = geometry.getIndex();

		} else {

			console.error( 'THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.' );
			return geometry;

		}

	}

	//

	const numberOfTriangles = index.count - 2;
	const newIndices = [];

	if ( drawMode === three.TriangleFanDrawMode ) {

		// gl.TRIANGLE_FAN

		for ( let i = 1; i <= numberOfTriangles; i ++ ) {

			newIndices.push( index.getX( 0 ) );
			newIndices.push( index.getX( i ) );
			newIndices.push( index.getX( i + 1 ) );

		}

	} else {

		// gl.TRIANGLE_STRIP

		for ( let i = 0; i < numberOfTriangles; i ++ ) {

			if ( i % 2 === 0 ) {

				newIndices.push( index.getX( i ) );
				newIndices.push( index.getX( i + 1 ) );
				newIndices.push( index.getX( i + 2 ) );


			} else {

				newIndices.push( index.getX( i + 2 ) );
				newIndices.push( index.getX( i + 1 ) );
				newIndices.push( index.getX( i ) );

			}

		}

	}

	if ( ( newIndices.length / 3 ) !== numberOfTriangles ) {

		console.error( 'THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.' );

	}

	// build final geometry

	const newGeometry = geometry.clone();
	newGeometry.setIndex( newIndices );

	return newGeometry;

}/**
 * @webxr-input-profiles/motion-controllers 1.0.0 https://github.com/immersive-web/webxr-input-profiles
 */

const Constants = {
  Handedness: Object.freeze({
    NONE: 'none',
    LEFT: 'left',
    RIGHT: 'right'
  }),
  ComponentState: Object.freeze({
    DEFAULT: 'default',
    TOUCHED: 'touched',
    PRESSED: 'pressed'
  }),
  ComponentProperty: Object.freeze({
    BUTTON: 'button',
    X_AXIS: 'xAxis',
    Y_AXIS: 'yAxis',
    STATE: 'state'
  }),
  ComponentType: Object.freeze({
    TRIGGER: 'trigger',
    SQUEEZE: 'squeeze',
    TOUCHPAD: 'touchpad',
    THUMBSTICK: 'thumbstick',
    BUTTON: 'button'
  }),
  ButtonTouchThreshold: 0.05,
  AxisTouchThreshold: 0.1,
  VisualResponseProperty: Object.freeze({
    TRANSFORM: 'transform',
    VISIBILITY: 'visibility'
  })
};

/** @constant {Object} */
const defaultComponentValues = {
  xAxis: 0,
  yAxis: 0,
  button: 0,
  state: Constants.ComponentState.DEFAULT
};

/**
 * @description Static helper function to fetch a JSON file and turn it into a JS object
 * @param {string} path - Path to JSON file to be fetched
 */
async function fetchJsonFile(path) {
  const response = await fetch(path);
  if (!response.ok) {
    throw new Error(response.statusText);
  } else {
    return response.json();
  }
}
async function fetchProfilesList(basePath) {
  if (!basePath) {
    throw new Error('No basePath supplied');
  }
  const profileListFileName = 'profilesList.json';
  const profilesList = await fetchJsonFile(`${basePath}/${profileListFileName}`);
  return profilesList;
}
async function fetchProfile(xrInputSource, basePath, defaultProfile, getAssetPath) {
  if (defaultProfile === void 0) {
    defaultProfile = null;
  }
  if (getAssetPath === void 0) {
    getAssetPath = true;
  }
  if (!xrInputSource) {
    throw new Error('No xrInputSource supplied');
  }
  if (!basePath) {
    throw new Error('No basePath supplied');
  }

  // Get the list of profiles
  const supportedProfilesList = await fetchProfilesList(basePath);

  // Find the relative path to the first requested profile that is recognized
  let match;
  xrInputSource.profiles.some(profileId => {
    const supportedProfile = supportedProfilesList[profileId];
    if (supportedProfile) {
      match = {
        profileId,
        profilePath: `${basePath}/${supportedProfile.path}`,
        deprecated: !!supportedProfile.deprecated
      };
    }
    return !!match;
  });
  if (!match) {
    if (!defaultProfile) {
      throw new Error('No matching profile name found');
    }
    const supportedProfile = supportedProfilesList[defaultProfile];
    if (!supportedProfile) {
      throw new Error(`No matching profile name found and default profile "${defaultProfile}" missing.`);
    }
    match = {
      profileId: defaultProfile,
      profilePath: `${basePath}/${supportedProfile.path}`,
      deprecated: !!supportedProfile.deprecated
    };
  }
  const profile = await fetchJsonFile(match.profilePath);
  let assetPath;
  if (getAssetPath) {
    let layout;
    if (xrInputSource.handedness === 'any') {
      layout = profile.layouts[Object.keys(profile.layouts)[0]];
    } else {
      layout = profile.layouts[xrInputSource.handedness];
    }
    if (!layout) {
      throw new Error(`No matching handedness, ${xrInputSource.handedness}, in profile ${match.profileId}`);
    }
    if (layout.assetPath) {
      assetPath = match.profilePath.replace('profile.json', layout.assetPath);
    }
  }
  return {
    profile,
    assetPath
  };
}

/**
 * @description Converts an X, Y coordinate from the range -1 to 1 (as reported by the Gamepad
 * API) to the range 0 to 1 (for interpolation). Also caps the X, Y values to be bounded within
 * a circle. This ensures that thumbsticks are not animated outside the bounds of their physical
 * range of motion and touchpads do not report touch locations off their physical bounds.
 * @param {number} x The original x coordinate in the range -1 to 1
 * @param {number} y The original y coordinate in the range -1 to 1
 */
function normalizeAxes(x, y) {
  if (x === void 0) {
    x = 0;
  }
  if (y === void 0) {
    y = 0;
  }
  let xAxis = x;
  let yAxis = y;

  // Determine if the point is outside the bounds of the circle
  // and, if so, place it on the edge of the circle
  const hypotenuse = Math.sqrt(x * x + y * y);
  if (hypotenuse > 1) {
    const theta = Math.atan2(y, x);
    xAxis = Math.cos(theta);
    yAxis = Math.sin(theta);
  }

  // Scale and move the circle so values are in the interpolation range.  The circle's origin moves
  // from (0, 0) to (0.5, 0.5). The circle's radius scales from 1 to be 0.5.
  const result = {
    normalizedXAxis: xAxis * 0.5 + 0.5,
    normalizedYAxis: yAxis * 0.5 + 0.5
  };
  return result;
}

/**
 * Contains the description of how the 3D model should visually respond to a specific user input.
 * This is accomplished by initializing the object with the name of a node in the 3D model and
 * property that need to be modified in response to user input, the name of the nodes representing
 * the allowable range of motion, and the name of the input which triggers the change. In response
 * to the named input changing, this object computes the appropriate weighting to use for
 * interpolating between the range of motion nodes.
 */

class VisualResponse {
  constructor(visualResponseDescription) {
    this.componentProperty = visualResponseDescription.componentProperty;
    this.states = visualResponseDescription.states;
    this.valueNodeName = visualResponseDescription.valueNodeName;
    this.valueNodeProperty = visualResponseDescription.valueNodeProperty;
    if (this.valueNodeProperty === Constants.VisualResponseProperty.TRANSFORM) {
      this.minNodeName = visualResponseDescription.minNodeName;
      this.maxNodeName = visualResponseDescription.maxNodeName;
    }
    // Initializes the response's current value based on default data
    this.value = 0;
    this.updateFromComponent(defaultComponentValues);
  }

  /**
   * Computes the visual response's interpolation weight based on component state
   * @param {Object} componentValues - The component from which to update
   * @param {number} xAxis - The reported X axis value of the component
   * @param {number} yAxis - The reported Y axis value of the component
   * @param {number} button - The reported value of the component's button
   * @param {string} state - The component's active state
   */
  updateFromComponent(_ref) {
    let {
      xAxis,
      yAxis,
      button,
      state
    } = _ref;
    const {
      normalizedXAxis,
      normalizedYAxis
    } = normalizeAxes(xAxis, yAxis);
    switch (this.componentProperty) {
      case Constants.ComponentProperty.X_AXIS:
        this.value = this.states.includes(state) ? normalizedXAxis : 0.5;
        break;
      case Constants.ComponentProperty.Y_AXIS:
        this.value = this.states.includes(state) ? normalizedYAxis : 0.5;
        break;
      case Constants.ComponentProperty.BUTTON:
        this.value = this.states.includes(state) ? button : 0;
        break;
      case Constants.ComponentProperty.STATE:
        if (this.valueNodeProperty === Constants.VisualResponseProperty.VISIBILITY) {
          this.value = this.states.includes(state);
        } else {
          this.value = this.states.includes(state) ? 1.0 : 0.0;
        }
        break;
      default:
        throw new Error(`Unexpected visualResponse componentProperty ${this.componentProperty}`);
    }
  }
}
class Component {
  /**
   * @param {Object} componentId - Id of the component
   * @param {Object} componentDescription - Description of the component to be created
   */
  constructor(componentId, componentDescription) {
    if (!componentId || !componentDescription || !componentDescription.visualResponses || !componentDescription.gamepadIndices || Object.keys(componentDescription.gamepadIndices).length === 0) {
      throw new Error('Invalid arguments supplied');
    }
    this.id = componentId;
    this.type = componentDescription.type;
    this.rootNodeName = componentDescription.rootNodeName;
    this.touchPointNodeName = componentDescription.touchPointNodeName;
    // Build all the visual responses for this component
    this.visualResponses = {};
    Object.keys(componentDescription.visualResponses).forEach(responseName => {
      const visualResponse = new VisualResponse(componentDescription.visualResponses[responseName]);
      this.visualResponses[responseName] = visualResponse;
    });
    // Set default values
    this.gamepadIndices = Object.assign({}, componentDescription.gamepadIndices);
    this.values = {
      state: Constants.ComponentState.DEFAULT,
      button: this.gamepadIndices.button !== undefined ? 0 : undefined,
      xAxis: this.gamepadIndices.xAxis !== undefined ? 0 : undefined,
      yAxis: this.gamepadIndices.yAxis !== undefined ? 0 : undefined
    };
  }
  get data() {
    const data = _objectSpread2({
      id: this.id
    }, this.values);
    return data;
  }

  /**
   * @description Poll for updated data based on current gamepad state
   * @param {Object} gamepad - The gamepad object from which the component data should be polled
   */
  updateFromGamepad(gamepad) {
    // Set the state to default before processing other data sources
    this.values.state = Constants.ComponentState.DEFAULT;
    // Get and normalize button
    if (this.gamepadIndices.button !== undefined && gamepad.buttons.length > this.gamepadIndices.button) {
      const gamepadButton = gamepad.buttons[this.gamepadIndices.button];
      this.values.button = gamepadButton.value;
      this.values.button = this.values.button < 0 ? 0 : this.values.button;
      this.values.button = this.values.button > 1 ? 1 : this.values.button;
      // Set the state based on the button
      if (gamepadButton.pressed || this.values.button === 1) {
        this.values.state = Constants.ComponentState.PRESSED;
      } else if (gamepadButton.touched || this.values.button > Constants.ButtonTouchThreshold) {
        this.values.state = Constants.ComponentState.TOUCHED;
      }
    }
    // Get and normalize x axis value
    if (this.gamepadIndices.xAxis !== undefined && gamepad.axes.length > this.gamepadIndices.xAxis) {
      this.values.xAxis = gamepad.axes[this.gamepadIndices.xAxis];
      this.values.xAxis = this.values.xAxis < -1 ? -1 : this.values.xAxis;
      this.values.xAxis = this.values.xAxis > 1 ? 1 : this.values.xAxis;
      // If the state is still default, check if the xAxis makes it touched
      if (this.values.state === Constants.ComponentState.DEFAULT && Math.abs(this.values.xAxis) > Constants.AxisTouchThreshold) {
        this.values.state = Constants.ComponentState.TOUCHED;
      }
    }

    // Get and normalize Y axis value
    if (this.gamepadIndices.yAxis !== undefined && gamepad.axes.length > this.gamepadIndices.yAxis) {
      this.values.yAxis = gamepad.axes[this.gamepadIndices.yAxis];
      this.values.yAxis = this.values.yAxis < -1 ? -1 : this.values.yAxis;
      this.values.yAxis = this.values.yAxis > 1 ? 1 : this.values.yAxis;

      // If the state is still default, check if the yAxis makes it touched
      if (this.values.state === Constants.ComponentState.DEFAULT && Math.abs(this.values.yAxis) > Constants.AxisTouchThreshold) {
        this.values.state = Constants.ComponentState.TOUCHED;
      }
    }
    // Update the visual response weights based on the current component data
    Object.values(this.visualResponses).forEach(visualResponse => {
      visualResponse.updateFromComponent(this.values);
    });
  }
}

/**
  * @description Builds a motion controller with components and visual responses based on the
  * supplied profile description. Data is polled from the xrInputSource's gamepad.
  * @author Nell Waliczek / https://github.com/NellWaliczek
*/
class MotionController {
  /**
   * @param {Object} xrInputSource - The XRInputSource to build the MotionController around
   * @param {Object} profile - The best matched profile description for the supplied xrInputSource
   * @param {Object} assetUrl
   */
  constructor(xrInputSource, profile, assetUrl) {
    if (!xrInputSource) {
      throw new Error('No xrInputSource supplied');
    }
    if (!profile) {
      throw new Error('No profile supplied');
    }
    this.xrInputSource = xrInputSource;
    this.assetUrl = assetUrl;
    this.id = profile.profileId;
    // Build child components as described in the profile description
    this.layoutDescription = profile.layouts[xrInputSource.handedness];
    this.components = {};
    Object.keys(this.layoutDescription.components).forEach(componentId => {
      const componentDescription = this.layoutDescription.components[componentId];
      this.components[componentId] = new Component(componentId, componentDescription);
    });
    // Initialize components based on current gamepad state
    this.updateFromGamepad();
  }
  get gripSpace() {
    return this.xrInputSource.gripSpace;
  }
  get targetRaySpace() {
    return this.xrInputSource.targetRaySpace;
  }

  /**
   * @description Returns a subset of component data for simplified debugging
   */
  get data() {
    const data = [];
    Object.values(this.components).forEach(component => {
      data.push(component.data);
    });
    return data;
  }

  /**
   * @description Poll for updated data based on current gamepad state
   */
  updateFromGamepad() {
    Object.values(this.components).forEach(component => {
      component.updateFromGamepad(this.xrInputSource.gamepad);
    });
  }
}const DEFAULT_PROFILES_PATH = 'https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0/dist/profiles';
const DEFAULT_PROFILE = 'generic-trigger';
class XRControllerModel extends THREE.Object3D {
  constructor() {
    super();
    this.motionController = null;
    this.envMap = null;
  }
  setEnvironmentMap(envMap) {
    if (this.envMap == envMap) {
      return this;
    }
    this.envMap = envMap;
    this.traverse(child => {
      if (child.isMesh) {
        child.material.envMap = this.envMap;
        child.material.needsUpdate = true;
      }
    });
    return this;
  }

  /**
   * Polls data from the XRInputSource and updates the model's components to match
   * the real world data
   */
  updateMatrixWorld(force) {
    super.updateMatrixWorld(force);
    if (!this.motionController) {
      return;
    }
    // Cause the MotionController to poll the Gamepad for data
    this.motionController.updateFromGamepad();
    // Update the 3D model to reflect the button, thumbstick, and touchpad state
    Object.values(this.motionController.components).forEach(component => {
      // Update node data based on the visual responses' current states
      Object.values(component.visualResponses).forEach(visualResponse => {
        const {
          valueNode,
          minNode,
          maxNode,
          value,
          valueNodeProperty
        } = visualResponse;
        // Skip if the visual response node is not found. No error is needed,
        // because it will have been reported at load time.
        if (!valueNode) {
          return;
        }
        // Calculate the new properties based on the weight supplied
        if (valueNodeProperty === Constants.VisualResponseProperty.VISIBILITY) {
          valueNode.visible = value;
        } else if (valueNodeProperty === Constants.VisualResponseProperty.TRANSFORM) {
          valueNode.quaternion.slerpQuaternions(minNode.quaternion, maxNode.quaternion, value);
          valueNode.position.lerpVectors(minNode.position, maxNode.position, value);
        }
      });
    });
  }
}

/**
 * Walks the model's tree to find the nodes needed to animate the components and
 * saves them to the motionContoller components for use in the frame loop. When
 * touchpads are found, attaches a touch dot to them.
 */
function findNodes(motionController, scene) {
  // Loop through the components and find the nodes needed for each components' visual responses
  Object.values(motionController.components).forEach(component => {
    const {
      type,
      touchPointNodeName,
      visualResponses
    } = component;
    if (type === Constants.ComponentType.TOUCHPAD) {
      component.touchPointNode = scene.getObjectByName(touchPointNodeName);
      if (component.touchPointNode) {
        // Attach a touch dot to the touchpad.
        const sphereGeometry = new THREE.SphereGeometry(0.001);
        const material = new THREE.MeshBasicMaterial({
          color: 0x0000FF
        });
        const sphere = new THREE.Mesh(sphereGeometry, material);
        component.touchPointNode.add(sphere);
      } else {
        console.warn(`Could not find touch dot, ${component.touchPointNodeName}, in touchpad component ${component.id}`);
      }
    }
    // Loop through all the visual responses to be applied to this component
    Object.values(visualResponses).forEach(visualResponse => {
      const {
        valueNodeName,
        minNodeName,
        maxNodeName,
        valueNodeProperty
      } = visualResponse;
      // If animating a transform, find the two nodes to be interpolated between.
      if (valueNodeProperty === Constants.VisualResponseProperty.TRANSFORM) {
        visualResponse.minNode = scene.getObjectByName(minNodeName);
        visualResponse.maxNode = scene.getObjectByName(maxNodeName);
        // If the extents cannot be found, skip this animation
        if (!visualResponse.minNode) {
          console.warn(`Could not find ${minNodeName} in the model`);
          return;
        }
        if (!visualResponse.maxNode) {
          console.warn(`Could not find ${maxNodeName} in the model`);
          return;
        }
      }
      // If the target node cannot be found, skip this animation
      visualResponse.valueNode = scene.getObjectByName(valueNodeName);
      if (!visualResponse.valueNode) {
        console.warn(`Could not find ${valueNodeName} in the model`);
      }
    });
  });
}
function addAssetSceneToControllerModel(controllerModel, scene) {
  // Find the nodes needed for animation and cache them on the motionController.
  findNodes(controllerModel.motionController, scene);
  // Apply any environment map that the mesh already has set.
  if (controllerModel.envMap) {
    scene.traverse(child => {
      if (child.isMesh) {
        child.material.envMap = controllerModel.envMap;
        child.material.needsUpdate = true;
      }
    });
  }
  // Add the glTF scene to the controllerModel.
  controllerModel.add(scene);
}
class XRControllerModelFactory {
  constructor(gltfLoader) {
    if (gltfLoader === void 0) {
      gltfLoader = null;
    }
    this.gltfLoader = gltfLoader;
    this.path = DEFAULT_PROFILES_PATH;
    this._assetCache = {};
    // If a GLTFLoader wasn't supplied to the constructor create a new one.
    if (!this.gltfLoader) {
      this.gltfLoader = new GLTFLoader();
    }
  }
  createControllerModel(controller) {
    const controllerModel = new XRControllerModel();
    let scene = null;
    controller.addEventListener('connected', event => {
      const xrInputSource = event.data;
      if (xrInputSource.targetRayMode !== 'tracked-pointer' || !xrInputSource.gamepad) {
        return;
      }
      fetchProfile(xrInputSource, this.path, DEFAULT_PROFILE).then(_ref => {
        let {
          profile,
          assetPath
        } = _ref;
        controllerModel.motionController = new MotionController(xrInputSource, profile, assetPath);
        const cachedAsset = this._assetCache[controllerModel.motionController.assetUrl];
        if (cachedAsset) {
          scene = cachedAsset.scene.clone();
          addAssetSceneToControllerModel(controllerModel, scene);
        } else {
          if (!this.gltfLoader) {
            throw new Error('GLTFLoader not set.');
          }
          this.gltfLoader.setPath('');
          this.gltfLoader.load(controllerModel.motionController.assetUrl, asset => {
            this._assetCache[controllerModel.motionController.assetUrl] = asset;
            scene = asset.scene.clone();
            addAssetSceneToControllerModel(controllerModel, scene);
          }, null, () => {
            throw new Error(`Asset ${controllerModel.motionController.assetUrl} missing or malformed.`);
          });
        }
      }).catch(err => {
        console.warn(err);
      });
    });
    controller.addEventListener('disconnected', () => {
      controllerModel.motionController = null;
      controllerModel.remove(scene);
      scene = null;
    });
    return controllerModel;
  }
}const ZERO = new THREE.Vector3();
const DOWN = new THREE.Vector3(0, -1, 0);
const CONTROL_INFO = {
  type: MessageType.ControlInfo,
  orientation: {
    latitude: 0,
    longitude: 0
  },
  zoom: 1,
  cameraGroup: {
    position: [0, 0, 0],
    rotation: [0, 0, 0]
  },
  pointer: [0, 0, 0]
};
class WorldComponent extends rxcomp.Component {
  get error() {
    return this.error_;
  }
  set error(error) {
    if (this.error_ !== error) {
      this.error_ = error;
      this.pushChanges();
    }
  }
  get view() {
    return this.view_;
  }
  set view(view) {
    if (this.view_ !== view) {
      this.view_ = view;
      this.setView();
    }
  }
  get debugging() {
    // return STATIC || DEBUG;
    return DEBUG;
  }
  get controlled() {
    return StateService.state.controlling && StateService.state.controlling !== StateService.state.uid;
  }
  get controlling() {
    return StateService.state.controlling && StateService.state.controlling === StateService.state.uid;
  }
  get silencing() {
    return StateService.state.silencing;
  }
  get silenced() {
    return StateService.state.silencing && StateService.state.role === RoleType.Streamer;
  }
  get spyed() {
    return StateService.state.spying && StateService.state.spying === StateService.state.uid;
  }
  get spying() {
    return StateService.state.spying && StateService.state.spying !== StateService.state.uid;
  }
  get locked() {
    return this.controlled || this.spying;
  }
  get lockedOrXR() {
    return this.locked || this.renderer.xr.isPresenting;
  }
  get showMenu() {
    return StateService.state.hosted && StateService.state.navigable && (StateService.state.mode !== 'embed' || environment.flags.menuEmbed);
  }
  get showPointer() {
    return this.pointer.mesh.parent != null;
  }
  set showPointer(showPointer) {
    if (this.showPointer !== showPointer) {
      showPointer ? this.scene.add(this.pointer.mesh) : this.scene.remove(this.pointer.mesh);
      // Logger.log('WorldComponent.showPointer', showPointer);
    }
  }

  set menu(menu) {
    if (this.menu_ !== menu) {
      this.menu_ = menu;
      this.scene.traverse(object => {
        if (object instanceof MediaMesh || object instanceof MediaPlayMesh) {
          object.freezed = menu != null;
        }
      });
    }
  }
  get menu() {
    return this.menu_;
  }
  onInit() {
    // Logger.log('WorldComponent.onInit');
    Host.host = this;
    this.defaultTexture = Texture.gridTexture;
    this.index = 0;
    this.error_ = null;
    this.loading = null;
    this.waiting = null;
    this.avatars = {};
    this.createScene();
    // this.setView();
    this.addListeners();
    this.animate(); // !!!
    KeyboardService.keys$().pipe(operators.takeUntil(this.unsubscribe$)).subscribe(keys => {
      this.keys = keys;
      // console.log(keys);
    });

    LanguageService.lang$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(_ => {
      this.setView();
    });
  }

  /*
  onChanges() {
  	if (this.view) {
  		const selected = this.view.items.find(item => item.selected);
  		if (selected && selected.mesh) {
  			if (this.view.type.name !== 'model') {
  				this.orbitService.lookAt(selected.mesh);
  			}
  		}
  	}
  }
  */

  onDestroy() {
    this.removeListeners();
    const renderer = this.renderer;
    renderer.setAnimationLoop(() => {});
  }
  createScene() {
    const {
      node
    } = rxcomp.getContext(this);
    this.size = {
      left: 0,
      top: 0,
      width: 0,
      height: 0,
      aspect: 0
    };
    this.mouse = new THREE.Vector2();
    this.controllerMatrix_ = new THREE.Matrix4();
    this.controllerWorldPosition_ = new THREE.Vector3();
    this.controllerWorldDirection_ = new THREE.Vector3();
    const container = this.container = node;
    this.info = node.querySelector('.world__info');
    this.worldRect = Rect.fromNode(container);
    this.cameraRect = new Rect();
    const cameraGroup = this.cameraGroup = new THREE.Group();
    // new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, ROOM_RADIUS * 2);
    // const camera = this.camera = new THREE.PerspectiveCamera(70, container.offsetWidth / container.offsetHeight, 0.01, 1000);
    const camera = this.camera = new THREE.PerspectiveCamera(70, container.offsetWidth / container.offsetHeight, 0.01, 1000);
    camera.target = new THREE.Vector3();
    cameraGroup.add(camera);
    // cameraGroup.target = new THREE.Vector3();

    this.orbitService = new OrbitService(camera);
    const renderer = this.renderer = new THREE.WebGLRenderer({
      antialias: environment.flags.antialias || false,
      alpha: environment.flags.alpha || false,
      premultipliedAlpha: environment.flags.premultipliedAlpha || false,
      logarithmicDepthBuffer: true,
      // physicallyCorrectLights: true,
      powerPreference: 'high-performance'
    });
    renderer.setClearColor(0x000000, 1);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(container.offsetWidth, container.offsetHeight);
    renderer.xr.enabled = true;
    renderer.outputEncoding = THREE.LinearEncoding;
    // renderer.toneMapping = THREE.NoToneMapping;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = environment.toneMappingExposure || 1; // 2;

    if (container.childElementCount > 0) {
      container.insertBefore(renderer.domElement, container.children[0]);
    } else {
      container.appendChild(renderer.domElement);
    }
    const raycaster = this.raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(this.mouse, camera);
    const scene = this.scene = new THREE.Scene();
    scene.add(cameraGroup);
    if (environment.flags.useTextureEnvironment) {
      this.addEnvironment();
    }
    const objects = this.objects = new THREE.Group();
    objects.name = '[objects]';
    scene.add(objects);
    const panorama = this.panorama = new Panorama(renderer);
    this.panoramaIntersectObjects = [panorama.mesh];
    this.intersectObjects = this.panoramaIntersectObjects;
    objects.add(panorama.mesh);
    this.indicator = new PointerElement();
    this.pointer = new PointerElement('#ff4332');
    const light1 = new THREE.PointLight(0xffffff, 0.8);
    light1.position.set(-50, 0, 0);
    objects.add(light1);
    const light2 = new THREE.PointLight(0xffffff, 0.3);
    light2.position.set(50, 0, 0);
    objects.add(light2);
    const light3 = new THREE.PointLight(0xffffff, 0.5);
    light3.position.set(0, 50, 0);
    objects.add(light3);
    const light4 = new THREE.PointLight(0xffffff, 0.1);
    light4.position.set(0, -50, 0);
    objects.add(light4);
    const ambient = this.ambient = new THREE.AmbientLight(0xffffff, 0.25);
    objects.add(ambient);

    /*
    const direct = this.direct = new THREE.DirectionalLight(0xffffff, 1);
    direct.position.set(-40, -40, -40);
    direct.target.position.set(0, 0, 0);
    objects.add(direct);
    */

    this.addControllers();
    this.resize();

    // show hide items
    LoaderService.progress$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(progress => {
      const complete = progress.count === 0;
      const view = this.view_;
      // this.panorama.mesh.visible = complete;
      if (view.items) {
        view.items.forEach(item => {
          item.visible = complete;
        });
      }
      // console.log(view, complete, progress);
    });

    // Logger.log('WorldComponent.createScene', this);
  }

  toggleLights(enabled) {
    if (this.ambient) {
      this.ambient.visible = enabled;
    }
    if (this.direct) {
      this.direct.visible = enabled;
    }
  }
  addEnvironment() {
    const segments = environment.textures.envMap.split('/');
    const filename = segments.pop();
    const folder = segments.join('/') + '/';
    const isHdr = filename.indexOf('.hdr') !== -1;
    // const loader = isHdr ? new RGBELoader().setDataType(THREE.UnsignedByteType) : new THREE.TextureLoader();
    let loader;
    if (isHdr) {
      loader = new RGBELoader();
      loader.setDataType(THREE.HalfFloatType);
    } else {
      loader = new THREE.TextureLoader();
    }
    loader.setPath(environment.getPath(folder)).load(filename, texture => {
      if (isHdr && texture) {
        texture.mapping = THREE.EquirectangularReflectionMapping;
        this.scene.background = texture;
        this.scene.environment = texture;
      } else {
        this.setBackground(texture);
      }
    });
  }
  addOffCanvasScene(message) {
    const avatar = new AvatarElement(message);
    this.avatars[message.clientId] = avatar;
    // avatar.container.appendChild(avatar.element);
  }

  removeOffCanvasScene(message) {
    this.avatars[message.clientId];
    /*
    if (avatar && avatar.element.parentNode) {
    	avatar.element.parentNode.removeChild(avatar.element);
    }
    */
    delete this.avatars[message.clientId];
  }
  updateOffCanvasScene(message) {
    const avatar = this.avatars[message.clientId];
    if (avatar) {
      avatar.update(message);
    }
  }
  setBackground(texture) {
    let background = texture || this.defaultTexture;
    background.mapping = THREE.EquirectangularReflectionMapping;
    // background.encoding = THREE.LinearEncoding;
    background.encoding = THREE.sRGBEncoding;
    // background.encoding = THREE.GammaEncoding;
    // background.encoding = THREE.RGBEEncoding;
    // background.encoding = THREE.LogLuvEncoding;
    // background.encoding = THREE.RGBM7Encoding;
    // background.encoding = THREE.RGBM16Encoding;
    // background.encoding = THREE.RGBDEncoding;
    // background.encoding = THREE.BasicDepthPacking;
    // background.encoding = THREE.RGBADepthPacking;
    // this.scene.background = background;
    this.scene.environment = background;
  }
  setView() {
    if (!this.renderer) {
      return;
    }
    if (!this.panorama) {
      return;
    }
    const view = this.view_;
    if (view) {
      if (StateService.state.zoomedId != null) {
        StateService.patchState({
          zoomedId: null
        });
      }
      if (this.views) {
        this.views.forEach(view => delete view.onUpdateAsset);
      }
      const message = this.requestInfoResult;
      if (message) {
        if (view instanceof PanoramaGridView && message.gridIndex !== undefined) {
          view.index_ = message.gridIndex;
        }
      }
      view.ready = false;
      this.cameraGroup.position.set(0, 0, 0);
      this.cameraGroup.rotation.set(0, 0, 0);
      if (view.type.name === ViewType.Room3d.name) {
        this.renderer.setClearColor(0x000000, 1);
        this.objects.remove(this.panorama.mesh);
        this.toggleLights(false);
      } else {
        this.renderer.setClearColor(0x000000, 1);
        this.objects.add(this.panorama.mesh);
        this.toggleLights(true);
      }
      // this.waiting = null;
      this.pushChanges();
      PrefetchService.cancel();
      this.panorama.change(view, this.renderer, texture => {
        // Logger.log('WorldComponent.panorama.change', texture);
        if (!environment.flags.useTextureEnvironment) {
          this.setBackground(texture);
        }
        view.ready = true;
        view.onUpdateAsset = () => {
          this.onViewAssetDidChange();
        };
        const context = rxcomp.getContext(this);
        // Logger.log('WorldCompoent.setView.context', context);
        if (context) {
          this.pushChanges();
        }
      }, view => {
        this.setViewOrientation(view);
        PrefetchService.prefetch(view.prefetchAssets);
        // this.loading = null;
        // this.pushChanges();
      });
    }
  }

  onViewAssetDidChange() {
    if (this.panorama) {
      this.panorama.crossfade(this.view, this.renderer, texture => {
        if (!environment.flags.useTextureEnvironment) {
          this.setBackground(texture);
        }
      });
    }
  }
  setViewOrientation(view) {
    const message = this.requestInfoResult;
    this.requestInfoResult = null;
    if (this.orbitService) {
      this.orbitService.mode = view.type.name;
      if (!this.renderer.xr.isPresenting) {
        let orientation;
        if (message) {
          orientation = message.orientation;
          this.orbitService.setOrientation(orientation);
          this.orbitService.zoom = message.zoom;
          this.camera.updateProjectionMatrix();
        } else if (!view.keepOrientation) {
          // Logger.log('WorldComponent.setViewOrientation', view.useLastOrientation, view.lastOrientation);
          orientation = view.useLastOrientation ? view.lastOrientation : view.orientation;
          this.orbitService.setOrientation(orientation);
          this.orbitService.zoom = view.zoom;
          this.camera.updateProjectionMatrix();
        }
      }
    }
  }
  addControllers() {
    const controllerGroup = this.controllerGroup = new THREE.Group();
    this.teleport = new TeleportElement();
    this.controllers = [];
    this.controllerModelFactory = new XRControllerModelFactory();
    this.addController(0);
    this.addController(1);
    this.cameraGroup.add(controllerGroup);
  }
  addController(index) {
    const showPhone = StateService.state.live;
    const renderer = this.renderer;
    const controllerGroup = this.controllerGroup;
    const controller = renderer.xr.getController(index);
    const controllerModelFactory = this.controllerModelFactory;
    const teleport = this.teleport;
    const scene = this.scene;
    const camera = this.camera;
    const cameraGroup = this.cameraGroup;
    controller.name = `[controller${index + 1}]`;
    controllerGroup.add(controller);
    const setController = controller => {
      // Logger.log('WorldComponent.setController', this);
      this.controller = controller;
    };
    const onSelectStart = event => {
      controller.userData.isSelecting = true;
      setController(controller);
    };
    const onSelectEnd = event => {
      controller.userData.isSelecting = false;
    };
    const onSqueezeStart = event => {
      if (this.view && this.view.type.name === ViewType.Room3d.name) {
        teleport.addToController(controller, scene);
        // this.scene.remove(this.indicator.mesh);
        this.indicator.mesh.visible = false;
        controller.children[0].visible = false;
      }
    };
    const onSqueezeEnd = event => {
      // if (this.view && this.view.type.name === ViewType.Room3d.name) {
      teleport.removeFromController(controller, scene, renderer, camera, cameraGroup);
      // this.scene.add(this.indicator.mesh);
      this.indicator.mesh.visible = true;
      controller.children[0].visible = true;
      // }
    };
    // const debugService = DebugService.getService();
    // debugService.setMessage('DebugService 1001');
    const onPress = event => {
      // Logger.log('WorldComponent.Gamepad.onPress', event, controller);
      // debugService.setMessage('Gamepad.onPress ' + event.index);
      // 0: select
      // 1: squeeze
      // 4: x / a
      // 5: y / b
      switch (event.index) {
        case 0:
          // select
          break;
        case 1:
          // squeeze
          break;
        case 4:
          // x / a
          MessageService.send({
            type: MessageType.MenuToggle
          });
          break;
      }
    };
    const onRelease = event => {
      this.onModelUp();
    };
    const onLeft = event => {
      // Logger.log('WorldComponent.Gamepad.onLeft', event, controller);
      // debugService.setMessage('Gamepad.onLeft');
      this.cameraGroup.rotation.y += Math.PI / 180 * 45;
    };
    const onRight = event => {
      // Logger.log('WorldComponent.Gamepad.onRight', event, controller);
      // debugService.setMessage('Gamepad.onRight');
      this.cameraGroup.rotation.y -= Math.PI / 180 * 45;
    };
    /*
    const onAxis = (event) => {
    	// Logger.log('WorldComponent.Gamepad.onAxis', event, controller);
    	// debugService.setMessage('Gamepad.onAxis');
    	this.cameraGroup.rotation.y += (Math.PI / 180 * event.x);
    };
    */
    const onAxis = event => {
      // Logger.log('WorldComponent.Gamepad.onAxis', event, controller);
      // debugService.setMessage('Gamepad.onAxis');
      this.onModelDistance(event.y);
    };
    /*
    const onUp = (event) => {
    	// Logger.log('WorldComponent.Gamepad.onUp', event, controller);
    	// debugService.setMessage('Gamepad.onUp');
    	this.cameraGroup.position.y += 1;
    };
    const onDown = (event) => {
    	// Logger.log('WorldComponent.Gamepad.onDown', event, controller);
    	// debugService.setMessage('Gamepad.onDown');
    	this.cameraGroup.position.y -= 1;
    };
    */
    /*
    const onUp = (event) => {
    	this.onModelDistance(1);
    };
    const onDown = (event) => {
    	this.onModelDistance(-1);
    };
    */
    const onConnected = event => {
      controller.add(this.buildController(event.data));
      if (showPhone && event.data.handedness === 'left') {
        const phone = this.phone = new PhoneElement();
        controller.add(phone.mesh);
      }
      if (!showPhone || event.data.handedness === 'right') {
        const controllerGrip = renderer.xr.getControllerGrip(index);
        controllerGrip.name = `[controller-grip${index + 1}]`;
        const controllerModel = controllerModelFactory.createControllerModel(controllerGrip);
        controller.userData.model = controllerModel;
        controllerGrip.add(controllerModel);
        controllerGroup.add(controllerGrip);
      }
      const gamepad = new Gamepad(event.data.gamepad);
      gamepad.on('press', onPress);
      gamepad.on('release', onRelease);
      gamepad.on('left', onLeft);
      gamepad.on('right', onRight);
      gamepad.on('axis', onAxis);
      // gamepad.on('up', onUp);
      // gamepad.on('down', onDown);
      controller.userData.gamepad = gamepad;
      controller.userData.update = () => {
        gamepad.update();
      };
    };
    const onDisconnected = event => {
      while (controller.children.length) {
        controller.remove(controller.children[0]);
      }
      const controllerGrip = renderer.xr.getControllerGrip(index);
      while (controllerGrip.children.length) {
        controllerGrip.remove(controllerGrip.children[0]);
      }
      controllerGroup.remove(controllerGrip);
      controller.userData.update = () => {};
      const gamepad = controller.userData.gamepad;
      if (gamepad) {
        gamepad.off('press', onPress);
        gamepad.off('release', onRelease);
        gamepad.off('left', onLeft);
        gamepad.off('right', onRight);
        gamepad.off('axis', onAxis);
        // gamepad.off('up', onUp);
        // gamepad.off('down', onDown);
        delete controller.userData.gamepad;
      }
      teleport.removeFromController(controller, scene, renderer, camera, cameraGroup);
    };
    controller.userData.update = () => {};
    controller.addEventListener('selectstart', onSelectStart);
    controller.addEventListener('selectend', onSelectEnd);
    controller.addEventListener('connected', onConnected);
    controller.addEventListener('disconnected', onDisconnected);
    controller.addEventListener('squeezestart', onSqueezeStart);
    controller.addEventListener('squeezeend', onSqueezeEnd);
    const controllers = this.controllers;
    controllers.push(controller);
  }
  buildController(data) {
    // Logger.log('WorldComponent.buildController', data);
    let geometry, material;
    switch (data.targetRayMode) {
      case 'tracked-pointer':
        geometry = new THREE.BufferGeometry();
        geometry.setAttribute('position', new THREE.Float32BufferAttribute([0, 0, 0, 0, 0, -1], 3));
        geometry.setAttribute('color', new THREE.Float32BufferAttribute([0.5, 0.5, 0.5, 0, 0, 0], 3));
        material = new THREE.LineBasicMaterial({
          vertexColors: true,
          blending: THREE.AdditiveBlending
        });
        return new THREE.Line(geometry, material);
      case 'gaze':
        geometry = new THREE.RingBufferGeometry(0.02, 0.04, 32).translate(0, 0, -1);
        material = new THREE.MeshBasicMaterial({
          opacity: 0.5,
          transparent: true
        });
        return new THREE.Mesh(geometry, material);
    }
  }
  updateRaycasterXR(controller, raycaster) {
    if (controller) {
      this.controllerMatrix_.identity().extractRotation(controller.matrixWorld);
      raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
      raycaster.ray.direction.set(0, 0, -1).applyMatrix4(this.controllerMatrix_);
      // raycaster.camera = this.host.renderer.xr.getCamera(this.camera);
      return raycaster;
    }
  }
  repos(object, rect) {
    const worldRect = this.worldRect;
    const sx = 0.8;
    // const sx = rect.width / worldRect.width;
    // const sy = rect.height / worldRect.height;
    object.scale.set(sx, sx, sx);
    // const tx = ((rect.x + rect.width / 2) - worldRect.width / 2) / worldRect.width * 2.0 * this.camera.aspect; // * cameraRect.width / worldRect.width - cameraRect.width / 2;
    // const ty = ((rect.y + rect.height / 2) - worldRect.height / 2) / worldRect.height * 2.0 * this.camera.aspect; // * cameraRect.height / worldRect.height - cameraRect.height / 2;
    const tx = (rect.x + rect.width / 2 - worldRect.width / 2) / worldRect.width * 2.0 * this.camera.aspect;
    const ty = (rect.y + rect.height / 2 - worldRect.height / 2) / worldRect.height * 2.0 * this.camera.aspect;
    // console.log(tx);
    // const position = new THREE.Vector3(tx, ty, 0).unproject(this.camera);
    object.position.set(tx, -ty, 0);
    // console.log(tx, -ty, 0);
  }

  render(delta) {
    try {
      const renderer = this.renderer,
        scene = this.scene,
        camera = this.camera,
        avatars = this.avatars;
      const isPresenting = renderer.xr.isPresenting;
      if (!isPresenting && StateService.state.mode === UIMode.LiveMeeting) {
        // !!! || (StateService.state.remoteScreen !== null)
        return;
      }
      if (isPresenting) {
        gsap.ticker.tick();
        this.controllers.forEach(controller => controller.userData.update());
        this.teleport.update();
      } else {
        this.navWithKeys();
      }
      this.orbitService.render();
      const time = performance.now();
      const tick = this.tick_ ? ++this.tick_ : this.tick_ = 1;
      scene.traverse(child => {
        const render = child.userData.render;
        if (typeof render === 'function') {
          render(time, tick, renderer, scene, camera);
        }
      });
      Object.keys(avatars).forEach(key => {
        avatars[key].render();
      });
      this.vrService.updateState(this);
      this.raycasterXRHitTest();
      renderer.render(scene, camera);
    } catch (error) {
      this.error = error;
      // throw (error);
    }
  }

  navWithKeys() {
    if (this.view && this.view.type.name === ViewType.Room3d.name && this.view.mesh && !this.locked && !ModalService.hasModal) {
      this.intersectObjects = this.view.intersectObjects;
      const velocity = this.velocity || (this.velocity = new THREE.Vector3());
      const direction = this.direction || (this.direction = new THREE.Vector3());
      const camera = this.camera;
      const speed = 0.1;
      if (this.keys.w || this.keys.ArrowUp) {
        camera.getWorldDirection(direction);
        direction.multiplyScalar(speed);
        velocity.copy(direction);
      } else if (this.keys.s || this.keys.ArrowDown) {
        camera.getWorldDirection(direction);
        direction.multiplyScalar(-speed);
        velocity.copy(direction);
      } else if (this.keys.d || this.keys.ArrowRight) {
        camera.getWorldDirection(direction);
        direction.multiplyScalar(speed);
        const axisY = this.axisY || (this.direction = new THREE.Vector3(0, 1, 0));
        const angle = -Math.PI / 2;
        direction.applyAxisAngle(axisY, angle);
        velocity.copy(direction);
      } else if (this.keys.a || this.keys.ArrowLeft) {
        camera.getWorldDirection(direction);
        direction.multiplyScalar(-speed);
        const axisY = this.axisY || (this.direction = new THREE.Vector3(0, 1, 0));
        const angle = -Math.PI / 2;
        direction.applyAxisAngle(axisY, angle);
        velocity.copy(direction);
      }
      const manhattanLength = velocity.manhattanLength();
      if (manhattanLength > 0.00001) {
        // console.log(velocity.x, velocity.y, velocity.z);
        direction.copy(this.cameraGroup.position);
        direction.add(velocity);
        direction.y = 0;
        const raycaster = this.raycaster;
        raycaster.set(direction, DOWN);
        const intersects = raycaster.intersectObjects(this.view.navIntersectObjects);
        if (intersects.length) {
          // console.log(manhattanLength, intersects);
          this.cameraGroup.position.add(velocity);
          this.cameraGroup.position.y = 0;
          this.orbitService.markAsDirty();
          // this.orbitService.events$.next(OrbitService.orbitMoveEvent);
          // camera.updateProjectionMatrix();
        }

        velocity.lerp(ZERO, 0.1);
      } else {
        velocity.set(0, 0, 0);
      }
    } else {
      this.intersectObjects = this.panoramaIntersectObjects;
    }
  }
  animate() {
    const renderer = this.renderer;
    renderer.setAnimationLoop(this.render);
  }
  resize() {
    try {
      const container = this.container,
        renderer = this.renderer,
        camera = this.camera;
      const size = this.size;
      const rect = container.getBoundingClientRect();
      size.left = Math.floor(rect.left);
      size.top = Math.floor(rect.top);
      size.width = Math.ceil(rect.width);
      size.height = Math.ceil(rect.height);
      size.aspect = size.width / size.height;
      const worldRect = this.worldRect;
      worldRect.setSize(size.width, size.height);
      if (!renderer.xr.isPresenting) {
        renderer.setSize(size.width, size.height);
        if (camera) {
          camera.aspect = size.width / size.height;
          const angle = camera.fov * Math.PI / 180;
          const height = Math.abs(camera.position.z * Math.tan(angle / 2) * 2);
          const cameraRect = this.cameraRect;
          cameraRect.width = height * camera.aspect;
          cameraRect.height = height;
          // Logger.log('WorldComponent.position', camera.position.z, 'angle', angle, 'height', height, 'aspect', camera.aspect, cameraRect);
          camera.updateProjectionMatrix();
        }
      }
      // this.render();
    } catch (error) {
      this.error = error;
      // throw (error);
    }
  }

  updateRaycasterMouse(event) {
    const w2 = this.size.width / 2;
    const h2 = this.size.height / 2;
    this.mouse.x = (event.clientX - this.size.left - w2) / w2;
    this.mouse.y = -(event.clientY - this.size.top - h2) / h2;
    const raycaster = this.raycaster;
    raycaster.setFromCamera(this.mouse, this.camera);
    return raycaster;
  }
  raycasterXRHitTest() {
    if (this.renderer.xr.isPresenting && !this.locked) {
      const raycaster = this.updateRaycasterXR(this.controller, this.raycaster);
      if (raycaster) {
        Interactive.hittest(raycaster, this.controller.userData.isSelecting);
        this.indicator.update(this.renderer.xr.getCamera(this.camera));
        /*
        if (hit && hit !== this.panorama.mesh) {
        	// controllers.feedback();
        }
        */
      }
    }
  }

  raycasterDesktopHitTest(event) {
    const raycaster = this.updateRaycasterMouse(event);
    if (this.lockedOrXR) {
      return;
    }
    if (this.dragItem) {
      if (typeof this.dragItem.onDragMove === 'function') {
        const intersections = raycaster.intersectObjects(this.intersectObjects);
        if (intersections.length) {
          const intersection = intersections[0];
          // this.panorama.mesh.intersection = intersection;
          const intersectionPoint = this.intersectionPoint || (this.intersectionPoint = new THREE.Vector3());
          const intersectionNormal = this.intersectionNormal || (this.intersectionNormal = new THREE.Vector3());
          const position = intersectionPoint.copy(intersection.point);
          const normal = intersectionNormal.copy(intersection.face.normal);
          this.dragItem.onDragMove(position, normal, this.intersectObjects === this.panoramaIntersectObjects);
        }
      }
    } else if (this.resizeItem) ; else {
      Interactive.hittest(raycaster);
      this.controlEvent$.next(CONTROL_INFO);
    }
  }
  onMouseDown(event) {
    try {
      if (this.locked) {
        return;
      }
      if (event.button !== 0) {
        return;
      }
      const raycaster = this.updateRaycasterMouse(event);
      const hit = Interactive.hittest(raycaster, true);
      if (this.editor || DEBUG) {
        if (!(this.keys.Shift || this.keys.Control)) {
          this.select.next({
            item: null
          });
          const intersections = raycaster.intersectObjects(this.intersectObjects);
          if (intersections.length) {
            const intersection = intersections[0];
            const intersectionPoint = this.intersectionPoint || (this.intersectionPoint = new THREE.Vector3());
            const intersectionNormal = this.intersectionNormal || (this.intersectionNormal = new THREE.Vector3());
            const position = intersectionPoint.copy(intersection.point);
            const normal = intersectionNormal.copy(intersection.face.normal);
            this.viewHit.next({
              position,
              normal,
              spherical: this.intersectObjects === this.panoramaIntersectObjects
            });
          }
          /*
          if (this.panorama.mesh.intersection) {
          	const position = new THREE.Vector3().copy(this.panorama.mesh.intersection.point).normalize();
          	// console.log(JSON.stringify({ position: position.toArray() }));
          	this.viewHit.next(position);
          }
          */
        }
      } else if (this.isTouchDevice() && hit && hit.name === '[panorama]') {
        const item = this.view.items.find(item => item.showPanel);
        if (item) {
          item.showPanel = false;
          this.pushChanges();
          // console.log(item, hit, this.view.items);
        }
      }
    } catch (error) {
      this.error = error;
      // throw (error);
    }
  }

  onMouseMove(event) {
    try {
      this.raycasterDesktopHitTest(event);
    } catch (error) {
      this.error = error;
      // throw (error);
    }
  }

  onMouseUp(event) {
    try {
      if (this.lockedOrXR) {
        return;
      }
      if (this.dragItem) {
        if (typeof this.dragItem.onDragEnd === 'function') {
          this.dragItem.onDragEnd();
          this.dragEnd.next(this.dragItem);
        }
      }
      this.dragItem = null;
      if (this.resizeItem) {
        if (typeof this.resizeItem.onResizeEnd === 'function') {
          this.resizeItem.onResizeEnd();
          this.resizeEnd.next(this.resizeItem);
        }
      }
      this.resizeItem = null;
      const raycaster = this.updateRaycasterMouse(event);
      const hit = Interactive.hittest(raycaster, false);
      this.checkSelectedItem();
    } catch (error) {
      this.error = error;
      // throw (error);
    }
  }

  onMouseWheel(event) {
    try {
      if (this.lockedOrXR) {
        return;
      }
      const deltaY = event.deltaY * (event.wheelDeltaY !== undefined ? 1 : 37);
      const orbitService = this.orbitService;
      gsap.to(orbitService, {
        duration: 0.5,
        zoom: orbitService.zoom + deltaY * 0.1,
        ease: Power4.easeOut,
        overwrite: true
      });
    } catch (error) {
      this.error = error;
      // throw (error);
    }
  }

  onOrientationDidChange() {
    this.controlEvent$.next(CONTROL_INFO);
  }
  checkSelectedItem() {
    if (this.view) {
      const selected = this.view.items.find(item => item.selected);
      if (selected && selected.mesh) {
        if (this.view.type.name !== 'model') {
          this.orbitService.lookAt(selected.mesh);
        }
      }
    }
  }
  onVRStarted() {
    // this.objects.rotation.y = - Math.PI / 2;
    this.objects.position.y = 1.3;
    this.scene.add(this.indicator.mesh);
    MessageService.send({
      type: MessageType.VRStarted
    });
  }
  onVREnded() {
    // this.objects.rotation.y = 0;
    this.objects.position.y = 0;
    this.cameraGroup.rotation.y = 0;
    this.cameraGroup.position.y = 0;
    this.scene.remove(this.indicator.mesh);
    this.orbitService.markAsDirty();
    MessageService.send({
      type: MessageType.VREnded
    });
  }
  onVRStateDidChange(state) {
    MessageService.send({
      type: MessageType.VRState,
      camera: state.camera.array
    });
  }
  onMenuNav(event) {
    // Logger.log('WorldComponent.onMenuNav', event.id, event);
    this.menu = undefined;
    this.navTo.next({
      viewId: event.id
    });
  }
  onMenuToggle(event) {
    // Logger.log('WorldComponent.onMenuToggle', event.id, event);
    if (this.locked) {
      return;
    }
    this.menu = event;
    this.view.items.forEach(item => item.showPanel = false);
    this.pushChanges();
  }
  onNavOver(nav) {
    if (this.menu) {
      return;
      // this.menu.removeMenu();
    }

    this.view.items.forEach(item => item.showPanel = false);
    if (nav.item.to) {
      clearTimeout(nav.item.to);
    }
    nav.item.showPanel = nav.shouldShowPanel();
    // Logger.log('WorldComponent.onNavOver', nav, nav.item.showPanel);
    this.pushChanges();
    MessageService.send({
      type: MessageType.ShowPanel,
      itemId: nav.item.showPanel ? nav.item.id : null
    });
  }
  onNavOut(nav) {
    // Logger.log('WorldComponent.onNavOut', nav);
    if (this.isTouchDevice()) {
      return;
    }
    // nav.item.showPanel = false;
    nav.item.to = setTimeout(() => {
      nav.item.showPanel = false;
      this.pushChanges();
    }, 6000);
    this.pushChanges();
  }
  onNavDown(event) {
    if (!this.isTouchDevice()) {
      event.item.showPanel = false;
    }
    // Logger.log('WorldComponent.onNavDown', this.keys);
    if (this.locked) {
      return;
    }
    if (this.editor && this.keys.Shift) {
      this.dragItem = event;
      this.select.next(event);
    } else if (this.editor && this.keys.Control) {
      this.resizeItem = event;
      this.select.next(event);
    } else {
      this.navTo.next(event.item);
    }
  }
  onNavLink(event) {
    // Logger.log('WorldComponent.onNavLink', event.link.href);
    if (this.locked || this.editor) {
      return;
    }
    if (environment.flags.useIframe) {
      MessageService.send({
        type: MessageType.NavLink,
        itemId: event.item.id,
        linkIndex: event.linkIndex
      });
      this.navLink.next(event);
    } else {
      window.open(event.link.href, '_blank');
    }
  }
  isTouchDevice() {
    return 'ontouchstart' in window || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0;
  }
  onModelDown(event) {
    if (this.editor) {
      return this.onObjectDown(event);
    }
    // vr controller model grab
    const controller = this.controller;
    if (controller && this.renderer.xr.isPresenting) {
      const target = this.tempTarget = event.mesh;
      // Logger.log('WorldComponent.onModelDown', target);
      // DebugService.getService().setMessage('onModelDown ', target.name);
      this.tempParent = target.parent;
      const position = new THREE.Vector3();
      target.localToWorld(position);
      controller.worldToLocal(position);
      controller.add(target);
      target.position.copy(position);
    }
  }
  onModelDistance(direction) {
    // vr controller model distance
    const controller = this.controller;
    const target = this.tempTarget;
    if (controller && target && this.renderer.xr.isPresenting) {
      let position = new THREE.Vector3();
      position = position.copy(target.position);
      const distance = Math.max(1, Math.min(8, position.distanceTo(ZERO) + 0.02 * direction));
      position.normalize();
      position = position.multiplyScalar(distance);
      // DebugService.getService().setMessage('onModelDistance ' + distance);
      target.position.copy(position);
    }
  }
  onModelUp() {
    // vr controller model release
    const target = this.tempTarget;
    const parent = this.tempParent;
    if (target && parent) {
      // Logger.log('WorldComponent.onModelUp', target, parent);
      const position = new THREE.Vector3();
      target.localToWorld(position);
      parent.worldToLocal(position);
      parent.add(target);
      target.position.copy(position);
      this.tempTarget = null;
      this.tempParent = null;
    }
  }
  onObjectDown(event) {
    // Logger.log('WorldComponent.onObjectDown', this.keys);
    if (this.lockedOrXR) {
      return;
    }
    if (this.editor && this.keys.Shift) {
      this.dragItem = event;
      this.select.next(event);
    } else if (this.editor && this.keys.Control) {
      this.resizeItem = event;
      this.select.next(event);
    }
  }
  onPanelDown(event) {
    // Logger.log('WorldComponent.onPanelDown', event.link.href);
    if (this.locked) {
      return;
    }
    if (environment.flags.useIframe) {
      MessageService.send({
        type: MessageType.NavLink,
        itemId: event.item.id,
        linkIndex: event.linkIndex
      });
      this.navLink.next(event);
    } else {
      window.open(event.link.href, '_blank');
      /*
      const href = event.getAttribute('href');
      const target = event.getAttribute('target') || '_self';
      if (href) {
      	window.open(href, '_blank');
      }
      */
    }
  }

  onPlayMedia(event) {
    if (this.editor) {
      return;
    }
    MessageService.send({
      type: MessageType.PlayMedia,
      itemId: event.itemId,
      playing: event.playing
    });
  }
  onZoomMedia(event) {
    if (event.zoomed) {
      this.view.items.forEach(item => {
        if (item.mesh instanceof MediaMesh) {
          // console.log(item.id, event.itemId, item.id !== event.itemId);
          if (item.id !== event.itemId) {
            item.mesh.setZoomedState(false);
          }
        }
      });
    }
    this.view.items.forEach(item => item.showPanel = false);
    StateService.patchState({
      zoomedId: event.zoomed ? event.itemId : null
    });
    MessageService.send({
      type: MessageType.ZoomMedia,
      itemId: event.itemId,
      zoomed: event.zoomed
    });
  }
  onCurrentTimeMedia(event) {
    if (this.editor) {
      return;
    }
    MessageService.send({
      type: MessageType.CurrentTimeMedia,
      itemId: event.itemId,
      currentTime: event.currentTime
    });
  }
  onPlayModel(event) {
    if (this.editor) {
      return;
    }
    MessageService.send({
      type: MessageType.PlayModel,
      itemId: event.itemId,
      actionIndex: event.actionIndex
    });
  }
  onGridMove(event) {
    // Logger.log('WorldComponent.onGridMove', event, this.view);
    this.view.items = [];
    this.pushChanges();
    this.orbitService.walk(event.position, (headingLongitude, headingLatitude) => {
      const tile = this.view.getTile(event.indices.x, event.indices.y);
      if (tile) {
        this.panorama.crossfade(tile, this.renderer, texture => {
          if (!environment.flags.useTextureEnvironment) {
            this.setBackground(texture);
          }
          this.orbitService.walkComplete(headingLongitude, headingLatitude);
          this.view.updateCurrentItems();
          // this.loading = null;
          this.pushChanges();
          // this.render();
          // this.pushChanges();
        });
      }
    });
  }

  onGridNav(event) {
    // Logger.log('WorldComponent.onGridNav', event);
    if (this.locked) {
      return;
    }
    MessageService.send({
      type: MessageType.NavToGrid,
      viewId: this.view.id,
      gridIndex: event
    });
    this.pushChanges();
  }
  setSnapshot(snapshot) {
    if (ViewService.viewId !== snapshot.viewId) {
      ViewService.viewId = snapshot.viewId;
      this.requestInfoResult = snapshot;
    } else {
      if (!this.renderer.xr.isPresenting) {
        this.orbitService.setOrientation(snapshot.orientation);
        this.orbitService.zoom = snapshot.zoom;
        this.cameraGroup.position.set(snapshot.cameraGroup.position[0], snapshot.cameraGroup.position[1], snapshot.cameraGroup.position[2]);
        this.cameraGroup.rotation.set(snapshot.cameraGroup.rotation[0], snapshot.cameraGroup.rotation[1], snapshot.cameraGroup.rotation[2]);
        // this.camera.updateProjectionMatrix();
      }

      if (this.view instanceof PanoramaGridView && snapshot.gridIndex) {
        this.view.index = snapshot.gridIndex;
      }
      if (!this.view || !this.view.ready) {
        this.requestInfoResult = snapshot;
      }
    }
  }
  getSnapshot() {
    const snapshot = _objectSpread2(_objectSpread2({}, CONTROL_INFO), {}, {
      viewId: this.view.id,
      type: MessageType.SetSnapshot
    });
    if (this.view instanceof PanoramaGridView) {
      snapshot.gridIndex = this.view.index;
    }
    return snapshot;
  }
  sendSetSnapshot() {
    const snapshot = this.getSnapshot();
    // snapshot.type = MessageType.SetSnapshot;
    MessageService.send(snapshot);
  }
  control$() {
    return this.controlEvent$.pipe(operators.filter(() => this.controlling || this.spyed || this.editor), operators.auditTime(Math.floor(1000 / 15)), operators.map(control => {
      /**
       * here we are updating original CONTROL_INFO object
       */
      control.orientation.latitude = this.orbitService.latitude;
      control.orientation.longitude = this.orbitService.longitude;
      control.zoom = this.orbitService.zoom;
      control.cameraGroup = {
        position: this.cameraGroup.position.toArray(),
        rotation: this.cameraGroup.rotation.toArray()
      };
      const intersections = this.raycaster.intersectObjects(this.intersectObjects);
      const point = intersections.length ? intersections[0].point.normalize() : null;
      if (point) {
        control.pointer[0] = point.x;
        control.pointer[1] = point.y;
        control.pointer[2] = point.z;
      }
      MessageService.send(control);
      return control;
    }), operators.auditTime(4000), operators.tap(control => {
      /**
       * !!! every 4 seconds we save the last view snapshot
       */
      const snapshot = this.getSnapshot();
      // snapshot.type = MessageType.SetSnapshot;
      MessageService.send(snapshot);
    }));
  }
  addListeners() {
    this.controlEvent$ = new rxjs.ReplaySubject(1);
    this.control$().pipe(operators.takeUntil(this.unsubscribe$)).subscribe();
    const vrService = this.vrService = VRService.getService();
    vrService.session$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(session => {
      this.renderer.xr.setSession(session);
      if (session) {
        this.onVRStarted();
      } else {
        this.onVREnded();
      }
    });
    vrService.state$.pipe(operators.takeUntil(this.unsubscribe$), operators.auditTime(Math.floor(1000 / 15))).subscribe(state => {
      this.onVRStateDidChange(state);
    });
    const orbit$ = this.orbitService.observe$(this.container).pipe(operators.shareReplay(1));
    /*
    const drag$ = orbit$.pipe(
    	filter(event => event instanceof OrbitDragEvent),
    );
    */
    const orientation$ = orbit$.pipe(operators.filter(event => event instanceof OrbitMoveEvent), operators.auditTime(Math.floor(1000 / 15)));
    orientation$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(event => {
      // this.render();
      this.onOrientationDidChange();
    });
    MessageService.out$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(message => {
      Logger.log('WorldComponent.addListeners', 'MessageService.out$', message);
      switch (message.type) {
        case MessageType.RequestControl:
          {
            Logger.log('WorldComponent.MessageType.RequestControl', message.controllingId);
            StateService.patchState({
              controlling: message.controllingId,
              spying: false
            });
            if (message.controllingId === StateService.state.uid) {
              this.sendSetSnapshot();
            }
            break;
          }
        case MessageType.RequestSpy:
          {
            Logger.log('WorldComponent.MessageType.RequestSpy', message.spyingId);
            StateService.patchState({
              spying: message.spyingId,
              controlling: false
            });
            if (message.spyingId === StateService.state.uid) {
              this.sendSetSnapshot();
            }
            break;
          }
        case MessageType.SetSnapshot:
          this.setSnapshot(message);
          break;
        case MessageType.ShowPanel:
          if (this.menu) {
            this.menu.removeMenu();
          }
          this.view.items.forEach(item => item.showPanel = item.id === message.itemId);
          this.pushChanges();
          break;
        case MessageType.NavLink:
          {
            const item = this.view.items.find(item => item.id === message.itemId);
            if (item) {
              const link = item.links[message.linkIndex];
              this.navLink.next({
                item,
                link,
                linkIndex: message.linkIndex
              });
            }
            break;
          }
        case MessageType.NavLinkClose:
          {
            const closeItem = this.view.items.find(item => item.id === message.itemId);
            if (closeItem) {
              ModalService.resolve();
            }
            break;
          }
        case MessageType.PlayMedia:
          {
            // !!! uniformare a PlayModel
            const item = this.view.items.find(item => item.id === message.itemId);
            if (item && item.mesh instanceof MediaMesh) {
              item.mesh.setPlayingState(message.playing);
            }
            break;
          }
        case MessageType.ZoomMedia:
          {
            this.view.items.forEach(item => {
              if (item.mesh instanceof MediaMesh) {
                if (item.id === message.itemId) {
                  item.mesh.setZoomedState(message.zoomed);
                } else {
                  item.mesh.setZoomedState(false);
                }
              }
            });
            StateService.patchState({
              zoomedId: message.zoomed ? message.itemId : null
            });
            break;
          }
        case MessageType.CurrentTimeMedia:
          {
            const item = this.view.items.find(item => item.id === message.itemId);
            if (item && item.mesh instanceof MediaMesh) {
              item.mesh.setCurrentTime(message.currentTime);
            }
            break;
          }
        case MessageType.PlayModel:
          {
            const item = this.view.items.find(item => item.id === message.itemId);
            if (item) {
              item.onMessage(message);
            }
            break;
          }
        case MessageType.NavToGrid:
          // Logger.log('WorldComponent.NavToGrid', this.view.id, message);
          if (this.view.id === message.viewId) {
            this.view.index = message.gridIndex;
          }
          break;
        case MessageType.VRStarted:
          this.addOffCanvasScene(message);
          break;
        case MessageType.VREnded:
          this.removeOffCanvasScene(message);
          break;
        case MessageType.VRState:
          this.updateOffCanvasScene(message);
          if (StateService.state.spying === message.clientId || StateService.state.controlling === message.clientId) {
            this.orbitService.setVRCamera(message.camera);
          }
          break;
        case MessageType.ControlInfo:
          if (!this.renderer.xr.isPresenting) {
            this.orbitService.setOrientation(message.orientation);
            this.orbitService.zoom = message.zoom;
            this.cameraGroup.position.set(message.cameraGroup.position[0], message.cameraGroup.position[1], message.cameraGroup.position[2]);
            this.cameraGroup.rotation.set(message.cameraGroup.rotation[0], message.cameraGroup.rotation[1], message.cameraGroup.rotation[2]);
            // this.camera.updateProjectionMatrix();
          }

          this.pointer.setPosition(message.pointer[0], message.pointer[1], message.pointer[2], this.camera);
          break;
      }
    });
    MessageService.in$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(message => {
      switch (message.type) {
        case MessageType.SelectItem:
          this.checkSelectedItem();
          break;
      }
    });
    StateService.state$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(state => {
      this.state = state;
      this.showPointer = this.locked;
      // console.log(state);
      // this.pushChanges();
    });

    this.resize = this.resize.bind(this);
    this.render = this.render.bind(this);
    this.onMouseDown = this.onMouseDown.bind(this);
    this.onMouseMove = this.onMouseMove.bind(this);
    this.onMouseUp = this.onMouseUp.bind(this);
    this.onMouseWheel = this.onMouseWheel.bind(this);
    // this.controls.addEventListener('change', this.render); // use if there is no animation loop
    window.addEventListener('resize', this.resize, false);
    this.container.addEventListener('wheel', this.onMouseWheel, false);
    this.container.addEventListener('mousedown', this.onMouseDown, false);
    this.container.addEventListener('mouseup', this.onMouseUp, false);
    document.addEventListener('mousemove', this.onMouseMove, false);
  }
  removeListeners() {
    window.removeEventListener('resize', this.resize, false);
    window.removeEventListener('resize', this.resize, false);
    document.removeEventListener('mousemove', this.onMouseMove, false);
    document.removeEventListener('wheel', this.onMouseWheel, false);
    this.container.removeEventListener('mousedown', this.onMouseDown, false);
    this.container.removeEventListener('mouseup', this.onMouseUp, false);
  }
}
WorldComponent.meta = {
  selector: '[world]',
  inputs: ['view', 'views', 'editor'],
  outputs: ['navTo', 'navLink', 'viewHit', 'dragEnd', 'resizeEnd', 'select'],
  template: /* html */`
	<div class="world__view" *if="view">
		<div class="grid" model-grid *if="view.type.name === 'panorama-grid'" [view]="view" (move)="onGridMove($event)" (nav)="onGridNav($event)"></div>
		<div *if="view.ready">
			<div model-room [view]="view" *if="view.type.name === 'room-3d'"></div>
			<div class="world__item" *for="let item of view.pathItems; let index = index;">
				<div model-nav [item]="item" [view]="view" (over)="onNavOver($event)" (out)="onNavOut($event)" (down)="onNavDown($event)" (link)="onNavLink($event)" *if="item.type.name == 'nav'"></div>
				<div model-plane [item]="item" [view]="view" (play)="onPlayMedia($event)" (zoom)="onZoomMedia($event)" (down)="onObjectDown($event)" (currentTime)="onCurrentTimeMedia($event)" *if="item.type.name == 'plane'"></div>
				<div model-curved-plane [item]="item" [view]="view" (play)="onPlayMedia($event)" (zoom)="onZoomMedia($event)" (down)="onObjectDown($event)" (currentTime)="onCurrentTimeMedia($event)" *if="item.type.name == 'curved-plane'"></div>
				<div class="model-viewer__item" model-model [item]="item" [view]="view" (down)="onModelDown($event)" (play)="onPlayModel($event)" *if="item.type.name == 'model'"></div>
				<div class="panel" [class]="{ 'panel--lg': item.asset != null }" model-panel [item]="item" (down)="onPanelDown($event)" *if="item.showPanel"></div>
			</div>
		</div>
	</div>
	<div class="progress-indicator" model-progress [view]="view">
		<div class="inner"></div>
	</div>
	<div model-menu [views]="views" (nav)="onMenuNav($event)" (toggle)="onMenuToggle($event)" *if="showMenu"></div>
	<div model-debug *if="debugging"></div>
	<div class="world__info" *if="error" [innerHTML]="error"></div>
	`
};class ModelComponent extends rxcomp.Component {
  set renderOrder(renderOrder) {
    this.group.renderOrder = renderOrder;
  }
  onInit() {
    // console.log('ModelComponent.onInit');
    // console.log('item', this.item, 'host', this.host);
    if (!this.host) {
      throw 'ModelComponent host is undefined';
    }
    this.scale = new THREE.Vector3(1.0, 1.0, 1.0);
    this.position = new THREE.Vector3();
    const group = this.group = new THREE.Group();
    group.name = this.getName();
    group.userData.render = (time, tick) => {
      // if (this.intersection) {
      this.render(this, time, tick);
      // }
    };

    this.getContainer().add(group);
    this.onCreate((mesh, item) => this.onMount(mesh, item), (mesh, item) => this.onDismount(mesh, item));
  }
  onDestroy() {
    // console.log('ModelComponent', this);
    const group = this.group;
    this.getContainer().remove(group);
    delete group.userData.render;
    this.disposeObject(group);
    this.group = null;
  }
  getContainer() {
    return this.host.objects;
  }
  getName(name) {
    return `${this.constructor.meta.selector}-${this.rxcompId}${name ? `-${name}` : ''}`;
  }
  onCreate(mounth, dismount) {
    const material = new THREE.MeshStandardMaterial({
      color: new THREE.Color('#ffcc00'),
      roughness: 0.4,
      metalness: 0.01,
      flatShading: true,
      transparent: true,
      opacity: 0.9
    });
    const mesh = new THREE.Mesh(Geometry.defaultGeometry, material);
    if (typeof mounth === 'function') {
      mounth(mesh);
    }
    return mesh;
  }
  onMount(mesh, item) {
    if (this.mesh) {
      // console.log('ModelComponent.dismount.mesh');
      this.onDismount(this.mesh);
    }
    mesh.name = this.getName('mesh');
    this.mesh = mesh;
    if (item) {
      item.mesh = mesh;
      Object.defineProperty(item, 'visible', {
        get: () => {
          return mesh.visible;
        },
        set: visible => {
          this.setVisible(visible);
        },
        configurable: true
      });
      item.onUpdate = () => {
        this.onUpdate(item, mesh);
      };
      item.onUpdateAsset = () => {
        this.onUpdateAsset(item, mesh);
      };
      item.onMessage = message => {
        this.onMessage(message);
      };
    }
    if (this.group) {
      this.group.add(mesh);
    }
    // this.host.render(); !!!
    /*
    const node = this.node;
    DomService.scrollIntersection$(node).subscribe(event => {
    	this.scroll = event.scroll;
    	this.intersection = event.intersection;
    	this.calculateScaleAndPosition();
    });
    */
    // console.log('Model.loaded', mesh);
  }

  onDismount(mesh, item) {
    this.group.remove(mesh);
    if (typeof mesh.dispose === 'function') {
      mesh.dispose();
    }
    this.disposeObject(mesh);
    this.mesh = null;
    if (item) {
      delete item.mesh;
      delete item.onUpdate;
      delete item.onUpdateAsset;
      delete item.onMessage;
    }
  }
  disposeObject(object) {
    object.traverse(child => {
      if (child.isInteractiveMesh || child.isInteractiveSprite) {
        Interactive.dispose(child);
      }
      if (child.isMesh) {
        if (child.material.map && child.material.map.disposable !== false) {
          child.material.map.dispose();
        }
        child.material.dispose();
        child.geometry.dispose();
      } else if (child.isSprite) {
        if (child.material.map && child.material.map.disposable !== false) {
          child.material.map.dispose();
        }
        child.material.dispose();
      }
    });
    // console.log('ModelComponent.disposeObject', object);
  }

  calculateScaleAndPosition() {
    const {
      node
    } = rxcomp.getContext(this);
    this.host.repos(this, node.getBoundingClientRect());
  }
  render(time, tick) {
    /*
    this.calculateScaleAndPosition();
    const group = this.group;
    const scale = this.scale;
    // group.scale.set(scale.x, scale.y, scale.z);
    const position = this.position;
    group.position.set(position.x, 0, 0);
    // const tween = this.tween();
    // group.rotation.x = THREE.Math.degToRad(180) * tween;
    // group.rotation.y = THREE.Math.degToRad(360) * tween;
    */
  }
  setVisible(visible) {
    if (this.mesh) {
      this.mesh.visible = visible;
    }
  }
  getScroll(offset) {
    const scroll = this.intersection.scroll(offset);
    // console.log(scroll);
    return scroll;
  }
  getTween(offset) {
    let tween = Math.min(0.0, this.intersection.offset(offset)) + 1;
    tween = Math.max(0.0, tween);
    // tween = Ease.Sine.InOut(tween);
    tween -= 1;
    return tween;
  }

  // called by UpdateViewItemComponent
  onUpdate(item, mesh) {}

  // called by UpdateViewItemComponent
  onUpdateAsset(item, mesh) {}

  // called by remote events
  onMessage(message) {}
}
ModelComponent.meta = {
  selector: '[model]',
  hosts: {
    host: WorldComponent
  },
  inputs: ['item']
};class ModelEditableComponent extends ModelComponent {
  get editing() {
    return this.editing_;
  }
  set editing(editing) {
    if (this.editing_ !== editing) {
      this.editing_ = editing;
      this.setHelper(editing);
    }
  }
  onInit() {
    super.onInit();
    this.RADIUS = 100;
  }
  onDestroy() {
    // console.log('ModelEditableComponent', this);
    this.editing = false;
    super.onDestroy();
  }
  setHelper(showHelper) {
    if (showHelper) {
      if (!this.helper) {
        this.helper = new THREE.BoxHelper(this.mesh, 0x00ff00);
      }
      this.host.scene.add(this.helper);
    } else if (this.helper) {
      this.host.scene.remove(this.helper);
    }
  }
  updateHelper() {
    if (this.helper) {
      this.helper.setFromObject(this.mesh);
      // this.helper.update();
    }
  }
}

ModelEditableComponent.meta = {
  selector: '[model-editable]',
  hosts: {
    host: WorldComponent
  },
  inputs: ['item']
};const NavModeType = {
  None: 'none',
  Move: 'move',
  Info: 'info',
  Point: 'point',
  Title: 'title',
  Transparent: 'transparent',
  Wishlist: 'wishlist'
};
class ModelNavComponent extends ModelEditableComponent {
  constructor() {
    super(...arguments);
    this.hidden_ = false;
    this.isMobile_ = void 0;
  }
  static getLoader() {
    return ModelNavComponent.loader || (ModelNavComponent.loader = new THREE.TextureLoader());
  }
  static getTexturePoint() {
    return ModelNavComponent.texturePoint || (ModelNavComponent.texturePoint = ModelNavComponent.getLoader().load(environment.getPath('textures/ui/nav-point.png')));
  }
  static getTexturePointImportant() {
    return ModelNavComponent.texturePointImportant || (ModelNavComponent.texturePointImportant = ModelNavComponent.getLoader().load(environment.getPath('textures/ui/nav-point-important.png')));
  }
  static getTextureMove() {
    return ModelNavComponent.textureMove || (ModelNavComponent.textureMove = ModelNavComponent.getLoader().load(environment.getPath('textures/ui/nav-more.png')));
  }
  static getTextureMoveImportant() {
    return ModelNavComponent.textureMoveImportant || (ModelNavComponent.textureMoveImportant = ModelNavComponent.getLoader().load(environment.getPath('textures/ui/nav-more-important.png')));
  }
  static getTextureInfo() {
    return ModelNavComponent.textureInfo || (ModelNavComponent.textureInfo = ModelNavComponent.getLoader().load(environment.getPath('textures/ui/nav-info.png')));
  }
  static getTextureInfoImportant() {
    return ModelNavComponent.textureInfoImportant || (ModelNavComponent.textureInfoImportant = ModelNavComponent.getLoader().load(environment.getPath('textures/ui/nav-info-important.png')));
  }
  static getTextureWishlist() {
    return ModelNavComponent.textureWishlist || (ModelNavComponent.textureWishlist = ModelNavComponent.getLoader().load(environment.getPath('textures/ui/nav-wishlist-off.png')));
  }
  static getTextureWishlistAdded() {
    return ModelNavComponent.textureWishlistAdded || (ModelNavComponent.textureWishlistAdded = ModelNavComponent.getLoader().load(environment.getPath('textures/ui/nav-wishlist-on.png')));
  }
  static getTexture(mode, item) {
    let texture;
    switch (mode) {
      case NavModeType.Move:
        texture = item.important ? this.getTextureMoveImportant() : this.getTextureMove();
        break;
      case NavModeType.Info:
        texture = item.important ? this.getTextureInfoImportant() : this.getTextureInfo();
        break;
      case NavModeType.Point:
      case NavModeType.Title:
        texture = item.important ? this.getTexturePointImportant() : this.getTexturePoint();
        break;
      case NavModeType.Wishlist:
        texture = item.added ? this.getTextureWishlistAdded() : this.getTextureWishlist();
        break;
    }
    texture.disposable = false;
    texture.encoding = THREE.sRGBEncoding;
    return texture;
  }
  static getTitleTexture(item, mode) {
    let texture;
    if (mode === NavModeType.Title) {
      const text = item.title;
      const canvas = document.createElement('canvas');
      // document.querySelector('body').appendChild(canvas);
      canvas.width = 512;
      canvas.height = 32;
      const ctx = canvas.getContext('2d');
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = 'high';
      ctx.font = `24px ${environment.fontFamily}`;
      const metrics = ctx.measureText(text);
      let w = metrics.width + 8;
      w = Math.pow(2, Math.ceil(Math.log(w) / Math.log(2)));
      const x = w / 2;
      const y = 16;
      canvas.width = w;
      ctx.font = `24px ${environment.fontFamily}`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.strokeStyle = 'rgba(0, 0, 0, 0.5)';
      ctx.lineWidth = 6;
      ctx.lineJoin = 'round'; // Experiment with 'bevel' & 'round' for the effect you want!
      ctx.miterLimit = 2;
      ctx.strokeText(text, x, y);
      ctx.fillStyle = 'white';
      ctx.fillText(text, x, y);
      texture = new THREE.CanvasTexture(canvas);
    }
    return texture;
  }
  static getNavMode(item, view) {
    let mode = NavModeType.None;
    if (item.hook && item.hook === 'ToggleWishlist') {
      mode = NavModeType.Wishlist;
    } else if (item.transparent) {
      mode = NavModeType.Transparent;
    } else if (item.viewId !== view.id) {
      mode = NavModeType.Move;
      if (this.isValidText(item.title)) {
        mode = NavModeType.Title;
      }
      if (this.isValidText(item.abstract) || item.asset && item.asset.id || item.link && item.link.href) {
        mode = NavModeType.Point;
      }
    } else if (this.isValidText(item.title) || this.isValidText(item.abstract) || item.asset && item.asset.id || item.link && item.link.href) {
      mode = NavModeType.Info;
    }
    return mode;
  }
  static hasNavInfo(view) {
    const item = view.items.find(x => this.getNavMode(x, view) === NavModeType.Info);
    // console.log('ModelNavComponent.hasNavInfo', item);
    return item != null;
  }
  static isValidText(text) {
    return text && text.length > 0;
  }
  get hidden() {
    return this.hidden_;
  }
  set hidden(hidden) {
    if (this.hidden_ !== hidden) {
      this.hidden_ = hidden;
      this.updateVisibility(!hidden);
    }
  }
  get isHidden() {
    return StateService.state.zoomedId != null || environment.flags.hideNavInfo && !this.host.editor && !StateService.state.showNavInfo && !(this.host.renderer.xr.isPresenting || StateService.state.role === RoleType.SelfService || StateService.state.role === RoleType.Embed) && this.mode === NavModeType.Info;
  }
  get isAnimated() {
    let isAnimated = false;
    const mode = this.mode;
    const important = this.item.important;
    switch (mode) {
      case NavModeType.Info:
        isAnimated = important ? environment.flags.navInfoImportantAnimated : environment.flags.navInfoAnimated;
        break;
      case NavModeType.Move:
        isAnimated = important ? environment.flags.navMoveImportantAnimated : environment.flags.navMoveAnimated;
        break;
      case NavModeType.Point:
        isAnimated = important ? environment.flags.navPointImportantAnimated : environment.flags.navPointAnimated;
        break;
      case NavModeType.Title:
        isAnimated = important ? environment.flags.navTitleImportantAnimated : environment.flags.navTitleAnimated;
        break;
      case NavModeType.Transparent:
        isAnimated = important ? environment.flags.navTransparentImportantAnimated : environment.flags.navTransparentAnimated;
        break;
    }
    return isAnimated;
  }
  get iconMinScale() {
    return (environment.navs.iconMinScale || 1) * 0.03 * (this.isMobile ? 1.6 : 1);
  }
  get iconMaxScale() {
    return (environment.navs.iconMaxScale || 1.5) * 0.03 * (this.isMobile ? 1.6 : 1);
  }
  get isMobile() {
    return this.isMobile_;
  }
  set isMobile(isMobile) {
    if (this.isMobile_ !== isMobile) {
      this.isMobile_ = isMobile;
      this.setScale();
    }
  }
  render(time, tick) {
    // console.log('render', this.host.worldRect.width);
    this.isMobile = this.host.worldRect.width < 768;
  }
  setScale(pow) {
    if (pow === void 0) {
      pow = 0;
    }
    const icon = this.icon;
    if (icon) {
      const scale = this.iconMinScale + pow * (this.iconMaxScale - this.iconMinScale);
      icon.scale.set(scale, scale, scale);
    }
  }
  shouldShowPanel() {
    return !this.editing && this.mode !== NavModeType.Move && this.mode !== NavModeType.Title && this.mode !== NavModeType.Wishlist && (this.mode !== NavModeType.Transparent || ModelNavComponent.isValidText(this.item.title));
  }
  updateVisibility(visible) {
    if (this.mesh) {
      this.mesh.visible = visible;
    }
    if (this.sphere) {
      this.sphere.freezed = !visible;
    }
    if (!visible && this.item) {
      this.item.showPanel = false;
    }
  }
  setVisible(visible) {
    if (this.mesh) {
      this.mesh.visible = visible && !this.hidden_;
    }
  }
  onInit() {
    super.onInit();
  }
  onChanges() {
    const view = this.view;
    const item = this.item;
    const mode = this.mode = ModelNavComponent.getNavMode(item, this.view);
    if (mode === NavModeType.Wishlist) {
      item.added = WishlistService.has({
        viewId: view.id,
        itemId: item.id
      });
      this.onCreateSprites(this.mesh, 1);
    }
    this.editing = item.selected;
    this.hidden = this.isHidden;
  }
  onCreate(mount, dismount) {
    // this.renderOrder = environment.renderOrder.nav;
    const view = this.view;
    const item = this.item;
    const mode = this.mode = ModelNavComponent.getNavMode(item, this.view);
    if (mode === NavModeType.None) {
      return;
    }
    if (mode === NavModeType.Wishlist) {
      item.added = WishlistService.has({
        viewId: view.id,
        itemId: item.id
      });
    }
    const isAnimated = this.isAnimated;
    const nav = new THREE.Group();
    if (mode === NavModeType.Transparent) {
      const opacityIdle = this.host.editor ? 0.1 : 0.0;
      const opacityOver = 0.2;
      const opacityDown = 0.3;
      nav.position.fromArray(item.position);
      nav.rotation.fromArray(item.rotation);
      nav.scale.fromArray(item.scale);
      const geometry = Geometry.planeGeometry;
      const plane = this.plane = new InteractiveMesh(geometry, new THREE.MeshBasicMaterial({
        depthTest: false,
        depthWrite: false,
        transparent: true,
        opacity: opacityIdle,
        color: new THREE.Color(environment.colors.menuOverBackground),
        toneMapped: false
      }));
      plane.name = `[nav] ${item.id}`;
      plane.depthTest = false;
      nav.add(plane);
      if (isAnimated) {
        const from = {
          pow: 0
        };
        gsap.to(from, {
          pow: 1,
          duration: 0.6,
          delay: 0.5 + 0.1 * item.index,
          ease: Power2.easeOut,
          repeat: -1,
          yoyo: true,
          onUpdate: () => {
            plane.material.opacity = from.pow * opacityDown;
          }
        });
      }
      plane.on('over', () => {
        if (!isAnimated) {
          plane.material.opacity = opacityOver;
        }
        this.over.next(this);
      });
      plane.on('out', () => {
        if (!isAnimated) {
          plane.material.opacity = opacityIdle;
        }
        this.out.next(this);
      });
      plane.on('down', () => {
        if (!isAnimated) {
          plane.material.opacity = opacityDown;
        }
        this.down.next(this);
        // opening nav link
        const item = this.item;
        const link = item.firstLink;
        if (!this.host.editor && !this.shouldShowPanel() && link && link.href) {
          this.shouldNavToLink = link.href;
        }
        console.log('ModelNavComponent.down');
      });
      plane.on('up', () => {
        if (!isAnimated) {
          plane.material.opacity = opacityIdle;
        }
        // opening nav link
        if (this.shouldNavToLink != null) {
          /*
          const link = this.shouldNavToLink;
          window.open(link, '_blank');
          */
          this.shouldNavToLink = null;
          const item = this.item;
          const link = item.firstLink;
          this.link.next({
            item,
            link
          });
        }
      });
    } else {
      // !! fixing normalized positions;
      const position = new THREE.Vector3(item.position[0], item.position[1], item.position[2]);
      const normalizedPosition = new THREE.Vector3(item.position[0], item.position[1], item.position[2]).normalize();
      if (position.distanceToSquared(normalizedPosition) < 0.0001) {
        position.multiplyScalar(ModelNavComponent.RADIUS);
      }
      // console.log('!!! fixing normalized positions', 'position', position, 'normalizedPosition', normalizedPosition, 'distanceToSquared', position.distanceToSquared(normalizedPosition));
      nav.position.copy(position);
      this.onCreateSprites(nav);
      const geometry = Geometry.sphereGeometry;
      const sphere = this.sphere = new InteractiveMesh(geometry, new THREE.MeshBasicMaterial({
        depthTest: false,
        depthWrite: false,
        transparent: true,
        opacity: 0.0,
        color: 0x00ffff,
        toneMapped: false
      }));
      sphere.name = `[nav] ${item.id}`;
      // sphere.lookAt(Host.origin); ??
      sphere.depthTest = false;
      // sphere.renderOrder = 0;
      nav.add(sphere);
      const from = {
        pow: 0
      };
      gsap.to(from, {
        pow: 1,
        duration: 0.7,
        delay: 0.5 + 0.1 * item.index,
        ease: Power2.easeInOut,
        overwrite: true,
        onUpdate: () => {
          this.materials.forEach(material => {
            material.opacity = from.pow;
            // material.needsUpdate = true;
          });
        },

        onComplete: () => {
          if (isAnimated) {
            const icon = this.icon;
            from.pow = 0;
            gsap.to(from, {
              pow: 1,
              duration: 0.6,
              delay: 0.5 + 0.1 * item.index,
              ease: Power2.easeOut,
              repeat: -1,
              yoyo: true,
              onUpdate: () => {
                this.setScale(from.pow);
                icon.material.opacity = from.pow;
              }
            });
          }
        }
      });
      sphere.on('over', () => {
        this.over.next(this);
        if (!isAnimated) {
          const icon = this.icon;
          const from = {
            scale: icon.scale.x
          };
          gsap.to(from, {
            duration: 0.35,
            scale: this.iconMaxScale,
            delay: 0,
            ease: Power2.easeOut,
            overwrite: true,
            onUpdate: () => {
              icon.scale.set(from.scale, from.scale, from.scale);
            }
          });
        }
      });
      sphere.on('out', () => {
        this.out.next(this);
        if (!isAnimated) {
          const icon = this.icon;
          const from = {
            scale: icon.scale.x
          };
          gsap.to(from, {
            duration: 0.35,
            scale: this.iconMinScale,
            delay: 0,
            ease: Power2.easeOut,
            overwrite: true,
            onUpdate: () => {
              icon.scale.set(from.scale, from.scale, from.scale);
            }
          });
        }
      });
      sphere.on('down', () => {
        this.down.next(this);
      });
    }
    if (typeof mount === 'function') {
      mount(nav, item);
    }
  }
  onCreateSprites(mesh, opacity) {
    if (opacity === void 0) {
      opacity = 0;
    }
    this.onRemoveSprite(this.icon);
    this.onRemoveSprite(this.title);
    const item = this.item;
    const mode = this.mode = ModelNavComponent.getNavMode(item, this.view);
    if (mode === NavModeType.None) {
      return;
    }
    if (mode === NavModeType.Transparent) {
      this.materials = [];
    } else {
      const map = ModelNavComponent.getTexture(mode, item);
      const material = new THREE.SpriteMaterial({
        map: map,
        depthTest: false,
        depthWrite: false,
        transparent: true,
        sizeAttenuation: false,
        opacity: opacity,
        toneMapped: false
        // color: 0xff0000,
      });

      const materials = [material];
      const icon = this.icon = new THREE.Sprite(material);
      icon.renderOrder = environment.renderOrder.nav;
      this.setScale();
      mesh.add(icon);
      let titleMaterial;
      const titleTexture = ModelNavComponent.getTitleTexture(item, mode);
      if (titleTexture) {
        titleMaterial = new THREE.SpriteMaterial({
          depthTest: false,
          depthWrite: false,
          transparent: true,
          map: titleTexture,
          sizeAttenuation: false,
          opacity: opacity,
          toneMapped: false
          // color: 0xff0000,
        });
        // console.log(titleTexture);
        const image = titleTexture.image;
        const title = this.title = new THREE.Sprite(titleMaterial);
        const scale = this.iconMinScale;
        title.scale.set(scale * image.width / image.height, scale, scale);
        title.position.set(0, -3.5, 0);
        mesh.add(title);
        materials.push(titleMaterial);
      }
      this.materials = materials;
    }
  }
  onRemoveSprite(sprite) {
    if (sprite) {
      if (sprite.parent) {
        sprite.parent.remove(sprite);
      }
      if (sprite.material.map && sprite.material.map.disposable !== false) {
        sprite.material.map.dispose();
      }
      sprite.material.dispose();
    }
  }
  onDestroy() {
    Interactive.dispose(this.sphere);
    super.onDestroy();
  }

  // called by UpdateViewItemComponent
  onUpdate(item, mesh) {
    this.item = item;
    this.onCreateSprites(mesh, 1);
    if (this.mode === NavModeType.Transparent) {
      if (item.position) {
        mesh.position.fromArray(item.position);
      }
      if (item.rotation) {
        mesh.rotation.fromArray(item.rotation);
      }
      if (item.scale) {
        mesh.scale.fromArray(item.scale);
      }
    } else {
      // const position = new THREE.Vector3().set(...item.position).normalize().multiplyScalar(ModelNavComponent.RADIUS);
      // mesh.position.set(position.x, position.y, position.z);
      mesh.position.fromArray(item.position);
      mesh.rotation.set(0, 0, 0);
      mesh.scale.set(1, 1, 1);
    }
    // console.log('onUpdate', item, mesh.position);
    this.updateHelper();
    /*
    this.onCreate(
    	(mesh, item) => this.onMount(mesh, item),
    	(mesh, item) => this.onDismount(mesh, item)
    );
    */
  }

  // called by WorldComponent
  onDragMove(position, normal, spherical) {
    // console.log('ModelNavComponent.onDragMove', position, normal, spherical);
    const item = this.item;
    const mesh = this.mesh;
    this.editing = true;
    item.showPanel = false;
    if (this.mode === NavModeType.Transparent) {
      if (spherical) {
        position.normalize().multiplyScalar(ModelNavComponent.RADIUS);
        mesh.position.set(position.x, position.y, position.z);
        mesh.lookAt(Host.origin);
      } else {
        mesh.position.set(0, 0, 0);
        mesh.lookAt(normal);
        mesh.position.set(position.x, position.y, position.z);
        mesh.position.add(normal.multiplyScalar(0.01));
      }
    } else {
      if (spherical) {
        position.normalize().multiplyScalar(ModelNavComponent.RADIUS);
        mesh.position.set(position.x, position.y, position.z);
      } else {
        mesh.position.set(position.x, position.y, position.z);
        mesh.position.add(normal.multiplyScalar(0.01));
      }
    }
    this.updateHelper();
  }

  // called by WorldComponent
  onDragEnd() {
    const item = this.item;
    const mesh = this.mesh;
    if (this.mode === NavModeType.Transparent) {
      item.position = mesh.position.toArray();
      item.rotation = mesh.rotation.toArray();
      item.scale = mesh.scale.toArray();
    } else {
      item.position = mesh.position.toArray(); // new THREE.Vector3().copy(mesh.position).normalize().toArray();
    }

    this.editing = false;
  }
}
ModelNavComponent.RADIUS = 100;
ModelNavComponent.meta = {
  selector: '[model-nav]',
  hosts: {
    host: WorldComponent
  },
  outputs: ['over', 'out', 'down', 'link'],
  inputs: ['item', 'view']
};class AgoraComponent extends rxcomp.Component {
  get meetingUrl() {
    if (!this.meetingUrl_) {
      this.meetingUrl_ = new MeetingUrl();
    }
    return this.meetingUrl_;
  }
  get isVirtualTourUser() {
    return [RoleType.Publisher, RoleType.Attendee, RoleType.Streamer, RoleType.Viewer].indexOf(StateService.state.role) !== -1;
  }
  get isEmbed() {
    return this.route && this.route.params.mode === 'embed';
  }
  get isSelfServiceTour() {
    return this.route && this.route.params.mode === 'selfServiceTour';
  }
  get isNavigable() {
    const embedViewId = this.meetingUrl.embedViewId;
    const navigable = embedViewId == null;
    return navigable;
  }
  get isBackButtonVisible() {
    return this.view && (this.view.type.name === ViewType.Media.name || this.view.type.name === ViewType.Model.name);
  }
  get isSelfServiceProposition() {
    return StateService.state.role === RoleType.SelfService && environment.flags.selfServiceProposition;
  }
  get isSelfServiceSupport() {
    return StateService.state.role === RoleType.Publisher && environment.flags.selfServiceProposition && this.meetingUrl.support;
  }
  get showNavInfoToggler() {
    return environment.flags.hideNavInfo && this.state.mode !== UIMode.LiveMeeting && this.view && ModelNavComponent.hasNavInfo(this.view);
  }
  get uiClass() {
    const uiClass = {};
    uiClass[this.state.role] = true;
    // uiClass[this.state.mode] = true;
    uiClass.chat = this.state.chat;
    uiClass.remotes = this.state.mode === UIMode.LiveMeeting;
    uiClass.remoteScreen = this.remoteScreen != null && !this.hasScreenViewItem;
    uiClass.locked = this.locked;
    // uiClass.media = !uiClass.remotes && this.media;
    return uiClass;
  }
  get remoteClass() {
    return `group--remote--${Math.min(9, this.remotes.length)}`;
  }
  get controlled() {
    return StateService.state.controlling && StateService.state.controlling !== StateService.state.uid;
  }
  get controlling() {
    return StateService.state.controlling && StateService.state.controlling === StateService.state.uid;
  }
  get silencing() {
    return StateService.state.silencing;
  }
  get silenced() {
    return StateService.state.silencing && StateService.state.role === RoleType.Streamer;
  }
  get spyed() {
    return StateService.state.spying && StateService.state.spying === StateService.state.uid;
  }
  get spying() {
    return StateService.state.spying && StateService.state.spying !== StateService.state.uid;
  }
  get locked() {
    return this.controlled || this.spying;
  }
  get remoteScreen() {
    return this.remoteScreen_;
  }
  set remoteScreen(remoteScreen) {
    if (this.remoteScreen_ !== remoteScreen) {
      this.remoteScreen_ = remoteScreen;
      setTimeout(() => {
        window.dispatchEvent(new Event('resize'));
      }, 1);
    }
  }
  get pathViews() {
    return ViewService.pathViews;
  }
  onInit() {
    // Logger.log('AgoraComponent.onInit', this.host);
    const {
      node
    } = rxcomp.getContext(this);
    node.classList.remove('hidden');
    this.platform = DeviceService.platform;
    this.route = this.host ? this.host.route : null;
    this.state = {};
    this.hosted = null;
    this.view = null;
    this.previousView = null;
    this.form = null;
    this.local = null;
    this.screen = null;
    this.remoteScreen_ = null;
    this.navmaps = [];
    this.navmap = null;
    // this.media = null;
    this.hasScreenViewItem = false;
    this.remotes = [];
    const vrService = this.vrService = VRService.getService();
    vrService.status$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(status => this.pushChanges());
    this.resolveUser();
  }
  getName(user) {
    return StateService.state.name || MeetingUrl.getName(user);
  }
  getLinkRole() {
    let linkRole = null;
    if (this.isSelfServiceTour) {
      linkRole = RoleType.SelfService;
      return linkRole;
    }
    const meetingUrl = new MeetingUrl();
    const match = (meetingUrl.link || '').match(/\d{9}-(\d{4})-\d{13}/);
    if (match) {
      const index = parseInt(match[1]);
      linkRole = Object.keys(RoleType).reduce((p, c, i) => {
        return i === index ? RoleType[c] : p;
      }, null);
    }
    return linkRole;
  }
  resolveUser() {
    if (this.isEmbed) {
      UserService.temporaryUser$(RoleType.Embed).pipe(operators.first()).subscribe(user => {
        this.initWithUser(user);
      });
    } else if (this.isSelfServiceTour) {
      UserService.overrideUser$(RoleType.SelfService).pipe(operators.first()).subscribe(user => {
        this.initWithUser(user);
      });
    } else {
      UserService.me$().pipe(operators.first()).subscribe(user => {
        this.initWithUser(user);
        // this.userGuard(user);
      });
    }
  }

  userGuard(user) {
    // Logger.log('AgoraComponent.userGuard', user);
    const linkRole = this.getLinkRole();
    if (user && (!linkRole || user.type === linkRole)) {
      this.initWithUser(user);
    } else {
      this.initWithUser({
        type: linkRole
      });
    }
  }
  userGuardRedirect(user) {
    // Logger.log('AgoraComponent.userGuardRedirect', user);
    const linkRole = this.getLinkRole();
    if (user && (!linkRole || linkRole === user.type)) {
      this.initWithUser(user);
    } else if (linkRole === RoleType.Publisher || linkRole === RoleType.Attendee) {
      RouterService.setRouterLink(RoutePipe.transform(':lang.access'));
    } else {
      this.initWithUser({
        type: linkRole
      });
    }
  }
  setNextStatus() {
    let status = AgoraStatus.Idle;
    const state = StateService.state;
    if (state.role === RoleType.SmartDevice) {
      state.name = state.name || 'Smart Device';
    }
    if (!state.checklist) {
      status = AgoraStatus.Checklist;
    } else if (!state.link) {
      status = AgoraStatus.Link;
    } else if (!state.user.id && (state.role === RoleType.Publisher || state.role === RoleType.Attendee)) {
      status = AgoraStatus.Login;
    } else if (!state.name) {
      status = AgoraStatus.Name;
    } else if (state.role !== RoleType.Viewer && state.role !== RoleType.SmartDevice) {
      status = AgoraStatus.Device;
    } else {
      status = AgoraStatus.ShouldConnect;
    }
    StateService.patchState({
      status
    });
    return status;
  }
  getPathId() {
    const meetingUrl = new MeetingUrl();
    let pathId = meetingUrl.pathId;
    if (pathId) {
      // Logger.log('AgoraComponent.getPathId', pathId);
      return parseInt(pathId);
    }
    const link = meetingUrl.link;
    if (link) {
      const meetingId = new MeetingId(link);
      pathId = meetingId.pathId;
    }
    // Logger.log('AgoraComponent.getPathId', pathId);
    return pathId;
  }
  initWithUser(user) {
    // Logger.log('AgoraComponent.initWithUser', user);
    const meetingUrl = new MeetingUrl();
    const link = meetingUrl.link;
    const pathId = this.getPathId();
    const role = this.getLinkRole() || (user ? user.type : null);
    switch (role) {
      case RoleType.SelfService:
        if (!user || user.type !== RoleType.SelfService && user.type !== RoleType.Publisher) {
          RouterService.setRouterLink(RoutePipe.transform(':lang.access'));
          return;
        } else {
          // forcing role type to RoleType.SelfService
          user = Object.assign({}, user, {
            type: RoleType.SelfService
          });
        }
        break;
      default:
        user = user || {
          type: role
        };
        if (role !== user.type) {
          user = {
            type: role
          };
        }
    }
    // Logger.log('AgoraComponent.initWithUser', role, user);
    const mode = UserService.getMode(role);
    const name = this.getMeetingName(user);
    // const name = meetingUrl.name || this.getName(user);
    const checklist = null;
    const hosted = role === RoleType.Publisher ? true : false;
    const live = role === RoleType.SelfService || role === RoleType.Embed || DEBUG ? false : true;
    const navigable = this.isNavigable;
    const state = {
      user: user,
      role: role,
      mode: mode,
      name: name,
      checklist: checklist,
      pathId: pathId,
      link: link,
      channelName: environment.channelName,
      uid: null,
      status: AgoraStatus.Idle,
      connecting: false,
      connected: false,
      controlling: false,
      spying: false,
      silencing: false,
      hosted: hosted,
      live: live,
      navigable: navigable,
      cameraMuted: false,
      audioMuted: false,
      showNavInfo: true
    };
    StateService.state = state;
    StateService.state$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(state => {
      this.state = state;
      this.hosted = state.hosted;
      this.pushChanges();
      // console.log(state);
      this.locked ? document.body.classList.add('locked') : document.body.classList.remove('locked');
    });
    this.initAgora();
  }
  getMeetingName(user) {
    const meetingUrl = new MeetingUrl();
    let name = null;
    if (environment.flags.useExtendedUserInfo) {
      name = meetingUrl.firstName && meetingUrl.lastName ? `${meetingUrl.firstName} ${meetingUrl.lastName}` : null;
    } else {
      name = meetingUrl.name ? meetingUrl.name : null;
    }
    if (!name && user.firstName && user.lastName) {
      name = `${user.firstName} ${user.lastName}`;
    }
    return name;
  }
  viewObserver$() {
    return ViewService.data$().pipe(operators.switchMap(data => {
      // Logger.log('AgoraComponent.viewObserver$', 'pathId', StateService.state.pathId);
      return PathService.getCurrentPath$(StateService.state.pathId).pipe(operators.switchMap(path => {
        return ViewService.hostedView$(data, path);
      }));
    }),
    /*
    tap(view => {
    	this.view = null;
    	this.pushChanges();
    }),
    delay(1),
    */
    operators.map(view => {
      // Logger.log('AgoraComponent.viewObserver$', view);
      // !!! move navToView to user action?
      if (this.agora) {
        this.agora.navToView(view.id, view.keepOrientation, view.useLastOrientation);
      }
      this.previousView = this.view;
      this.view = view;
      this.setNavmap(view);
      this.hasScreenViewItem = view.items.find(x => MediaLoader.isPublisherScreen(x) || MediaLoader.isAttendeeScreen(x)) != null;
      this.pushChanges();
      const state = this.state;
      GtmService.push({
        action: 'b-here-view',
        viewId: view.id,
        userType: state.role // aggiunto
      });

      return view;
    }));
  }
  load(callback) {
    this.loadNavmaps();
    this.viewObserver$().pipe(operators.takeUntil(this.unsubscribe$)).subscribe(view => {
      // Logger.log('AgoraComponent.load', view);
      if (typeof callback === 'function') {
        callback();
        callback = null;
      }
    });
  }
  loadNavmaps() {
    if (environment.flags.navmaps) {
      NavmapService.navmapGet$().pipe(operators.first()).subscribe(navmaps => {
        this.navmaps = navmaps;
      });
    }
  }
  setNavmap(view) {
    const navmaps = this.navmaps;
    const navmap = (navmaps || []).find(x => (x.items || []).find(i => i.viewId === view.id) != null) || null;
    // Logger.log('AgoraComponent.setNavmap', navmap);
    this.navmap = navmap;
  }
  toggleNavmap() {
    StateService.patchState({
      showNavmap: !StateService.state.showNavmap
    });
  }
  onNavmapItem(item) {
    StateService.patchState({
      showNavmap: false
    });
    this.onNavTo(item);
  }
  loadAndConnect(preferences) {
    this.load(() => {
      this.connect(preferences);
    });
  }
  initAgora() {
    if (this.state.role === RoleType.SelfService || this.state.role === RoleType.Embed || DEBUG) {
      this.load(() => {
        StateService.patchState({
          status: AgoraStatus.Connected,
          hosted: true
        });
      });
      this.checkSelfServiceProposition();
      this.checkSelfServiceAudio();
    } else {
      AgoraChecklistService.isChecked$().pipe(operators.first()).subscribe(checked => {
        StateService.patchState({
          checklist: checked
        });
        this.agora = AgoraService.getSingleton();
        this.getLinkRole();
        this.setNextStatus();
        // Logger.log('AgoraComponent.initAgora', status, role);
      });
    }

    StreamService.local$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(local => {
      // Logger.log('AgoraComponent.initAgora', 'StreamService.local$', local);
      this.local = local;
      this.pushChanges();
    });
    StreamService.screen$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(screen => {
      // Logger.log('AgoraComponent.initAgora', 'StreamService.screen$', screen);
      if (this.screen === this.remoteScreen) {
        this.remoteScreen = null;
      }
      this.screen = screen;
      this.remoteScreen = screen || this.remoteScreen;
      this.pushChanges();
    });
    StreamService.orderedRemotes$().pipe(operators.takeUntil(this.unsubscribe$)).subscribe(remotes => {
      this.remotes = [];
      this.remoteScreen = this.screen;
      remotes.forEach(x => {
        if (x.clientInfo && x.clientInfo.screenUid === x.streamId) {
          this.remoteScreen = x;
        } else {
          this.remotes.push(x);
        }
      });
      // Logger.log('AgoraComponent.initAgora', 'StreamService.orderedRemotes$', this.remotes, this.remoteScreen, remotes.map(x => `${x.clientInfo ? x.clientInfo.uid : 'null'}-${x.clientInfo ? x.clientInfo.screenUid : 'null'}`).join(','));
      this.pushChanges();
    });
    /*
    MediaLoader.events$.pipe(
    	tap(event => {
    		if (event instanceof MediaLoaderPlayEvent) {
    			this.media = event.loader;
    			// this.pushChanges();
    		} else if (event instanceof MediaLoaderDisposeEvent) {
    			if (this.media === event.loader) {
    				this.media = null;
    				// this.pushChanges();
    			}
    		}
    		// Logger.log('AgoraComponent.initAgora', 'MediaLoader.events$', event);
    	}),
    	takeUntil(this.unsubscribe$)
    ).subscribe();
    */
    MessageService.out$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(message => {
      // Logger.log('AgoraComponent.initAgora', 'MessageService.out$', message);
      switch (message.type) {
        case MessageType.ChannelMembers:
          if (this.isSelfServiceSupport) {
            const members = message.members;
            // Logger.log('AgoraComponent.initAgora', 'MessageService.out$', members, members.length);
            if (members.length > 0) {
              ToastService.open$({
                message: LabelPipe.transform('bhere_support_request_sent'),
                type: ToastType.Alert,
                position: ToastPosition.BottomRight
              });
              MessageService.send({
                type: MessageType.SupportRequest
              });
            } else {
              ToastService.open$({
                message: LabelPipe.transform('bhere_support_request_leaved'),
                type: ToastType.Alert,
                position: ToastPosition.BottomRight
              });
            }
          }
          break;
        case MessageType.SupportRequest:
          if (this.isSelfServiceProposition) {
            this.openSupportRequestDialog(message.clientInfo);
          }
          break;
        case MessageType.SupportRequestAccepted:
          ToastService.open$({
            message: LabelPipe.transform('bhere_support_request_accepted'),
            type: ToastType.Alert,
            position: ToastPosition.BottomRight
          });
          break;
        case MessageType.SupportRequestRejected:
          ToastService.open$({
            message: LabelPipe.transform('bhere_support_request_rejected'),
            type: ToastType.Alert,
            position: ToastPosition.BottomRight
          });
          break;
        case MessageType.RemoteSilencing:
          StateService.patchState({
            silencing: message.silencing
          });
          this.setAudio(message.silencing);
          break;
        case MessageType.NavToView:
          this.onRemoteNavTo(message);
          break;
        case MessageType.Mode:
          StateService.patchState({
            mode: message.mode
          });
          window.dispatchEvent(new Event('resize'));
          break;
        case MessageType.NavInfo:
          this.hidePanels();
          StateService.patchState({
            showNavInfo: message.showNavInfo
          });
          break;
        case MessageType.AddLike:
          ViewService.setViewLike$(message).pipe(operators.first()).subscribe(view => this.showLove(view));
          break;
        case MessageType.ChatMessage:
          if (!StateService.state.chat) {
            StateService.patchState({
              chatDirty: true
            });
          }
          break;
      }
    });
    MessageService.in$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(message => {
      if (this.agora) {
        this.agora.sendMessage(message);
      }
    });
    this.fullscreen$().pipe(operators.takeUntil(this.unsubscribe$)).subscribe();
    if (this.agora && StateService.state.status === AgoraStatus.ShouldConnect) {
      this.loadAndConnect();
    }
  }
  onChecked(checklist) {
    // Logger.log('AgoraComponent.onChecked', checklist);
    StateService.patchState({
      checklist: true
    });
    this.setNextStatus();
  }
  onLink(link) {
    const meetingId = new MeetingId(link);
    // Logger.log('AgoraComponent.onLink', meetingId);
    const pathId = meetingId.pathId;
    const role = this.getLinkRole();
    const mode = UserService.getMode(role);
    const user = StateService.state.user;
    if ((role === RoleType.Publisher || role === RoleType.Attendee) && (!user.id || user.type !== role)) {
      StateService.patchState({
        link,
        pathId,
        role,
        mode,
        status: AgoraStatus.Login
      });
    } else if (StateService.state.name) {
      if (role === RoleType.Viewer || role === RoleType.SmartDevice) {
        StateService.patchState({
          link,
          pathId,
          role,
          mode
        });
        this.loadAndConnect();
      } else {
        StateService.patchState({
          link,
          pathId,
          role,
          mode,
          status: AgoraStatus.Device
        });
      }
    } else {
      StateService.patchState({
        link,
        pathId,
        role,
        mode,
        status: AgoraStatus.Name
      });
    }
  }
  onLogin(user) {
    const name = this.getName(user);
    if (name) {
      StateService.patchState({
        user,
        name,
        status: AgoraStatus.Device
      });
    } else {
      StateService.patchState({
        user,
        status: AgoraStatus.Name
      });
    }
  }
  onName(name) {
    if (StateService.state.role === RoleType.Viewer || StateService.state.role === RoleType.SmartDevice) {
      StateService.patchState({
        name
      });
      this.loadAndConnect();
    } else {
      StateService.patchState({
        name,
        status: AgoraStatus.Device
      });
    }
  }
  onEnter(preferences) {
    this.loadAndConnect(preferences);
  }
  connect(preferences) {
    // Logger.log('AgoraComponent.connect', preferences);
    this.agora.connect$(preferences).pipe(operators.takeUntil(this.unsubscribe$)).subscribe();
    const state = this.state;
    // Logger.log('AgoraComponent.connect', this.state.role);
    if (state.role === RoleType.SelfService) {
      GtmService.push({
        action: 'b-here-tour',
        userType: state.role
      });
    } else if (state.role === RoleType.Embed) {
      GtmService.push({
        action: 'b-here-embed',
        userType: state.role
      });
    } else {
      const meetingUrl = new MeetingUrl();
      const sharedMeetingId = state.link.replace(/-\d+-/, '-');
      const log = {
        meetingId: state.link,
        sharedMeetingId: sharedMeetingId,
        userType: state.role
      };
      if (environment.flags.useExtendedUserInfo) {
        // !!! update server side logic to use extended user info
        log.firstName = meetingUrl.firstName;
        log.lastName = meetingUrl.lastName;
        log.email = meetingUrl.email;
      } else {
        log.fullName = state.name;
      }
      // Logger.log('AgoraComponent.connect', log);
      UserService.log$(log).pipe(operators.first()).subscribe();
      // do not share user data in gtm
      GtmService.push({
        action: 'b-here-meeting',
        meetingId: state.link,
        sharedMeetingId: sharedMeetingId,
        userType: state.role
      });
    }
  }
  disconnect() {
    if (this.agora) {
      this.agora.leaveChannel().then(() => {
        // StateService.patchState({ status: AgoraStatus.Disconnected, connected: false });
        // window.location.href = window.location.href;
        // window.location.replace(window.location.href);
        window.location.reload();
      }, console.log);
    } else {
      this.patchState({
        connecting: false,
        connected: false
      });
    }
  }
  onNavTo(item) {
    const viewId = item.viewId;
    const view = this.pathViews.find(x => x.id === viewId);
    if (view) {
      // Logger.log('AgoraComponent.onNavTo', item, view);
      ViewService.action = {
        viewId,
        keepOrientation: item.keepOrientation,
        useLastOrientation: item.useLastOrientation
      };
      this.onHandleHook(view, item);
    }
  }
  onNavLink(event) {
    // Logger.log('AgoraComponent.onNavLink', event.link.href);
    ModalService.open$({
      iframe: event.link.href
    }).pipe(operators.first()).subscribe(_ => {
      MessageService.send({
        type: MessageType.NavLinkClose,
        itemId: event.item.id
      });
    });
  }
  onRemoteNavTo(message) {
    const viewId = message.viewId;
    const gridIndex = message.gridIndex;
    if (viewId && ViewService.viewId !== viewId) {
      const view = this.pathViews.find(x => x.id === viewId);
      if (view) {
        // Logger.log('AgoraComponent.onRemoteNavTo', message, view);
        ViewService.action = {
          viewId,
          keepOrientation: message.keepOrientation,
          useLastOrientation: message.useLastOrientation
        };
        if (gridIndex != null && view instanceof PanoramaGridView) {
          view.index = gridIndex;
        }
      }
      // Logger.log('AgoraComponent.onRemoteNavTo', viewId, gridIndex);
    }
  }

  onHandleHook(view, item) {
    switch (item.hook) {
      case 'ToggleWishlist':
        {
          const payload = {
            viewId: view.id,
            itemId: item.id
          };
          WishlistService.toggle$(payload).pipe(operators.switchMap(items => {
            payload.added = WishlistService.has(payload);
            return WebhookService.send$(item.hook, payload, item.extra);
          }), operators.first()).subscribe(response => {
            Logger.log('AgoraComponent.onHandleHook', response);
            item.added = payload.added;
            this.pushChanges();
          });
          break;
        }
    }
  }

  // !!! why locally?
  patchState(state) {
    this.state = Object.assign({}, this.state, state);
    this.pushChanges();
    // console.log(this.state);
  }

  toggleCamera() {
    if (this.agora) {
      this.agora.toggleCamera();
    } else {
      this.patchState({
        cameraMuted: !this.state.cameraMuted
      });
    }
  }
  toggleAudio() {
    if (this.agora) {
      this.agora.toggleAudio();
    } else {
      this.patchState({
        audioMuted: !this.state.audioMuted
      });
    }
  }
  setAudio(audioMuted) {
    if (this.agora) {
      this.agora.setAudio(audioMuted);
    } else {
      this.patchState({
        audioMuted
      });
    }
  }
  toggleScreen() {
    if (this.agora) {
      this.agora.toggleScreen();
    } else {
      this.patchState({
        screen: !this.state.screen
      });
    }
    window.dispatchEvent(new Event('resize'));
  }
  toggleVolume() {
    const volumeMuted = !this.state.volumeMuted;
    StateService.patchState({
      volumeMuted
    });
    const selfServiceAudio = this.selfServiceAudio;
    if (selfServiceAudio) {
      selfServiceAudio.volume = volumeMuted ? 0 : 0.5;
    }
  }
  toggleMode() {
    if (this.agora && StateService.state.role === RoleType.Publisher) {
      this.agora.toggleMode();
    } else {
      const mode = this.state.mode === UIMode.VirtualTour ? UIMode.LiveMeeting : UIMode.VirtualTour;
      StateService.patchState({
        mode
      });
      // this.patchState({ mode });
    }

    window.dispatchEvent(new Event('resize'));
  }
  toggleFullScreen() {
    const {
      node
    } = rxcomp.getContext(this);
    const fullScreen = !this.state.fullScreen;
    if (fullScreen) {
      if (node.requestFullscreen) {
        node.requestFullscreen();
      } else if (node.webkitRequestFullscreen) {
        node.webkitRequestFullscreen();
      } else if (node.msRequestFullscreen) {
        node.msRequestFullscreen();
      }
    } else {
      if (document.exitFullscreen) {
        document.exitFullscreen();
      } else if (document.webkitExitFullscreen) {
        document.webkitExitFullscreen();
      } else if (document.msExitFullscreen) {
        document.msExitFullscreen();
      }
    }
    // StateService.patchState({ fullScreen });
  }

  fullscreen$() {
    return rxjs.fromEvent(document, 'fullscreenchange').pipe(operators.tap(_ => {
      const fullScreen = document.fullscreenElement != null;
      // Logger.log('AgoraComponent.fullscreen$', fullScreen);
      StateService.patchState({
        fullScreen
      });
    }));
  }
  toggleChat() {
    StateService.patchState({
      chat: !StateService.state.chat,
      chatDirty: false
    });
    window.dispatchEvent(new Event('resize'));
  }
  onChatClose() {
    StateService.patchState({
      chat: false
    });
    window.dispatchEvent(new Event('resize'));
  }
  toggleNavInfo() {
    this.hidePanels();
    if (this.agora) {
      this.agora.toggleNavInfo();
    } else {
      this.patchState({
        showNavInfo: !this.state.showNavInfo
      });
    }
  }
  onBack() {
    // Logger.log('AgoraCompoent.onBack');
    if (this.previousView && this.view && this.previousView.id !== this.view.id) {
      ViewService.action = {
        viewId: this.previousView.id,
        useLastOrientation: true
      };
    }
  }
  hidePanels() {
    this.view.items.forEach(item => item.showPanel = false);
  }
  onToggleControl(remoteId) {
    if (this.agora) {
      this.agora.toggleControl(remoteId);
    } else {
      const controlling = this.state.controlling === remoteId ? null : remoteId;
      this.patchState({
        controlling,
        spying: false
      });
    }
  }
  onToggleSilence() {
    if (this.agora) {
      this.agora.toggleSilence();
    } else {
      this.patchState({
        silencing: !this.state.silencing
      });
    }
  }
  onToggleSpy(remoteId) {
    if (this.agora) {
      this.agora.toggleSpy(remoteId);
    } else {
      const spying = this.state.spying === remoteId ? null : remoteId;
      this.patchState({
        spying,
        controlling: false
      });
    }
  }
  addLike() {
    ViewService.viewLike$(this.view).pipe(operators.first()).subscribe(view => {
      if (view) {
        this.view.liked = true; // view.liked;
        this.showLove(view);
        // this.view.likes = view.likes;
        // this.pushChanges();
        MessageService.send({
          type: MessageType.AddLike,
          viewId: this.view.id,
          likes: this.view.likes
        });
      }
    });
  }
  showLove(view) {
    if (view && this.view.id === view.id) {
      const skipTimeout = this.view.showLove;
      this.view.likes = view.likes;
      this.view.showLove = true;
      this.pushChanges();
      if (!skipTimeout) {
        setTimeout(() => {
          this.view.showLove = false;
          this.pushChanges();
        }, 3100);
      }
    }
  }
  tryInAr() {
    if (this.platform === DevicePlatform.IOS || this.platform === DevicePlatform.Android) {
      TryInARModalComponent.openInAR(this.view);
    } else {
      ModalService.open$({
        template: TryInARModalComponent.chunk(),
        data: this.view
      }).pipe(operators.first()).subscribe(event => {
        // this.pushChanges();
      });
    }
  }
  checkSelfServiceProposition() {
    // self service proposition
    const isSelfServiceProposition = this.isSelfServiceProposition;
    // Logger.log('AgoraComponent.checkSelfServiceProposition', isSelfServiceProposition);
    if (isSelfServiceProposition) {
      AgoraChecklistService.check$().pipe(operators.first()).subscribe(event => {
        const meetingId = new MeetingId({
          pathId: StateService.state.pathId
        });
        const meetingIdRoles = meetingId.toRoles();
        const meetingUrl = new MeetingUrl({
          link: meetingIdRoles.id,
          support: true
        });
        const href = window.location.origin + meetingUrl.toGuidedTourUrl();
        Logger.log('AgoraComponent.checkSelfServiceProposition', href);
        UserService.selfServiceSupportRequest$(StateService.state.user, meetingIdRoles.id, href).pipe(operators.first()).subscribe(_ => {
          const name = this.getName(StateService.state.user);
          StateService.patchState({
            checklist: true,
            link: meetingIdRoles.idSelfService,
            name
          });
          this.agora = AgoraService.getSingleton();
          this.connect();
        });
      }, error => {
        Logger.error('AgoraComponent.checkSelfServiceProposition.error', error);
        /*
        UserService.selfServiceTourSupportFailedRequest$(StateService.state.user).pipe(
        	first(),
        ).subscribe();
        */
      });
    }
  }

  checkSelfServiceAudio() {
    if (StateService.state.role === RoleType.SelfService && environment.selfServiceAudio) {
      const selfServiceAudio = document.createElement('audio');
      selfServiceAudio.setAttribute('playsinline', 'true');
      selfServiceAudio.setAttribute('autoplay', 'true');
      selfServiceAudio.setAttribute('loop', 'true');
      selfServiceAudio.volume = 0.5;
      selfServiceAudio.src = environment.getPath(environment.selfServiceAudio);
      const {
        node
      } = rxcomp.getContext(this);
      node.parentNode.appendChild(selfServiceAudio);
      this.selfServiceAudio = selfServiceAudio;
      MediaLoader.events$.pipe(operators.tap(event => {
        // Logger.log('AgoraComponent.checkSelfServiceAudio', 'MediaLoader.event$', event);
        if (event instanceof MediaLoaderPlayEvent) {
          selfServiceAudio.pause();
          // selfServiceAudio.volume = 0;
        } else if (event instanceof MediaLoaderPauseEvent || event instanceof MediaLoaderDisposeEvent) {
          selfServiceAudio.play();
          // selfServiceAudio.volume = 0.5;
        }
      }), operators.takeUntil(this.unsubscribe$)).subscribe();
    }
  }
  openSupportRequestDialog(clientInfo) {
    ToastService.open$({
      message: LabelPipe.transform('bhere_support_request_dialog'),
      acceptMessage: LabelPipe.transform('bhere_support_request_dialog_accept'),
      rejectMessage: LabelPipe.transform('bhere_support_request_dialog_reject'),
      type: ToastType.Dialog,
      position: ToastPosition.BottomRight
    }).pipe(operators.takeUntil(this.unsubscribe$)).subscribe(event => {
      if (event instanceof ToastResolveEvent) {
        MessageService.send({
          type: MessageType.SupportRequestAccepted
        });
        const name = StateService.state.name;
        const meetingId = new MeetingId(StateService.state.link);
        meetingId.role = RoleType.Streamer;
        const options = {
          link: meetingId.toString()
        };
        if (environment.flags.useExtendedUserInfo) {
          const user = StateService.state.user;
          options.firstName = user.firstName;
          options.lastName = user.lastName;
          options.email = user.email;
        } else {
          options.name = name;
        }
        const meetingUrl = new MeetingUrl(options);
        const href = meetingUrl.toGuidedTourUrl();
        setTimeout(() => {
          window.location.href = href;
        }, 1000);
      } else {
        MessageService.send({
          type: MessageType.SupportRequestRejected
        });
      }
    });
    /*
    ModalService.open$({ template: SupportRequestModalComponent.chunk(), data: clientInfo }).pipe(
    	first(),
    ).subscribe(event => {
    	if (event instanceof ModalResolveEvent) {
    		MessageService.send({ type: MessageType.SupportRequestAccepted });
    		const name = StateService.state.name;
    		const meetingId = new MeetingId(StateService.state.link);
    		meetingId.role = RoleType.Streamer;
    		const meetingUrl = new MeetingUrl({ link: meetingId.toString(), name });
    		const href = meetingUrl.toGuidedTourUrl();
    		setTimeout(() => {
    			window.location.href = href;
    		}, 1000);
    	} else {
    		MessageService.send({ type: MessageType.SupportRequestRejected });
    	}
    });
    */
  }

  /*
  onPrevent(event) {
  	event.preventDefault();
  	event.stopImmediatePropagation();
  }
  */
}

AgoraComponent.meta = {
  selector: '[agora-component]',
  hosts: {
    host: RouterOutletStructure
  },
  template: /* html */`
	<div class="page page--agora">
		${CHUNK_BACKGROUND}
		<!-- Status Checklist -->
		<div class="ui ui--info ui--info-centered" *if="state.status == 'checklist'" [agora-checklist] (checked)="onChecked($event)"></div>
		<!-- Status Link -->
		<div class="ui ui--info ui--info-centered" *if="state.status == 'link'" [agora-link] (link)="onLink($event)"></div>
		<!-- Status Login -->
		<div class="ui ui--info ui--info-centered" *if="state.status == 'login'" [agora-login] (login)="onLogin($event)"></div>
		<!-- Status Name -->
		<div class="ui ui--info ui--info-centered" *if="state.status == 'name' || (state.status == 'disconnected' && state.role === 'viewer')" [agora-name] (name)="onName($event)"></div>
		<!-- Status Device -->
		<div class="ui ui--info" *if="state.status == 'device' || (state.status == 'disconnected' && state.role !== 'viewer')" [agora-device] (enter)="onEnter($event)"></div>
		${CHUNK_VIRTUAL_TOUR}
		${CHUNK_SMART_DEVICE}
		${CHUNK_SELF_SERVICE_TOUR}
		${CHUNK_EMBED}
		<header>
			${CHUNK_LOGO}
			${CHUNK_LANGUAGE}
		</header>
		<footer *if="state.status != 'connected'">
			<span class="group--colophon">
				${CHUNK_CREDITS}
				${CHUNK_COPYRIGHT}
			</span>
			<a [routerLink]="':lang.editor' | route" class="btn--absolute" *if="('editor' | flag) && !('deployed' | flag) && state.role == 'publisher' && (state.status == 'checklist' || state.status == 'link')">
				<span [innerHTML]="'bhere_editor' | label"></span> <svg class="edit" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#edit"></use></svg>
			</a>
		</footer>
	</div>
	`
};class AssetService {
  static assetCreate$(asset) {
    return HttpService.post$('/api/asset', asset).pipe(operators.map(asset => mapAsset(asset)));
  }
  static assetUpdate$(asset) {
    return HttpService.put$(`/api/asset/${asset.id}`, asset).pipe(operators.map(asset => mapAsset(asset)));
  }
  static assetDelete$(asset) {
    if (asset && asset.id) {
      return HttpService.delete$(`/api/asset/${asset.id}`).pipe(operators.map(() => null));
    } else {
      return rxjs.of(null);
    }
  }
  static localizedAssetCreate$(lg, asset) {
    return HttpService.post$(`/api/${lg}/asset`, asset).pipe(operators.map(asset => mapAsset(asset)));
  }
  static localizedAssetUpdate$(lg, asset) {
    return HttpService.put$(`/api/${lg}/asset/${asset.id}`, asset).pipe(operators.map(asset => mapAsset(asset)));
  }
  static upload$(files) {
    const formData = new FormData();
    files.forEach(file => formData.append('file', file, file.name));
    const xhr = new XMLHttpRequest();
    const events$ = rxjs.merge(rxjs.fromEvent(xhr.upload, 'loadstart'), rxjs.fromEvent(xhr.upload, 'progress'), rxjs.fromEvent(xhr.upload, 'load'), rxjs.fromEvent(xhr, 'readystatechange')).pipe(operators.map(event => {
      switch (event.type) {
        case 'readystatechange':
          if (xhr.readyState === 4) {
            return JSON.parse(xhr.responseText);
          } else {
            return null;
          }
        default:
          return null;
      }
    }), operators.filter(event => event !== null));
    xhr.open('POST', '/api/upload/', true);
    xhr.send(formData);
    return events$;
  }
  static createOrUpdateAsset$(uploads, control) {
    const upload = uploads[0];
    const asset = Asset.fromUrl(upload.url);
    if (control.value && control.value.id) {
      // !!! must check for id
      asset.id = control.value.id;
      return AssetService.assetUpdate$(asset);
    } else {
      return AssetService.assetCreate$(asset);
    }
  }
  static createOrUpdateLocalizedAsset$(uploads, control, lg) {
    const upload = uploads[0];
    const asset = Asset.fromUrl(upload.url);
    if (control.value && control.value.id) {
      // !!! must check for id
      asset.id = control.value.id;
      return AssetService.localizedAssetUpdate$(lg, asset);
    } else {
      return AssetService.localizedAssetCreate$(lg, asset);
    }
  }
  static assetDidChange(previous, current) {
    let previousId = null;
    let previousFile = null;
    let currentId = null;
    let currentFile = null;
    if (previous) {
      previousId = previous.id;
      previousFile = previous.file;
    }
    if (current) {
      currentId = current.id;
      currentFile = current.file;
    }
    return previousId !== currentId || previousFile !== currentFile;
  }
}class EditorService {
  static data$() {
    if (!this.data$_) {
      this.data$_ = HttpService.get$('/api/view').pipe(operators.map(data => {
        data.views = data.views.map(view => mapView(view));
        return data;
      }), operators.shareReplay(1));
    }
    return this.data$_;
  }
  static viewIdOptions$() {
    return this.data$().pipe(operators.map(data => {
      const options = data.views.filter(x => x.type.name !== ViewType.WaitingRoom.name).map(view => ({
        id: view.id,
        name: view.name
      }));
      options.unshift({
        id: null,
        name: 'select'
      }); // LabelPipe.transform('select')
      return options;
    }));
  }
  static viewCreate$(view) {
    return HttpService.post$('/api/view', view).pipe(operators.map(view => mapView(view)));
  }
  static viewUpdate$(view) {
    return HttpService.put$(`/api/view/${view.id}`, view.payload).pipe(operators.map(view => mapView(view)));
  }
  static viewDelete$(view) {
    return HttpService.delete$(`/api/view/${view.id}`);
  }
  static getTile(view) {
    let tile;
    if (view.type.name === ViewType.PanoramaGrid.name) {
      tile = view.tiles[view.index];
    }
    return tile;
  }
  static inferItemCreate$(view, item) {
    const tile = this.getTile(view);
    if (tile) {
      return this.tileItemCreate$(view, tile, item);
    } else {
      return this.itemCreate$(view, item);
    }
  }
  static inferItemUpdate$(view, item) {
    const tile = this.getTile(view);
    if (tile) {
      return this.tileItemUpdate$(view, tile, item);
    } else {
      return this.itemUpdate$(view, item);
    }
  }
  static inferItemDelete$(view, item) {
    const tile = this.getTile(view);
    if (tile) {
      return this.tileItemDelete$(view, tile, item);
    } else {
      return this.itemDelete$(view, item);
    }
  }
  static inferItemUpdateResult$(view, item) {
    const tile = this.getTile(view);
    let currentItem;
    if (tile) {
      currentItem = tile.navs.find(i => i.id === item.id);
    } else {
      currentItem = view.items.find(i => i.id === item.id);
    }
    if (currentItem) {
      Object.assign(currentItem, item);
    }
  }
  static inferItemDeleteResult$(view, item) {
    const tile = this.getTile(view);
    let items;
    if (tile) {
      items = tile.navs;
    } else {
      items = view.items;
    }
    if (items) {
      const index = items.indexOf(item);
      if (index !== -1) {
        items.splice(index, 1);
      }
      if (tile) {
        view.updateCurrentItems();
      }
    }
  }
  static itemCreate$(view, item) {
    return HttpService.post$(`/api/view/${view.id}/item`, item).pipe(operators.map(item => mapViewItem(item)));
  }
  static itemUpdate$(view, item) {
    return HttpService.put$(`/api/view/${view.id}/item/${item.id}`, item.payload).pipe(operators.map(item => mapViewItem(item)));
  }
  static itemDelete$(view, item) {
    return HttpService.delete$(`/api/view/${view.id}/item/${item.id}`);
  }
  static tileItemCreate$(view, tile, item) {
    return HttpService.post$(`/api/view/${view.id}/tile/${tile.id}/item`, item).pipe(operators.map(item => mapViewItem(item)));
  }
  static tileItemUpdate$(view, tile, item) {
    return HttpService.put$(`/api/view/${view.id}/tile/${tile.id}/item/${item.id}`, item.payload).pipe(operators.map(item => mapViewItem(item)));
  }
  static tileItemDelete$(view, tile, item) {
    return HttpService.delete$(`/api/view/${view.id}/tile/${tile.id}/item/${item.id}`);
  }
}class CurvedPlaneModalComponent extends rxcomp.Component {
  get data() {
    let data = null;
    const {
      parentInstance
    } = rxcomp.getContext(this);
    if (parentInstance instanceof ModalOutletComponent) {
      data = parentInstance.modal.data;
    }
    return data;
  }
  get view() {
    let view = null;
    const data = this.data;
    if (data) {
      view = data.view;
    }
    return view;
  }
  get object() {
    const object = new THREE.Object3D();
    const data = this.data;
    if (data) {
      const position = data.hit.position.clone();
      const normal = data.hit.normal.clone();
      const spherical = data.hit.spherical;
      if (spherical) {
        position.normalize().multiplyScalar(20);
        object.position.copy(position);
        object.lookAt(Host.origin);
      } else {
        object.lookAt(normal);
        object.position.set(position.x, position.y, position.z);
        object.position.add(normal.multiplyScalar(0.01));
      }
    }
    return object;
  }
  onInit() {
    const object = this.object;
    const form = this.form = new rxcompForm.FormGroup({
      type: ViewItemType.CurvedPlane,
      position: new rxcompForm.FormControl(object.position.toArray(), rxcompForm.RequiredValidator()),
      rotation: new rxcompForm.FormControl(object.rotation.toArray(), rxcompForm.RequiredValidator()),
      scale: new rxcompForm.FormControl([1, 1, 1], rxcompForm.RequiredValidator()),
      radius: new rxcompForm.FormControl(35, rxcompForm.RequiredValidator()),
      height: new rxcompForm.FormControl(20, rxcompForm.RequiredValidator()),
      arc: new rxcompForm.FormControl(90, rxcompForm.RequiredValidator()),
      asset: null
    });
    this.controls = form.controls;
    form.changes$.subscribe(changes => {
      // console.log('CurvedPlaneModalComponent.form.changes$', changes, form.valid, form);
      this.pushChanges();
    });
  }
  onSubmit() {
    if (this.form.valid) {
      const item = Object.assign({}, this.form.value);
      // item.viewId = parseInt(item.viewId);
      // console.log('CurvedPlaneModalComponent.onSubmit', this.view, item);
      EditorService.inferItemCreate$(this.view, item).pipe(operators.first()).subscribe(response => {
        // console.log('CurvedPlaneModalComponent.onSubmit.success', response);
        ModalService.resolve(response);
      }, error => console.log('CurvedPlaneModalComponent.onSubmit.error', error));
    } else {
      this.form.touched = true;
    }
  }
  onClose() {
    ModalService.reject();
  }
}
CurvedPlaneModalComponent.meta = {
  selector: '[curved-plane-modal]',
  template: /* html */`
		<div class="modal__header">
			<button type="button" class="btn--close" (click)="onClose()">
				<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#close"></use></svg>
			</button>
		</div>
		<div class="container">
			<div class="form">
				<div class="title">Create Curved Plane.</div>
				<form [formGroup]="form" (submit)="onSubmit()" name="form" role="form" novalidate autocomplete="off">
					<div class="form-controls">
						<!-- <div control-text [control]="controls.title" label="Title"></div> -->
						<div control-vector [control]="controls.position" label="Position" [precision]="2" [disabled]="true"></div>
						<div control-vector [control]="controls.rotation" label="Rotation" [precision]="3" [increment]="Math.PI / 360" [disabled]="true"></div>
						<!--
						<div control-vector [control]="controls.scale" label="Scale" [precision]="2" [disabled]="true"></div>
						<div control-number [control]="controls.radius" label="Radius" [precision]="2" [disabled]="true"></div>
						<div control-number [control]="controls.height" label="Height" [precision]="2" [disabled]="true"></div>
						<div control-number [control]="controls.arc" label="Arc" [precision]="0" [disabled]="true"></div>
						-->
						<div control-localized-asset [control]="controls.asset" label="Image or Video" accept="image/jpeg, video/mp4"></div>
					</div>
					<div class="group--cta">
						<button type="submit" class="btn--accept">
							<span>Create</span>
						</button>
					</div>
				</form>
			</div>
		</div>
	`
};
CurvedPlaneModalComponent.chunk = () => /* html */'<div class="curved-plane-modal" curved-plane-modal></div>';class ItemModelModalComponent extends rxcomp.Component {
  get data() {
    let data = null;
    const {
      parentInstance
    } = rxcomp.getContext(this);
    if (parentInstance instanceof ModalOutletComponent) {
      data = parentInstance.modal.data;
    }
    return data;
  }
  get view() {
    let view = null;
    const data = this.data;
    if (data) {
      view = data.view;
    }
    return view;
  }
  get object() {
    const object = new THREE.Object3D();
    const data = this.data;
    if (data) {
      const position = data.hit.position.clone();
      const normal = data.hit.normal.clone();
      const spherical = data.hit.spherical;
      if (spherical) {
        position.normalize().multiplyScalar(4);
        object.position.copy(position);
        object.lookAt(Host.origin);
      } else {
        object.lookAt(normal);
        object.position.set(position.x, position.y, position.z);
        object.position.add(normal.multiplyScalar(0.01));
      }
    }
    return object;
  }
  onInit() {
    const object = this.object;
    const form = this.form = new rxcompForm.FormGroup({
      type: ViewItemType.Model,
      position: new rxcompForm.FormControl(object.position.toArray(), rxcompForm.RequiredValidator()),
      rotation: new rxcompForm.FormControl([0, 0, 0], rxcompForm.RequiredValidator()),
      // [0, -Math.PI / 2, 0],
      // rotation: new FormControl(object.rotation.toArray(), RequiredValidator()), // [0, -Math.PI / 2, 0],
      scale: new rxcompForm.FormControl([1, 1, 1], rxcompForm.RequiredValidator()),
      asset: new rxcompForm.FormControl(null, rxcompForm.RequiredValidator())
    });
    this.controls = form.controls;
    form.changes$.subscribe(changes => {
      // console.log('ItemModelModalComponent.form.changes$', changes, form.valid, form);
      this.pushChanges();
    });
  }
  onSubmit() {
    if (this.form.valid) {
      const item = Object.assign({}, this.form.value);
      // item.viewId = parseInt(item.viewId);
      // console.log('ItemModelModalComponent.onSubmit', this.view, item);
      EditorService.inferItemCreate$(this.view, item).pipe(operators.first()).subscribe(response => {
        // console.log('ItemModelModalComponent.onSubmit.success', response);
        ModalService.resolve(response);
      }, error => console.log('ItemModelModalComponent.onSubmit.error', error));
    } else {
      this.form.touched = true;
    }
  }
  onClose() {
    ModalService.reject();
  }
}
ItemModelModalComponent.meta = {
  selector: '[item-model-modal]',
  template: /* html */`
		<div class="modal__header">
			<button type="button" class="btn--close" (click)="onClose()">
				<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#close"></use></svg>
			</button>
		</div>
		<div class="container">
			<div class="form">
				<div class="title">Create Model Item.</div>
				<form [formGroup]="form" (submit)="onSubmit()" name="form" role="form" novalidate autocomplete="off">
					<div class="form-controls">
						<div control-vector [control]="controls.position" label="Position" [precision]="2" [disabled]="true"></div>
						<div control-vector [control]="controls.rotation" label="Rotation" [precision]="3" [increment]="Math.PI / 360" [disabled]="true"></div>
						<div control-vector [control]="controls.scale" label="Scale" [precision]="2" [disabled]="true"></div>
						<div control-model [control]="controls.asset" label="Model (.glb)" accept=".glb"></div>
					</div>
					<div class="group--cta">
						<button type="submit" class="btn--accept">
							<span>Create</span>
						</button>
					</div>
				</form>
			</div>
		</div>
	`
};
ItemModelModalComponent.chunk = () => /* html */'<div class="item-model-modal" item-model-modal></div>';class MediaModalComponent extends rxcomp.Component {
  onInit() {
    this.error = null;
    const form = this.form = new rxcompForm.FormGroup({
      type: ViewType.Media,
      name: new rxcompForm.FormControl(null, rxcompForm.RequiredValidator()),
      asset: new rxcompForm.FormControl(null, rxcompForm.RequiredValidator())
    });
    this.controls = form.controls;
    form.changes$.subscribe(changes => {
      // console.log('MediaModalComponent.form.changes$', changes, form.valid, form);
      this.pushChanges();
    });
  }
  onSubmit() {
    if (this.form.valid) {
      this.form.submitted = true;
      const values = this.form.value;
      const view = {
        type: values.type,
        name: values.name,
        asset: values.asset,
        orientation: {
          latitude: 0,
          longitude: 0
        },
        zoom: 75
      };
      // console.log('MediaModalComponent.onSubmit.view', view);
      return EditorService.viewCreate$(view).pipe(operators.switchMap(view => {
        const item = {
          type: ViewItemType.Plane,
          position: [20, 0, 0],
          rotation: [0, -Math.PI / 2, 0],
          scale: [12, 6.75, 1],
          asset: values.asset
        };
        return EditorService.itemCreate$(view, item).pipe(operators.map(item => {
          view.items = [item];
          return view;
        }));
      }), operators.first()).subscribe(response => {
        // console.log('MediaModalComponent.onSubmit.success', response);
        ModalService.resolve(response);
      }, error => {
        console.log('MediaModalComponent.onSubmit.error', error);
        this.error = error;
        this.form.reset();
      });
    } else {
      this.form.touched = true;
    }
  }
  onClose() {
    ModalService.reject();
  }
}
MediaModalComponent.meta = {
  selector: '[media-modal]',
  template: /* html */`
		<div class="modal__header">
			<button type="button" class="btn--close" (click)="onClose()">
				<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#close"></use></svg>
			</button>
		</div>
		<div class="container">
			<div class="form">
				<div class="title">Create Media.</div>
				<form [formGroup]="form" (submit)="onSubmit()" name="form" role="form" novalidate autocomplete="off">
					<div class="form-controls">
						<div control-text [control]="controls.name" label="Name"></div>
						<div control-asset [control]="controls.asset" label="Image or Video" accept="image/jpeg, video/mp4"></div>
					</div>
					<div class="group--cta">
						<button type="submit" class="btn--accept">
							<span>Create</span>
						</button>
					</div>
				</form>
			</div>
		</div>
	`
};
MediaModalComponent.chunk = () => /* html */'<div class="media-modal" media-modal></div>';class ModelModalComponent extends rxcomp.Component {
  onInit() {
    this.error = null;
    const form = this.form = new rxcompForm.FormGroup({
      type: ViewType.Model,
      name: new rxcompForm.FormControl(null, rxcompForm.RequiredValidator()),
      asset: new rxcompForm.FormControl(null, rxcompForm.RequiredValidator()),
      model: new rxcompForm.FormControl(null, rxcompForm.RequiredValidator())
    });
    this.controls = form.controls;
    form.changes$.subscribe(changes => {
      // console.log('ModelModalComponent.form.changes$', changes, form.valid, form);
      this.pushChanges();
    });
  }
  onSubmit() {
    if (this.form.valid) {
      this.form.submitted = true;
      const values = this.form.value;
      const view = {
        type: values.type,
        name: values.name,
        asset: values.asset,
        orientation: {
          latitude: 0,
          longitude: 0
        },
        zoom: 75
      };
      // console.log('ModelModalComponent.onSubmit.view', view);
      return EditorService.viewCreate$(view).pipe(operators.switchMap(view => {
        const item = {
          type: ViewItemType.Model,
          asset: values.model
        };
        return EditorService.itemCreate$(view, item).pipe(operators.map(item => {
          view.items = [item];
          return view;
        }));
      }), operators.first()).subscribe(response => {
        // console.log('ModelModalComponent.onSubmit.success', response);
        ModalService.resolve(response);
      }, error => {
        console.log('ModelModalComponent.onSubmit.error', error);
        this.error = error;
        this.form.reset();
      });
    } else {
      this.form.touched = true;
    }
  }
  onClose() {
    ModalService.reject();
  }
}
ModelModalComponent.meta = {
  selector: '[model-modal]',
  template: /* html */`
		<div class="modal__header">
			<button type="button" class="btn--close" (click)="onClose()">
				<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#close"></use></svg>
			</button>
		</div>
		<div class="container">
			<div class="form">
				<div class="title">Create Model View.</div>
				<form [formGroup]="form" (submit)="onSubmit()" name="form" role="form" novalidate autocomplete="off">
					<div class="form-controls">
						<div control-text [control]="controls.name" label="Name"></div>
						<div control-asset [control]="controls.asset" label="Image" accept="image/jpeg"></div>
						<div control-model [control]="controls.model" label="Model (.glb)" accept=".glb"></div>
					</div>
					<div class="group--cta">
						<button type="submit" class="btn--accept">
							<span>Create</span>
						</button>
					</div>
				</form>
			</div>
		</div>
	`
};
ModelModalComponent.chunk = () => /* html */'<div class="model-modal" model-modal></div>';class NavModalComponent extends rxcomp.Component {
  get data() {
    let data = null;
    const {
      parentInstance
    } = rxcomp.getContext(this);
    if (parentInstance instanceof ModalOutletComponent) {
      data = parentInstance.modal.data;
    }
    return data;
  }
  get view() {
    let view = null;
    const data = this.data;
    if (data) {
      view = data.view;
    }
    return view;
  }
  get position() {
    let position = null;
    const data = this.data;
    if (data) {
      position = data.hit.position;
    }
    return position;
  }
  get object() {
    const object = new THREE.Object3D();
    const data = this.data;
    if (data) {
      const position = data.hit.position.clone();
      const normal = data.hit.normal.clone();
      const spherical = data.hit.spherical;
      if (spherical) {
        position.normalize().multiplyScalar(ModelNavComponent.RADIUS);
        object.position.copy(position);
        object.lookAt(Host.origin);
      } else {
        object.lookAt(normal);
        object.position.set(position.x, position.y, position.z);
        object.position.add(normal.multiplyScalar(0.01));
      }
    }
    return object;
  }
  onInit() {
    const object = this.object;
    this.error = null;
    this.useHooks = WebhookService.enabled;
    const form = this.form = new rxcompForm.FormGroup({
      type: ViewItemType.Nav,
      title: null,
      abstract: null,
      viewId: null,
      // new FormControl(null, RequiredValidator()),
      hook: null,
      hookExtra: null,
      keepOrientation: false,
      important: false,
      transparent: false,
      //
      position: new rxcompForm.FormControl(object.position.toArray(), rxcompForm.RequiredValidator()),
      rotation: new rxcompForm.FormControl(object.rotation.toArray(), rxcompForm.RequiredValidator()),
      // [0, -Math.PI / 2, 0],
      scale: new rxcompForm.FormControl([20, 5, 1], rxcompForm.RequiredValidator()),
      //
      asset: null,
      link: new rxcompForm.FormGroup({
        title: new rxcompForm.FormControl(null),
        href: new rxcompForm.FormControl(null),
        target: '_blank'
      })
      // upload: new FormControl(null, RequiredValidator()),
      // items: new FormArray([null, null, null], RequiredValidator()),
    });

    this.controls = form.controls;
    if (WebhookService.enabled) {
      const options = environment.webhook.methods.nav.map(x => ({
        id: x,
        name: x
      }));
      options.unshift({
        id: null,
        name: 'select'
      });
      this.controls.hook.options = options;
    }
    // !!! mode validator
    // form.addValidators(NavModalValidator(form, this.view));
    /*
    this.controls.viewId.options = [{
    	name: 'Name',
    	id: 2,
    }];
    */
    form.changes$.subscribe(changes => {
      // console.log('NavModalComponent.form.changes$', changes, form.valid, form);
      this.pushChanges();
    });
    EditorService.viewIdOptions$().pipe(operators.first()).subscribe(options => {
      this.controls.viewId.options = options;
      this.pushChanges();
    });
  }
  onSubmit() {
    if (this.form.valid) {
      this.form.submitted = true;
      const item = Object.assign({}, this.form.value);
      item.viewId = item.viewId ? parseInt(item.viewId) : this.view.id;
      if (item.link && (!item.link.title || !item.link.href)) {
        item.link = null;
      }
      // console.log('NavModalComponent.onSubmit', this.view, item);
      EditorService.inferItemCreate$(this.view, item).pipe(operators.first()).subscribe(response => {
        // console.log('NavModalComponent.onSubmit.success', response);
        ModalService.resolve(response);
      }, error => {
        console.log('NavModalComponent.onSubmit.error', error);
        this.error = error;
        this.form.submitted = false;
        // this.form.reset();
      });
    } else {
      this.form.touched = true;
    }
  }
  onViewIdDidChange(viewId) {
    // console.log('NavModalComponent.onViewIdDidChange', viewId, this.form.value);
    // const viewId = this.form.value.viewId;
    if (viewId != null && environment.flags.navAutoUpdateTitle) {
      const options = this.controls.viewId.options;
      const selectedOption = options.find(x => x.id === viewId);
      // console.log('NavModalComponent.onViewIdDidChange', selectedOption, options);
      if (selectedOption != null) {
        const title = selectedOption.name;
        const currentTitle = this.form.value.title;
        // console.log('NavModalComponent.onViewIdDidChange', title, currentTitle);
        if (!currentTitle || options.find(x => x.name === currentTitle)) {
          this.form.patch({
            title
          });
        }
      }
    }
  }
  onClose() {
    ModalService.reject();
  }
}
NavModalComponent.meta = {
  selector: '[nav-modal]',
  template: /* html */`
		<div class="modal__header">
			<button type="button" class="btn--close" (click)="onClose()">
				<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#close"></use></svg>
			</button>
		</div>
		<div class="container">
			<div class="form">
				<div class="title">Create Nav.</div>
				<form [formGroup]="form" (submit)="onSubmit()" name="form" role="form" novalidate autocomplete="off">
					<div class="form-controls">
						<div control-text [control]="controls.title" label="Title"></div>
						<div control-textarea [control]="controls.abstract" label="Abstract"></div>
						<div control-custom-select [control]="controls.viewId" label="NavToView" (change)="onViewIdDidChange($event)"></div>
						<div control-checkbox [control]="controls.keepOrientation" label="Keep Orientation"></div>
						<div control-checkbox [control]="controls.important" label="Important"></div>
						<div control-checkbox [control]="controls.transparent" label="Transparent"></div>
						<div control-vector [control]="controls.position" label="Position" [precision]="3" [disabled]="true"></div>
						<div *if="controls.transparent.value == true">
							<div control-vector [control]="controls.rotation" label="Rotation" [precision]="3" [increment]="Math.PI / 360" [disabled]="true"></div>
							<div control-vector [control]="controls.scale" label="Scale" [precision]="2" [disabled]="true"></div>
						</div>
						<div control-asset [control]="controls.asset" label="Image" accept="image/png, image/jpeg"></div>
						<div control-text [control]="controls.link.controls.title" label="Link Title"></div>
						<div control-text [control]="controls.link.controls.href" label="Link Url"></div>
						<div control-custom-select [control]="controls.hook" label="Hook" *if="useHooks"></div>
						<div control-text [control]="controls.hookExtra" label="Hook Extra" *if="useHooks"></div>
					</div>
					<div class="group--cta">
						<button type="submit" class="btn--accept">
							<span>Create</span>
						</button>
					</div>
				</form>
			</div>
		</div>
	`
};
NavModalComponent.chunk = () => /* html */'<div class="nav-modal" nav-modal></div>';class PanoramaGridModalComponent extends rxcomp.Component {
  onInit() {
    this.error = null;
    const form = this.form = new rxcompForm.FormGroup({
      type: ViewType.PanoramaGrid,
      name: new rxcompForm.FormControl(null, rxcompForm.RequiredValidator()),
      assets: new rxcompForm.FormControl(null, rxcompForm.RequiredValidator())
    });
    this.controls = form.controls;
    form.changes$.subscribe(changes => {
      // console.log('PanoramaGridModalComponent.form.changes$', changes, form.valid, form);
      this.pushChanges();
    });
  }
  onSubmit() {
    if (this.form.valid) {
      this.form.submitted = true;
      // console.log('PanoramaGridModalComponent.onSubmit', this.form.value);
      const assets = this.form.value.assets;
      const tiles = PanoramaGridView.mapTiles(assets.map(asset => ({
        asset,
        navs: []
      })), false, true);
      tiles.sort((a, b) => {
        const ai = a.indices.x * 10000 + a.indices.y;
        const bi = b.indices.x * 10000 + b.indices.y;
        return ai - bi;
      });
      // console.log('PanoramaGridModalComponent.onSubmit', tiles);
      const asset = tiles[0].asset;
      const view = {
        type: this.form.value.type,
        name: this.form.value.name,
        asset,
        tiles: tiles,
        invertAxes: true,
        flipAxes: false,
        orientation: {
          latitude: 0,
          longitude: 0
        },
        zoom: 75
      };
      EditorService.viewCreate$(view).pipe(operators.first()).subscribe(response => {
        // console.log('PanoramaGridModalComponent.onSubmit.success', response);
        ModalService.resolve(response);
      }, error => {
        console.log('PanoramaGridModalComponent.onSubmit.error', error);
        this.error = error;
        this.form.reset();
      });
    } else {
      this.form.touched = true;
    }
  }
  onClose() {
    ModalService.reject();
  }
}
PanoramaGridModalComponent.meta = {
  selector: '[panorama-grid-modal]',
  template: /* html */`
		<div class="modal__header">
			<button type="button" class="btn--close" (click)="onClose()">
				<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#close"></use></svg>
			</button>
		</div>
		<div class="container">
			<div class="form">
				<div class="title">Create Panorama Grid.</div>
				<form [formGroup]="form" (submit)="onSubmit()" name="form" role="form" novalidate autocomplete="off">
					<div class="form-controls">
						<div control-text [control]="controls.name" label="Name"></div>
						<div control-assets [control]="controls.assets" label="Image" accept="image/jpeg"></div>
					</div>
					<div class="group--cta">
						<button type="submit" class="btn--accept">
							<span>Create</span>
						</button>
					</div>
				</form>
			</div>
		</div>
	`
};
PanoramaGridModalComponent.chunk = () => /* html */'<div class="panorama-grid-modal" panorama-grid-modal></div>';class PanoramaModalComponent extends rxcomp.Component {
  onInit() {
    this.error = null;
    const form = this.form = new rxcompForm.FormGroup({
      type: ViewType.Panorama,
      name: new rxcompForm.FormControl(null, rxcompForm.RequiredValidator()),
      asset: new rxcompForm.FormControl(null, rxcompForm.RequiredValidator())
      // upload: new FormControl(null, RequiredValidator()),
      // items: new FormArray([null, null, null], RequiredValidator()),
    });

    this.controls = form.controls;
    form.changes$.subscribe(changes => {
      // console.log('PanoramaModalComponent.form.changes$', changes, form.valid, form);
      this.pushChanges();
    });
  }
  onSubmit() {
    if (this.form.valid) {
      this.form.submitted = true;
      const values = this.form.value;
      const view = {
        type: values.type,
        name: values.name,
        asset: values.asset,
        orientation: {
          latitude: 0,
          longitude: 0
        },
        zoom: 75
      };
      // console.log('PanoramaModalComponent.onSubmit.view', view);
      return EditorService.viewCreate$(view).pipe(operators.first()).subscribe(response => {
        // console.log('PanoramaModalComponent.onSubmit.success', response);
        ModalService.resolve(response);
      }, error => {
        console.log('PanoramaModalComponent.onSubmit.error', error);
        this.error = error;
        this.form.reset();
      });
    } else {
      this.form.touched = true;
    }
  }
  onClose() {
    ModalService.reject();
  }
}
PanoramaModalComponent.meta = {
  selector: '[panorama-modal]',
  template: /* html */`
		<div class="modal__header">
			<button type="button" class="btn--close" (click)="onClose()">
				<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#close"></use></svg>
			</button>
		</div>
		<div class="container">
			<div class="form">
				<div class="title">Create Panorama.</div>
				<form [formGroup]="form" (submit)="onSubmit()" name="form" role="form" novalidate autocomplete="off">
					<div class="form-controls">
						<div control-text [control]="controls.name" label="Name"></div>
						<div control-asset [control]="controls.asset" label="Image or Video" accept="image/jpeg, video/mp4"></div>
					</div>
					<div class="group--cta">
						<button type="submit" class="btn--accept">
							<span>Create</span>
						</button>
					</div>
					<!--
					<div class="group--form group--form--fixed">
						<code [innerHTML]="form.value | json"></code>
						<button type="button" class="btn--test" (click)="test()"><span>test</span></button>
					</div>
					-->
				</form>
			</div>
		</div>
	`
};
PanoramaModalComponent.chunk = () => /* html */'<div class="panorama-modal" panorama-modal></div>';class PathAddModalComponent extends rxcomp.Component {
  onInit() {
    const {
      parentInstance
    } = rxcomp.getContext(this);
    if (parentInstance instanceof ModalOutletComponent) {
      this.data = parentInstance.modal.data;
    }
    this.error = null;
    const form = this.form = new rxcompForm.FormGroup({
      name: new rxcompForm.FormControl(null, rxcompForm.RequiredValidator())
    });
    this.controls = form.controls;
    form.changes$.subscribe(changes => {
      // console.log('PathAddModalComponent.form.changes$', changes, form.valid, form);
      this.pushChanges();
    });
  }
  onSubmit() {
    if (this.form.valid) {
      this.form.submitted = true;
      const values = this.form.value;
      const path = {
        name: values.name,
        items: this.data ? this.data.item.items : []
      };
      // console.log('PathAddModalComponent.onSubmit.path', path);
      return PathService.pathCreate$(path).pipe(operators.first()).subscribe(response => {
        // console.log('PathAddModalComponent.onSubmit.success', response);
        ModalService.resolve(response);
      }, error => {
        console.log('PathAddModalComponent.onSubmit.error', error);
        this.error = error;
        this.form.reset();
      });
    } else {
      this.form.touched = true;
    }
  }
  onClose() {
    ModalService.reject();
  }
}
PathAddModalComponent.meta = {
  selector: '[path-add-modal]',
  template: /* html */`
		<div class="modal__header">
			<button type="button" class="btn--close" (click)="onClose()">
				<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#close"></use></svg>
			</button>
		</div>
		<div class="container">
			<div class="form">
				<div class="title">Add Path.</div>
				<div class="description">Aggiungi un percorso</div>
				<form [formGroup]="form" (submit)="onSubmit()" name="form" role="form" novalidate autocomplete="off">
					<div class="form-controls">
						<div control-text [control]="controls.name" label="Name"></div>
					</div>
					<div class="group--cta">
						<button type="submit" class="btn--accept">
							<span>Create</span>
						</button>
					</div>
				</form>
			</div>
		</div>
	`
};
PathAddModalComponent.chunk = () => /* html */'<div class="panorama-modal" path-add-modal></div>';class PathEditModalComponent extends rxcomp.Component {
  onInit() {
    this.item = null;
    this.views = null;
    const {
      parentInstance
    } = rxcomp.getContext(this);
    if (parentInstance instanceof ModalOutletComponent) {
      const data = parentInstance.modal.data;
      if (data) {
        this.item = data.item ? data.item : null;
        this.views = this.parseViews(data.views, this.item);
      }
    }
    this.error = null;
    const form = this.form = new rxcompForm.FormGroup({
      name: new rxcompForm.FormControl(this.item ? this.item.name : null, rxcompForm.RequiredValidator())
    });
    this.controls = form.controls;
    form.changes$.subscribe(changes => {
      // console.log('PathEditModalComponent.form.changes$', changes, form.valid, form);
      this.pushChanges();
    });
  }
  parseViews(views, item) {
    if (views && item) {
      return views.map(view => {
        return {
          id: view.id,
          name: view.name,
          type: view.type,
          active: item.items.indexOf(view.id) === -1
        };
      });
    } else {
      return [];
    }
  }
  onToggleView(view) {
    view.active = !view.active;
    this.pushChanges();
  }
  onSubmit() {
    if (this.form.valid) {
      this.form.submitted = true;
      const values = this.form.value;
      const payload = {
        id: this.item.id,
        name: values.name,
        items: this.views.filter(x => !x.active).map(x => x.id)
      };
      // console.log('PathEditModalComponent.onSubmit', payload);
      return PathService.pathUpdate$(payload).pipe(operators.first()).subscribe(response => {
        // console.log('PathEditModalComponent.onSubmit.success', response);
        ModalService.resolve(response);
      }, error => {
        console.log('PathEditModalComponent.onSubmit.error', error);
        this.error = error;
        this.form.reset();
      });
    } else {
      this.form.touched = true;
    }
  }
  onSelectAll() {
    this.views.forEach(view => view.active = true);
    this.pushChanges();
  }
  onSelectNone() {
    this.views.forEach(view => view.active = false);
    this.pushChanges();
  }
  onClose() {
    ModalService.reject();
  }
}
PathEditModalComponent.meta = {
  selector: '[path-edit-modal]',
  template: /* html */`
		<div class="modal__header">
			<button type="button" class="btn--close" (click)="onClose()">
				<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#close"></use></svg>
			</button>
		</div>
		<div class="container">
			<div class="form">
				<div class="title">Edit Path <span *if="item">&ldquo;<span [innerHTML]="item.title || item.name"></span>&rdquo;</span>.</div>
				<div class="description">Modifica il percorso</div>
				<form [formGroup]="form" (submit)="onSubmit()" name="form" role="form" novalidate autocomplete="off">
					<div class="form-controls">
						<div control-text [control]="controls.name" label="Name"></div>
					</div>
					<ul class="nav--flag" *if="views">
						<li class="nav__item" *for="let view of views">
							<button type="button" class="btn--flag" [class]="{ active: view.active }" [title]="view.name" (click)="onToggleView(view)">
								<div class="icon">
									<svg-icon [name]="view.type.name"></svg-icon>
								</div>
								<span class="name" [innerHTML]="view.name"></span>
								<span class="flag">
									<svg class="check" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#check"></use></svg>
									<svg class="close" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#close"></use></svg>
								</span>
							</button>
						</li>
					</ul>
					<div class="group--cta">
						<div class="group--options">
							<button type="button" class="btn--link" (click)="onSelectAll()">
								<span>Select all</span>
							</button>
							<button type="button" class="btn--link" (click)="onSelectNone()">
								<span>Select none</span>
							</button>
						</div>
						<button type="submit" class="btn--accept">
							<span>Save</span>
						</button>
					</div>
				</form>
			</div>
		</div>
	`
};
PathEditModalComponent.chunk = () => /* html */'<div class="path-edit-modal" path-edit-modal></div>';class PlaneModalComponent extends rxcomp.Component {
  get data() {
    let data = null;
    const {
      parentInstance
    } = rxcomp.getContext(this);
    if (parentInstance instanceof ModalOutletComponent) {
      data = parentInstance.modal.data;
    }
    return data;
  }
  get view() {
    let view = null;
    const data = this.data;
    if (data) {
      view = data.view;
    }
    return view;
  }
  get object() {
    const object = new THREE.Object3D();
    const data = this.data;
    if (data) {
      const position = data.hit.position.clone();
      const normal = data.hit.normal.clone();
      const spherical = data.hit.spherical;
      if (spherical) {
        position.normalize().multiplyScalar(20);
        object.position.copy(position);
        object.lookAt(Host.origin);
      } else {
        object.lookAt(normal);
        object.position.set(position.x, position.y, position.z);
        object.position.add(normal.multiplyScalar(0.01));
      }
    }
    return object;
  }
  onInit() {
    const object = this.object;
    const form = this.form = new rxcompForm.FormGroup({
      type: ViewItemType.Plane,
      position: new rxcompForm.FormControl(object.position.toArray(), rxcompForm.RequiredValidator()),
      rotation: new rxcompForm.FormControl(object.rotation.toArray(), rxcompForm.RequiredValidator()),
      // [0, -Math.PI / 2, 0],
      scale: new rxcompForm.FormControl([12, 6.75, 1], rxcompForm.RequiredValidator()),
      asset: null
    });
    this.controls = form.controls;
    form.changes$.subscribe(changes => {
      // console.log('PlaneModalComponent.form.changes$', changes, form.valid, form);
      this.pushChanges();
    });
  }
  onSubmit() {
    if (this.form.valid) {
      const item = Object.assign({}, this.form.value);
      // item.viewId = parseInt(item.viewId);
      // console.log('PlaneModalComponent.onSubmit', this.view, item);
      EditorService.inferItemCreate$(this.view, item).pipe(operators.first()).subscribe(response => {
        // console.log('PlaneModalComponent.onSubmit.success', response);
        ModalService.resolve(response);
      }, error => console.log('PlaneModalComponent.onSubmit.error', error));
    } else {
      this.form.touched = true;
    }
  }
  onClose() {
    ModalService.reject();
  }
}
PlaneModalComponent.meta = {
  selector: '[plane-modal]',
  template: /* html */`
		<div class="modal__header">
			<button type="button" class="btn--close" (click)="onClose()">
				<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#close"></use></svg>
			</button>
		</div>
		<div class="container">
			<div class="form">
				<div class="title">Create Plane.</div>
				<form [formGroup]="form" (submit)="onSubmit()" name="form" role="form" novalidate autocomplete="off">
					<div class="form-controls">
						<!-- <div control-text [control]="controls.title" label="Title"></div> -->
						<div control-vector [control]="controls.position" label="Position" [precision]="2" [disabled]="true"></div>
						<div control-vector [control]="controls.rotation" label="Rotation" [precision]="3" [increment]="Math.PI / 360" [disabled]="true"></div>
						<div control-vector [control]="controls.scale" label="Scale" [precision]="2" [disabled]="true"></div>
						<div control-localized-asset [control]="controls.asset" label="Image or Video" accept="image/jpeg, video/mp4"></div>
					</div>
					<div class="group--cta">
						<button type="submit" class="btn--accept">
							<span>Create</span>
						</button>
					</div>
				</form>
			</div>
		</div>
	`
};
PlaneModalComponent.chunk = () => /* html */'<div class="plane-modal" plane-modal></div>';class RemoveModalComponent extends rxcomp.Component {
  get data() {
    let data = null;
    const {
      parentInstance
    } = rxcomp.getContext(this);
    if (parentInstance instanceof ModalOutletComponent) {
      data = parentInstance.modal.data;
    }
    return data;
  }
  get item() {
    let item = null;
    const data = this.data;
    if (data) {
      item = data.item;
    }
    return item;
  }
  onRemove() {
    ModalService.resolve();
  }
  onCancel() {
    ModalService.reject();
  }
  onClose() {
    ModalService.reject();
  }
}
RemoveModalComponent.meta = {
  selector: '[remove-modal]',
  template: /* html */`
		<div class="modal__header">
			<button type="button" class="btn--close" (click)="onClose()">
				<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#close"></use></svg>
			</button>
		</div>
		<div class="container">
			<div class="form">
				<div class="title">Remove <span *if="item">&ldquo;<span [innerHTML]="item.title || item.name"></span>&rdquo;</span>.</div>
				<div class="abstract">are you sure?</div>
				<div class="group--cta">
					<button type="button" class="btn--remove" (click)="onRemove($event)">
						<span>Remove</span>
					</button>
					<button type="button" class="btn--accept" (click)="onCancel($event)">
						<span>Cancel</span>
					</button>
				</div>
			</div>
		</div>
	`
};
RemoveModalComponent.chunk = () => /* html */'<div class="remove-modal" remove-modal></div>';class Room3DModalComponent extends rxcomp.Component {
  onInit() {
    this.error = null;
    const form = this.form = new rxcompForm.FormGroup({
      type: ViewType.Room3d,
      name: new rxcompForm.FormControl(null, rxcompForm.RequiredValidator()),
      asset: new rxcompForm.FormControl(null, rxcompForm.RequiredValidator())
      // model: new FormControl(null, RequiredValidator()),
    });

    this.controls = form.controls;
    form.changes$.subscribe(changes => {
      // console.log('Room3DModalComponent.form.changes$', changes, form.valid, form);
      this.pushChanges();
    });
  }
  onSubmit() {
    if (this.form.valid) {
      this.form.submitted = true;
      const values = this.form.value;
      const view = {
        type: values.type,
        name: values.name,
        asset: values.asset,
        orientation: {
          latitude: 0,
          longitude: 0
        },
        zoom: 75
      };
      // console.log('Room3DModalComponent.onSubmit.view', view);
      return EditorService.viewCreate$(view).pipe(
      /*
      switchMap(view => {
      	const item = {
      		type: ViewItemType.Model,
      		asset: values.model,
      	};
      	return EditorService.itemCreate$(view, item).pipe(
      		map(item => {
      			view.items = [item];
      			return view;
      		})
      	);
      }),
      */
      operators.first()).subscribe(response => {
        // console.log('Room3DModalComponent.onSubmit.success', response);
        ModalService.resolve(response);
      }, error => {
        console.log('Room3DModalComponent.onSubmit.error', error);
        this.error = error;
        this.form.reset();
      });
    } else {
      this.form.touched = true;
    }
  }
  onClose() {
    ModalService.reject();
  }
}
Room3DModalComponent.meta = {
  selector: '[room-3d-modal]',
  template: /* html */`
		<div class="modal__header">
			<button type="button" class="btn--close" (click)="onClose()">
				<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#close"></use></svg>
			</button>
		</div>
		<div class="container">
			<div class="form">
				<div class="title">Create Room 3D View.</div>
				<form [formGroup]="form" (submit)="onSubmit()" name="form" role="form" novalidate autocomplete="off">
					<div class="form-controls">
						<div control-text [control]="controls.name" label="Name"></div>
						<!--
						<div control-asset [control]="controls.asset" label="Image" accept="image/jpeg"></div>
						<div control-model [control]="controls.model" label="Model (.glb)" accept=".glb"></div>
						-->
						<div control-model [control]="controls.asset" label="Model (.glb)" accept=".glb"></div>
					</div>
					<div class="group--cta">
						<button type="submit" class="btn--accept">
							<span>Create</span>
						</button>
					</div>
				</form>
			</div>
		</div>
	`
};
Room3DModalComponent.chunk = () => /* html */'<div class="room-3d-modal" room-3d-modal></div>';const SETTINGS = {
  menu: [{
    id: 'menu',
    title: 'editor_menu',
    active: true
  }, {
    id: 'navmaps',
    title: 'editor_navmaps',
    active: true
  }],
  current: null,
  active: false
};
class EditorComponent extends rxcomp.Component {
  get dataViews() {
    return ViewService.dataViews;
  }
  get pathViews() {
    return ViewService.pathViews;
  }
  onInit() {
    const {
      node
    } = rxcomp.getContext(this);
    node.classList.remove('hidden');
    this.settings = this.getSettings();
    this.aside = false;
    this.state = {};
    this.view = null;
    this.paths = null;
    this.path = null;
    this.form = null;
    this.local = null;
    this.remotes = [];
    this.viewHit = new rxjs.Subject();
    const vrService = this.vrService = VRService.getService();
    vrService.status$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(status => this.pushChanges());
    this.resolveUser();
  }
  resolveUser() {
    UserService.me$().pipe(operators.takeUntil(this.unsubscribe$)).subscribe(user => {
      if (user && user.type === RoleType.Publisher) {
        this.user = user;
        this.initState();
      } else {
        RouterService.setRouterLink(RoutePipe.transform(':lang.access'));
      }
    });
  }
  initState() {
    const user = this.user;
    const role = user.type;
    const name = user.firstName && user.lastName ? `${user.firstName} ${user.lastName}` : null;
    const state = {
      user: user,
      role: role,
      name: name,
      mode: UIMode.VirtualTour,
      link: null,
      channelName: environment.channelName,
      uid: null,
      status: AgoraStatus.Connected,
      connecting: false,
      connected: true,
      controlling: false,
      spying: false,
      silencing: false,
      hosted: true,
      live: false,
      navigable: true,
      cameraMuted: false,
      audioMuted: false,
      showNavInfo: true
    };
    StateService.state = state;
    StateService.state$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(state => {
      this.state = state;
      this.hosted = state.hosted;
      this.pushChanges();
    });
    this.viewObserver$().pipe(operators.takeUntil(this.unsubscribe$)).subscribe(view => {
      // console.log('EditorComponent.viewObserver$', view);
    });
    StreamService.mode = StreamServiceMode.Editor;
    // this.getUserMedia();
  }

  viewObserver$() {
    return EditorService.data$().pipe(operators.switchMap(data => {
      // console.log('viewObserver$', data);
      const meetingUrl = new MeetingUrl();
      const pathId = meetingUrl.pathId;
      return PathService.getCurrentPath$(pathId).pipe(operators.switchMap(path => {
        this.paths = PathService.paths;
        this.path = path;
        return ViewService.editorView$(data, path);
      }));
    }), operators.tap(view => {
      this.view = null;
      this.pushChanges();
    }), operators.delay(1), operators.tap(view => {
      // console.log('EditorComponent.viewObserver$', view, ViewService.pathViews, ViewService.dataViews);
      this.view = view;
      this.pushChanges();
    }));
  }
  onAddPath() {
    // console.log('EditorComponent.onAddPath');
    ModalService.open$({
      template: PathAddModalComponent.chunk()
    }).pipe(operators.first()).subscribe(event => {
      if (event instanceof ModalResolveEvent) {
        PathService.addPath(event.data);
      }
    });
  }
  onEditPath(item) {
    // console.log('EditorComponent.onEditPath', item);
    ModalService.open$({
      template: PathEditModalComponent.chunk(),
      data: {
        item: item,
        views: ViewService.validViews
      }
    }).pipe(operators.first()).subscribe(event => {
      if (event instanceof ModalResolveEvent) {
        PathService.editPath(event.data);
      }
    });
  }
  onDuplicatePath(item) {
    // console.log('EditorComponent.onDuplicatePath', item);
    ModalService.open$({
      template: PathAddModalComponent.chunk(),
      data: {
        item
      }
    }).pipe(operators.first()).subscribe(event => {
      if (event instanceof ModalResolveEvent) {
        PathService.addPath(event.data);
      }
    });
  }
  onDeletePath(item) {
    // console.log('EditorComponent.onDeletePath', item);
    ModalService.open$({
      template: RemoveModalComponent.chunk(),
      data: {
        item: item
      }
    }).pipe(operators.first()).subscribe(event => {
      if (event instanceof ModalResolveEvent) {
        PathService.pathDelete$(item).pipe(operators.first()).subscribe(_ => {
          PathService.deletePath(item);
        });
      }
    });
  }
  onSelectPath(item) {
    // console.log('EditorComponent.onSelectPath', item);
    PathService.path = item;
  }
  isPathSelected(item) {
    // console.log('EditorComponent.isPathSelected', item);
    return PathService.path.id === item.id;
  }
  onNavTo(item) {
    // console.log('EditorComponent.onNavTo', item);
    const viewId = item.viewId;
    const view = ViewService.pathViews.find(x => x.id === viewId);
    if (view) {
      ViewService.action = {
        viewId,
        keepOrientation: item.keepOrientation,
        useLastOrientation: item.useLastOrientation
      };
    }
  }
  onNavLink(event) {
    // console.log('EditorComponent.onNavLink', event);
    ModalService.open$({
      iframe: event.link.href
    }).pipe(operators.first()).subscribe(_ => {
      MessageService.send({
        type: MessageType.NavLinkClose,
        itemId: event.item.id
      });
    });
  }
  patchState(state) {
    this.state = Object.assign({}, this.state, state);
    this.pushChanges();
    // console.log(this.state);
  }

  tryInAr() {
    ModalService.open$({
      template: TryInARModalComponent.chunk(),
      data: this.view
    }).pipe(operators.first()).subscribe(event => {
      // this.pushChanges();
    });
  }
  onToggleAside() {
    this.aside = !this.aside;
    this.pushChanges();
    window.dispatchEvent(new Event('resize'));
  }
  getSettings() {
    const settings = Object.assign({}, SETTINGS);
    settings.menu = settings.menu.filter(x => environment.flags[x.id]);
    settings.current = settings.menu.length ? settings.menu[0].id : null;
    return settings;
  }
  onToggleSettings() {
    const settings = this.settings;
    settings.active = !settings.active;
    this.pushChanges();
  }
  onSelectSetting(item) {
    this.settings.current = item.id;
    this.pushChanges();
  }

  // editor

  onViewHit(event) {
    // console.log('onViewHit');
    this.viewHit.next(event);
  }
  onViewHitted(callback) {
    if (this.viewHitSubscription) {
      this.viewHitSubscription.unsubscribe();
      this.viewHitSubscription = null;
    }
    if (typeof callback === 'function') {
      this.viewHitSubscription = this.viewHit.pipe(operators.first()).subscribe(event => callback(event));
    }
  }
  onDragEnd(event) {
    EditorService.inferItemUpdate$(this.view, event.item).pipe(operators.first()).subscribe(response => {
      // console.log('EditorComponent.onDragEnd.inferItemUpdate$.success', response);
      this.pushChanges();
    }, error => console.log('EditorComponent.onDragEnd.inferItemUpdate$.error', error, this.view, event.item, event.item.payload));
  }
  onResizeEnd(event) {
    // console.log('EditorComponent.onResizeEnd');
    /*
    EditorService.inferItemUpdate$(this.view, event.item).pipe(
    	first(),
    ).subscribe(response => {
    	// console.log('EditorComponent.onResizeEnd.inferItemUpdate$.success', response);
    	this.pushChanges();
    }, error => console.log('EditorComponent.onResizeEnd.inferItemUpdate$.error', error));
    */
  }
  onWorldSelect(event) {
    // console.log('EditorComponent.onWorldSelect', this.view);
    if (this.view) {
      let selectedItem;
      this.view.items.forEach(item => item.showPanel = false);
      this.view.items.forEach(item => {
        item.selected = item === event.item;
        selectedItem = item.selected ? item : selectedItem;
      });
      this.view.selected = !selectedItem;
      this.pushChanges();
      if (selectedItem) {
        this.aside = true;
        this.pushChanges();
        window.dispatchEvent(new Event('resize'));
      }
    }
  }
  onOpenModal(modal, data) {
    let template = null;
    switch (modal.type) {
      case 'view':
        switch (modal.value) {
          case ViewType.Panorama.name:
            template = PanoramaModalComponent.chunk();
            break;
          case ViewType.PanoramaGrid.name:
            template = PanoramaGridModalComponent.chunk();
            break;
          case ViewType.Model.name:
            template = ModelModalComponent.chunk();
            break;
          case ViewType.Room3d.name:
            template = Room3DModalComponent.chunk();
            break;
          case ViewType.Media.name:
            template = MediaModalComponent.chunk();
            break;
        }
        break;
      case 'viewItem':
        switch (modal.value) {
          case ViewItemType.Nav.name:
            template = NavModalComponent.chunk();
            break;
          case ViewItemType.Plane.name:
            template = PlaneModalComponent.chunk();
            break;
          case ViewItemType.CurvedPlane.name:
            template = CurvedPlaneModalComponent.chunk();
            break;
          case ViewItemType.Model.name:
            template = ItemModelModalComponent.chunk();
            break;
        }
        break;
    }
    if (!template) {
      return;
    }
    ModalService.open$({
      template,
      data
    }).pipe(operators.first()).subscribe(event => {
      if (event instanceof ModalResolveEvent) {
        // console.log('EditorComponent.onOpenModal.resolve', event);
        switch (modal.type) {
          case 'view':
            switch (modal.value) {
              case ViewType.Panorama.name:
              case ViewType.PanoramaGrid.name:
              case ViewType.Model.name:
              case ViewType.Room3d.name:
              case ViewType.Media.name:
                ViewService.addView(event.data);
                break;
            }
            break;
          case 'viewItem':
            switch (modal.value) {
              case ViewItemType.Nav.name:
              case ViewItemType.Plane.name:
              case ViewItemType.CurvedPlane.name:
              case ViewItemType.Model.name:
                {
                  const item = event.data; // Object.assign({}, event.data);
                  const tile = EditorService.getTile(this.view);
                  if (tile) {
                    const navs = tile.navs || [];
                    navs.push(item);
                    tile.navs = navs;
                    this.view.updateCurrentItems();
                  } else {
                    item.path = true;
                    const items = this.view.items || [];
                    items.push(item);
                    this.view.items = items;
                  }
                  this.pushChanges();
                  break;
                }
            }
            break;
        }
      }
      this.pushChanges();
    });
  }
  onAsideSelect(event) {
    // console.log('onAsideSelect', event);
    if (event.value) {
      switch (event.value) {
        case ViewItemType.Nav.name:
        case ViewItemType.Plane.name:
        case ViewItemType.CurvedPlane.name:
          this.onViewHitted(hit => {
            this.onOpenModal(event, {
              view: this.view,
              hit
            });
          });
          ToastService.open$({
            message: 'Click a point on the view'
          });
          break;
        case ViewItemType.Model.name:
          if (event.type === 'viewItem') {
            if (this.view.type.name === ViewType.Model.name) {
              return;
            }
            this.onViewHitted(hit => {
              this.onOpenModal(event, {
                view: this.view,
                hit
              });
            });
            ToastService.open$({
              message: 'Click a point on the view'
            });
          } else {
            this.onOpenModal(event, {
              view: this.view
            });
          }
          break;
        default:
          this.onOpenModal(event, {
            view: this.view
          });
      }
    } else if (event.view && (event.item || event.item === null)) {
      event.view.selected = false;
      event.view.items.forEach(item => item.selected = item === event.item);
      MessageService.send({
        type: MessageType.SelectItem
      });
      this.pushChanges();
    } else if (event.view && (event.tile || event.tile === null)) {
      event.view.selected = false;
      event.view.tiles.forEach(tile => tile.selected = tile === event.tile);
      MessageService.send({
        type: MessageType.SelectItem
      });
      /*
      // if tile selected
      // send ChangeTile message to world component
      this.orbitService.walk(event.position, (headingLongitude, headingLatitude) => {
      	const item = this.view.getTile(event.indices.x, event.indices.y);
      	if (item) {
      		this.panorama.crossfade(item, this.renderer, (envMap, texture, rgbe) => {
      			// this.scene.background = envMap;
      			this.scene.environment = envMap;
      			this.orbitService.walkComplete(headingLongitude, headingLatitude);
      			// this.render();
      			// this.pushChanges();
      		});
      	}
      });
      */
      this.pushChanges();
    } else if (event.view || event.view === null) {
      this.view.selected = this.view === event.view;
      this.view.items.forEach(item => item.selected = false);
      const currentTile = EditorService.getTile(this.view);
      if (currentTile) {
        this.view.tiles.forEach(tile => tile.selected = tile === currentTile);
      }
      MessageService.send({
        type: MessageType.SelectItem
      });
      this.pushChanges();
    }
  }
  onAsideUpdate(event) {
    // console.log('onAsideUpdate', event);
    if (event.item && event.view) {
      this.pushChanges();
    } else if (event.tile && event.view) ; else if (event.view) {
      if (ViewService.viewId !== event.view.id) {
        ViewService.viewId = event.view.id;
      } else {
        const assetDidChange = AssetService.assetDidChange(this.view.asset, event.view.asset);
        Object.assign(this.view, event.view);
        if (assetDidChange) {
          if (typeof this.view.onUpdateAsset === 'function') {
            this.view.onUpdateAsset();
          }
        }
        this.pushChanges();
      }
    }
  }
  onAsideDelete(event) {
    // console.log('onAsideDelete', event);
    if (event.item && event.view) {
      EditorService.inferItemDelete$(event.view, event.item).pipe(operators.first()).subscribe(response => {
        // console.log('EditorComponent.onAsideDelete.inferItemDelete$.success', response);
        EditorService.inferItemDeleteResult$(event.view, event.item);
        this.pushChanges();
      }, error => console.log('EditorComponent.onAsideDelete.inferItemDelete$.error', error));
    } else if (event.view) {
      EditorService.viewDelete$(event.view).pipe(operators.first()).subscribe(response => {
        // console.log('EditorComponent.onAsideDelete.viewDelete$.success', response);
        ViewService.deleteView(event.view);
      }, error => console.log('EditorComponent.onAsideDelete.viewDelete$.error', error));
    }
  }
}
EditorComponent.meta = {
  selector: '[editor-component]',
  hosts: {
    host: RouterOutletStructure
  },
  template: /* html */`
	<div class="page page--editor">
		<div class="ui" [class]="{ open: aside }" *if="dataViews.length">
			<div class="ui__navbar">
				<div class="btn--settings" [class]="{ active: settings.active }" (click)="onToggleSettings($event)" *if="settings.menu.length > 0">
					<svg class="settings" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#settings-full"></use></svg>
				</div>
				<div class="headline" *if="view">
					<div class="headline__id" [innerHTML]="view.id"></div>
					<div class="headline__icon">
						<svg-icon [name]="view.type.name"></svg-icon>
					</div>
					<div class="headline__name" [innerHTML]="view.name"></div>
				</div>
				<div class="group--path" *if="('usePaths' | flag) && path">
					<div class="group--path__select">
						<div class="group--form--select" [dropdown]="'path'">
							<label>Percorso</label>
							<span class="control--custom-select" [innerHTML]="path.name"></span>
							<svg class="icon--caret-down"><use xlink:href="#caret-down"></use></svg>
						</div>
						<div class="dropdown dropdown-item" [dropdown-item]="'path'">
							<div class="category">Percorso</div>
							<ul class="nav--dropdown">
								<li [class]="{ active: isPathSelected(item) }" *for="let item of paths">
									<span [innerHTML]="item.name" (click)="onSelectPath(item)"></span>
									<div class="check">
										<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#check"></use></svg>
									</div>
									<div class="btn--flags" (click)="onEditPath(item)" title="Edit" *if="item.id">
										<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#flags"></use></svg>
									</div>
									<div class="btn--duplicate" (click)="onDuplicatePath(item)" title="Duplicate" *if="item.id">
										<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#duplicate"></use></svg>
									</div>
									<div class="btn--trash" (click)="onDeletePath(item)" title="Delete" *if="item.id">
										<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#trash"></use></svg>
									</div>
								</li>
							</ul>
							<div class="btn--mode" (click)="onAddPath()">Aggiungi un percorso</div>
						</div>
					</div>
				</div>
				<div class="btn--edit" [class]="{ active: aside }" (click)="onToggleAside($event)">
					<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#edit"></use></svg>
				</div>
			</div>
			<div class="ui__body">
				<div class="world" world [view]="view" [views]="pathViews" [editor]="true" (navTo)="onNavTo($event)" (viewHit)="onViewHit($event)" (dragEnd)="onDragEnd($event)" (select)="onWorldSelect($event)"></div>
			</div>
			<!-- footer -->
			<div class="group--footer">
				<div class="group--ar-vr">
					<button type="button" class="btn--ar" [href]="view?.ar" (click)="tryInAr()" *if="view?.ar">
						<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#ar"></use></svg> <span>Try in AR</span>
					</button>
					<button type="button" class="btn--vr" [class]="{ disabled: vrService.isDisabled() }" (click)="vrService.toggleVR()">
						<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#vr"></use></svg> <span [innerHTML]="vrService.getLabel()"></span>
					</button>
				</div>
			</div>
			<div class="ui__settings" *if="settings.active">
				<!-- settings navs -->
				<div class="group--nav">
					<ul class="nav--menu">
						<li class="nav__item" *for="let item of settings.menu" [class]="{ active: settings.current === item.id }" (click)="onSelectSetting(item)"><span class="title" [innerHTML]="item.title | label"></span></li>
					</ul>
				</div>
				<!-- menu -->
				<div class="group--content" menu-builder [views]="dataViews" *if="settings.current === 'menu'"></div>
				<!-- navmaps -->
				<div class="group--content" navmap-builder [views]="dataViews" *if="settings.current === 'navmaps'"></div>
			</div>
		</div>
		<div class="aside" [class]="{ active: aside }" aside [view]="view" (select)="onAsideSelect($event)" (update)="onAsideUpdate($event)" (delete)="onAsideDelete($event)" *if="view && aside"></div>
	</div>
	`
};class GenericService {
  static currentLanguagePage$(key) {
    return LanguageService.lang$.pipe(operators.switchMap(lang => {
      return this.page$(lang, key);
    }));
  }
  static page$(lang, key) {
    const url = environment.flags.production ? `/api/${lang}/pages/${key}/` : `./api/${lang}/pages/${key}.json`;
    return HttpService.get$(url);
  }
}class GenericComponent extends rxcomp.Component {
  onInit() {
    this.route = this.host ? this.host.route : null;
    this.state = {
      status: 'generic'
    };
    this.page = null;
    GenericService.currentLanguagePage$(this.route.params.mode).pipe(operators.takeUntil(this.unsubscribe$)).subscribe(page => {
      this.page = page;
      this.pushChanges();
    });
  }
}
GenericComponent.meta = {
  selector: '[generic-component]',
  hosts: {
    host: RouterOutletStructure
  },
  template: /*html*/`
		<div class="page page--generic">
			<!-- generic -->
			<div class="ui ui--generic" *if="page">
				<div class="group--generic">
					<div class="group--generic__content stagger--childs">
						<h1 class="title" [innerHTML]="page.title"></h1>
						<div class="description" [innerHTML]="page.description"></div>
					</div>
				</div>
			</div>
			<header>
				${CHUNK_LOGO}
				${CHUNK_LANGUAGE}
			</header>
			<footer>
				<span class="group--colophon" *if="state.status != 'connected'">
					${CHUNK_CREDITS}
					${CHUNK_COPYRIGHT}
				</span>
			</footer>
		</div>
	`
};class LayoutComponent extends rxcomp.Component {
  get meetingUrl() {
    if (!this.meetingUrl_) {
      this.meetingUrl_ = new MeetingUrl();
    }
    return this.meetingUrl_;
  }
  get isVirtualTourUser() {
    return [RoleType.Publisher, RoleType.Attendee, RoleType.Streamer, RoleType.Viewer].indexOf(this.state.role) !== -1;
  }
  get isEmbed() {
    return this.route && this.route.params.mode === 'embed';
  }
  get isSelfServiceTour() {
    return this.route && this.route.params.mode === 'selfServiceTour';
  }
  get isNavigable() {
    const embedViewId = this.meetingUrl.embedViewId;
    const navigable = embedViewId == null;
    return navigable;
  }
  get isBackButtonVisible() {
    return this.view && (this.view.type.name === ViewType.Media.name || this.view.type.name === ViewType.Model.name);
  }
  get showNavInfoToggler() {
    return environment.flags.hideNavInfo && this.state.mode !== UIMode.LiveMeeting;
  }
  get uiClass() {
    const uiClass = {};
    uiClass[this.state.role] = true;
    // uiClass[this.state.mode] = true;
    uiClass.chat = this.state.chat;
    uiClass.remotes = this.state.mode === UIMode.LiveMeeting;
    uiClass.remoteScreen = this.remoteScreen != null && !this.hasScreenViewItem;
    uiClass.media = !uiClass.remotes && this.media;
    uiClass.locked = this.locked;
    return uiClass;
  }
  get remoteClass() {
    return `group--remote--${Math.min(9, this.remotes.length)}`;
  }
  get controlled() {
    return this.state.controlling && this.state.controlling !== this.state.uid;
  }
  get controlling() {
    return this.state.controlling && this.state.controlling === this.state.uid;
  }
  get silencing() {
    return StateService.state.silencing;
  }
  get silenced() {
    return StateService.state.silencing && StateService.state.role === RoleType.Streamer;
  }
  get spyed() {
    return this.state.spying && this.state.spying === this.state.uid;
  }
  get spying() {
    return this.state.spying && this.state.spying !== this.state.uid;
  }
  get locked() {
    return this.controlled || this.spying;
  }
  get remoteScreen() {
    return this.remoteScreen_;
  }
  set remoteScreen(remoteScreen) {
    if (this.remoteScreen_ !== remoteScreen) {
      this.remoteScreen_ = remoteScreen;
      window.dispatchEvent(new Event('resize'));
    }
  }
  onInit() {
    const meetingUrl = this.meetingUrl;
    const embedViewId = meetingUrl.embedViewId;
    this.state = {
      status: LocationService.get('status') || AgoraStatus.Connected,
      role: LocationService.get('role') || RoleType.Publisher,
      // Publisher, Attendee, Streamer, Viewer, SmartDevice, SelfService, Embed
      membersCount: 3,
      controlling: false,
      spying: false,
      silencing: false,
      hosted: true,
      chat: false,
      chatDirty: true,
      name: 'Jhon Appleseed',
      uid: '7341614597544882',
      showNavInfo: true
    };
    this.state.live = this.state.role === RoleType.SelfService || this.state.role === RoleType.Embed || DEBUG ? false : true;
    this.state.navigable = embedViewId == null;
    this.state.mode = UserService.getMode(this.state.role);
    this.view = {
      likes: 41,
      type: {
        id: 2,
        name: 'panorama'
      }
    };
    this.local = {};
    this.screen = null;
    this.remoteScreen_ = null;
    this.media = null;
    this.hasScreenViewItem = false;
    this.media = true;
    this.remotes = new Array(8).fill(0).map((x, i) => ({
      id: i + 1
    }));
    this.languageService = LanguageService;
    this.showLanguages = false;
    StateService.patchState(this.state);
    this.fullscreen$().pipe(operators.takeUntil(this.unsubscribe$)).subscribe();
    this.vrService = VRService.getService();
    console.log('LayoutComponent', this);
    // console.log(AgoraService.getUniqueUserId());

    setTimeout(() => {
      const type = ToastType.Dialog;
      switch (type) {
        case ToastType.Info:
          ToastService.open$({
            message: LabelPipe.transform('bhere_support_request_sent')
          }).pipe(operators.takeUntil(this.unsubscribe$)).subscribe(event => {
            if (event instanceof ToastResolveEvent) {
              console.log('ToastResolveEvent', event);
            }
          });
          break;
        case ToastType.Alert:
          ToastService.open$({
            message: LabelPipe.transform('bhere_support_request_sent'),
            type: type,
            position: ToastPosition.BottomRight
          }).pipe(operators.takeUntil(this.unsubscribe$)).subscribe(event => {
            if (event instanceof ToastResolveEvent) {
              console.log('ToastResolveEvent', event);
            } else if (event instanceof ToastRejectEvent) {
              console.log('ToastRejectEvent', event);
            }
          });
          break;
        case ToastType.Dialog:
          ToastService.open$({
            message: LabelPipe.transform('bhere_support_request_dialog'),
            acceptMessage: LabelPipe.transform('bhere_support_request_dialog_accept'),
            rejectMessage: LabelPipe.transform('bhere_support_request_dialog_reject'),
            type: type,
            position: ToastPosition.BottomRight
          }).pipe(operators.takeUntil(this.unsubscribe$)).subscribe(event => {
            if (event instanceof ToastResolveEvent) {
              console.log('ToastResolveEvent', event);
            } else if (event instanceof ToastRejectEvent) {
              console.log('ToastRejectEvent', event);
            }
          });
          break;
      }
    }, 3000);
  }
  setLanguage(language) {
    this.languageService.setLanguage$(language).pipe(operators.first()).subscribe(_ => {
      this.showLanguages = false;
      this.pushChanges();
    });
  }
  toggleLanguages() {
    this.showLanguages = !this.showLanguages;
    this.pushChanges();
  }
  patchState(state) {
    this.state = Object.assign({}, this.state, state);
    this.screen = this.state.screen || null;
    this.remoteScreen = this.screen;
    this.pushChanges();
  }
  toggleCamera() {
    this.patchState({
      cameraMuted: !this.state.cameraMuted
    });
  }
  toggleAudio() {
    this.patchState({
      audioMuted: !this.state.audioMuted
    });
  }
  toggleScreen() {
    this.patchState({
      screen: !this.state.screen
    });
    window.dispatchEvent(new Event('resize'));
  }
  toggleVolume() {
    this.patchState({
      volumeMuted: !this.state.volumeMuted
    });
  }
  toggleMode() {
    const mode = this.state.mode === UIMode.VirtualTour ? UIMode.LiveMeeting : UIMode.VirtualTour;
    this.patchState({
      mode: mode
    });
    // this.pushChanges();
  }

  toggleFullScreen() {
    const {
      node
    } = rxcomp.getContext(this);
    const fullScreen = !this.state.fullScreen;
    if (fullScreen) {
      if (node.requestFullscreen) {
        node.requestFullscreen();
      } else if (node.webkitRequestFullscreen) {
        node.webkitRequestFullscreen();
      } else if (node.msRequestFullscreen) {
        node.msRequestFullscreen();
      }
    } else {
      if (document.exitFullscreen) {
        document.exitFullscreen();
      } else if (document.webkitExitFullscreen) {
        document.webkitExitFullscreen();
      } else if (document.msExitFullscreen) {
        document.msExitFullscreen();
      }
    }
    // this.patchState({ fullScreen });
  }

  fullscreen$() {
    return rxjs.fromEvent(document, 'fullscreenchange').pipe(operators.tap(_ => {
      const fullScreen = document.fullscreenElement != null;
      // console.log('fullscreen$', fullScreen);
      this.patchState({
        fullScreen
      });
    }));
  }
  toggleChat() {
    this.patchState({
      chat: !this.state.chat,
      chatDirty: false
    });
    window.dispatchEvent(new Event('resize'));
  }
  toggleNavInfo() {
    this.patchState({
      showNavInfo: !this.state.showNavInfo
    });
  }
  onBack() {
    console.log('LayoutComponent.onBack');
  }
  onChatClose() {
    this.patchState({
      chat: false
    });
    window.dispatchEvent(new Event('resize'));
  }
  onToggleControl(remoteId) {
    const controlling = this.state.controlling === remoteId ? null : remoteId;
    this.patchState({
      controlling,
      spying: false
    });
  }
  onToggleSilence() {
    this.patchState({
      silencing: !this.state.silencing
    });
  }
  onToggleSpy(remoteId) {
    const spying = this.state.spying === remoteId ? null : remoteId;
    this.patchState({
      spying,
      controlling: false
    });
  }
  addLike() {
    this.view.liked = true; // view.liked;
    this.showLove(this.view);
  }
  showLove(view) {
    if (view && this.view.id === view.id) {
      const skipTimeout = this.view.showLove;
      this.view.likes = view.likes;
      this.view.showLove = true;
      this.pushChanges();
      if (!skipTimeout) {
        setTimeout(() => {
          this.view.showLove = false;
          this.pushChanges();
        }, 3100);
      }
    }
  }
  disconnect() {}
}
LayoutComponent.meta = {
  selector: '[layout-component]',
  hosts: {
    host: RouterOutletStructure
  },
  template: /* html */`
	<div class="page page--agora">
		${CHUNK_BACKGROUND}
		<!-- Status Checklist -->
		<div class="ui ui--info ui--info-centered" *if="state.status == 'checklist'" [agora-checklist] (checked)="onChecked($event)"></div>
		<!-- Status Link -->
		<div class="ui ui--info ui--info-centered" *if="state.status == 'link'" [agora-link] (link)="onLink($event)"></div>
		<!-- Status Login -->
		<div class="ui ui--info ui--info-centered" *if="state.status == 'login'" [agora-login] (login)="onLogin($event)"></div>
		<!-- Status Name -->
		<div class="ui ui--info ui--info-centered" *if="state.status == 'name' || (state.status == 'disconnected' && state.role === 'viewer')" [agora-name] (name)="onName($event)"></div>
		<!-- Status Device -->
		<div class="ui ui--info" *if="state.status == 'device' || (state.status == 'disconnected' && state.role !== 'viewer')" [agora-device] (enter)="onEnter($event)"></div>
		<!-- Virtual Tour -->
		<div class="ui virtual-tour" [class]="uiClass" *if="state.status == 'connected' && isVirtualTourUser">
			<!-- world -->
			<div class="ui__body">
				<div class="world"></div>
			</div>
			<!-- remote sidebar -->
			<div class="group--remote" [class]="remoteClass" *if="state.live">
				<div class="agora-stream" *for="let remote of remotes">
					<div class="agora-stream__player"></div>
					<div class="agora-stream__info" [class]="{ spyed: state.spying == remote.streamId, controlling: state.controlling == remote.streamId }">
						<svg class="cam-muted" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#cam-muted"></use></svg>
						<svg class="mic-muted" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#mic-muted"></use></svg>
						<div class="id">name</div>
						<button type="button" class="btn--control" [title]="'title_control' | label" (click)="onToggleControl(remote.streamId)" *if="state.role === 'publisher'">
							<svg class="control" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#control"></use></svg>
						</button>
						<button type="button" class="btn--spy" [title]="'title_spy' | label" (click)="onToggleSpy(remote.streamId)" *if="state.role === 'publisher'">
							<svg class="spy" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#spy"></use></svg>
						</button>
					</div>
				</div>
				<div class="group--members" *if="state.mode == 'virtual-tour'">
					<div class="members" *if="state.role === 'publisher'">
						<svg class="spy" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#users"></use></svg>
						<span class="members__count" [innerHTML]="state.membersCount"></span>
					</div>
					<div class="credits">
						<a class="btn--credits" href="https://www.websolute.com/" target="_blank" rel="noopener">
							<svg viewBox="0 0 270 98"><use xlink:href="#b-here"></use></svg>
						</a>
					</div>
				</div>
			</div>
			<!-- remote screen -->
			<div class="group--remote-screen" *if="remoteScreen">
				<div class="agora-stream">
					<div class="agora-stream__player"></div>
					<div class="agora-stream__info">
						<div class="id">name</div>
					</div>
				</div>
			</div>
			<div class="group--header">
				<!-- service -->
				<div class="group--service">
					<button type="button" class="btn--back" [title]="'title_back' | label" (click)="onBack($event)" *if="isBackButtonVisible">
						<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#arrow-prev"></use></svg>
					</button>
					<button type="button" class="btn--view-mode" [title]="'title_view_mode' | label" (click)="toggleMode($event)" *if="state.mode != 'embed'">
						<svg width="24" height="24" viewBox="0 0 24 24" *if="state.mode == 'virtual-tour'"><use xlink:href="#live-meeting"></use></svg>
						<svg width="24" height="24" viewBox="0 0 24 24" *if="state.mode == 'live-meeting'"><use xlink:href="#virtual-tour"></use></svg>
					</button>
					<button type="button" class="btn--volume" [title]="'title_volume' | label" [class]="{ muted: state.volumeMuted }" (click)="toggleVolume($event)">
						<svg width="24" height="24" viewBox="0 0 24 24" *if="!state.volumeMuted"><use xlink:href="#volume-on"></use></svg>
						<svg width="24" height="24" viewBox="0 0 24 24" *if="state.volumeMuted"><use xlink:href="#volume-off"></use></svg>
					</button>
					<button type="button" class="btn--fullscreen" [title]="'title_fullscreen' | label" [class]="{ muted: state.fullScreen }" (click)="toggleFullScreen($event)">
						<svg width="24" height="24" viewBox="0 0 24 24" *if="!state.fullScreen"><use xlink:href="#fullscreen-on"></use></svg>
						<svg width="24" height="24" viewBox="0 0 24 24" *if="state.fullScreen"><use xlink:href="#fullscreen-off"></use></svg>
					</button>
					<button type="button" class="btn--navmap" [title]="'title_navmap' | label" [class]="{ active: state.showNavmap }" (click)="toggleNavmap($event)" *if="navmap && state.mode != 'live-meeting'">
						<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#navmap"></use></svg>
					</button>
				</div>
				<!-- local streams -->
				<div class="group--local" [class]="{ publisher: state.role == 'publisher', viewer: state.role == 'viewer' }" *if="state.live">
					<button type="button" class="btn--silence" [title]="'title_silence' | label" [class]="{ active: state.silencing }" (click)="onToggleSilence()" *if="state.role === 'publisher'">
						<svg class="mic-muted" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#mic-muted"></use></svg>
					</button>
					<button type="button" class="btn--control" [title]="'title_control' | label" [class]="{ active: state.controlling == state.uid }" (click)="onToggleControl(state.uid)" *if="state.role == 'publisher'">
						<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#control"></use></svg>
					</button>
					<div class="agora-stream" *if="!local"></div>
					<div class="agora-stream" *if="local">
						<div class="agora-stream__player"></div>
						<div class="agora-stream__info">
							<svg class="cam-muted" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#cam-muted"></use></svg>
							<svg class="mic-muted" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#mic-muted"></use></svg>
						</div>
					</div>
					<div class="agora-stream agora-stream--screen" *if="screen">
						<div class="agora-stream__player"></div>
					</div>
				</div>
			</div>
			<div class="group--footer">
				${CHUNK_CONTROLS}
				${CHUNK_MEDIA}
				${CHUNK_AR_VR}
				${CHUNK_LIKE}
			</div>
			<!-- members -->
			<div class="group--members" *if="state.mode == 'live-meeting'">
				<div class="members" *if="state.role === 'publisher'">
					<svg class="spy" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#users"></use></svg>
					<span class="members__count" [innerHTML]="state.membersCount"></span>
				</div>
				<div class="credits">
					<a class="btn--credits" href="https://www.websolute.com/" target="_blank" rel="noopener">
						<svg viewBox="0 0 270 98"><use xlink:href="#b-here"></use></svg>
					</a>
				</div>
			</div>
			${CHUNK_CHAT}
			${CHUNK_LOCK}
			${CHUNK_NAVMAP}
		</div>
		<!-- Smart Device -->
		<div class="ui remotes" [class]="uiClass" *if="state.status == 'connected' && state.role == 'smart-device'">
			<!-- world -->
			<div class="ui__body">
			</div>
			<!-- remote sidebar -->
			<div class="group--remote" [class]="remoteClass" *if="state.live">
				<div class="agora-stream" *for="let remote of remotes">
					<div class="agora-stream__player"></div>
					<div class="agora-stream__info">
						<svg class="cam-muted" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#cam-muted"></use></svg>
						<svg class="mic-muted" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#mic-muted"></use></svg>
						<div class="id">name</div>
						<button type="button" class="btn--spy" [title]="'title_spy' | label" *if="state.role === 'publisher'" (click)="onToggleSpy(remote.streamId)">
							<svg class="spy" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#spy"></use></svg>
						</button>
					</div>
				</div>
			</div>
			<!-- remote screen -->
			<div class="group--remote-screen" *if="remoteScreen">
				<div class="agora-stream">
					<div class="agora-stream__player"></div>
					<div class="agora-stream__info">
						<div class="id">name</div>
					</div>
				</div>
			</div>
			<!-- local streams -->
			<div class="group--local" [class]="{ publisher: state.role == 'publisher', viewer: state.role == 'viewer' }" *if="state.live">
				<div class="agora-stream" *if="local">
					<div class="agora-stream__player"></div>
					<div class="agora-stream__info">
						<svg class="cam-muted" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#cam-muted"></use></svg>
						<svg class="mic-muted" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#mic-muted"></use></svg>
					</div>
				</div>
			</div>
			<!-- controls -->
			<div class="group--controls" *if="state.live">
				<div class="group--actions">
					<button type="button" class="btn--call" [title]="'title_disconnect' | label" (click)="disconnect()">
						<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#call"></use></svg>
					</button>
					<button type="button" class="btn--cam" [title]="'title_mute_camera' | label" [class]="{ muted: state.cameraMuted, disabled: !local }" (click)="toggleCamera()">
						<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#cam"></use></svg>
					</button>
					<button type="button" class="btn--mic" [title]="'title_mute_mic' | label" [class]="{ muted: state.audioMuted, disabled: !local || silenced }" (click)="toggleAudio()">
						<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#mic"></use></svg>
					</button>
					<button type="button" class="btn--screen" [title]="'title_share_screen' | label" [class]="{ active: screen }" (click)="toggleScreen()" *if="('screenShare' | flag) && (state.role == 'publisher' || state.role == 'attendee' || controlling)">
						<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#screen"></use></svg>
					</button>
					<button type="button" class="btn--chat" [title]="'title_chat' | label" [class]="{ active: state.chatDirty }" (click)="toggleChat()" *if="('chat' | flag)">
						<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#chat"></use></svg>
					</button>
					<button type="button" class="btn--navinfo" [title]="'title_navinfo' | label" [class]="{ active: state.showNavInfo }" (click)="toggleNavInfo()" *if="showNavInfoToggler">
						<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#navinfo"></use></svg>
					</button>
				</div>
			</div>
			<!-- members -->
			<div class="group--members">
				<div class="members" *if="state.role === 'publisher'">
					<svg class="spy" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#users"></use></svg>
					<span class="members__count" [innerHTML]="state.membersCount"></span>
				</div>
				<div class="credits">
					<a class="btn--credits" href="https://www.websolute.com/" target="_blank" rel="noopener">
						<svg viewBox="0 0 270 98"><use xlink:href="#b-here"></use></svg>
					</a>
				</div>
			</div>
		</div>
		<!-- Self Service Tour -->
		<div class="ui" [class]="uiClass" *if="state.status == 'connected' && state.mode == 'self-service-tour'">
			<!-- world -->
			<div class="ui__body">
				<div class="world"></div>
			</div>
			<!-- service -->
			<div class="group--service">
				<button type="button" class="btn--volume" [title]="'title_volume' | label" [class]="{ muted: state.volumeMuted }" (click)="toggleVolume($event)">
					<svg width="24" height="24" viewBox="0 0 24 24" *if="!state.volumeMuted"><use xlink:href="#volume-on"></use></svg>
					<svg width="24" height="24" viewBox="0 0 24 24" *if="state.volumeMuted"><use xlink:href="#volume-off"></use></svg>
				</button>
				<button type="button" class="btn--fullscreen" [title]="'title_fullscreen' | label" [class]="{ muted: state.fullScreen }" (click)="toggleFullScreen($event)">
					<svg width="24" height="24" viewBox="0 0 24 24" *if="!state.fullScreen"><use xlink:href="#fullscreen-on"></use></svg>
					<svg width="24" height="24" viewBox="0 0 24 24" *if="state.fullScreen"><use xlink:href="#fullscreen-off"></use></svg>
				</button>
			</div>
			${CHUNK_AR_VR}
			${CHUNK_LIKE}
		</div>
		<!-- Embed -->
		<div class="ui" [class]="uiClass" *if="state.status == 'connected' && state.mode == 'embed'">
			<!-- world -->
			<div class="ui__body">
				<div class="world"></div>
			</div>
			<!-- service -->
			<div class="group--service">
				<button type="button" class="btn--volume" [title]="'title_volume' | label" [class]="{ muted: state.volumeMuted }" (click)="toggleVolume($event)">
					<svg width="24" height="24" viewBox="0 0 24 24" *if="!state.volumeMuted"><use xlink:href="#volume-on"></use></svg>
					<svg width="24" height="24" viewBox="0 0 24 24" *if="state.volumeMuted"><use xlink:href="#volume-off"></use></svg>
				</button>
				<button type="button" class="btn--fullscreen" [title]="'title_fullscreen' | label" [class]="{ muted: state.fullScreen }" (click)="toggleFullScreen($event)">
					<svg width="24" height="24" viewBox="0 0 24 24" *if="!state.fullScreen"><use xlink:href="#fullscreen-on"></use></svg>
					<svg width="24" height="24" viewBox="0 0 24 24" *if="state.fullScreen"><use xlink:href="#fullscreen-off"></use></svg>
				</button>
			</div>
			${CHUNK_AR_VR}
			${CHUNK_LIKE}
		</div>
		<a class="btn--logo" [routerLink]="':lang.access' | route" *if="state.status != 'connected'">
			<img [src]="'logo' | env" *if="'logo' | env" />
			<svg viewBox="0 0 270 98" *if="!('logo' | env)"><use xlink:href="#b-here"></use></svg>
		</a>
		<a class="btn--credits" href="https://www.websolute.com/" target="_blank" rel="noopener" *if="state.status != 'connected'">
			<svg viewBox="0 0 270 98"><use xlink:href="#b-here"></use></svg>
		</a>
		<div class="group--language" language *if="state.status != 'connected'"></div>
	</div>
	`
};class TryInARComponent extends rxcomp.Component {
  get viewId() {
    const viewId = this.route ? this.route.params.viewId : undefined;
    return viewId ? parseInt(viewId) : null;
  }
  onInit() {
    this.platform = DeviceService.platform;
    this.route = this.host ? this.host.route : null;
    this.missingAr = false;
    this.missingUsdz = false;
    this.missingGltf = false;
    const viewId = this.viewId;
    // console.log('TryInARComponent.viewId', viewId);
    if (viewId) {
      ViewService.viewById$(viewId).pipe(operators.first()).subscribe(view => {
        if (!view.ar) {
          this.missingAr = true;
          this.pushChanges();
          return;
        }
        // console.log('TryInARComponent.view', view);
        if (this.platform === DevicePlatform.IOS) {
          const usdzSrc = this.getUsdzSrc(view);
          if (usdzSrc) {
            window.location.href = usdzSrc;
          } else {
            this.missingUsdz = true;
            this.pushChanges();
          }
        } else if (this.getGltfSrc(view) !== null) {
          const modelViewerNode = this.getModelViewerNode(view);
          const {
            node
          } = rxcomp.getContext(this);
          node.appendChild(modelViewerNode);
          this.addARScripts();
        } else {
          this.missingGltf = true;
          this.pushChanges();
        }
      });
    }
  }
  addARScripts() {
    let script = document.createElement('script');
    script.setAttribute('type', 'module');
    script.setAttribute('src', 'https://unpkg.com/@google/model-viewer/dist/model-viewer.min.js');
    document.head.appendChild(script);
    script = document.createElement('script');
    script.setAttribute('nomodule', '');
    script.setAttribute('src', 'https://unpkg.com/@google/model-viewer/dist/model-viewer-legacy.js');
    document.head.appendChild(script);
  }
  getUsdzSrc(view) {
    return view.ar && view.ar.usdz ? environment.getPath(view.ar.usdz.folder + view.ar.usdz.file) : null;
  }
  getGltfSrc(view) {
    return view.ar && view.ar.gltf ? environment.getPath(view.ar.gltf.folder + view.ar.gltf.file) : null;
  }
  getViewId() {
    const meetingUrl = new MeetingUrl();
    let viewId = null;
    if (meetingUrl.viewId) {
      viewId = parseInt(meetingUrl.viewId);
    }
    return viewId;
  }
  getModelViewerNode(view) {
    const environmentImage = environment.getPath(environment.textures.envMap);
    const skyboxImage = environment.getPath(view.asset.folder + view.asset.file);
    const usdzSrc = this.getUsdzSrc(view);
    const gltfSrc = this.getGltfSrc(view);
    const template = /* html */`
			<model-viewer alt="${view.name}" environment-image="${environmentImage}" skybox-image="${skyboxImage}" ios-src="${usdzSrc}" src="${gltfSrc}" ar ar-modes="webxr scene-viewer quick-look" ar-scale="auto" camera-controls></model-viewer>
		`;
    const div = document.createElement('div');
    div.innerHTML = template;
    const node = div.firstElementChild;
    return node;
  }
}
TryInARComponent.meta = {
  selector: '[try-in-ar]',
  hosts: {
    host: RouterOutletStructure
  },
  template: /* html */`
		<div class="page page--try-in-ar">
			<!--
			<div *if="platform != 'ios'">
				<script type="module" src="https://unpkg.com/@google/model-viewer/dist/model-viewer.min.js"></script>
				<script nomodule src="https://unpkg.com/@google/model-viewer/dist/model-viewer-legacy.js"></script>
			</div>
			-->
			<div class="ui" *if="!viewId">
				<div class="group--info">
					<div class="group--info__content">
						<div class="info">Not found.</div>
					</div>
				</div>
			</div>
			<div class="ui" *if="missingAr">
				<div class="group--info">
					<div class="group--info__content">
						<div class="info">Missing AR in view.</div>
					</div>
				</div>
			</div>
			<div class="ui" *if="missingUsdz">
				<div class="group--info">
					<div class="group--info__content">
						<div class="info">Missing .usdz in ar.</div>
					</div>
				</div>
			</div>
			<div class="ui" *if="missingGltf">
				<div class="group--info">
					<div class="group--info__content">
						<div class="info">Missing .gltf in ar.</div>
					</div>
				</div>
			</div>
		</div>
	`
};console.log('environment.defaultLanguage', environment.defaultLanguage);
const AppRoutesInit = () => [{
  name: 'index',
  path: '/',
  forwardTo: environment.defaultLanguage || 'it'
},
// it
{
  name: 'it',
  path: '/it',
  defaultParams: {
    lang: 'it',
    mode: 'access'
  },
  factory: AccessComponent
}, {
  name: 'it.access',
  path: '/accesso',
  defaultParams: {
    lang: 'it',
    mode: 'access'
  },
  factory: AccessComponent
}, {
  name: 'it.accessCode',
  path: '/codice-di-accesso?:p&:link&:name&:role&:viewId&:pathId&:support',
  defaultParams: {
    lang: 'it',
    mode: 'accessCode'
  },
  factory: AccessCodeComponent
}, {
  name: 'it.guidedTour',
  path: '/tour-guidato?:p&:link&:name&:role&:viewId&:pathId&:support',
  defaultParams: {
    lang: 'it',
    mode: 'guidedTour'
  },
  factory: AgoraComponent
},
// { name: 'it.guidedTour', path: '/tour-guidato', defaultParams: { lang: 'it', mode: 'guidedTour' }, factory: AgoraComponent },
{
  name: 'it.selfServiceTour',
  path: '/tour-self-service?:p&:viewId&:pathId',
  defaultParams: {
    lang: 'it',
    mode: 'selfServiceTour'
  },
  factory: AgoraComponent
}, {
  name: 'it.embed',
  path: '/embed',
  defaultParams: {
    lang: 'it',
    mode: 'embed'
  },
  factory: AgoraComponent
}, {
  name: 'it.tryInAr',
  path: '/prova-in-ar?:p&:viewId',
  defaultParams: {
    lang: 'it',
    mode: 'tryInAr'
  },
  factory: TryInARComponent
}, {
  name: 'it.editor',
  path: '/editor?:p&:viewId',
  defaultParams: {
    lang: 'it',
    mode: 'editor'
  },
  factory: EditorComponent
}, {
  name: 'it.layout',
  path: '/layout',
  defaultParams: {
    lang: 'it',
    mode: 'layout'
  },
  factory: LayoutComponent
}, {
  name: 'it.privacy',
  path: '/informativa-sulla-privacy',
  defaultParams: {
    lang: 'it',
    mode: 'privacy_policy'
  },
  factory: GenericComponent
}, {
  name: 'it.terms',
  path: '/termini-di-utilizzo',
  defaultParams: {
    lang: 'it',
    mode: 'terms'
  },
  factory: GenericComponent
},
// en
{
  name: 'en',
  path: '/en',
  defaultParams: {
    lang: 'en',
    mode: 'access'
  },
  factory: AccessComponent
}, {
  name: 'en.access',
  path: '/access',
  defaultParams: {
    lang: 'en',
    mode: 'access'
  },
  factory: AccessComponent
}, {
  name: 'en.accessCode',
  path: '/accesso-code?:p&:link&:name&:role&:viewId&:pathId&:support',
  defaultParams: {
    lang: 'en',
    mode: 'accessCode'
  },
  factory: AccessCodeComponent
}, {
  name: 'en.guidedTour',
  path: '/guided-tour?:p&:link&:name&:role&:viewId&:pathId&:support',
  defaultParams: {
    lang: 'en',
    mode: 'guidedTour'
  },
  factory: AgoraComponent
},
// { name: 'en.guidedTour', path: '/guided-tour', defaultParams: { lang: 'en', mode: 'guidedTour' }, factory: AgoraComponent },
{
  name: 'en.selfServiceTour',
  path: '/self-service-tour?:p&:viewId&:pathId',
  defaultParams: {
    lang: 'en',
    mode: 'selfServiceTour'
  },
  factory: AgoraComponent
}, {
  name: 'en.embed',
  path: '/embed',
  defaultParams: {
    lang: 'en',
    mode: 'embed'
  },
  factory: AgoraComponent
}, {
  name: 'en.tryInAr',
  path: '/try-in-ar?:p&:viewId',
  defaultParams: {
    lang: 'en',
    mode: 'tryInAr'
  },
  factory: TryInARComponent
}, {
  name: 'en.editor',
  path: '/editor?:p&:viewId',
  defaultParams: {
    lang: 'en',
    mode: 'editor'
  },
  factory: EditorComponent
}, {
  name: 'en.layout',
  path: '/layout',
  defaultParams: {
    lang: 'en',
    mode: 'layout'
  },
  factory: LayoutComponent
}, {
  name: 'en.privacy',
  path: '/privacy-policy',
  defaultParams: {
    lang: 'en',
    mode: 'privacy_policy'
  },
  factory: GenericComponent
}, {
  name: 'en.terms',
  path: '/terms-of-service',
  defaultParams: {
    lang: 'en',
    mode: 'terms'
  },
  factory: GenericComponent
}];const SVG_CHUNK = /* html */`
		<svg width="0" height="0" class="hidden" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true">
			<symbol id="arrow-down" viewBox="0 0 24 24">
				<path d="M0 7.33l2.829-2.83 9.175 9.339 9.167-9.339 2.829 2.83-11.996 12.17z"></path>
			</symbol>
			<symbol id="arrow-next" viewBox="0 0 24 24">
				<path d="M7.33 24l-2.83-2.829 9.339-9.175-9.339-9.167 2.83-2.829 12.17 11.996z"></path>
			</symbol>
			<symbol id="arrow-prev" viewBox="0 0 24 24">
				<path d="M16.67 0l2.83 2.829-9.339 9.175 9.339 9.167-2.83 2.829-12.17-11.996z"></path>
			</symbol>
			<symbol id="call" viewBox="0 0 24 24">
				<path d="M20 22.621l-3.521-6.795c-.008.004-1.974.97-2.064 1.011-2.24 1.086-6.799-7.82-4.609-8.994l2.083-1.026-3.493-6.817-2.106 1.039c-7.202 3.755 4.233 25.982 11.6 22.615.121-.055 2.102-1.029 2.11-1.033z"></path>
			</symbol>
			<symbol id="heart" viewBox="0 0 24 24">
				<path d="M12 4.435c-1.989-5.399-12-4.597-12 3.568 0 4.068 3.06 9.481 12 14.997 8.94-5.516 12-10.929 12-14.997 0-8.118-10-8.999-12-3.568z"></path>
			</symbol>
			<symbol id="heart-outline" viewBox="0 0 24 24">
				<path d="M12 9.229c.234-1.12 1.547-6.229 5.382-6.229 2.22 0 4.618 1.551 4.618 5.003 0 3.907-3.627 8.47-10 12.629-6.373-4.159-10-8.722-10-12.629 0-3.484 2.369-5.005 4.577-5.005 3.923 0 5.145 5.126 5.423 6.231zm-12-1.226c0 4.068 3.06 9.481 12 14.997 8.94-5.516 12-10.929 12-14.997 0-7.962-9.648-9.028-12-3.737-2.338-5.262-12-4.27-12 3.737z"/>
			</symbol>
			<symbol id="cam" viewBox="0 0 24 24">
				<path d="M16 18c0 1.104-.896 2-2 2h-12c-1.105 0-2-.896-2-2v-12c0-1.104.895-2 2-2h12c1.104 0 2 .896 2 2v12zm8-14l-6 6.223v3.554l6 6.223v-16z"></path>
			</symbol>
			<symbol id="cam-muted" viewBox="0 0 24 24">
				<path d="M0.7,19.5L15.5,4.7C15.1,4.3,14.6,4,14,4H2C0.9,4,0,4.9,0,6v12C0,18.6,0.3,19.1,0.7,19.5z"></path>
				<path d="M18 13.8L24 20 24 4 18 10.2z"></path>
				<path d="M7.8,20H14c1.1,0,2-0.9,2-2v-6.2L7.8,20z"></path>
				<path d="M-3.4 11.2H27.400000000000002V12.7H-3.4z" transform="rotate(-45.001 12 12)"></path>
			</symbol>
			<symbol id="mic" viewBox="0 0 24 24">
				<path d="M16 11c0 2.209-1.791 4-4 4s-4-1.791-4-4v-7c0-2.209 1.791-4 4-4s4 1.791 4 4v7zm4-2v2c0 4.418-3.582 8-8 8s-8-3.582-8-8v-2h2v2c0 3.309 2.691 6 6 6s6-2.691 6-6v-2h2zm-7 13v-2h-2v2h-4v2h10v-2h-4z"></path>
			</symbol>
			<symbol id="mic-muted" viewBox="0 0 24 24">
				<path d="M16,11.4L12.4,15C14.3,14.8,15.8,13.3,16,11.4z"></path>
				<path d="M16,4.6V4c0-2.2-1.8-4-4-4S8,1.8,8,4v7c0,0.5,0.1,0.9,0.3,1.4L16,4.6z"></path>
				<path d="M13 20L11 20 11 22 7 22 7 24 17 24 17 22 13 22z"></path>
				<path d="M18,11c0,3.3-2.7,6-6,6c-0.5,0-1-0.1-1.4-0.2L9,18.4c0.9,0.4,2,0.6,3,0.6c4.4,0,8-3.6,8-8V9h-2V11z"></path>
				<path d="M6.7,13.9C6.3,13,6,12,6,11V9H4v2c0,1.6,0.5,3.1,1.3,4.3L6.7,13.9z"></path>
				<path d="M-3.4 11.2H27.400000000000002V12.7H-3.4z" transform="rotate(-45.001 12 12)"></path>
			</symbol>
			<symbol id="gamepad" viewBox="0 0 24 24">
				<path d="M17.622 3c-1.913 0-2.558 1.382-5.623 1.382-3.009 0-3.746-1.382-5.623-1.382-5.209 0-6.376 10.375-6.376 14.348 0 2.145.817 3.652 2.469 3.652 3.458 0 2.926-5 6.915-5h5.23c3.989 0 3.457 5 6.915 5 1.652 0 2.471-1.506 2.471-3.651 0-3.973-1.169-14.349-6.378-14.349zm-10.622 10c-1.657 0-3-1.343-3-3s1.343-3 3-3 3 1.343 3 3-1.343 3-3 3zm10-6c.552 0 1 .447 1 1 0 .553-.448 1-1 1s-1-.447-1-1c0-.553.448-1 1-1zm-2 4c-.552 0-1-.447-1-1 0-.553.448-1 1-1s1 .447 1 1c0 .553-.448 1-1 1zm2 2c-.552 0-1-.447-1-1 0-.553.448-1 1-1s1 .447 1 1c0 .553-.448 1-1 1zm2-2c-.552 0-1-.447-1-1 0-.553.448-1 1-1s1 .447 1 1c0 .553-.448 1-1 1zm-10.25-1c0 .965-.785 1.75-1.75 1.75s-1.75-.785-1.75-1.75.785-1.75 1.75-1.75 1.75.785 1.75 1.75z"></path>
			</symbol>
			<symbol id="ar" viewBox="0 0 24 24">
				<path d="M12 0l-11 6v12.131l11 5.869 11-5.869v-12.066l-11-6.065zm7.91 6.646l-7.905 4.218-7.872-4.294 7.862-4.289 7.915 4.365zm-16.91 1.584l8 4.363v8.607l-8-4.268v-8.702zm10 12.97v-8.6l8-4.269v8.6l-8 4.269zm6.678-5.315c.007.332-.256.605-.588.612-.332.007-.604-.256-.611-.588-.006-.331.256-.605.588-.612.331-.007.605.256.611.588zm-2.71-1.677c-.332.006-.595.28-.588.611.006.332.279.595.611.588s.594-.28.588-.612c-.007-.331-.279-.594-.611-.587zm-2.132-1.095c-.332.007-.595.281-.588.612.006.332.279.594.611.588.332-.007.594-.28.588-.612-.007-.331-.279-.594-.611-.588zm-9.902 2.183c.332.007.594.281.588.612-.007.332-.279.595-.611.588-.332-.006-.595-.28-.588-.612.005-.331.279-.594.611-.588zm1.487-.5c-.006.332.256.605.588.612s.605-.257.611-.588c.007-.332-.256-.605-.588-.611-.332-.008-.604.255-.611.587zm2.132-1.094c-.006.332.256.605.588.612.332.006.605-.256.611-.588.007-.332-.256-.605-.588-.612-.332-.007-.604.256-.611.588zm3.447-5.749c-.331 0-.6.269-.6.6s.269.6.6.6.6-.269.6-.6-.269-.6-.6-.6zm0-2.225c-.331 0-.6.269-.6.6s.269.6.6.6.6-.269.6-.6-.269-.6-.6-.6zm0-2.031c-.331 0-.6.269-.6.6s.269.6.6.6.6-.269.6-.6-.269-.6-.6-.6z"></path>
			</symbol>
			<symbol id="close" viewBox="0 0 24 24">
				<path d="M23 20.168l-8.185-8.187 8.185-8.174-2.832-2.807-8.182 8.179-8.176-8.179-2.81 2.81 8.186 8.196-8.186 8.184 2.81 2.81 8.203-8.192 8.18 8.192z"></path>
			</symbol>
			<symbol id="vr" viewBox="0 0 24 24">
				<path d="M22.3,4.3H1.7C0.8,4.3,0,5.1,0,6v12c0,0.9,0.8,1.7,1.7,1.7h5.6c0.7,0,1.4-0.5,1.6-1.2l1.4-4.2c0.5-1.6,2.7-1.6,3.3,0 l1.4,4.2c0.2,0.7,0.9,1.2,1.6,1.2h5.6c0.9,0,1.7-0.8,1.7-1.7V6C24,5.1,23.2,4.3,22.3,4.3z M6,14.6c-1.4,0-2.6-1.2-2.6-2.6 S4.6,9.4,6,9.4s2.6,1.2,2.6,2.6S7.4,14.6,6,14.6z M18,14.6c-1.4,0-2.6-1.2-2.6-2.6s1.2-2.6,2.6-2.6s2.6,1.2,2.6,2.6 S19.4,14.6,18,14.6z"></path>
			</symbol>
			<symbol id="vr-02" viewBox="0 0 24 24">
				<path d="M22.5,8.6c-0.3,0-0.6,0.1-0.8,0.3c-0.3-1.9-1.9-3.4-3.9-3.4H6.2c-2,0-3.6,1.5-3.9,3.4C2,8.7,1.7,8.6,1.4,8.6 C0.6,8.6,0,9.3,0,10.1v3.9c0,0.8,0.6,1.4,1.4,1.4c0.3,0,0.6-0.1,0.8-0.3c0.3,1.9,1.9,3.4,3.9,3.4h11.6c2,0,3.6-1.5,3.9-3.4 c0.2,0.2,0.5,0.3,0.8,0.3c0.8,0,1.4-0.6,1.4-1.4v-3.9C24,9.3,23.3,8.6,22.5,8.6z M20.7,14.6c0,1.6-1.3,2.8-2.8,2.8H6.2 c-1.6,0-2.8-1.3-2.8-2.8V9.4c0-1.6,1.3-2.8,2.8-2.8h11.6c1.6,0,2.8,1.3,2.8,2.8V14.6z"></path><circle cx="5.7" cy="8.7" r=".8"></circle><circle cx="18.3" cy="8.6" r=".8"></circle><circle cx="5.7" cy="15.4" r=".8"></circle><circle cx="18.3" cy="15.3" r=".8"></circle>
			</symbol>
			<symbol id="the-spy" viewBox="0 0 24 24">
				<path d="M17,14c-1.8,0-3.3,1.3-3.7,3h-2.5c-0.5-2.1-2.5-3.4-4.6-2.9c-2.1,0.5-3.4,2.5-2.9,4.6s2.5,3.4,4.6,2.9 c1.4-0.3,2.6-1.5,2.9-2.9h2.5c0.5,2.1,2.5,3.4,4.6,2.9s3.4-2.5,2.9-4.6C20.4,15.3,18.8,14,17,14z"></path>
				<path d="M23.2,11.5h-2.6V6c0-0.7-0.5-1.4-1.2-1.6l-5.5-1.8c-1.2-0.4-2.6-0.4-3.8,0L4.6,4.4C3.9,4.6,3.4,5.3,3.4,6v5.4H0.8 c-0.5,0-0.8,0.4-0.8,0.8s0.4,0.8,0.8,0.8h22.3c0.5,0,0.8-0.4,0.8-0.8S23.6,11.5,23.2,11.5z"></path>
			</symbol>
			<symbol id="spy-eye" viewBox="0 0 24 24">
				<path d="M12,19.6c-4.6,0-8.9-3.5-11.7-6.8c-0.4-0.5-0.4-1.2,0-1.6C3.1,7.9,7.4,4.4,12,4.4s8.9,3.5,11.7,6.8 c0.4,0.5,0.4,1.2,0,1.6C20.9,16.1,16.6,19.6,12,19.6z M12,7.5c2.5,0,4.4,1.9,4.4,4.4s-1.9,4.4-4.4,4.4s-4.4-1.9-4.4-4.4 S9.5,7.5,12,7.5z" clip-rule="evenodd"></path>
				<path d="M12,9.3c1.4,0,2.6,1.2,2.6,2.6s-1.2,2.6-2.6,2.6s-2.6-1.2-2.6-2.6S10.6,9.3,12,9.3z" fill-rule="evenodd" ></path>
			</symbol>
			<symbol id="copy" viewBox="0 0 24 24">
				<path d="M7 16h10v1h-10v-1zm0-1h10v-1h-10v1zm15-13v22h-20v-22h3c1.229 0 2.18-1.084 3-2h8c.82.916 1.771 2 3 2h3zm-11 1c0 .552.448 1 1 1s1-.448 1-1-.448-1-1-1-1 .448-1 1zm9 1h-4l-2 2h-3.898l-2.102-2h-4v18h16v-18zm-13 9h10v-1h-10v1zm0-2h10v-1h-10v1z"></path>
			</symbol>
			<symbol id="menu" viewBox="0 0 24 24">
				<path d="M12 18c1.657 0 3 1.343 3 3s-1.343 3-3 3-3-1.343-3-3 1.343-3 3-3zm0-9c1.657 0 3 1.343 3 3s-1.343 3-3 3-3-1.343-3-3 1.343-3 3-3zm0-9c1.657 0 3 1.343 3 3s-1.343 3-3 3-3-1.343-3-3 1.343-3 3-3z"></path>
			</symbol>
			<symbol id="menu-light" viewBox="0 0 24 24">
				<path d="M14 19h-14v-1h14v1zm9.247-8.609l-3.247 4.049-3.263-4.062-.737.622 4 5 4-5-.753-.609zm-9.247 2.609h-14v-1h14v1zm0-6h-14v-1h14v1z"/>
			</symbol>
			<symbol id="settings" viewBox="0 0 24 24">
				<path d="M24 14.187v-4.374c-2.148-.766-2.726-.802-3.027-1.529-.303-.729.083-1.169 1.059-3.223l-3.093-3.093c-2.026.963-2.488 1.364-3.224 1.059-.727-.302-.768-.889-1.527-3.027h-4.375c-.764 2.144-.8 2.725-1.529 3.027-.752.313-1.203-.1-3.223-1.059l-3.093 3.093c.977 2.055 1.362 2.493 1.059 3.224-.302.727-.881.764-3.027 1.528v4.375c2.139.76 2.725.8 3.027 1.528.304.734-.081 1.167-1.059 3.223l3.093 3.093c1.999-.95 2.47-1.373 3.223-1.059.728.302.764.88 1.529 3.027h4.374c.758-2.131.799-2.723 1.537-3.031.745-.308 1.186.099 3.215 1.062l3.093-3.093c-.975-2.05-1.362-2.492-1.059-3.223.3-.726.88-.763 3.027-1.528zm-4.875.764c-.577 1.394-.068 2.458.488 3.578l-1.084 1.084c-1.093-.543-2.161-1.076-3.573-.49-1.396.581-1.79 1.693-2.188 2.877h-1.534c-.398-1.185-.791-2.297-2.183-2.875-1.419-.588-2.507-.045-3.579.488l-1.083-1.084c.557-1.118 1.066-2.18.487-3.58-.579-1.391-1.691-1.784-2.876-2.182v-1.533c1.185-.398 2.297-.791 2.875-2.184.578-1.394.068-2.459-.488-3.579l1.084-1.084c1.082.538 2.162 1.077 3.58.488 1.392-.577 1.785-1.69 2.183-2.875h1.534c.398 1.185.792 2.297 2.184 2.875 1.419.588 2.506.045 3.579-.488l1.084 1.084c-.556 1.121-1.065 2.187-.488 3.58.577 1.391 1.689 1.784 2.875 2.183v1.534c-1.188.398-2.302.791-2.877 2.183zm-7.125-5.951c1.654 0 3 1.346 3 3s-1.346 3-3 3-3-1.346-3-3 1.346-3 3-3zm0-2c-2.762 0-5 2.238-5 5s2.238 5 5 5 5-2.238 5-5-2.238-5-5-5z"/>
			</symbol>
			<symbol id="settings-full" viewBox="0 0 24 24">
				<path d="M24 13.616v-3.232l-2.869-1.02c-.198-.687-.472-1.342-.811-1.955l1.308-2.751-2.285-2.285-2.751 1.307c-.613-.339-1.269-.613-1.955-.811l-1.021-2.869h-3.232l-1.021 2.869c-.686.198-1.342.471-1.955.811l-2.751-1.308-2.285 2.285 1.308 2.752c-.339.613-.614 1.268-.811 1.955l-2.869 1.02v3.232l2.869 1.02c.197.687.472 1.342.811 1.955l-1.308 2.751 2.285 2.286 2.751-1.308c.613.339 1.269.613 1.955.811l1.021 2.869h3.232l1.021-2.869c.687-.198 1.342-.472 1.955-.811l2.751 1.308 2.285-2.286-1.308-2.751c.339-.613.613-1.268.811-1.955l2.869-1.02zm-12 2.384c-2.209 0-4-1.791-4-4s1.791-4 4-4 4 1.791 4 4-1.791 4-4 4z"/>
			</symbol>
			<symbol id="emoji" viewBox="0 0 24 24">
				<path d="M12,2c5.5,0,10,4.5,10,10s-4.5,10-10,10S2,17.5,2,12S6.5,2,12,2z M12,0C5.4,0,0,5.4,0,12s5.4,12,12,12s12-5.4,12-12 S18.6,0,12,0z M18,14H6c0.3,1.5,2.8,4,6,4C15.1,18,17.7,15.5,18,14z M8.5,8C7.7,8,7,8.7,7,9.5S7.7,11,8.5,11S10,10.3,10,9.5 S9.3,8,8.5,8z M15.5,8C14.7,8,14,8.7,14,9.5s0.7,1.5,1.5,1.5c0.8,0,1.5-0.7,1.5-1.5S16.3,8,15.5,8z"/>
			</symbol>
			<symbol id="pencil" viewBox="0 0 24 24">
				<path d="M19.769 9.923l-12.642 12.639-7.127 1.438 1.438-7.128 12.641-12.64 5.69 5.691zm1.414-1.414l2.817-2.82-5.691-5.689-2.816 2.817 5.69 5.692z"/>
			</symbol>
			<symbol id="erase" viewBox="0 0 24 24">
				<path d="M5.662 23l-5.369-5.365c-.195-.195-.293-.45-.293-.707 0-.256.098-.512.293-.707l14.929-14.928c.195-.194.451-.293.707-.293.255 0 .512.099.707.293l7.071 7.073c.196.195.293.451.293.708 0 .256-.097.511-.293.707l-11.216 11.219h5.514v2h-12.343zm3.657-2l-5.486-5.486-1.419 1.414 4.076 4.072h2.829zm.456-11.429l-4.528 4.528 5.658 5.659 4.527-4.53-5.657-5.657z"/>
			</symbol>
			<symbol id="move" viewBox="0 0 24 24">
				<path d="M12 10c1.104 0 2 .896 2 2s-.896 2-2 2-2-.896-2-2 .896-2 2-2zm-3.857 3c-.084-.321-.143-.652-.143-1s.059-.679.143-1h-2.143v-4l-6 5 6 5v-4h2.143zm7.714-2c.084.321.143.652.143 1s-.059.679-.143 1h2.143v4l6-5-6-5v4h-2.143zm-2.857 4.857c-.321.084-.652.143-1 .143s-.679-.059-1-.143v2.143h-4l5 6 5-6h-4v-2.143zm-2-7.714c.321-.084.652-.143 1-.143s.679.059 1 .143v-2.143h4l-5-6-5 6h4v2.143z"/>
			</symbol>
			<symbol id="caret-down" viewBox="0 0 8 5">
				<path d="M0 0h8L4 5 0 0z" fill-rule="evenodd" clip-rule="evenodd"></path>
			</symbol>
			<symbol id="caret-right" viewBox="0 0 8 12">
				<path d="M0 12V0l8 6-8 6z" fill-rule="evenodd" clip-rule="evenodd"></path>
			</symbol>
			<symbol id="websolute" viewBox="0 0 20 20">
				<path d="M20 10c0 5.5-4.5 10-10 10S0 15.5 0 10 4.5 0 10 0s10 4.5 10 10m-10 2.3c.5.5 1.3.8 2.1.8s1.5-.3 2.1-.8c.5-.5.8-1.2.8-2V7.5h-1.7v2.8c0 .3-.1.6-.4.8-.1.1-.3.2-.4.3-.2.1-.3.1-.5.1s-.3 0-.5-.1c-.1-.1-.3-.2-.4-.3-.2-.2-.4-.5-.4-.8V7.6H9.2v2.8c0 .3-.1.6-.4.9-.2.2-.5.4-.8.4-.3 0-.7-.1-.9-.3-.2-.2-.4-.5-.3-.8V7.5H5v2.8c0 .7.3 1.5.8 2 .6.5 1.3.8 2.1.8.8.1 1.6-.2 2.1-.8z" fill-rule="evenodd" clip-rule="evenodd"></path>
			</symbol>
			<symbol id="search" viewBox="0 0 21 23">
				<path d="M20.6 20.3l-4.9-5.2c1.2-1.7 1.8-3.7 1.8-5.7 0-5.2-3.9-9.4-8.7-9.4S0 4.2 0 9.4s3.7 7.8 6.3 8.4c1.8.4 3.9.6 7.1-.7l5.1 5.4c.5.6 1.4.6 2 .1l.1-.1c.5-.6.5-1.6 0-2.2zM15 9.4c-.2 3.5-3.2 6.1-6.7 5.8S2.2 12 2.5 8.5c.2-3.3 3-5.8 6.3-5.8 3.5.1 6.3 3.1 6.2 6.7z" fill-rule="evenodd" clip-rule="evenodd"></path>
			</symbol>
			<symbol id="result-indicator" viewBox="0 0 24 24">
				<path d="M11 21.883l-6.235-7.527-.765.644 7.521 9 7.479-9-.764-.645-6.236 7.529v-21.884h-1v21.883z"></path>
			</symbol>
			<symbol id="bullet" viewBox="0 0 18 18">
				<path d="M9 2c3.9 0 7 3.1 7 7s-3.1 7-7 7-7-3.1-7-7 3.1-7 7-7m0-2C4 0 0 4 0 9s4 9 9 9 9-4 9-9-4-9-9-9z" opacity=".15" fill="#17265a"></path>
				<circle cx="9" cy="9" r="4" fill="#17265a"></circle>
			</symbol>
			<symbol id="play" viewBox="0 0 16 20">
				<path d="M0,0v19.8l15.4-11L0,0z" fill-rule="evenodd" clip-rule="evenodd" ></path>
			</symbol>
			<symbol id="play-progress" viewBox="0 0 196 196">
				<path d="M195.5,98c0,53.8-43.7,97.5-97.5,97.5S0.5,151.8,0.5,98S44.2,0.5,98,0.5S195.5,44.2,195.5,98z" stroke-width="2px" stroke-linecap="square" ></path>
			</symbol>
			<symbol id="pause" viewBox="0 0 16 20">
				<path d="M0 0.9H4V18.9H0z"></path>
				<path d="M11.4 0.9H15.4V18.9H11.4z"></path>
			</symbol>
			<symbol id="wishlist-add" viewBox="0 0 25 20">
				<path d="M12.5,20.8c-0.3,0-0.5-0.1-0.8-0.3c-0.3-0.2-0.6-0.4-0.9-0.6c-0.7-0.5-1.4-0.9-2.1-1.5 c-1.1-0.8-2.1-1.6-3.1-2.4C4.2,15,3,13.8,1.9,12.4c-0.9-1.1-1.4-2.3-1.7-3.7C0.1,8.5,0.1,8.2,0,7.9l0-0.2l0.1-1.4 c0-0.1,0.1-0.3,0.1-0.4c0.1-0.3,0.1-0.7,0.3-1c0.6-1.7,1.8-3.2,3.4-4c1.5-0.8,3.3-1.1,5-0.8c1.4,0.2,2.6,0.8,3.7,1.7 c2.9-2.4,7.2-2.4,10,0.1c1.1,0.9,1.9,2.2,2.2,3.5c0.1,0.3,0.1,0.6,0.2,0.8L25,6.7l-0.1,1.4c-0.2,1.2-0.6,2.4-1.2,3.4 c-0.5,0.8-1.1,1.6-1.8,2.3c-0.8,0.9-1.7,1.7-2.6,2.5c-0.7,0.6-1.6,1.3-2.6,2c-0.8,0.5-1.5,1.1-2.3,1.6c-0.4,0.3-0.8,0.5-1.2,0.8 C13.1,20.8,12.8,20.8,12.5,20.8z M2.1,7.6c0,0.2,0.1,0.4,0.1,0.6c0.2,1.1,0.7,2,1.4,2.9c1,1.2,2.1,2.3,3.3,3.3c1,0.8,2,1.6,3,2.4 c0.7,0.5,1.4,0.9,2.1,1.4l0.5,0.3c0.2-0.2,0.5-0.3,0.7-0.5c0.8-0.5,1.5-1,2.3-1.6c0.9-0.7,1.8-1.4,2.5-1.9c0.9-0.7,1.7-1.5,2.4-2.3 c0.6-0.6,1.1-1.2,1.5-1.9c0.5-0.8,0.8-1.7,0.9-2.6c0-0.1,0-0.1,0-0.2l0-0.9c0-0.2-0.1-0.4-0.1-0.6c-0.3-1-0.8-1.9-1.6-2.5 c-2.1-1.8-5.2-1.8-7.3,0c-0.1,0.1-0.3,0.2-0.4,0.4l-0.9,1.2l-1-1.3c-0.8-0.8-1.9-1.4-3-1.6C7.2,2,5.9,2.2,4.9,2.8 c-1.1,0.6-2,1.6-2.4,2.8C2.4,5.9,2.3,6.1,2.3,6.4c0,0.1-0.1,0.3-0.1,0.4l0,0L2.1,7.6L2.1,7.6z" clip-rule="evenodd" fill-rule="evenodd" ></path>
			</symbol>
			<symbol id="wishlist-added" viewBox="0 0 25 20">
				<path d="M12.5,20.8c-0.3,0-0.5-0.1-0.8-0.3c-0.3-0.2-0.6-0.4-0.9-0.6c-0.7-0.5-1.4-0.9-2.1-1.5 c-1.1-0.8-2.1-1.6-3.1-2.4c-1.4-1-2.6-2.2-3.7-3.6C1,11.3,0.5,10.1,0.2,8.7C0.1,8.5,0.1,8.2,0,7.9V7.7l0.1-1.4 c0-0.1,0.1-0.3,0.1-0.4c0.1-0.3,0.1-0.7,0.3-1c0.6-1.7,1.8-3.2,3.4-4c1.5-0.8,3.3-1.1,5-0.8c1.4,0.2,2.6,0.8,3.7,1.7 c2.9-2.4,7.2-2.4,10,0.1c1.1,0.9,1.9,2.2,2.2,3.5C24.9,5.7,24.9,6,25,6.2v0.5l-0.1,1.4c-0.2,1.2-0.6,2.4-1.2,3.4 c-0.5,0.8-1.1,1.6-1.8,2.3c-0.8,0.9-1.7,1.7-2.6,2.5c-0.7,0.6-1.6,1.3-2.6,2c-0.8,0.5-1.5,1.1-2.3,1.6c-0.4,0.3-0.8,0.5-1.2,0.8 C13.1,20.8,12.8,20.8,12.5,20.8z" clip-rule="evenodd" fill-rule="evenodd" ></path>
			</symbol>
			<symbol id="wishlist" viewBox="0 0 16 14">
				<path d="M8,14c-0.2,0-0.3-0.1-0.5-0.2l-0.6-0.4c-0.5-0.3-0.9-0.6-1.4-1c-0.7-0.5-1.4-1.1-2-1.6 c-0.9-0.7-1.6-1.6-2.3-2.5C0.7,7.6,0.3,6.8,0.1,5.9c0-0.2-0.1-0.4-0.1-0.5l0-0.1l0-1c0-0.1,0-0.2,0.1-0.3c0.1-0.2,0.1-0.4,0.2-0.7 c0.4-1.1,1.2-2.1,2.2-2.7c1.8-1,4-0.8,5.5,0.6c1.8-1.6,4.6-1.6,6.4,0.1c0.7,0.6,1.2,1.5,1.4,2.4C15.9,3.8,15.9,4,16,4.2l0,0.3l0,0.9 c-0.1,0.8-0.4,1.6-0.8,2.3c-0.3,0.5-0.7,1-1.1,1.5c-0.5,0.6-1.1,1.1-1.7,1.7c-0.4,0.4-1,0.9-1.7,1.3c-0.5,0.4-1,0.7-1.5,1.1 c-0.2,0.2-0.5,0.3-0.7,0.5C8.4,13.9,8.2,14,8,14z M1.4,5.1c0,0.1,0.1,0.3,0.1,0.4c0.1,0.7,0.4,1.4,0.9,1.9C2.9,8.3,3.6,9,4.4,9.7 c0.6,0.5,1.3,1.1,1.9,1.6c0.4,0.3,0.9,0.6,1.3,0.9c0.1,0.1,0.2,0.2,0.3,0.2c0.2-0.1,0.3-0.2,0.5-0.3c0.5-0.3,1-0.7,1.5-1 c0.6-0.4,1.2-0.9,1.6-1.3c0.5-0.5,1.1-1,1.5-1.5c0.4-0.4,0.7-0.8,1-1.3c0.3-0.5,0.5-1.1,0.6-1.7c0,0,0-0.1,0-0.1l0-0.6 c0-0.1,0-0.3-0.1-0.4c-0.2-0.7-0.5-1.2-1-1.7c-1.3-1.2-3.4-1.2-4.7,0C8.7,2.4,8.6,2.5,8.5,2.6L8,3.4L7.3,2.5 C6.3,1.4,4.5,1.1,3.1,1.9C2.4,2.3,1.8,3,1.6,3.8C1.5,3.9,1.5,4.1,1.4,4.3L1.4,4.6l0,0L1.4,5.1L1.4,5.1z" clip-rule="evenodd" fill-rule="evenodd" ></path>
			</symbol>
			<symbol id="expand" viewBox="0 0 29 30">
				<path d="M26 16.3V5.9L2.2 29.7.1 27.6 24 3.3H13v-3h16v16h-3z" fill-rule="evenodd" clip-rule="evenodd"></path>
			</symbol>
			<symbol id="download" viewBox="0 0 9 13">
				<path d="M8.5 7.9c-.3-.4-.8-.4-1.2-.1l-.1.1-2 2V1.2c0-.2-.1-.4-.2-.6-.2-.3-.7-.3-1 0-.2.2-.3.4-.3.6v8.6l-2-2c-.2-.1-.4-.2-.7-.2-.2 0-.4.1-.6.3-.1.2-.1.4-.1.6 0 .2.1.4.2.5l3.4 3.4c.2.2.4.2.6.2.2 0 .4-.1.6-.2L8.4 9c.2-.1.2-.3.3-.6 0-.1-.1-.4-.2-.5z" fill-rule="evenodd" clip-rule="evenodd"></path>
			</symbol>
			<symbol id="upload" viewBox="0 0 24 24">
				<path d="M10 9H4l8-9 8 9h-6v11h-4V9zm11 11v2H3v-2H1v4h22v-4h-2z"></path>
			</symbol>
			<symbol id="user" viewBox="0 0 24 24">
				<path d="M20.822 18.096c-3.439-.794-6.64-1.49-5.09-4.418C20.452 4.766 16.983 0 12 0 6.918 0 3.536 4.949 8.268 13.678c1.597 2.945-1.725 3.641-5.09 4.418C.105 18.806-.01 20.332 0 23l.004 1h23.99l.004-.969c.012-2.688-.092-4.222-3.176-4.935z"></path>
			</symbol>
			<symbol id="back" viewBox="0 0 24 24">
				<path d="M2.117 12l7.527 6.235L9 19l-9-7.521L9 4l.645.764L2.116 11H24v1H2.117z" fill-rule="evenodd" clip-rule="evenodd"></path>
			</symbol>
			<symbol id="add" viewBox="0 0 24 24">
				<path d="M24 10h-10v-10h-4v10h-10v4h10v10h4v-10h10z"></path>
			</symbol>
			<symbol id="remove" viewBox="0 0 24 24">
				<path d="M0 10h24v4h-24z"></path>
			</symbol>
			<symbol id="link" viewBox="0 0 24 24">
				<path d="M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z"></path>
			</symbol>
			<symbol id="up" viewBox="0 0 24 24">
				<path d="M7 11h-6l11-11 11 11h-6v13h-10z"></path>
			</symbol>
			<symbol id="down" viewBox="0 0 24 24">
				<path d="M17,13h6L12,24L1,13h6V0h10V13z"></path>
			</symbol>
			<symbol id="waiting-room" viewBox="0 0 24 24">
				<path d="M2,6c0-2.2,1.8-4,4-4h12c2.2,0,4,1.8,4,4v12c0,2.2-1.8,4-4,4H6c-2.2,0-4-1.8-4-4V6z" opacity=".2"></path>
				<path d="M17.8,10.7c0.7,0,1.3,0.6,1.3,1.3s-0.6,1.3-1.3,1.3H6.2c-0.7,0-1.3-0.6-1.3-1.3s0.6-1.3,1.3-1.3H17.8z M19.7,12 c0-1.1-0.9-1.9-1.9-1.9H6.2c-1.1,0-1.9,0.9-1.9,1.9s0.9,1.9,1.9,1.9h11.6C18.9,13.9,19.7,13.1,19.7,12z M13.9,11.4H6.2 c-0.4,0-0.6,0.3-0.6,0.6s0.3,0.6,0.6,0.6h7.7c0.4,0,0.6-0.3,0.6-0.6S14.3,11.4,13.9,11.4z"></path>
			</symbol>
			<symbol id="panorama" viewBox="0 0 24 24">
				<path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path>
				<path d="M 9 15 C 9 14.448 9.448 14 10 14 L 14 14 C 14.552 14 15 14.448 15 15 L 15 16 C 15 16.552 14.552 17 14 17 L 10 17 C 9.448 17 9 16.552 9 16 Z" fill="var(--svg-icon-tint)" opacity="0.4"></path>
				<path d="M 7 8 C 7 7.448 7.448 7 8 7 L 16 7 C 16.552 7 17 7.448 17 8 L 17 12 C 17 12.552 16.552 13 16 13 L 8 13 C 7.448 13 7 12.552 7 12 Z" fill="var(--svg-icon-tint)"></path>
			</symbol>
			<symbol id="panorama-grid" viewBox="0 0 24 24">
				<path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path>
				<path d="M 7.333 8.333 C 7.333 7.781 7.781 7.333 8.333 7.333 L 10.333 7.333 C 10.886 7.333 11.333 7.781 11.333 8.333 L 11.333 10.333 C 11.333 10.886 10.886 11.333 10.333 11.333 L 8.333 11.333 C 7.781 11.333 7.333 10.886 7.333 10.333 Z" fill="var(--svg-icon-tint)" opacity="0.4"></path>
				<path d="M 12.333 8.333 C 12.333 7.781 12.781 7.333 13.333 7.333 L 15.333 7.333 C 15.886 7.333 16.333 7.781 16.333 8.333 L 16.333 10.333 C 16.333 10.886 15.886 11.333 15.333 11.333 L 13.333 11.333 C 12.781 11.333 12.333 10.886 12.333 10.333 Z" fill="var(--svg-icon-tint)" opacity="0.4"></path>
				<path d="M 7.333 13.667 C 7.333 13.114 7.781 12.667 8.333 12.667 L 10.333 12.667 C 10.886 12.667 11.333 13.114 11.333 13.667 L 11.333 15.667 C 11.333 16.219 10.886 16.667 10.333 16.667 L 8.333 16.667 C 7.781 16.667 7.333 16.219 7.333 15.667 Z" fill="var(--svg-icon-tint)"></path>
				<path d="M 12.333 13.667 C 12.333 13.114 12.781 12.667 13.333 12.667 L 15.333 12.667 C 15.886 12.667 16.333 13.114 16.333 13.667 L 16.333 15.667 C 16.333 16.219 15.886 16.667 15.333 16.667 L 13.333 16.667 C 12.781 16.667 12.333 16.219 12.333 15.667 Z" fill="var(--svg-icon-tint)" opacity="0.4"></path>
			</symbol>
			<symbol id="room-3d" viewBox="0 0 24 24">
				<path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path>
				<path d="M 6.6 9.056 C 6.6 8.533 6.905 8.059 7.381 7.842 L 8.995 7.108 C 9.436 6.907 9.938 7.23 9.938 7.715 L 9.938 16.272 C 9.938 16.757 9.436 17.08 8.995 16.879 L 7.381 16.145 C 6.905 15.928 6.6 15.454 6.6 14.931 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path>
				<path d="M 10.754 7.453 C 10.754 6.795 11.378 6.316 12.014 6.487 L 16.32 7.647 C 17.193 7.882 17.8 8.674 17.8 9.578 L 17.8 14.105 C 17.8 15.009 17.193 15.801 16.32 16.036 L 12.014 17.196 C 11.378 17.367 10.754 16.889 10.754 16.231 Z" fill="var(--svg-icon-tint)"></path>
			</symbol>
			<symbol id="model" viewBox="0 0 24 24">
				<path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.3"></path>
				<path d="M 11.298 7.283 C 11.602 6.729 12.398 6.729 12.702 7.283 L 14.009 9.673 C 14.082 9.807 14.193 9.918 14.327 9.991 L 16.717 11.298 C 17.271 11.602 17.271 12.398 16.717 12.702 L 14.327 14.009 C 14.193 14.082 14.082 14.193 14.009 14.327 L 12.702 16.717 C 12.398 17.271 11.602 17.271 11.298 16.717 L 9.991 14.327 C 9.918 14.193 9.807 14.082 9.673 14.009 L 7.283 12.702 C 6.729 12.398 6.729 11.602 7.283 11.298 L 9.673 9.991 C 9.807 9.918 9.918 9.807 9.991 9.673 Z" fill="var(--svg-icon-tint)"></path>
			</symbol>
			<symbol id="media" viewBox="0 0 24 24">
				<path d="M2,6c0-2.2,1.8-4,4-4h12c2.2,0,4,1.8,4,4v12c0,2.2-1.8,4-4,4H6c-2.2,0-4-1.8-4-4V6z" fill="var(--svg-icon-tint)" opacity="0.3"></path>
				<path d="M12,19c-2.2,0-4.3-1-5.6-2.7L7,15.9c1.2,1.5,3,2.4,5,2.4c1.9,0,3.8-0.9,5-2.4l0.6,0.4C16.3,18,14.2,19,12,19z M5.5,14.7C5.2,13.8,5,12.8,5,12c0-3.5,2.7-6.5,6.2-7v0.6C8,6.1,5.7,8.8,5.7,12c0,0.8,0.1,1.5,0.4,2.4L5.5,14.7z M18,14.4 c0.3-0.8,0.4-1.6,0.4-2.4c0-3.2-2.3-5.9-5.5-6.4c0-0.2,0-0.5,0-0.6c3.5,0.4,6.2,3.4,6.2,7c0,0.8-0.2,1.8-0.5,2.7L18,14.4z" fill="var(--svg-icon-tint)" opacity="0.3"></path>
				<path d="M10.2,15V8.9l5.5,3.1L10.2,15z" fill="var(--svg-icon-tint)"></path>
			</symbol>
			<symbol id="nav" viewBox="0 0 24 24">
				<path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path>
				<path d="M 6.5 8.667 C 6.5 8.114 6.948 7.667 7.5 7.667 L 16.5 7.667 C 17.052 7.667 17.5 8.114 17.5 8.667 L 17.5 14.495 C 17.5 15.046 17.053 15.494 16.502 15.495 L 14.189 15.499 C 13.959 15.5 13.736 15.58 13.558 15.725 L 12.211 16.827 C 12.088 16.928 11.912 16.928 11.789 16.827 L 10.442 15.725 C 10.264 15.58 10.041 15.5 9.811 15.499 L 7.498 15.495 C 6.947 15.494 6.5 15.046 6.5 14.495 Z" fill="var(--svg-icon-tint)"></path>
			</symbol>
			<symbol id="plane" viewBox="0 0 24 24">
				<path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path>
				<path d="M 2 1 L 1 0 L 0 1" transform="translate(4.667 11.5) rotate(-90 1 0.5)" fill="transparent" opacity="0.4" stroke="var(--svg-icon-tint)" stroke-linecap="round" stroke-linejoin="round"></path>
				<path d="M 2 1 L 1 0 L 0 1" transform="translate(17.333 11.5) rotate(90 1 0.5)" fill="transparent" opacity="0.4" stroke="var(--svg-icon-tint)" stroke-linecap="round" stroke-linejoin="round"></path>
				<path d="M 8 9 C 8 8.448 8.448 8 9 8 L 15 8 C 15.552 8 16 8.448 16 9 L 16 15 C 16 15.552 15.552 16 15 16 L 9 16 C 8.448 16 8 15.552 8 15 Z" fill="var(--svg-icon-tint)"></path>
			</symbol>
			<symbol id="curved-plane" viewBox="0 0 24 24">
				<path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path>
				<path d="M 2 1 L 1 0 L 0 1" transform="translate(4.667 11.5) rotate(-90 1 0.5)" fill="transparent" opacity="0.4" stroke="var(--svg-icon-tint)" stroke-linecap="round" stroke-linejoin="round"></path>
				<path d="M 2 1 L 1 0 L 0 1" transform="translate(17.333 11.5) rotate(90 1 0.5)" fill="transparent" opacity="0.4" stroke="var(--svg-icon-tint)" stroke-linecap="round" stroke-linejoin="round"></path>
				<path d="M 8 9 C 8 8.448 8.448 8 9 8 L 15 8 C 15.552 8 16 8.448 16 9 L 16 15 C 16 15.552 15.552 16 15 16 L 9 16 C 8.448 16 8 15.552 8 15 Z" fill="var(--svg-icon-tint)"></path>
			</symbol>
			<symbol id="texture" viewBox="0 0 24 24">
				<path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path>
				<path d="M 7.333 8.95 C 7.333 8.274 7.839 7.705 8.511 7.626 L 14.805 6.886 C 15.796 6.769 16.667 7.543 16.667 8.541 L 16.667 15.49 C 16.667 16.477 15.814 17.247 14.833 17.148 L 8.533 16.513 C 7.852 16.444 7.333 15.871 7.333 15.187 Z" fill="var(--svg-icon-tint)"></path>
			</symbol>
			<symbol id="gltf" viewBox="0 0 24 24">
				<path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.3"></path>
				<path d="M 11.298 7.283 C 11.602 6.729 12.398 6.729 12.702 7.283 L 14.009 9.673 C 14.082 9.807 14.193 9.918 14.327 9.991 L 16.717 11.298 C 17.271 11.602 17.271 12.398 16.717 12.702 L 14.327 14.009 C 14.193 14.082 14.082 14.193 14.009 14.327 L 12.702 16.717 C 12.398 17.271 11.602 17.271 11.298 16.717 L 9.991 14.327 C 9.918 14.193 9.807 14.082 9.673 14.009 L 7.283 12.702 C 6.729 12.398 6.729 11.602 7.283 11.298 L 9.673 9.991 C 9.807 9.918 9.918 9.807 9.991 9.673 Z" fill="var(--svg-icon-tint)"></path>
			</symbol>
			<symbol id="tile" viewBox="0 0 24 24">
				<path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path>
				<path d="M 15.667 13 C 17.139 13 18.333 14.194 18.333 15.667 C 18.333 17.139 17.139 18.333 15.667 18.333 C 14.194 18.333 13 17.139 13 15.667 C 13 14.194 14.194 13 15.667 13 Z" fill="var(--svg-icon-tint)"></path>
			</symbol>
			<symbol id="image" viewBox="0 0 24 24">
				<path d="M5 8.5c0-.828.672-1.5 1.5-1.5s1.5.672 1.5 1.5c0 .829-.672 1.5-1.5 1.5s-1.5-.671-1.5-1.5zm9 .5l-2.519 4-2.481-1.96-4 5.96h14l-5-8zm8-4v14h-20v-14h20zm2-2h-24v18h24v-18z"></path>
			</symbol>
			<symbol id="video" viewBox="0 0 24 24">
				<path d="M2.184 7.874l-2.184-.918 2.967-2.956.933 2.164-1.716 1.71zm21.816 2.126l-3 2v4l3 2v-8zm-7-2h-7.018l.79.787c.356.355.629.769.831 1.213h4.897c.276 0 .5.224.5.5v7c0 .276-.224.5-.5.5h-11c-.276 0-.5-.224-.5-.5v-2.909l-.018-.014-1.982-1.975v5.398c0 1.104.896 2 2 2h12c1.104 0 2-.896 2-2v-8c0-1.104-.896-2-2-2zm-14.65 1.13l2.967-2.956 4.044 4.029c.819.816.819 2.14 0 2.956-.819.816-2.147.815-2.967 0l-4.044-4.029z"></path>
			</symbol>
			<symbol id="stream" viewBox="0 0 24 24">
				<path d="M6.613 18.581m9.387-9.581c0 2.209-1.791 4-4 4s-4-1.791-4-4 1.791-4 4-4 4 1.791 4 4zm-2 0c0-1.103-.896-2-2-2s-2 .897-2 2 .896 2 2 2 2-.897 2-2zm-9 0c0 3.86 3.141 7 7 7s7-3.14 7-7-3.141-7-7-7-7 3.14-7 7zm16 0c0 4.97-4.029 9-9 9s-9-4.03-9-9 4.029-9 9-9 9 4.03 9 9zm-.404 12.501c1.007 1.142-.014 2.679-1.448 2.481-1.795-.245-3.236-1.702-7.147-1.702-3.91 0-5.352 1.458-7.146 1.702-1.436.198-2.456-1.34-1.449-2.481l2.898-3.289c.559.388 1.156.725 1.79.994l-2.025 2.298c1.295-.524 3.065-1.225 5.933-1.225s4.638.7 5.933 1.224l-2.025-2.298c.634-.27 1.231-.606 1.79-.994l2.896 3.29z"></path>
			</symbol>
			<symbol id="spinner" viewBox="0 0 24 24">
				<path d="M8.175 7.377l-3.042-5.27 1.732-1 3.045 5.273c-.635.238-1.222.573-1.735.997zm-.799.8l-5.27-3.042-1 1.732 5.274 3.045c.237-.635.572-1.223.996-1.735zm-1.376 3.823c0-.341.035-.673.09-.999h-6.09v1.999h6.09c-.055-.326-.09-.659-.09-1zm11.351-2.705l5.208-3.007-.333-.577-5.206 3.007c.121.185.23.379.331.577zm-5.351-3.295c.341 0 .673.035.999.09v-6.09h-1.999v6.09c.326-.055.659-.09 1-.09zm3.14.894l3.004-5.204-.288-.166-3 5.197.284.173zm1.685 8.662l5.234 3.022.666-1.154-5.229-3.019c-.181.41-.408.794-.671 1.151zm-10.444-1.467l-5.274 3.046 1 1.732 5.27-3.042c-.424-.513-.759-1.1-.996-1.736zm11.594-2.589l.025.5-.025.5h6.025v-1h-6.025zm-3.727 6.061l3.03 5.249 1.442-.833-3.031-5.25c-.437.34-.92.623-1.441.834zm-2.248.439c-.341 0-.674-.035-1-.09v6.09h1.999v-6.09c-.326.055-.658.09-.999.09zm-3.824-1.376l-3.042 5.27 1.732 1 3.045-5.274c-.635-.237-1.222-.572-1.735-.996z"></path>
			</symbol>
			<symbol id="update" viewBox="0 0 24 24">
				<path d="M23 12c0 1.042-.154 2.045-.425 3h-2.101c.335-.94.526-1.947.526-3 0-4.962-4.037-9-9-9-1.706 0-3.296.484-4.655 1.314l1.858 2.686h-6.994l2.152-7 1.849 2.673c1.684-1.049 3.659-1.673 5.79-1.673 6.074 0 11 4.925 11 11zm-6.354 7.692c-1.357.826-2.944 1.308-4.646 1.308-4.962 0-9-4.038-9-9 0-1.053.191-2.06.525-3h-2.1c-.271.955-.425 1.958-.425 3 0 6.075 4.925 11 11 11 2.127 0 4.099-.621 5.78-1.667l1.853 2.667 2.152-6.989h-6.994l1.855 2.681z"></path>
			</symbol>
			<symbol id="edit" viewBox="0 0 24 24">
				<path d="M0 1h24v2h-24v-2zm11 7h13v-2h-13v2zm0 5h13v-2h-13v2zm0 5h13v-2h-13v2zm-11 5h24v-2h-24v2zm8-17l-8 6 8 6v-12z"></path>
			</symbol>
			<symbol id="lock" viewBox="0 0 24 24">
				<path d="M18 10v-4c0-3.313-2.687-6-6-6s-6 2.687-6 6v4h-3v14h18v-14h-3zm-10 0v-4c0-2.206 1.794-4 4-4s4 1.794 4 4v4h-8z"></path>
			</symbol>
			<symbol id="volume-off" viewBox="0 0 24 24">
				<path d="M5 17h-5v-10h5v10zm2-10v10l9 5v-20l-9 5zm15.324 4.993l1.646-1.659-1.324-1.324-1.651 1.67-1.665-1.648-1.316 1.318 1.67 1.657-1.65 1.669 1.318 1.317 1.658-1.672 1.666 1.653 1.324-1.325-1.676-1.656z"></path>
			</symbol>
			<symbol id="volume-on" viewBox="0 0 24 24">
				<path d="M5 17h-5v-10h5v10zm2-10v10l9 5v-20l-9 5zm11.008 2.093c.742.743 1.2 1.77 1.198 2.903-.002 1.133-.462 2.158-1.205 2.9l1.219 1.223c1.057-1.053 1.712-2.511 1.715-4.121.002-1.611-.648-3.068-1.702-4.125l-1.225 1.22zm2.142-2.135c1.288 1.292 2.082 3.073 2.079 5.041s-.804 3.75-2.096 5.039l1.25 1.254c1.612-1.608 2.613-3.834 2.616-6.291.005-2.457-.986-4.681-2.595-6.293l-1.254 1.25z"></path>
			</symbol>
			<symbol id="fullscreen-off" viewBox="0 0 24 24">
				<path d="M15 2h2v5h7v2h-9v-7zm9 13v2h-7v5h-2v-7h9zm-15 7h-2v-5h-7v-2h9v7zm-9-13v-2h7v-5h2v7h-9z"></path>
			</symbol>
			<symbol id="fullscreen-on" viewBox="0 0 24 24">
				<path d="M24 9h-2v-7h-7v-2h9v9zm-9 15v-2h7v-7h2v9h-9zm-15-9h2v7h7v2h-9v-9zm9-15v2h-7v7h-2v-9h9z"></path>
			</symbol>
			<symbol id="navmap" viewBox="0 0 24 24">
				<path d="M24 22.586l-2.823-2.823c.526-.792.836-1.74.836-2.763 0-2.762-2.238-5-5-5s-5 2.238-5 5 2.238 5 5 5c1.016 0 1.957-.307 2.746-.827l2.827 2.827 1.414-1.414zm-9.987-5.586c0-1.654 1.346-3 3-3s3 1.346 3 3-1.346 3-3 3-3-1.346-3-3zm-4 0l.002-.034-3.015 2.175v-13.068l4-2.886v10.247c.508-.854 1.189-1.591 2-2.161v-8.086l4 2.886v3.927h.013c.336 0 .664.032.987.078v-4.007l4-2.479v8.504c1.188 1.208 1.936 2.844 2 4.653v-16.749l-6.455 4-5.545-4-5.545 4-6.455-4v18l6.455 4 3.91-2.82c-.226-.687-.352-1.419-.352-2.18zm-4.013 2.365l-4-2.479v-13.294l4 2.479v13.294z"/>
			</symbol>
			<symbol id="screen" viewBox="0 0 24 24">
				<path d="M0 0v19h24v-19h-24zm22 14h-20v-12h20v12zm-6.599 7l2.599 3h-12l2.599-3h6.802z"></path>
			</symbol>
			<symbol id="chat" viewBox="0 0 24 24">
				<path d="M22 3v13h-11.643l-4.357 3.105v-3.105h-4v-13h20zm2-2h-24v16.981h4v5.019l7-5.019h13v-16.981z"></path>
			</symbol>
			<symbol id="send" viewBox="0 0 24 24">
				<path d="M22 12l-20 12 5-12-5-12z"></path>
			</symbol>
			<symbol id="users" viewBox="0 0 24 24">
				<path d="M10.644 17.08c2.866-.662 4.539-1.241 3.246-3.682-3.932-7.427-1.042-11.398 3.111-11.398 4.235 0 7.054 4.124 3.11 11.398-1.332 2.455.437 3.034 3.242 3.682 2.483.574 2.647 1.787 2.647 3.889v1.031h-18c0-2.745-.22-4.258 2.644-4.92zm-12.644 4.92h7.809c-.035-8.177 3.436-5.313 3.436-11.127 0-2.511-1.639-3.873-3.748-3.873-3.115 0-5.282 2.979-2.333 8.549.969 1.83-1.031 2.265-3.181 2.761-1.862.43-1.983 1.34-1.983 2.917v.773z"></path>
			</symbol>
			<symbol id="virtual-tour" viewBox="0 0 24 24">
				<path d="M17 17h-10v-10h10v10zm7 3l-5-3v-10l5-3v16zm-24-16l5 3v10l-5 3v-16z"></path>
			</symbol>
			<symbol id="live-meeting" viewBox="0 0 24 24">
				<path d="M18 18h6v6h-6v-6zm-9 6h6v-6h-6v6zm-9 0h6v-6h-6v6zm0-8h24v-16h-24v16z"></path>
			</symbol>
			<symbol id="control" viewBox="0 0 24 24">
				<circle cx="7" cy="10" r="1"></circle>
				<path d="M17,3H7c-3.9,0-7,3.1-7,7v6c0,2.8,2.2,5,5,5c2.4,0,4.4-1.7,4.9-4h4.2c0.5,2.7,3.2,4.5,5.9,3.9c2.3-0.5,4-2.5,4-4.9v-6 C24,6.1,20.9,3,17,3z M17,7c0.6,0,1,0.4,1,1s-0.4,1-1,1s-1-0.4-1-1S16.4,7,17,7z M7,13c-1.7,0-3-1.3-3-3s1.3-3,3-3s3,1.3,3,3 S8.7,13,7,13z M15,11c-0.6,0-1-0.4-1-1s0.4-1,1-1s1,0.4,1,1S15.6,11,15,11z M17,13c-0.6,0-1-0.4-1-1c0-0.6,0.4-1,1-1s1,0.4,1,1 C18,12.5,17.6,13,17,13z M19,11c-0.6,0-1-0.4-1-1s0.4-1,1-1s1,0.4,1,1S19.6,11,19,11z"></path>
			</symbol>
			<symbol id="spy" viewBox="0 0 24 24">
				<path fill-rule="evenodd" d="M0.2,11.4c5.2-8.6,18.3-8.5,23.6,0c0.2,0.3,0.2,0.8,0,1.2c-5.3,8.4-18.4,8.6-23.6,0 C-0.1,12.2-0.1,11.7,0.2,11.4z M12,7.8c2.3,0,4.2,1.9,4.2,4.3s-1.9,4.2-4.2,4.2S7.8,14.3,7.8,12S9.7,7.8,12,7.8z" clip-rule="evenodd"></path>
			</symbol>
			<symbol id="joystick" viewBox="0 0 24 24">
				<path d="M10.7,10.5V16H9.3C8.6,16,8,16.6,8,17.3h8c0-0.7-0.6-1.3-1.3-1.3h-1.3v-5.5c2.8-0.7,4.5-3.6,3.8-6.5 c-0.7-2.8-3.6-4.5-6.5-3.8S6.1,3.9,6.9,6.7C7.3,8.6,8.8,10,10.7,10.5z"></path>
				<path d="M1.4,18.6h21.2c0.7,0,1.3,0.6,1.3,1.3v2.7c0,0.7-0.6,1.3-1.3,1.3H1.4c-0.7,0-1.3-0.6-1.3-1.3V20 C0.1,19.2,0.7,18.6,1.4,18.6z"></path>
			</symbol>
			<symbol id="navinfo" viewBox="0 0 24 24">
				<path d="M12,2c5.5,0,10,4.5,10,10s-4.5,10-10,10S2,17.5,2,12S6.5,2,12,2z M12,0C5.4,0,0,5.4,0,12s5.4,12,12,12s12-5.4,12-12 S18.6,0,12,0z"/>
				<path d="M13,18h-2v-8h2V18z M12,5.8c0.7,0,1.2,0.6,1.2,1.2S12.7,8.2,12,8.2S10.8,7.7,10.8,7S11.3,5.8,12,5.8z"/>
			</symbol>
			<symbol id="check" viewBox="0 0 24 24">
				<path d="M9,21l-9-8.6l2.8-2.9l6.2,5.9L21.2,3L24,5.8L9,21z"/>
			</symbol>
			<symbol id="duplicate" viewBox="0 0 24 24">
				<path d="M18,6V0H0v18h6v6h18V6H18z M6,16H2V2h14v4H6V16z M22,22H8V8h14V22z M19,14h-3v-3h-2v3h-3v2h3v3h2v-3h3V14z"/>
			</symbol>
			<symbol id="trash" viewBox="0 0 24 24">
				<path fill-rule="evenodd" d="M19,24H5c-1.1,0-2-0.9-2-2V5H2V3h6V1.5C8,0.7,8.7,0,9.5,0h5C15.3,0,16,0.7,16,1.5V3h6v2h-1v17 C21,23.1,20.1,24,19,24z M19,5H5v16.5C5,21.8,5.2,22,5.5,22h13c0.3,0,0.5-0.2,0.5-0.5V5z M10,9c0-0.6-0.4-1-1-1S8,8.4,8,9v9 c0,0.6,0.4,1,1,1s1-0.4,1-1V9z M16,9c0-0.6-0.4-1-1-1s-1,0.4-1,1v9c0,0.6,0.4,1,1,1s1-0.4,1-1V9z M14,2h-4v1h4V2z" clip-rule="evenodd"/>
			</symbol>
			<symbol id="flags" viewBox="0 0 24 24">
				<path d="M19,18c0,1.1-0.9,2-2,2s-2-0.9-2-2s0.9-2,2-2S19,16.9,19,18z M5,15c-1.7,0-3,1.3-3,3s1.3,3,3,3h14c1.7,0,3-1.3,3-3 s-1.3-3-3-3H5z M24,18c0,2.8-2.2,5-5,5H5c-2.8,0-5-2.2-5-5s2.2-5,5-5h14C21.8,13,24,15.2,24,18z M7,4C5.9,4,5,4.9,5,6s0.9,2,2,2 s2-0.9,2-2S8.1,4,7,4z M5,3C3.3,3,2,4.3,2,6s1.3,3,3,3h14c1.7,0,3-1.3,3-3s-1.3-3-3-3H5z M24,6c0,2.8-2.2,5-5,5H5c-2.8,0-5-2.2-5-5 s2.2-5,5-5h14C21.8,1,24,3.2,24,6z"/>
			</symbol>
			<symbol id="b-here" viewBox="0 0 270 98">
				<path d="M61.5,87.9c0-2.7,0.9-5,2.8-6.9c1.9-1.9,4.2-2.8,7-2.8c1.4,0,2.7,0.2,3.9,0.8c1.2,0.5,2.2,1.2,3.2,2 c0.9,0.9,1.6,1.9,2.1,3.1s0.8,2.5,0.8,3.8s-0.2,2.6-0.8,3.8c-0.5,1.2-1.2,2.2-2.1,3.1s-1.9,1.6-3.2,2.1c-1.2,0.5-2.5,0.8-3.9,0.8 s-2.7-0.2-3.9-0.8c-1.2-0.5-2.2-1.2-3.1-2.1s-1.6-1.9-2.1-3.1S61.5,89.2,61.5,87.9z"></path>
				<path d="M16,70.2H0.7v-70H16V29c0.6-1.1,1.4-2.1,2.4-3.1s2.2-1.9,3.5-2.6s2.8-1.3,4.2-1.8c1.5-0.4,3-0.6,4.6-0.6 c3.5,0,6.7,0.6,9.6,1.9s5.4,3.1,7.4,5.3c2.1,2.2,3.7,4.9,4.8,8s1.7,6.4,1.7,10.1c0,3.6-0.6,6.9-1.7,10c-1.1,3.1-2.7,5.8-4.8,8 c-2.1,2.2-4.5,4-7.4,5.3s-6.1,2-9.6,2c-1.6,0-3.1-0.2-4.6-0.7c-1.5-0.4-2.9-1-4.2-1.7c-1.3-0.7-2.5-1.5-3.5-2.5s-1.8-2-2.4-3.1 C16,63.5,16,70.2,16,70.2z M27.6,58.5c1.7,0,3.2-0.3,4.6-1c1.4-0.7,2.6-1.5,3.6-2.7c1-1.1,1.8-2.4,2.4-3.9c0.6-1.5,0.8-3.1,0.8-4.8 s-0.3-3.2-0.8-4.7c-0.6-1.5-1.4-2.8-2.4-3.9c-1-1.1-2.2-2-3.6-2.7c-1.4-0.7-2.9-1-4.6-1s-3.3,0.3-4.8,1c-1.4,0.7-2.7,1.6-3.7,2.7 c-1,1.1-1.8,2.4-2.3,3.9c-0.6,1.5-0.8,3-0.8,4.7s0.3,3.2,0.8,4.8s1.3,2.8,2.3,3.9c1,1.1,2.2,2,3.7,2.7 C24.3,58.2,25.9,58.5,27.6,58.5z"></path>
				<path d="M64.1,0.2h14.8V29c1.3-2.5,3.3-4.5,6-6s5.9-2.2,9.6-2.2c3.1,0,5.8,0.5,7.9,1.4c2.1,1,3.9,2.3,5.2,4.1 c1.5,1.9,2.6,4,3.1,6.5s0.8,5.4,0.8,8.9v28.5H96.7V45.5c0-3.5-0.6-6.3-1.8-8.5c-1.2-2.2-3.5-3.2-6.7-3.2c-3.1,0-5.5,1.1-7,3.3 s-2.3,5.2-2.3,8.9v24.2H64.1V0.2z"></path>
				<path d="M135.9,49.8c0.1,1.5,0.3,2.9,0.7,4.2s1,2.4,1.8,3.4s1.9,1.7,3.2,2.3s3,0.8,5,0.8c2.7,0,4.7-0.5,6-1.6 c1.4-1.1,2.3-2.4,2.9-3.9h15c-0.3,2.3-1.1,4.4-2.4,6.4c-1.2,2-2.9,3.8-4.9,5.2c-2,1.5-4.4,2.7-7.2,3.5c-2.8,0.9-5.9,1.3-9.3,1.3 c-4.2,0-7.9-0.6-11.2-1.8c-3.2-1.2-6-3-8.2-5.2c-2.2-2.3-3.9-5-5-8c-1.1-3.1-1.7-6.5-1.7-10.2c0-3.5,0.5-6.8,1.6-9.9s2.7-5.8,4.9-8 c2.2-2.3,4.8-4.1,8-5.5c3.2-1.3,6.8-2,11-2c3.8,0,7.2,0.6,10.2,1.8c3,1.2,5.6,2.8,7.8,4.8s3.8,4.3,5,7s1.8,5.5,1.8,8.4 c0,1,0,2.1,0,3.2c0,1.1-0.2,2.4-0.5,3.9h-34.5V49.8z M146.2,31c-3,0-5.5,0.9-7.4,2.6c-1.9,1.7-2.9,4.2-2.9,7.5h20.2 c0-3.1-0.9-5.6-2.8-7.4C151.5,31.9,149.1,31,146.2,31z"></path>
				<path d="M216.1,36c-1.1-0.3-2-0.5-2.7-0.6c-0.7-0.1-1.6-0.1-2.7-0.1c-4.2,0-7.6,1.2-10.1,3.7s-3.8,6.6-3.8,12.5v18.8h-15.3V22h15.3 v7.8c1.1-2.3,3-4.3,5.7-6c2.6-1.7,5.6-2.6,9-2.6c1.8,0,3.3,0.3,4.6,0.8V36z"></path>
				<path d="M234.3,49.8c0.1,1.5,0.3,2.9,0.7,4.2s1,2.4,1.8,3.4s1.9,1.7,3.2,2.3s3,0.8,5,0.8c2.7,0,4.7-0.5,6-1.6 c1.4-1.1,2.3-2.4,2.9-3.9h15c-0.3,2.3-1.1,4.4-2.4,6.4c-1.2,2-2.9,3.8-4.9,5.2c-2,1.5-4.4,2.7-7.2,3.5c-2.8,0.9-5.9,1.3-9.3,1.3 c-4.2,0-7.9-0.6-11.2-1.8c-3.2-1.2-6-3-8.2-5.2c-2.2-2.3-3.9-5-5-8c-1.1-3.1-1.7-6.5-1.7-10.2c0-3.5,0.5-6.8,1.6-9.9s2.7-5.8,4.9-8 c2.2-2.3,4.8-4.1,8-5.5c3.2-1.3,6.8-2,11-2c3.8,0,7.2,0.6,10.2,1.8c3,1.2,5.6,2.8,7.8,4.8c2.2,2,3.8,4.3,5,7s1.8,5.5,1.8,8.4 c0,1,0,2.1,0,3.2c0,1.1-0.2,2.4-0.5,3.9h-34.5V49.8z M244.6,31c-3,0-5.5,0.9-7.4,2.6c-1.9,1.7-2.9,4.2-2.9,7.5h20.2 c0-3.1-0.9-5.6-2.8-7.4C249.9,31.9,247.5,31,244.6,31z"></path>
			</symbol>
		</svg>
	`;class AppComponent extends rxcomp.Component {
  onInit() {
    const routes = AppRoutesInit();
    RouterService.useBrowser(routes);
    AssetGroupTypeInit();
    RouterService.event$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(event => {
      const route = event.route;
      if (route && route.params.mode === 'embed') {
        environment.flags.like = false;
      }
      LanguageService.setRoute(route, routes);
    });
    LanguageService.lang$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(_ => {
      this.pushChanges();
    });
    const {
      node
    } = rxcomp.getContext(this);
    node.classList.remove('hidden');
  }
}
AppComponent.meta = {
  selector: '[b-here-component]',
  template: /* html */`
		<!-- svg -->
		${SVG_CHUNK}
		<!-- header -->
		<router-outlet></router-outlet>
		<!-- footer -->
		<div class="toast-outlet" toast-outlet></div>
		<div class="modal-outlet" modal-outlet></div>
	`
};const MIME_IMAGE = ['bmp', 'gif', 'ico', 'jpeg', 'jpg', 'png', 'svg', 'tif', 'tiff', 'webp', 'hdr'];
const MIME_VIDEO = ['mp4', 'avi', 'mpeg', 'ogv', 'ts', 'webm', '3gp', '3g2'];
const MIME_MODEL = ['fbx', 'gltf', 'glb', 'obj', 'usdz'];
const MIME_STREAM = ['publisherStream', 'nextAttendeeStream', 'publisherScreen', 'attendeeScreen'];
function isImage(path) {
  // eslint-disable-next-line no-useless-escape
  return new RegExp(`/\.(${MIME_IMAGE.join('|')})$/i`).test(path);
}
function isVideo(path) {
  // eslint-disable-next-line no-useless-escape
  return new RegExp(`/\.(${MIME_VIDEO.join('|')})$/i`).test(path);
}
function isModel(path) {
  // eslint-disable-next-line no-useless-escape
  return new RegExp(`/\.(${MIME_MODEL.join('|')})$/i`).test(path);
}
function isStream(path) {
  return MIME_STREAM.indexOf(path) !== -1;
}
class AssetPipe extends rxcomp.Pipe {
  static transform(asset, type) {
    if (type === void 0) {
      type = null;
    }
    if (type != null) {
      // keep loose equality
      asset = asset.type.name === type ? asset : null;
    }
    if (asset) {
      if (typeof asset === 'string') {
        return environment.getPath(asset);
      }
      // console.log(asset.type.name, AssetType.Image.name);
      switch (asset.type.name) {
        case AssetType.Image.name:
        case AssetType.Video.name:
          asset = asset.folder + asset.file;
          asset = environment.getPath(asset);
          break;
        case AssetType.Model.name:
          asset = asset.folder + asset.file;
          asset = environment.getPath(asset);
          break;
        case AssetType.PublisherStream.name:
        case AssetType.AttendeeStream.name:
        case AssetType.PublisherScreen.name:
        case AssetType.AttendeeScreen.name:
        case AssetType.SmartDeviceStream.name:
          asset = environment.getPath(asset.file);
          break;
        default:
          if (isImage(asset.file) || isVideo(asset.file)) {
            asset = asset.folder + asset.file;
            asset = environment.getPath(asset);
          } else if (isModel(asset.file)) {
            asset = asset.folder + asset.file;
            asset = environment.getPath(asset);
          } else if (isStream(asset.file)) {
            asset = asset.file;
          }
      }
      // asset = asset;
    } else {
      asset = null;
    }
    // console.log('AssetPipe.transform', asset);
    return asset;
  }
}
AssetPipe.meta = {
  name: 'asset'
};class ControlRequestModalComponent extends rxcomp.Component {
  onInit() {
    super.onInit();
    const {
      parentInstance
    } = rxcomp.getContext(this);
    if (parentInstance instanceof ModalOutletComponent) {
      this.data = parentInstance.modal.data;
    }
  }
  onAccept(user) {
    ModalService.resolve();
  }
  onReject(user) {
    ModalService.reject();
  }

  /*
  onDestroy() {
  	// console.log('ControlRequestModalComponent.onDestroy');
  }
  */

  onClose() {
    ModalService.reject();
  }
}
ControlRequestModalComponent.meta = {
  selector: '[control-request-modal]',
  template: /* html */`
		<div class="modal__header">
			<button type="button" class="btn--close" (click)="onClose()">
				<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#close"></use></svg>
			</button>
		</div>
		<div class="container">
			<div class="form">
				<div class="title">L'utente ha richiesto il controllo della navigazione. Accetti?</div>
				<div class="group--cta">
					<button type="button" class="btn--cancel" (click)="onReject()">
						<span>Rifiuta</span>
					</button>
					<button type="button" class="btn--accept" (click)="onAccept()">
						<span>Accetta</span>
					</button>
				</div>
			</div>
		</div>
	`
};
ControlRequestModalComponent.chunk = () => /* html */'<div class="control-request-modal" control-request-modal></div>';class DropDirective extends rxcomp.Directive {
  onInit() {
    const {
      module,
      node,
      parentInstance,
      selector
    } = rxcomp.getContext(this);
    const event = 'drop';
    const event$ = rxjs.fromEvent(node, event).pipe(operators.shareReplay(1));
    const expression = node.getAttribute(`(${event})`);
    if (expression) {
      const outputFunction = module.makeFunction(expression, ['$event']);
      event$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(event => {
        module.resolve(outputFunction, parentInstance, event);
      });
      rxjs.fromEvent(node, 'dragover').pipe(operators.takeUntil(this.unsubscribe$)).subscribe(event => event.preventDefault());
    } else {
      parentInstance[`${event}$`] = event$;
    }
    // console.log('DropDirective.onInit', 'selector', selector, 'event', event);
  }
}

DropDirective.meta = {
  selector: '[(drop)]'
};let DROPDOWN_ID = 1000000;
class DropdownDirective extends rxcomp.Directive {
  get id() {
    return this.dropdown || this.id_ || (this.id_ = DropdownDirective.nextId());
  }
  onInit() {
    const {
      node
    } = rxcomp.getContext(this);
    const trigger = node.getAttribute('dropdown-trigger');
    this.trigger = trigger ? node.querySelector(trigger) : node;
    this.opened = null;
    this.onClick = this.onClick.bind(this);
    this.onDocumentClick = this.onDocumentClick.bind(this);
    this.openDropdown = this.openDropdown.bind(this);
    this.closeDropdown = this.closeDropdown.bind(this);
    this.addListeners();
    DropdownDirective.dropdown$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(id => {
      // console.log('DropdownDirective', id, this['dropdown-item']);
      if (this.id === id) {
        node.classList.add('dropped');
      } else {
        node.classList.remove('dropped');
      }
    });
  }
  onClick(event) {
    const {
      node
    } = rxcomp.getContext(this);
    if (this.opened === null) {
      this.openDropdown();
    } else {
      const dropdownItemNode = node.querySelector('[dropdown-item]');
      // console.log('dropdownItemNode', dropdownItemNode);
      if (!dropdownItemNode) {
        // if (this.trigger !== node) {
        this.closeDropdown();
      }
    }
  }
  onDocumentClick(event) {
    const {
      node
    } = rxcomp.getContext(this);
    const clickedInside = node === event.target || node.contains(event.target);
    if (!clickedInside) {
      this.closeDropdown();
    }
  }
  openDropdown() {
    if (this.opened === null) {
      this.opened = true;
      this.addDocumentListeners();
      DropdownDirective.dropdown$.next(this.id);
      this.dropped.next(this.id);
    }
  }
  closeDropdown() {
    if (this.opened !== null) {
      this.removeDocumentListeners();
      this.opened = null;
      if (DropdownDirective.dropdown$.getValue() === this.id) {
        DropdownDirective.dropdown$.next(null);
        this.dropped.next(null);
      }
    }
  }
  addListeners() {
    this.trigger.addEventListener('click', this.onClick);
  }
  addDocumentListeners() {
    document.addEventListener('click', this.onDocumentClick);
  }
  removeListeners() {
    this.trigger.removeEventListener('click', this.onClick);
  }
  removeDocumentListeners() {
    document.removeEventListener('click', this.onDocumentClick);
  }
  onDestroy() {
    this.removeListeners();
    this.removeDocumentListeners();
  }
  static nextId() {
    return DROPDOWN_ID++;
  }
}
DropdownDirective.meta = {
  selector: '[dropdown]',
  inputs: ['dropdown', 'dropdown-trigger'],
  outputs: ['dropped']
};
DropdownDirective.dropdown$ = new rxjs.BehaviorSubject(null);class DropdownItemDirective extends rxcomp.Directive {
  get id() {
    return this['dropdown-item'];
  }
  onInit() {
    const {
      node
    } = rxcomp.getContext(this);
    node.classList.add('dropdown-item');
    DropdownDirective.dropdown$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(id => {
      // console.log('DropdownItemDirective', id, this['dropdown-item']);
      if (this.id === id) {
        node.classList.add('dropped');
      } else {
        node.classList.remove('dropped');
      }
    });
  }
}
DropdownItemDirective.meta = {
  selector: '[dropdown-item], [[dropdown-item]]',
  inputs: ['dropdown-item']
};class ToastOutletComponent extends rxcomp.Component {
  onInit() {
    this.toast = null;
    this.lastToast = null;
    ToastService.toast$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(toast => {
      if (toast) {
        this.lastToast = toast;
      }
      this.toast = toast;
      this.pushChanges();
    });
    // console.log('ToastOutletComponent.onInit');
  }

  getClass() {
    const classList = {};
    if (this.toast) {
      classList.active = true;
    }
    if (this.lastToast) {
      classList[this.lastToast.type] = true;
      classList[this.lastToast.position] = true;
    }
    return classList;
  }
  onClose() {
    ToastService.reject(this.toast);
  }
  onAccept() {
    ToastService.resolve(this.toast);
  }
  onReject() {
    ToastService.reject(this.toast);
  }
}
ToastOutletComponent.meta = {
  selector: '[toast-outlet]',
  template: /* html */`
	<div class="toast-outlet__container" [class]="getClass()">
		<div class="toast-outlet__toast" *if="lastToast">
			<span class="toast-outlet__message" [innerHTML]="lastToast.message"></span>
			<div class="group--cta" *if="lastToast.type != 'info'">
				<button type="button" class="btn--accept" (click)="onAccept()">
					<span [innerHTML]="lastToast.acceptMessage"></span>
				</button>
				<button type="button" class="btn--cancel" (click)="onReject()" *if="lastToast.type == 'dialog'">
					<span [innerHTML]="lastToast.rejectMessage"></span>
				</button>
			</div>
			<button type="button" class="btn--close" (click)="onClose()" *if="lastToast.type != 'info'">
				<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#close"></use></svg>
			</button>
		</div>
	</div>
	`
};class AsideComponent extends rxcomp.Component {
  onInit() {
    this.mode = 1;
    this.viewTypes = Object.keys(ViewType).map(key => {
      const type = ViewType[key];
      return {
        type: type,
        name: LabelPipe.getKeys('editor', type.name),
        disabled: environment.editor.disabledViewTypes.indexOf(type.name) !== -1
      };
    });
    this.viewItemTypes = Object.keys(ViewItemType).map(key => {
      const type = ViewItemType[key];
      return {
        type: type,
        name: LabelPipe.getKeys('editor', type.name),
        disabled: environment.editor.disabledViewItemTypes.indexOf(type.name) !== -1
      };
    });
    this.setSupportedViewTypes();
    this.setSupportedViewItemTypes();
  }
  onChanges() {
    this.setSupportedViewTypes();
    this.setSupportedViewItemTypes();
  }
  setSupportedViewTypes() {
    this.supportedViewTypes = this.viewTypes.filter(x => this.supportedViewType(x.type.name)).sort((a, b) => {
      if (a.disabled === b.disabled) {
        return 0; // (a.type.name < b.type.name) ? -1 : (a.type.name > b.type.name) ? 1 : 0;
      } else {
        return a.disabled ? 1 : -1;
      }
    });
  }
  setSupportedViewItemTypes() {
    if (this.view) {
      this.supportedViewItemTypes = this.viewItemTypes.filter(x => this.supportedViewItemType(this.view.type.name, x.type.name)).sort((a, b) => {
        if (a.disabled === b.disabled) {
          return 0; // (a.type.name < b.type.name) ? -1 : (a.type.name > b.type.name) ? 1 : 0;
        } else {
          return a.disabled ? 1 : -1;
        }
      });
    } else {
      this.supportedViewItemTypes = [];
    }
  }
  setMode(mode) {
    if (this.mode !== mode) {
      this.mode = mode;
      this.pushChanges();
    }
  }
  supportedViewType(viewTypeName) {
    let supported = [ViewType.Panorama.name, ViewType.PanoramaGrid.name, ViewType.Room3d.name, ViewType.Model.name, ViewType.Media.name].indexOf(viewTypeName) !== -1; // ViewType.WaitingRoom,
    // console.log('supportedViewType', viewType, supported);
    return supported;
  }
  supportedViewItemType(viewTypeName, viewItemTypeName) {
    let supported;
    switch (viewTypeName) {
      case ViewType.WaitingRoom.name:
        supported = false;
        break;
      case ViewType.Panorama.name:
        supported = [ViewItemType.Nav.name, ViewItemType.Model.name, ViewItemType.Plane.name, ViewItemType.CurvedPlane.name].indexOf(viewItemTypeName) !== -1;
        break;
      case ViewType.PanoramaGrid.name:
        supported = [ViewItemType.Nav.name, ViewItemType.Model.name, ViewItemType.Plane.name, ViewItemType.CurvedPlane.name].indexOf(viewItemTypeName) !== -1;
        break;
      case ViewType.Room3d.name:
        supported = [ViewItemType.Nav.name, ViewItemType.Model.name, ViewItemType.Plane.name, ViewItemType.Texture.name].indexOf(viewItemTypeName) !== -1;
        break;
      case ViewType.Model.name:
        supported = [ViewItemType.Nav.name, ViewItemType.Model.name, ViewItemType.Plane.name, ViewItemType.CurvedPlane.name].indexOf(viewItemTypeName) !== -1;
        break;
      case ViewType.Media.name:
        supported = [].indexOf(viewItemTypeName) !== -1;
        break;
    }
    // console.log('supportedViewItemType', viewTypeName, viewItemTypeName, supported);
    return supported;
  }
  onSelect(event) {
    this.select.next(event);
  }
  onUpdate(event) {
    this.update.next(event);
  }
  onDelete(event) {
    this.delete.next(event);
  }
}
AsideComponent.meta = {
  selector: '[aside]',
  outputs: ['select', 'update', 'delete'],
  inputs: ['view'],
  template: /* html */`
	<div class="headline">
		<ul class="nav--tab">
			<li [class]="{ active: mode === 1 }" (click)="setMode(1)" [innerHTML]="'editor_properties' | label"></li>
			<li [class]="{ active: mode === 2 }" (click)="setMode(2)" [innerHTML]="'editor_views' | label"></li>
			<li [class]="{ active: mode === 3 }" (click)="setMode(3)" [innerHTML]="'editor_view_items' | label"></li>
		</ul>
		<!--
		<div class="btn--mode" [class]="{ active: mode === 1 }" (click)="setMode(1)" [innerHTML]="'editor_properties' | label"></div>
		<div class="btn--mode" [class]="{ active: mode === 2 }" (click)="setMode(2)" [innerHTML]="'editor_views' | label"></div>
		<div class="btn--mode" [class]="{ active: mode === 3 }" (click)="setMode(3)" [innerHTML]="'editor_view_items' | label"></div>
		-->
	</div>
	<div class="scrollable">
		<ul class="nav--editor" *if="mode === 1">
			<li>
				<div class="title" [innerHTML]="'editor_properties' | label"></div>
				<update-view [view]="view" (select)="onSelect($event)" (update)="onUpdate($event)" (delete)="onDelete($event)"></update-view>
			</li>
			<li *if="view.type.name != 'panorama-grid'">
				<div class="title" [innerHTML]="'editor_items' | label"></div>
				<update-view-item [view]="view" [item]="item" (select)="onSelect($event)" (update)="onUpdate($event)" (delete)="onDelete($event)" *for="let item of view.pathItems"></update-view-item>
				<div class="abstract" *if="view.pathItems.length == 0" [innerHTML]="'editor_no_items' | label"></div>
				<div class="btn--mode" (click)="setMode(3)" [innerHTML]="'editor_add_item' | label"></div>
			</li>
			<li *if="view.type.name == 'panorama-grid'">
				<div class="title" [innerHTML]="'editor_tiles' | label"></div>
				<div *for="let tile of view.tiles">
					<div *if="tile.selected">
						<update-view-tile [view]="view" [tile]="tile" (update)="onUpdate($event)" (delete)="onDelete($event)"></update-view-tile>
						<ul class="nav--editor">
							<li>
								<update-view-item [view]="view" [item]="item" (select)="onSelect($event)" (update)="onUpdate($event)" (delete)="onDelete($event)" *for="let item of tile.navs"></update-view-item>
								<div class="abstract" *if="tile.navs.length == 0" [innerHTML]="'editor_no_navs' | label"></div>
								<div class="btn--mode" (click)="onSelect({ type:'viewItem', value: 'nav', tile: tile })" [innerHTML]="'editor_add_nav' | label"></div>
							</li>
							<!--
							<li>
								<div class="btn" (click)="onSelect({ type:'viewItem', value: 'nav', tile: tile })">
									<div class="icon">
										<svg-icon name="nav"></svg-icon>
									</div>
									<div class="title" [innerHTML]="'editor_add_nav' | label"></div>
								</div>
							</li>
							-->
						</ul>
					</div>
				</div>
				<div class="abstract" *if="view.tiles.length == 0" [innerHTML]="'editor_no_tiles' | label"></div>
				<!-- <div class="btn--mode" (click)="setMode(3)">Add Tile</div> -->
			</li>
			<!--
			<li *if="false">
				<div class="title">Icons</div>
				<ul class="nav--editor">
					<li>
						<div class="btn" (click)="onSelect('animated-tabs')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.3"></path><path d="M 2 8.4 L 12 8.4 L 12 2 L 6 2 C 3.791 2 2 3.791 2 6 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 12 8.4 L 22 8.4 L 22 6 C 22 3.791 20.209 2 18 2 L 12 2 Z" fill="var(--svg-icon-tint)"></path></svg></div>
							<div class="title">Animated Tabs</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('card-list')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.3"></path><path d="M 6.8 13.6 C 6.8 13.158 7.158 12.8 7.6 12.8 L 16.8 12.8 C 17.242 12.8 17.6 13.158 17.6 13.6 L 17.6 16.8 C 17.6 17.242 17.242 17.6 16.8 17.6 L 7.6 17.6 C 7.158 17.6 6.8 17.242 6.8 16.8 Z" fill="var(--svg-icon-tint)"></path><path d="M 6.8 7.2 C 6.8 6.758 7.158 6.4 7.6 6.4 L 16.8 6.4 C 17.242 6.4 17.6 6.758 17.6 7.2 L 17.6 10.4 C 17.6 10.842 17.242 11.2 16.8 11.2 L 7.6 11.2 C 7.158 11.2 6.8 10.842 6.8 10.4 Z" fill="var(--svg-icon-tint)"></path></svg></div>
							<div class="title">Card List</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('container-transitions')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 15.667 13 C 17.139 13 18.333 14.194 18.333 15.667 C 18.333 17.139 17.139 18.333 15.667 18.333 C 14.194 18.333 13 17.139 13 15.667 C 13 14.194 14.194 13 15.667 13 Z" fill="var(--svg-icon-tint)"></path></svg></svg></div>
							<div class="title">Container Transitions</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('dynamic-grid')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.3"></path><g transform="translate(6.6 6.6)"><path d="M 6.048 0.8 C 6.048 0.358 6.406 0 6.848 0 L 10 0 C 10.442 0 10.8 0.358 10.8 0.8 L 10.8 3.952 C 10.8 4.394 10.442 4.752 10 4.752 L 6.848 4.752 C 6.406 4.752 6.048 4.394 6.048 3.952 Z" fill="var(--svg-icon-tint)" opacity="0.5"></path><path d="M 6.048 6.848 C 6.048 6.406 6.406 6.048 6.848 6.048 L 10 6.048 C 10.442 6.048 10.8 6.406 10.8 6.848 L 10.8 10 C 10.8 10.442 10.442 10.8 10 10.8 L 6.848 10.8 C 6.406 10.8 6.048 10.442 6.048 10 Z" fill="var(--svg-icon-tint)"></path><path d="M 0 0.8 C 0 0.358 0.358 0 0.8 0 L 3.952 0 C 4.394 0 4.752 0.358 4.752 0.8 L 4.752 3.952 C 4.752 4.394 4.394 4.752 3.952 4.752 L 0.8 4.752 C 0.358 4.752 0 4.394 0 3.952 Z" fill="var(--svg-icon-tint)"></path><path d="M 0 6.848 C 0 6.406 0.358 6.048 0.8 6.048 L 3.952 6.048 C 4.394 6.048 4.752 6.406 4.752 6.848 L 4.752 10 C 4.752 10.442 4.394 10.8 3.952 10.8 L 0.8 10.8 C 0.358 10.8 0 10.442 0 10 Z" fill="var(--svg-icon-tint)" opacity="0.5"></path></g></svg></div>
							<div class="title">Dynamic Grid</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('expand-on-tap')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 0 0 L 7.833 0" transform="translate(8.583 11.583) rotate(270 3.917 0.5)" fill="transparent" stroke-width="1.67" stroke="var(--svg-icon-tint)" stroke-linecap="round" stroke-linejoin="round"></path><path d="M 14.667 9.333 L 12 6.667 L 9.333 9.333" stroke="var(--svg-icon-tint)" fill="transparent" stroke-width="1.67" stroke-linecap="round" stroke-linejoin="round"></path><path d="M 14.667 14.667 L 12 17.333 L 9.333 14.667" stroke="var(--svg-icon-tint)" fill="transparent" stroke-width="1.67" stroke-linecap="round" stroke-linejoin="round"></path> </svg></div>
							<div class="title">Expand on Tap</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('image-gallery-2')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 7.333 8.333 C 7.333 7.781 7.781 7.333 8.333 7.333 L 10.333 7.333 C 10.886 7.333 11.333 7.781 11.333 8.333 L 11.333 10.333 C 11.333 10.886 10.886 11.333 10.333 11.333 L 8.333 11.333 C 7.781 11.333 7.333 10.886 7.333 10.333 Z" fill="var(--svg-icon-tint)" opacity="0.4"></path><path d="M 12.333 8.333 C 12.333 7.781 12.781 7.333 13.333 7.333 L 15.333 7.333 C 15.886 7.333 16.333 7.781 16.333 8.333 L 16.333 10.333 C 16.333 10.886 15.886 11.333 15.333 11.333 L 13.333 11.333 C 12.781 11.333 12.333 10.886 12.333 10.333 Z" fill="var(--svg-icon-tint)" opacity="0.4"></path><path d="M 7.333 13.667 C 7.333 13.114 7.781 12.667 8.333 12.667 L 15.333 12.667 C 15.886 12.667 16.333 13.114 16.333 13.667 L 16.333 15.667 C 16.333 16.219 15.886 16.667 15.333 16.667 L 8.333 16.667 C 7.781 16.667 7.333 16.219 7.333 15.667 Z" fill="var(--svg-icon-tint)"></path></svg></div>
							<div class="title">Image Gallery 2</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('stories-ui')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.3"></path><path d="M 6.8 4.8 C 7.905 4.8 8.8 5.695 8.8 6.8 C 8.8 7.905 7.905 8.8 6.8 8.8 C 5.695 8.8 4.8 7.905 4.8 6.8 C 4.8 5.695 5.695 4.8 6.8 4.8 Z" fill="var(--svg-icon-tint)"></path><path d="M 12 4.8 C 13.105 4.8 14 5.695 14 6.8 C 14 7.905 13.105 8.8 12 8.8 C 10.895 8.8 10 7.905 10 6.8 C 10 5.695 10.895 4.8 12 4.8 Z" fill="var(--svg-icon-tint)"></path><path d="M 17.2 4.8 C 18.305 4.8 19.2 5.695 19.2 6.8 C 19.2 7.905 18.305 8.8 17.2 8.8 C 16.095 8.8 15.2 7.905 15.2 6.8 C 15.2 5.695 16.095 4.8 17.2 4.8 Z" fill="var(--svg-icon-tint)"></path></svg></div>
							<div class="title">Stories UI</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('todo-list')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 8 12.333 L 10.5 14.833 L 16 9.333" stroke="var(--svg-icon-tint)" fill="transparent" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path></svg></div>
							<div class="title">To-Do List</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('toggle-menu')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 17.333 15.333 C 18.438 15.333 19.333 16.229 19.333 17.333 C 19.333 18.438 18.438 19.333 17.333 19.333 C 16.229 19.333 15.333 18.438 15.333 17.333 C 15.333 16.229 16.229 15.333 17.333 15.333 Z" fill="var(--svg-icon-tint)"></path><path d="M 17.333 10 C 18.438 10 19.333 10.895 19.333 12 C 19.333 13.105 18.438 14 17.333 14 C 16.229 14 15.333 13.105 15.333 12 C 15.333 10.895 16.229 10 17.333 10 Z" fill="var(--svg-icon-tint)" opacity="0.4"></path><path d="M 17.333 4.667 C 18.438 4.667 19.333 5.562 19.333 6.667 C 19.333 7.771 18.438 8.667 17.333 8.667 C 16.229 8.667 15.333 7.771 15.333 6.667 C 15.333 5.562 16.229 4.667 17.333 4.667 Z" fill="var(--svg-icon-tint)" opacity="0.4"></path></svg></div>
							<div class="title">Toggle Menu</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('bottom-sheet')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 10.333 C 22 10.886 21.552 11.333 21 11.333 L 3 11.333 C 2.448 11.333 2 10.886 2 10.333 Z" fill="var(--svg-icon-tint)" opacity="0.4"></path><path d="M 2 13.333 C 2 12.781 2.448 12.333 3 12.333 L 21 12.333 C 21.552 12.333 22 12.781 22 13.333 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)"></path></svg></div>
							<div class="title">Bottom Sheet</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('draggable-sheet')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 2 14 C 2 12.895 2.895 12 4 12 L 20 12 C 21.105 12 22 12.895 22 14 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z M 10.667 15.333 L 13.333 15.333 C 13.702 15.333 14 15.035 14 14.667 C 14 14.298 13.702 14 13.333 14 L 10.667 14 C 10.298 14 10 14.298 10 14.667 C 10 15.035 10.298 15.333 10.667 15.333 Z" fill="var(--svg-icon-tint)"></path></svg></div>
							<div class="title">Draggable Sheet</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('modal-box')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 7.333 9.333 C 7.333 8.229 8.229 7.333 9.333 7.333 L 14.667 7.333 C 15.771 7.333 16.667 8.229 16.667 9.333 L 16.667 14.667 C 16.667 15.771 15.771 16.667 14.667 16.667 L 9.333 16.667 C 8.229 16.667 7.333 15.771 7.333 14.667 Z" fill="var(--svg-icon-tint)"></path></svg></div>
							<div class="title">Modal Box</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('side-menu')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 11 2 C 11.552 2 12 2.448 12 3 L 12 21 C 12 21.552 11.552 22 11 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)"></path></svg></div>
							<div class="title">Side Menu</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('input-form')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 7.333 8.333 C 7.333 7.781 7.781 7.333 8.333 7.333 L 11.667 7.333 C 11.667 7.333 11.667 7.333 11.667 7.333 L 15.667 7.333 C 16.219 7.333 16.667 7.781 16.667 8.333 L 16.667 9 C 16.667 9.552 16.219 10 15.667 10 L 13.333 10 L 13.333 15.667 C 13.333 16.219 12.886 16.667 12.333 16.667 L 11.667 16.667 C 11.114 16.667 10.667 16.219 10.667 15.667 L 10.667 10 L 8.333 10 C 7.781 10 7.333 9.552 7.333 9 Z" fill="var(--svg-icon-tint)"></path></svg></div>
							<div class="title">Input Form</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('loading-indicator')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.3"></path><path d="M 16.4 10.4 C 17.284 10.4 18 11.116 18 12 C 18 12.884 17.284 13.6 16.4 13.6 C 15.516 13.6 14.8 12.884 14.8 12 C 14.8 11.116 15.516 10.4 16.4 10.4 Z" fill="var(--svg-icon-tint)"></path><path d="M 12 10.4 C 12.884 10.4 13.6 11.116 13.6 12 C 13.6 12.884 12.884 13.6 12 13.6 C 11.116 13.6 10.4 12.884 10.4 12 C 10.4 11.116 11.116 10.4 12 10.4 Z" fill="var(--svg-icon-tint)"></path><path d="M 7.6 10.4 C 8.484 10.4 9.2 11.116 9.2 12 C 9.2 12.884 8.484 13.6 7.6 13.6 C 6.716 13.6 6 12.884 6 12 C 6 11.116 6.716 10.4 7.6 10.4 Z" fill="var(--svg-icon-tint)"></path></svg></div>
							<div class="title">Loading Indicator</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('radio-button-form')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 9.833 8.167 L 14.167 8.167 C 16.284 8.167 18 9.883 18 12 C 18 14.117 16.284 15.833 14.167 15.833 L 9.833 15.833 C 7.716 15.833 6 14.117 6 12 C 6 9.883 7.716 8.167 9.833 8.167 Z M 11.333 12 C 11.333 13.473 12.527 14.667 14 14.667 C 15.473 14.667 16.667 13.473 16.667 12 C 16.667 10.527 15.473 9.333 14 9.333 C 12.527 9.333 11.333 10.527 11.333 12 Z" fill="var(--svg-icon-tint)"></path></svg></div>
							<div class="title">Radio Button Form</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('checkbox-form')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 8.651 6.931 C 7.911 6.738 7.238 7.411 7.431 8.151 L 9.363 15.558 C 9.592 16.435 10.775 16.58 11.208 15.784 L 13 12.5 L 16.284 10.708 C 17.08 10.275 16.935 9.092 16.058 8.863 Z" fill="var(--svg-icon-tint)"></path><path d="M 16 15.5 L 11 10.5" fill="transparent" stroke-width="1.67" stroke="var(--svg-icon-tint)" stroke-linecap="round"></path></svg></div>
							<div class="title">Checkbox Form</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('splash-screen')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 7.757 13.414 C 6.976 12.633 6.976 11.367 7.757 10.586 L 10.586 7.757 C 11.367 6.976 12.633 6.976 13.414 7.757 L 16.243 10.586 C 17.024 11.367 17.024 12.633 16.243 13.414 L 13.414 16.243 C 12.633 17.024 11.367 17.024 10.586 16.243 Z" fill="var(--svg-icon-tint)"></path></svg></div>
							<div class="title">Splash Screen</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('timeout-transition')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 1 5.8 C 1 3.149 3.149 1 5.8 1 L 18.2 1 C 20.851 1 23 3.149 23 5.8 L 23 18.2 C 23 20.851 20.851 23 18.2 23 L 5.8 23 C 3.149 23 1 20.851 1 18.2 Z" fill="var(--svg-icon-tint)" opacity="0.3"></path><path d="M 12 6.72 C 14.916 6.72 17.28 9.084 17.28 12 C 17.28 14.916 14.916 17.28 12 17.28 C 9.084 17.28 6.72 14.916 6.72 12 C 6.72 9.084 9.084 6.72 12 6.72 Z M 11.34 12 C 11.34 12.365 11.635 12.66 12 12.66 L 14.2 12.66 C 14.565 12.66 14.86 12.365 14.86 12 C 14.86 11.635 14.565 11.34 14.2 11.34 L 12.66 11.34 L 12.66 9.8 C 12.66 9.435 12.365 9.14 12 9.14 C 11.635 9.14 11.34 9.435 11.34 9.8 Z" fill="var(--svg-icon-tint)"></path></svg></div>
							<div class="title">Timeout Transition</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('accordion-menu')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 16 10.667 L 12 14.667 L 8 10.667" fill="transparent" stroke-width="2" stroke="var(--svg-icon-tint)" stroke-linecap="round" stroke-linejoin="round"></path></svg></div>
							<div class="title">Accordion Menu</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('drop-on-scroll')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 0 0 L 8 0" transform="translate(8.5 11.5) rotate(270 4 0.5)" fill="transparent" stroke-width="1.67" stroke="var(--svg-icon-tint)" stroke-linecap="round" stroke-linejoin="round"></path><path d="M 15.333 11.333 L 12 8 L 8.667 11.333" fill="transparent" stroke-width="1.67" stroke="var(--svg-icon-tint)" stroke-linecap="round" stroke-linejoin="round"></path></svg></div>
							<div class="title">Drop on Scroll</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('nested-scroll')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 1.82 6 C 1.82 3.791 3.61 2 5.82 2 L 17.82 2 C 20.029 2 21.82 3.791 21.82 6 L 21.82 7 C 21.82 7.552 21.372 8 20.82 8 L 2.82 8 C 2.267 8 1.82 7.552 1.82 7 Z" fill="var(--svg-icon-tint)" opacity="0.4"></path><path d="M 1.82 17 C 1.82 16.448 2.267 16 2.82 16 L 20.82 16 C 21.372 16 21.82 16.448 21.82 17 L 21.82 18 C 21.82 20.209 20.029 22 17.82 22 L 5.82 22 C 3.61 22 1.82 20.209 1.82 18 Z" fill="var(--svg-icon-tint)" opacity="0.4"></path><path d="M 8.82 10 C 8.82 9.448 9.267 9 9.82 9 L 20.82 9 C 21.372 9 21.82 9.448 21.82 10 L 21.82 14 C 21.82 14.552 21.372 15 20.82 15 L 9.82 15 C 9.267 15 8.82 14.552 8.82 14 Z" fill="var(--svg-icon-tint)"></path><path d="M 1.82 10 C 1.82 9.448 2.267 9 2.82 9 L 6.82 9 C 7.372 9 7.82 9.448 7.82 10 L 7.82 14 C 7.82 14.552 7.372 15 6.82 15 L 2.82 15 C 2.267 15 1.82 14.552 1.82 14 Z" fill="var(--svg-icon-tint)"></path></svg></div>
							<div class="title">Nested Scroll</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('star-rating')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 11.399 6.884 C 11.645 6.386 12.355 6.386 12.601 6.884 L 13.705 9.122 C 13.803 9.32 13.992 9.457 14.21 9.489 L 16.68 9.848 C 17.229 9.928 17.449 10.603 17.051 10.99 L 15.264 12.733 C 15.106 12.887 15.034 13.108 15.071 13.326 L 15.493 15.786 C 15.587 16.333 15.013 16.75 14.521 16.492 L 12.312 15.331 C 12.117 15.228 11.883 15.228 11.688 15.331 L 9.479 16.492 C 8.987 16.75 8.413 16.333 8.507 15.786 L 8.929 13.326 C 8.966 13.108 8.894 12.887 8.736 12.733 L 6.949 10.99 C 6.551 10.603 6.771 9.928 7.32 9.848 L 9.79 9.489 C 10.008 9.457 10.197 9.32 10.295 9.122 Z" fill="var(--svg-icon-tint)"></path></svg></div>
							<div class="title">Star Rating</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('swipe-menu')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 17.33 C 2 16.595 2.595 16 3.33 16 L 21 16 C 21.552 16 22 16.448 22 17 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.4"></path><path d="M 2 10 C 2 9.448 2.448 9 3 9 L 14 9 C 14.552 9 15 9.448 15 10 L 15 14 C 15 14.552 14.552 15 14 15 L 3 15 C 2.448 15 2 14.552 2 14 Z M 19 9 C 20.657 9 22 10.343 22 12 C 22 13.657 20.657 15 19 15 C 17.343 15 16 13.657 16 12 C 16 10.343 17.343 9 19 9 Z" fill="var(--svg-icon-tint)"></path><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 7 C 22 7.552 21.552 8 21 8 L 3 8 C 2.448 8 2 7.552 2 7 Z" fill="var(--svg-icon-tint)" opacity="0.4"></path></svg></div>
							<div class="title">Swipe Menu</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('switch-sheet')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 15.667 13.333 C 17.139 13.333 18.333 14.527 18.333 16 C 18.333 17.473 17.139 18.667 15.667 18.667 C 14.194 18.667 13 17.473 13 16 C 13 14.527 14.194 13.333 15.667 13.333 Z" fill="var(--svg-icon-tint)"></path><path d="M 8.333 13.333 C 9.806 13.333 11 14.527 11 16 C 11 17.473 9.806 18.667 8.333 18.667 C 6.861 18.667 5.667 17.473 5.667 16 C 5.667 14.527 6.861 13.333 8.333 13.333 Z" fill="var(--svg-icon-tint)" opacity="0.4"></path></svg></div>
							<div class="title">Switch Sheet</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('tab-menu')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 10 15.333 L 14 15.333 L 14 18.667 L 10 18.667 Z" fill="var(--svg-icon-tint)" opacity="0.4"></path><path d="M 5.333 16.333 C 5.333 15.781 5.781 15.333 6.333 15.333 L 9.333 15.333 L 9.333 18.667 L 6.333 18.667 C 5.781 18.667 5.333 18.219 5.333 17.667 Z" fill="var(--svg-icon-tint)"></path><path d="M 18.667 16.333 C 18.667 15.781 18.219 15.333 17.667 15.333 L 14.667 15.333 L 14.667 18.667 L 17.667 18.667 C 18.219 18.667 18.667 18.219 18.667 17.667 Z" fill="var(--svg-icon-tint)" opacity="0.4"></path></svg></div>
							<div class="title">Tab Menu</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('wheel-picker')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 3.667 6 C 3.667 3.791 5.458 2 7.667 2 L 16.333 2 C 18.542 2 20.333 3.791 20.333 6 L 20.333 7 C 20.333 7.552 19.886 8 19.333 8 L 4.667 8 C 4.114 8 3.667 7.552 3.667 7 Z" fill="var(--svg-icon-tint)" opacity="0.4"></path><path d="M 2 11 C 2 9.895 2.895 9 4 9 L 20 9 C 21.105 9 22 9.895 22 11 L 22 13 C 22 14.105 21.105 15 20 15 L 4 15 C 2.895 15 2 14.105 2 13 Z" fill="var(--svg-icon-tint)"></path><path d="M 3.667 17 C 3.667 16.448 4.114 16 4.667 16 L 19.333 16 C 19.886 16 20.333 16.448 20.333 17 L 20.333 18 C 20.333 20.209 18.542 22 16.333 22 L 7.667 22 C 5.458 22 3.667 20.209 3.667 18 Z" fill="var(--svg-icon-tint)" opacity="0.4"></path></svg></div>
							<div class="title">Wheel Picker</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('cover-flow')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 11.333 17.962 C 11.333 18.385 11.068 18.762 10.67 18.904 L 4.673 21.045 C 3.37 21.511 2 20.545 2 19.162 L 2 4.838 C 2 3.455 3.37 2.489 4.673 2.955 L 10.67 5.096 C 11.068 5.238 11.333 5.615 11.333 6.038 Z" fill="var(--svg-icon-tint)"></path><path d="M 22 4.838 C 22 3.455 20.63 2.489 19.327 2.955 L 13.33 5.096 C 12.932 5.238 12.667 5.615 12.667 6.038 L 12.667 17.962 C 12.667 18.385 12.932 18.762 13.33 18.904 L 19.327 21.045 C 20.63 21.511 22 20.545 22 19.162 Z" fill="var(--svg-icon-tint)" opacity="0.4"></path></svg></div>
							<div class="title">Cover Flow</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('cube-effect')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6.743 C 2 5.898 2.531 5.144 3.327 4.859 L 9.997 2.477 C 10.648 2.245 11.333 2.727 11.333 3.419 L 11.333 20.581 C 11.333 21.273 10.648 21.755 9.997 21.523 L 3.327 19.141 C 2.531 18.856 2 18.102 2 17.257 Z" fill="var(--svg-icon-tint)" opacity="0.4"></path><path d="M 12.667 3.419 C 12.667 2.727 13.352 2.245 14.003 2.477 L 20.673 4.859 C 21.469 5.144 22 5.898 22 6.743 L 22 17.257 C 22 18.102 21.469 18.856 20.673 19.141 L 14.003 21.523 C 13.352 21.755 12.667 21.273 12.667 20.581 Z" fill="var(--svg-icon-tint)"></path></svg></div>
							<div class="title">Cube Effect</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('flip-effect')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 11.333 4.667 C 11.333 4.114 10.886 3.667 10.333 3.667 L 4 3.667 C 2.895 3.667 2 4.562 2 5.667 L 2 18.333 C 2 19.438 2.895 20.333 4 20.333 L 10.333 20.333 C 10.886 20.333 11.333 19.886 11.333 19.333 Z" fill="var(--svg-icon-tint)" opacity="0.4"></path><path d="M 20 4.167 C 20 3.891 20.224 3.667 20.5 3.667 L 20.5 3.667 C 21.328 3.667 22 4.338 22 5.167 L 22 18.833 C 22 19.662 21.328 20.333 20.5 20.333 L 20.5 20.333 C 20.224 20.333 20 20.109 20 19.833 Z" fill="var(--svg-icon-tint)" opacity="0.4"></path><path d="M 18.667 4.631 C 18.667 3.309 17.406 2.35 16.131 2.704 L 13.399 3.463 C 12.966 3.583 12.667 3.978 12.667 4.427 L 12.667 19.573 C 12.667 20.022 12.966 20.417 13.399 20.537 L 16.131 21.296 C 17.406 21.65 18.667 20.691 18.667 19.369 Z" fill="var(--svg-icon-tint)"></path></svg></div>
							<div class="title">Flip Effect</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('parallax-scroll')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 12 6.667 C 12 5.562 12.895 4.667 14 4.667 L 17.333 4.667 C 18.438 4.667 19.333 5.562 19.333 6.667 L 19.333 10 C 19.333 11.105 18.438 12 17.333 12 L 14 12 C 12.895 12 12 11.105 12 10 Z" fill="var(--svg-icon-tint)"></path><path d="M 4.667 14 C 4.667 12.895 5.562 12 6.667 12 L 10 12 C 11.105 12 12 12.895 12 14 L 12 17.333 C 12 18.438 11.105 19.333 10 19.333 L 6.667 19.333 C 5.562 19.333 4.667 18.438 4.667 17.333 Z" fill="var(--svg-icon-tint)"></path></svg></div>
							<div class="title">Parallax Scroll</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('pile-effect')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 6.5 4 C 6.224 4 6 3.776 6 3.5 L 6 3.5 C 6 2.672 6.672 2 7.5 2 L 16.5 2 C 17.328 2 18 2.672 18 3.5 L 18 3.5 C 18 3.776 17.776 4 17.5 4 Z" fill="var(--svg-icon-tint)" opacity="0.4"></path><path d="M 4.5 7 C 4.224 7 4 6.776 4 6.5 L 4 6.5 C 4 5.672 4.672 5 5.5 5 L 18.5 5 C 19.328 5 20 5.672 20 6.5 L 20 6.5 C 20 6.776 19.776 7 19.5 7 Z" fill="var(--svg-icon-tint)" opacity="0.7"></path><path d="M 0 2.67 C 0 1.195 1.195 0 2.67 0 L 11.33 0 C 12.805 0 14 1.195 14 2.67 L 14 17.33 C 14 18.805 12.805 20 11.33 20 L 2.67 20 C 1.195 20 0 18.805 0 17.33 Z" transform="translate(5 5) rotate(-90 7 10)" fill="var(--svg-icon-tint)"></path></svg></div>
							<div class="title">Pile Effect</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('shuffle')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 15.174 10.452 L 16.708 9.06 L 15.174 7.667" fill="transparent" stroke-width="1.33" stroke="var(--svg-icon-tint)" stroke-linecap="round" stroke-linejoin="round"></path><path d="M 15.174 16.333 L 16.708 14.94 L 15.174 13.548" fill="transparent" stroke-width="1.33" stroke="var(--svg-icon-tint)" stroke-linecap="round" stroke-linejoin="round"></path><path d="M 16.145 9.06 C 16.145 9.06 13.982 8.542 12.617 9.679 C 11.252 10.815 11.829 12.213 10.776 13.548 C 9.724 14.882 7.708 14.94 7.708 14.94" fill="transparent" stroke-width="1.33" stroke="var(--svg-icon-tint)" stroke-linecap="round" stroke-linejoin="round"></path><path d="M 16.145 14.823 C 16.145 14.823 13.982 15.34 12.617 14.204 C 11.252 13.068 11.829 11.669 10.776 10.335 C 9.724 9.001 7.708 8.942 7.708 8.942" fill="transparent" stroke-width="1.33" stroke="var(--svg-icon-tint)" stroke-linecap="round" stroke-linejoin="round"></path></svg></div>
							<div class="title">Shuffle</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('svg-animation')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 8 12.333 L 10.5 14.833 L 16 9.333" stroke="var(--svg-icon-tint)" fill="transparent" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path></svg></div>
							<div class="title">SVG Animation</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('google-sheets')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 7 8.667 C 7 8.206 7.373 7.833 7.833 7.833 L 7.833 7.833 C 8.294 7.833 8.667 8.206 8.667 8.667 L 8.667 8.667 C 8.667 9.127 8.294 9.5 7.833 9.5 L 7.833 9.5 C 7.373 9.5 7 9.127 7 8.667 Z" fill="var(--svg-icon-tint)"></path><path d="M 7 12 C 7 11.54 7.373 11.167 7.833 11.167 L 7.833 11.167 C 8.294 11.167 8.667 11.54 8.667 12 L 8.667 12 C 8.667 12.46 8.294 12.833 7.833 12.833 L 7.833 12.833 C 7.373 12.833 7 12.46 7 12 Z" fill="var(--svg-icon-tint)"></path><path d="M 7 15.333 C 7 14.873 7.373 14.5 7.833 14.5 L 7.833 14.5 C 8.294 14.5 8.667 14.873 8.667 15.333 L 8.667 15.333 C 8.667 15.794 8.294 16.167 7.833 16.167 L 7.833 16.167 C 7.373 16.167 7 15.794 7 15.333 Z" fill="var(--svg-icon-tint)"></path><path d="M 9.778 8.667 C 9.778 8.206 10.151 7.833 10.611 7.833 L 16.167 7.833 C 16.627 7.833 17 8.206 17 8.667 L 17 8.667 C 17 9.127 16.627 9.5 16.167 9.5 L 10.611 9.5 C 10.151 9.5 9.778 9.127 9.778 8.667 Z" fill="var(--svg-icon-tint)"></path><path d="M 9.778 12 C 9.778 11.54 10.151 11.167 10.611 11.167 L 16.167 11.167 C 16.627 11.167 17 11.54 17 12 L 17 12 C 17 12.46 16.627 12.833 16.167 12.833 L 10.611 12.833 C 10.151 12.833 9.778 12.46 9.778 12 Z" fill="var(--svg-icon-tint)"></path><path d="M 9.778 15.333 C 9.778 14.873 10.151 14.5 10.611 14.5 L 16.167 14.5 C 16.627 14.5 17 14.873 17 15.333 L 17 15.333 C 17 15.794 16.627 16.167 16.167 16.167 L 10.611 16.167 C 10.151 16.167 9.778 15.794 9.778 15.333 Z" fill="var(--svg-icon-tint)"></path></svg></div>
							<div class="title">Google Sheets</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('map')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 1.82 6 C 1.82 3.791 3.61 2 5.82 2 L 17.82 2 C 20.029 2 21.82 3.791 21.82 6 L 21.82 18 C 21.82 20.209 20.029 22 17.82 22 L 5.82 22 C 3.61 22 1.82 20.209 1.82 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 11.82 6.504 C 14.029 6.504 15.82 8.282 15.82 10.476 C 15.82 10.698 15.801 10.915 15.766 11.127 C 15.359 14.488 13.033 16.581 12.155 17.261 C 12.051 17.341 11.976 17.437 11.82 17.437 C 11.663 17.437 11.586 17.34 11.481 17.258 C 10.6 16.576 8.28 14.483 7.873 11.127 C 7.838 10.915 7.82 10.698 7.82 10.476 C 7.82 8.282 9.61 6.504 11.82 6.504 Z M 9.486 10.644 C 9.486 11.933 10.531 12.977 11.82 12.977 C 13.108 12.977 14.153 11.933 14.153 10.644 C 14.153 9.355 13.108 8.311 11.82 8.311 C 10.531 8.311 9.486 9.355 9.486 10.644 Z" fill="var(--svg-icon-tint)"></path></svg></div>
							<div class="title">Map</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('signature-pad')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 8.82 13.068 C 8.56 12.807 8.56 12.385 8.82 12.125 L 13.733 7.212 C 13.993 6.952 14.415 6.952 14.676 7.212 L 16.788 9.324 C 17.048 9.585 17.048 10.007 16.788 10.267 L 11.875 15.18 C 11.615 15.44 11.193 15.44 10.932 15.18 Z" fill="var(--svg-icon-tint)"></path><path d="M 3.096 0.303 C 3.318 0.17 3.6 0.33 3.6 0.589 L 3.6 3.732 C 3.6 3.991 3.318 4.151 3.096 4.018 L 0.953 2.732 C 0.521 2.473 0.521 1.848 0.953 1.589 Z" transform="translate(6.24 13.8) rotate(-45 1.8 2.16)" fill="var(--svg-icon-tint)"></path></svg></div>
							<div class="title">Signature Pad</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('sound-effects')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 14.225 10.793 C 14.471 11.102 14.623 11.529 14.623 12 C 14.623 12.471 14.471 12.898 14.225 13.207" fill="transparent" stroke-width="1.33" stroke="var(--svg-icon-tint)" stroke-linecap="round" stroke-linejoin="round"></path><path d="M 16.224 9.185 C 16.96 9.911 17.417 10.905 17.417 12 C 17.417 13.095 16.96 14.09 16.224 14.816" fill="transparent" stroke-width="1.33" stroke="var(--svg-icon-tint)" stroke-linecap="round" stroke-linejoin="round"></path><path d="M 6.083 10.656 C 6.083 10.288 6.382 9.989 6.75 9.989 L 7.674 9.989 L 11.021 7.835 C 11.464 7.549 12.048 7.868 12.048 8.396 L 12.048 15.604 C 12.048 16.132 11.464 16.451 11.021 16.165 L 7.674 14.011 L 6.75 14.011 C 6.382 14.011 6.083 13.712 6.083 13.344 Z" fill="var(--svg-icon-tint)"></path></svg></div>
							<div class="title">Sound Effects</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('card-swipe')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 3.423 7.423 C 3.423 5.214 5.214 3.423 7.423 3.423 L 16.756 3.423 C 18.965 3.423 20.756 5.214 20.756 7.423 L 20.756 16.756 C 20.756 18.965 18.965 20.756 16.756 20.756 L 7.423 20.756 C 5.214 20.756 3.423 18.965 3.423 16.756 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 9.172 3.377 C 10.734 1.815 13.266 1.815 14.828 3.377 L 20.721 9.269 C 22.283 10.831 22.283 13.364 20.721 14.926 L 14.828 20.819 C 13.266 22.381 10.734 22.381 9.172 20.819 L 3.279 14.926 C 1.717 13.364 1.717 10.831 3.279 9.269 Z" fill="var(--svg-icon-tint)"></path></svg></div>
							<div class="title">Card Swipe</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('custom-effect')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6.2 C 2 5.673 2.31 5.195 2.792 4.981 L 7.063 3.083 C 7.503 2.887 8 3.21 8 3.693 L 8 20.307 C 8 20.79 7.503 21.113 7.063 20.917 L 2.792 19.019 C 2.31 18.805 2 18.327 2 17.8 Z" fill="var(--svg-icon-tint)" opacity="0.4"></path><path d="M 9.333 3.297 C 9.333 2.642 9.954 2.163 10.588 2.33 L 20.509 4.941 C 21.388 5.172 22 5.967 22 6.875 L 22 17.125 C 22 18.033 21.388 18.828 20.509 19.059 L 10.588 21.67 C 9.954 21.837 9.333 21.358 9.333 20.703 Z" fill="var(--svg-icon-tint)"></path></svg></div>
							<div class="title">Custom Effect</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('drag-handle')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 5.333 2.667 L 2.667 0 L 0 2.667" transform="translate(5.667 10.667) rotate(-90 2.667 1.333)" fill="transparent" stroke-width="1.67" stroke="var(--svg-icon-tint)" stroke-linecap="round" stroke-linejoin="round"></path><path d="M 5.333 0 L 2.667 2.667 L 0 0" transform="translate(13 10.667) rotate(-90 2.667 1.333)" fill="transparent" stroke-width="1.67" stroke="var(--svg-icon-tint)" stroke-linecap="round" stroke-linejoin="round"></path></svg></div>
							<div class="title">Drag Handle</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('dynamic-header')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 8 L 2 8 Z" fill="var(--svg-icon-tint)"></path></svg></div>
							<div class="title">Dynamic Header</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('image-panning')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 12 14 C 12 12.895 12.895 12 14 12 L 20 12 C 21.105 12 22 12.895 22 14 L 22 18 C 22 20.209 20.209 22 18 22 L 14 22 C 12.895 22 12 21.105 12 20 Z" fill="var(--svg-icon-tint)"></path></svg></div>
							<div class="title">Image Panning</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('input-data')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 7.333 8.333 C 7.333 7.781 7.781 7.333 8.333 7.333 L 15.667 7.333 C 16.219 7.333 16.667 7.781 16.667 8.333 L 16.667 10.333 C 16.667 10.886 16.219 11.333 15.667 11.333 L 8.333 11.333 C 7.781 11.333 7.333 10.886 7.333 10.333 Z" fill="var(--svg-icon-tint)"></path><path d="M 7.333 13.667 C 7.333 13.114 7.781 12.667 8.333 12.667 L 15.667 12.667 C 16.219 12.667 16.667 13.114 16.667 13.667 L 16.667 15.667 C 16.667 16.219 16.219 16.667 15.667 16.667 L 8.333 16.667 C 7.781 16.667 7.333 16.219 7.333 15.667 Z" fill="var(--svg-icon-tint)" opacity="0.4"></path></svg></div>
							<div class="title">Input Data</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('input-validation')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 7.333 8.333 C 7.333 7.781 7.781 7.333 8.333 7.333 L 15.667 7.333 C 16.219 7.333 16.667 7.781 16.667 8.333 L 16.667 10.333 C 16.667 10.886 16.219 11.333 15.667 11.333 L 8.333 11.333 C 7.781 11.333 7.333 10.886 7.333 10.333 Z" fill="var(--svg-icon-tint)" opacity="0.4"></path><path d="M 7.333 13.667 C 7.333 13.114 7.781 12.667 8.333 12.667 L 15.667 12.667 C 16.219 12.667 16.667 13.114 16.667 13.667 L 16.667 15.667 C 16.667 16.219 16.219 16.667 15.667 16.667 L 8.333 16.667 C 7.781 16.667 7.333 16.219 7.333 15.667 Z" fill="var(--svg-icon-tint)"></path></svg></div>
							<div class="title">Input Validation</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('like-animation')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 5.28 0 C 7.017 0 7.747 2.366 6.357 3.755 C 4.968 5.144 3.543 5.905 3.543 5.905 C 3.543 5.905 2.118 5.144 0.728 3.755 C -0.661 2.365 0.069 -0 1.806 0 C 3.543 0 3.543 1.701 3.543 1.701 C 3.543 1.701 3.543 0 5.28 0 Z" transform="translate(11.213 11.787) rotate(15 3.543 2.953)" fill="var(--svg-icon-tint)"></path><path d="M 5.28 0 C 7.017 -0 7.747 2.365 6.357 3.755 C 4.968 5.144 3.543 5.905 3.543 5.905 C 3.543 5.905 2.118 5.144 0.728 3.755 C -0.661 2.366 0.069 0 1.806 0 C 3.543 0 3.543 1.701 3.543 1.701 C 3.543 1.701 3.543 0 5.28 0 Z" transform="translate(5.701 6.669) rotate(-15 3.543 2.953)" fill="var(--svg-icon-tint)" opacity="0.4"></path></svg></div>
							<div class="title">Like Animation</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('like-counter')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 14.778 7.333 C 17.556 7.333 18.724 11.072 16.502 13.268 C 14.279 15.464 12 16.667 12 16.667 C 12 16.667 9.721 15.464 7.498 13.268 C 5.276 11.072 6.444 7.333 9.222 7.333 C 12 7.333 12 10.022 12 10.022 C 12 10.022 12 7.333 14.778 7.333 Z" fill="var(--svg-icon-tint)"></path></svg></div>
							<div class="title">Like Counter</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('lock-screen')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 7.333 11 C 7.333 10.448 7.781 10 8.333 10 L 15.667 10 C 16.219 10 16.667 10.448 16.667 11 L 16.667 15.667 C 16.667 16.219 16.219 16.667 15.667 16.667 L 8.333 16.667 C 7.781 16.667 7.333 16.219 7.333 15.667 Z" fill="var(--svg-icon-tint)"></path><path d="M 12 7.333 C 13.289 7.333 14.333 8.378 14.333 9.667 C 14.333 10.955 13.289 12 12 12 C 10.711 12 9.667 10.955 9.667 9.667 C 9.667 8.378 10.711 7.333 12 7.333 Z" fill="transparent" stroke-width="1.67" stroke="var(--svg-icon-tint)"></path></svg></div>
							<div class="title">Lock Screen</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('long-press-menu')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 16.667 10.667 C 17.771 10.667 18.667 11.562 18.667 12.667 C 18.667 13.771 17.771 14.667 16.667 14.667 C 15.562 14.667 14.667 13.771 14.667 12.667 C 14.667 11.562 15.562 10.667 16.667 10.667 Z" fill="var(--svg-icon-tint)" opacity="0.4"></path><path d="M 12 8 C 13.105 8 14 8.895 14 10 C 14 11.105 13.105 12 12 12 C 10.895 12 10 11.105 10 10 C 10 8.895 10.895 8 12 8 Z" fill="var(--svg-icon-tint)"></path><path d="M 7.333 10.667 C 8.438 10.667 9.333 11.562 9.333 12.667 C 9.333 13.771 8.438 14.667 7.333 14.667 C 6.229 14.667 5.333 13.771 5.333 12.667 C 5.333 11.562 6.229 10.667 7.333 10.667 Z" fill="var(--svg-icon-tint)" opacity="0.4"></path></svg></div>
							<div class="title">Long Press Menu</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('perspective-3d')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 6.913 22 C 5.987 22 5.182 21.364 4.967 20.463 L 2.586 10.463 C 2.287 9.206 3.24 8 4.532 8 L 19.468 8 C 20.76 8 21.713 9.206 21.414 10.463 L 19.033 20.463 C 18.818 21.364 18.013 22 17.087 22 Z" fill="var(--svg-icon-tint)"></path><path d="M 3.833 7 C 3.557 7 3.333 6.776 3.333 6.5 L 3.333 6.5 C 3.333 5.672 4.005 5 4.833 5 L 19.167 5 C 19.995 5 20.667 5.672 20.667 6.5 L 20.667 6.5 C 20.667 6.776 20.443 7 20.167 7 Z" fill="var(--svg-icon-tint)" opacity="0.7"></path><path d="M 5.167 4 C 4.891 4 4.667 3.776 4.667 3.5 L 4.667 3.5 C 4.667 2.672 5.338 2 6.167 2 L 17.833 2 C 18.662 2 19.333 2.672 19.333 3.5 L 19.333 3.5 C 19.333 3.776 19.109 4 18.833 4 Z" fill="var(--svg-icon-tint)" opacity="0.4"></path></svg></div>
							<div class="title">Perspective 3D</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('progress-bar')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 1.82 6 C 1.82 3.791 3.61 2 5.82 2 L 17.82 2 C 20.029 2 21.82 3.791 21.82 6 L 21.82 18 C 21.82 20.209 20.029 22 17.82 22 L 5.82 22 C 3.61 22 1.82 20.209 1.82 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 5.153 17 C 5.153 16.08 5.899 15.333 6.82 15.333 L 16.82 15.333 C 17.74 15.333 18.486 16.08 18.486 17 L 18.486 17 C 18.486 17.92 17.74 18.667 16.82 18.667 L 6.82 18.667 C 5.899 18.667 5.153 17.92 5.153 17 Z" fill="var(--svg-icon-tint)" opacity="0.4"></path><path d="M 5.153 17 C 5.153 16.08 5.899 15.333 6.82 15.333 L 11.486 15.333 C 12.407 15.333 13.153 16.08 13.153 17 L 13.153 17 C 13.153 17.92 12.407 18.667 11.486 18.667 L 6.82 18.667 C 5.899 18.667 5.153 17.92 5.153 17 Z" fill="var(--svg-icon-tint)"></path></svg></div>
							<div class="title">Progress Bar</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('scroll-progress')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 7.333 10.333 C 7.333 9.781 7.781 9.333 8.333 9.333 L 15.667 9.333 C 16.219 9.333 16.667 9.781 16.667 10.333 L 16.667 11.667 C 16.667 12.219 16.219 12.667 15.667 12.667 L 8.333 12.667 C 7.781 12.667 7.333 12.219 7.333 11.667 Z" fill="var(--svg-icon-tint)" opacity="0.4"></path><path d="M 7.333 14.667 C 7.333 14.114 7.781 13.667 8.333 13.667 L 15.667 13.667 C 16.219 13.667 16.667 14.114 16.667 14.667 L 16.667 16 C 16.667 16.552 16.219 17 15.667 17 L 8.333 17 C 7.781 17 7.333 16.552 7.333 16 Z" fill="var(--svg-icon-tint)" opacity="0.4"></path><path d="M 7.333 7.667 C 7.333 7.298 7.632 7 8 7 L 16 7 C 16.368 7 16.667 7.298 16.667 7.667 L 16.667 7.667 C 16.667 8.035 16.368 8.333 16 8.333 L 8 8.333 C 7.632 8.333 7.333 8.035 7.333 7.667 Z" fill="var(--svg-icon-tint)" opacity="0.4"></path><path d="M 7.333 7.667 C 7.333 7.298 7.632 7 8 7 L 12.667 7 C 13.035 7 13.333 7.298 13.333 7.667 L 13.333 7.667 C 13.333 8.035 13.035 8.333 12.667 8.333 L 8 8.333 C 7.632 8.333 7.333 8.035 7.333 7.667 Z" fill="var(--svg-icon-tint)"></path></svg></div>
							<div class="title">Scroll Progress</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('show-password')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 10.6 12 C 10.6 11.227 11.227 10.6 12 10.6 L 12 10.6 C 12.773 10.6 13.4 11.227 13.4 12 L 13.4 12 C 13.4 12.773 12.773 13.4 12 13.4 L 12 13.4 C 11.227 13.4 10.6 12.773 10.6 12 Z" fill="var(--svg-icon-tint)"></path><path d="M 12.166 7.833 C 14.892 7.833 17.161 9.42 17.811 12 C 17.161 14.58 14.892 16.167 12.166 16.167 C 9.44 16.167 7.127 14.58 6.478 12 C 7.127 9.42 9.44 7.833 12.166 7.833 Z M 9.333 12 C 9.333 13.473 10.527 14.667 12 14.667 C 13.473 14.667 14.667 13.473 14.667 12 C 14.667 10.527 13.473 9.333 12 9.333 C 10.527 9.333 9.333 10.527 9.333 12 Z" fill="var(--svg-icon-tint)"></path></svg></div>
							<div class="title">Show Password</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('slider')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 5.667 12 L 18.333 12" stroke="var(--svg-icon-tint)" fill="transparent" opacity="0.4" stroke-width="2.67" stroke-linecap="round" stroke-linejoin="round"></path><path d="M 12 8.333 C 14.025 8.333 15.667 9.975 15.667 12 C 15.667 14.025 14.025 15.667 12 15.667 C 9.975 15.667 8.333 14.025 8.333 12 C 8.333 9.975 9.975 8.333 12 8.333 Z" fill="var(--svg-icon-tint)"></path></svg></div>
							<div class="title">Slider</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('stories-drag')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 5.333 6.667 C 5.333 5.93 5.93 5.333 6.667 5.333 L 10 5.333 C 10.736 5.333 11.333 5.93 11.333 6.667 L 11.333 6.667 C 11.333 7.403 10.736 8 10 8 L 6.667 8 C 5.93 8 5.333 7.403 5.333 6.667 Z" fill="var(--svg-icon-tint)" opacity="0.4"></path><path d="M 12.667 6.667 C 12.667 5.93 13.264 5.333 14 5.333 L 17.333 5.333 C 18.07 5.333 18.667 5.93 18.667 6.667 L 18.667 6.667 C 18.667 7.403 18.07 8 17.333 8 L 14 8 C 13.264 8 12.667 7.403 12.667 6.667 Z" fill="var(--svg-icon-tint)"></path></svg></div>
							<div class="title">Stories: Drag</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('stories-tap')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 5.333 6.667 C 5.333 5.93 5.93 5.333 6.667 5.333 L 10 5.333 C 10.736 5.333 11.333 5.93 11.333 6.667 L 11.333 6.667 C 11.333 7.403 10.736 8 10 8 L 6.667 8 C 5.93 8 5.333 7.403 5.333 6.667 Z" fill="var(--svg-icon-tint)"></path><path d="M 12.667 6.667 C 12.667 5.93 13.264 5.333 14 5.333 L 17.333 5.333 C 18.07 5.333 18.667 5.93 18.667 6.667 L 18.667 6.667 C 18.667 7.403 18.07 8 17.333 8 L 14 8 C 13.264 8 12.667 7.403 12.667 6.667 Z" fill="var(--svg-icon-tint)" opacity="0.4"></path></svg></div>
							<div class="title">Stories: Tap</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('toast-prompt')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18.333 C 22 20.542 20.209 22.333 18 22.333 L 6 22.333 C 3.791 22.333 2 20.542 2 18.333 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 12 6.333 C 15.13 6.333 17.667 8.87 17.667 12 C 17.667 15.13 15.13 17.667 12 17.667 C 8.87 17.667 6.333 15.13 6.333 12 C 6.333 8.87 8.87 6.333 12 6.333 Z" fill="transparent" stroke-width="1.33" stroke="var(--svg-icon-tint)"></path><path d="M 12 13 C 12.552 13 13 13.448 13 14 C 13 14.552 12.552 15 12 15 C 11.448 15 11 14.552 11 14 C 11 13.448 11.448 13 12 13 Z" fill="var(--svg-icon-tint)"></path><path d="M 11.06 9.998 C 11.027 9.457 11.458 9 12 9 L 12 9 C 12.542 9 12.973 9.457 12.94 9.998 L 12.848 11.535 C 12.821 11.983 12.449 12.333 12 12.333 L 12 12.333 C 11.551 12.333 11.179 11.983 11.152 11.535 Z" fill="var(--svg-icon-tint)"></path></svg></div>
							<div class="title">Toast Prompt</div>
						</div>
					</li>
				</ul>
			</li>
			-->
		</ul>
		<ul class="nav--editor" *if="mode === 2">
			<li>
				<div class="title" [innerHTML]="'editor_views' | label"></div>
				<ul class="nav--editor">
					<li *for="let item of supportedViewTypes">
						<div class="btn" [class]="{ disabled: item.disabled }" (click)="onSelect({ type:'view', value: item.type.name })">
							<div class="icon">
								<svg-icon [name]="item.type.name"></svg-icon>
							</div>
							<div class="title" [innerHTML]="item.name"></div>
						</div>
					</li>
				</ul>
			</li>
		</ul>
		<ul class="nav--editor" *if="mode === 3">
			<li>
				<div class="title" [innerHTML]="'editor_view_items' | label"></div>
				<ul class="nav--editor">
					<li *for="let item of supportedViewItemTypes">
						<div class="btn" [class]="{ disabled: item.disabled }" (click)="onSelect({ type:'viewItem', value: item.type.name })" [title]="item.id">
							<div class="icon">
								<svg-icon [name]="item.type.name"></svg-icon>
							</div>
							<div class="title" [innerHTML]="item.name"></div>
						</div>
					</li>
				</ul>
				<div class="abstract" *if="supportedViewItemTypes.length == 0" [innerHTML]="'editor_type_no_items' | label"></div>
			</li>
		</ul>
	</div>
	`
};let MENU_UID = 0;
class MenuService {
  static set active(active) {
    this.active$.next(active);
  }
  static get active() {
    return this.active$.getValue();
  }
  static menu$() {
    return this.getMenu$().pipe(operators.switchMap(menu => {
      this.menu$_.next(menu);
      return this.menu$_;
    }));
  }
  static getMenu$() {
    return HttpService.get$('/api/menu').pipe(operators.map(data => {
      data.menu.sort((a, b) => {
        return a.order - b.order;
      });
      return data.menu;
    }));
  }
  static updateMenu$(menu) {
    return HttpService.put$('/api/menu', menu);
  }
  static createMenuItem$(parentId, order) {
    if (parentId === void 0) {
      parentId = null;
    }
    if (order === void 0) {
      order = 0;
    }
    const payload = {
      parentId: parentId,
      viewId: null,
      order: order * 10,
      name: 'Folder ' + ++MENU_UID
    };
    return HttpService.post$('/api/menu', payload);
  }
  static updateMenuItem$(item) {
    return HttpService.put$(`/api/menu/${item.id}`, item);
  }
  static deleteMenuItem$(item) {
    return HttpService.delete$(`/api/menu/${item.id}`);
  }
  static getModelMenu$(views, editor) {
    if (editor === void 0) {
      editor = false;
    }
    return this.menu$().pipe(operators.map(menu => {
      if (menu && menu.length) {
        menu = menu.filter(x => x.viewId == null || x.viewId == 0 || views.find(v => v.id === x.viewId) != null);
        // menu = menu.filter(x => x.viewId == null || views.find(v => v.id === x.viewId) != null);
        // console.log('getModelMenu$', menu);
        return this.mapMenuItems(menu);
      } else {
        // console.log('MenuService.getModelMenu$.Views', views);
        const keys = {};
        views.forEach(item => {
          if (item.type.name !== ViewType.WaitingRoom.name && (!item.hidden || editor)) {
            let group = keys[item.type.name];
            if (!group) {
              group = keys[item.type.name] = [];
            }
            group.push(item);
          }
        });
        const menu = Object.keys(keys).map(typeName => {
          let name = 'Button';
          switch (typeName) {
            case ViewType.WaitingRoom.name:
              name = 'Waiting Room';
              break;
            case ViewType.Panorama.name:
              name = 'Experience';
              break;
            case ViewType.PanoramaGrid.name:
              name = 'Virtual Tour';
              break;
            case ViewType.Room3d.name:
              name = 'Stanze 3D';
              break;
            case ViewType.Model.name:
              name = 'Modelli 3D';
              break;
            case ViewType.Media.name:
              name = 'Media';
              break;
          }
          return {
            name,
            type: {
              name: 'menu-group'
            },
            items: views.filter(x => x.type.name === typeName && (!x.hidden || editor))
          };
        });
        return menu;
      }
    }));
  }
  static mapMenuItem(item, items) {
    if (item.viewId) {
      return {
        id: item.viewId,
        name: item.name,
        type: {
          name: 'panorama'
        }
      };
    } else {
      return {
        name: item.name,
        type: {
          name: 'menu-group'
        },
        items: this.mapMenuItems(items, item.id)
      };
    }
  }
  static mapMenuItems(items, parentId) {
    if (parentId === void 0) {
      parentId = null;
    }
    return items.filter(item => {
      // console.log('MenuService.mapMenuItems', item);
      return (item.parentId || null) === parentId;
    }).map(item => this.mapMenuItem(item, items)).filter(x => x.id != null || x.items.length > 0);
  }
}
MenuService.active$ = new rxjs.BehaviorSubject(false);
MenuService.menu$_ = new rxjs.BehaviorSubject([]);class DropService {
  static drop$(input) {
    if (rxcomp.isPlatformBrowser && input) {
      const body = document.querySelector('body');
      return rxjs.merge(rxjs.fromEvent(body, 'drop'), rxjs.fromEvent(body, 'dragover')).pipe(operators.map(event => {
        // console.log('DropService.drop$', event);
        event.preventDefault();
        if (event.target === input) {
          input.files = event.dataTransfer.files;
        }
        return;
      }));
    } else {
      return rxjs.EMPTY;
    }
  }
  static change$(input) {
    if (rxcomp.isPlatformBrowser && input) {
      return rxjs.fromEvent(input, 'change').pipe(operators.filter(event => input.files && input.files.length), operators.map(event => Array.from(input.files)));
    } else {
      return rxjs.EMPTY;
    }
  }
  static asset$(input, previews) {
    if (previews === void 0) {
      previews = [];
    }
    return this.change$(input).pipe(operators.switchMap(files => {
      previews.length = files.length;
      previews.fill(null);
      // output.previews = files.map(() => null);
      const uploads$ = files.map((file, i) => this.read$(file, i, previews).pipe(operators.map(() => file), operators.switchMap(file => AssetService.upload$([file])), operators.switchMap(uploads => {
        const upload = uploads[0];
        const asset = Asset.fromUrl(upload.url);
        return AssetService.assetCreate$(asset);
      })));
      return rxjs.combineLatest(uploads$);
    }));
  }
  static read$(file, i, previews) {
    if (previews === void 0) {
      previews = [];
    }
    const reader = new FileReader();
    const reader$ = rxjs.fromEvent(reader, 'load').pipe(operators.switchMap(event => {
      const blob = event.target.result;
      return this.resize$(blob);
    }), operators.tap(resized => {
      previews[i] = resized;
    }));
    reader.readAsDataURL(file);
    return reader$;
  }
  static resize$(blob) {
    return rxjs.from(this.resize_(blob));
  }
  static resize_(blob) {
    return new Promise((resolve, reject) => {
      const img = document.createElement('img');
      img.onload = function () {
        const MAX_WIDTH = 320;
        const MAX_HEIGHT = 240;
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        let width = img.width;
        let height = img.height;
        if (width > height) {
          if (width > MAX_WIDTH) {
            height *= MAX_WIDTH / width;
            width = MAX_WIDTH;
          }
        } else {
          if (height > MAX_HEIGHT) {
            width *= MAX_HEIGHT / height;
            height = MAX_HEIGHT;
          }
        }
        canvas.width = width;
        canvas.height = height;
        ctx.drawImage(img, 0, 0, width, height);
        const dataUrl = canvas.toDataURL('image/jpeg', 0.9);
        resolve(dataUrl);
      };
      img.onerror = function () {
        reject(blob);
      };
      img.src = blob;
    });
  }
}class ControlComponent extends rxcomp.Component {
  onChanges() {
    const {
      node
    } = rxcomp.getContext(this);
    // console.log(this, node, this.control);
    const control = this.control;
    const flags = control.flags;
    Object.keys(flags).forEach(key => {
      flags[key] ? node.classList.add(key) : node.classList.remove(key);
    });
  }
}
ControlComponent.meta = {
  selector: '[control]',
  inputs: ['control']
};class ControlAssetComponent extends ControlComponent {
  onInit() {
    this.label = this.label || 'label';
    this.disabled = this.disabled || false;
    this.accept = this.accept || 'image/png, image/jpeg';
    const {
      node
    } = rxcomp.getContext(this);
    const input = node.querySelector('input');
    input.setAttribute('accept', this.accept);
    DropService.drop$(input).pipe(operators.takeUntil(this.unsubscribe$)).subscribe();
    DropService.change$(input).pipe(operators.switchMap(files => {
      const uploads$ = files.map((file, i) => AssetService.upload$([file]).pipe(operators.switchMap(uploads => AssetService.createOrUpdateAsset$(uploads, this.control))));
      return rxjs.combineLatest(uploads$);
    }), operators.takeUntil(this.unsubscribe$)).subscribe(assets => {
      // console.log('ControlAssetComponent.change$', assets);
      this.control.value = assets[0];
    });
  }
}
ControlAssetComponent.meta = {
  selector: '[control-asset]',
  inputs: ['control', 'label', 'disabled', 'accept'],
  template: /* html */`
		<div class="group--form" [class]="{ required: control.validators.length, disabled: disabled }">
			<div class="control--head">
				<label [innerHTML]="label"></label>
				<span class="required__badge" [innerHTML]="'required' | label"></span>
			</div>
			<div class="group--picture">
				<div class="group--picture__info">
					<span [innerHTML]="'browse' | label"></span>
				</div>
				<img [lazy]="control.value | asset" [size]="{ width: 320, height: 240 }" *if="control.value && control.value.type.name === 'image'" />
				<video [src]="control.value | asset" *if="control.value && control.value.type.name === 'video'"></video>
				<input type="file">
			</div>
			<div class="file-name" *if="control.value" [innerHTML]="control.value.file"></div>
		</div>
		<errors-component [control]="control"></errors-component>
	`
};class ControlMenuComponent extends ControlAssetComponent {
  static itemToFormGroup(item) {
    return new rxcompForm.FormGroup({
      id: item.id,
      parentId: item.parentId,
      viewId: item.viewId,
      name: item.name,
      items: new rxcompForm.FormArray()
    });
  }

  /*
  static newFormGroup(parentId = null) {
  	return new FormGroup({
  		id: null,
  		parentId: parentId,
  		viewId: null,
  		name: 'Folder ' + (++MENU_UID),
  		items: new FormArray(),
  	});
  }
  */

  onInit() {
    this.dropdownId = DropdownDirective.nextId();
    this.controls = this.control.controls;
    EditorService.viewIdOptions$().pipe(operators.first()).subscribe(options => {
      this.controls.viewId.options = options;
    });
  }
  onAddItem() {
    MenuService.createMenuItem$(this.controls.id.value, this.controls.items.length).pipe(operators.first()).subscribe(item => {
      this.controls.items.push(ControlMenuComponent.itemToFormGroup(item));
    });
    // this.controls.items.push(ControlMenuComponent.newFormGroup(this.controls.id.value));
  }

  onRemoveItem() {
    this.remove.next(this.control);
  }
  onRemoveControl(control) {
    MenuService.deleteMenuItem$(control.value).pipe(operators.first()).subscribe(() => {
      this.controls.items.remove(control);
    });
    // this.controls.items.remove(control);
  }

  onLinkItem() {
    this.link.next(this.control);
  }
  onLinkControl(control) {
    this.link.next(control);
  }
  onItemUp() {
    this.up.next(this.control);
  }
  onItemDown() {
    this.down.next(this.control);
  }
  onUpControl(control) {
    const items = this.controls.items;
    const length = items.controls.length;
    let index = items.controls.indexOf(control);
    items.controls.splice(index, 1);
    if (index > 0) {
      index--;
    } else {
      index = length - 1;
    }
    items.insert(control, index);
  }
  onDownControl(control) {
    const items = this.controls.items;
    const length = items.controls.length;
    let index = items.controls.indexOf(control);
    items.controls.splice(index, 1);
    if (index < length - 1) {
      index++;
    } else {
      index = 0;
    }
    items.insert(control, index);
  }
  setView(view) {
    // console.log('ControlMenuComponent.setView', view.id);
    const payload = Object.assign({}, this.control.value);
    payload.viewId = view.id;
    if (view.id) {
      payload.name = view.name;
    }
    MenuService.updateMenuItem$(payload).pipe(operators.first()).subscribe(() => {
      this.controls.viewId.value = view.id;
      if (view.id) {
        this.controls.name.value = view.name;
        // clear sub items
        this.controls.items.controls = [];
        this.controls.items.switchSubjects_();
      }
      // this.change.next(value);
    });
  }

  onTextDidChange(event) {
    // console.log('ControlMenuComponent.onTextDidChange', this.controls.name.value);
    MenuService.updateMenuItem$(this.control.value).pipe(operators.first()).subscribe();
  }
  hasOption(item) {
    return this.controls.viewId.value === item.id;
  }
  onDropped(id) {
    // console.log('ControlMenuComponent.onDropped', id);
  }
}
ControlMenuComponent.meta = {
  selector: '[control-menu]',
  outputs: ['remove', 'link', 'up', 'down'],
  inputs: ['control'],
  template: /* html */`
		<div class="group--form">
			<button type="button" class="control-menu__link" [class]="{ active: control.controls.viewId.value }" (click)="onLinkItem($event)" [dropdown]="dropdownId" (dropped)="onDropped($event)">
				<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#link"></use></svg>
				<div class="dropdown" [dropdown-item]="dropdownId">
					<div class="category">View</div>
					<ul class="nav--dropdown">
						<li (click)="setView(item)" [class]="{ empty: item.id == null }" *for="let item of control.controls.viewId.options">
							<span [class]="{ active: hasOption(item) }" [innerHTML]="item.name"></span>
						</li>
					</ul>
				</div>
			</button>
			<input type="text" class="control--text" [formControl]="control.controls.name" placeholder="Name" (change)="onTextDidChange($event)" />
			<!--
			<button type="button" class="control-menu__add" (click)="onAddItem($event)">
				<span [innerHTML]="control.controls.viewId.value"></span>
			</button>
			-->
			<!--
			<select class="control--select" [formControl]="control.controls.viewId">
				<option [value]="item.id" *for="let item of control.controls.viewId.options" [innerHTML]="item.name"></option>
			</select>
			-->
			<button type="button" class="control-menu__up" (click)="onItemUp($event)">
				<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#up"></use></svg>
			</button>
			<button type="button" class="control-menu__down" (click)="onItemDown($event)">
				<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#down"></use></svg>
			</button>
			<button type="button" class="control-menu__add" (click)="onAddItem($event)" *if="!control.controls.viewId.value">
				<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#add"></use></svg>
			</button>
			<button type="button" class="control-menu__remove" (click)="onRemoveItem($event)">
				<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#remove"></use></svg>
			</button>
		</div>
		<div class="group--items">
			<div control-menu *for="let sub of control.controls.items.controls" [control]="sub" (remove)="onRemoveControl($event)" (link)="onLinkControl($event)" (up)="onUpControl($event)" (down)="onDownControl($event)"></div>
		</div>
	`
};class MenuBuilderComponent extends rxcomp.Component {
  onInit() {
    this.changes = 0;
    this.form = null;
    MenuService.getMenu$().pipe(operators.first()).subscribe(menu => this.initForm(menu));
  }
  initForm(menu) {
    if (menu === void 0) {
      menu = [];
    }
    const items = this.menuToControls(menu);
    // console.log('MenuBuilderComponent', items);
    const form = this.form = new rxcompForm.FormGroup({
      items: items
    });
    this.controls = form.controls;
    form.changes$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(changes => {
      // console.log('MenuBuilderComponent', changes);
      this.changes++;
      this.pushChanges();
    });
  }
  onLinkControl(control) {}
  onUpControl(control) {
    const items = this.controls.items;
    const length = items.controls.length;
    let index = items.controls.indexOf(control);
    items.controls.splice(index, 1);
    if (index > 0) {
      index--;
    } else {
      index = length - 1;
    }
    items.insert(control, index);
  }
  onDownControl(control) {
    const items = this.controls.items;
    const length = items.controls.length;
    let index = items.controls.indexOf(control);
    items.controls.splice(index, 1);
    if (index < length - 1) {
      index++;
    } else {
      index = 0;
    }
    items.insert(control, index);
  }
  onAddItem() {
    MenuService.createMenuItem$(null, this.controls.items.length).pipe(operators.first()).subscribe(item => {
      this.controls.items.push(ControlMenuComponent.itemToFormGroup(item));
    });
    // this.controls.items.push(ControlMenuComponent.newFormGroup());
  }

  onRemoveControl(control) {
    MenuService.deleteMenuItem$(control.value).pipe(operators.first()).subscribe(() => {
      this.controls.items.remove(control);
    });
    // this.controls.items.remove(control);
  }

  isValid() {
    const isValid = this.form.valid;
    return isValid;
  }
  onSubmit(event) {
    if (this.form.valid) {
      const changes = this.form.value;
      const menu = this.controlsToMenu(changes);
      MenuService.updateMenu$(menu);
    } else {
      this.form.touched = true;
    }
  }
  menuToControls(menu, parentId) {
    if (parentId === void 0) {
      parentId = null;
    }
    const items = new rxcompForm.FormArray(menu.filter(x => {
      return (x.parentId || null) === parentId;
    }).map(x => {
      const subitems = this.menuToControls(menu, x.id);
      return new rxcompForm.FormGroup({
        id: x.id,
        parentId: x.parentId,
        viewId: x.viewId,
        name: x.name,
        items: subitems
      });
    }));
    return items;
  }
  controlsToMenu(changes) {
    const menu = [];
    const pushItem = items => {
      if (items) {
        items.forEach((item, i) => {
          const menuItem = Object.assign({}, item);
          menuItem.order = i * 10;
          delete menuItem.items;
          menu.push(menuItem);
          pushItem(item.items);
        });
      }
    };
    pushItem(changes.items);
    return menu;
  }
}
MenuBuilderComponent.meta = {
  selector: '[menu-builder]',
  inputs: ['views'],
  template: /* html */`
	<div class="group--head">
		<div class="title" [innerHTML]="'editor_menu' | label"></div>
	</div>
	<div class="group--main">
		<div class="nav--tree" *if="form">
			<form class="form" [formGroup]="form" (submit)="isValid() && onSubmit()" name="form" role="form" novalidate autocomplete="off">
				<div class="abstract" *if="controls.items.controls.length == 0" [innerHTML]="'editor_add_item' | label"></div>
				<div *for="let control of controls.items.controls">
					<div control-menu [control]="control" (remove)="onRemoveControl($event)" (link)="onLinkControl($event)" (up)="onUpControl($event)" (down)="onDownControl($event)"></div>
				</div>
			</form>
		</div>
	</div>
	<div class="group--foot">
		<button type="button" class="btn--mode" (click)="onAddItem($event)" [innerHTML]="'editor_add' | label"></button>
		<button type="button" class="btn--mode" (click)="isValid() && onSubmit()" *if="changes > 1" [innerHTML]="'editor_save' | label"></button>
	</div>
	`
};class NavmapItemModalComponent extends rxcomp.Component {
  get data() {
    let data = null;
    const {
      parentInstance
    } = rxcomp.getContext(this);
    if (parentInstance instanceof ModalOutletComponent) {
      data = parentInstance.modal.data;
    }
    return data;
  }
  get navmap() {
    let navmap = null;
    const data = this.data;
    if (data) {
      navmap = data.navmap;
    }
    return navmap;
  }
  get position() {
    let position = [0, 0, 0];
    const data = this.data;
    if (data) {
      position = [data.hit.x, data.hit.y, 0];
    }
    return position;
  }
  onInit() {
    const position = this.position;
    this.error = null;
    const form = this.form = new rxcompForm.FormGroup({
      type: ViewItemType.Nav,
      title: null,
      abstract: null,
      viewId: new rxcompForm.FormControl(null, rxcompForm.RequiredValidator()),
      keepOrientation: false,
      important: false,
      transparent: false,
      position: new rxcompForm.FormControl(position, rxcompForm.RequiredValidator()),
      asset: null
    });
    this.controls = form.controls;
    form.changes$.subscribe(changes => {
      // console.log('NavmapItemModalComponent.form.changes$', changes, form.valid, form);
      this.pushChanges();
    });
    EditorService.viewIdOptions$().pipe(operators.first()).subscribe(options => {
      this.controls.viewId.options = options;
      this.pushChanges();
    });
  }
  onSubmit() {
    if (this.form.valid) {
      this.form.submitted = true;
      const item = Object.assign({}, this.form.value);
      item.viewId = parseInt(item.viewId);
      // console.log('NavmapItemModalComponent.onSubmit', this.navmap, item);
      NavmapService.itemCreate$(this.navmap, item).pipe(operators.first()).subscribe(response => {
        // console.log('NavmapItemModalComponent.onSubmit.success', response);
        ModalService.resolve(response);
      }, error => {
        console.log('NavmapItemModalComponent.onSubmit.error', error);
        this.error = error;
        this.form.submitted = false;
        // this.form.reset();
      });
    } else {
      this.form.touched = true;
    }
  }
  onClose() {
    ModalService.reject();
  }
}
NavmapItemModalComponent.meta = {
  selector: '[navmap-item-modal]',
  template: /* html */`
		<div class="modal__header">
			<button type="button" class="btn--close" (click)="onClose()">
				<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#close"></use></svg>
			</button>
		</div>
		<div class="container">
			<div class="form">
				<div class="title">Create Map Nav.</div>
				<form [formGroup]="form" (submit)="onSubmit()" name="form" role="form" novalidate autocomplete="off">
					<div class="form-controls">
						<div control-text [control]="controls.title" label="Title"></div>
						<div control-textarea [control]="controls.abstract" label="Abstract"></div>
						<div control-custom-select [control]="controls.viewId" label="NavToView"></div>
						<div control-vector [control]="controls.position" label="Position" [precision]="3" [disabled]="true"></div>
					</div>
					<div class="group--cta">
						<button type="submit" class="btn--accept">
							<span>Create</span>
						</button>
					</div>
				</form>
			</div>
		</div>
	`
};
NavmapItemModalComponent.chunk = () => /* html */'<div class="nav-modal" navmap-item-modal></div>';class NavmapModalComponent extends rxcomp.Component {
  onInit() {
    this.error = null;
    const form = this.form = new rxcompForm.FormGroup({
      name: new rxcompForm.FormControl(null, rxcompForm.RequiredValidator()),
      asset: new rxcompForm.FormControl(null, rxcompForm.RequiredValidator())
    });
    this.controls = form.controls;
    form.changes$.subscribe(changes => {
      // console.log('NavmapModalComponent.form.changes$', changes, form.valid, form);
      this.pushChanges();
    });
  }
  onSubmit() {
    if (this.form.valid) {
      this.form.submitted = true;
      const values = this.form.value;
      const navmap = {
        name: values.name,
        asset: values.asset
      };
      // console.log('NavmapModalComponent.onSubmit.navmap', navmap);
      return NavmapService.navmapCreate$(navmap).pipe(operators.first()).subscribe(response => {
        // console.log('NavmapModalComponent.onSubmit.success', response);
        ModalService.resolve(response);
      }, error => {
        console.log('NavmapModalComponent.onSubmit.error', error);
        this.error = error;
        this.form.reset();
      });
    } else {
      this.form.touched = true;
    }
  }
  onClose() {
    ModalService.reject();
  }
}
NavmapModalComponent.meta = {
  selector: '[navmap-modal]',
  template: /* html */`
		<div class="modal__header">
			<button type="button" class="btn--close" (click)="onClose()">
				<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#close"></use></svg>
			</button>
		</div>
		<div class="container">
			<div class="form">
				<div class="title">Create Map.</div>
				<form [formGroup]="form" (submit)="onSubmit()" name="form" role="form" novalidate autocomplete="off">
					<div class="form-controls">
						<div control-text [control]="controls.name" label="Name"></div>
						<div control-asset [control]="controls.asset" label="Image" accept="image/png"></div>
					</div>
					<div class="description">Formato immagine .png con trasparenza (2048x1024 o 1024x512)</div>
					<div class="group--cta">
						<button type="submit" class="btn--accept">
							<span>Create</span>
						</button>
					</div>
				</form>
			</div>
		</div>
	`
};
NavmapModalComponent.chunk = () => /* html */'<div class="panorama-modal" navmap-modal></div>';class NavmapBuilderComponent extends rxcomp.Component {
  onInit() {
    this.navmap = null;
    this.navmaps = [];
    NavmapService.navmapGet$().pipe(operators.first()).subscribe(navmaps => {
      this.navmaps = navmaps;
      this.pushChanges();
    });
  }
  onBack(event) {
    this.navmap = null;
    this.pushChanges();
  }
  onAdd() {
    ModalService.open$({
      template: NavmapModalComponent.chunk()
    }).pipe(operators.first()).subscribe(event => {
      if (event instanceof ModalResolveEvent) {
        this.navmaps.push(event.data);
        this.navmap = event.data;
        this.pushChanges();
      }
    });
  }
  onSet(item) {
    this.navmap = this.navmaps.find(x => x.id === item.id);
    this.pushChanges();
  }
  onAddItem(navmap, hit) {
    ModalService.open$({
      template: NavmapItemModalComponent.chunk(),
      data: {
        navmap,
        hit
      }
    }).pipe(operators.first()).subscribe(event => {
      if (event instanceof ModalResolveEvent) {
        const items = navmap.items || [];
        items.push(event.data);
        Object.assign(navmap, {
          items
        });
        this.pushChanges();
      }
    });
  }
  onDelete(navmap) {
    const index = this.navmaps.indexOf(navmap);
    if (index !== -1) {
      this.navmaps.splice(index, 1);
    }
    this.navmap = null;
    this.pushChanges();
  }
}
NavmapBuilderComponent.meta = {
  selector: '[navmap-builder]',
  inputs: ['views'],
  template: /* html */`
	<div class="group--head">
		<div class="title" [innerHTML]="'editor_navmaps' | label"></div>
	</div>
	<div class="group--main">
		<!-- listing navmaps -->
		<div class="listing--navmaps" *if="!navmap">
			<div class="abstract" *if="navmaps.length == 0" [innerHTML]="'editor_add_item' | label"></div>
			<div class="listing__item" *for="let item of navmaps">
				<div class="card--navmap" (click)="onSet(item)">
					<div class="card__picture">
						<img [src]="item.asset | asset" *if="item.asset" />
					</div>
					<div class="card__content">
						<div class="card__name" [innerHTML]="item.name"></div>
					</div>
				</div>
			</div>
		</div>
		<!-- navmap edit -->
		<div class="navmap" navmap-edit [navmap]="navmap" (delete)="onDelete($event)" *if="navmap">
			<form class="form" [formGroup]="form" (submit)="onSubmit()" name="form" role="form" novalidate autocomplete="off">
				<div class="title"><span [innerHTML]="navmap.name"></span> <span [innerHTML]="navmap.id"></span></div>
				<div class="form-controls">
					<div control-text [control]="controls.name" label="Name"></div>
					<!--
					<div control-asset [control]="controls.asset" label="Image" accept="image/png"></div>
					-->
				</div>
				<div class="group--cta">
					<button type="submit" class="btn--accept">
						<span [innerHTML]="'editor_save' | label"></span>
					</button>
					<button type="button" class="btn--remove" (click)="onRemove($event)">
						<span [innerHTML]="'editor_remove' | label"></span>
					</button>
				</div>
				<div class="navmap-control" [class]="mode">
					<div class="navmap-control__image">
						<img draggable="false" [src]="navmap.asset | asset" *if="navmap.asset" />
						<div class="navmap__item" [style]="{ left: item.position[0] * 100 + '%', top: item.position[1] * 100 + '%' }" (mousedown)="onMoveItem($event, item)" (click)="onRemoveItem(item)" *for="let item of navmap.items">
							<img draggable="false" [src]="'textures/ui/nav-point.png' | asset" />
							<div class="title" [innerHTML]="item.title" *if="item.title"></div>
						</div>
					</div>
					<ul class="navmap-control__toolbar">
						<li class="nav__item"><span [class]="{ active: mode === 'insert' }" (click)="onToggleMode('insert')"><svg class="pencil" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#pencil"></use></svg></span></li>
						<li class="nav__item"><span [class]="{ active: mode === 'move' }" (click)="onToggleMode('move')"><svg class="move" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#move"></use></svg></span></li>
						<li class="nav__item"><span [class]="{ active: mode === 'remove' }" (click)="onToggleMode('remove')"><svg class="erase" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#erase"></use></svg></span></li>
					</ul>
				</div>
			</form>
		</div>
	</div>
	<div class="group--foot">
		<button type="button" class="btn--mode" (click)="onAdd($event)" [innerHTML]="'editor_add' | label" *if="!navmap"></button>
		<button type="button" class="btn--mode" (click)="onBack($event)" [innerHTML]="'editor_back' | label" *if="navmap"></button>
	</div>
	`
};const NavmapModes = {
  Idle: 'idle',
  Insert: 'insert',
  Remove: 'remove',
  Move: 'move'
};
class ControlEvent {
  constructor(element, event) {
    const rect = element.getBoundingClientRect();
    this.x = (event.clientX - rect.x) / rect.width;
    this.y = (event.clientY - rect.y) / rect.height;
    // console.log(this);
  }
}

class ControlDownEvent extends ControlEvent {}
class ControlMoveEvent extends ControlEvent {}
class ControlUpEvent extends ControlEvent {}
class NavmapEditComponent extends rxcomp.Component {
  onInit() {
    this.mode = NavmapModes.Idle;
    this.error = null;
    const navmap = this.navmap;
    const form = this.form = new rxcompForm.FormGroup({
      name: new rxcompForm.FormControl(navmap.name, rxcompForm.RequiredValidator()),
      asset: new rxcompForm.FormControl(navmap.asset, rxcompForm.RequiredValidator())
    });
    this.controls = form.controls;
    form.changes$.subscribe(changes => {
      // console.log('NavmapEditComponent.form.changes$', changes, form.valid, form);
      this.pushChanges();
    });
    this.insert$().pipe(operators.takeUntil(this.unsubscribe$)).subscribe(event => {
      // console.log('NavmapEditComponent.insert', event);
      const hit = event;
      ModalService.open$({
        template: NavmapItemModalComponent.chunk(),
        data: {
          navmap,
          hit
        }
      }).pipe(operators.first()).subscribe(event => {
        if (event instanceof ModalResolveEvent) {
          const items = navmap.items || [];
          items.push(event.data);
          Object.assign(navmap, {
            items
          });
          this.pushChanges();
        }
      });
    });
  }
  insert$() {
    const {
      node
    } = rxcomp.getContext(this);
    const image = node.querySelector('.navmap-control__image');
    return rxjs.fromEvent(image, 'pointerdown').pipe(operators.filter(x => this.mode === NavmapModes.Insert), operators.map(event => new ControlDownEvent(image, event)));
  }
  onToggleMode(mode) {
    this.mode = this.mode === mode ? NavmapModes.Idle : mode;
    this.pushChanges();
  }
  onMoveItem(event, item) {
    const navmap = this.navmap;
    switch (this.mode) {
      case NavmapModes.Move:
        {
          const {
            node
          } = rxcomp.getContext(this);
          const image = node.querySelector('.navmap-control__image');
          const position = item.position.slice();
          const down = new ControlDownEvent(image, event);
          const move$ = rxjs.fromEvent(image, 'mousemove').pipe(operators.map(event => new ControlMoveEvent(image, event)), operators.tap(event => {
            const diff = {
              x: event.x - down.x,
              y: event.y - down.y
            };
            item.position = [Math.max(0, Math.min(1, position[0] + diff.x)), Math.max(0, Math.min(1, position[1] + diff.y)), 0];
            this.pushChanges();
          }));
          const up$ = rxjs.fromEvent(image, 'mouseup').pipe(operators.map(event => new ControlUpEvent(image, event)), operators.tap(event => {
            const diff = {
              x: event.x - down.x,
              y: event.y - down.y
            };
            item.position = [Math.max(0, Math.min(1, position[0] + diff.x)), Math.max(0, Math.min(1, position[1] + diff.y)), 0];
            // console.log('NavmapEditComponent.onNavmapItem.Update', navmap, item);
            NavmapService.itemUpdate$(navmap, item).pipe(operators.first()).subscribe(item_ => {
              Object.assign(item, item_);
              // console.log('NavmapEditComponent.onNavmapItem.Update');
              this.pushChanges();
            });
          }));
          move$.pipe(operators.takeUntil(up$)).subscribe();
          break;
        }
    }
  }
  onRemoveItem(item) {
    const navmap = this.navmap;
    switch (this.mode) {
      case NavmapModes.Remove:
        NavmapService.itemDelete$(navmap, item).pipe(operators.first()).subscribe(_ => {
          // console.log('NavmapEditComponent.onNavmapItem.Remove');
          const items = navmap.items || [];
          const index = items.indexOf(item);
          if (index !== -1) {
            items.splice(index, 1);
          }
          Object.assign(navmap, {
            items
          });
          this.pushChanges();
        });
        break;
    }
  }
  onSubmit() {
    if (this.form.valid) {
      this.form.submitted = true;
      const values = this.form.value;
      const payload = Object.assign({
        items: []
      }, this.navmap, {
        name: values.name
      });
      // console.log('NavmapEditComponent.onSubmit.navmap', payload);
      NavmapService.navmapUpdate$(payload).pipe(operators.first()).subscribe(response => {
        // console.log('NavmapEditComponent.onSubmit.success', response);
        Object.assign(this.navmap, response);
        this.pushChanges();
      }, error => {
        // console.log('NavmapEditComponent.onSubmit.error', error);
        this.error = error;
        this.form.reset();
      });
    } else {
      this.form.touched = true;
    }
  }
  onRemove() {
    const navmap = this.navmap;
    ModalService.open$({
      template: RemoveModalComponent.chunk(),
      data: {
        item: navmap
      }
    }).pipe(operators.first()).subscribe(event => {
      if (event instanceof ModalResolveEvent) {
        NavmapService.navmapDelete$(navmap).pipe(operators.first()).subscribe(response => {
          this.delete.next(navmap);
        });
      }
    });
  }
}
NavmapEditComponent.meta = {
  selector: '[navmap-edit]',
  outputs: ['delete'],
  inputs: ['navmap']
};class UpdateViewItemComponent extends rxcomp.Component {
  onInit() {
    this.busy = false;
    this.active = false;
    this.useHooks = WebhookService.enabled;
    const form = this.form = new rxcompForm.FormGroup();
    this.controls = form.controls;
    const item = this.item;
    this.originalItem = Object.assign({}, item);
    item.hasChromaKeyColor = item.asset && item.asset.chromaKeyColor ? true : false;
    item.autoplay = item.asset && item.asset.type.name === AssetType.Video.name ? item.asset.autoplay : undefined;
    item.loop = item.asset && item.asset.type.name === AssetType.Video.name ? item.asset.loop : undefined;
    item.assetType = assetGroupTypeFromItem(item).id;
    this.doUpdateForm();
    form.changes$.subscribe(changes => {
      // console.log('UpdateViewItemComponent.form.changes$', changes);
      this.doUpdateItem(changes);
      this.pushChanges();
    });
  }
  getFlagsDidChange(item, changes) {
    const flags = ['hasChromaKeyColor', 'autoplay', 'loop'];
    return flags.reduce((p, c) => {
      const a = changes[c] || false;
      const b = item[c] || false;
      // console.log(c, a, b);
      return p || a !== b;
    }, false);
  }
  getAssetDidChange(item, changes) {
    // console.log('UpdateViewItemComponent.getAssetDidChange', item.asset, changes.asset);
    return AssetService.assetDidChange(item.asset, changes.asset);
  }
  doUpdateItem(changes) {
    const item = this.item;
    const assetDidChange = this.getAssetDidChange(item, changes);
    const flagsDidChange = this.getFlagsDidChange(item, changes);
    // console.log('UpdateViewItemCompoent.doUpdateItem', 'assetDidChange', assetDidChange, 'flagsDidChange', flagsDidChange);
    Object.assign(item, changes);
    if (item.asset) {
      item.asset.chromaKeyColor = item.hasChromaKeyColor ? [0.0, 1.0, 0.0] : null;
      item.asset.autoplay = item.autoplay;
      item.asset.loop = item.loop;
    }
    if (assetDidChange || flagsDidChange) {
      const asset$ = item.asset ? AssetService.assetUpdate$(item.asset) : rxjs.of(null);
      asset$.pipe(operators.switchMap(() => EditorService.inferItemUpdate$(this.view, item)), operators.first()).subscribe();
      // !!! create indices for nextAttendeeStream
      this.view.updateIndices(this.view.items);
      if (typeof item.onUpdateAsset === 'function') {
        item.onUpdateAsset();
      }
    }
    if (typeof item.onUpdate === 'function') {
      item.onUpdate();
    }
  }
  doUpdateForm() {
    const item = this.item;
    const form = this.form;
    if (!this.type || this.type.name !== item.type.name) {
      this.type = item.type;
      Object.keys(this.controls).forEach(key => {
        form.removeKey(key);
      });
      let keys;
      switch (item.type.name) {
        case ViewItemType.Nav.name:
          if (this.useHooks) {
            keys = ['id', 'type', 'title?', 'abstract?', 'viewId?', 'hook?', 'hookExtra?', 'keepOrientation?', 'important?', 'transparent?', 'position', 'rotation', 'scale', 'asset?', 'link?', 'links?'];
          } else {
            keys = ['id', 'type', 'title?', 'abstract?', 'viewId?', 'keepOrientation?', 'important?', 'transparent?', 'position', 'rotation', 'scale', 'asset?', 'link?', 'links?'];
          }
          break;
        case ViewItemType.Plane.name:
          keys = ['id', 'type', 'position', 'rotation', 'scale', 'assetType?', 'asset?', 'hasChromaKeyColor?', 'autoplay?', 'loop?'];
          break;
        case ViewItemType.CurvedPlane.name:
          keys = ['id', 'type', 'position', 'rotation', 'scale', 'radius', 'height', 'arc', 'assetType?', 'asset?', 'hasChromaKeyColor?', 'autoplay?', 'loop?'];
          break;
        case ViewItemType.Texture.name:
          keys = ['id', 'type', 'assetType?', 'asset?', 'hasChromaKeyColor?', 'autoplay?', 'loop?']; // asset, key no id!!
          break;
        case ViewItemType.Model.name:
          if (this.view.type.name === ViewType.Model) {
            keys = ['id', 'type', 'asset?'];
          } else {
            keys = ['id', 'type', 'position', 'rotation', 'asset?'];
          }
          break;
        default:
          keys = ['id', 'type'];
      }
      keys.forEach(key => {
        const optional = key.indexOf('?') !== -1;
        key = key.replace('?', '');
        const value = item[key] != null ? item[key] : null;
        let control;
        switch (key) {
          case 'viewId':
            control = new rxcompForm.FormControl(value, optional ? undefined : rxcompForm.RequiredValidator());
            EditorService.viewIdOptions$().pipe(operators.first()).subscribe(options => {
              control.options = options;
              control.value = control.value || null;
              this.pushChanges();
            });
            break;
          case 'hook':
            control = new rxcompForm.FormControl(value, optional ? undefined : rxcompForm.RequiredValidator());
            if (WebhookService.enabled) {
              const options = environment.webhook.methods.nav.map(x => ({
                id: x,
                name: x
              }));
              options.unshift({
                id: null,
                name: 'select'
              });
              control.options = options;
            }
            control.value = control.value || null;
            this.pushChanges();
            break;
          case 'assetType':
            control = new rxcompForm.FormControl(value, optional ? undefined : rxcompForm.RequiredValidator());
            control.options = Object.keys(AssetGroupType).map(x => AssetGroupType[x]);
            // console.log(control.options);
            break;
          case 'link':
            /*
            const title = item.link ? item.link.title : null;
            const href = item.link ? item.link.href : null;
            const target = '_blank';
            control = new FormGroup({
            	title: new FormControl(title),
            	href: new FormControl(href),
            	target
            });
            */
            break;
          case 'links':
            {
              const links = item.links;
              control = new rxcompForm.FormArray(links.map(link => new rxcompForm.FormGroup({
                title: new rxcompForm.FormControl(link.title),
                href: new rxcompForm.FormControl(link.href),
                target: '_blank'
              })));
              break;
            }
          default:
            control = new rxcompForm.FormControl(value, optional ? undefined : rxcompForm.RequiredValidator());
        }
        form.add(control, key);
      });
      this.controls = form.controls;
    } else {
      Object.keys(this.controls).forEach(key => {
        switch (key) {
          case 'link':
            /*
            const title = item.link ? item.link.title : null;
            const href = item.link ? item.link.href : null;
            const target = '_blank';
            this.controls[key].value = { title, href, target };
            */
            break;
          case 'links':
            {
              const links = item.links.map(link => ({
                title: link.title || null,
                href: link.href || null,
                target: '_blank'
              }));
              const formArray = this.controls[key];
              while (formArray.controls.length > links.length) {
                formArray.remove(formArray.controls[formArray.controls.length - 1]);
              }
              while (formArray.controls.length < links.length) {
                formArray.push(new rxcompForm.FormGroup({
                  title: new rxcompForm.FormControl(null),
                  href: new rxcompForm.FormControl(null),
                  target: '_blank'
                }));
              }
              // console.log(formArray, links);
              formArray.patch(links);
              break;
            }
          case 'hasChromaKeyColor':
            this.controls[key].value = item.asset && item.asset.chromaKeyColor ? true : false;
            break;
          case 'autoplay':
            this.controls[key].value = item.asset && item.asset.autoplay ? true : false;
            break;
          case 'loop':
            this.controls[key].value = item.asset && item.asset.loop ? true : false;
            break;
          case 'assetType':
            this.controls[key].value = assetGroupTypeFromItem(item).id;
            break;
          default:
            this.controls[key].value = item[key] != null ? item[key] : null;
        }
      });
    }
  }
  onAssetTypeDidChange(assetType) {
    const item = this.item;
    const currentType = assetGroupTypeFromItem(item).id;
    // console.log('UpdateViewItemComponent.onAssetTypeDidChange', assetType, currentType);
    if (assetType !== currentType) {
      item.assetType = assetType;
      let asset$ = rxjs.of(null); // AssetService.assetDelete$(item.asset);
      if (assetType !== AssetGroupType.ImageOrVideo.id) {
        asset$ = asset$.pipe(operators.switchMap(() => {
          const asset = assetPayloadFromGroupTypeId(assetType);
          return AssetService.assetCreate$(asset);
        }));
      }
      asset$.pipe(operators.first()).subscribe(asset => {
        // console.log('UpdateViewItemComponent.asset$', asset);
        this.controls.asset.value = asset;
      });
      /*
      asset$.pipe(
      	tap(asset => {
      		item.asset = asset;
      		if (typeof item.onUpdateAsset === 'function') {
      			item.onUpdateAsset();
      		}
      	}),
      	switchMap(() => EditorService.inferItemUpdate$(this.view, item)),
      	first()
      ).subscribe();
      */
    }
  }

  onChanges(changes) {
    // console.log('UpdateViewItemComponent.onChanges', changes);
    this.doUpdateForm();
  }
  onSubmit() {
    if (!this.busy && this.form.valid) {
      this.busy = true;
      this.pushChanges();
      const changes = this.form.value;
      const payload = Object.assign({}, changes);
      if (this.item.type.name === ViewItemType.Nav.name) {
        payload.viewId = payload.viewId || this.view.id;
      }
      const view = this.view;
      const item = new ViewItem(payload);
      EditorService.inferItemUpdate$(view, item).pipe(operators.first()).subscribe(response => {
        // console.log('UpdateViewItemComponent.onSubmit.inferItemUpdate$.success', response);
        EditorService.inferItemUpdateResult$(view, item);
        this.update.next({
          view,
          item
        });
        this.setTimeout(() => {
          this.busy = false;
          this.pushChanges();
        });
      }, error => console.log('UpdateViewItemComponent.onSubmit.inferItemUpdate$.error', error));
      // this.update.next({ view: this.view, item: new ViewItem(payload) });
    } else {
      this.form.touched = true;
    }
  }
  onRemove(event) {
    ModalService.open$({
      template: RemoveModalComponent.chunk(),
      data: {
        item: this.item
      }
    }).pipe(operators.first()).subscribe(event => {
      if (event instanceof ModalResolveEvent) {
        this.delete.next({
          view: this.view,
          item: this.item
        });
      }
    });
  }
  onSelect(event) {
    this.select.next({
      view: this.view,
      item: this.item.selected ? null : this.item
    });
    /*
    this.item.active = !this.item.active;
    this.pushChanges();
    */
  }

  getTitle(item) {
    return LabelPipe.getKeys('editor', item.type.name);
  }
  onAddLink(event) {
    this.controls.links.push(new rxcompForm.FormGroup({
      title: new rxcompForm.FormControl(null),
      href: new rxcompForm.FormControl(null),
      target: '_blank'
    }));
  }
  onRemoveLink(item) {
    this.controls.links.remove(item);
  }
  clearTimeout() {
    if (this.to) {
      clearTimeout(this.to);
    }
  }
  setTimeout(callback, msec) {
    if (msec === void 0) {
      msec = 300;
    }
    this.clearTimeout();
    if (typeof callback === 'function') {
      this.to = setTimeout(callback, msec);
    }
  }
  onDestroy() {
    this.clearTimeout();
  }
}
UpdateViewItemComponent.meta = {
  selector: 'update-view-item',
  outputs: ['select', 'update', 'delete'],
  inputs: ['view', 'item'],
  template: /* html */`
		<div class="group--headline" [class]="{ active: item.selected }" (click)="onSelect($event)">
			<!-- <div class="id" [innerHTML]="item.id"></div> -->
			<div class="icon">
				<svg-icon [name]="item.type.name"></svg-icon>
			</div>
			<div class="title" [innerHTML]="getTitle(item)"></div>
			<svg class="icon--caret-down"><use xlink:href="#caret-down"></use></svg>
		</div>
		<form [formGroup]="form" (submit)="onSubmit()" name="form" role="form" novalidate autocomplete="off" *if="item.selected">
			<div class="form-controls">
				<div control-text [control]="controls.id" label="Id" [disabled]="true"></div>
				<!-- <div control-text [control]="controls.type" label="Type" [disabled]="true"></div> -->
			</div>
			<div class="form-controls" *if="item.type.name == 'nav'">
				<div control-text [control]="controls.title" label="Title"></div>
				<div control-textarea [control]="controls.abstract" label="Abstract"></div>
				<div control-custom-select [control]="controls.viewId" label="NavToView"></div>
				<div control-checkbox [control]="controls.keepOrientation" label="Keep Orientation"></div>
				<div control-checkbox [control]="controls.important" label="Important"></div>
				<div control-checkbox [control]="controls.transparent" label="Transparent"></div>
				<div control-vector [control]="controls.position" label="Position" [precision]="3"></div>
				<div *if="controls.transparent.value == true">
					<div control-vector [control]="controls.rotation" label="Rotation" [precision]="3" [increment]="Math.PI / 360"></div>
					<div control-vector [control]="controls.scale" label="Scale" [precision]="2"></div>
				</div>
				<div control-localized-asset [control]="controls.asset" label="Image" accept="image/jpeg, image/png"></div>

				<div class="group--link" *for="let link of controls.links.controls">
					<div class="group--controls">
						<div control-text [control]="link.controls.title" label="Link Title"></div>
						<div control-text [control]="link.controls.href" label="Link Url"></div>
					</div>
					<button type="button" class="btn--remove" (click)="onRemoveLink(link)"><svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#remove"></use></svg></button>
				</div>

				<div class="group--cta">
					<button type="button" class="btn--update" (click)="onAddLink($event)">
						<span>Add Link</span>
					</button>
				</div>

				<div *if="useHooks">
					<div control-custom-select [control]="controls.hook" label="Hook"></div>
					<div control-text [control]="controls.hookExtra" label="Hook Extra"></div>
				</div>
			</div>
			<div class="form-controls" *if="item.type.name == 'plane' && view.type.name != 'media'">
				<div control-vector [control]="controls.position" label="Position" [precision]="2"></div>
				<div control-vector [control]="controls.rotation" label="Rotation" [precision]="3" [increment]="Math.PI / 360"></div>
				<div control-vector [control]="controls.scale" label="Scale" [precision]="2"></div>
				<div control-custom-select [control]="controls.assetType" label="Asset" (change)="onAssetTypeDidChange($event)"></div>
				<div control-localized-asset [control]="controls.asset" label="Localized Image or Video" accept="image/jpeg, video/mp4" *if="controls.assetType.value == 1"></div>
				<div control-checkbox [control]="controls.hasChromaKeyColor" label="Use Green Screen" *if="item.asset"></div>
				<div control-checkbox [control]="controls.autoplay" label="Autoplay" *if="item.asset && item.asset.type.name === 'video'"></div>
				<div control-checkbox [control]="controls.loop" label="Loop" *if="item.asset && item.asset.type.name === 'video'"></div>
			</div>
			<div class="form-controls" *if="item.type.name == 'plane' && view.type.name == 'media'">
				<div control-vector [control]="controls.scale" label="Scale" [precision]="2"></div>
				<div control-localized-asset [control]="controls.asset" label="Localized Image or Video" accept="image/jpeg, video/mp4"></div>
				<div control-checkbox [control]="controls.autoplay" label="Autoplay" *if="item.asset && item.asset.type.name === 'video'"></div>
				<div control-checkbox [control]="controls.loop" label="Loop" *if="item.asset && item.asset.type.name === 'video'"></div>
			</div>
			<div class="form-controls" *if="item.type.name == 'curved-plane'">
				<div control-vector [control]="controls.position" label="Position" [precision]="2"></div>
				<div control-vector [control]="controls.rotation" label="Rotation" [precision]="3" [increment]="Math.PI / 360"></div>
				<!-- <div control-vector [control]="controls.scale" label="Scale" [precision]="2" [disabled]="true"></div> -->
				<div control-number [control]="controls.radius" label="Radius" [precision]="2"></div>
				<div control-number [control]="controls.height" label="Height" [precision]="2"></div>
				<div control-number [control]="controls.arc" label="Arc" [precision]="0"></div>
				<div control-custom-select [control]="controls.assetType" label="Asset" (change)="onAssetTypeDidChange($event)"></div>
				<div control-localized-asset [control]="controls.asset" label="Image or Video" accept="image/jpeg, video/mp4" *if="controls.assetType.value == 1"></div>
				<div control-checkbox [control]="controls.hasChromaKeyColor" label="Use Green Screen" *if="item.asset"></div>
				<div control-checkbox [control]="controls.autoplay" label="Autoplay" *if="item.asset && item.asset.type.name === 'video'"></div>
				<div control-checkbox [control]="controls.loop" label="Loop" *if="item.asset && item.asset.type.name === 'video'"></div>
			</div>
			<div class="form-controls" *if="item.type.name == 'texture'">
				<div control-custom-select [control]="controls.assetType" label="Asset" (change)="onAssetTypeDidChange($event)"></div>
				<div control-localized-asset [control]="controls.asset" label="Image or Video" accept="image/jpeg, video/mp4" *if="controls.assetType.value == 1"></div>
				<div control-checkbox [control]="controls.hasChromaKeyColor" label="Use Green Screen" *if="item.asset"></div>
				<div control-checkbox [control]="controls.autoplay" label="Autoplay" *if="item.asset && item.asset.type.name === 'video'"></div>
				<div control-checkbox [control]="controls.loop" label="Loop" *if="item.asset && item.asset.type.name === 'video'"></div>
			</div>
			<div class="form-controls" *if="item.type.name == 'model'">
				<div control-vector [control]="controls.position" label="Position" [precision]="2" *if="view.type.name !== 'model'"></div>
				<div control-vector [control]="controls.rotation" label="Rotation" [precision]="3" [increment]="Math.PI / 360" *if="view.type.name !== 'model'"></div>
				<div control-model [control]="controls.asset" label="Model (.glb)" accept=".glb"></div>
			</div>
			<div class="group--cta">
				<button type="submit" class="btn--update" [class]="{ busy: busy }">
					<span [innerHTML]="'update' | label"></span>
				</button>
				<button type="button" class="btn--remove" (click)="onRemove($event)">
					<span [innerHTML]="'remove' | label"></span>
				</button>
			</div>
		</form>
	`
};class UpdateViewTileComponent extends rxcomp.Component {
  onInit() {
    this.busy = false;
    this.active = false;
    const form = this.form = new rxcompForm.FormGroup({
      id: new rxcompForm.FormControl(this.tile.id, rxcompForm.RequiredValidator()),
      asset: new rxcompForm.FormControl(this.tile.asset, rxcompForm.RequiredValidator()),
      navs: new rxcompForm.FormControl(this.tile.navs, rxcompForm.RequiredValidator())
    });
    this.controls = form.controls;
    form.changes$.subscribe(changes => {
      // console.log('UpdateViewTileComponent.form.changes$', changes);
      const tile = this.tile;
      Object.assign(tile, changes);
      if (typeof tile.onUpdate === 'function') {
        tile.onUpdate();
      }
      this.pushChanges();
    });
    // console.log('UpdateViewTileComponent.onInit', this.view, this.tile);
  }

  onSubmit() {
    if (!this.busy && this.form.valid) {
      this.busy = true;
      this.pushChanges();
      const payload = Object.assign({}, this.form.value);
      const view = this.view;
      const tile = payload;
      /*
      EditorService.tileUpdate$...
      */
      this.update.next({
        view,
        tile
      });
      this.setTimeout(() => {
        this.busy = false;
        this.pushChanges();
      });
    } else {
      this.form.touched = true;
    }
  }
  onRemove(event) {
    ModalService.open$({
      template: RemoveModalComponent.chunk(),
      data: {
        tile: this.tile
      }
    }).pipe(operators.first()).subscribe(event => {
      if (event instanceof ModalResolveEvent) {
        this.delete.next({
          view: this.view,
          tile: this.tile
        });
      }
    });
  }
  onSelect(event) {
    this.select.next({
      view: this.view,
      tile: this.tile.selected ? null : this.tile
    });
  }
  clearTimeout() {
    if (this.to) {
      clearTimeout(this.to);
    }
  }
  setTimeout(callback, msec) {
    if (msec === void 0) {
      msec = 300;
    }
    this.clearTimeout();
    if (typeof callback === 'function') {
      this.to = setTimeout(callback, msec);
    }
  }
  onDestroy() {
    this.clearTimeout();
  }
}
UpdateViewTileComponent.meta = {
  selector: 'update-view-tile',
  outputs: ['select', 'update', 'delete'],
  inputs: ['view', 'tile'],
  template: /* html */`
		<div class="group--headline" [class]="{ active: tile.selected }" (click)="onSelect($event)">
			<div class="icon">
				<svg-icon name="tile"></svg-icon>
			</div>
			<div class="title">Tile {{tile.id}}</div>
			<svg class="icon--caret-down"><use xlink:href="#caret-down"></use></svg>
		</div>
		<form [formGroup]="form" (submit)="onSubmit()" name="form" role="form" novalidate autocomplete="off" *if="tile.selected">
			<div class="form-controls">
				<div control-text [control]="controls.id" label="Id" [disabled]="true"></div>
				<div control-asset [control]="controls.asset" label="Image" accept="image/jpeg, image/png"></div>
			</div>
			<div class="group--cta">
				<button type="submit" class="btn--update" [class]="{ busy: busy }">
					<span [innerHTML]="'update' | label"></span>
				</button>
				<!--
				<button type="button" class="btn--remove" (click)="onRemove($event)">
					<span [innerHTML]="'remove' | label"></span>
				</button>
				-->
			</div>
		</form>
	`
};class UpdateViewComponent extends rxcomp.Component {
  onInit() {
    this.busy = false;
    const form = this.form = new rxcompForm.FormGroup();
    this.controls = form.controls;
    this.doUpdateForm();
    form.changes$.subscribe(changes => {
      // console.log('UpdateViewComponent.form.changes$', changes);
      this.doUpdateView(changes);
      this.pushChanges();
    });
    this.orbit$().pipe(operators.takeUntil(this.unsubscribe$)).subscribe(message => {
      switch (this.view.type.name) {
        case ViewType.WaitingRoom.name:
        case ViewType.Panorama.name:
        case ViewType.PanoramaGrid.name:
        case ViewType.Room3d.name:
        case ViewType.Model.name:
        case ViewType.Media.name:
          this.form.patch({
            latitude: message.orientation.latitude,
            longitude: message.orientation.longitude,
            zoom: message.zoom
          });
          break;
      }
    });
  }
  orbit$() {
    let latitude,
      longitude,
      zoom = null;
    return MessageService.in$.pipe(operators.filter(message => message.type === MessageType.ControlInfo), operators.auditTime(Math.floor(1000 / 15)), operators.distinctUntilChanged((previous, current) => {
      const didChange = latitude !== current.orientation.latitude || longitude !== current.orientation.longitude || zoom !== current.zoom;
      latitude = current.orientation.latitude;
      longitude = current.orientation.longitude;
      zoom = current.zoom;
      return !didChange;
    }));
  }
  getAssetDidChange(changes) {
    const view = this.view;
    if (view.type.name === ViewType.PanoramaGrid.name) {
      return false;
    }
    const assetDidChange = AssetService.assetDidChange(view.asset, changes.asset);
    const usdzDidChange = AssetService.assetDidChange(view.ar ? view.ar.usdz : null, changes.usdz);
    const gltfDidChange = AssetService.assetDidChange(view.ar ? view.ar.gltf : null, changes.gltf);
    if (assetDidChange || usdzDidChange || gltfDidChange) {
      // console.log('UpdateViewComponent.getAssetDidChange', assetDidChange, usdzDidChange, gltfDidChange);
      return true;
    } else {
      return false;
    }
  }
  doUpdateView(changes) {
    const assetDidChange = this.getAssetDidChange(changes);
    // console.log('doUpdateItem.assetDidChange', assetDidChange);
    if (assetDidChange) {
      this.onSubmit();
    }
  }
  doUpdateForm() {
    const view = this.view;
    if (!this.type || this.type.name !== view.type.name) {
      this.type = view.type;
      const form = this.form;
      Object.keys(this.controls).forEach(key => {
        form.removeKey(key);
      });
      let keys;
      switch (view.type.name) {
        case ViewType.WaitingRoom.name:
          keys = ['id', 'type', 'name', 'latitude', 'longitude', 'zoom', 'asset'];
          break;
        case ViewType.Panorama.name:
          keys = ['id', 'type', 'name', 'hidden?', 'latitude', 'longitude', 'zoom', 'asset'];
          break;
        case ViewType.PanoramaGrid.name:
          keys = ['id', 'type', 'name', 'hidden?', 'latitude', 'longitude', 'zoom'];
          break;
        case ViewType.Room3d.name:
          keys = ['id', 'type', 'name', 'hidden?', 'latitude', 'longitude', 'zoom', 'asset'];
          break;
        case ViewType.Model.name:
          keys = ['id', 'type', 'name', 'hidden?', 'latitude', 'longitude', 'zoom', 'asset'];
          break;
        case ViewType.Media.name:
          keys = ['id', 'type', 'name', 'hidden?', 'asset'];
          break;
        default:
          keys = ['id', 'type', 'name'];
      }
      if (view.type.name !== ViewType.WaitingRoom.name && environment.flags.ar) {
        keys.push('usdz?');
        keys.push('gltf?');
      }
      keys.forEach(key => {
        const optional = key.indexOf('?') !== -1;
        key = key.replace('?', '');
        switch (key) {
          case 'latitude':
          case 'longitude':
            {
              const orientation = view.orientation || {
                latitude: 0,
                longitude: 0
              };
              form.add(new rxcompForm.FormControl(orientation[key], rxcompForm.RequiredValidator()), key);
              break;
            }
          case 'usdz':
          case 'gltf':
            {
              form.add(new rxcompForm.FormControl(view.ar ? view.ar[key] || null : null, optional ? undefined : rxcompForm.RequiredValidator()), key);
              break;
            }
          default:
            {
              form.add(new rxcompForm.FormControl(view[key] != null ? view[key] : null, optional ? undefined : rxcompForm.RequiredValidator()), key);
            }
        }
      });
      this.controls = form.controls;
    }
  }
  onChanges(changes) {
    // console.log('UpdateViewComponent.onChanges');
    this.doUpdateForm();
  }
  onSubmit() {
    if (!this.busy && this.form.valid) {
      this.busy = true;
      this.pushChanges();
      const payload = Object.assign({}, this.form.value);
      if (payload.latitude != null) {
        // !!! keep loose inequality
        payload.orientation = {
          latitude: payload.latitude,
          longitude: payload.longitude
        };
        delete payload.latitude;
        delete payload.longitude;
      }
      const usdz = payload.usdz || null;
      const gltf = payload.gltf || null;
      delete payload.usdz;
      delete payload.gltf;
      payload.ar = usdz || gltf ? {
        usdz,
        gltf
      } : null;
      const view = new View(Object.assign({}, this.view, payload));
      /*
      let dataView = Object.assign({}, ViewService.getDataView(this.view.id), payload);
      dataView = new View(dataView);
      let pathView = Object.assign({}, this.view, payload);
      pathView = new View(pathView);
      */
      EditorService.viewUpdate$(view).pipe(operators.first()).subscribe(response => {
        // console.log('UpdateViewComponent.onSubmit.viewUpdate$.success', response);
        this.update.next({
          view: view
        });
        this.setTimeout(() => {
          this.busy = false;
          this.pushChanges();
        });
      }, error => console.log('UpdateViewComponent.onSubmit.viewUpdate$.error', error));
      // this.update.next({ view: new View(payload) });
    } else {
      this.form.touched = true;
    }
  }
  onRemove(event) {
    ModalService.open$({
      template: RemoveModalComponent.chunk(),
      data: {
        item: this.item
      }
    }).pipe(operators.first()).subscribe(event => {
      if (event instanceof ModalResolveEvent) {
        this.delete.next({
          view: this.view
        });
      }
    });
  }
  onSelect(event) {
    this.select.next({
      view: this.view.selected ? null : this.view
    });
  }
  getTitle(view) {
    return LabelPipe.getKeys('editor', view.type.name);
  }
  clearTimeout() {
    if (this.to) {
      clearTimeout(this.to);
    }
  }
  setTimeout(callback, msec) {
    if (msec === void 0) {
      msec = 300;
    }
    this.clearTimeout();
    if (typeof callback === 'function') {
      this.to = setTimeout(callback, msec);
    }
  }
  onDestroy() {
    this.clearTimeout();
  }
}
UpdateViewComponent.meta = {
  selector: 'update-view',
  outputs: ['select', 'update', 'delete'],
  inputs: ['view'],
  template: /* html */`
		<div class="group--headline" [class]="{ active: view.selected }" (click)="onSelect($event)">
			<!-- <div class="id" [innerHTML]="view.id"></div> -->
			<div class="icon">
				<svg-icon [name]="view.type.name"></svg-icon>
			</div>
			<div class="title" [innerHTML]="getTitle(view)"></div>
			<svg class="icon--caret-down"><use xlink:href="#caret-down"></use></svg>
		</div>
		<form [formGroup]="form" (submit)="onSubmit()" name="form" role="form" novalidate autocomplete="off" *if="view.selected">
			<div class="form-controls">
				<div control-text [control]="controls.id" label="Id" [disabled]="true"></div>
				<!-- <div control-text [control]="controls.type" label="Type" [disabled]="true"></div> -->
				<div control-text [control]="controls.name" label="Name"></div>
			</div>
			<div class="form-controls" *if="view.type.name == 'waiting-room'">
				<div control-localized-asset [control]="controls.asset" label="Image" accept="image/jpeg"></div>
				<div control-text [control]="controls.latitude" label="Latitude" [disabled]="true"></div>
				<div control-text [control]="controls.longitude" label="Longitude" [disabled]="true"></div>
				<div control-text [control]="controls.zoom" label="Zoom" [disabled]="true"></div>
			</div>
			<div class="form-controls" *if="view.type.name == 'panorama'">
				<div control-checkbox [control]="controls.hidden" label="Hide from menu"></div>
				<div control-localized-asset [control]="controls.asset" label="Image or Video" accept="image/jpeg, video/mp4"></div>
				<div control-text [control]="controls.latitude" label="Latitude" [disabled]="true"></div>
				<div control-text [control]="controls.longitude" label="Longitude" [disabled]="true"></div>
				<div control-text [control]="controls.zoom" label="Zoom" [disabled]="true"></div>
			</div>
			<div class="form-controls" *if="view.type.name == 'panorama-grid'">
				<div control-checkbox [control]="controls.hidden" label="Hide from menu"></div>
				<div control-text [control]="controls.latitude" label="Latitude" [disabled]="true"></div>
				<div control-text [control]="controls.longitude" label="Longitude" [disabled]="true"></div>
				<div control-text [control]="controls.zoom" label="Zoom" [disabled]="true"></div>
			</div>
			<div class="form-controls" *if="view.type.name == 'room-3d'">
				<div control-checkbox [control]="controls.hidden" label="Hide from menu"></div>
				<div control-model [control]="controls.asset" label="Model (.glb)" accept=".glb"></div>
				<div control-text [control]="controls.latitude" label="Latitude" [disabled]="true"></div>
				<div control-text [control]="controls.longitude" label="Longitude" [disabled]="true"></div>
				<div control-text [control]="controls.zoom" label="Zoom" [disabled]="true"></div>
			</div>
			<div class="form-controls" *if="view.type.name == 'model'">
				<div control-checkbox [control]="controls.hidden" label="Hide from menu"></div>
				<div control-localized-asset [control]="controls.asset" label="Image" accept="image/jpeg"></div>
				<div control-text [control]="controls.latitude" label="Latitude" [disabled]="true"></div>
				<div control-text [control]="controls.longitude" label="Longitude" [disabled]="true"></div>
				<div control-text [control]="controls.zoom" label="Zoom" [disabled]="true"></div>
			</div>
			<div class="form-controls" *if="view.type.name != 'waiting-room' && ('ar' | flag)">
				<div control-model [control]="controls.usdz" label="AR IOS (.usdz)" accept=".usdz"></div>
				<div control-model [control]="controls.gltf" label="AR Android (.glb)" accept=".glb"></div>
			</div>
			<div class="group--cta">
				<button type="submit" class="btn--update" [class]="{ busy: busy }">
					<span [innerHTML]="'update' | label"></span>
				</button>
				<button type="button" class="btn--remove" *if="view.type.name != 'waiting-room'" (click)="onRemove($event)">
					<span [innerHTML]="'remove' | label"></span>
				</button>
			</div>
		</form>
	`
};const factories = [AsideComponent, CurvedPlaneModalComponent, EditorComponent, ItemModelModalComponent, NavmapBuilderComponent, NavmapEditComponent, NavmapModalComponent, NavmapItemModalComponent, MediaModalComponent, MenuBuilderComponent, ModelModalComponent, NavModalComponent, PanoramaModalComponent, PanoramaGridModalComponent, PathAddModalComponent, PathEditModalComponent, PlaneModalComponent, RemoveModalComponent, Room3DModalComponent, ToastOutletComponent, UpdateViewItemComponent, UpdateViewTileComponent, UpdateViewComponent];
const pipes = [];
class EditorModule extends rxcomp.Module {}
EditorModule.meta = {
  imports: [],
  declarations: [...factories, ...pipes],
  exports: [...factories, ...pipes]
};class IframeModalComponent extends rxcomp.Component {
  onClose() {
    ModalService.reject();
  }
}
IframeModalComponent.meta = {
  selector: '[iframe-modal]',
  inputs: ['src'],
  template: /* html */`
		<div class="modal__header">
			<button type="button" class="btn--close" (click)="onClose()">
				<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#close"></use></svg>
			</button>
		</div>
		<div class="modal__content">
			<iframe [src]="src"></iframe>
		</div>
	`
};
IframeModalComponent.chunk = src => /* html */`<div class="iframe-modal" iframe-modal src="${src}"></div>`;class EnvPipe extends rxcomp.Pipe {
  static transform(keypath) {
    let env = environment;
    const keys = keypath.split('.');
    let k = keys.shift();
    while (keys.length > 0 && env[k]) {
      env = env[k];
      k = keys.shift();
    }
    const value = env[k] || null;
    return value;
  }
}
EnvPipe.meta = {
  name: 'env'
};class FlagPipe extends rxcomp.Pipe {
  static transform(key) {
    const flags = environment.flags;
    return flags[key] || false;
  }
}
FlagPipe.meta = {
  name: 'flag'
};class UploadItem {
  constructor(file) {
    this.file = file;
    this.name = file.name;
    this.type = assetTypeFromPath(file.name);
    this.progress = 0;
    this.size = file.size;
    this.uploading = false;
    this.paused = false;
    this.success = false;
    this.complete = false;
    this.error = null;
    this.preview = null;
  }
}
class UploadEvent {
  constructor(options) {
    if (options) {
      Object.assign(this, options);
    }
  }
}
class UploadStartEvent extends UploadEvent {}
class UploadCompleteEvent extends UploadEvent {}
class UploadAssetEvent extends UploadEvent {}
class UploadService {
  constructor() {
    this.concurrent$ = new rxjs.BehaviorSubject(0);
    this.items$ = new rxjs.BehaviorSubject([]);
    this.events$ = new rxjs.ReplaySubject(1);
  }
  upload$() {
    const items = this.items$.getValue();
    const uploadItems = items.filter(item => !item.uploading);
    return rxjs.combineLatest(uploadItems.map(item => this.uploadItem$(item)));
  }
  uploadItem$(item) {
    // max 4 concurrent upload
    item.uploading = true;
    this.events$.next(new UploadStartEvent({
      item
    }));
    const files = [item.file];
    return rxjs.of(files).pipe(operators.delayWhen(() => this.concurrent$.pipe(operators.filter(x => x < 4))), operators.tap(() => this.concurrent$.next(this.concurrent$.getValue() + 1)), operators.first(), operators.switchMap(files => AssetService.upload$(files)), operators.switchMap(uploads => {
      const upload = uploads[0];
      item.uploading = false;
      item.complete = true;
      const asset = Asset.fromUrl(upload.url);
      this.events$.next(new UploadCompleteEvent({
        item,
        asset
      }));
      return AssetService.assetCreate$(asset).pipe(operators.tap(asset => {
        this.remove(item);
        this.events$.next(new UploadAssetEvent({
          item,
          asset
        }));
        this.concurrent$.next(this.concurrent$.getValue() - 1);
      }));
    }));
    /*
    // concurrent upload
    return AssetService.upload$([item.file]).pipe(
    	switchMap((uploads) => {
    		const upload = uploads[0];
    		item.uploading = false;
    		item.complete = true;
    		const asset = Asset.fromUrl(upload.url);
    		this.events$.next(new UploadCompleteEvent({ item, asset }));
    		return AssetService.assetCreate$(asset).pipe(
    			tap(asset => {
    				this.remove(item);
    				this.events$.next(new UploadAssetEvent({ item, asset }));
    			}),
    		);
    	}),
    );
    */
  }

  addItems(files) {
    if (files && files.length) {
      // console.log('addItems', files);
      const items = this.items$.getValue();
      const newItems = Array.from(files).map(file => new UploadItem(file));
      items.push(...newItems);
      this.items$.next(items);
    }
  }
  remove(item) {
    const items = this.items$.getValue();
    const index = items.indexOf(item);
    if (index !== -1) {
      items.splice(index, 1);
    }
    this.items$.next(items);
  }
  removeAll() {
    // !!!
    this.items$.next([]);
  }
  drop$(input, dropArea) {
    if (rxcomp.isPlatformBrowser && input) {
      dropArea = dropArea || input;
      const body = document.querySelector('body');
      return rxjs.merge(rxjs.fromEvent(body, 'drop'), rxjs.fromEvent(body, 'dragover')).pipe(operators.map(event => {
        // console.log('UploadService.drop$', event);
        event.preventDefault();
        if (event.target === dropArea) {
          this.addItems(event.dataTransfer.files);
        }
        return this.items$;
      }));
    } else {
      return rxjs.EMPTY;
    }
  }
  change$(input) {
    if (rxcomp.isPlatformBrowser && input) {
      return rxjs.fromEvent(input, 'change').pipe(operators.switchMap(event => {
        if (input.files.length) {
          this.addItems(input.files);
          input.value = '';
        }
        return this.items$;
      }));
    } else {
      return rxjs.EMPTY;
    }
  }
  files$(files) {
    return rxjs.combineLatest(Array.from(files).map((file, i) => this.file$(file, i)));
  }
  file$(file, i) {
    return this.read$(file, i).pipe(operators.switchMap(() => this.uploadFile$(file)));
  }

  /*
  static files$(files) {
  	const fileArray = Array.from(files);
  	this.previews = fileArray.map(() => null);
  	const uploads$ = fileArray.map((file, i) => this.read$(file, i).pipe(
  		switchMap(() => this.uploadFile$(file)),
  	));
  	return combineLatest(uploads$);
  }
  */

  read$(file, i) {
    const reader = new FileReader();
    const reader$ = rxjs.fromEvent(reader, 'load').pipe(operators.tap(event => {
      const blob = event.target.result;
      this.resize(blob, resized => {
        this.previews[i] = resized;
        // console.log('resized', resized);
        this.pushChanges();
      });
    }));
    reader.readAsDataURL(file);
    return reader$;
  }
  uploadFile$(file) {
    return AssetService.upload$([file]).pipe(operators.switchMap(uploads => {
      const upload = uploads[0];
      /*
      id: 1601303293569
      type: 'image/jpeg'
      file: '1601303293569_ambiente1_x0_y2.jpg'
      originalFileName: 'ambiente1_x0_y2.jpg'
      url: '/uploads/1601303293569_ambiente1_x0_y2.jpg'
      */
      const asset = Asset.fromUrl(upload.url);
      return AssetService.assetCreate$(asset);
    }));
  }
  resize(blob, callback) {
    if (typeof callback === 'function') {
      const img = document.createElement('img');
      img.onload = function () {
        const MAX_WIDTH = 320;
        const MAX_HEIGHT = 240;
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        let width = img.width;
        let height = img.height;
        if (width > height) {
          if (width > MAX_WIDTH) {
            height *= MAX_WIDTH / width;
            width = MAX_WIDTH;
          }
        } else {
          if (height > MAX_HEIGHT) {
            width *= MAX_HEIGHT / height;
            height = MAX_HEIGHT;
          }
        }
        canvas.width = width;
        canvas.height = height;
        ctx.drawImage(img, 0, 0, width, height);
        const dataUrl = canvas.toDataURL('image/jpeg', 0.9);
        callback(dataUrl);
      };
      img.src = blob;
    }
  }
  supported() {
    return supportFileAPI() && supportAjaxUploadProgressEvents() && supportFormData();
    function supportFileAPI() {
      var input = document.createElement('input');
      input.type = 'file';
      return 'files' in input;
    }
    function supportAjaxUploadProgressEvents() {
      var xhr = new XMLHttpRequest();
      return !!(xhr && 'upload' in xhr && 'onprogress' in xhr.upload);
    }
    function supportFormData() {
      return !!window.FormData;
    }
  }
}class ControlAssetsComponent extends ControlComponent {
  get items() {
    return this.items_;
  }
  set items(items) {
    this.items_ = items;
    this.uploadCount = items.reduce((p, c) => {
      return p + (c.uploading || c.completed ? 0 : 1);
    }, 0);
  }
  onInit() {
    this.label = this.label || 'label';
    this.accept = this.accept || 'image/png, image/jpeg';
    this.multiple = this.multiple !== false;
    this.items = [];
    this.assets = this.control.value || [];
    this.hasFiles = false;
    const {
      node
    } = rxcomp.getContext(this);
    const input = node.querySelector('input');
    input.setAttribute('accept', this.accept);
    const dropArea = node.querySelector('.upload-drop');
    const service = this.service = new UploadService();
    service.drop$(input, dropArea).pipe(operators.takeUntil(this.unsubscribe$)).subscribe(items => {
      // console.log('ControlAssetComponent.drop$', items);
      this.items = items;
      this.pushChanges();
    });
    service.change$(input).pipe(operators.takeUntil(this.unsubscribe$)).subscribe(items => {
      // console.log('ControlAssetComponent.change$', items);
      this.items = items;
      this.pushChanges();
    });
    service.events$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(event => {
      // console.log('ControlAssetComponent.events$', event);
      if (event instanceof UploadAssetEvent) {
        this.assets.push(event.asset);
        this.control.value = this.assets;
      }
      this.items = this.items_;
      this.pushChanges();
      // this.control.value = assets;
    });
  }

  onUpload() {
    // console.log('ControlAssetsComponent.onUpload');
    this.service.upload$().pipe(operators.first()).subscribe();
  }
  onCancel() {
    // console.log('ControlAssetsComponent.onCancel');
    this.service.removeAll();
  }
  onItemPause(item) {
    // console.log('ControlAssetsComponent.onPause', item);
  }
  onItemResume(item) {
    // console.log('ControlAssetsComponent.onResume', item);
  }
  onItemCancel(item) {
    // console.log('ControlAssetsComponent.onCancel', item);
  }
  onItemRemove(item) {
    // console.log('ControlAssetsComponent.onRemove', item);
    this.service.remove(item);
  }
}
ControlAssetsComponent.meta = {
  selector: '[control-assets]',
  inputs: ['control', 'label', 'multiple'],
  template: /* html */`
		<div class="group--form" [class]="{ required: control.validators.length }">
			<div class="control--head">
				<label [innerHTML]="label"></label>
				<span class="required__badge" [innerHTML]="'required' | label"></span>
			</div>
			<div class="listing--assets">
				<div class="listing__item" *for="let item of assets">
					<div class="upload-item">
						<div class="picture">
							<img [lazy]="item | asset" [size]="{ width: 320, height: 240 }" *if="item.type.name === 'image'" />
							<video [src]="item | asset" *if="item.type.name === 'video'"></video>
						</div>
						<div class="name" [innerHTML]="item.file"></div>
					</div>
				</div>
				<div class="listing__item" *for="let item of items">
					<div upload-item [item]="item" (pause)="onItemPause($event)" (resume)="onItemResume($event)" (cancel)="onItemCancel($event)" (remove)="onItemRemove($event)"></div>
				</div>
			</div>
			<div class="group--cta">
				<div class="btn--browse">
					<span [innerHTML]="'browse' | label"></span>
					<input type="file" accept="image/jpeg" multiple />
				</div>
				<div class="btn--upload" (click)="onUpload()" *if="uploadCount > 0" [innerHTML]="'upload' | label"></div>
				<div class="btn--cancel" (click)="onCancel()" *if="uploadCount > 0" [innerHTML]="'cancel' | label"></div>
			</div>
			<div class="upload-drop">
    			<span [innerHTML]="'drag_and_drop_images' | label"></span>
			</div>
		</div>
		<errors-component [control]="control"></errors-component>
	`
};class GenericModalComponent extends rxcomp.Component {
  get data() {
    let data = null;
    const {
      parentInstance
    } = rxcomp.getContext(this);
    if (parentInstance instanceof ModalOutletComponent) {
      data = parentInstance.modal.data;
    }
    return data;
  }
  onInit() {
    console.log(this.data);
    this.page = null;
    GenericService.currentLanguagePage$(this.data.mode).pipe(operators.takeUntil(this.unsubscribe$)).subscribe(page => {
      this.page = page;
      this.pushChanges();
    });
  }
  onClose() {
    ModalService.reject();
  }
}
GenericModalComponent.meta = {
  selector: '[generic-modal]',
  template: /* html */`
		<div class="modal__header">
			<button type="button" class="btn--close" (click)="onClose()">
				<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#close"></use></svg>
			</button>
		</div>
		<div class="container" *if="page">
			<h1 class="title" [innerHTML]="page.title"></h1>
			<div class="description" [innerHTML]="page.description"></div>
		</div>
		<div class="modal__footer">
			<button type="button" class="btn--accept" (click)="onClose()">
				<span [innerHTML]="'title_close' | label"></span>
			</button>
		</div>
	`
};
GenericModalComponent.chunk = () => /* html */'<div class="generic-modal" generic-modal></div>';class ControlCheckboxComponent extends ControlComponent {
  onInit() {
    this.label = this.label || 'label';
    this.linksSubject = new rxjs.ReplaySubject();
    this.links$().pipe(operators.takeUntil(this.unsubscribe$)).subscribe();
  }
  onChanges() {
    const {
      node
    } = rxcomp.getContext(this);
    const links = Array.prototype.slice.call(node.querySelectorAll('a'));
    // console.log('ControlCheckboxComponent.onChanges', links);
    this.linksSubject.next(links.length ? rxjs.fromEvent(links, 'click') : rxjs.EMPTY);
  }
  links$() {
    const linksSubject = this.linksSubject.pipe(operators.switchAll(), operators.tap(event => {
      // console.log(event);
      if (environment.flags.gdprRoutes) {
        const template = GenericModalComponent.chunk();
        ModalService.open$({
          template,
          data: {
            mode: 'privacy_policy'
          }
        }).pipe(operators.first()).subscribe();
        event.preventDefault();
      }
    }));
    return linksSubject;
  }
}
ControlCheckboxComponent.meta = {
  selector: '[control-checkbox]',
  inputs: ['control', 'label'],
  template: /* html */`
		<div class="group--form--checkbox" [class]="{ required: control.validators.length }">
			<label>
				<input type="checkbox" class="control--checkbox" [formControl]="control" [value]="true" />
				<span [innerHTML]="label | html"></span>
			</label>
			<span class="required__badge" [innerHTML]="'required' | label"></span>
		</div>
		<errors-component [control]="control"></errors-component>
	`
};class ControlCustomSelectComponent extends ControlComponent {
  onInit() {
    this.label = this.label || 'label';
    this.dropped = false;
    this.dropdownId = DropdownDirective.nextId();
    KeyboardService.typing$().pipe(operators.takeUntil(this.unsubscribe$)).subscribe(word => {
      this.scrollToWord(word);
    });
    /*
    KeyboardService.key$().pipe(
    	takeUntil(this.unsubscribe$)
    ).subscribe(key => {
    	this.scrollToKey(key);
    });
    */
  }

  /*
  onChanges() {
  	// console.log('ControlCustomSelectComponent.onChanges');
  }
  */

  scrollToWord(word) {
    // console.log('ControlCustomSelectComponent.scrollToWord', word);
    const items = this.control.options || [];
    let index = -1;
    for (let i = 0; i < items.length; i++) {
      const x = items[i];
      if (x.name.toLowerCase().indexOf(word.toLowerCase()) === 0) {
        // console.log(word, x.name);
        index = i;
        break;
      }
    }
    if (index !== -1) {
      const {
        node
      } = rxcomp.getContext(this);
      const dropdown = node.querySelector('.dropdown');
      const navDropdown = node.querySelector('.nav--dropdown');
      const item = navDropdown.children[index];
      if (item) {
        dropdown.scrollTo(0, item.offsetTop);
      }
    }
  }
  setOption(item) {
    // console.log('setOption', item, this.isMultiple);
    let value;
    if (this.isMultiple) {
      value = this.control.value || [];
      const index = value.indexOf(item.id);
      if (index !== -1) {
        // if (value.length > 1) {
        value.splice(index, 1);
        // }
      } else {
        value.push(item.id);
      }
      value = value.length ? value.slice() : null;
    } else {
      value = item.id;
      // DropdownDirective.dropdown$.next(null);
    }

    this.control.value = value;
    this.change.next(value);
  }
  hasOption(item) {
    if (this.isMultiple) {
      const values = this.control.value || [];
      return values.indexOf(item.id) !== -1;
    } else {
      return this.control.value === item.id;
    }
  }
  getLabel() {
    let value = this.control.value;
    const items = this.control.options || [];
    if (this.isMultiple) {
      value = value || [];
      if (value.length) {
        return value.map(v => {
          const item = items.find(x => x.id === v || x.name === v);
          return item ? item.name : '';
        }).join(', ');
      } else {
        return 'select'; // LabelPipe.transform('select');
      }
    } else {
      const item = items.find(x => x.id === value || x.name === value);
      if (item) {
        return item.name;
      } else {
        return 'select'; // LabelPipe.transform('select');
      }
    }
  }

  onDropped($event) {
    // console.log('ControlCustomSelectComponent.onDropped', id);
    if (this.dropped && $event === null) {
      this.control.touched = true;
    }
    this.dropped = $event === this.dropdownId;
  }
  get isMultiple() {
    return this.multiple && this.multiple !== false && this.multiple !== 'false';
  }
}
ControlCustomSelectComponent.meta = {
  selector: '[control-custom-select]',
  outputs: ['change'],
  inputs: ['control', 'label', 'multiple'],
  template: /* html */`
		<div class="group--form--select" [class]="{ required: control.validators.length, multiple: isMultiple }" [dropdown]="dropdownId" (dropped)="onDropped($event)">
			<label [innerHTML]="label"></label>
			<span class="control--custom-select" [innerHTML]="getLabel() | label"></span>
			<svg class="icon--caret-down"><use xlink:href="#caret-down"></use></svg>
			<span class="required__badge" [innerHTML]="'required' | label"></span>
		</div>
		<errors-component [control]="control"></errors-component>
		<div class="dropdown" [dropdown-item]="dropdownId">
			<div class="category" [innerHTML]="label"></div>
			<ul class="nav--dropdown" [class]="{ multiple: isMultiple }">
				<li (click)="setOption(item)" [class]="{ empty: item.id == null }" *for="let item of control.options">
					<span [class]="{ active: hasOption(item) }" [innerHTML]="item.name | label"></span>
				</li>
			</ul>
		</div>
	`
};class ControlLinkComponent extends ControlComponent {
  onInit() {
    this.label = this.label || 'label';
    this.disabled = this.disabled || false;
    const {
      node
    } = rxcomp.getContext(this);
    const input = this.input = node.querySelector('input');
    rxjs.merge(rxjs.fromEvent(input, 'input')).pipe(operators.takeUntil(this.unsubscribe$)).subscribe(event => this.onInputDidChange(event));
    rxjs.fromEvent(input, 'blur').pipe(operators.takeUntil(this.unsubscribe$)).subscribe(event => this.onInputDidBlur(event));
  }
  onInputDidChange(event) {
    // console.log('ControlLinkComponent.onInputDidChange', event.target.value);
  }
  onInputDidBlur(event) {
    // console.log('ControlLinkComponent.onInputDidBlur', event.target.value);
    this.control.touched = true;
    this.value = this.input.value;
  }
}
ControlLinkComponent.meta = {
  selector: '[control-link]',
  inputs: ['control', 'label', 'disabled'],
  template: /* html */`
		<div class="group--form" [class]="{ required: control.validators.length, disabled: disabled }">
			<label [innerHTML]="label"></label>
			<input type="text" class="control--text" [formControl]="control" [placeholder]="label" [disabled]="disabled" />
			<span class="required__badge" [innerHTML]="'required' | label"></span>
		</div>
		<errors-component [control]="control"></errors-component>
	`
};class ControlLocalizedAssetComponent extends ControlComponent {
  get localizedValue() {
    let asset = this.control.value;
    if (asset && asset.locale) {
      const localizedAsset = asset.locale[this.currentLanguage];
      if (localizedAsset) {
        asset = localizedAsset;
      }
    }
    return asset;
  }
  onInit() {
    this.label = this.label || 'label';
    this.disabled = this.disabled || false;
    this.accept = this.accept || 'image/png, image/jpeg';
    this.languages = environment.languages;
    this.currentLanguage = LanguageService.lang;
    const {
      node
    } = rxcomp.getContext(this);
    const input = node.querySelector('input');
    input.setAttribute('accept', this.accept);
    DropService.drop$(input).pipe(operators.takeUntil(this.unsubscribe$)).subscribe();
    DropService.change$(input).pipe(operators.switchMap(files => {
      const uploads$ = files.map((file, i) => AssetService.upload$([file]).pipe(operators.switchMap(uploads => (this.languages.length > 1 ? AssetService.createOrUpdateLocalizedAsset$ : AssetService.createOrUpdateAsset$)(uploads, this.control, this.currentLanguage))));
      return rxjs.combineLatest(uploads$);
    }), operators.takeUntil(this.unsubscribe$)).subscribe(assets => {
      // console.log('ControlLocalizedAssetComponent.change$', assets);
      this.control.value = assets[0];
    });
  }
  setLanguage(language) {
    LanguageService.setLanguage$(language).pipe(operators.first()).subscribe(_ => {
      this.currentLanguage = language;
      this.pushChanges();
    });
  }
}
ControlLocalizedAssetComponent.meta = {
  selector: '[control-localized-asset]',
  inputs: ['control', 'label', 'disabled', 'accept'],
  template: /* html */`
		<div class="group--form" [class]="{ required: control.validators.length, disabled: disabled }">
			<div class="control--head">
				<label [innerHTML]="label"></label>
				<span class="required__badge" [innerHTML]="'required' | label"></span>
			</div>
			<div class="group--picture">
				<div class="group--picture__info">
					<span [innerHTML]="'browse' | label"></span>
				</div>
				<img [lazy]="localizedValue | asset" [size]="{ width: 320, height: 240 }" *if="localizedValue && localizedValue.type.name === 'image'" />
				<video [src]="localizedValue | asset" *if="localizedValue && localizedValue.type.name === 'video'"></video>
				<input type="file">
			</div>
			<div class="file-name" *if="localizedValue" [innerHTML]="localizedValue.file"></div>
			<ul class="nav--languages" *if="languages.length > 1">
				<li class="nav__item" [class]="{ active: lang == currentLanguage }" (click)="setLanguage(lang)" [innerHTML]="lang" *for="let lang of languages"></li>
			</ul>
		</div>
		<errors-component [control]="control"></errors-component>
	`
};class ControlModelComponent extends ControlAssetComponent {
  onInit() {
    this.label = this.label || 'label';
    this.disabled = this.disabled || false;
    this.accept = this.accept || '.glb';
    const {
      node
    } = rxcomp.getContext(this);
    const input = this.input = node.querySelector('input');
    input.setAttribute('accept', this.accept);
    /*
    this.click$(input).pipe(
    	takeUntil(this.unsubscribe$)
    ).subscribe();
    */
    DropService.change$(input).pipe(operators.switchMap(files => {
      const uploads$ = files.map((file, i) => AssetService.upload$([file]).pipe(operators.switchMap(uploads => AssetService.createOrUpdateAsset$(uploads, this.control))));
      return rxjs.combineLatest(uploads$);
    }), operators.takeUntil(this.unsubscribe$)).subscribe(assets => {
      // console.log('ControlModelComponent.change$', assets);
      this.control.value = assets[0];
    });
  }
  onRemove(event) {
    AssetService.assetDelete$(this.control.value).pipe(operators.first()).subscribe(() => {
      this.control.value = null;
      this.input.value = null;
      this.control.touched = true; // !!!
    });
    // !!! delete upload
    // !!! delete asset
  }

  /*
  click$(input) {
  	if (isPlatformBrowser && input) {
  		return fromEvent(input, 'click').pipe(
  			tap(() => input.value = null),
  		);
  	} else {
  		return EMPTY;
  	}
  }
  */

  read$(file, i) {
    return rxjs.of(file);
  }
}
ControlModelComponent.meta = {
  selector: '[control-model]',
  inputs: ['control', 'label', 'disabled', 'accept'],
  template: /* html */`
		<div class="group--form" [class]="{ required: control.validators.length, disabled: disabled }">
			<div class="control--head">
				<label [innerHTML]="label"></label>
				<span class="required__badge" [innerHTML]="'required' | label"></span>
			</div>
			<div class="group--model">
				<div class="file-name" *if="!control.value" [innerHTML]="'select_file' | label"></div>
				<div class="file-name" *if="control.value" [innerHTML]="control.value.file"></div>
				<div class="btn--upload"><input type="file"><span [innerHTML]="'browse' | label"></span></div>
				<div class="btn--remove" *if="control.value" (click)="onRemove($event)"><span [innerHTML]="'remove' | label"></span></div>
			</div>
		</div>
		<errors-component [control]="control"></errors-component>
	`
};class ControlNumberComponent extends ControlComponent {
  onInit() {
    this.label = this.label || 'label';
    this.precision = this.precision || 3;
    this.increment = this.increment || 1 / Math.pow(10, this.precision);
    this.disabled = this.disabled || false;
  }
  updateValue(value) {
    this.control.value = value;
  }
}
ControlNumberComponent.meta = {
  selector: '[control-number]',
  inputs: ['control', 'label', 'precision', 'increment', 'disabled'],
  template: /* html */`
		<div class="group--form" [class]="{ required: control.validators.length }">
			<div class="control--head">
				<label [innerHTML]="label"></label>
				<span class="required__badge" [innerHTML]="'required' | label"></span>
			</div>
			<div class="control--content control--number">
				<input-value label="" [precision]="precision" [increment]="increment" [disabled]="disabled" [value]="control.value" (update)="updateValue($event)"></input-value>
			</div>
		</div>
		<errors-component [control]="control"></errors-component>
	`
};class ControlPasswordComponent extends ControlComponent {
  onInit() {
    this.label = this.label || 'label';
  }
}
ControlPasswordComponent.meta = {
  selector: '[control-password]',
  inputs: ['control', 'label'],
  template: /* html */`
		<div class="group--form" [class]="{ required: control.validators.length }">
			<label [innerHTML]="label"></label>
			<input type="password" class="control--text" [formControl]="control" [placeholder]="label" />
			<span class="required__badge" [innerHTML]="'required' | label"></span>
		</div>
		<errors-component [control]="control"></errors-component>
	`
};class ControlSelectComponent extends ControlComponent {
  onInit() {
    this.label = this.label || 'label';
  }
}
ControlSelectComponent.meta = {
  selector: '[control-select]',
  inputs: ['control', 'label'],
  template: /* html */`
		<div class="group--form--select" [class]="{ required: control.validators.length }">
			<label [innerHTML]="label"></label>
			<select class="control--select" [formControl]="control" required>
				<option [value]="null" [innerHTML]="'select' | label"></option>
				<option [value]="item.id" *for="let item of control.options" [innerHTML]="item.name"></option>
			</select>
			<span class="required__badge" [innerHTML]="'required' | label"></span>
			<svg class="icon--caret-down"><use xlink:href="#caret-down"></use></svg>
		</div>
		<errors-component [control]="control"></errors-component>
	`
};class ControlTextComponent extends ControlComponent {
  onInit() {
    this.label = this.label || 'label';
    this.disabled = this.disabled || false;
  }
}
ControlTextComponent.meta = {
  selector: '[control-text]',
  inputs: ['control', 'label', 'disabled'],
  template: /* html */`
		<div class="group--form" [class]="{ required: control.validators.length, disabled: disabled }">
			<label [innerHTML]="label"></label>
			<span class="required__badge" [innerHTML]="'required' | label"></span>
			<input type="text" class="control--text" [formControl]="control" [placeholder]="label" [disabled]="disabled" />
		</div>
		<errors-component [control]="control"></errors-component>
	`
};class ControlTextareaComponent extends ControlComponent {
  onInit() {
    this.label = this.label || 'label';
    this.disabled = this.disabled || false;
  }
}
ControlTextareaComponent.meta = {
  selector: '[control-textarea]',
  inputs: ['control', 'label', 'disabled'],
  template: /* html */`
		<div class="group--form--textarea" [class]="{ required: control.validators.length, disabled: disabled }">
			<label [innerHTML]="label"></label>
			<textarea class="control--text" [formControl]="control" [placeholder]="label" [innerHTML]="label" rows="4" [disabled]="disabled"></textarea>
			<span class="required__badge" [innerHTML]="'required' | label"></span>
		</div>
		<errors-component [control]="control"></errors-component>
	`
};class ControlVectorComponent extends ControlComponent {
  onInit() {
    this.label = this.label || 'label';
    this.precision = this.precision || 3;
    this.increment = this.increment || 1 / Math.pow(10, this.precision);
    this.disabled = this.disabled || false;
  }
  updateValue(index, value) {
    const values = this.control.value;
    values[index] = value;
    this.control.value = values.slice();
  }
}
ControlVectorComponent.meta = {
  selector: '[control-vector]',
  inputs: ['control', 'label', 'precision', 'increment', 'disabled'],
  template: /* html */`
		<div class="group--form" [class]="{ required: control.validators.length }">
			<div class="control--head">
				<label [innerHTML]="label"></label>
				<span class="required__badge" [innerHTML]="'required' | label"></span>
			</div>
			<div class="control--content control--vector">
				<input-value label="x" [precision]="precision" [increment]="increment" [disabled]="disabled" [value]="control.value[0]" (update)="updateValue(0, $event)"></input-value>
				<input-value label="y" [precision]="precision" [increment]="increment" [disabled]="disabled" [value]="control.value[1]" (update)="updateValue(1, $event)"></input-value>
				<input-value label="z" [precision]="precision" [increment]="increment" [disabled]="disabled" [value]="control.value[2]" (update)="updateValue(2, $event)"></input-value>
			</div>
		</div>
		<errors-component [control]="control"></errors-component>
	`
};class DisabledDirective extends rxcomp.Directive {
  onChanges() {
    const {
      node
    } = rxcomp.getContext(this);
    // console.log('DisabledDirective.onChanges', this.disabled);
    if (this.disabled === true) {
      node.disabled = this.disabled;
      node.setAttribute('disabled', this.disabled);
    } else {
      delete node.disabled;
      node.removeAttribute('disabled');
    }
  }
}
DisabledDirective.meta = {
  selector: 'input[disabled],textarea[disabled]',
  inputs: ['disabled']
};class ErrorsComponent extends ControlComponent {
  getLabel(key, value) {
    const label = LabelPipe.transform(`error_${key}`);
    return label;
  }
}
ErrorsComponent.meta = {
  selector: 'errors-component',
  inputs: ['control'],
  template: /* html */`
	<div class="inner" [style]="{ display: control.invalid && control.touched ? 'block' : 'none' }">
		<div class="error" *for="let [key, value] of control.errors">
			<span [innerHTML]="getLabel(key, value)"></span>
			<!-- <span class="key" [innerHTML]="key"></span> <span class="value" [innerHTML]="value | json"></span> -->
		</div>
	</div>
	`
};class InputValueComponent extends rxcomp.Component {
  onInit() {
    this.label = this.label || 'label';
    this.value = this.value || 0;
    this.precision = this.precision || 3;
    this.increment = this.increment || 1 / Math.pow(10, this.precision);
    this.disabled = this.disabled || false;
    this.increment$('.btn--more', 1).pipe(operators.takeUntil(this.unsubscribe$)).subscribe(event => {
      // console.log('InputValueComponent.increment$', event);
      this.value += event;
      this.update.next(this.value);
      this.pushChanges();
    });
    this.increment$('.btn--less', -1).pipe(operators.takeUntil(this.unsubscribe$)).subscribe(event => {
      // console.log('InputValueComponent.increment$', event);
      this.value += event;
      this.update.next(this.value);
      this.pushChanges();
    });
    const {
      node
    } = rxcomp.getContext(this);
    const input = this.input = node.querySelector('input');
    // fromEvent(input, 'change')
    rxjs.merge(rxjs.fromEvent(input, 'input')).pipe(operators.takeUntil(this.unsubscribe$)).subscribe(event => this.onInputDidChange(event));
    rxjs.merge(rxjs.fromEvent(input, 'blur'), rxjs.fromEvent(input, 'keydown').pipe(operators.filter(event => event.key === 'Enter' || event.keyCode === 13))).pipe(operators.takeUntil(this.unsubscribe$)).subscribe(event => this.onInputDidBlur(event));
    // fromEvent(node, 'focus').pipe(takeUntil(this.unsubscribe$)).subscribe(event => this.onFocus(event));
  }

  onInputDidChange(event) {
    // const node = getContext(this).node;
    // const value = node.value === '' ? null : node.value;
    // eslint-disable-next-line no-useless-escape
    event.target.value = event.target.value.replace(/[^\d|\.|-]/g, '');
    // console.log('InputValueComponent.onInputDidChange', event.target.value);
    /*
    const value = parseFloat(event.target.value);
    if (this.value !== value) {
    	if (value !== NaN) {
    		this.value = value;
    		this.update.next(this.value);
    	}
    }
    */
  }

  onInputDidBlur(event) {
    // this.control.touched = true;
    // console.log('InputValueComponent.onInputDidBlur', event.target.value);
    const value = parseFloat(this.input.value);
    if (this.value !== value) {
      if (!isNaN(value)) {
        this.value = value;
        this.update.next(this.value);
      } else {
        this.input.value = this.getValue();
      }
    }
  }
  increment$(selector, sign) {
    const {
      node
    } = rxcomp.getContext(this);
    const element = node.querySelector(selector);
    let m, increment;
    return rxjs.race(rxjs.fromEvent(element, 'mousedown'), rxjs.fromEvent(element, 'touchstart')).pipe(operators.tap(() => {
      increment = this.increment;
      m = 16;
    }), operators.switchMap(e => {
      return rxjs.interval(30).pipe(operators.filter(i => {
        return i % m === 0;
      }), operators.map(() => {
        const i = increment * sign;
        // increment = Math.min(this.increment * 100, increment * 2);
        m = Math.max(1, Math.floor(m * 0.85));
        return i;
      }),
      // startWith(increment * sign),
      operators.takeUntil(rxjs.race(rxjs.fromEvent(element, 'mouseup'), rxjs.fromEvent(element, 'touchend'))));
    }));
  }
  getValue() {
    return this.value.toFixed(this.precision);
  }
  setValue(sign) {
    this.value += this.increment * sign;
    this.update.next(this.value);
    this.pushChanges();
  }
}
InputValueComponent.meta = {
  selector: 'input-value',
  outputs: ['update'],
  inputs: ['value', 'label', 'precision', 'increment', 'disabled'],
  template: /* html */`
		<div class="group--control" [class]="{ disabled: disabled }">
			<input type="text" class="control--text" [placeholder]="label" [value]="getValue()" [disabled]="disabled" />
			<div class="control--trigger">
				<div class="btn--more" (click)="setValue(1)">+</div>
				<div class="btn--less" (click)="setValue(-1)">-</div>
			</div>
		</div>
	`
};class TestComponent extends rxcomp.Component {
  onInit() {
    this.env = ENV;
  }
  onTest(event) {
    this.test.next(event);
  }
  onReset(event) {
    this.reset.next(event);
  }
}
TestComponent.meta = {
  selector: 'test-component',
  inputs: ['form'],
  outputs: ['test', 'reset'],
  template: /* html */`
	<div class="group--form--results" *if="env.DEVELOPMENT">
		<code [innerHTML]="form.value | json"></code>
		<button type="button" class="btn--mode" (click)="onReset($event)"><span>reset</span></button>
		<button type="button" class="btn--mode" (click)="onTest($event)"><span>test</span></button>
	</div>
	`
};class ValueDirective extends rxcomp.Directive {
  onChanges(changes) {
    const {
      node
    } = rxcomp.getContext(this);
    // console.log('ValueDirective.onChanges', this.value);
    node.value = this.value;
    node.setAttribute('value', this.value);
  }
}
ValueDirective.meta = {
  selector: '[value]',
  inputs: ['value']
};/*
['quot', 'amp', 'apos', 'lt', 'gt', 'nbsp', 'iexcl', 'cent', 'pound', 'curren', 'yen', 'brvbar', 'sect', 'uml', 'copy', 'ordf', 'laquo', 'not', 'shy', 'reg', 'macr', 'deg', 'plusmn', 'sup2', 'sup3', 'acute', 'micro', 'para', 'middot', 'cedil', 'sup1', 'ordm', 'raquo', 'frac14', 'frac12', 'frac34', 'iquest', 'Agrave', 'Aacute', 'Acirc', 'Atilde', 'Auml', 'Aring', 'AElig', 'Ccedil', 'Egrave', 'Eacute', 'Ecirc', 'Euml', 'Igrave', 'Iacute', 'Icirc', 'Iuml', 'ETH', 'Ntilde', 'Ograve', 'Oacute', 'Ocirc', 'Otilde', 'Ouml', 'times', 'Oslash', 'Ugrave', 'Uacute', 'Ucirc', 'Uuml', 'Yacute', 'THORN', 'szlig', 'agrave', 'aacute', 'atilde', 'auml', 'aring', 'aelig', 'ccedil', 'egrave', 'eacute', 'ecirc', 'euml', 'igrave', 'iacute', 'icirc', 'iuml', 'eth', 'ntilde', 'ograve', 'oacute', 'ocirc', 'otilde', 'ouml', 'divide', 'oslash', 'ugrave', 'uacute', 'ucirc', 'uuml', 'yacute', 'thorn', 'yuml', 'amp', 'bull', 'deg', 'infin', 'permil', 'sdot', 'plusmn', 'dagger', 'mdash', 'not', 'micro', 'perp', 'par', 'euro', 'pound', 'yen', 'cent', 'copy', 'reg', 'trade', 'alpha', 'beta', 'gamma', 'delta', 'epsilon', 'zeta', 'eta', 'theta', 'iota', 'kappa', 'lambda', 'mu', 'nu', 'xi', 'omicron', 'pi', 'rho', 'sigma', 'tau', 'upsilon', 'phi', 'chi', 'psi', 'omega', 'Alpha', 'Beta', 'Gamma', 'Delta', 'Epsilon', 'Zeta', 'Eta', 'Theta', 'Iota', 'Kappa', 'Lambda', 'Mu', 'Nu', 'Xi', 'Omicron', 'Pi', 'Rho', 'Sigma', 'Tau', 'Upsilon', 'Phi', 'Chi', 'Psi', 'Omega'];
['"', '&', ''', '<', '>', ' ', '¡', '¢', '£', '¤', '¥', '¦', '§', '¨', '©', 'ª', '«', '¬', '­', '®', '¯', '°', '±', '²', '³', '´', 'µ', '¶', '·', '¸', '¹', 'º', '»', '¼', '½', '¾', '¿', 'À', 'Á', 'Â', 'Ã', 'Ä', 'Å', 'Æ', 'Ç', 'È', 'É', 'Ê', 'Ë', 'Ì', 'Í', 'Î', 'Ï', 'Ð', 'Ñ', 'Ò', 'Ó', 'Ô', 'Õ', 'Ö', '×', 'Ø', 'Ù', 'Ú', 'Û', 'Ü', 'Ý', 'Þ', 'ß', 'à', 'á', 'ã', 'ä', 'å', 'æ', 'ç', 'è', 'é', 'ê', 'ë', 'ì', 'í', 'î', 'ï', 'ð', 'ñ', 'ò', 'ó', 'ô', 'õ', 'ö', '÷', 'ø', 'ù', 'ú', 'û', 'ü', 'ý', 'þ', 'ÿ', '&', '•', '°', '∞', '‰', '⋅', '±', '†', '—', '¬', 'µ', '⊥', '∥', '€', '£', '¥', '¢', '©', '®', '™', 'α', 'β', 'γ', 'δ', 'ε', 'ζ', 'η', 'θ', 'ι', 'κ', 'λ', 'μ', 'ν', 'ξ', 'ο', 'π', 'ρ', 'σ', 'τ', 'υ', 'φ', 'χ', 'ψ', 'ω', 'Α', 'Β', 'Γ', 'Δ', 'Ε', 'Ζ', 'Η', 'Θ', 'Ι', 'Κ', 'Λ', 'Μ', 'Ν', 'Ξ', 'Ο', 'Π', 'Ρ', 'Σ', 'Τ', 'Υ', 'Φ', 'Χ', 'Ψ', 'Ω'];
*/

class HtmlPipe extends rxcomp.Pipe {
  static transform(value) {
    if (value) {
      value = value.replace(/&#(\d+);/g, function (m, n) {
        return String.fromCharCode(parseInt(n));
      });
      const escapes = ['quot', 'amp', 'apos', 'lt', 'gt', 'nbsp', 'iexcl', 'cent', 'pound', 'curren', 'yen', 'brvbar', 'sect', 'uml', 'copy', 'ordf', 'laquo', 'not', 'shy', 'reg', 'macr', 'deg', 'plusmn', 'sup2', 'sup3', 'acute', 'micro', 'para', 'middot', 'cedil', 'sup1', 'ordm', 'raquo', 'frac14', 'frac12', 'frac34', 'iquest', 'Agrave', 'Aacute', 'Acirc', 'Atilde', 'Auml', 'Aring', 'AElig', 'Ccedil', 'Egrave', 'Eacute', 'Ecirc', 'Euml', 'Igrave', 'Iacute', 'Icirc', 'Iuml', 'ETH', 'Ntilde', 'Ograve', 'Oacute', 'Ocirc', 'Otilde', 'Ouml', 'times', 'Oslash', 'Ugrave', 'Uacute', 'Ucirc', 'Uuml', 'Yacute', 'THORN', 'szlig', 'agrave', 'aacute', 'atilde', 'auml', 'aring', 'aelig', 'ccedil', 'egrave', 'eacute', 'ecirc', 'euml', 'igrave', 'iacute', 'icirc', 'iuml', 'eth', 'ntilde', 'ograve', 'oacute', 'ocirc', 'otilde', 'ouml', 'divide', 'oslash', 'ugrave', 'uacute', 'ucirc', 'uuml', 'yacute', 'thorn', 'yuml', 'amp', 'bull', 'deg', 'infin', 'permil', 'sdot', 'plusmn', 'dagger', 'mdash', 'not', 'micro', 'perp', 'par', 'euro', 'pound', 'yen', 'cent', 'copy', 'reg', 'trade', 'alpha', 'beta', 'gamma', 'delta', 'epsilon', 'zeta', 'eta', 'theta', 'iota', 'kappa', 'lambda', 'mu', 'nu', 'xi', 'omicron', 'pi', 'rho', 'sigma', 'tau', 'upsilon', 'phi', 'chi', 'psi', 'omega', 'Alpha', 'Beta', 'Gamma', 'Delta', 'Epsilon', 'Zeta', 'Eta', 'Theta', 'Iota', 'Kappa', 'Lambda', 'Mu', 'Nu', 'Xi', 'Omicron', 'Pi', 'Rho', 'Sigma', 'Tau', 'Upsilon', 'Phi', 'Chi', 'Psi', 'Omega'];
      const unescapes = ['"', '&', '\'', '<', '>', ' ', '¡', '¢', '£', '¤', '¥', '¦', '§', '¨', '©', 'ª', '«', '¬', '­', '®', '¯', '°', '±', '²', '³', '´', 'µ', '¶', '·', '¸', '¹', 'º', '»', '¼', '½', '¾', '¿', 'À', 'Á', 'Â', 'Ã', 'Ä', 'Å', 'Æ', 'Ç', 'È', 'É', 'Ê', 'Ë', 'Ì', 'Í', 'Î', 'Ï', 'Ð', 'Ñ', 'Ò', 'Ó', 'Ô', 'Õ', 'Ö', '×', 'Ø', 'Ù', 'Ú', 'Û', 'Ü', 'Ý', 'Þ', 'ß', 'à', 'á', 'ã', 'ä', 'å', 'æ', 'ç', 'è', 'é', 'ê', 'ë', 'ì', 'í', 'î', 'ï', 'ð', 'ñ', 'ò', 'ó', 'ô', 'õ', 'ö', '÷', 'ø', 'ù', 'ú', 'û', 'ü', 'ý', 'þ', 'ÿ', '&', '•', '°', '∞', '‰', '⋅', '±', '†', '—', '¬', 'µ', '⊥', '∥', '€', '£', '¥', '¢', '©', '®', '™', 'α', 'β', 'γ', 'δ', 'ε', 'ζ', 'η', 'θ', 'ι', 'κ', 'λ', 'μ', 'ν', 'ξ', 'ο', 'π', 'ρ', 'σ', 'τ', 'υ', 'φ', 'χ', 'ψ', 'ω', 'Α', 'Β', 'Γ', 'Δ', 'Ε', 'Ζ', 'Η', 'Θ', 'Ι', 'Κ', 'Λ', 'Μ', 'Ν', 'Ξ', 'Ο', 'Π', 'Ρ', 'Σ', 'Τ', 'Υ', 'Φ', 'Χ', 'Ψ', 'Ω'];
      const rx = new RegExp(`(&${escapes.join(';)|(&')};)`, 'g');
      value = value.replace(rx, function () {
        for (let i = 1; i < arguments.length; i++) {
          if (arguments[i]) {
            // console.log(arguments[i], unescapes[i - 1]);
            return unescapes[i - 1];
          }
        }
      });
      // console.log(value);
      return value;
    }
  }
}
HtmlPipe.meta = {
  name: 'html'
};class IdDirective extends rxcomp.Directive {
  onChanges() {
    const {
      node
    } = rxcomp.getContext(this);
    node.setAttribute('id', this.id);
  }
}
IdDirective.meta = {
  selector: '[id]',
  inputs: ['id']
};class LanguageComponent extends rxcomp.Component {
  onInit() {
    this.showLanguages = false;
    this.languageService = LanguageService;
  }
  setLanguage(language) {
    this.languageService.setLanguage$(language).pipe(operators.first()).subscribe(_ => {
      this.showLanguages = false;
      this.pushChanges();
      this.set.next();
    });
  }
  toggleLanguages() {
    this.showLanguages = !this.showLanguages;
    this.pushChanges();
  }
}
LanguageComponent.meta = {
  selector: '[language]',
  outputs: ['set'],
  template: /* html */`
		<button type="button" class="btn--language" (click)="toggleLanguages()" *if="languageService.hasLanguages"><span [innerHTML]="languageService.activeLanguage.title"></span> <svg viewBox="0 0 8 5"><use xlink:href="#caret-down"></use></svg></button>
		<ul class="nav--language" *if="showLanguages">
			<li (click)="setLanguage(language)" *for="let language of languageService.languages"><span [innerHTML]="language.title"></span></li>
		</ul>
	`
};class IntersectionService {
  static observer() {
    if (!this.observer_) {
      this.readySubject_ = new rxjs.BehaviorSubject(false);
      this.observerSubject_ = new rxjs.Subject();
      this.observer_ = new IntersectionObserver(entries => {
        this.observerSubject_.next(entries);
      });
    }
    return this.observer_;
  }
  static intersection$(node) {
    if ('IntersectionObserver' in window) {
      const observer = this.observer();
      observer.observe(node);
      return this.observerSubject_.pipe(
      // tap(entries => console.log(entries.length)),
      operators.map(entries => entries.find(entry => entry.target === node)),
      // tap(entry => console.log('IntersectionService.intersection$', entry)),
      operators.filter(entry => entry !== undefined && entry.isIntersecting),
      // entry.intersectionRatio > 0
      operators.first(), operators.finalize(() => observer.unobserve(node)));
    } else {
      return rxjs.of({
        target: node
      });
    }

    /*
    function observer() {
    	if ('IntersectionObserver' in window) {
    		return new IntersectionObserver(entries => {
    			entries.forEach(function(entry) {
    				if (entry.isIntersecting) {
    					entry.target.classList.add('appear');
    				}
    			})
    		});
    	} else {
    		return { observe: function(node) { node.classList.add('appear')}, unobserve: function() {} };
    	}
    }
    observer.observe(node);
    observer.unobserve(node);
    */
  }
}class LazyCache {
  static get cache() {
    if (!this.cache_) {
      this.cache_ = {};
    }
    return this.cache_;
  }
  static get(src) {
    return this.cache[src];
  }
  static set(src, blob) {
    this.cache[src] = blob;
    const keys = Object.keys(this.cache);
    if (keys.length > 100) {
      this.remove(keys[0]);
    }
  }
  static remove(src) {
    delete this.cache[src];
  }
}class LazyDirective extends rxcomp.Directive {
  onInit() {
    const {
      node
    } = rxcomp.getContext(this);
    node.classList.add('lazy');
    this.input$ = new rxjs.Subject().pipe(operators.distinctUntilChanged(), operators.switchMap(input => {
      const src = LazyCache.get(input);
      if (src) {
        return rxjs.of(src);
      }
      node.classList.remove('lazyed');
      return this.lazy$(input);
    }), operators.takeUntil(this.unsubscribe$));
    this.input$.subscribe(src => {
      LazyCache.set(this.lazy, src);
      node.setAttribute('src', src);
      node.classList.add('lazyed');
    });
  }
  onChanges() {
    this.input$.next(this.lazy);
  }
  lazy$(input) {
    const {
      node
    } = rxcomp.getContext(this);
    return IntersectionService.intersection$(node).pipe(
    // first(),
    operators.switchMap(() => ImageService.load$(input, this.size)), operators.first()
    // takeUntil(this.unsubscribe$),
    );
  }
}

LazyDirective.meta = {
  selector: '[lazy],[[lazy]]',
  inputs: ['lazy', 'size']
};// export const URL_PATTERN = '/((http:\/\/|https:\/\/|www\.)([a-z0-9])([a-z0-9]|\.)+(\?[a-z]([a-z0-9]|\=|\&)+)?)';

class MessagePipe extends rxcomp.Pipe {
  static transform(text) {
    let html = MessagePipe.urlify(text);
    html = MessagePipe.breakLines(html);
    // console.log('MessagePipe', text, html);
    return html;
  }
  static urlify(text) {
    // const regex = new RegExp(URL_PATTERN, 'gim');
    // eslint-disable-next-line no-useless-escape
    const regex = /(?:(?:https?|ftp):\/\/|\b(?:[a-z\d]+\.))(?:(?:[^\s()<>]+|\((?:[^\s()<>]+|(?:\([^\s()<>]+\)))?\))+(?:\((?:[^\s()<>]+|(?:\(?:[^\s()<>]+\)))?\)|[^\s`!()\[\]{};:'".,<>?«»“”‘’]))?/gmi;
    return text.replace(regex, url => {
      return (/*html*/`<a href="${url}" target="_blank">${url}</a>`
      );
    });
    // or alternatively
    // return text.replace(urlRegex, '<a href="$1">$1</a>')
  }

  static breakLines(text) {
    const regex = /\n/gm;
    return text.replace(regex, text => {
      return (/*html*/'<br>'
      );
    });
  }
}
MessagePipe.meta = {
  name: 'message'
};class ModalComponent extends rxcomp.Component {
  onInit() {
    const {
      parentInstance
    } = rxcomp.getContext(this);
    if (parentInstance instanceof ModalOutletComponent) {
      this.data = parentInstance.modal.data;
    }
  }
  onClose() {
    ModalService.reject();
  }
}
ModalComponent.meta = {
  selector: '[modal]'
};class RouterLinkDirective extends rxcomp.Directive {
  constructor() {
    super(...arguments);
    this.path = void 0;
    this.segments = void 0;
    this.routerLink_ = void 0;
  }
  get routerLink() {
    return this.routerLink_;
  }
  set routerLink(routerLink) {
    this.routerLink_ = Array.isArray(routerLink) ? routerLink : [routerLink];
    // this.segments = this.getSegments(this.routerLink_);
  }

  onInit() {
    // const { node, module } = getContext(this);
    // console.log('RouterLinkDirective.onInit', this.routerLink, node, module);
    this.routerLink$().pipe(operators.takeUntil(this.unsubscribe$)).subscribe();
  }
  onChanges() {
    const {
      node
    } = rxcomp.getContext(this);
    // const routerLink = Array.isArray(this.routerLink) ? this.routerLink : [this.routerLink];
    const routerLink = this.routerLink;
    if (routerLink.length) {
      const routeUrl = RouterService.buildUrl(...routerLink);
      // RouterService.isActive(name, params, [strictEquality], [ignoreQueryParams])
      // console.log('RouterLinkDirective.routeUrl', routeUrl);
      node.setAttribute('href', routeUrl);
    } else {
      node.setAttribute('href', '');
    }
  }
  routerLink$() {
    const {
      node
    } = rxcomp.getContext(this);
    return rxjs.fromEvent(node, 'click').pipe(operators.map(event => {
      // console.log('RouterLinkDirective.routerLink$', this.routerLink);
      RouterService.setRouterLink(...this.routerLink);
      event.preventDefault();
      return false;
    }));
  }
  getSegments(routerLink) {
    // console.log('RouterLinkDirective.getSegments', routerLink);
    const segments = [];
    routerLink.forEach(item => {
      if (typeof item === 'string') {
        // eslint-disable-next-line no-useless-escape
        const regExp = /([^:]+)|\:([^\/]+)/g;
        const matches = item.matchAll(regExp);
        for (let match of matches) {
          const g1 = match[1];
          const g2 = match[2];
          if (g1) ; else if (g2) {
            const param = {};
            param[g2] = null;
          }
        }
      } else {
        // !!! todo fix RouteSegment
        segments.push(new RouteSegment('', {}));
      }
    });
    return segments;
  }
}

/*
get urlTree(): UrlTree {
	return RouterService.createUrlTree(this.routerLink, {
		relativeTo: this.route,
		queryParams: this.queryParams,
		fragment: this.fragment,
		preserveQueryParams: this.preserve,
		queryParamsHandling: this.queryParamsHandling,
		preserveFragment: this.preserveFragment,
	});
}
*/
RouterLinkDirective.meta = {
  selector: '[routerLink]',
  inputs: ['routerLink']
};class SupportRequestModalComponent extends rxcomp.Component {
  onInit() {
    super.onInit();
    const {
      parentInstance
    } = rxcomp.getContext(this);
    if (parentInstance instanceof ModalOutletComponent) {
      this.data = parentInstance.modal.data;
    }
  }
  onAccept(user) {
    ModalService.resolve();
  }
  onReject(user) {
    ModalService.reject();
  }
  onClose() {
    ModalService.reject();
  }
}
SupportRequestModalComponent.meta = {
  selector: '[support-request-modal]',
  template: /* html */`
		<div class="modal__header">
			<button type="button" class="btn--close" (click)="onClose()">
				<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#close"></use></svg>
			</button>
		</div>
		<div class="container">
			<div class="form">
				<div class="title">Un operatore è disponibile per un tour guidato.<br>Desideri Accettare?</div>
				<div class="group--cta">
					<button type="button" class="btn--accept" (click)="onAccept()">
						<span>Accetta</span>
					</button>
					<button type="button" class="btn--cancel" (click)="onReject()">
						<span>Rifiuta</span>
					</button>
				</div>
			</div>
		</div>
	`
};
SupportRequestModalComponent.chunk = () => /* html */'<div class="support-request-modal" support-request-modal></div>';class SvgIconStructure extends rxcomp.Structure {
  onInit() {
    this.update();
  }
  onChanges() {
    this.update();
  }
  update() {
    if (this.name_ !== this.name) {
      this.name_ = this.name;
      const {
        node
      } = rxcomp.getContext(this);
      if (node.parentNode) {
        const xmlns = 'http://www.w3.org/2000/svg';
        const element = document.createElementNS(xmlns, 'svg');
        const w = this.width || 24;
        const h = this.height || 24;
        element.setAttribute('class', `icon--${this.name}`);
        // element.setAttributeNS(null, 'width', w);
        // element.setAttributeNS(null, 'height', h);
        element.setAttributeNS(null, 'viewBox', `0 0 ${w} ${h}`);
        element.innerHTML = `<use xlink:href="#${this.name}"></use>`;
        element.rxcompId = node.rxcompId;
        element.classList.add(...node.classList);
        node.parentNode.replaceChild(element, node);
      }
    }
  }
}
SvgIconStructure.meta = {
  selector: 'svg-icon',
  inputs: ['name', 'width', 'height']
};

/*
<svg class="copy" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#copy"></use></svg>
*/class TitleDirective extends rxcomp.Directive {
  set title(title) {
    if (this.title_ !== title) {
      this.title_ = title;
      const {
        node
      } = rxcomp.getContext(this);
      title ? node.setAttribute('title', title) : node.removeAttribute('title');
    }
  }
  get title() {
    return this.title_;
  }
}
TitleDirective.meta = {
  selector: '[[title]]',
  inputs: ['title']
};class UploadItemComponent extends rxcomp.Component {
  onInit() {
    // console.log('UploadItemComponent.onInit', this.item);
    if (this.item.preview === null) {
      this.read$(this.item.file).pipe(operators.takeUntil(this.unsubscribe$)).subscribe(preview => {
        this.item.preview = preview;
        this.pushChanges();
      });
    }
  }
  read$(file) {
    const reader = new FileReader();
    const reader$ = rxjs.fromEvent(reader, 'load').pipe(operators.switchMap(event => {
      const blob = event.target.result;
      if (this.item.type.name === AssetType.Image.name) {
        return this.resize$(blob);
      } else {
        return rxjs.of(blob);
      }
    }));
    reader.readAsDataURL(file);
    return reader$;
  }
  resize$(blob) {
    return new Promise((resolve, reject) => {
      const img = document.createElement('img');
      img.onload = function () {
        const MAX_WIDTH = 320;
        const MAX_HEIGHT = 240;
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        let width = img.width;
        let height = img.height;
        if (width > height) {
          if (width > MAX_WIDTH) {
            height *= MAX_WIDTH / width;
            width = MAX_WIDTH;
          }
        } else {
          if (height > MAX_HEIGHT) {
            width *= MAX_HEIGHT / height;
            height = MAX_HEIGHT;
          }
        }
        canvas.width = width;
        canvas.height = height;
        ctx.drawImage(img, 0, 0, width, height);
        const dataUrl = canvas.toDataURL('image/jpeg', 0.9);
        resolve(dataUrl);
      };
      img.onerror = function (error) {
        reject(error);
      };
      img.src = blob;
    });
  }
  onPause() {
    this.pause.next(this.item);
  }
  onResume() {
    this.resume.next(this.item);
  }
  onCancel() {
    this.cancel.next(this.item);
  }
  onRemove() {
    this.remove.next(this.item);
  }
}
UploadItemComponent.meta = {
  selector: '[upload-item]',
  outputs: ['pause', 'resume', 'cancel', 'remove'],
  inputs: ['item'],
  template: /* html */`
	<div class="upload-item" [class]="{ 'error': item.error, 'success': item.success }">
		<div class="picture">
			<img [lazy]="item.preview" [size]="{ width: 320, height: 240 }" *if="item.preview && item.type.name === 'image'" />
			<video [src]="item.preview" *if="item.preview && item.type.name === 'video'"></video>
			<svg class="spinner" width="24" height="24" viewBox="0 0 24 24" [class]="{ uploading: item.uploading }" *if="item.uploading"><use xlink:href="#spinner"></use></svg>
		</div>
		<div class="name">{{item.name}}</div>
		<!--
		<div class="group--info">
			<div>progress: {{item.progress}}</div>
			<div>size: {{item.size}} bytes</div>
			<div>current speed: {{item.currentSpeed}} bytes/s</div>
			<div>average speed: {{item.averageSpeed}} bytes/s</div>
			<div>time ramining: {{item.timeRemaining}}s</div>
			<div>paused: {{item.paused}}</div>
			<div>success: {{item.success}}</div>
			<div>complete: {{item.complete}}</div>
			<div>error: {{item.error}}</div>
		</div>
		-->
		<!--
		<div class="group--cta" *if="!item.complete && item.uploading">
			<div class="btn--pause" (click)="onPause()">pause</div>
			<div class="btn--resume" (click)="onResume()">resume</div>
			<div class="btn--cancel" (click)="onCancel()">cancel</div>
		</div>
		-->
		<div class="group--cta">
			<div class="btn--remove" (click)="onRemove()" *if="!item.complete">remove</div>
		</div>
	</div>
	`
};class HlsDirective extends rxcomp.Directive {
  set hls(hls) {
    if (this.hls_ !== hls) {
      this.hls_ = hls;
      this.play(hls);
    }
  }
  get hls() {
    return this.hls_;
  }
  play(src) {
    const {
      node
    } = rxcomp.getContext(this);
    if (Hls.isSupported()) {
      var hls = new Hls();
      // bind them together
      hls.attachMedia(node);
      hls.on(Hls.Events.MEDIA_ATTACHED, () => {
        hls.loadSource(src);
        hls.on(Hls.Events.MANIFEST_PARSED, (event, data) => {
          // console.log('HlsDirective', data.levels);
          node.play();
        });
      });
    }
  }
}
HlsDirective.meta = {
  selector: '[[hls]]',
  inputs: ['hls']
};class VirtualItem extends rxcomp.Context {
  constructor(key, $key, value, $value, index, count, parentInstance) {
    super(parentInstance);
    this[key] = $key;
    this[value] = $value;
    this.index = index;
    this.count = count;
  }
  get first() {
    return this.index === 0;
  }
  get last() {
    return this.index === this.count - 1;
  }
  get even() {
    return this.index % 2 === 0;
  }
  get odd() {
    return !this.even;
  }
}const VirtualMode = {
  Responsive: 1,
  Grid: 2,
  Centered: 3,
  List: 4
};
class VirtualStructure extends rxcomp.Structure {
  onInit() {
    const {
      module,
      node
    } = rxcomp.getContext(this);
    const template = node.firstElementChild;
    const expression = node.getAttribute('*virtual');
    node.removeAttribute('*virtual');
    node.removeChild(template);
    const tokens = this.tokens = this.getExpressionTokens(expression);
    this.virtualFunction = module.makeFunction(tokens.iterable);
    this.container = node;
    this.template = template;
    this.mode = this.mode || 1;
    this.width = this.width || 250;
    this.gutter = this.gutter !== undefined ? this.gutter : 20;
    this.reverse = this.reverse === true ? true : false;
    this.options = {
      width: this.width,
      gutter: this.gutter,
      reverse: this.reverse,
      containerWidth: 0,
      containerHeight: 0,
      top: 0,
      cols: [0]
    };
    this.cachedRects = {};
    this.cachedInstances = [];
    this.cacheNodes = [];
    this.items$ = new rxjs.BehaviorSubject([]);
    this.update$().pipe(operators.takeUntil(this.unsubscribe$)).subscribe(visibleItems => {
      // console.log(visibleItems.length);
    });
  }
  onChanges(changes) {
    const context = rxcomp.getContext(this);
    const module = context.module;
    // resolve
    const items = module.resolve(this.virtualFunction, context.parentInstance, this) || [];
    this.mode = this.mode || 1;
    this.width = this.width || 250;
    this.gutter = this.gutter !== undefined ? this.gutter : 20;
    this.options.width = this.width;
    this.updateView(true);
    this.items$.next(items);
    // console.log('VirtualStructure', 'items.length', items.length);
  }

  update$() {
    this.updateView(true);
    return rxjs.merge(this.scroll$(), this.resize$(), this.items$.pipe(operators.distinctUntilChanged())).pipe(operators.map(_ => {
      const visibleItems = this.updateForward();
      return visibleItems;
    }));
  }
  updateForward() {
    const options = this.options;
    const items = this.items$.getValue();
    const total = items.length;
    this.container.position = 'relative';
    let highestHeight = 0;
    const width = this.getWidth();
    const gutter = this.getGutter(width);
    const visibleItems = [];
    for (let i = 0, len = items.length; i < len; i++) {
      const item = items[i];
      let col, height, top, left, bottom;
      let rect = this.cachedRects[i];
      if (rect) {
        col = rect.col;
        height = rect.height;
        left = rect.left;
        // top = rect.top;
        // bottom = rect.bottom;
      } else {
        col = this.getCol();
        height = this.getHeight(width, item);
      }
      top = options.cols[col];
      if (this.intersect(top + options.top, top + height + options.top, 0, options.containerHeight)) {
        if (!rect) {
          left = this.getLeft(col, width, gutter);
        }
        const node = this.cachedNode(i, i, item, total);
        node.style.position = 'absolute';
        node.style.top = top + 'px';
        node.style.left = left + 'px';
        node.style.width = width + 'px';
        if (height !== node.offsetHeight) {
          height = node.offsetHeight;
        }
        bottom = top + height + options.gutter;
        highestHeight = Math.max(highestHeight, bottom);
        options.cols[col] = bottom;
        if (!rect) {
          this.cachedRects[i] = {
            col,
            width,
            height,
            left,
            top,
            bottom
          };
        } else {
          rect.height = height;
          rect.bottom = bottom;
        }
        visibleItems.push(item);
      } else {
        this.removeNode(i);
        bottom = top + height + options.gutter;
        options.cols[col] = bottom;
        highestHeight = Math.max(highestHeight, bottom);
      }
    }
    let removeIndex = items.length;
    while (removeIndex < this.cacheNodes.length) {
      this.removeNode(removeIndex);
      removeIndex++;
    }
    this.cacheNodes.length = items.length;
    const parentContainer = this.container.parentNode;
    if (this.reverse && highestHeight < parentContainer.offsetHeight - 1) {
      const diff = parentContainer.offsetHeight - 1 - highestHeight;
      items.forEach((item, i) => {
        if (visibleItems.indexOf(item) !== -1) {
          const rect = this.cachedRects[i];
          const node = this.cachedNode(i, i, item, total);
          node.style.top = rect.top + diff + 'px';
        }
      });
      this.container.style.height = `${parentContainer.offsetHeight - 1}px`;
    } else {
      this.container.style.height = `${highestHeight}px`;
    }
    // console.log('VirtualStructure.updateForward', 'items.length', items.length, highestHeight, visibleItems);
    return visibleItems;
  }

  /*
  updateForward__() {
  	const options = this.options;
  	const items = this.items$.getValue();
  	// console.log('VirtualStructure', 'items.length', items.length);
  	const total = items.length;
  	this.container.position = 'relative';
  	let highestHeight = 0;
  	const width = this.getWidth();
  	const gutter = this.getGutter(width);
  	const visibleItems = items.filter((item, i) => {
  		let col, height, top, left, bottom;
  		let rect = this.cachedRects[i];
  		if (rect) {
  			col = rect.col;
  			height = rect.height;
  			left = rect.left;
  			// top = rect.top;
  			// bottom = rect.bottom;
  		} else {
  			col = this.getCol();
  			height = this.getHeight(width, item);
  		}
  		top = options.cols[col];
  		if (this.intersect(top + options.top, top + height + options.top, options.top, options.top + options.containerHeight)) {
  			if (!rect) {
  				left = this.getLeft(col, width, gutter);
  			}
  			const node = this.cachedNode(i, i, item, total);
  			node.style.position = 'absolute';
  			node.style.top = top + 'px';
  			node.style.left = left + 'px';
  			node.style.width = width + 'px';
  			if (height !== node.offsetHeight) {
  				height = node.offsetHeight;
  			}
  			bottom = top + height + options.gutter;
  			highestHeight = Math.max(highestHeight, bottom);
  			options.cols[col] = bottom;
  			if (!rect) {
  				this.cachedRects[i] = { col, width, height, left, top, bottom };
  			} else {
  				rect.height = height;
  				rect.bottom = bottom;
  			}
  			return true;
  		} else {
  			this.removeNode(i);
  			bottom = top + height + options.gutter;
  			options.cols[col] = bottom;
  			highestHeight = Math.max(highestHeight, bottom);
  			return false;
  		}
  	});
  	let removeIndex = items.length;
  	while (removeIndex < this.cacheNodes.length) {
  		this.removeNode(removeIndex);
  		removeIndex++;
  	}
  	this.cacheNodes.length = items.length;
  	this.container.style.height = `${highestHeight}px`;
  	return visibleItems;
  }
  
  updateBackward__() {
  	const options = this.options;
  	const items = this.items$.getValue();
  	// console.log('VirtualStructure', 'items.length', items.length);
  	const total = items.length;
  	this.container.position = 'relative';
  	let lowestHeight = 0;
  	const width = this.getWidth();
  	const gutter = this.getGutter(width);
  	const visibleItems = [];
  	for (let i = items.length - 1; i >= 0; i--) {
  		const item = items[i];
  		let col, height, top, left, bottom;
  		let rect = this.cachedRects[i];
  		if (rect) {
  			col = rect.col;
  			height = rect.height;
  			left = rect.left;
  			// top = rect.top;
  			// bottom = rect.bottom;
  		} else {
  			col = this.getCol();
  			height = this.getHeight(width, item);
  		}
  		bottom = options.cols[col];
  		if (this.intersect(bottom - height + options.top, bottom + options.top, options.top, options.top + options.containerHeight)) {
  			if (!rect) {
  				left = this.getLeft(col, width, gutter);
  			}
  			const node = this.cachedNode(i, i, item, total);
  			node.style.position = 'absolute';
  			node.style.top = top + 'px';
  			node.style.left = left + 'px';
  			node.style.width = width + 'px';
  			if (height !== node.offsetHeight) {
  				height = node.offsetHeight;
  			}
  			top = bottom - height - options.gutter;
  			lowestHeight = Math.min(lowestHeight, -top);
  			options.cols[col] = top;
  			if (!rect) {
  				this.cachedRects[i] = { col, width, height, left, top, bottom: bottom };
  			} else {
  				rect.height = height;
  				rect.top = top;
  			}
  			visibleItems.push(item);
  		} else {
  			this.removeNode(i);
  			top = bottom - height - options.gutter;
  			options.cols[col] = top;
  			lowestHeight = Math.min(lowestHeight, top);
  		}
  	}
  	let removeIndex = items.length;
  	while (removeIndex < this.cacheNodes.length) {
  		this.removeNode(removeIndex);
  		removeIndex++;
  	}
  	this.cacheNodes.length = items.length;
  	this.container.style.height = `${-lowestHeight}px`;
  	return visibleItems;
  }
  */

  getCols() {
    const options = this.options;
    const cols = Math.floor((options.containerWidth + options.gutter) / (options.width + options.gutter)) || 1;
    return new Array(cols).fill(0);
  }
  getCol() {
    const options = this.options;
    let col;
    switch (this.mode) {
      case VirtualMode.Grid:
      case VirtualMode.Centered:
      case VirtualMode.Responsive:
        col = options.cols.reduce((p, c, i, a) => {
          return c < a[p] ? i : p;
        }, 0);
        break;
      case VirtualMode.List:
      default:
        col = 0;
    }
    return col;
  }
  getWidth() {
    const options = this.options;
    let width;
    switch (this.mode) {
      case VirtualMode.Grid:
      case VirtualMode.Centered:
        width = options.width;
        break;
      case VirtualMode.Responsive:
        width = (options.containerWidth - (options.cols.length - 1) * options.gutter) / options.cols.length;
        break;
      case VirtualMode.List:
      default:
        width = options.containerWidth;
    }
    return width;
  }
  getHeight(width, item) {
    const options = this.options;
    let height;
    switch (this.mode) {
      case VirtualMode.Grid:
      case VirtualMode.Centered:
      case VirtualMode.Responsive:
        height = options.width;
        break;
      case VirtualMode.List:
      default:
        height = 80;
    }
    return height;
  }
  getGutter(width) {
    const options = this.options;
    let gutter;
    switch (this.mode) {
      case VirtualMode.Grid:
      case VirtualMode.Centered:
        gutter = options.gutter;
        break;
      case VirtualMode.Responsive:
        gutter = (options.containerWidth - options.cols.length * width) / (options.cols.length - 1);
        break;
      case VirtualMode.List:
      default:
        gutter = 0;
    }
    return gutter;
  }
  getLeft(index, width, gutter) {
    const options = this.options;
    let left;
    switch (this.mode) {
      case VirtualMode.Grid:
      case VirtualMode.Responsive:
        left = index * (width + gutter);
        break;
      case VirtualMode.Centered:
        left = (options.containerWidth - options.cols.length * (width + gutter) + gutter) / 2 + index * (width + gutter);
        break;
      case VirtualMode.List:
      default:
        left = 0;
    }
    return left;
  }
  cachedNode(index, i, value, total) {
    if (this.cacheNodes[index]) {
      return this.updateNode(index, i, value);
    } else {
      return this.createNode(index, i, value, total);
    }
  }
  createNode(index, i, value, total) {
    const clonedNode = this.template.cloneNode(true);
    delete clonedNode.rxcompId;
    this.container.appendChild(clonedNode);
    this.cacheNodes[index] = clonedNode;
    const context = rxcomp.getContext(this);
    const module = context.module;
    const tokens = this.tokens;
    const args = [tokens.key, i, tokens.value, value, i, total, context.parentInstance];
    const instance = module.makeInstance(clonedNode, VirtualItem, context.selector, context.parentInstance, args);
    const forItemContext = rxcomp.getContext(instance);
    module.compile(clonedNode, forItemContext.instance);
    this.cachedInstances[index] = instance;
    return clonedNode;
  }
  updateNode(index, i, value) {
    const instance = this.cachedInstances[index];
    const tokens = this.tokens;
    if (instance[tokens.key] !== i) {
      instance[tokens.key] = i;
      instance[tokens.value] = value;
      instance.pushChanges();
    }
    // console.log(index, i, value);
    return this.cacheNodes[index];
  }
  removeNode(index) {
    this.cachedInstances[index] = undefined;
    const node = this.cacheNodes[index];
    if (node) {
      const context = rxcomp.getContext(this);
      const module = context.module;
      node.parentNode.removeChild(node);
      module.remove(node);
    }
    this.cacheNodes[index] = undefined;
    return node;
  }
  intersect(top1, bottom1, top2, bottom2) {
    // console.log(top2, '<', bottom1, bottom2, '>', top1);
    return top2 < bottom1 && bottom2 > top1;
  }
  resize$() {
    return rxjs.fromEvent(window, 'resize').pipe(operators.startWith(_ => null), operators.auditTime(100), operators.tap(() => this.updateView(true)));
  }
  scroll$() {
    const {
      node
    } = rxcomp.getContext(this);
    // console.log(node.parentNode, getComputedStyle(node.parentNode).overflowY, node.parentNode.style.overflowY);
    if (node.parentNode && getComputedStyle(node.parentNode).overflowY === 'auto') {
      return rxjs.fromEvent(node.parentNode, 'scroll').pipe(operators.tap(() => {
        this.updateView();
      }));
    } else {
      return rxjs.fromEvent(window, 'scroll').pipe(operators.tap(() => this.updateView()));
    }
  }
  updateView(reset) {
    const rect = this.container.getBoundingClientRect();
    const options = this.options;
    options.top = rect.top;
    options.containerWidth = rect.width;
    // options.containerHeight = rect.height;
    options.containerHeight = this.container.parentNode.offsetHeight;
    options.cols = this.getCols();
    if (reset) {
      this.cachedRects = {};
    }
  }
  getExpressionTokens(expression) {
    if (expression === null) {
      throw new Error('invalid virtual');
    }
    if (expression.trim().indexOf('let ') === -1 || expression.trim().indexOf(' of ') === -1) {
      throw new Error('invalid virtual');
    }
    const expressions = expression.split(';').map(x => x.trim()).filter(x => x !== '');
    const virtualExpressions = expressions[0].split(' of ').map(x => x.trim());
    let value = virtualExpressions[0].replace(/\s*let\s*/, '');
    const iterable = virtualExpressions[1];
    let key = 'index';
    const keyValueMatches = value.match(/\[(.+)\s*,\s*(.+)\]/);
    if (keyValueMatches) {
      key = keyValueMatches[1];
      value = keyValueMatches[2];
    }
    if (expressions.length > 1) {
      const indexExpressions = expressions[1].split(/\s*let\s*|\s*=\s*index/).map(x => x.trim());
      if (indexExpressions.length === 3) {
        key = indexExpressions[1];
      }
    }
    return {
      key,
      value,
      iterable
    };
  }
}
VirtualStructure.meta = {
  selector: '[*virtual]',
  inputs: ['mode', 'width', 'gutter', 'reverse']
};class MediaPlayerComponent extends rxcomp.Component {
  onInit() {
    // console.log('MediaPlayerComponent', this.media);
    this.playing = false;
    this.progress = 0;
    this.media$().pipe(operators.takeUntil(this.unsubscribe$)).subscribe();
    this.drag$().pipe(operators.takeUntil(this.unsubscribe$)).subscribe();
  }
  media$() {
    const {
      node
    } = rxcomp.getContext(this);
    const page = document.querySelector('.page');
    return MediaLoader.events$.pipe(
    // filter(event => event.loader.item.id === this.media.item.id),
    operators.tap(event => {
      if (event instanceof MediaLoaderPlayEvent) {
        this.media = event.loader;
        this.playing = true;
        node.classList.add('active');
        page.classList.add('media-player-active');
        this.pushChanges();
      } else if (this.media === event.loader) {
        if (event instanceof MediaLoaderPauseEvent) {
          this.playing = false;
          this.pushChanges();
        } else if (event instanceof MediaLoaderTimeUpdateEvent) {
          if (!this.dragging) {
            this.progress = this.media.progress;
            this.pushChanges();
          }
        } else if (event instanceof MediaLoaderDisposeEvent) {
          this.media = null;
          node.classList.remove('active');
          page.classList.remove('media-player-active');
          this.pushChanges();
        }
      }
      // console.log('MediaPlayerComponent.MediaLoader.events$', event);
    }));
  }

  drag$() {
    const {
      node
    } = rxcomp.getContext(this);
    const track = node.querySelector('.track');
    let initialProgress;
    return DragService.observe$(track).pipe(operators.filter(_ => this.media), operators.tap(event => {
      if (event instanceof DragDownEvent) {
        const rect = track.getBoundingClientRect();
        initialProgress = Math.max(0, Math.min(1, (event.down.x - rect.left) / rect.width));
        this.dragging = true;
      } else if (event instanceof DragMoveEvent) {
        const rect = track.getBoundingClientRect();
        const progress = Math.max(0, Math.min(1, initialProgress + event.distance.x / rect.width));
        this.progress = progress;
        this.pushChanges();
      } else if (event instanceof DragUpEvent) {
        this.media.progress = this.progress;
        this.dragging = false;
      }
    }));
  }
  onPlay() {
    this.media.play();
  }
  onPause() {
    this.media.pause();
  }
  onTrack(event) {
    const rect = event.currentTarget.getBoundingClientRect();
    const progress = (event.screenX - rect.left) / rect.width;
    this.media.progress = progress;
    // console.log(rect.left, event.screenX);
  }
}

MediaPlayerComponent.meta = {
  selector: '[media-player]'
};const PANEL_RADIUS$1 = PANORAMA_RADIUS - 0.01;
class ModelBannerComponent extends ModelComponent {
  get title() {
    return this.title_;
  }
  set title(title) {
    if (this.title_ !== title) {
      const init = this.title_ != null;
      this.title_ = title;
      if (!init) {
        this.createBanner();
      } else {
        this.updateBanner();
      }
    }
  }

  /*
  onInit() {
  	super.onInit();
  	// console.log('ModelBannerComponent.onInit', this.item);
  }
  
  onView() {
  	// console.log('ModelBannerComponent.onView', this.item);
  	if (this.viewed) {
  		return;
  	}
  	this.viewed = true;
  	// this.createBanner();
  }
  */

  onChanges() {
    // console.log('ModelBannerComponent.onChanges', this.item);
    this.title = this.item.title;
  }
  createBanner() {
    this.getCanvasTexture().then(result => {
      const texture = result.texture;
      const repeat = 24;
      texture.wrapS = texture.wrapY = THREE.RepeatWrapping;
      texture.repeat.x = repeat;
      texture.encoding = THREE.sRGBEncoding;
      const aspect = result.width * repeat / result.height;
      const arc = Math.PI / 180 * 360;
      const width = PANEL_RADIUS$1 * arc;
      const height = width / aspect;
      const geometry = new THREE.CylinderBufferGeometry(PANEL_RADIUS$1, PANEL_RADIUS$1, height, 80, 2, true, 0, arc);
      geometry.scale(-1, 1, 1);
      const material = new THREE.MeshBasicMaterial({
        map: texture,
        transparent: true,
        opacity: 0,
        toneMapped: false
        // side: THREE.DoubleSide,
      });

      const mesh = this.mesh;
      const banners = this.banners = new Array(1).fill(0).map(x => new THREE.Mesh(geometry, material));
      banners.forEach((banner, i) => {
        banner.rotation.y = Math.PI / 2 * i;
        // !!!
        // mesh.add(banner);
      });

      const from = {
        value: 0
      };
      gsap.to(from, {
        duration: 0.5,
        value: 1,
        delay: 0.0,
        ease: Power2.easeInOut,
        onUpdate: () => {
          material.opacity = from.value;
          material.needsUpdate = true;
        }
      });
      mesh.userData = {
        render: () => {
          mesh.rotation.y += Math.PI / 180 * 0.02;
          // texture.offset.x = (texture.offset.x - 0.01) % 1;
          material.needsUpdate = true;
        }
      };
    });
  }
  updateBanner() {
    this.getCanvasTexture().then(result => {
      // console.log('ModelBannerComponent.updateBanner', result);
    });
  }

  /*
  onViewBak() {
  	if (this.viewed) {
  		return;
  	}
  	this.viewed = true;
  	this.getCanvasTexture().then(result => {
  		const texture = result.texture;
  		const repeat = 3;
  		texture.wrapS = texture.wrapY = THREE.RepeatWrapping;
  		texture.repeat.x = repeat;
  		texture.encoding = THREE.sRGBEncoding;
  		const aspect = (result.width * repeat) / result.height;
  		const arc = Math.PI / 180 * 45;
  		const width = PANEL_RADIUS * arc;
  		const height = width / aspect;
  		const geometry = new THREE.CylinderBufferGeometry(PANEL_RADIUS, PANEL_RADIUS, height, 20, 2, true, 0, arc);
  		geometry.scale(-1, 1, 1);
  		const material = new THREE.MeshBasicMaterial({
  			map: texture,
  			transparent: true,
  			opacity: 0,
  			// side: THREE.DoubleSide,
  		});
  		const mesh = this.mesh;
  		const banners = this.banners = new Array(4).fill(0).map(x => new THREE.Mesh(geometry, material));
  		banners.forEach((banner, i) => {
  			banner.rotation.y = Math.PI / 2 * i;
  			mesh.add(banner);
  		});
  		const from = { value: 0 };
  		gsap.to(from, {
  			duration: 0.5,
  			value: 1,
  			delay: 0.0,
  			ease: Power2.easeInOut,
  			onUpdate: () => {
  				material.opacity = from.value;
  				material.needsUpdate = true;
  			}
  		});
  		mesh.userData = {
  			render: () => {
  				mesh.rotation.y += Math.PI / 180 * 0.2;
  				texture.offset.x = (texture.offset.x - 0.01) % 1;
  				material.needsUpdate = true;
  			}
  		};
  	});
  }
  */

  onCreate(mount, dismount) {
    const mesh = new THREE.Group();
    if (typeof mount === 'function') {
      mount(mesh);
    }
  }
  getCanvasTexture() {
    return new Promise((resolve, reject) => {
      const MIN_W = 512;
      let W = MIN_W;
      let H = 128;
      const F = Math.floor(H * 0.8);
      const L = Math.floor(H * 0.075);
      let canvas;
      if (this.canvas) {
        canvas = this.canvas;
      } else {
        canvas = this.canvas = document.createElement('canvas');
        // canvas.classList.add('canvas--debug');
        // document.querySelector('body').appendChild(canvas);
      }

      canvas.width = W;
      canvas.height = H;
      const text = this.item.title;
      const ctx = canvas.getContext('2d');
      // const ctx = text.material.map.image.getContext('2d');
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = 'high';
      ctx.font = `${F}px ${environment.fontFamily}`;
      const metrics = ctx.measureText(text);
      W = metrics.width + 8;
      W = Math.max(MIN_W, Math.pow(2, Math.ceil(Math.log(W) / Math.log(2))));
      // const x = W / 2;
      // const y = 16;
      canvas.width = W;
      ctx.clearRect(0, 0, W, H);
      ctx.fillStyle = '#0000005A'; // 35% // '#000000C0'; // 75%
      ctx.fillRect(0, 0, W, H);
      ctx.font = `${F}px ${environment.fontFamily}`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.strokeStyle = 'rgba(0, 0, 0, 0.5)';
      ctx.lineWidth = L;
      ctx.lineJoin = 'round'; // Experiment with 'bevel' & 'round' for the effect you want!
      ctx.miterLimit = 2;
      ctx.strokeText(text, W / 2, H / 2);
      ctx.fillStyle = 'white';
      ctx.fillText(text, W / 2, H / 2, W);
      // text.material.map.needsUpdate = true;
      let texture;
      if (this.texture) {
        texture = this.texture;
        texture.needsUpdate = true;
      } else {
        texture = this.texture = new THREE.CanvasTexture(canvas);
      }
      // console.log(F, L, W, H);
      resolve({
        texture: texture,
        width: W,
        height: H
      });
    });
  }

  /*
  getCanvasTexture_() {
  	return new Promise((resolve, reject) => {
  		if (this.item.bannerTexture) {
  			resolve(this.item.bannerTexture);
  		} else {
  			const { node } = getContext(this);
  			setTimeout(() => {
  				html2canvas(node, {
  					backgroundColor: '#00000000', // '#000000ff',
  					scale: 2,
  				}).then(canvas => {
  					// !!!
  					// document.body.appendChild(canvas);
  					// const alpha = this.getAlphaFromCanvas(canvas);
  					// document.body.appendChild(alpha);
  					const texture = new THREE.CanvasTexture(canvas);
  					// const alphaMap = new THREE.CanvasTexture(alpha);
  					this.item.bannerTexture = {
  						texture: texture,
  						width: canvas.width,
  						height: canvas.height,
  					};
  					resolve(this.item.bannerTexture);
  				}, error => {
  					reject(error);
  				});
  			}, 1);
  		}
  	});
  }
  */
}

ModelBannerComponent.meta = {
  selector: '[model-banner]',
  hosts: {
    host: WorldComponent
  },
  inputs: ['item']
};class ModelCurvedPlaneComponent extends ModelEditableComponent {
  onInit() {
    super.onInit();
    // console.log('ModelCurvedPlaneComponent.onInit');
  }

  onChanges() {
    const selected = this.item.selected;
    this.editing = selected;
    if (this.mesh) {
      this.mesh.editing = selected;
    }
  }
  onCreate(mount, dismount) {
    const item = this.item;
    const view = this.view;
    view.items;
    const geometry = this.getCurvedPanelGeometry(item);
    this.onMeshDown = this.onMeshDown.bind(this);
    this.onMeshPlaying = this.onMeshPlaying.bind(this);
    this.onMeshZoomed = this.onMeshZoomed.bind(this);
    this.onMeshCurrentTime = this.onMeshCurrentTime.bind(this);
    let mesh;
    let subscription;
    MediaMesh.getStreamId$(item).pipe(operators.takeUntil(this.unsubscribe$)).subscribe(streamId => {
      if (this.streamId !== streamId) {
        this.streamId = streamId;
        // !!! called by ModelComponent
        /*
        if (mesh) {
        	dismount(mesh, item);
        }
        */
        if (subscription) {
          subscription.unsubscribe();
          subscription = null;
        }
        // console.log('ModelCurvedPanel', streamId, item.asset)
        if (streamId || !item.asset) {
          item.streamId = streamId;
          mesh = this.disposableMesh = new MediaMesh(item, view, geometry, this.host);
          mesh.updateFromItem(item);
          mesh.name = 'curved-plane';
          mesh.load(() => {
            this.disposableMesh = null;
            if (typeof mount === 'function') {
              mount(mesh, item);
            }
            subscription = mesh.events$().pipe(operators.takeUntil(this.unsubscribe$)).subscribe(() => {});
          });
          this.addMeshListeners(mesh);
        } else if (this.mesh) {
          dismount(this.mesh, item);
        }
        // console.log('streamId', streamId, mesh);
      }
    });
  }

  addMeshListeners(mesh) {
    mesh.on('down', this.onMeshDown);
    mesh.on('playing', this.onMeshPlaying);
    mesh.on('zoomed', this.onMeshZoomed);
    mesh.on('currentTime', this.onMeshCurrentTime);
  }
  removeMeshListeners(mesh) {
    mesh.off('down', this.onMeshDown);
    mesh.off('playing', this.onMeshPlaying);
    mesh.off('zoomed', this.onMeshZoomed);
    mesh.off('currentTime', this.onMeshCurrentTime);
  }
  onMeshDown() {
    // console.log('ModelCurvedPanelComponent.onMeshDown');
    this.down.next(this);
  }
  onMeshPlaying(playing) {
    // console.log('ModelCurvedPanelComponent.playing', playing);
    this.play.next({
      itemId: this.item.id,
      playing
    });
  }
  onMeshZoomed(zoomed) {
    // console.log('ModelCurvedPanelComponent.zoomed', zoomed);
    this.zoom.next({
      itemId: this.item.id,
      zoomed
    });
  }
  onMeshCurrentTime(currentTime) {
    // console.log('ModelCurvedPanelComponent.playing', playing);
    this.currentTime.next({
      itemId: this.item.id,
      currentTime
    });
  }
  onDestroy() {
    // console.log('ModelCurvedPlaneComponent.onDestroy');
    super.onDestroy();
    if (this.disposableMesh) {
      this.removeMeshListeners(this.disposableMesh);
      this.disposableMesh.dispose();
    }
    if (this.mesh) {
      this.removeMeshListeners(this.mesh);
      this.mesh.dispose();
    }
  }

  // called by UpdateViewItemComponent
  onUpdate(item, mesh) {
    // console.log('ModelCurvedPlaneComponent.onUpdate', item);
    // !!! true
    if ((item.radius !== this.radius_ || item.height !== this.height_ || item.arc !== this.arc_)) {
      mesh.geometry.dispose();
      const geometry = this.getCurvedPanelGeometry(item);
      mesh.geometry = geometry;
    }
    mesh.updateFromItem(item);
    this.updateHelper();
  }

  // called by UpdateViewItemComponent
  onUpdateAsset(item, mesh) {
    // console.log('ModelCurvedPlaneComponent.onUpdateAsset', item);
    mesh.updateByItem(item);
    MediaMesh.getStreamId$(item).pipe(operators.filter(streamId => streamId !== null), operators.take(1)).subscribe(streamId => {
      item.streamId = streamId;
      mesh.load(() => {
        // console.log('ModelCurvedPlaneComponent.mesh.load.complete');
      });
    });
  }

  // called by WorldComponent
  onDragMove(position, normal, spherical) {
    // console.log('ModelCurvedPlaneComponent.onDragMove', position, normal, spherical);
    const item = this.item;
    const mesh = this.mesh;
    item.showPanel = false;
    this.editing = true;
    mesh.position.set(position.x, position.y, position.z);
    if (spherical) {
      position.normalize().multiplyScalar(20);
      mesh.lookAt(Host.origin);
    } else {
      mesh.position.set(0, 0, 0);
      mesh.lookAt(normal);
      mesh.position.set(position.x, position.y, position.z);
      mesh.position.add(normal.multiplyScalar(0.01));
    }
    this.updateHelper();
  }

  // called by WorldComponent
  onDragEnd() {
    const item = this.item;
    const mesh = this.mesh;
    item.position = mesh.position.toArray();
    item.rotation = mesh.rotation.toArray();
    item.scale = mesh.scale.toArray();
    mesh.updateFromItem(item);
    this.editing = false;
  }
  getCurvedPanelGeometry(item) {
    this.radius_ = item.radius;
    this.height_ = item.height;
    this.arc_ = item.arc;
    const arc = Math.PI / 180 * item.arc;
    const geometry = new THREE.CylinderBufferGeometry(item.radius, item.radius, item.height, 36, 2, true, 0, arc);
    geometry.rotateY(-Math.PI - arc / 2);
    geometry.scale(-1, 1, 1);
    return geometry;
  }
}
ModelCurvedPlaneComponent.textures = {};
ModelCurvedPlaneComponent.meta = {
  selector: '[model-curved-plane]',
  hosts: {
    host: WorldComponent
  },
  outputs: ['down', 'play', 'zoom', 'currentTime'],
  inputs: ['item', 'view']
};class DebugService {
  static getService() {
    if (!this.service_) {
      this.service_ = new DebugService();
    }
    return this.service_;
  }
  get message() {
    return this.message$.getValue();
  }
  constructor() {
    if (DebugService.service_) {
      throw 'DebugService is a singleton class!';
    }
    this.message$ = new rxjs.BehaviorSubject(null);
  }
  setMessage(message) {
    if (this.message !== message) {
      this.message$.next(message);
    }
  }
}class ModelDebugComponent extends ModelComponent {
  static getLoader() {
    return ModelDebugComponent.loader || (ModelDebugComponent.loader = new THREE.FontLoader());
  }
  static getFontLoader(callback) {
    return ModelDebugComponent.fontLoader || (ModelDebugComponent.fontLoader = ModelDebugComponent.getLoader().load(environment.getPath('fonts/helvetiker/helvetiker_regular.typeface.json'), callback));
  }
  get message() {
    return this.message_;
  }
  set message(message) {
    message = message && message !== '' ? message : null;
    if (this.message_ !== message) {
      this.message_ = message;
      // console.log('ModelDebugComponent.set.message', message);
      this.setText(message);
      /*
      if (this.font) {
      	this.setText(message);
      }
      */
    }
  }

  onInit() {
    super.onInit();
    // console.log('ModelDebugComponent.onInit');
    // this.loadFont();
    const vrService = this.vrService = VRService.getService();
    vrService.session$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(session => {
      if (session) {
        if (this.text) {
          this.textGroup.add(this.text);
        }
      } else {
        if (this.text) {
          this.text.parent.remove(this.text);
        }
      }
    });
    const debugService = this.debugService = DebugService.getService();
    debugService.message$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(message => this.message = message);
  }
  createText() {
    const canvas = document.createElement('canvas');
    // document.querySelector('body').appendChild(canvas);
    canvas.width = ModelDebugComponent.W;
    canvas.height = ModelDebugComponent.H;
    const texture = new THREE.CanvasTexture(canvas);
    texture.encoding = THREE.sRGBEncoding;
    texture.minFilter = THREE.LinearFilter;
    texture.magFilter = THREE.LinearFilter;
    texture.mapping = THREE.UVMapping;
    texture.needsUpdate = true;
    const geometry = new THREE.PlaneBufferGeometry(4, 1, 2, 2);
    const material = new THREE.MeshBasicMaterial({
      depthTest: false,
      depthWrite: false,
      map: texture,
      color: 0xffffff,
      // 0x33c5f6,
      transparent: true,
      opacity: 1,
      toneMapped: false
      // blending: THREE.AdditiveBlending,
      // side: THREE.DoubleSide
    });

    const text = new THREE.Mesh(geometry, material);
    text.renderOrder = environment.renderOrder.debug;
    text.position.y = 0;
    return text;
  }
  loadFont() {
    this.fontLoader = ModelDebugComponent.getFontLoader(font => {
      this.font = font;
      if (this.message_) {
        this.setText(this.message_);
      }
    });
  }
  onCreate(mount, dismount) {
    const textGroup = this.textGroup = new THREE.Group();
    this.material = new THREE.MeshBasicMaterial({
      depthTest: false,
      color: 0xffffff,
      // 0x33c5f6,
      transparent: true,
      opacity: 1,
      side: THREE.DoubleSide
    });
    this.text = this.createText();
    if (typeof mount === 'function') {
      mount(textGroup);
    }
  }

  // onView() { const context = getContext(this); }

  // onChanges() {}

  render(time, tick) {
    const group = this.group;
    let camera = this.host.camera;
    const position = this.position;
    if (this.host.renderer.xr.isPresenting) {
      camera = this.host.renderer.xr.getCamera(camera);
      // camera.updateMatrixWorld(); // make sure the camera matrix is updated
      // camera.matrixWorldInverse.getInverse(camera.matrixWorld);
    }

    camera.getWorldDirection(position);
    // console.log(position);
    // if (position.lengthSq() > 0.01) {
    // normalize so we can get a constant speed
    // position.normalize();
    position.multiplyScalar(3);
    // move body, not the camera
    // VR.body.position.add(lookDirection);
    // console.log(position.x + '|' + position.y + '|' + position.z);
    group.position.copy(position);
    group.lookAt(Host.origin);
    // }
  }

  setText(message) {
    const text = this.text;
    if (text) {
      if (this.host.renderer.xr.isPresenting && message != null) {
        // draw
        const ctx = text.material.map.image.getContext('2d');
        ctx.clearRect(0, 0, ModelDebugComponent.W, ModelDebugComponent.H);
        // ctx.fillRect(0, 0, 10, 10);
        // ctx.fillRect(ModelDebugComponent.W - 10, ModelDebugComponent.H - 10, 10, 10);
        ctx.font = `30px ${environment.fontFamily}`;
        ctx.textBaseline = 'middle';
        ctx.textAlign = 'center';
        ctx.fillStyle = '#FFFFFF';
        ctx.strokeStyle = '#000000';
        ctx.lineWidth = 5;
        ctx.fillText(message, ModelDebugComponent.W / 2, ModelDebugComponent.H / 2, ModelDebugComponent.W - 20);
        text.material.map.needsUpdate = true;
        // draw
        this.textGroup.add(text);
      } else if (text.parent) {
        text.parent.remove(text);
      }
    }
  }
}
ModelDebugComponent.W = 1024;
ModelDebugComponent.H = 256;
ModelDebugComponent.meta = {
  selector: '[model-debug]',
  hosts: {
    host: WorldComponent
  }
};const VERTEX_SHADER = `
varying vec2 vUv;
void main() {
	vUv = uv;
	gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}
`;
const FRAGMENT_SHADER = `
varying vec2 vUv;
uniform sampler2D textureA;
uniform sampler2D textureB;
uniform float opacity;
uniform float tween;

void main() {
	vec4 colorA = texture2D(textureA, vUv);
	vec4 colorB = texture2D(textureB, vUv);
	vec4 color = mix(colorA, colorB, tween);
	color.a = clamp(color.a * opacity, 0.0, 1.0);
	color.rgb /= color.a;
	gl_FragColor = color;
}
`;
class ModelGridComponent extends ModelComponent {
  static getLoader() {
    return ModelGridComponent.loader || (ModelGridComponent.loader = new THREE.TextureLoader());
  }
  static getTexture() {
    return ModelGridComponent.texture || (ModelGridComponent.texture = ModelGridComponent.getLoader().load(environment.getPath('textures/ui/floor-nav.png')));
  }
  static getOverTexture() {
    return ModelGridComponent.textureOver || (ModelGridComponent.textureOver = ModelGridComponent.getLoader().load(environment.getPath('textures/ui/floor-nav-over.png')));
  }
  set coords(coords) {
    if (!coords && this.coords_ !== coords || !this.coords_ || coords.x !== this.coords_.x || coords.y !== this.coords_.y) {
      // changed!
      const tileMap = this.tileMap;
      if (this.coords_) {
        const previousTile = tileMap[`${this.coords_.x}_${this.coords_.y}`];
        const previousUniforms = previousTile.uniforms;
        gsap.to(previousUniforms, {
          tween: 0,
          duration: 0.4,
          delay: 0,
          ease: Power2.easeInOut,
          onUpdate: () => {
            previousTile.material.uniforms.tween.value = previousUniforms.tween;
            previousTile.material.needsUpdate = true;
          }
        });
      }
      if (coords) {
        const currentTile = this.currentTile = tileMap[`${coords.x}_${coords.y}`];
        const currentUniforms = currentTile.uniforms;
        gsap.to(currentUniforms, {
          tween: 1,
          duration: 0.4,
          delay: 0,
          ease: Power2.easeInOut,
          onUpdate: () => {
            currentTile.material.uniforms.tween.value = currentUniforms.tween;
            currentTile.material.needsUpdate = true;
          }
        });
        // console.log(currentTile, `${coords.x}_${coords.y}`);
      }

      this.coords_ = coords;
    }
  }
  set coords__(coords) {
    if (!coords && this.coords_ !== coords || !this.coords_ || coords.x !== this.coords_.x || coords.y !== this.coords_.y) {
      // changed!
      const tileMap = this.tileMap;
      if (this.coords_) {
        const previousTile = tileMap[`${this.coords_.x}_${this.coords_.y}`];
        const from = {
          tween: 1
        };
        gsap.to(from, {
          duration: 0.4,
          tween: 0,
          delay: 0,
          ease: Power2.easeInOut,
          onUpdate: () => {
            previousTile.material.opacity = from.tween;
            // previousTile.material.needsUpdate = true;
          }
        });
      }

      if (coords) {
        const currentTile = this.currentTile = tileMap[`${coords.x}_${coords.y}`];
        const from = {
          tween: 0
        };
        gsap.to(from, {
          duration: 0.4,
          tween: 1,
          delay: 0,
          ease: Power2.easeInOut,
          onUpdate: () => {
            currentTile.material.opacity = from.tween;
            // currentTile.material.needsUpdate = true;
          }
        });
        // console.log(currentTile, `${coords.x}_${coords.y}`);
      }

      this.coords_ = coords;
    }
  }
  getCoords(point) {
    const outerTileSize = ModelGridComponent.RADIUS / 10; // assume room is 20m x 20m
    const col = Math.ceil((point.x + outerTileSize / 2) / outerTileSize) - 1;
    const row = Math.ceil((point.z + outerTileSize / 2) / outerTileSize) - 1;
    const dx = Math.floor(ModelGridComponent.COLS / 2);
    const dy = Math.floor(ModelGridComponent.ROWS / 2);
    const ci = Math.min(dx, Math.abs(col)) * (col ? Math.abs(col) / col : 1);
    const ri = Math.min(dy, Math.abs(row)) * (row ? Math.abs(row) / row : 1);
    if (this.view.hasTile(this.indices.x + ci, this.indices.y + ri)) {
      // console.log('col', col, 'row', row, 'ci', ci, 'ri', ri);
      return new THREE.Vector2(ci, ri);
    }
  }
  onInit() {
    super.onInit();
    this.indices = new THREE.Vector2();
    // console.log('ModelGridComponent.onInit', this.view);
    this.view.index$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(index => {
      this.moveToIndex(index);
    });
  }
  addTiles(mesh) {
    // console.log('addTiles');
    const outerTileSize = ModelGridComponent.RADIUS / 10; // assume room is 20m x 20m
    const innerTileSize = outerTileSize * 0.9;
    const geometry = new THREE.PlaneBufferGeometry(innerTileSize, innerTileSize, 2, 2);
    geometry.rotateX(-Math.PI / 2);
    const map = ModelGridComponent.getTexture();
    map.disposable = false;
    map.encoding = THREE.sRGBEncoding;
    const mapOver = ModelGridComponent.getOverTexture();
    mapOver.disposable = false;
    mapOver.encoding = THREE.sRGBEncoding;
    // geometry.scale(-1, 1, 1);
    const tileMap = this.tileMap = {};
    this.tiles = new Array(ModelGridComponent.COLS * ModelGridComponent.ROWS).fill(0).map((x, i) => {
      const material = new THREE.ShaderMaterial({
        depthTest: false,
        depthWrite: false,
        transparent: true,
        toneMapped: false,
        vertexShader: VERTEX_SHADER,
        fragmentShader: FRAGMENT_SHADER,
        uniforms: {
          textureA: {
            type: 't',
            value: map
          },
          textureB: {
            type: 't',
            value: mapOver
          },
          tween: {
            value: 0
          },
          opacity: {
            value: 0
          }
        },
        extensions: {
          fragDepth: true
        }
        // side: THREE.DoubleSide
      });
      /*
      const material = new THREE.MeshBasicMaterial({
      	depthTest: false,
      	depthWrite: false,
      	map: map,
      	transparent: true,
      	opacity: 0,
      	// side: THREE.DoubleSide,
      });
      */
      const tile = new THREE.Mesh(geometry, material);
      const dx = Math.floor(ModelGridComponent.COLS / 2);
      const dy = Math.floor(ModelGridComponent.ROWS / 2);
      const row = Math.floor(i / ModelGridComponent.COLS);
      const col = i % ModelGridComponent.COLS;
      const ci = -dx + col;
      const ri = -dy + row;
      // console.log(ci, ri);
      tile.position.set(ci * outerTileSize, -ModelGridComponent.RADIUS * 0.15, ri * outerTileSize);
      tile.name = this.getName(`tile_${ci}_${ri}`);
      tile.uniforms = {
        tween: 0,
        opacity: 0,
        ci: ci,
        ri: ri
      };
      tileMap[`${ci}_${ri}`] = tile;
      mesh.add(tile);
      return tile;
    });
    this.showTiles();
  }
  showTiles() {
    this.tiles.forEach((tile, i) => {
      const ix = this.indices ? this.indices.x : 0;
      const iy = this.indices ? this.indices.y : 0;
      const visible = this.view.hasTile(ix + tile.uniforms.ci, iy + tile.uniforms.ri);
      const uniforms = tile.uniforms;
      gsap.to(uniforms, {
        opacity: visible ? 1 : 0,
        duration: 0.4,
        // delay: 0 + i * 0.02,
        ease: Power2.easeInOut,
        onUpdate: () => {
          tile.material.uniforms.opacity.value = uniforms.opacity;
          tile.material.needsUpdate = true;
        }
      });
    });
  }
  addHitArea(mesh) {
    this.onGroundOver = this.onGroundOver.bind(this);
    this.onGroundMove = this.onGroundMove.bind(this);
    this.onGroundDown = this.onGroundDown.bind(this);
    this.onGroundOut = this.onGroundOut.bind(this);
    ModelGridComponent.RADIUS / 10; // assume room is 20m x 20m
    const geometry = new THREE.PlaneBufferGeometry(ModelGridComponent.RADIUS, ModelGridComponent.RADIUS, 8, 8); // 20, 20
    geometry.rotateX(-Math.PI / 2);
    // geometry.scale(-1, 1, 1);
    const material = new THREE.MeshBasicMaterial({
      depthTest: false,
      depthWrite: false,
      transparent: true,
      toneMapped: false,
      opacity: 0
      // side: THREE.DoubleSide,
    });

    const ground = this.ground = new InteractiveMesh(geometry, material);
    ground.name = this.getName('ground');
    ground.position.set(0, -ModelGridComponent.RADIUS * 0.15, 0);
    ground.on('over', this.onGroundOver);
    ground.on('move', this.onGroundMove);
    ground.on('out', this.onGroundOut);
    ground.on('down', this.onGroundDown);
    mesh.add(ground);
  }
  onGroundOver() {
    const ground = this.ground;
    const coords = this.getCoords(ground.intersection.point);
    this.coords = coords;
  }
  onGroundMove() {
    const ground = this.ground;
    const coords = this.getCoords(ground.intersection.point);
    this.coords = coords;
  }
  onGroundDown() {
    const ground = this.ground;
    const coords = this.getCoords(ground.intersection.point);
    this.coords = coords;
    if (coords) {
      const index = this.view.getTileIndex(this.indices.x + coords.x, this.indices.y + coords.y);
      this.view.index = index;
      this.nav.next(index);
      /*
      this.indices.x += coords.x;
      this.indices.y += coords.y;
      const outerTileSize = ModelGridComponent.RADIUS / 10; // assume room is 20m x 20m
      this.move.next({
      	indices: this.indices,
      	coords,
      	position: coords.clone().multiplyScalar(outerTileSize)
      });
      */
    }
  }

  onGroundOut() {
    this.coords = null;
  }
  moveToIndex(index) {
    // console.log('ModelGridComponent.moveToIndex', index);
    this.coords = null;
    const tile = this.view.tiles[index];
    const coords = new THREE.Vector2(tile.indices.x - this.indices.x, tile.indices.y - this.indices.y);
    this.indices.x = tile.indices.x;
    this.indices.y = tile.indices.y;
    this.showTiles();
    const outerTileSize = ModelGridComponent.RADIUS / 10; // assume room is 20m x 20m
    this.move.next({
      indices: this.indices,
      coords,
      position: coords.clone().multiplyScalar(outerTileSize)
    });
  }
  onCreate(mount, dismount) {
    // this.renderOrder = environment.renderOrder.tile;
    const mesh = new THREE.Group();
    this.addTiles(mesh);
    this.addHitArea(mesh);
    /*
    mesh.userData = {
    	render: () => {
    			}
    };
    */
    if (typeof mount === 'function') {
      mount(mesh);
    }
  }
  onDestroy() {
    super.onDestroy();
    const ground = this.ground;
    ground.off('over', this.onGroundOver);
    ground.off('move', this.onGroundMove);
    ground.off('down', this.onGroundDown);
    ground.off('out', this.onGroundOut);
  }
}
ModelGridComponent.RADIUS = 101;
ModelGridComponent.COLS = 11;
ModelGridComponent.ROWS = 11;
ModelGridComponent.meta = {
  selector: '[model-grid]',
  hosts: {
    host: WorldComponent
  },
  outputs: ['move', 'nav'],
  inputs: ['view']
};class MenuButton extends InteractiveMesh {
  static getGrid(total) {
    const cols = Math.ceil(total / MenuButton.ROWS);
    const rows = Math.ceil(total / cols);
    return [rows, cols];
  }
  static getX(index, total) {
    const cols = Math.ceil(total / MenuButton.ROWS);
    const c = index % cols;
    const w = 1 / MenuButton.W * (MenuButton.W + MenuButton.G);
    return w / 2 - cols * w / 2 + c * w;
  }
  static getY(index, total) {
    const cols = Math.ceil(total / MenuButton.ROWS);
    const rows = Math.ceil(total / cols);
    const r = Math.floor(index / cols);
    const h = 1 / MenuButton.W * (MenuButton.H + MenuButton.G);
    return rows * h / 2 - h / 2 + r * -h; // y flipped
  }

  static get geometry() {
    if (this.geometry_) {
      return this.geometry_;
    }
    const geometry = new THREE.PlaneBufferGeometry(1, 1 / MenuButton.W * MenuButton.H, 2, 2);
    this.geometry_ = geometry;
    return geometry;
  }
  static get material() {
    const material = new THREE.ShaderMaterial({
      depthTest: false,
      transparent: true,
      toneMapped: false,
      vertexShader: ModelMenuComponent.VERTEX_SHADER,
      fragmentShader: ModelMenuComponent.FRAGMENT_SHADER,
      uniforms: {
        textureA: {
          type: 't',
          value: null
        },
        textureB: {
          type: 't',
          value: null
        },
        resolutionA: {
          value: new THREE.Vector2()
        },
        resolutionB: {
          value: new THREE.Vector2()
        },
        tween: {
          value: 0
        },
        opacity: {
          value: 0
        }
      },
      extensions: {
        fragDepth: true
      }
    });
    /*
    const material = new THREE.MeshBasicMaterial({
    	// depthTest: false,
    	transparent: true,
    	opacity: 0.8,
    	// side: THREE.DoubleSide,
    });
    */
    return material;
  }
  constructor(item, index, total) {
    const geometry = MenuButton.geometry;
    const material = MenuButton.material;
    super(geometry, material);
    // this.userData.item = item;
    // this.userData.index = index;
    this.renderOrder = environment.renderOrder.menu;
    this.name = item.name;
    this.item = item;
    this.index = index;
    this.total = total;
    this.tween = 0;
    this.opacity = 0;
    const textureA = this.textureA = this.getTextureA(item.name);
    // material.map = textureA;
    material.uniforms.textureA.value = textureA;
    material.uniforms.resolutionA.value = new THREE.Vector2(textureA.width, textureA.height);
    const textureB = this.textureB = this.getTextureB(item.name);
    // material.map = textureB;
    material.uniforms.textureB.value = textureB;
    material.uniforms.resolutionA.value = new THREE.Vector2(textureB.width, textureB.height);
    material.uniforms.tween.value = this.tween;
    material.uniforms.opacity.value = this.opacity;
    material.needsUpdate = true;
    this.position.set(MenuButton.getX(index, total), MenuButton.getY(index, total), 0);
    this.onOver = this.onOver.bind(this);
    this.onOut = this.onOut.bind(this);
  }
  getTextureA(text) {
    const w = MenuButton.W;
    const h = MenuButton.H;
    const canvas = document.createElement('canvas');
    canvas.width = w;
    canvas.height = h;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = environment.colors.menuBackground;
    ctx.fillRect(0, 0, w, h);
    ctx.fillStyle = environment.colors.menuForeground;
    this.writeText(ctx, text, w, h);
    const texture = new THREE.CanvasTexture(canvas);
    texture.minFilter = THREE.LinearFilter;
    texture.magFilter = THREE.LinearFilter;
    texture.mapping = THREE.UVMapping;
    // texture.encoding = THREE.sRGBEncoding;
    texture.needsUpdate = true;
    return texture;
  }
  getTextureB(text) {
    const w = MenuButton.W;
    const h = MenuButton.H;
    const canvas = document.createElement('canvas');
    canvas.width = w;
    canvas.height = h;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = environment.colors.menuOverBackground;
    ctx.fillRect(0, 0, w, h);
    ctx.fillStyle = environment.colors.menuOverForeground;
    this.writeText(ctx, text, w, h);
    const texture = new THREE.CanvasTexture(canvas);
    // texture.encoding = THREE.sRGBEncoding;
    texture.magFilter = THREE.LinearFilter;
    texture.needsUpdate = true;
    return texture;
  }
  writeText(ctx, text, w, h) {
    this.setFont(ctx);
    const lineHeight = MenuButton.FONT_SIZE * MenuButton.LINE_HEIGHT;
    const lines = this.getLines(ctx, text, w);
    const lineCount = lines.length;
    this.setFont(ctx, lineCount - 1);
    lines.forEach((line, i) => {
      ctx.fillText(line, 10, (h - lineCount * lineHeight) * 0.5 + (0.5 + i) * lineHeight, w - 20);
    });
  }
  setFont(ctx, diff) {
    if (diff === void 0) {
      diff = 0;
    }
    ctx.textBaseline = 'middle';
    ctx.font = `${MenuButton.FONT_SIZE - diff * 2}px ${environment.fontFamily}`;
  }
  getLines(ctx, text, maxWidth) {
    const words = text.split(' ');
    const lines = [];
    let currentLine = words[0];
    for (let i = 1; i < words.length; i++) {
      const word = words[i];
      const width = ctx.measureText(currentLine + ' ' + word).width;
      if (width < maxWidth) {
        currentLine += ' ' + word;
      } else {
        lines.push(currentLine);
        currentLine = word;
      }
    }
    lines.push(currentLine);
    return lines;
  }
  onOver() {
    // DebugService.getService().setMessage('over ' + this.name);
    gsap.to(this, {
      duration: 0.4,
      tween: 1,
      ease: Power2.easeOut,
      onUpdate: () => {
        this.position.z = 0.1 * this.tween;
        this.material.uniforms.tween.value = this.tween;
        this.material.needsUpdate = true;
      }
    });
  }
  onOut() {
    gsap.to(this, {
      duration: 0.4,
      tween: 0,
      ease: Power2.easeOut,
      onUpdate: () => {
        this.position.z = 0.1 * this.tween;
        this.material.uniforms.tween.value = this.tween;
        this.material.needsUpdate = true;
      }
    });
  }
  dispose() {
    Interactive.dispose(this);
    this.textureA.dispose();
    this.textureB.dispose();
    this.material.dispose();
    this.geometry.dispose();
  }
}
MenuButton.FONT_SIZE = 19; // 20
MenuButton.LINE_HEIGHT = 0.9;
MenuButton.W = 256;
MenuButton.H = 64;
MenuButton.G = 2;
MenuButton.ROWS = 6;
class BackButton extends MenuButton {
  constructor(item, index, total) {
    super(item, index, total);
  }
  getTextureA(text) {
    const w = MenuButton.W;
    const h = MenuButton.H;
    const canvas = document.createElement('canvas');
    canvas.width = w;
    canvas.height = h;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = environment.colors.menuBackBackground;
    ctx.fillRect(0, 0, w, h);
    ctx.fillStyle = environment.colors.menuBackForeground;
    ctx.font = `${MenuButton.FONT_SIZE}px ${environment.fontFamily}`;
    ctx.fillText(text, 10, 50, w - 20);
    const texture = new THREE.CanvasTexture(canvas);
    texture.minFilter = THREE.LinearFilter;
    texture.magFilter = THREE.LinearFilter;
    texture.mapping = THREE.UVMapping;
    texture.needsUpdate = true;
    return texture;
  }
  getTextureB(text) {
    const w = MenuButton.W;
    const h = MenuButton.H;
    const canvas = document.createElement('canvas');
    canvas.width = w;
    canvas.height = h;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = environment.colors.menuBackOverBackground;
    ctx.fillRect(0, 0, w, h);
    ctx.fillStyle = environment.colors.menuBackOverForeground;
    ctx.font = `${MenuButton.FONT_SIZE}px ${environment.fontFamily}`;
    ctx.fillText(text, 10, 50, w - 20);
    const texture = new THREE.CanvasTexture(canvas);
    // texture.encoding = THREE.sRGBEncoding;
    texture.magFilter = THREE.LinearFilter;
    texture.needsUpdate = true;
    return texture;
  }
}
class ModelMenuComponent extends ModelComponent {
  get controlled() {
    return StateService.state.controlling && StateService.state.controlling !== StateService.state.uid;
  }
  get controlling() {
    return StateService.state.controlling && StateService.state.controlling === StateService.state.uid;
  }
  get silencing() {
    return StateService.state.silencing;
  }
  get silenced() {
    return StateService.state.silencing && StateService.state.role === RoleType.Streamer;
  }
  get spyed() {
    return StateService.state.spying && StateService.state.spying === StateService.state.uid;
  }
  get spying() {
    return StateService.state.spying && StateService.state.spying !== StateService.state.uid;
  }
  get locked() {
    return this.controlled || this.spying;
  }
  get loading() {
    return this.loading_;
  }
  set loading(loading) {
    // console.log('loading', loading);
    if (this.loading_ !== loading) {
      this.loading_ = loading;
      const {
        node
      } = rxcomp.getContext(this);
      const btn = node.querySelector('.btn--menu');
      btn.classList.toggle('loading', loading);
    }
  }
  onInit() {
    super.onInit();
    this.onDown = this.onDown.bind(this);
    this.onToggle = this.onToggle.bind(this);
    // console.log('ModelMenuComponent.onInit');
    /*
    const vrService = this.vrService = VRService.getService();
    vrService.session$.pipe(
    	takeUntil(this.unsubscribe$),
    ).subscribe((session) => {
    	if (session) {
    		this.addToggler();
    	} else {
    		this.removeMenu();
    	}
    });
    */
    const {
      node
    } = rxcomp.getContext(this);
    this.progressIndicator = node.querySelector('.progress circle');
    LoaderService.progress$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(progress => {
      this.loading = progress.count > 0;
      let strokeDashoffset = 144.51;
      if (progress.count) {
        strokeDashoffset = 144.51 * (1 - progress.value);
      }
      gsap.set(this.progressIndicator, {
        'strokeDashoffset': strokeDashoffset
      });
    });
    MessageService.in$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(message => {
      // DebugService.getService().setMessage('ModelMenuComponent.MessageService ' + message.type);
      switch (message.type) {
        case MessageType.MenuToggle:
          this.onToggle();
          break;
      }
    });
  }

  /*
  buildMenu() {
  	if (!this.views) {
  		return;
  	}
  	MenuService.getModelMenu$(this.views, this.host.editor).pipe(
  		first(),
  	).subscribe(menu => this.groups = menu);
  }
  */

  onDestroy() {
    if (this.buttons) {
      this.buttons.forEach(x => Interactive.dispose(x));
    }
    super.onDestroy();
  }
  getContainer() {
    return this.host.cameraGroup;
  }
  onCreate(mount, dismount) {
    // this.renderOrder = environment.renderOrder.menu;
    const menuGroup = this.menuGroup = new THREE.Group();
    if (typeof mount === 'function') {
      mount(menuGroup);
    }
  }
  render(time, tick) {
    const group = this.group;
    this.host.cameraGroup;
    let camera = this.host.camera;
    const position = this.position;
    if (this.host.renderer.xr.isPresenting) {
      camera = this.host.renderer.xr.getCamera(camera);
      camera.getWorldDirection(position);
      position.y += 0.5;
      position.multiplyScalar(3);
      this.host.cameraGroup.worldToLocal(position);
      position.y += this.host.cameraGroup.position.y;
      group.position.copy(position);
      group.scale.set(1, 1, 1);
      group.lookAt(Host.origin);
    } else {
      camera.getWorldDirection(position);
      if (OrbitService.mode === OrbitMode.Model) {
        position.multiplyScalar(0.01);
      } else {
        position.multiplyScalar(3);
      }
      group.position.copy(position);
      const s = 1 / camera.zoom;
      group.scale.set(s, s, s);
      group.lookAt(Host.origin);
    }
  }
  items$(item) {
    if (item === void 0) {
      item = null;
    }
    if (item) {
      return rxjs.of(item.items);
    } else if (this.rootItems) {
      return rxjs.of(this.rootItems);
    } else {
      return MenuService.getModelMenu$(this.views, this.host.editor).pipe(operators.first(), operators.tap(items => {
        if (!this.host.editor) {
          this.rootItems = items;
        }
      }));
    }
  }
  addMenu(item) {
    if (item === void 0) {
      item = null;
    }
    this.removeMenu();
    // nav to view
    if (item && item.type.name !== 'menu-group') {
      /*
      if (this.host.renderer.xr.isPresenting) {
      	this.addToggler();
      }
      */
      this.nav.next(item);
      return;
    }
    MenuService.active = true;
    this.items$(item).pipe(operators.first()).subscribe(items => {
      if (items) {
        items = items.slice();
        const back = {
          type: {
            name: 'back'
          },
          name: item ? 'Back' : 'Close',
          backItem: item
        };
        items.push(back);
        const buttons = this.buttons = items.map((x, i, a) => {
          x.backItem = item;
          return x.type.name === 'back' ? new BackButton(x, i, a.length) : new MenuButton(x, i, a.length);
        });
        buttons.forEach(button => {
          button.depthTest = false;
          button.on('over', button.onOver);
          button.on('out', button.onOut);
          button.on('down', this.onDown);
          this.menuGroup.add(button);
          /*
          var box = new THREE.BoxHelper(button, 0xffff00);
          this.host.scene.add(box);
          */
        });

        gsap.to(buttons, {
          duration: 0.3,
          opacity: 0.8,
          ease: Power2.easeOut,
          stagger: {
            grid: MenuButton.getGrid(buttons.length),
            from: 0,
            // index
            amount: 0.02 * buttons.length
          },
          onUpdate: () => {
            buttons.forEach(button => {
              button.material.uniforms.opacity.value = button.opacity * (button.item.hidden ? 0.5 : 1);
              // button.material.needsUpdate = true;
            });
          }
        });
      }
    });
  }

  removeMenu() {
    MenuService.active = false;
    this.removeButtons();
    this.removeToggler();
  }
  removeButtons() {
    const buttons = this.buttons;
    if (buttons) {
      buttons.forEach(button => {
        this.menuGroup.remove(button);
        button.off('over', button.onOver);
        button.off('out', button.onOut);
        button.off('down', this.onDown);
        button.dispose();
      });
    }
    this.buttons = null;
  }
  addToggler() {
    this.removeMenu();
    const toggler = this.toggler = new MenuButton({
      type: {
        name: 'menu'
      },
      name: 'Menu'
    }, 0, 1);
    // toggler.position.y = -0.5;
    toggler.opacity = 0.8;
    toggler.material.uniforms.opacity.value = toggler.opacity;
    toggler.material.needsUpdate = true;
    toggler.on('over', toggler.onOver);
    toggler.on('out', toggler.onOut);
    toggler.on('down', this.onToggle);
    this.menuGroup.add(toggler);
  }
  removeToggler() {
    const toggler = this.toggler;
    if (toggler) {
      this.menuGroup.remove(toggler);
      toggler.off('over', toggler.onOver);
      toggler.off('out', toggler.onOut);
      toggler.off('down', this.onToggle);
      toggler.dispose();
    }
    this.toggler = null;
  }
  onDown(button) {
    // this.down.next(this.item);
    if (button.item && button.item.type.name === 'back') {
      this.removeMenu();
      if (button.item.backItem) {
        this.addMenu(button.item.backItem.backItem);
      } else {
        /*
        if (this.host.renderer.xr.isPresenting) {
        	this.addToggler();
        }
        */
        this.toggle.next();
      }
    } else {
      this.addMenu(button.item);
    }
  }
  onToggle(event) {
    if (event) {
      event.preventDefault();
      event.stopImmediatePropagation();
    }
    if (this.locked) {
      return;
    }
    if (MenuService.active) {
      this.removeMenu();
      this.toggle.next();
    } else {
      this.addMenu();
      this.toggle.next(this);
    }
  }
}
ModelMenuComponent.VERTEX_SHADER = `
varying vec2 vUv;
void main() {
	vUv = uv;
	gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}
`;
ModelMenuComponent.FRAGMENT_SHADER = `
varying vec2 vUv;
uniform float opacity;
uniform float tween;
uniform sampler2D textureA;
uniform sampler2D textureB;
uniform vec2 resolutionA;
uniform vec2 resolutionB;

void main() {
	vec4 colorA = texture2D(textureA, vUv);
	vec4 colorB = texture2D(textureB, vUv);
	vec4 color = vec4(mix(colorA.rgb, colorB.rgb, tween), opacity);
	gl_FragColor = color;
}
`;
ModelMenuComponent.meta = {
  selector: '[model-menu]',
  hosts: {
    host: WorldComponent
  },
  // outputs: ['over', 'out', 'down', 'nav'],
  outputs: ['nav', 'toggle'],
  inputs: ['views'],
  template: /* html */`
	<div class="btn--menu" (mousedown)="onToggle($event)">
		<svg class="menu-light" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#menu-light"></use></svg>
		<div class="btn--menu__spinner"></div>
		<svg class="bullets" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#menu"></use></svg>
		<svg class="progress" width="50" height="50" viewBox="0 0 50 50">
			<circle id="circle" r="23" cx="25" cy="25" fill="transparent"></circle>
		</svg>
	</div>
	`
};const _taskCache = new WeakMap();

class DRACOLoader extends three.Loader {

	constructor( manager ) {

		super( manager );

		this.decoderPath = '';
		this.decoderConfig = {};
		this.decoderBinary = null;
		this.decoderPending = null;

		this.workerLimit = 4;
		this.workerPool = [];
		this.workerNextTaskID = 1;
		this.workerSourceURL = '';

		this.defaultAttributeIDs = {
			position: 'POSITION',
			normal: 'NORMAL',
			color: 'COLOR',
			uv: 'TEX_COORD'
		};
		this.defaultAttributeTypes = {
			position: 'Float32Array',
			normal: 'Float32Array',
			color: 'Float32Array',
			uv: 'Float32Array'
		};

	}

	setDecoderPath( path ) {

		this.decoderPath = path;

		return this;

	}

	setDecoderConfig( config ) {

		this.decoderConfig = config;

		return this;

	}

	setWorkerLimit( workerLimit ) {

		this.workerLimit = workerLimit;

		return this;

	}

	load( url, onLoad, onProgress, onError ) {

		const loader = new three.FileLoader( this.manager );

		loader.setPath( this.path );
		loader.setResponseType( 'arraybuffer' );
		loader.setRequestHeader( this.requestHeader );
		loader.setWithCredentials( this.withCredentials );

		loader.load( url, ( buffer ) => {

			const taskConfig = {
				attributeIDs: this.defaultAttributeIDs,
				attributeTypes: this.defaultAttributeTypes,
				useUniqueIDs: false
			};

			this.decodeGeometry( buffer, taskConfig )
				.then( onLoad )
				.catch( onError );

		}, onProgress, onError );

	}

	/** @deprecated Kept for backward-compatibility with previous DRACOLoader versions. */
	decodeDracoFile( buffer, callback, attributeIDs, attributeTypes ) {

		const taskConfig = {
			attributeIDs: attributeIDs || this.defaultAttributeIDs,
			attributeTypes: attributeTypes || this.defaultAttributeTypes,
			useUniqueIDs: !! attributeIDs
		};

		this.decodeGeometry( buffer, taskConfig ).then( callback );

	}

	decodeGeometry( buffer, taskConfig ) {

		// TODO: For backward-compatibility, support 'attributeTypes' objects containing
		// references (rather than names) to typed array constructors. These must be
		// serialized before sending them to the worker.
		for ( const attribute in taskConfig.attributeTypes ) {

			const type = taskConfig.attributeTypes[ attribute ];

			if ( type.BYTES_PER_ELEMENT !== undefined ) {

				taskConfig.attributeTypes[ attribute ] = type.name;

			}

		}

		//

		const taskKey = JSON.stringify( taskConfig );

		// Check for an existing task using this buffer. A transferred buffer cannot be transferred
		// again from this thread.
		if ( _taskCache.has( buffer ) ) {

			const cachedTask = _taskCache.get( buffer );

			if ( cachedTask.key === taskKey ) {

				return cachedTask.promise;

			} else if ( buffer.byteLength === 0 ) {

				// Technically, it would be possible to wait for the previous task to complete,
				// transfer the buffer back, and decode again with the second configuration. That
				// is complex, and I don't know of any reason to decode a Draco buffer twice in
				// different ways, so this is left unimplemented.
				throw new Error(

					'THREE.DRACOLoader: Unable to re-decode a buffer with different ' +
					'settings. Buffer has already been transferred.'

				);

			}

		}

		//

		let worker;
		const taskID = this.workerNextTaskID ++;
		const taskCost = buffer.byteLength;

		// Obtain a worker and assign a task, and construct a geometry instance
		// when the task completes.
		const geometryPending = this._getWorker( taskID, taskCost )
			.then( ( _worker ) => {

				worker = _worker;

				return new Promise( ( resolve, reject ) => {

					worker._callbacks[ taskID ] = { resolve, reject };

					worker.postMessage( { type: 'decode', id: taskID, taskConfig, buffer }, [ buffer ] );

					// this.debug();

				} );

			} )
			.then( ( message ) => this._createGeometry( message.geometry ) );

		// Remove task from the task list.
		// Note: replaced '.finally()' with '.catch().then()' block - iOS 11 support (#19416)
		geometryPending
			.catch( () => true )
			.then( () => {

				if ( worker && taskID ) {

					this._releaseTask( worker, taskID );

					// this.debug();

				}

			} );

		// Cache the task result.
		_taskCache.set( buffer, {

			key: taskKey,
			promise: geometryPending

		} );

		return geometryPending;

	}

	_createGeometry( geometryData ) {

		const geometry = new three.BufferGeometry();

		if ( geometryData.index ) {

			geometry.setIndex( new three.BufferAttribute( geometryData.index.array, 1 ) );

		}

		for ( let i = 0; i < geometryData.attributes.length; i ++ ) {

			const attribute = geometryData.attributes[ i ];
			const name = attribute.name;
			const array = attribute.array;
			const itemSize = attribute.itemSize;

			geometry.setAttribute( name, new three.BufferAttribute( array, itemSize ) );

		}

		return geometry;

	}

	_loadLibrary( url, responseType ) {

		const loader = new three.FileLoader( this.manager );
		loader.setPath( this.decoderPath );
		loader.setResponseType( responseType );
		loader.setWithCredentials( this.withCredentials );

		return new Promise( ( resolve, reject ) => {

			loader.load( url, resolve, undefined, reject );

		} );

	}

	preload() {

		this._initDecoder();

		return this;

	}

	_initDecoder() {

		if ( this.decoderPending ) return this.decoderPending;

		const useJS = typeof WebAssembly !== 'object' || this.decoderConfig.type === 'js';
		const librariesPending = [];

		if ( useJS ) {

			librariesPending.push( this._loadLibrary( 'draco_decoder.js', 'text' ) );

		} else {

			librariesPending.push( this._loadLibrary( 'draco_wasm_wrapper.js', 'text' ) );
			librariesPending.push( this._loadLibrary( 'draco_decoder.wasm', 'arraybuffer' ) );

		}

		this.decoderPending = Promise.all( librariesPending )
			.then( ( libraries ) => {

				const jsContent = libraries[ 0 ];

				if ( ! useJS ) {

					this.decoderConfig.wasmBinary = libraries[ 1 ];

				}

				const fn = DRACOWorker.toString();

				const body = [
					'/* draco decoder */',
					jsContent,
					'',
					'/* worker */',
					fn.substring( fn.indexOf( '{' ) + 1, fn.lastIndexOf( '}' ) )
				].join( '\n' );

				this.workerSourceURL = URL.createObjectURL( new Blob( [ body ] ) );

			} );

		return this.decoderPending;

	}

	_getWorker( taskID, taskCost ) {

		return this._initDecoder().then( () => {

			if ( this.workerPool.length < this.workerLimit ) {

				const worker = new Worker( this.workerSourceURL );

				worker._callbacks = {};
				worker._taskCosts = {};
				worker._taskLoad = 0;

				worker.postMessage( { type: 'init', decoderConfig: this.decoderConfig } );

				worker.onmessage = function ( e ) {

					const message = e.data;

					switch ( message.type ) {

						case 'decode':
							worker._callbacks[ message.id ].resolve( message );
							break;

						case 'error':
							worker._callbacks[ message.id ].reject( message );
							break;

						default:
							console.error( 'THREE.DRACOLoader: Unexpected message, "' + message.type + '"' );

					}

				};

				this.workerPool.push( worker );

			} else {

				this.workerPool.sort( function ( a, b ) {

					return a._taskLoad > b._taskLoad ? - 1 : 1;

				} );

			}

			const worker = this.workerPool[ this.workerPool.length - 1 ];
			worker._taskCosts[ taskID ] = taskCost;
			worker._taskLoad += taskCost;
			return worker;

		} );

	}

	_releaseTask( worker, taskID ) {

		worker._taskLoad -= worker._taskCosts[ taskID ];
		delete worker._callbacks[ taskID ];
		delete worker._taskCosts[ taskID ];

	}

	debug() {

		console.log( 'Task load: ', this.workerPool.map( ( worker ) => worker._taskLoad ) );

	}

	dispose() {

		for ( let i = 0; i < this.workerPool.length; ++ i ) {

			this.workerPool[ i ].terminate();

		}

		this.workerPool.length = 0;

		return this;

	}

}

/* WEB WORKER */

function DRACOWorker() {

	let decoderConfig;
	let decoderPending;

	onmessage = function ( e ) {

		const message = e.data;

		switch ( message.type ) {

			case 'init':
				decoderConfig = message.decoderConfig;
				decoderPending = new Promise( function ( resolve/*, reject*/ ) {

					decoderConfig.onModuleLoaded = function ( draco ) {

						// Module is Promise-like. Wrap before resolving to avoid loop.
						resolve( { draco: draco } );

					};

					DracoDecoderModule( decoderConfig ); // eslint-disable-line no-undef

				} );
				break;

			case 'decode':
				const buffer = message.buffer;
				const taskConfig = message.taskConfig;
				decoderPending.then( ( module ) => {

					const draco = module.draco;
					const decoder = new draco.Decoder();
					const decoderBuffer = new draco.DecoderBuffer();
					decoderBuffer.Init( new Int8Array( buffer ), buffer.byteLength );

					try {

						const geometry = decodeGeometry( draco, decoder, decoderBuffer, taskConfig );

						const buffers = geometry.attributes.map( ( attr ) => attr.array.buffer );

						if ( geometry.index ) buffers.push( geometry.index.array.buffer );

						self.postMessage( { type: 'decode', id: message.id, geometry }, buffers );

					} catch ( error ) {

						console.error( error );

						self.postMessage( { type: 'error', id: message.id, error: error.message } );

					} finally {

						draco.destroy( decoderBuffer );
						draco.destroy( decoder );

					}

				} );
				break;

		}

	};

	function decodeGeometry( draco, decoder, decoderBuffer, taskConfig ) {

		const attributeIDs = taskConfig.attributeIDs;
		const attributeTypes = taskConfig.attributeTypes;

		let dracoGeometry;
		let decodingStatus;

		const geometryType = decoder.GetEncodedGeometryType( decoderBuffer );

		if ( geometryType === draco.TRIANGULAR_MESH ) {

			dracoGeometry = new draco.Mesh();
			decodingStatus = decoder.DecodeBufferToMesh( decoderBuffer, dracoGeometry );

		} else if ( geometryType === draco.POINT_CLOUD ) {

			dracoGeometry = new draco.PointCloud();
			decodingStatus = decoder.DecodeBufferToPointCloud( decoderBuffer, dracoGeometry );

		} else {

			throw new Error( 'THREE.DRACOLoader: Unexpected geometry type.' );

		}

		if ( ! decodingStatus.ok() || dracoGeometry.ptr === 0 ) {

			throw new Error( 'THREE.DRACOLoader: Decoding failed: ' + decodingStatus.error_msg() );

		}

		const geometry = { index: null, attributes: [] };

		// Gather all vertex attributes.
		for ( const attributeName in attributeIDs ) {

			const attributeType = self[ attributeTypes[ attributeName ] ];

			let attribute;
			let attributeID;

			// A Draco file may be created with default vertex attributes, whose attribute IDs
			// are mapped 1:1 from their semantic name (POSITION, NORMAL, ...). Alternatively,
			// a Draco file may contain a custom set of attributes, identified by known unique
			// IDs. glTF files always do the latter, and `.drc` files typically do the former.
			if ( taskConfig.useUniqueIDs ) {

				attributeID = attributeIDs[ attributeName ];
				attribute = decoder.GetAttributeByUniqueId( dracoGeometry, attributeID );

			} else {

				attributeID = decoder.GetAttributeId( dracoGeometry, draco[ attributeIDs[ attributeName ] ] );

				if ( attributeID === - 1 ) continue;

				attribute = decoder.GetAttribute( dracoGeometry, attributeID );

			}

			geometry.attributes.push( decodeAttribute( draco, decoder, dracoGeometry, attributeName, attributeType, attribute ) );

		}

		// Add index.
		if ( geometryType === draco.TRIANGULAR_MESH ) {

			geometry.index = decodeIndex( draco, decoder, dracoGeometry );

		}

		draco.destroy( dracoGeometry );

		return geometry;

	}

	function decodeIndex( draco, decoder, dracoGeometry ) {

		const numFaces = dracoGeometry.num_faces();
		const numIndices = numFaces * 3;
		const byteLength = numIndices * 4;

		const ptr = draco._malloc( byteLength );
		decoder.GetTrianglesUInt32Array( dracoGeometry, byteLength, ptr );
		const index = new Uint32Array( draco.HEAPF32.buffer, ptr, numIndices ).slice();
		draco._free( ptr );

		return { array: index, itemSize: 1 };

	}

	function decodeAttribute( draco, decoder, dracoGeometry, attributeName, attributeType, attribute ) {

		const numComponents = attribute.num_components();
		const numPoints = dracoGeometry.num_points();
		const numValues = numPoints * numComponents;
		const byteLength = numValues * attributeType.BYTES_PER_ELEMENT;
		const dataType = getDracoDataType( draco, attributeType );

		const ptr = draco._malloc( byteLength );
		decoder.GetAttributeDataArrayForAllPoints( dracoGeometry, attribute, dataType, byteLength, ptr );
		const array = new attributeType( draco.HEAPF32.buffer, ptr, numValues ).slice();
		draco._free( ptr );

		return {
			name: attributeName,
			array: array,
			itemSize: numComponents
		};

	}

	function getDracoDataType( draco, attributeType ) {

		switch ( attributeType ) {

			case Float32Array: return draco.DT_FLOAT32;
			case Int8Array: return draco.DT_INT8;
			case Int16Array: return draco.DT_INT16;
			case Int32Array: return draco.DT_INT32;
			case Uint8Array: return draco.DT_UINT8;
			case Uint16Array: return draco.DT_UINT16;
			case Uint32Array: return draco.DT_UINT32;

		}

	}

}class ModelModelComponent extends ModelEditableComponent {
  get freezed() {
    return this.freezed_;
  }
  set freezed(freezed) {
    if (this.freezed_ !== freezed) {
      this.freezed_ = freezed;
      const mesh = this.mesh;
      if (mesh) {
        mesh.traverse(child => {
          if (child.isInteractiveMesh) {
            child.freezed = freezed;
          }
        });
      }
    }
  }
  onInit() {
    super.onInit();
    this.isPresenting = false;
    MenuService.active$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(active => this.freezed = active);
  }
  onChanges() {
    this.editing = this.item.selected;
  }
  onCreate(mount, dismount) {
    this.loadGlb(environment.getPath(this.item.asset.folder), this.item.asset.file, (mesh, animations) => {
      this.onGlbLoaded(mesh, animations, mount, dismount);
    });
  }
  loadGlb(path, file, callback) {
    this.host.renderer;
    // const roughnessMipmapper = new RoughnessMipmapper(renderer); // optional
    const progressRef = LoaderService.getRef();
    // console.log('progressRef');
    const loader = new GLTFLoader().setPath(path);
    // Optional: Provide a DRACOLoader instance to decode compressed mesh data
    const decoderPath = `${environment.dist}js/draco/`;
    // console.log(decoderPath);
    const dracoLoader = new DRACOLoader();
    dracoLoader.setDecoderPath(decoderPath);
    loader.setDRACOLoader(dracoLoader);
    loader.load(file, glb => {
      /*
      glb.scene.traverse((child) => {
      	if (child.isMesh) {
      		// roughnessMipmapper.generateMipmaps(child.material);
      	}
      });
      */
      if (typeof callback === 'function') {
        callback(glb.scene, glb.animations);
      }
      LoaderService.setProgress(progressRef, 1);
      // roughnessMipmapper.dispose();
    }, progressEvent => {
      LoaderService.setProgress(progressRef, progressEvent.loaded, progressEvent.total);
    });
  }
  onGlbLoaded(mesh, animations, mount, dismount) {
    // animations
    this.parseAnimations(mesh, animations);
    // scale
    const box = new THREE.Box3().setFromObject(mesh);
    const size = box.max.clone().sub(box.min);
    const max = Math.max(size.x, size.y, size.z);
    const scale = 1.7 / max;
    mesh.scale.set(scale, scale, scale);
    // repos
    let dummy;
    const view = this.view;
    const item = this.item;
    if (view.type.name === ViewType.Model.name) {
      // this.onUpdateVRSession(this.vrService.currentSession);
      dummy = new THREE.Group();
      dummy.add(mesh);
      box.setFromObject(dummy);
      const center = box.getCenter(new THREE.Vector3());
      dummy.position.set(mesh.position.x - center.x, mesh.position.y - center.y, mesh.position.z - center.z + (this.host.renderer.xr.isPresenting ? -2 : 0)
      // mesh.position.z - center.z,
      );

      const endY = dummy.position.y;
      const from = {
        tween: 1
      };
      const onUpdate = () => {
        dummy.position.y = endY + 3 * from.tween;
        dummy.rotation.y = 0 + Math.PI * from.tween;
      };
      onUpdate();
      this.makeInteractive(mesh);
      gsap.to(from, {
        duration: 1.5,
        tween: 0,
        delay: 0.1,
        ease: Power2.easeInOut,
        onUpdate: onUpdate,
        onComplete: () => {
          this.updateHelper();
        }
      });
    } else {
      box.setFromObject(mesh);
      const center = box.getCenter(new THREE.Vector3());
      mesh.position.set(-center.x, -center.y, -center.z);
      dummy = new THREE.Group();
      dummy.add(mesh);
      if (item.position) {
        dummy.position.fromArray(item.position);
      }
      if (item.rotation) {
        dummy.rotation.fromArray(item.rotation);
      }
      if (item.scale) {
        dummy.scale.fromArray(item.scale);
      }
      this.makeInteractive(mesh);
      /*
      const geometry = ModelModelComponent.getInteractiveGeometry();
      const sphere = new InteractiveMesh(geometry, new THREE.MeshBasicMaterial({
      	depthTest: false,
      	depthWrite: false,
      	transparent: true,
      	// wireframe: true,
      	// opacity: 1.0,
      	opacity: 0.0,
      	color: 0x00ffff,
      }));
      const radius = max * scale / 1.7;
      sphere.scale.set(radius, radius, radius);
      sphere.name = `[model] ${this.item.id}`;
      // sphere.depthTest = false;
      sphere.renderOrder = 0;
      dummy.add(sphere);
      sphere.on('down', () => {
      	// console.log('ModelModelComponent.down');
      	this.down.next(this);
      });
      */
      this.updateHelper();
    }
    if (typeof mount === 'function') {
      mount(dummy, this.item);
      this.freezed = MenuService.active;
    }
  }
  parseAnimations(mesh, animations) {
    // animations
    // console.log('ModelModelComponent.onGlbLoaded', 'animations', animations);
    this.actionIndex = -1;
    const actions = this.actions = [];
    if (animations && animations.length) {
      this.clock = new THREE.Clock();
      const mixer = this.mixer = new THREE.AnimationMixer(mesh);
      mixer.timeScale = 1;
      animations.forEach(animation => {
        const action = mixer.clipAction(animation);
        action.enabled = true;
        action.setEffectiveTimeScale(1);
        action.setEffectiveWeight(1);
        // action.setLoop(THREE.LoopPingPong);
        action.setLoop(THREE.LoopRepeat);
        // action.clampWhenFinished = true; // pause on last frame
        actions.push(action);
      });
    }
  }
  onClipToggle() {
    let actionIndex;
    const actions = this.actions;
    if (actions.length === 1) {
      actionIndex = this.actionIndex === -1 ? 0 : -1;
      this.setSingleAction(actionIndex);
    } else if (actions.length > 1) {
      actionIndex = this.actionIndex + 1;
      if (actionIndex === actions.length) {
        actionIndex = -1;
      }
      this.setMultiAction(actionIndex);
    }
    this.play.next({
      itemId: this.item.id,
      actionIndex
    });
  }
  setSingleAction(actionIndex) {
    if (this.actionIndex !== actionIndex) {
      this.actionIndex = actionIndex;
      const action = this.actions[0];
      if (actionIndex === 0) {
        if (action.paused || action.timeScale === 0) {
          action.paused = false;
        } else {
          action.play();
        }
      } else if (actionIndex === -1) {
        action.halt(0.3);
      }
    }
  }
  setMultiAction(actionIndex) {
    if (this.actionIndex !== actionIndex) {
      const actions = this.actions;
      const previousClip = this.actionIndex > -1 ? actions[this.actionIndex] : null;
      this.actionIndex = actionIndex;
      if (previousClip) {
        previousClip.halt(0.3);
      }
      // console.log('setMultiAction', actionIndex, actions.length);
      if (actionIndex > -1) {
        const action = actions[actionIndex];
        if (action.paused) {
          action.paused = false;
        }
        if (action.timeScale === 0) {
          action.timeScale = 1;
        }
        action.play();
      }
    }
  }
  onMessage(message) {
    switch (message.type) {
      case MessageType.PlayModel:
        {
          const actions = this.actions;
          if (actions.length === 1) {
            this.setSingleAction(message.actionIndex);
          } else if (actions.length > 1) {
            this.setMultiAction(message.actionIndex);
          }
          break;
        }
    }
  }
  render(time, tick) {
    const view = this.view;
    this.item;
    const mesh = this.mesh;
    const isPresenting = this.host.renderer.xr.isPresenting;
    this.group;
    if (mesh) {
      if (view.type.name === ViewType.Model.name) {
        if (this.isPresenting !== isPresenting) {
          this.isPresenting = isPresenting;
          if (isPresenting) {
            mesh.position.x = 0;
            mesh.position.y = 0;
            mesh.position.z = -2;
            mesh.rotation.y = 0;
          } else {
            mesh.position.x = 0;
            mesh.position.y = 0;
            mesh.position.z = 0;
            mesh.rotation.y = 0;
          }
        }
        if (isPresenting) {
          mesh.rotation.y -= Math.PI / 180 / 60 * 5;
        }
      } else {
        if (isPresenting) {
          mesh.rotation.y -= Math.PI / 180 / 60 * 5;
        }
      }
    }
    const mixer = this.mixer;
    const clock = this.clock;
    if (mixer) {
      const delta = clock.getDelta();
      mixer.update(delta);
    }
  }

  // called by UpdateViewItemComponent
  onUpdate(item, mesh) {
    // console.log('ModelModelComponent.onUpdate', item);
    const view = this.view;
    if (view.type.name !== ViewType.Model.name) {
      if (item.position) {
        mesh.position.fromArray(item.position);
      }
      if (item.rotation) {
        mesh.rotation.fromArray(item.rotation);
      }
      if (item.scale) {
        mesh.scale.fromArray(item.scale);
      }
    }
    this.updateHelper();
  }

  // called by UpdateViewItemComponent
  onUpdateAsset(item, mesh) {
    // console.log('ModelModelComponent.onUpdateAsset', item);
    this.loadGlb(environment.getPath(item.asset.folder), item.asset.file, (mesh, animations) => {
      this.onGlbLoaded(mesh, animations, (mesh, item) => this.onMount(mesh, item), (mesh, item) => this.onDismount(mesh, item));
    });
    /*
    this.mesh.updateByItem(item);
    this.mesh.load(() => {
    	// console.log('ModelModelComponent.mesh.load.complete');
    });
    */
  }

  // called by WorldComponent
  onDragMove(position, normal, spherical) {
    // console.log('ModelModelComponent.onDragMove', position, normal, spherical);
    if (spherical) {
      position.normalize().multiplyScalar(4);
    }
    this.editing = true;
    const view = this.view;
    if (view.type.name !== ViewType.Model.name) {
      this.mesh.position.set(position.x, position.y, position.z);
      // this.mesh.lookAt(Host.origin);
    }

    this.updateHelper();
  }

  // called by WorldComponent
  onDragEnd() {
    // console.log('ModelModelComponent.onDragEnd');
    const view = this.view;
    if (view.type.name !== ViewType.Model.name) {
      this.item.position = this.mesh.position.toArray();
      this.item.rotation = this.mesh.rotation.toArray();
      this.item.scale = this.mesh.scale.toArray();
    }
    this.editing = false;
  }
  static getInteractiveDescriptors() {
    let descriptors = ModelModelComponent.interactiveDescriptors;
    if (!descriptors) {
      const freezableDescriptors = Object.getOwnPropertyDescriptors(FreezableMesh.prototype);
      const emittableDescriptors = Object.getOwnPropertyDescriptors(EmittableMesh.prototype);
      const interactiveDescriptors = Object.getOwnPropertyDescriptors(InteractiveMesh.prototype);
      descriptors = Object.assign({}, freezableDescriptors, emittableDescriptors, interactiveDescriptors);
      ModelModelComponent.interactiveDescriptors = descriptors;
    }
    return descriptors;
  }
  makeInteractive(mesh) {
    const interactiveDescriptors = ModelModelComponent.getInteractiveDescriptors();
    mesh.traverse(child => {
      if (child.isMesh) {
        Object.keys(interactiveDescriptors).forEach(key => {
          if (key !== 'constructor') {
            Object.defineProperty(child, key, interactiveDescriptors[key]);
          }
        });
        child.freezed = false;
        child.events = {};
        child.depthTest = true;
        child.over_ = false;
        child.down_ = false;
        Interactive.items.push(child);
        child.on('down', () => {
          // console.log('ModelModelComponent.down', child);
          this.onClipToggle();
          this.down.next(this);
        });
      }
    });
  }
}
ModelModelComponent.meta = {
  selector: '[model-model]',
  hosts: {
    host: WorldComponent
  },
  outputs: ['down', 'play'],
  inputs: ['item', 'view']
};class FreezableSprite extends THREE.Sprite {
  get freezed() {
    return this.freezed_;
  }
  set freezed(freezed) {
    // !!! cycle through freezable and not freezable
    this.freezed_ = freezed;
    this.children.filter(x => x.__lookupGetter__('freezed')).forEach(x => x.freezed = freezed);
  }
  constructor(material) {
    material = material || new THREE.SpriteMaterial({
      color: 0xff00ff
      // opacity: 1,
      // transparent: true,
    });

    super(material);
    this.freezed = false;
  }
  freeze() {
    this.freezed = true;
  }
  unfreeze() {
    this.freezed = false;
  }
}class EmittableSprite extends FreezableSprite {
  constructor(material) {
    material = material || new THREE.SpriteMaterial({
      color: 0xff00ff
      // opacity: 1,
      // transparent: true,
    });

    super(material);
    this.events = {};
  }
  on(type, callback) {
    const event = this.events[type] = this.events[type] || [];
    event.push(callback);
    return () => {
      this.events[type] = event.filter(x => x !== callback);
    };
  }
  off(type, callback) {
    const event = this.events[type];
    if (event) {
      this.events[type] = event.filter(x => x !== callback);
    }
  }
  emit(type, data) {
    const event = this.events[type];
    if (event) {
      event.forEach(callback => {
        // callback.call(this, data);
        callback(data);
      });
    }
    const broadcast = this.events.broadcast;
    if (broadcast) {
      broadcast.forEach(callback => {
        callback(type, data);
      });
    }
  }
}class InteractiveSprite extends EmittableSprite {
  constructor(material) {
    super(material);
    this.depthTest = true;
    this.over_ = false;
    this.down_ = false;
    Interactive.items.push(this);
  }
  get isInteractiveSprite() {
    return true;
  }
  get over() {
    return this.over_;
  }
  set over(over) {
    if (this.over_ != over) {
      this.over_ = over;
      /*
      if (over) {
      	this.emit('hit', this);
      }
      */
      if (over) {
        this.emit('over', this);
      } else {
        this.emit('out', this);
      }
    }
  }
  get down() {
    return this.down_;
  }
  set down(down) {
    down = down && this.over;
    if (this.down_ != down) {
      this.down_ = down;
      if (down) {
        this.emit('down', this);
      } else {
        this.emit('up', this);
      }
    }
  }
}// import domtoimage from 'dom-to-image';

// const USE_DOM_TO_IMAGE = true;

class ModelPanelComponent extends ModelComponent {
  constructor() {
    super(...arguments);
    this.isMobile_ = void 0;
  }
  get isMobile() {
    return this.isMobile_;
  }
  set isMobile(isMobile) {
    if (this.isMobile_ !== isMobile) {
      this.isMobile_ = isMobile;
      this.setScale();
    }
  }
  render(time, tick) {
    // console.log('render', this.host.worldRect.width);
    this.isMobile = this.host.worldRect.width < 768;
  }
  setScale(pow) {
    if (pow === void 0) {
      pow = 0;
    }
    const textureWidth = this.textureWidth;
    const textureHeight = this.textureHeight;
    const item = this.item;
    const panel = this.panel;
    if (panel) {
      const scale = 0.2 * (item.asset ? 1.5 : 1.0) * (this.isMobile ? 1.6 : 1);
      const aspect = textureWidth / textureHeight;
      const width = ModelPanelComponent.PANEL_RADIUS * scale;
      const height = ModelPanelComponent.PANEL_RADIUS * scale / aspect;
      const dy = width * 0.25;
      const position = item.mesh.position.normalize().multiplyScalar(ModelPanelComponent.PANEL_RADIUS);
      panel.position.set(position.x, position.y + (height + dy * 2) - dy * (1 - pow), position.z);
      panel.scale.set(0.02 * width, 0.02 * height, 1);
    }
  }
  onInit() {
    super.onInit();
    this.textureWidth = 0;
    this.textureHeight = 0;
    // console.log('ModelPanelComponent.onInit', this.item);
  }

  onView() {
    if (this.viewed) {
      return;
    }
    this.viewed = true;
    const {
      node
    } = rxcomp.getContext(this);
    this.getCanvasTexture(node).then(texture => {
      this.textureWidth = texture.width;
      this.textureHeight = texture.height;
      if (this.mesh && this.item) {
        const material = new THREE.SpriteMaterial({
          depthTest: false,
          transparent: true,
          opacity: 0,
          map: texture.map,
          sizeAttenuation: false,
          toneMapped: false
        });
        const item = this.item;
        const panel = this.panel = new InteractiveSprite(material);
        panel.renderOrder = environment.renderOrder.panel;
        this.setScale(1);
        panel.on('down', event => {
          // console.log(event.intersection.uv.x, event.intersection.uv.y, node.offsetWidth, node.offsetHeight);
          const xy = {
            x: parseInt(event.intersection.uv.x * node.offsetWidth),
            y: parseInt((1 - event.intersection.uv.y) * node.offsetHeight)
          };
          // console.log('ModelPanelComponent.down.xy', xy);
          const linkNodes = Array.prototype.slice.call(node.querySelectorAll('.panel__link'));
          // console.log('linkNodes', linkNodes);
          const linkNode = linkNodes.find(link => {
            const inside = xy.x >= link.offsetLeft && xy.y >= link.offsetTop && xy.x <= link.offsetLeft + link.offsetWidth && xy.y <= link.offsetTop + link.offsetHeight;
            /*
            console.log(
            	(link.offsetLeft + link.offsetWidth), '>=', xy.x, '>=', link.offsetLeft,
            	(link.offsetTop + link.offsetHeight), '>=', xy.y, '>=', link.offsetTop,
            	inside,
            );
            */
            return inside;
          });
          // console.log('linkNode', linkNode);
          if (linkNode) {
            const linkIndex = linkNodes.indexOf(linkNode);
            const link = item.links[linkIndex];
            // console.log('ModelPanelComponent.down.link', link, linkNode, linkNodes);
            this.down.next({
              item,
              link,
              linkIndex
            });
            const rect = node.getBoundingClientRect();
            const mouseEvent = {
              button: 0,
              buttons: 0,
              clientX: xy.x + rect.left,
              clientY: xy.y + rect.top,
              movementX: 0,
              movementY: 0,
              relatedTarget: linkNode,
              screenX: xy.x,
              screenY: xy.y
            };
            const event = new MouseEvent('mouseup', mouseEvent);
            linkNode.dispatchEvent(event);
            // console.log('ModelPanelComponent.dispatchEvent', mouseEvent);
            setTimeout(() => {
              DragService.dismissEvent(event, DragService.events$, DragService.dismiss$, DragService.downEvent);
            }, 1);
          }
        });
        this.mesh.add(panel);
        const from = {
          value: 0
        };
        gsap.to(from, {
          duration: 0.5,
          value: 1,
          delay: 0.0,
          ease: Power2.easeInOut,
          onUpdate: () => {
            this.setScale(1 - from.value);
            panel.lookAt(Host.origin);
            panel.material.opacity = from.value;
            panel.material.needsUpdate = true;
          }
        });
      }
    }, error => {
      console.log('ModelPanelComponent.getCanvasTexture.error', error);
    });
  }
  onCreate(mount, dismount) {
    const mesh = new THREE.Group();
    if (typeof mount === 'function') {
      mount(mesh);
    }
  }
  onDestroy() {
    // console.log('ModelPanelComponent.onDestroy');
    super.onDestroy();
  }
  imagesLoaded() {
    const {
      node
    } = rxcomp.getContext(this);
    if (node) {
      const images = Array.prototype.slice.call(node.querySelectorAll('img'));
      const promises = images.map(x => new Promise(function (resolve, reject) {
        const cors = x.src && x.src.indexOf(location.origin) === -1;
        if (x.complete) {
          return setTimeout(() => {
            resolve(cors);
          }, 10);
        }
        function onLoad() {
          removeListeners();
          setTimeout(() => {
            resolve(cors);
          }, 10);
        }
        function onError() {
          removeListeners();
          resolve(false);
        }
        function removeListeners() {
          x.removeEventListener('load', onLoad);
          x.removeEventListener('error', onError);
        }
        function addListeners() {
          x.addEventListener('load', onLoad);
          x.addEventListener('error', onError);
        }
        addListeners();
      }));
      if (promises.length) {
        return Promise.all(promises);
      } else {
        return Promise.resolve();
      }
    }
  }
  getCanvasTexture(node) {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (this.item.panelTexture) {
          resolve(this.item.panelTexture);
        } else {
          this.imagesLoaded().then(results => {
            const context = rxcomp.getContext(this);
            if (context && context.node) {
              node = context.node;
              const useCORS = results && results.find(x => x === true) != null; // !!! keep loose equality
              // console.log('ModelPanelComponent.getCanvasTexture.useCORS', useCORS);
              /*
              if (USE_DOM_TO_IMAGE) {
              	domtoimage.toBlob(node, { cacheBust: true }).then(function(blob) {
              		createImageBitmap(blob).then(function(imageBitmap) {
              			const map = new THREE.Texture();
              			map.image = imageBitmap;
              			map.needsUpdate = true;
              			this.item.panelTexture = {
              				map: map,
              				width: imageBitmap.width,
              				height: imageBitmap.height,
              			};
              			resolve(this.item.panelTexture);
              				}, error => {
              			reject(error);
              		});
              	}, error => {
              		reject(error);
              	});
              } else {
              */
              /*
              htmlToImage.toCanvas(node).then((canvas) => {
              	// !!!
              	// document.body.appendChild(canvas);
              	// const alpha = this.getAlphaFromCanvas(canvas);
              	// document.body.appendChild(alpha);
              	const map = new THREE.CanvasTexture(canvas);
              	// const alphaMap = new THREE.CanvasTexture(alpha);
              	// console.log(canvas.width, canvas.height);
              	this.item.panelTexture = {
              		map: map,
              		width: canvas.width,
              		height: canvas.height,
              	};
              	resolve(this.item.panelTexture);
              }).catch(error => {
              	console.log('htmlToImage', error);
              	reject(error);
              });
              */
              html2canvas__default["default"](node, {
                backgroundColor: '#ffffff00',
                scale: 1,
                useCORS
                // logging: true,
              }).then(canvas => {
                // !!!
                // document.body.appendChild(canvas);
                // const alpha = this.getAlphaFromCanvas(canvas);
                // document.body.appendChild(alpha);
                const map = new THREE.CanvasTexture(canvas);
                // const alphaMap = new THREE.CanvasTexture(alpha);
                // console.log(canvas.width, canvas.height);
                this.item.panelTexture = {
                  map: map,
                  width: canvas.width,
                  height: canvas.height
                };
                resolve(this.item.panelTexture);
              }, error => {
                reject(error);
              });
              // }
            }
          });
        }
      }, 1); // keep it for childnode images to be compiled
    });
  }
}

ModelPanelComponent.PANEL_RADIUS = 99;
ModelPanelComponent.meta = {
  selector: '[model-panel]',
  hosts: {
    host: WorldComponent
  },
  outputs: ['over', 'out', 'down'],
  inputs: ['item'],
  template: /* html */`
		<div class="panel__title"><span [innerHTML]="item.title"></span></div>
		<div class="panel__abstract"><span [innerHTML]="item.abstract"></span></div>
		<img class="panel__picture" [src]="item.asset | asset" *if="item.asset">
		<a class="panel__link" [href]="link.href" target="_blank" rel="noopener" *for="let link of item.links">
			<span [innerHTML]="link.title"></span>
		</a>
	`
};class ModelPictureComponent extends ModelComponent {
  onInit() {
    super.onInit();
    // console.log('ModelPictureComponent.onInit');
  }

  onCreate(mount, dismount) {
    const mesh = new THREE.Group();
    if (typeof mount === 'function') {
      mount(mesh);
    }
  }

  // onView() { const context = getContext(this); }

  // onChanges() {}
}

ModelPictureComponent.meta = {
  selector: '[model-picture]',
  hosts: {
    host: WorldComponent
  },
  inputs: ['item']
};class ModelPlaneComponent extends ModelEditableComponent {
  onInit() {
    super.onInit();
    // console.log('ModelPlaneComponent.onInit');
  }

  onChanges() {
    const selected = this.item.selected;
    this.editing = selected;
    if (this.mesh) {
      this.mesh.editing = selected;
    }
  }
  onCreate(mount, dismount) {
    const item = this.item;
    const view = this.view;
    view.items;
    const geometry = Geometry.planeGeometry;
    this.onMeshDown = this.onMeshDown.bind(this);
    this.onMeshPlaying = this.onMeshPlaying.bind(this);
    this.onMeshZoomed = this.onMeshZoomed.bind(this);
    this.onMeshCurrentTime = this.onMeshCurrentTime.bind(this);
    let mesh;
    let subscription;
    MediaMesh.getStreamId$(item).pipe(operators.takeUntil(this.unsubscribe$)).subscribe(streamId => {
      // console.log('ModelPlaneComponent.onCreate.streamId', streamId);
      if (this.streamId !== streamId) {
        this.streamId = streamId;
        // !!! called by ModelComponent
        /*
        if (mesh) {
        	dismount(mesh, item);
        }
        */
        if (subscription) {
          subscription.unsubscribe();
          subscription = null;
        }
        if (streamId || !item.asset) {
          item.streamId = streamId;
          mesh = this.disposableMesh = new MediaMesh(item, view, geometry, this.host);
          mesh.updateFromItem(item);
          mesh.name = 'plane';
          mesh.load(() => {
            this.disposableMesh = null;
            if (typeof mount === 'function') {
              mount(mesh, item);
            }
            subscription = mesh.events$().pipe(operators.takeUntil(this.unsubscribe$)).subscribe(() => {});
          });
          this.addMeshListeners(mesh);
        } else if (this.mesh) {
          dismount(this.mesh, item);
        }
        // console.log('streamId', streamId, mesh);
      }
    });
  }

  addMeshListeners(mesh) {
    mesh.on('down', this.onMeshDown);
    mesh.on('playing', this.onMeshPlaying);
    mesh.on('zoomed', this.onMeshZoomed);
    mesh.on('currentTime', this.onMeshCurrentTime);
  }
  removeMeshListeners(mesh) {
    mesh.off('down', this.onMeshDown);
    mesh.off('playing', this.onMeshPlaying);
    mesh.off('zoomed', this.onMeshZoomed);
    mesh.off('currentTime', this.onMeshCurrentTime);
  }
  onMeshDown() {
    // console.log('ModelPanelComponent.onMeshDown');
    this.down.next(this);
  }
  onMeshPlaying(playing) {
    // console.log('ModelPanelComponent.playing', playing);
    this.play.next({
      itemId: this.item.id,
      playing
    });
  }
  onMeshZoomed(zoomed) {
    // console.log('ModelPanelComponent.zoomed', zoomed);
    this.zoom.next({
      itemId: this.item.id,
      zoomed
    });
  }
  onMeshCurrentTime(currentTime) {
    // console.log('ModelPanelComponent.playing', playing);
    this.currentTime.next({
      itemId: this.item.id,
      currentTime
    });
  }
  onDestroy() {
    // console.log('ModelPlaneComponent.onDestroy');
    super.onDestroy();
    if (this.disposableMesh) {
      this.removeMeshListeners(this.disposableMesh);
      this.disposableMesh.dispose();
    }
    if (this.mesh) {
      this.removeMeshListeners(this.mesh);
      this.mesh.dispose();
    }
  }

  // called by UpdateViewItemComponent
  onUpdate(item, mesh) {
    // console.log('ModelPlaneComponent.onUpdate', item);
    mesh.updateFromItem(item);
    this.updateHelper();
  }

  // called by UpdateViewItemComponent
  onUpdateAsset(item, mesh) {
    // console.log('ModelPlaneComponent.onUpdateAsset', item);
    mesh.updateByItem(item);
    MediaMesh.getStreamId$(item).pipe(operators.filter(streamId => streamId !== null), operators.take(1)).subscribe(streamId => {
      item.streamId = streamId;
      mesh.load(() => {
        // console.log('ModelPlaneComponent.mesh.load.complete');
      });
    });
  }

  // called by WorldComponent
  onDragMove(position, normal, spherical) {
    // console.log('ModelPlaneComponent.onDragMove', position, normal, spherical);
    const item = this.item;
    const mesh = this.mesh;
    item.showPanel = false;
    this.editing = true;
    if (spherical) {
      position.normalize().multiplyScalar(20);
      mesh.position.set(position.x, position.y, position.z);
      mesh.lookAt(Host.origin);
    } else {
      mesh.position.set(0, 0, 0);
      mesh.lookAt(normal);
      mesh.position.set(position.x, position.y, position.z);
      mesh.position.add(normal.multiplyScalar(0.01));
    }
    this.updateHelper();
  }

  // called by WorldComponent
  onDragEnd() {
    // console.log('ModelPlaneComponent.onDragEnd');
    const item = this.item;
    const mesh = this.mesh;
    item.position = mesh.position.toArray();
    item.rotation = mesh.rotation.toArray();
    item.scale = mesh.scale.toArray();
    mesh.updateFromItem(item);
    this.editing = false;
  }
}
ModelPlaneComponent.textures = {};
ModelPlaneComponent.meta = {
  selector: '[model-plane]',
  hosts: {
    host: WorldComponent
  },
  outputs: ['down', 'play', 'zoom', 'currentTime'],
  inputs: ['item', 'view']
};// export const LOADING_BANNER = { title: LabelPipe.transform('loading') };
// export const WAITING_BANNER = { title: LabelPipe.transform('waiting_host') };

const PANEL_RADIUS = PANORAMA_RADIUS - 0.01;
class ModelProgressComponent extends ModelComponent {
  get title() {
    return this.title_;
  }
  set title(title) {
    if (this.title_ !== title) {
      this.title_ = title;
      if (title === LabelPipe.transform('waiting_host') || title !== '' && this.visible_) {
        this.updateProgress();
        this.show();
      } else {
        this.hide();
      }
    }
  }
  get visible() {
    return this.visible_;
  }
  set visible(visible) {
    if (this.visible_ !== visible) {
      this.visible_ = visible;
      if (visible && this.title_ !== '') {
        this.updateProgress();
        this.show();
      } else {
        this.hide();
      }
    }
  }
  onInit() {
    this.title_ = '';
    this.visible_ = this.host.renderer.xr.isPresenting;
    super.onInit();
    const vrService = this.vrService = VRService.getService();
    vrService.session$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(session => this.visible = session != null); // loose
    // this.progress = LoaderService.progress;
    /*
    const { node } = getContext(this);
    const inner = node.querySelector('.inner');
    LoaderService.progress$.pipe(
    	takeUntil(this.unsubscribe$)
    ).subscribe(progress => {
    	progress.count > 0 ? node.classList.add('active') : node.classList.remove('active');
    	inner.style.width = `${progress.count}%`;
    });
    */
  }

  onCreate(mount, dismount) {
    // console.log('ModelProgressComponent.onCreate');
    const {
      node
    } = rxcomp.getContext(this);
    const inner = node.querySelector('.inner');
    this.getCanvasTexture().then(result => {
      const mesh = this.createMesh(result);
      if (typeof mount === 'function') {
        mount(mesh);
      }
      LoaderService.progress$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(progress => {
        progress.count > 0 ? node.classList.add('active') : node.classList.remove('active');
        inner.style.width = `${progress.value * 100}%`;
        if (progress.count) {
          this.title = progress.value === 0 ? LabelPipe.transform('loading') : progress.title;
        } else {
          this.title = this.getTitle();
        }
      });
    });
  }
  getTitle() {
    if (this.view && this.view.type.name === ViewType.WaitingRoom.name) {
      return LabelPipe.transform('waiting_host');
    } else {
      return '';
    }
  }
  show() {
    this.mesh.add(this.banner);
    this.material.opacity = 1;
    this.material.needsUpdate = true;
    /*
    const material = this.material;
    const from = { value: material.opacity };
    gsap.to(from, {
    	duration: 0.5,
    	value: 1,
    	delay: 0.0,
    	ease: Power2.easeInOut,
    	overwrite: 'all',
    	onUpdate: () => {
    		material.opacity = from.value;
    		material.needsUpdate = true;
    	}
    });
    */
  }

  hide() {
    this.mesh.remove(this.banner);
    this.material.opacity = 0;
    this.material.needsUpdate = true;
    /*
    const from = { value: material.opacity };
    gsap.to(from, {
    	duration: 0.5,
    	value: 0,
    	delay: 0.0,
    	ease: Power2.easeInOut,
    	overwrite: 'all',
    	onUpdate: () => {
    		material.opacity = from.value;
    		material.needsUpdate = true;
    	},
    	onComplete: () => {
    		this.mesh.remove(this.banner);
    	}
    });
    */
  }

  createMesh(result) {
    const mesh = new THREE.Group();
    // const repeat = 24;
    // const aspect = (result.width * repeat) / result.height;
    const arc = Math.PI / 180 * 360;
    const width = PANEL_RADIUS * arc;
    const height = width / 360 * 2.4;
    const w = result.width * height / result.height;
    const repeat = width / w;
    const geometry = new THREE.CylinderBufferGeometry(PANEL_RADIUS, PANEL_RADIUS, height, 80, 2, true, 0, arc);
    geometry.scale(-1, 1, 1);
    const texture = result.texture;
    texture.wrapS = texture.wrapY = THREE.RepeatWrapping;
    texture.repeat.x = repeat;
    texture.encoding = THREE.sRGBEncoding;
    const material = this.material = new THREE.MeshBasicMaterial({
      map: texture,
      transparent: true,
      opacity: 0,
      toneMapped: false
      // side: THREE.DoubleSide,
    });

    this.banner = new THREE.Mesh(geometry, material);
    mesh.userData = {
      render: () => {
        mesh.rotation.y += Math.PI / 180 * 0.02;
        // texture.offset.x = (texture.offset.x - 0.01) % 1;
        // material.needsUpdate = true;
      }
    };

    return mesh;
  }
  updateProgress() {
    this.getCanvasTexture().then(result => {
      // console.log('ModelProgressComponent.updateProgress', result);
      const arc = Math.PI / 180 * 360;
      const width = PANEL_RADIUS * arc;
      const height = width / 360 * 2.4;
      const w = result.width * height / result.height;
      const repeat = width / w;
      this.texture.repeat.x = repeat;
    });
  }
  getCanvasTexture() {
    return new Promise((resolve, reject) => {
      const MIN_W = 512;
      let W = MIN_W;
      let H = 64;
      const F = Math.floor(H * 0.75);
      const L = Math.floor(H * 0.05);
      let canvas;
      if (this.canvas) {
        canvas = this.canvas;
      } else {
        canvas = this.canvas = document.createElement('canvas');
        // canvas.classList.add('canvas--debug');
        // document.querySelector('body').appendChild(canvas);
      }

      canvas.width = W;
      canvas.height = H;
      const text = this.title_;
      // console.log('ModelProgressComponent.getCanvasTexture', text);
      const ctx = canvas.getContext('2d');
      // const ctx = text.material.map.image.getContext('2d');
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = 'high';
      ctx.font = `300 ${F}px ${environment.fontFamily}`;
      const metrics = ctx.measureText(text);
      W = metrics.width + 8;
      W = Math.max(MIN_W, Math.pow(2, Math.ceil(Math.log(W) / Math.log(2))));
      // const x = W / 2;
      // const y = 16;
      canvas.width = W;
      ctx.clearRect(0, 0, W, H);
      ctx.fillStyle = '#0000005A'; // 35% // '#000000C0'; // 75%
      ctx.fillRect(0, 0, W, H);
      ctx.font = `300 ${F}px ${environment.fontFamily}`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.strokeStyle = 'rgba(0, 0, 0, 0.35)';
      ctx.lineWidth = L;
      ctx.lineJoin = 'round'; // Experiment with 'bevel' & 'round' for the effect you want!
      ctx.miterLimit = 2;
      ctx.strokeText(text, W / 2, H / 2);
      ctx.fillStyle = 'white';
      ctx.fillText(text, W / 2, H / 2, W);
      // text.material.map.needsUpdate = true;
      let texture;
      if (this.texture) {
        texture = this.texture;
        texture.needsUpdate = true;
      } else {
        texture = this.texture = new THREE.CanvasTexture(canvas);
      }
      // console.log(F, L, W, H);
      resolve({
        texture: texture,
        width: W,
        height: H
      });
    });
  }
}
ModelProgressComponent.meta = {
  selector: '[model-progress]',
  hosts: {
    host: WorldComponent
  },
  inputs: ['view']
};class ModelRoomComponent extends ModelComponent {
  static get transparentMaterial() {
    if (!this.transparentMaterial_) {
      this.transparentMaterial_ = new THREE.MeshBasicMaterial({
        color: 0xff0000,
        transparent: true,
        opacity: 0
        // side: THREE.DoubleSide
      });
    }

    return this.transparentMaterial_;
  }
  get freezed() {
    return this.freezed_;
  }
  set freezed(freezed) {
    if (this.freezed_ !== freezed) {
      this.freezed_ = freezed;
      const mesh = this.mesh;
      if (mesh) {
        mesh.traverse(child => {
          if (child.isInteractiveMesh) {
            child.freezed = freezed;
          }
        });
      }
    }
  }
  onInit() {
    // console.log('ModelRoomComponent.onInit');
    super.onInit();
    this.isPresenting = false;
    MenuService.active$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(active => this.freezed = active);
  }
  onChanges() {
    this.editing = this.view.selected;
  }
  onCreate(mount, dismount) {
    // this.renderOrder = environment.renderOrder.room;
    this.loadGlb(environment.getPath(this.view.asset.folder), this.view.asset.file, (mesh, animations) => {
      this.onGlbLoaded(mesh, animations, mount, dismount);
    });
  }

  // onView() { const context = getContext(this); }

  // onChanges() {}

  loadGlb(path, file, callback) {
    this.host.renderer;
    // const roughnessMipmapper = new RoughnessMipmapper(renderer); // optional
    const progressRef = LoaderService.getRef();
    // console.log('progressRef');
    const loader = new GLTFLoader().setPath(path);
    // Optional: Provide a DRACOLoader instance to decode compressed mesh data
    const decoderPath = `${environment.dist}js/draco/`;
    // console.log(decoderPath);
    const dracoLoader = new DRACOLoader();
    dracoLoader.setDecoderPath(decoderPath);
    loader.setDRACOLoader(dracoLoader);
    loader.load(file, glb => {
      /*
      glb.scene.traverse((child) => {
      	if (child.isMesh) {
      		// roughnessMipmapper.generateMipmaps(child.material);
      	}
      });
      */
      if (typeof callback === 'function') {
        callback(glb.scene, glb.animations);
      }
      // console.log('ModelRoomComponent.loadGlb');
      LoaderService.setProgress(progressRef, 1);
      // roughnessMipmapper.dispose();
    }, progressEvent => {
      LoaderService.setProgress(progressRef, progressEvent.loaded, progressEvent.total);
    });
  }
  onGlbLoaded(mesh, animations, mount, dismount) {
    const view = this.view;
    mesh.position.set(0, -1.76, 0);
    // nav
    const intersectObjects = [];
    mesh.traverse(child => {
      if (child.isMesh) {
        intersectObjects.push(child);
      }
      if (child.name === 'nav') {
        // child.parent.remove(child);
        view.navIntersectObjects = [child];
        this.makeTransparent(child);
      }
    });
    view.intersectObjects = intersectObjects;
    // animations
    let dummy;
    dummy = new THREE.Group();
    dummy.add(mesh);
    if (typeof mount === 'function') {
      mount(dummy, this.view);
    }
  }
  makeTransparent(object) {
    if (object.isMesh) {
      object.material = ModelRoomComponent.transparentMaterial;
    }
    object.traverse(child => {
      if (child.isMesh) {
        child.material = ModelRoomComponent.transparentMaterial;
      }
    });
  }

  // called by UpdateViewItemComponent
  onUpdateAsset(view, mesh) {
    // console.log('ModelRoomComponent.onUpdateAsset', view);
    this.loadGlb(environment.getPath(view.asset.folder), view.asset.file, (mesh, animations) => {
      this.onGlbLoaded(mesh, animations, (mesh, view) => this.onMount(mesh, view), (mesh, view) => this.onDismount(mesh, view));
    });
  }
}
ModelRoomComponent.meta = {
  selector: '[model-room]',
  hosts: {
    host: WorldComponent
  },
  inputs: ['view']
};class ModelTextComponent extends ModelComponent {
  onInit() {
    super.onInit();
    // console.log('ModelTextComponent.onInit');
  }

  onCreate(mount, dismount) {
    const mesh = new THREE.Group();
    if (typeof mount === 'function') {
      mount(mesh);
    }
  }

  // onView() { const context = getContext(this); }

  // onChanges() {}
}

ModelTextComponent.meta = {
  selector: '[model-text]',
  hosts: {
    host: WorldComponent
  },
  inputs: ['item']
};// AgoraService.fixLegacy();

class AppModule extends rxcomp.Module {}
AppModule.meta = {
  imports: [rxcomp.CoreModule, rxcompForm.FormModule, EditorModule],
  declarations: [AccessCodeComponent, AccessComponent, AgoraChatComponent, AgoraChatEmojiComponent, AgoraCheckComponent, AgoraChecklistComponent, AgoraComponent, AgoraConfigureFirewallModalComponent, AgoraDeviceComponent, AgoraDevicePreviewComponent, AgoraLinkComponent, AgoraLoginComponent, AgoraNameComponent, AgoraStreamComponent, AssetPipe, ControlAssetComponent, ControlAssetsComponent, ControlCheckboxComponent, ControlCustomSelectComponent, ControlLinkComponent, ControlLocalizedAssetComponent, ControlMenuComponent, ControlModelComponent, ControlNumberComponent, ControlPasswordComponent, ControlRequestModalComponent, ControlsComponent, ControlSelectComponent, ControlTextareaComponent, ControlTextComponent, ControlVectorComponent, DisabledDirective, DropDirective, DropdownDirective, DropdownItemDirective, EnvPipe, ErrorsComponent, FlagPipe, GenericComponent, GenericModalComponent, HlsDirective, HtmlPipe, IframeModalComponent, IdDirective, InputValueComponent, LabelPipe, LanguageComponent, LayoutComponent, LazyDirective, MediaPlayerComponent, MessagePipe, ModalComponent, ModalOutletComponent, ModelBannerComponent, ModelComponent, ModelCurvedPlaneComponent, ModelDebugComponent, ModelGridComponent, ModelMenuComponent, ModelModelComponent, ModelNavComponent, ModelPanelComponent, ModelPictureComponent, ModelPlaneComponent, ModelProgressComponent, ModelRoomComponent, ModelTextComponent, RoutePipe, SupportRequestModalComponent, SvgIconStructure, TestComponent, TitleDirective, TryInARComponent, TryInARModalComponent, UploadItemComponent, ValueDirective, VirtualStructure, WorldComponent, RouterOutletStructure, RouterLinkDirective],
  bootstrap: AppComponent
};rxcomp.Browser.bootstrap(AppModule);}));