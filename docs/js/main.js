/**
 * @license beta-bhere-development v1.0.30-canary.0
 * (c) 2023 Luca Zampetti <lzampetti@gmail.com>
 * License: MIT
 */

(function(g,f){typeof exports==='object'&&typeof module!=='undefined'?f(require('rxcomp'),require('rxcomp-form'),require('rxjs'),require('rxjs/operators'),require('three'),require('html2canvas')):typeof define==='function'&&define.amd?define(['rxcomp','rxcomp-form','rxjs','rxjs/operators','three','html2canvas'],f):(g=typeof globalThis!=='undefined'?globalThis:g||self,f(g.rxcomp,g.rxcomp.form,g.rxjs,g.rxjs.operators,g.THREE,g.html2canvas));})(this,(function(rxcomp,rxcompForm,rxjs,operators,three,html2canvas){'use strict';function _interopDefaultLegacy(e){return e&&typeof e==='object'&&'default'in e?e:{'default':e}}var html2canvas__default=/*#__PURE__*/_interopDefaultLegacy(html2canvas);const CHUNK_REMOTE = /* html */`
<!-- remote sidebar -->
<div class="group--remote" [class]="remoteClass" *if="state.live">
	<div class="agora-stream" (toggleControl)="onToggleControl($event)" (toggleSpy)="onToggleSpy($event)" agora-stream [stream]="remote" type="remote" *for="let remote of remotes">
		<div class="agora-stream__player"></div>
		<div class="agora-stream__info" [class]="{ spyed: state.spying == streamId, controlling: state.controlling == streamId }">
			<svg class="cam-muted" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#cam-muted"></use></svg>
			<svg class="mic-muted" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#mic-muted"></use></svg>
			<div class="id" [innerHTML]="stream.clientInfo.name || streamId" *if="stream.clientInfo"></div>
			<button type="button" class="btn--control" [title]="'title_control' | label" (click)="onToggleControl(streamId)" *if="state.role === 'publisher'">
				<svg class="control" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#control"></use></svg>
			</button>
			<button type="button" class="btn--spy" [title]="'title_spy' | label" (click)="onToggleSpy(streamId)" *if="state.role === 'publisher'">
				<svg class="spy" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#spy"></use></svg>
			</button>
		</div>
	</div>
	<div class="group--members" *if="state.mode == 'virtual-tour'">
		<div class="members" *if="state.role === 'publisher'">
			<svg class="spy" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#users"></use></svg>
			<span class="members__count" [innerHTML]="state.membersCount"></span>
		</div>
		<div class="credits">
			<a class="btn--credits" href="https://www.websolute.com/" target="_blank" rel="noopener">
				<svg viewBox="0 0 270 98"><use xlink:href="#b-here"></use></svg>
			</a>
		</div>
	</div>
</div>
<!-- remote screen -->
<div class="group--remote-screen" *if="remoteScreen">
	<div class="agora-stream" agora-stream [stream]="remoteScreen" type="remote">
		<div class="agora-stream__player"></div>
		<div class="agora-stream__info">
			<div class="id" [innerHTML]="stream.clientInfo.name || streamId" *if="stream.clientInfo"></div>
		</div>
	</div>
</div>
`;
const CHUNK_SERVICE = /* html */`
<!-- service -->
<div class="group--service">
	<button type="button" class="btn--back" [title]="'title_back' | label" (click)="onBack($event)" *if="isBackButtonVisible">
		<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#arrow-prev"></use></svg>
	</button>
	<button type="button" class="btn--view-mode" [title]="'title_view_mode' | label" (click)="toggleMode($event)" *if="state.mode != 'embed'">
		<svg width="24" height="24" viewBox="0 0 24 24" *if="state.mode == 'virtual-tour'"><use xlink:href="#live-meeting"></use></svg>
		<svg width="24" height="24" viewBox="0 0 24 24" *if="state.mode == 'live-meeting'"><use xlink:href="#virtual-tour"></use></svg>
	</button>
	<button type="button" class="btn--volume" [title]="'title_volume' | label" [class]="{ muted: state.volumeMuted }" (click)="toggleVolume($event)">
		<svg width="24" height="24" viewBox="0 0 24 24" *if="!state.volumeMuted"><use xlink:href="#volume-on"></use></svg>
		<svg width="24" height="24" viewBox="0 0 24 24" *if="state.volumeMuted"><use xlink:href="#volume-off"></use></svg>
	</button>
	<button type="button" class="btn--fullscreen" [title]="'title_fullscreen' | label" [class]="{ muted: state.fullScreen }" (click)="toggleFullScreen($event)">
		<svg width="24" height="24" viewBox="0 0 24 24" *if="!state.fullScreen"><use xlink:href="#fullscreen-on"></use></svg>
		<svg width="24" height="24" viewBox="0 0 24 24" *if="state.fullScreen"><use xlink:href="#fullscreen-off"></use></svg>
	</button>
	<button type="button" class="btn--navmap" [title]="'title_navmap' | label" [class]="{ active: state.showNavmap }" (click)="toggleNavmap($event)" *if="navmap && state.mode != 'live-meeting'">
		<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#navmap"></use></svg>
	</button>
</div>
`;
const CHUNK_LOCAL = /* html */`
<!-- local streams -->
<div class="group--local" [class]="{ publisher: state.role == 'publisher', viewer: state.role == 'viewer' }" *if="state.live">
	<button type="button" class="btn--silence" [title]="'title_silence' | label" [class]="{ active: state.silencing }" (click)="onToggleSilence()" *if="state.role === 'publisher'">
		<svg class="mic-muted" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#mic-muted"></use></svg>
	</button>
	<button type="button" class="btn--control" [title]="'title_control' | label" [class]="{ active: state.controlling == state.uid }" (click)="onToggleControl(state.uid)" *if="state.role == 'publisher'">
		<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#control"></use></svg>
	</button>
	<div class="agora-stream" *if="!local"></div>
	<div class="agora-stream" agora-stream [stream]="local" type="local" *if="local">
		<div class="agora-stream__player"></div>
		<div class="agora-stream__info">
			<svg class="cam-muted" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#cam-muted"></use></svg>
			<svg class="mic-muted" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#mic-muted"></use></svg>
		</div>
	</div>
	<div class="agora-stream agora-stream--screen" agora-stream [stream]="screen" type="local" *if="screen && hasScreenViewItem">
		<div class="agora-stream__player"></div>
	</div>
</div>
`;
const CHUNK_LOCAL_SMART_DEVICE = /* html */`
<!-- local streams -->
<div class="group--local" [class]="{ publisher: state.role == 'publisher', viewer: state.role == 'viewer' }" *if="state.live">
	<div class="agora-stream" agora-stream [stream]="local" type="local" *if="local">
		<div class="agora-stream__player"></div>
		<div class="agora-stream__info">
			<svg class="cam-muted" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#cam-muted"></use></svg>
			<svg class="mic-muted" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#mic-muted"></use></svg>
		</div>
	</div>
</div>
`;
const CHUNK_CONTROLS = /* html */`
<!-- controls -->
<div class="group--controls" *if="state.live">
	<div class="group--actions">
		<button type="button" class="btn--call" [title]="'title_disconnect' | label" (click)="disconnect()">
			<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#call"></use></svg>
		</button>
		<button type="button" class="btn--cam" [title]="'title_mute_camera' | label" [class]="{ muted: state.cameraMuted, disabled: !local }" (click)="toggleCamera()">
			<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#cam"></use></svg>
		</button>
		<button type="button" class="btn--mic" [title]="'title_mute_mic' | label" [class]="{ muted: state.audioMuted, disabled: !local || silenced }" (click)="toggleAudio()">
			<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#mic"></use></svg>
		</button>
		<button type="button" class="btn--screen" [title]="'title_share_screen' | label" [class]="{ active: screen }" (click)="toggleScreen()" *if="('screenShare' | flag) && (state.role == 'publisher' || state.role == 'attendee' || controlling)">
			<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#screen"></use></svg>
		</button>
		<button type="button" class="btn--chat" [title]="'title_chat' | label" [class]="{ active: state.chatDirty }" (click)="toggleChat()" *if="('chat' | flag)">
			<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#chat"></use></svg>
		</button>
		<button type="button" class="btn--navinfo" [title]="'title_navinfo' | label" [class]="{ active: state.showNavInfo }" (click)="toggleNavInfo()" *if="showNavInfoToggler">
			<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#navinfo"></use></svg>
		</button>
	</div>
</div>
`;
const CHUNK_CONTROLS_SMART_DEVICE = /* html */`
<!-- controls -->
<div class="group--controls" *if="state.live">
	<div class="group--actions">
		<button type="button" class="btn--call" [title]="'title_disconnect' | label" (click)="disconnect()">
			<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#call"></use></svg>
		</button>
		<button type="button" class="btn--cam" [title]="'title_mute_camera' | label" [class]="{ muted: state.cameraMuted, disabled: !local }" (click)="toggleCamera()">
			<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#cam"></use></svg>
		</button>
		<button type="button" class="btn--mic" [title]="'title_mute_mic' | label" [class]="{ muted: state.audioMuted, disabled: !local || silenced }" (click)="toggleAudio()">
			<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#mic"></use></svg>
		</button>
	</div>
</div>
`;
const CHUNK_MEMBERS = /* html */`
<!-- members -->
<div class="group--members" *if="state.mode == 'live-meeting'">
	<div class="members" *if="state.role === 'publisher'">
		<svg class="spy" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#users"></use></svg>
		<span class="members__count" [innerHTML]="state.membersCount"></span>
	</div>
	<div class="credits">
		<a class="btn--credits" href="https://www.websolute.com/" target="_blank" rel="noopener">
			<svg viewBox="0 0 270 98"><use xlink:href="#b-here"></use></svg>
		</a>
	</div>
</div>
`;
const CHUNK_MEMBERS_SMART_DEVICE = /* html */`
<!-- members -->
<div class="group--members">
	<div class="members" *if="state.role === 'publisher'">
		<svg class="spy" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#users"></use></svg>
		<span class="members__count" [innerHTML]="state.membersCount"></span>
	</div>
	<div class="credits">
		<a class="btn--credits" href="https://www.websolute.com/" target="_blank" rel="noopener">
			<svg viewBox="0 0 270 98"><use xlink:href="#b-here"></use></svg>
		</a>
	</div>
</div>
`;
const CHUNK_MEDIA = /* html */`
<!-- media -->
<div class="group--media" media-player>
	<button type="button" class="btn--play" [title]="'title_play' | label" (click)="onPlay()" *if="!playing">
		<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#play"></use></svg>
	</button>
	<button type="button" class="btn--pause" [title]="'title_pause' | label" (click)="onPause()" *if="playing">
		<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#pause"></use></svg>
	</button>
	<div class="track" (click)="onTrack($event)">
		<div class="track__progress" [style]="{ transform: 'scale(' + this.progress + ', 1)'}"></div>
	</div>
</div>
`;
const CHUNK_AR_VR = /* html */`
<!-- ar-vr -->
<div class="group--ar-vr">
	<button type="button" class="btn--ar" [title]="'title_ar' | label" [href]="view?.ar" (click)="tryInAr()" *if="view?.ar">
		<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#ar"></use></svg> <span>Try in AR</span>
	</button>
	<button type="button" class="btn--vr" [title]="'title_vr' | label" [class]="{ disabled: vrService.isDisabled() }" (click)="vrService.toggleVR()">
		<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#vr"></use></svg> <span [innerHTML]="vrService.getLabel()"></span>
	</button>
</div>
`;
const CHUNK_LIKE = /* html */`
<!-- like -->
<div class="group--heart" *if="view && ('like' | flag)">
	<svg class="love" [class]="{ active: view.showLove }" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#heart"></use></svg>
	<button type="button" class="btn--heart" [class]="{ active: view.showLove }" (click)="addLike($event)">
		<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#heart"></use></svg>
		<span class="badge" [innerHTML]="view.likes" *if="view.likes"></span>
	</button>
</div>
<div class="group--spacer" *if="!view || !('like' | flag)"></div>
`;
const CHUNK_CHAT = /* html */`
<!-- chat -->
<div class="group--chat" *if="state.chat" agora-chat (close)="onChatClose()"></div>
`;
const CHUNK_LOCK = /* html */`
<!-- lock -->
<div class="ui__lock" [class]="{ spying: spying }" *if="locked || controlling"></div>
`;
const CHUNK_NAVMAP = /* html */`
<!-- navmap -->
<div class="group--navmap" *if="navmap && state.showNavmap && state.mode != 'live-meeting'">
	<img draggable="false" [src]="navmap.asset | asset" *if="navmap.asset" />
	<div class="navmap__item" [style]="{ left: item.position[0] * 100 + '%', top: item.position[1] * 100 + '%' }" (click)="onNavmapItem(item)" *for="let item of navmap.items">
		<img draggable="false" [src]="'textures/ui/nav-point.png' | asset" />
		<div class="title" [innerHTML]="item.title" *if="item.title"></div>
	</div>
</div>
`;
const CHUNK_BACKGROUND = /* html */`
<!-- background -->
<div class="background" [class]="{ 'background--image': ('background.image' | env), 'background--video': ('background.video' | env) }" *if="state.status != 'connected'">
	<img [src]="'background.image' | env | asset" *if="'background.image' | env" />
	<video [src]="'background.video' | env | asset" *if="'background.video' | env" oncanplay="this.muted = true; this.classList.add('ready');" playsinline autoplay muted loop></video>
</div>
`;
const CHUNK_LOGO = /* html */`
<!-- logo -->
<a class="btn--logo" [routerLink]="':lang.access' | route" *if="state.status != 'connected'">
	<img [src]="'logo' | env" *if="'logo' | env" />
	<svg viewBox="0 0 270 98" *if="!('logo' | env)"><use xlink:href="#b-here"></use></svg>
</a>
`;
const CHUNK_CREDITS = /* html */`
<!-- credits -->
<a class="btn--credits" href="https://www.websolute.com/" target="_blank" rel="noopener" *if="state.status != 'connected'">
	<svg viewBox="0 0 270 98"><use xlink:href="#b-here"></use></svg>
</a>
`;
const CHUNK_COPYRIGHT = /* html */`
<!-- copyright -->
<span *if="'gdprRoutes' | flag"> <span [innerHTML]="'copyright' | label"></span> <span *if="'privacy_policy' | label">-</span> <a [routerLink]="':lang.privacy' | route" class="btn--colophon" [innerHTML]="'privacy_policy' | label"></a> <span *if="'terms_of_service' | label">-</span> <a [routerLink]="':lang.terms' | route" class="btn--colophon" [innerHTML]="'terms_of_service' | label"></a></span>
`;
const CHUNK_LANGUAGE = /* html */`
<!-- language -->
<div class="group--language" language *if="state.status != 'connected'"></div>
`;
const CHUNK_VIRTUAL_TOUR = /* html */`
<!-- Virtual Tour -->
<div class="ui virtual-tour" [class]="uiClass" *if="state.status == 'connected' && isVirtualTourUser">
	<!-- world -->
	<div class="ui__body">
		<div class="world" world [view]="view" [views]="pathViews" (navTo)="onNavTo($event)" (navLink)="onNavLink($event)"></div>
	</div>
	${CHUNK_REMOTE}
	<div class="group--header">
		${CHUNK_SERVICE}
		${CHUNK_LOCAL}
	</div>
	<div class="group--footer">
		${CHUNK_CONTROLS}
		${CHUNK_MEDIA}
		${CHUNK_AR_VR}
		${CHUNK_LIKE}
	</div>
	${CHUNK_MEMBERS}
	${CHUNK_CHAT}
	${CHUNK_LOCK}
	${CHUNK_NAVMAP}
</div>
`;
const CHUNK_SMART_DEVICE = /* html */`
<!-- Smart Device -->
<div class="ui remotes" [class]="uiClass" *if="state.status == 'connected' && state.role == 'smart-device'">
	<div class="ui__body"></div>
	<!-- remote sidebar -->
	<div class="group--remote" [class]="'group--remote--' + remotes.length" *if="state.live">
		<div class="agora-stream" (toggleSpy)="onToggleSpy($event)" agora-stream [stream]="remote" type="remote" *for="let remote of remotes">
			<div class="agora-stream__player"></div>
			<div class="agora-stream__info">
				<svg class="cam-muted" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#cam-muted"></use></svg>
				<svg class="mic-muted" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#mic-muted"></use></svg>
				<div class="id" [innerHTML]="stream.clientInfo.name || streamId" *if="stream.clientInfo"></div>
			</div>
		</div>
	</div>
	<!-- remote screen -->
	<div class="group--remote-screen" *if="remoteScreen && !hasScreenViewItem">
		<div class="agora-stream" agora-stream [stream]="remoteScreen" type="remote">
			<div class="agora-stream__player"></div>
			<div class="agora-stream__info">
				<div class="id" [innerHTML]="stream.clientInfo.name || streamId" *if="stream.clientInfo"></div>
			</div>
		</div>
	</div>
	<div class="group--header">
		${CHUNK_LOCAL_SMART_DEVICE}
	</div>
	<div class="group--footer">
		${CHUNK_CONTROLS_SMART_DEVICE}
	</div>
	${CHUNK_MEMBERS_SMART_DEVICE}
</div>
`;
const CHUNK_SELF_SERVICE_TOUR = /* html */`
<!-- Self Service Tour -->
<div class="ui" [class]="uiClass" *if="state.status == 'connected' && state.mode == 'self-service-tour'">
	<!-- world -->
	<div class="ui__body">
		<div class="world" world [view]="view" [views]="pathViews" (navTo)="onNavTo($event)" (navLink)="onNavLink($event)"></div>
	</div>
	<div class="group--header">
		${CHUNK_SERVICE}
	</div>
	<div class="group--footer">
		<div class="group--spacer"></div>
		${CHUNK_MEDIA}
		${CHUNK_AR_VR}
		${CHUNK_LIKE}
	</div>
	${CHUNK_NAVMAP}
</div>
`;
const CHUNK_EMBED = /* html */`
<!-- Embed -->
<div class="ui" [class]="uiClass" *if="state.status == 'connected' && state.mode == 'embed'">
	<!-- world -->
	<div class="ui__body">
		<div class="world" world [view]="view" [views]="pathViews" (navTo)="onNavTo($event)" (navLink)="onNavLink($event)"></div>
	</div>
	<div class="group--header">
		${CHUNK_SERVICE}
	</div>
	<div class="group--footer">
		<div class="group--spacer"></div>
		${CHUNK_MEDIA}
		${CHUNK_AR_VR}
		${CHUNK_LIKE}
	</div>
</div>
`;const environmentServed = {
  appKey: '8b0cae93d47a44e48e97e7fd0404be4e',
  channelName: 'BHere',
  flags: {
    production: true,
    useProxy: false,
    useToken: false,
    usePrefetch: true,
    useExtendedUserInfo: false,
    useEncryptedUrl: false,
    gdprRoutes: false,
    selfService: true,
    guidedTourRequest: true,
    guidedTourAccess: true,
    ssoLogin: false,
    ssoRegister: false,
    editor: false,
    editorAssetScreen: false,
    menu: true,
    menuEmbed: false,
    navmaps: false,
    screenShare: false,
    chat: false,
    ar: true,
    like: true,
    hideNavInfo: true,
    useIframe: true,
    attendee: true,
    streamer: true,
    viewer: true,
    smartDevice: true,
    selfServiceProposition: false,
    navInfoAnimated: false,
    navInfoImportantAnimated: false,
    navMoveAnimated: false,
    navMoveImportantAnimated: false,
    navPointAnimated: false,
    navPointImportantAnimated: false,
    navTitleAnimated: false,
    navTitleImportantAnimated: false,
    navTransparentAnimated: false,
    navTransparentImportantAnimated: false,
    useTextureEnvironment: true,
    usePaths: false,
    antialias: true,
    alpha: false,
    premultipliedAlpha: false
    // maxQuality: false,
  },

  navs: {
    iconMinScale: 1,
    iconMaxScale: 1.4
  },
  profiles: {
    // streamer: "480p_1", // 640 x 480 x 15
    streamer: '480p_2',
    // 640 x 480 x 30
    // streamer: "480p_3", // 480 x 480 x 15
    // streamer: "480p_4", // 640 x 480 x 30
    // streamer: "480p_6", // 480 x 480 x 30
    // streamer: "480p_8", // 848, 480 x 15
    // streamer: "480p_9", // 848, 480 x 30
    // streamer: "480p_10", // 640 x 480 x 10
    // streamer: "720p_1", // 1280 x 720 x 15
    // streamer: "720p_2", // 1280 x 720 x 30
    // streamer: "720p_3", // 1280 x 720 x 30
    // streamer: "720p_5", // 960 x 720 x 15
    // streamer: "720p_6", // 960 x 720 x 30
    // streamer: "1080p_1", // 1920 x 1080 x 15
    // streamer: "1080p_2", // 1920 x 1080 x 30
    // streamer: "1080p_3", // 1920 x 1080 x 30
    // streamer: "1080p_5", // 1920 x 1080 x 60

    // attendee: "720p_2", // 1920 x 1080 x 30
    attendee: '1080p_2',
    // 1920 x 1080 x 30

    // publisher: "720p_2", // 1920 x 1080 x 30
    publisher: '1080p_2',
    // 1920 x 1080 x 30

    // screen: "480p_1", // 640 × 480 x 5
    // screen: "480p_2", // 640 × 480 x 30
    // screen: "720p_1", // 1280 × 720 x 5
    screen: '720p_2' // 1280 × 720 x 30
    // screen: "1080p_1", // 1920 × 1080 x 5
    // screen: "1080p_2", // 1920 × 1080 30
  },

  logo: null,
  /*
  background: {
  	// image: 'img/background.jpg',
  	video: 'img/background.mp4',
  },
  */
  selfServiceAudio: null,
  // 'audio/self-service.mp3',
  colors: {
    menuBackground: '#000000',
    menuForeground: '#ffffff',
    menuOverBackground: '#0099ff',
    menuOverForeground: '#ffffff',
    menuBackBackground: '#0099ff',
    menuBackForeground: '#000000',
    menuBackOverBackground: '#0099ff',
    menuBackOverForeground: '#ffffff'
  },
  editor: {
    disabledViewTypes: ['waiting-room', 'room-3d', 'media'],
    disabledViewItemTypes: ['texture']
  },
  assets: '/Modules/B-Here/Client/docs/',
  dist: '/Modules/B-Here/Client/dist/',
  workers: {
    image: '/Modules/B-Here/Client/docs/js/workers/image.service.worker.js',
    prefetch: '/Modules/B-Here/Client/docs/js/workers/prefetch.service.worker.js'
  },
  textures: {
    envMap: 'textures/envMap/studio_small_03_2k.hdr',
    grid: 'textures/grid/grid.jpg'
  },
  toneMappingExposure: 1,
  githubDocs: 'https://raw.githubusercontent.com/actarian/b-here/beta-bhere-sso/docs/',
  template: {
    email: {
      supportRequest: '/template/modules/b-here/email/support-request.cshtml'
    }
  }
};const environmentStatic = {
  appKey: '8b0cae93d47a44e48e97e7fd0404be4e',
  channelName: 'BHere',
  flags: {
    production: false,
    useProxy: true,
    useToken: false,
    usePrefetch: true,
    useExtendedUserInfo: true,
    useEncryptedUrl: true,
    gdprRoutes: true,
    selfService: true,
    guidedTourRequest: true,
    guidedTourAccess: true,
    ssoLogin: false,
    ssoRegister: false,
    editor: true,
    editorAssetScreen: true,
    menu: true,
    menuEmbed: true,
    navmaps: true,
    screenShare: true,
    chat: true,
    ar: true,
    like: true,
    hideNavInfo: true,
    useIframe: true,
    attendee: true,
    streamer: true,
    viewer: true,
    smartDevice: true,
    selfServiceProposition: false,
    navInfoAnimated: false,
    navInfoImportantAnimated: false,
    navMoveAnimated: true,
    navMoveImportantAnimated: true,
    navPointAnimated: false,
    navPointImportantAnimated: false,
    navTitleAnimated: false,
    navTitleImportantAnimated: false,
    navTransparentAnimated: true,
    navTransparentImportantAnimated: true,
    useTextureEnvironment: true,
    usePaths: true,
    antialias: true,
    alpha: false,
    premultipliedAlpha: false
  },
  sso: {
    issuer: 'bhere-sso',
    origin: 'http://localhost:3010',
    loginUrl: 'http://localhost:3010/sso/login?redirectUrl={redirectUrl}',
    logoutUrl: 'http://localhost:3010/sso/logout?redirectUrl={redirectUrl}',
    registerUrl: 'http://localhost:3010/sso/register?redirectUrl={redirectUrl}',
    verifyTokenUrl: 'http://localhost:3010/sso/verifytoken?verifyToken={verifytoken}'
  },
  navs: {
    iconMinScale: 1,
    iconMaxScale: 1.4
  },
  profiles: {
    // streamer: "480p_1", // 640 x 480 x 15
    streamer: '480p_2',
    // 640 x 480 x 30
    // streamer: "480p_3", // 480 x 480 x 15
    // streamer: "480p_4", // 640 x 480 x 30
    // streamer: "480p_6", // 480 x 480 x 30
    // streamer: "480p_8", // 848, 480 x 15
    // streamer: "480p_9", // 848, 480 x 30
    // streamer: "480p_10", // 640 x 480 x 10
    // streamer: "720p_1", // 1280 x 720 x 15
    // streamer: "720p_2", // 1280 x 720 x 30
    // streamer: "720p_3", // 1280 x 720 x 30
    // streamer: "720p_5", // 960 x 720 x 15
    // streamer: "720p_6", // 960 x 720 x 30
    // streamer: "1080p_1", // 1920 x 1080 x 15
    // streamer: "1080p_2", // 1920 x 1080 x 30
    // streamer: "1080p_3", // 1920 x 1080 x 30
    // streamer: "1080p_5", // 1920 x 1080 x 60

    // attendee: "720p_2", // 1920 x 1080 x 30
    attendee: '1080p_2',
    // 1920 x 1080 x 30

    // publisher: "720p_2", // 1920 x 1080 x 30
    publisher: '1080p_2',
    // 1920 x 1080 x 30

    // screen: "480p_1", // 640 × 480 x 5
    // screen: "480p_2", // 640 × 480 x 30
    // screen: "720p_1", // 1280 × 720 x 5
    // screen: "720p_2", // 1280 × 720 x 30
    // screen: "1080p_1", // 1920 × 1080 x 5
    screen: '1080p_2' // 1920 × 1080 30
  },

  logo: null,
  /*
  background: {
  	// image: 'img/background.jpg',
  	video: 'img/background.mp4',
  },
  */
  selfServiceAudio: null,
  // 'audio/self-service.mp3',
  colors: {
    menuBackground: '#000000',
    menuForeground: '#ffffff',
    menuOverBackground: '#0099ff',
    menuOverForeground: '#ffffff',
    menuBackBackground: '#0099ff',
    menuBackForeground: '#000000',
    menuBackOverBackground: '#0099ff',
    menuBackOverForeground: '#ffffff'
  },
  editor: {
    disabledViewTypes: ['waiting-room'],
    disabledViewItemTypes: ['texture']
  },
  assets: '/docs/',
  dist: '/dist/',
  workers: {
    image: './js/workers/image.service.worker.js',
    prefetch: './js/workers/prefetch.service.worker.js'
  },
  textures: {
    envMap: 'textures/envMap/studio_small_03_2k.hdr',
    grid: 'textures/grid/grid.jpg'
  },
  toneMappingExposure: 1,
  githubDocs: 'https://raw.githubusercontent.com/actarian/b-here/beta-bhere-sso/docs/',
  template: {
    email: {
      supportRequest: '/email/support-request.html'
    }
  }
};class Utils {
  static merge(target, source) {
    // override null values
    if (source === null) {
      return source;
    }
    // assign new values
    if (!target) {
      if (source && typeof source === 'object') {
        return Object.assign({}, source);
      } else {
        return source;
      }
    }
    // merge objects
    if (source && typeof source === 'object') {
      Object.keys(source).forEach(key => {
        const value = source[key];
        if (typeof value === 'object' && !Array.isArray(value)) {
          target[key] = this.merge(target[key], value);
        } else {
          target[key] = value;
        }
      });
    }
    return target;
  }
}const NODE = typeof module !== 'undefined' && module.exports;
const PARAMS = NODE ? {
  get: () => {}
} : new URLSearchParams(window.location.search);
const DEBUG = PARAMS.get('debug') != null;
NODE ? null : document.querySelector('base').getAttribute('href');
const HEROKU = NODE ? false : window && window.location.host.indexOf('herokuapp') !== -1;
const VERCEL = NODE ? false : window && window.location.host.indexOf('vercel.app') !== -1;
const DEPLOYED = HEROKU || VERCEL;
const STATIC = NODE ? false : DEPLOYED || window && (window.location.port === '41789' || window.location.port === '5000' || window.location.port === '6443' || window.location.host === 'actarian.github.io');
const DEVELOPMENT = NODE ? false : window && ['localhost', '127.0.0.1', '0.0.0.0'].indexOf(window.location.host.split(':')[0]) !== -1;
const PRODUCTION = !DEVELOPMENT;
const ENV = {
  STATIC,
  DEVELOPMENT,
  PRODUCTION
};
class Environment {
  get STATIC() {
    return ENV.STATIC;
  }
  set STATIC(STATIC) {
    ENV.STATIC = STATIC === true || STATIC === 'true';
    console.log('Environment.STATIC.set', ENV.STATIC);
  }
  get href() {
    if (DEPLOYED) {
      return this.githubDocs;
    } else {
      return this.assets;
    }
  }
  getAbsoluteUrl(path, params) {
    let url = `${window.location.origin}${path}`;
    // let url = `${window.location.protocol}//${window.location.host}${path}`;
    Object.keys(params).forEach(key => {
      url = url.replace(`$${key}`, params[key]);
    });
    return url;
  }
  getPath(path) {
    return this.isLocal(path) ? this.href + path : path;
  }
  isLocal(path) {
    return path.indexOf('://') === -1;
  }
  merge(options) {
    if (options) {
      Utils.merge(this, options);
    }
  }
  constructor(options) {
    if (options) {
      Object.assign(this, options);
    }
  }
}
const defaultOptions$3 = {
  port: 5000,
  // fontFamily: 'GT Walsheim, sans-serif',
  fontFamily: 'Work Sans, sans-serif',
  colors: {
    menuBackground: '#000000',
    menuForeground: '#ffffff',
    menuOverBackground: '#0099ff',
    menuOverForeground: '#ffffff',
    menuBackBackground: '#0099ff',
    menuBackForeground: '#000000',
    menuBackOverBackground: '#0099ff',
    menuBackOverForeground: '#ffffff'
  },
  editor: {
    disabledViewTypes: ['waiting-room', 'room-3d', 'media'],
    disabledViewItemTypes: ['texture']
  },
  renderOrder: {
    panorama: 0,
    room: 10,
    plane: 20,
    tile: 30,
    model: 40,
    banner: 50,
    nav: 60,
    panel: 70,
    menu: 80,
    debug: 90,
    pointer: 100
  }
};
const defaultAppOptions = {
  channelName: 'BHere',
  flags: {
    heroku: HEROKU,
    vercel: VERCEL,
    deployed: DEPLOYED
  },
  navs: {
    iconMinScale: 1,
    iconMaxScale: 1.4
  },
  url: {},
  languages: ['it', 'en'],
  defaultLanguage: 'it',
  labels: {},
  data: {},
  fields: []
};
const environmentOptions = window.STATIC ? environmentStatic : environmentServed;
let options = Object.assign(defaultOptions$3, defaultAppOptions, environmentOptions);
options = Utils.merge(options, window.bhere);
const environment = new Environment(options);
console.log('environment', environment);/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

var __assign$3 = function() {
    __assign$3 = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign$3.apply(this, arguments);
};/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

var __assign$2 = function() {
    __assign$2 = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign$2.apply(this, arguments);
};var makeOptions = function makeOptions(opts) {
  if (opts === void 0) {
    opts = {};
  }

  return {
    arrayFormat: opts.arrayFormat || 'none',
    booleanFormat: opts.booleanFormat || 'none',
    nullFormat: opts.nullFormat || 'default'
  };
};

var encodeValue = function encodeValue(value) {
  return encodeURIComponent(value);
};

var decodeValue = function decodeValue(value) {
  return decodeURIComponent(value);
};

var encodeBoolean = function encodeBoolean(name, value, opts) {
  if (opts.booleanFormat === 'empty-true' && value) {
    return name;
  }

  var encodedValue;

  if (opts.booleanFormat === 'unicode') {
    encodedValue = value ? '✓' : '✗';
  } else {
    encodedValue = value.toString();
  }

  return name + "=" + encodedValue;
};

var encodeNull = function encodeNull(name, opts) {
  if (opts.nullFormat === 'hidden') {
    return '';
  }

  if (opts.nullFormat === 'string') {
    return name + "=null";
  }

  return name;
};

var getNameEncoder = function getNameEncoder(opts) {
  if (opts.arrayFormat === 'index') {
    return function (name, index) {
      return name + "[" + index + "]";
    };
  }

  if (opts.arrayFormat === 'brackets') {
    return function (name) {
      return name + "[]";
    };
  }

  return function (name) {
    return name;
  };
};

var encodeArray = function encodeArray(name, arr, opts) {
  var encodeName = getNameEncoder(opts);
  return arr.map(function (val, index) {
    return encodeName(name, index) + "=" + encodeValue(val);
  }).join('&');
};
var encode = function encode(name, value, opts) {
  if (value === null) {
    return encodeNull(name, opts);
  }

  if (typeof value === 'boolean') {
    return encodeBoolean(name, value, opts);
  }

  if (Array.isArray(value)) {
    return encodeArray(name, value, opts);
  }

  return name + "=" + encodeValue(value);
};
var decode = function decode(value, opts) {
  if (value === undefined) {
    return opts.booleanFormat === 'empty-true' ? true : null;
  }

  if (opts.booleanFormat === 'string') {
    if (value === 'true') {
      return true;
    }

    if (value === 'false') {
      return false;
    }
  }

  if (opts.booleanFormat === 'unicode') {
    if (decodeValue(value) === '✓') {
      return true;
    }

    if (decodeValue(value) === '✗') {
      return false;
    }
  }

  if (opts.nullFormat === 'string') {
    if (value === 'null') {
      return null;
    }
  }

  return decodeValue(value);
};

var getSearch$1 = function getSearch(path) {
  var pos = path.indexOf('?');

  if (pos === -1) {
    return path;
  }

  return path.slice(pos + 1);
};
var isSerialisable = function isSerialisable(val) {
  return val !== undefined;
};
var parseName = function parseName(name) {
  var bracketPosition = name.indexOf('[');
  var hasBrackets = bracketPosition !== -1;
  return {
    hasBrackets: hasBrackets,
    name: hasBrackets ? name.slice(0, bracketPosition) : name
  };
};

/**
 * Parse a querystring and return an object of parameters
 */

var parse = function parse(path, opts) {
  var options = makeOptions(opts);
  return getSearch$1(path).split('&').reduce(function (params, param) {
    var _a = param.split('='),
        rawName = _a[0],
        value = _a[1];

    var _b = parseName(rawName),
        hasBrackets = _b.hasBrackets,
        name = _b.name;

    var currentValue = params[name];
    var decodedValue = decode(value, options);

    if (currentValue === undefined) {
      params[name] = hasBrackets ? [decodedValue] : decodedValue;
    } else {
      params[name] = (Array.isArray(currentValue) ? currentValue : [currentValue]).concat(decodedValue);
    }

    return params;
  }, {});
};
/**
 * Build a querystring from an object of parameters
 */

var build = function build(params, opts) {
  var options = makeOptions(opts);
  return Object.keys(params).filter(function (paramName) {
    return isSerialisable(params[paramName]);
  }).map(function (paramName) {
    return encode(paramName, params[paramName], options);
  }).filter(Boolean).join('&');
};
/**
 * Remove a list of parameters from a querystring
 */

var omit = function omit(path, paramsToOmit, opts) {
  var options = makeOptions(opts);
  var searchPart = getSearch$1(path);

  if (searchPart === '') {
    return {
      querystring: '',
      removedParams: {}
    };
  }

  var _a = path.split('&').reduce(function (_a, chunk) {
    var left = _a[0],
        right = _a[1];
    var rawName = chunk.split('=')[0];
    var name = parseName(rawName).name;
    return paramsToOmit.indexOf(name) === -1 ? [left.concat(chunk), right] : [left, right.concat(chunk)];
  }, [[], []]),
      kept = _a[0],
      removed = _a[1];

  return {
    querystring: kept.join('&'),
    removedParams: parse(removed.join('&'), options)
  };
};/**
 * We encode using encodeURIComponent but we want to
 * preserver certain characters which are commonly used
 * (sub delimiters and ':')
 *
 * https://www.ietf.org/rfc/rfc3986.txt
 *
 * reserved    = gen-delims / sub-delims
 *
 * gen-delims  = ":" / "/" / "?" / "#" / "[" / "]" / "@"
 *
 * sub-delims  = "!" / "$" / "&" / "'" / "(" / ")"
              / "*" / "+" / "," / ";" / "="
 */
var excludeSubDelimiters = /[^!$'()*+,;|:]/g;
var encodeURIComponentExcludingSubDelims = function encodeURIComponentExcludingSubDelims(segment) {
  return segment.replace(excludeSubDelimiters, function (match) {
    return encodeURIComponent(match);
  });
};
var encodingMethods = {
  "default": encodeURIComponentExcludingSubDelims,
  uri: encodeURI,
  uriComponent: encodeURIComponent,
  none: function none(val) {
    return val;
  },
  legacy: encodeURI
};
var decodingMethods = {
  "default": decodeURIComponent,
  uri: decodeURI,
  uriComponent: decodeURIComponent,
  none: function none(val) {
    return val;
  },
  legacy: decodeURIComponent
};
var encodeParam = function encodeParam(param, encoding, isSpatParam) {
  var encoder = encodingMethods[encoding] || encodeURIComponentExcludingSubDelims;

  if (isSpatParam) {
    return String(param).split('/').map(encoder).join('/');
  }

  return encoder(String(param));
};
var decodeParam = function decodeParam(param, encoding) {
  return (decodingMethods[encoding] || decodeURIComponent)(param);
};

var defaultOrConstrained = function defaultOrConstrained(match) {
  return '(' + (match ? match.replace(/(^<|>$)/g, '') : "[a-zA-Z0-9-_.~%':|=+\\*@$]+") + ')';
};
var rules = [{
  name: 'url-parameter',
  pattern: /^:([a-zA-Z0-9-_]*[a-zA-Z0-9]{1})(<(.+?)>)?/,
  regex: function regex(match) {
    return new RegExp(defaultOrConstrained(match[2]));
  }
}, {
  name: 'url-parameter-splat',
  pattern: /^\*([a-zA-Z0-9-_]*[a-zA-Z0-9]{1})/,
  regex: /([^?]*)/
}, {
  name: 'url-parameter-matrix',
  pattern: /^;([a-zA-Z0-9-_]*[a-zA-Z0-9]{1})(<(.+?)>)?/,
  regex: function regex(match) {
    return new RegExp(';' + match[1] + '=' + defaultOrConstrained(match[2]));
  }
}, {
  name: 'query-parameter',
  pattern: /^(?:\?|&)(?::)?([a-zA-Z0-9-_]*[a-zA-Z0-9]{1})/
}, {
  name: 'delimiter',
  pattern: /^(\/|\?)/,
  regex: function regex(match) {
    return new RegExp('\\' + match[0]);
  }
}, {
  name: 'sub-delimiter',
  pattern: /^(!|&|-|_|\.|;)/,
  regex: function regex(match) {
    return new RegExp(match[0]);
  }
}, {
  name: 'fragment',
  pattern: /^([0-9a-zA-Z]+)/,
  regex: function regex(match) {
    return new RegExp(match[0]);
  }
}];

var tokenise = function tokenise(str, tokens) {
  if (tokens === void 0) {
    tokens = [];
  } // Look for a matching rule


  var matched = rules.some(function (rule) {
    var match = str.match(rule.pattern);

    if (!match) {
      return false;
    }

    tokens.push({
      type: rule.name,
      match: match[0],
      val: match.slice(1, 2),
      otherVal: match.slice(2),
      regex: rule.regex instanceof Function ? rule.regex(match) : rule.regex
    });

    if (match[0].length < str.length) {
      tokens = tokenise(str.substr(match[0].length), tokens);
    }

    return true;
  }); // If no rules matched, throw an error (possible malformed path)

  if (!matched) {
    throw new Error("Could not parse path '" + str + "'");
  }

  return tokens;
};

var exists$1 = function exists(val) {
  return val !== undefined && val !== null;
};

var optTrailingSlash = function optTrailingSlash(source, strictTrailingSlash) {
  if (strictTrailingSlash) {
    return source;
  }

  if (source === '\\/') {
    return source;
  }

  return source.replace(/\\\/$/, '') + '(?:\\/)?';
};

var upToDelimiter = function upToDelimiter(source, delimiter) {
  if (!delimiter) {
    return source;
  }

  return /(\/)$/.test(source) ? source : source + '(\\/|\\?|\\.|;|$)';
};

var appendQueryParam = function appendQueryParam(params, param, val) {
  if (val === void 0) {
    val = '';
  }

  var existingVal = params[param];

  if (existingVal === undefined) {
    params[param] = val;
  } else {
    params[param] = Array.isArray(existingVal) ? existingVal.concat(val) : [existingVal, val];
  }

  return params;
};

var defaultOptions$2 = {
  urlParamsEncoding: 'default'
};

var Path$1 =
/*#__PURE__*/

/** @class */
function () {
  function Path(path, options) {
    if (!path) {
      throw new Error('Missing path in Path constructor');
    }

    this.path = path;
    this.options = __assign$2(__assign$2({}, defaultOptions$2), options);
    this.tokens = tokenise(path);
    this.hasUrlParams = this.tokens.filter(function (t) {
      return /^url-parameter/.test(t.type);
    }).length > 0;
    this.hasSpatParam = this.tokens.filter(function (t) {
      return /splat$/.test(t.type);
    }).length > 0;
    this.hasMatrixParams = this.tokens.filter(function (t) {
      return /matrix$/.test(t.type);
    }).length > 0;
    this.hasQueryParams = this.tokens.filter(function (t) {
      return /^query-parameter/.test(t.type);
    }).length > 0; // Extract named parameters from tokens

    this.spatParams = this.getParams('url-parameter-splat');
    this.urlParams = this.getParams(/^url-parameter/); // Query params

    this.queryParams = this.getParams('query-parameter'); // All params

    this.params = this.urlParams.concat(this.queryParams); // Check if hasQueryParams
    // Regular expressions for url part only (full and partial match)

    this.source = this.tokens.filter(function (t) {
      return t.regex !== undefined;
    }).map(function (t) {
      return t.regex.source;
    }).join('');
  }

  Path.createPath = function (path, options) {
    return new Path(path, options);
  };

  Path.prototype.isQueryParam = function (name) {
    return this.queryParams.indexOf(name) !== -1;
  };

  Path.prototype.isSpatParam = function (name) {
    return this.spatParams.indexOf(name) !== -1;
  };

  Path.prototype.test = function (path, opts) {
    var _this = this;

    var options = __assign$2(__assign$2({
      caseSensitive: false,
      strictTrailingSlash: false
    }, this.options), opts); // trailingSlash: falsy => non optional, truthy => optional


    var source = optTrailingSlash(this.source, options.strictTrailingSlash); // Check if exact match

    var match = this.urlTest(path, source + (this.hasQueryParams ? '(\\?.*$|$)' : '$'), options.caseSensitive, options.urlParamsEncoding); // If no match, or no query params, no need to go further

    if (!match || !this.hasQueryParams) {
      return match;
    } // Extract query params


    var queryParams = parse(path, options.queryParams);
    var unexpectedQueryParams = Object.keys(queryParams).filter(function (p) {
      return !_this.isQueryParam(p);
    });

    if (unexpectedQueryParams.length === 0) {
      // Extend url match
      Object.keys(queryParams).forEach( // @ts-ignore
      function (p) {
        return match[p] = queryParams[p];
      });
      return match;
    }

    return null;
  };

  Path.prototype.partialTest = function (path, opts) {
    var _this = this;

    var options = __assign$2(__assign$2({
      caseSensitive: false,
      delimited: true
    }, this.options), opts); // Check if partial match (start of given path matches regex)
    // trailingSlash: falsy => non optional, truthy => optional


    var source = upToDelimiter(this.source, options.delimited);
    var match = this.urlTest(path, source, options.caseSensitive, options.urlParamsEncoding);

    if (!match) {
      return match;
    }

    if (!this.hasQueryParams) {
      return match;
    }

    var queryParams = parse(path, options.queryParams);
    Object.keys(queryParams).filter(function (p) {
      return _this.isQueryParam(p);
    }).forEach(function (p) {
      return appendQueryParam(match, p, queryParams[p]);
    });
    return match;
  };

  Path.prototype.build = function (params, opts) {
    var _this = this;

    if (params === void 0) {
      params = {};
    }

    var options = __assign$2(__assign$2({
      ignoreConstraints: false,
      ignoreSearch: false,
      queryParams: {}
    }, this.options), opts);

    var encodedUrlParams = Object.keys(params).filter(function (p) {
      return !_this.isQueryParam(p);
    }).reduce(function (acc, key) {
      if (!exists$1(params[key])) {
        return acc;
      }

      var val = params[key];

      var isSpatParam = _this.isSpatParam(key);

      if (typeof val === 'boolean') {
        acc[key] = val;
      } else if (Array.isArray(val)) {
        acc[key] = val.map(function (v) {
          return encodeParam(v, options.urlParamsEncoding, isSpatParam);
        });
      } else {
        acc[key] = encodeParam(val, options.urlParamsEncoding, isSpatParam);
      }

      return acc;
    }, {}); // Check all params are provided (not search parameters which are optional)

    if (this.urlParams.some(function (p) {
      return !exists$1(params[p]);
    })) {
      var missingParameters = this.urlParams.filter(function (p) {
        return !exists$1(params[p]);
      });
      throw new Error("Cannot build path: '" + this.path + "' requires missing parameters { " + missingParameters.join(', ') + ' }');
    } // Check constraints


    if (!options.ignoreConstraints) {
      var constraintsPassed = this.tokens.filter(function (t) {
        return /^url-parameter/.test(t.type) && !/-splat$/.test(t.type);
      }).every(function (t) {
        return new RegExp('^' + defaultOrConstrained(t.otherVal[0]) + '$').test(encodedUrlParams[t.val]);
      });

      if (!constraintsPassed) {
        throw new Error("Some parameters of '" + this.path + "' are of invalid format");
      }
    }

    var base = this.tokens.filter(function (t) {
      return /^query-parameter/.test(t.type) === false;
    }).map(function (t) {
      if (t.type === 'url-parameter-matrix') {
        return ";" + t.val + "=" + encodedUrlParams[t.val[0]];
      }

      return /^url-parameter/.test(t.type) ? encodedUrlParams[t.val[0]] : t.match;
    }).join('');

    if (options.ignoreSearch) {
      return base;
    }

    var searchParams = this.queryParams.filter(function (p) {
      return Object.keys(params).indexOf(p) !== -1;
    }).reduce(function (sparams, paramName) {
      sparams[paramName] = params[paramName];
      return sparams;
    }, {});
    var searchPart = build(searchParams, options.queryParams);
    return searchPart ? base + '?' + searchPart : base;
  };

  Path.prototype.getParams = function (type) {
    var predicate = type instanceof RegExp ? function (t) {
      return type.test(t.type);
    } : function (t) {
      return t.type === type;
    };
    return this.tokens.filter(predicate).map(function (t) {
      return t.val[0];
    });
  };

  Path.prototype.urlTest = function (path, source, caseSensitive, urlParamsEncoding) {
    var _this = this;

    var regex = new RegExp('^' + source, caseSensitive ? '' : 'i');
    var match = path.match(regex);

    if (!match) {
      return null;
    } else if (!this.urlParams.length) {
      return {};
    } // Reduce named params to key-value pairs


    return match.slice(1, this.urlParams.length + 1).reduce(function (params, m, i) {
      params[_this.urlParams[i]] = decodeParam(m, urlParamsEncoding);
      return params;
    }, {});
  };

  return Path;
}();var getMetaFromSegments = function getMetaFromSegments(segments) {
  var accName = '';
  return segments.reduce(function (meta, segment) {
    var _a, _b, _c, _d;

    var urlParams = (_b = (_a = segment.parser) === null || _a === void 0 ? void 0 : _a.urlParams.reduce(function (params, p) {
      params[p] = 'url';
      return params;
    }, {}), _b !== null && _b !== void 0 ? _b : {});
    var allParams = (_d = (_c = segment.parser) === null || _c === void 0 ? void 0 : _c.queryParams.reduce(function (params, p) {
      params[p] = 'query';
      return params;
    }, urlParams), _d !== null && _d !== void 0 ? _d : {});

    if (segment.name !== undefined) {
      accName = accName ? accName + '.' + segment.name : segment.name;
      meta[accName] = allParams;
    }

    return meta;
  }, {});
};
var buildStateFromMatch = function buildStateFromMatch(match) {
  if (!match || !match.segments || !match.segments.length) {
    return null;
  }

  var name = match.segments.map(function (segment) {
    return segment.name;
  }).filter(function (name) {
    return name;
  }).join('.');
  var params = match.params;
  return {
    name: name,
    params: params,
    meta: getMetaFromSegments(match.segments)
  };
};
var buildPathFromSegments = function buildPathFromSegments(segments, params, options) {
  if (params === void 0) {
    params = {};
  }

  if (options === void 0) {
    options = {};
  }

  var _a = options.queryParamsMode,
      queryParamsMode = _a === void 0 ? 'default' : _a,
      _b = options.trailingSlashMode,
      trailingSlashMode = _b === void 0 ? 'default' : _b;
  var searchParams = [];
  var nonSearchParams = [];

  for (var _i = 0, segments_1 = segments; _i < segments_1.length; _i++) {
    var segment = segments_1[_i];
    var parser = segment.parser;

    if (parser) {
      searchParams.push.apply(searchParams, parser.queryParams);
      nonSearchParams.push.apply(nonSearchParams, parser.urlParams);
      nonSearchParams.push.apply(nonSearchParams, parser.spatParams);
    }
  }

  if (queryParamsMode === 'loose') {
    var extraParams = Object.keys(params).reduce(function (acc, p) {
      return searchParams.indexOf(p) === -1 && nonSearchParams.indexOf(p) === -1 ? acc.concat(p) : acc;
    }, []);
    searchParams.push.apply(searchParams, extraParams);
  }

  var searchParamsObject = searchParams.reduce(function (acc, paramName) {
    if (Object.keys(params).indexOf(paramName) !== -1) {
      acc[paramName] = params[paramName];
    }

    return acc;
  }, {});
  var searchPart = build(searchParamsObject, options.queryParams);
  var path = segments.reduce(function (path, segment) {
    var _a, _b;

    var segmentPath = (_b = (_a = segment.parser) === null || _a === void 0 ? void 0 : _a.build(params, {
      ignoreSearch: true,
      queryParams: options.queryParams,
      urlParamsEncoding: options.urlParamsEncoding
    }), _b !== null && _b !== void 0 ? _b : '');
    return segment.absolute ? segmentPath : path + segmentPath;
  }, '') // remove repeated slashes
  .replace(/\/\/{1,}/g, '/');
  var finalPath = path;

  if (trailingSlashMode === 'always') {
    finalPath = /\/$/.test(path) ? path : path + "/";
  } else if (trailingSlashMode === 'never' && path !== '/') {
    finalPath = /\/$/.test(path) ? path.slice(0, -1) : path;
  }

  return finalPath + (searchPart ? '?' + searchPart : '');
};
var getPathFromSegments = function getPathFromSegments(segments) {
  return segments ? segments.map(function (segment) {
    return segment.path;
  }).join('') : null;
};

var getPath = function getPath(path) {
  return path.split('?')[0];
};

var getSearch = function getSearch(path) {
  return path.split('?')[1] || '';
};

var matchChildren = function matchChildren(nodes, pathSegment, currentMatch, options, consumedBefore) {
  if (options === void 0) {
    options = {};
  }

  var _a = options.queryParamsMode,
      queryParamsMode = _a === void 0 ? 'default' : _a,
      _b = options.strictTrailingSlash,
      strictTrailingSlash = _b === void 0 ? false : _b,
      _c = options.strongMatching,
      strongMatching = _c === void 0 ? true : _c,
      _d = options.caseSensitive,
      caseSensitive = _d === void 0 ? false : _d;
  var isRoot = nodes.length === 1 && nodes[0].name === '';

  var _loop_1 = function _loop_1(child) {
    // Partially match path
    var match = null;
    var remainingPath = void 0;
    var segment = pathSegment;

    if (consumedBefore === '/' && child.path === '/') {
      // when we encounter repeating slashes we add the slash
      // back to the URL to make it de facto pathless
      segment = '/' + pathSegment;
    }

    if (!child.children.length) {
      match = child.parser.test(segment, {
        caseSensitive: caseSensitive,
        strictTrailingSlash: strictTrailingSlash,
        queryParams: options.queryParams,
        urlParamsEncoding: options.urlParamsEncoding
      });
    }

    if (!match) {
      match = child.parser.partialTest(segment, {
        delimited: strongMatching,
        caseSensitive: caseSensitive,
        queryParams: options.queryParams,
        urlParamsEncoding: options.urlParamsEncoding
      });
    }

    if (match) {
      // Remove consumed segment from path
      var consumedPath = child.parser.build(match, {
        ignoreSearch: true,
        urlParamsEncoding: options.urlParamsEncoding
      });

      if (!strictTrailingSlash && !child.children.length) {
        consumedPath = consumedPath.replace(/\/$/, '');
      } // Can't create a regexp from the path because it might contain a
      // regexp character.


      if (segment.toLowerCase().indexOf(consumedPath.toLowerCase()) === 0) {
        remainingPath = segment.slice(consumedPath.length);
      } else {
        remainingPath = segment;
      }

      if (!strictTrailingSlash && !child.children.length) {
        remainingPath = remainingPath.replace(/^\/\?/, '?');
      }

      var querystring = omit(getSearch(segment.replace(consumedPath, '')), child.parser.queryParams, options.queryParams).querystring;
      remainingPath = getPath(remainingPath) + (querystring ? "?" + querystring : '');

      if (!strictTrailingSlash && !isRoot && remainingPath === '/' && !/\/$/.test(consumedPath)) {
        remainingPath = '';
      }

      currentMatch.segments.push(child);
      Object.keys(match).forEach(function (param) {
        return currentMatch.params[param] = match[param];
      });

      if (!isRoot && !remainingPath.length) {
        return {
          value: currentMatch
        };
      }

      if (!isRoot && queryParamsMode !== 'strict' && remainingPath.indexOf('?') === 0) {
        // unmatched queryParams in non strict mode
        var remainingQueryParams_1 = parse(remainingPath.slice(1), options.queryParams);
        Object.keys(remainingQueryParams_1).forEach(function (name) {
          return currentMatch.params[name] = remainingQueryParams_1[name];
        });
        return {
          value: currentMatch
        };
      } // Continue matching on non absolute children


      var children = child.getNonAbsoluteChildren(); // If no children to match against but unmatched path left

      if (!children.length) {
        return {
          value: null
        };
      }

      return {
        value: matchChildren(children, remainingPath, currentMatch, options, consumedPath)
      };
    }
  }; // for (child of node.children) {


  for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {
    var child = nodes_1[_i];

    var state_1 = _loop_1(child);

    if (typeof state_1 === "object") return state_1.value;
  }

  return null;
};

function sortChildren(children) {
  var originalChildren = children.slice(0);
  return children.sort(sortPredicate(originalChildren));
}

var sortPredicate = function sortPredicate(originalChildren) {
  return function (left, right) {
    var _a, _b, _c, _d, _e, _f;

    var leftPath = left.path.replace(/<.*?>/g, '').split('?')[0].replace(/(.+)\/$/, '$1');
    var rightPath = right.path.replace(/<.*?>/g, '').split('?')[0].replace(/(.+)\/$/, '$1'); // '/' last

    if (leftPath === '/') {
      return 1;
    }

    if (rightPath === '/') {
      return -1;
    } // Spat params last


    if ((_a = left.parser) === null || _a === void 0 ? void 0 : _a.hasSpatParam) {
      return 1;
    }

    if ((_b = right.parser) === null || _b === void 0 ? void 0 : _b.hasSpatParam) {
      return -1;
    } // No spat, number of segments (less segments last)


    var leftSegments = (leftPath.match(/\//g) || []).length;
    var rightSegments = (rightPath.match(/\//g) || []).length;

    if (leftSegments < rightSegments) {
      return 1;
    }

    if (leftSegments > rightSegments) {
      return -1;
    } // Same number of segments, number of URL params ascending


    var leftParamsCount = (_d = (_c = left.parser) === null || _c === void 0 ? void 0 : _c.urlParams.length, _d !== null && _d !== void 0 ? _d : 0);
    var rightParamsCount = (_f = (_e = right.parser) === null || _e === void 0 ? void 0 : _e.urlParams.length, _f !== null && _f !== void 0 ? _f : 0);

    if (leftParamsCount < rightParamsCount) {
      return -1;
    }

    if (leftParamsCount > rightParamsCount) {
      return 1;
    } // Same number of segments and params, last segment length descending


    var leftParamLength = (leftPath.split('/').slice(-1)[0] || '').length;
    var rightParamLength = (rightPath.split('/').slice(-1)[0] || '').length;

    if (leftParamLength < rightParamLength) {
      return 1;
    }

    if (leftParamLength > rightParamLength) {
      return -1;
    } // Same last segment length, preserve definition order. Note that we
    // cannot just return 0, as sort is not guaranteed to be a stable sort.


    return originalChildren.indexOf(left) - originalChildren.indexOf(right);
  };
};

var RouteNode =
/*#__PURE__*/

/** @class */
function () {
  function RouteNode(name, path, childRoutes, options) {
    if (name === void 0) {
      name = '';
    }

    if (path === void 0) {
      path = '';
    }

    if (childRoutes === void 0) {
      childRoutes = [];
    }

    if (options === void 0) {
      options = {};
    }

    this.name = name;
    this.absolute = /^~/.test(path);
    this.path = this.absolute ? path.slice(1) : path;
    this.parser = this.path ? new Path$1(this.path) : null;
    this.children = [];
    this.parent = options.parent;
    this.checkParents();
    this.add(childRoutes, options.onAdd, options.finalSort ? false : options.sort !== false);

    if (options.finalSort) {
      this.sortDescendants();
    }

    return this;
  }

  RouteNode.prototype.getParentSegments = function (segments) {
    if (segments === void 0) {
      segments = [];
    }

    return this.parent && this.parent.parser ? this.parent.getParentSegments(segments.concat(this.parent)) : segments.reverse();
  };

  RouteNode.prototype.setParent = function (parent) {
    this.parent = parent;
    this.checkParents();
  };

  RouteNode.prototype.setPath = function (path) {
    if (path === void 0) {
      path = '';
    }

    this.path = path;
    this.parser = path ? new Path$1(path) : null;
  };

  RouteNode.prototype.add = function (route, cb, sort) {
    var _this = this;

    if (sort === void 0) {
      sort = true;
    }

    if (route === undefined || route === null) {
      return this;
    }

    if (route instanceof Array) {
      route.forEach(function (r) {
        return _this.add(r, cb, sort);
      });
      return this;
    }

    if (!(route instanceof RouteNode) && !(route instanceof Object)) {
      throw new Error('RouteNode.add() expects routes to be an Object or an instance of RouteNode.');
    } else if (route instanceof RouteNode) {
      route.setParent(this);
      this.addRouteNode(route, sort);
    } else {
      if (!route.name || !route.path) {
        throw new Error('RouteNode.add() expects routes to have a name and a path defined.');
      }

      var routeNode = new RouteNode(route.name, route.path, route.children, {
        finalSort: false,
        onAdd: cb,
        parent: this,
        sort: sort
      });
      var fullName = routeNode.getParentSegments([routeNode]).map(function (_) {
        return _.name;
      }).join('.');

      if (cb) {
        cb(__assign$3(__assign$3({}, route), {
          name: fullName
        }));
      }

      this.addRouteNode(routeNode, sort);
    }

    return this;
  };

  RouteNode.prototype.addNode = function (name, path) {
    this.add(new RouteNode(name, path));
    return this;
  };

  RouteNode.prototype.getPath = function (routeName) {
    var segmentsByName = this.getSegmentsByName(routeName);
    return segmentsByName ? getPathFromSegments(segmentsByName) : null;
  };

  RouteNode.prototype.getNonAbsoluteChildren = function () {
    return this.children.filter(function (child) {
      return !child.absolute;
    });
  };

  RouteNode.prototype.sortChildren = function () {
    if (this.children.length) {
      sortChildren(this.children);
    }
  };

  RouteNode.prototype.sortDescendants = function () {
    this.sortChildren();
    this.children.forEach(function (child) {
      return child.sortDescendants();
    });
  };

  RouteNode.prototype.buildPath = function (routeName, params, options) {
    if (params === void 0) {
      params = {};
    }

    if (options === void 0) {
      options = {};
    }

    var segments = this.getSegmentsByName(routeName);

    if (!segments) {
      throw new Error("[route-node][buildPath] '{routeName}' is not defined");
    }

    return buildPathFromSegments(segments, params, options);
  };

  RouteNode.prototype.buildState = function (name, params) {
    if (params === void 0) {
      params = {};
    }

    var segments = this.getSegmentsByName(name);

    if (!segments || !segments.length) {
      return null;
    }

    return {
      name: name,
      params: params,
      meta: getMetaFromSegments(segments)
    };
  };

  RouteNode.prototype.matchPath = function (path, options) {
    if (options === void 0) {
      options = {};
    }

    if (path === '' && !options.strictTrailingSlash) {
      path = '/';
    }

    var match = this.getSegmentsMatchingPath(path, options);

    if (!match) {
      return null;
    }

    var matchedSegments = match.segments;

    if (matchedSegments[0].absolute) {
      var firstSegmentParams = matchedSegments[0].getParentSegments();
      matchedSegments.reverse();
      matchedSegments.push.apply(matchedSegments, firstSegmentParams);
      matchedSegments.reverse();
    }

    var lastSegment = matchedSegments[matchedSegments.length - 1];
    var lastSegmentSlashChild = lastSegment.findSlashChild();

    if (lastSegmentSlashChild) {
      matchedSegments.push(lastSegmentSlashChild);
    }

    return buildStateFromMatch(match);
  };

  RouteNode.prototype.addRouteNode = function (route, sort) {
    if (sort === void 0) {
      sort = true;
    }

    var names = route.name.split('.');

    if (names.length === 1) {
      // Check duplicated routes
      if (this.children.map(function (child) {
        return child.name;
      }).indexOf(route.name) !== -1) {
        throw new Error("Alias \"" + route.name + "\" is already defined in route node");
      } // Check duplicated paths


      if (this.children.map(function (child) {
        return child.path;
      }).indexOf(route.path) !== -1) {
        throw new Error("Path \"" + route.path + "\" is already defined in route node");
      }

      this.children.push(route);

      if (sort) {
        this.sortChildren();
      }
    } else {
      // Locate parent node
      var segments = this.getSegmentsByName(names.slice(0, -1).join('.'));

      if (segments) {
        route.name = names[names.length - 1];
        segments[segments.length - 1].add(route);
      } else {
        throw new Error("Could not add route named '" + route.name + "', parent is missing.");
      }
    }

    return this;
  };

  RouteNode.prototype.checkParents = function () {
    if (this.absolute && this.hasParentsParams()) {
      throw new Error('[RouteNode] A RouteNode with an abolute path cannot have parents with route parameters');
    }
  };

  RouteNode.prototype.hasParentsParams = function () {
    if (this.parent && this.parent.parser) {
      var parser = this.parent.parser;
      var hasParams = parser.hasUrlParams || parser.hasSpatParam || parser.hasMatrixParams || parser.hasQueryParams;
      return hasParams || this.parent.hasParentsParams();
    }

    return false;
  };

  RouteNode.prototype.findAbsoluteChildren = function () {
    return this.children.reduce(function (absoluteChildren, child) {
      return absoluteChildren.concat(child.absolute ? child : []).concat(child.findAbsoluteChildren());
    }, []);
  };

  RouteNode.prototype.findSlashChild = function () {
    var slashChildren = this.getNonAbsoluteChildren().filter(function (child) {
      return child.parser && /^\/(\?|$)/.test(child.parser.path);
    });
    return slashChildren[0];
  };

  RouteNode.prototype.getSegmentsByName = function (routeName) {
    var findSegmentByName = function findSegmentByName(name, routes) {
      var filteredRoutes = routes.filter(function (r) {
        return r.name === name;
      });
      return filteredRoutes.length ? filteredRoutes[0] : undefined;
    };

    var segments = [];
    var routes = this.parser ? [this] : this.children;
    var names = (this.parser ? [''] : []).concat(routeName.split('.'));
    var matched = names.every(function (name) {
      var segment = findSegmentByName(name, routes);

      if (segment) {
        routes = segment.children;
        segments.push(segment);
        return true;
      }

      return false;
    });
    return matched ? segments : null;
  };

  RouteNode.prototype.getSegmentsMatchingPath = function (path, options) {
    var topLevelNodes = this.parser ? [this] : this.children;
    var startingNodes = topLevelNodes.reduce(function (nodes, node) {
      return nodes.concat(node, node.findAbsoluteChildren());
    }, []);
    var currentMatch = {
      segments: [],
      params: {}
    };
    var finalMatch = matchChildren(startingNodes, path, currentMatch, options);

    if (finalMatch && finalMatch.segments.length === 1 && finalMatch.segments[0].name === '') {
      return null;
    }

    return finalMatch;
  };

  return RouteNode;
}();function symbolObservablePonyfill(root) {
	var result;
	var Symbol = root.Symbol;

	if (typeof Symbol === 'function') {
		if (Symbol.observable) {
			result = Symbol.observable;
		} else {
			result = Symbol('observable');
			Symbol.observable = result;
		}
	} else {
		result = '@@observable';
	}

	return result;
}/* global window */

var root;

if (typeof self !== 'undefined') {
  root = self;
} else if (typeof window !== 'undefined') {
  root = window;
} else if (typeof global !== 'undefined') {
  root = global;
} else if (typeof module !== 'undefined') {
  root = module;
} else {
  root = Function('return this')();
}

var result = symbolObservablePonyfill(root);var nameToIDs = function (name) {
    return name
        .split('.')
        .reduce(function (ids, name) {
        return ids.concat(ids.length ? ids[ids.length - 1] + '.' + name : name);
    }, []);
};
var exists = function (val) { return val !== undefined && val !== null; };
var hasMetaParams = function (state) { return state && state.meta && state.meta.params; };
var extractSegmentParams = function (name, state) {
    if (!hasMetaParams(state) || !exists(state.meta.params[name]))
        return {};
    return Object.keys(state.meta.params[name]).reduce(function (params, p) {
        params[p] = state.params[p];
        return params;
    }, {});
};
function transitionPath(toState, fromState) {
    var toStateOptions = (toState.meta && toState.meta && toState.meta.options) || {};
    var fromStateIds = fromState ? nameToIDs(fromState.name) : [];
    var toStateIds = nameToIDs(toState.name);
    var maxI = Math.min(fromStateIds.length, toStateIds.length);
    function pointOfDifference() {
        var i;
        var _loop_1 = function () {
            var left = fromStateIds[i];
            var right = toStateIds[i];
            if (left !== right)
                return { value: i };
            var leftParams = extractSegmentParams(left, toState);
            var rightParams = extractSegmentParams(right, fromState);
            if (Object.keys(leftParams).length !==
                Object.keys(rightParams).length)
                return { value: i };
            if (Object.keys(leftParams).length === 0)
                return "continue";
            var different = Object.keys(leftParams).some(function (p) { return rightParams[p] !== leftParams[p]; });
            if (different) {
                return { value: i };
            }
        };
        for (i = 0; i < maxI; i += 1) {
            var state_1 = _loop_1();
            if (typeof state_1 === "object")
                return state_1.value;
        }
        return i;
    }
    var i;
    if (!fromState || toStateOptions.reload) {
        i = 0;
    }
    else if (!hasMetaParams(fromState) && !hasMetaParams(toState)) {
        i = 0;
    }
    else {
        i = pointOfDifference();
    }
    var toDeactivate = fromStateIds.slice(i).reverse();
    var toActivate = toStateIds.slice(i);
    var intersection = fromState && i > 0 ? fromStateIds[i - 1] : '';
    return {
        intersection: intersection,
        toDeactivate: toDeactivate,
        toActivate: toActivate
    };
}/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

var __assign$1 = function() {
    __assign$1 = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign$1.apply(this, arguments);
};

var defaultOptions$1 = {
    trailingSlashMode: 'default',
    queryParamsMode: 'default',
    strictTrailingSlash: false,
    autoCleanUp: true,
    allowNotFound: false,
    strongMatching: true,
    rewritePathOnMatch: true,
    caseSensitive: false,
    urlParamsEncoding: 'default'
};
function withOptions(options) {
    return function (router) {
        var routerOptions = __assign$1(__assign$1({}, defaultOptions$1), options);
        router.getOptions = function () { return routerOptions; };
        router.setOption = function (option, value) {
            routerOptions[option] = value;
            return router;
        };
        return router;
    };
}

var errorCodes = {
    ROUTER_NOT_STARTED: 'NOT_STARTED',
    NO_START_PATH_OR_STATE: 'NO_START_PATH_OR_STATE',
    ROUTER_ALREADY_STARTED: 'ALREADY_STARTED',
    ROUTE_NOT_FOUND: 'ROUTE_NOT_FOUND',
    SAME_STATES: 'SAME_STATES',
    CANNOT_DEACTIVATE: 'CANNOT_DEACTIVATE',
    CANNOT_ACTIVATE: 'CANNOT_ACTIVATE',
    TRANSITION_ERR: 'TRANSITION_ERR',
    TRANSITION_CANCELLED: 'CANCELLED'
};
var constants = {
    UNKNOWN_ROUTE: '@@router5/UNKNOWN_ROUTE',
    ROUTER_START: '$start',
    ROUTER_STOP: '$stop',
    TRANSITION_START: '$$start',
    TRANSITION_CANCEL: '$$cancel',
    TRANSITION_SUCCESS: '$$success',
    TRANSITION_ERROR: '$$error'
};

function withRoutes(routes) {
    return function (router) {
        router.forward = function (fromRoute, toRoute) {
            router.config.forwardMap[fromRoute] = toRoute;
            return router;
        };
        var rootNode = routes instanceof RouteNode
            ? routes
            : new RouteNode('', '', routes, { onAdd: onRouteAdded });
        function onRouteAdded(route) {
            if (route.canActivate)
                router.canActivate(route.name, route.canActivate);
            if (route.forwardTo)
                router.forward(route.name, route.forwardTo);
            if (route.decodeParams)
                router.config.decoders[route.name] = route.decodeParams;
            if (route.encodeParams)
                router.config.encoders[route.name] = route.encodeParams;
            if (route.defaultParams)
                router.config.defaultParams[route.name] = route.defaultParams;
        }
        router.rootNode = rootNode;
        router.add = function (routes, finalSort) {
            rootNode.add(routes, onRouteAdded, !finalSort);
            if (finalSort) {
                rootNode.sortDescendants();
            }
            return router;
        };
        router.addNode = function (name, path, canActivateHandler) {
            rootNode.addNode(name, path);
            if (canActivateHandler)
                router.canActivate(name, canActivateHandler);
            return router;
        };
        router.isActive = function (name, params, strictEquality, ignoreQueryParams) {
            if (params === void 0) { params = {}; }
            if (strictEquality === void 0) { strictEquality = false; }
            if (ignoreQueryParams === void 0) { ignoreQueryParams = true; }
            var activeState = router.getState();
            if (!activeState)
                return false;
            if (strictEquality || activeState.name === name) {
                return router.areStatesEqual(router.makeState(name, params), activeState, ignoreQueryParams);
            }
            return router.areStatesDescendants(router.makeState(name, params), activeState);
        };
        router.buildPath = function (route, params) {
            if (route === constants.UNKNOWN_ROUTE) {
                return params.path;
            }
            var paramsWithDefault = __assign$1(__assign$1({}, router.config.defaultParams[route]), params);
            var _a = router.getOptions(), trailingSlashMode = _a.trailingSlashMode, queryParamsMode = _a.queryParamsMode, queryParams = _a.queryParams;
            var encodedParams = router.config.encoders[route]
                ? router.config.encoders[route](paramsWithDefault)
                : paramsWithDefault;
            return router.rootNode.buildPath(route, encodedParams, {
                trailingSlashMode: trailingSlashMode,
                queryParamsMode: queryParamsMode,
                queryParams: queryParams,
                urlParamsEncoding: router.getOptions().urlParamsEncoding
            });
        };
        router.matchPath = function (path, source) {
            var options = router.getOptions();
            var match = router.rootNode.matchPath(path, options);
            if (match) {
                var name_1 = match.name, params = match.params, meta = match.meta;
                var decodedParams = router.config.decoders[name_1]
                    ? router.config.decoders[name_1](params)
                    : params;
                var _a = router.forwardState(name_1, decodedParams), routeName = _a.name, routeParams = _a.params;
                var builtPath = options.rewritePathOnMatch === false
                    ? path
                    : router.buildPath(routeName, routeParams);
                return router.makeState(routeName, routeParams, builtPath, {
                    params: meta,
                    source: source
                });
            }
            return null;
        };
        router.setRootPath = function (rootPath) {
            router.rootNode.setPath(rootPath);
        };
        return router;
    };
}

function withDependencies(dependencies) {
    return function (router) {
        var routerDependencies = dependencies;
        router.setDependency = function (dependencyName, dependency) {
            routerDependencies[dependencyName] = dependency;
            return router;
        };
        router.setDependencies = function (deps) {
            Object.keys(deps).forEach(function (name) {
                return router.setDependency(name, deps[name]);
            });
            return router;
        };
        router.getDependencies = function () { return routerDependencies; };
        router.getInjectables = function () { return [router, router.getDependencies()]; };
        router.executeFactory = function (factoryFunction) {
            return factoryFunction.apply(void 0, router.getInjectables());
        };
        return router;
    };
}

function withState(router) {
    var stateId = 0;
    var routerState = null;
    router.getState = function () { return routerState; };
    router.setState = function (state) {
        routerState = state;
    };
    router.makeState = function (name, params, path, meta, forceId) { return ({
        name: name,
        params: __assign$1(__assign$1({}, router.config.defaultParams[name]), params),
        path: path,
        meta: meta
            ? __assign$1(__assign$1({}, meta), { id: forceId === undefined ? ++stateId : forceId }) : undefined
    }); };
    router.makeNotFoundState = function (path, options) {
        return router.makeState(constants.UNKNOWN_ROUTE, { path: path }, path, {
            options: options
        });
    };
    router.areStatesEqual = function (state1, state2, ignoreQueryParams) {
        if (ignoreQueryParams === void 0) { ignoreQueryParams = true; }
        if (state1.name !== state2.name)
            return false;
        var getUrlParams = function (name) {
            return router.rootNode
                //@ts-ignore
                .getSegmentsByName(name)
                .map(function (segment) { return segment.parser['urlParams']; })
                .reduce(function (params, p) { return params.concat(p); }, []);
        };
        var state1Params = ignoreQueryParams
            ? getUrlParams(state1.name)
            : Object.keys(state1.params);
        var state2Params = ignoreQueryParams
            ? getUrlParams(state2.name)
            : Object.keys(state2.params);
        return (state1Params.length === state2Params.length &&
            state1Params.every(function (p) { return state1.params[p] === state2.params[p]; }));
    };
    router.areStatesDescendants = function (parentState, childState) {
        var regex = new RegExp('^' + parentState.name + '\\.(.*)$');
        if (!regex.test(childState.name))
            return false;
        // If child state name extends parent state name, and all parent state params
        // are in child state params.
        return Object.keys(parentState.params).every(function (p) { return parentState.params[p] === childState.params[p]; });
    };
    router.forwardState = function (routeName, routeParams) {
        var name = router.config.forwardMap[routeName] || routeName;
        var params = __assign$1(__assign$1(__assign$1({}, router.config.defaultParams[routeName]), router.config.defaultParams[name]), routeParams);
        return {
            name: name,
            params: params
        };
    };
    router.buildState = function (routeName, routeParams) {
        var _a = router.forwardState(routeName, routeParams), name = _a.name, params = _a.params;
        return router.rootNode.buildState(name, params);
    };
    return router;
}

var eventsMap = {
    onStart: constants.ROUTER_START,
    onStop: constants.ROUTER_STOP,
    onTransitionSuccess: constants.TRANSITION_SUCCESS,
    onTransitionStart: constants.TRANSITION_START,
    onTransitionError: constants.TRANSITION_ERROR,
    onTransitionCancel: constants.TRANSITION_CANCEL
};
function withPlugins(router) {
    var routerPlugins = [];
    router.getPlugins = function () { return routerPlugins; };
    router.usePlugin = function () {
        var plugins = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            plugins[_i] = arguments[_i];
        }
        var removePluginFns = plugins.map(function (plugin) {
            routerPlugins.push(plugin);
            return startPlugin(plugin);
        });
        return function () {
            routerPlugins = routerPlugins.filter(function (plugin) { return plugins.indexOf(plugin) === -1; });
            removePluginFns.forEach(function (removePlugin) { return removePlugin(); });
        };
    };
    function startPlugin(plugin) {
        var appliedPlugin = router.executeFactory(plugin);
        var removeEventListeners = Object.keys(eventsMap)
            .map(function (methodName) {
            if (appliedPlugin[methodName]) {
                return router.addEventListener(eventsMap[methodName], appliedPlugin[methodName]);
            }
        })
            .filter(Boolean);
        return function () {
            removeEventListeners.forEach(function (removeListener) { return removeListener(); });
            if (appliedPlugin.teardown) {
                appliedPlugin.teardown();
            }
        };
    }
    return router;
}

function withMiddleware(router) {
    var middlewareFactories = [];
    var middlewareFunctions = [];
    router.useMiddleware = function () {
        var middlewares = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            middlewares[_i] = arguments[_i];
        }
        var removePluginFns = middlewares.map(function (middleware) {
            var middlewareFunction = router.executeFactory(middleware);
            middlewareFactories.push(middleware);
            middlewareFunctions.push(middlewareFunction);
            return function () {
                middlewareFactories = middlewareFactories.filter(function (m) { return m !== middleware; });
                middlewareFunctions = middlewareFunctions.filter(function (m) { return m !== middlewareFunction; });
            };
        });
        return function () { return removePluginFns.forEach(function (fn) { return fn(); }); };
    };
    router.clearMiddleware = function () {
        middlewareFactories = [];
        middlewareFunctions = [];
        return router;
    };
    router.getMiddlewareFactories = function () { return middlewareFactories; };
    router.getMiddlewareFunctions = function () { return middlewareFunctions; };
    return router;
}

function withObservability(router) {
    var callbacks = {};
    router.invokeEventListeners = function (eventName) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        (callbacks[eventName] || []).forEach(function (cb) { return cb.apply(void 0, args); });
    };
    router.removeEventListener = function (eventName, cb) {
        callbacks[eventName] = callbacks[eventName].filter(function (_cb) { return _cb !== cb; });
    };
    router.addEventListener = function (eventName, cb) {
        callbacks[eventName] = (callbacks[eventName] || []).concat(cb);
        return function () { return router.removeEventListener(eventName, cb); };
    };
    function subscribe(listener) {
        var isObject = typeof listener === 'object';
        var finalListener = isObject ? listener.next.bind(listener) : listener;
        var unsubscribeHandler = router.addEventListener(constants.TRANSITION_SUCCESS, function (toState, fromState) {
            finalListener({
                route: toState,
                previousRoute: fromState
            });
        });
        return isObject
            ? { unsubscribe: unsubscribeHandler }
            : unsubscribeHandler;
    }
    function observable() {
        var _a;
        return _a = {
                subscribe: function (observer) {
                    if (typeof observer !== 'object' || observer === null) {
                        throw new TypeError('Expected the observer to be an object.');
                    }
                    return subscribe(observer);
                }
            },
            _a[result] = function () {
                return this;
            },
            _a;
    }
    router.subscribe = subscribe;
    //@ts-ignore
    router[result] = observable;
    //@ts-ignore
    router['@@observable'] = observable;
    return router;
}

function resolve(functions, _a, callback) {
    var isCancelled = _a.isCancelled, toState = _a.toState, fromState = _a.fromState, _b = _a.errorKey, errorKey = _b === void 0 ? undefined : _b;
    var remainingFunctions = Array.isArray(functions)
        ? functions
        : Object.keys(functions);
    var isState = function (obj) {
        return typeof obj === 'object' &&
            obj.name !== undefined &&
            obj.params !== undefined &&
            obj.path !== undefined;
    };
    var hasStateChanged = function (toState, fromState) {
        return fromState.name !== toState.name ||
            fromState.params !== toState.params ||
            fromState.path !== toState.path;
    };
    var mergeStates = function (toState, fromState) { return (__assign$1(__assign$1(__assign$1({}, fromState), toState), { meta: __assign$1(__assign$1({}, fromState.meta), toState.meta) })); };
    var processFn = function (stepFn, errBase, state, _done) {
        var done = function (err, newState) {
            if (err) {
                _done(err);
            }
            else if (newState && newState !== state && isState(newState)) {
                if (hasStateChanged(newState, state)) {
                    console.error('[router5][transition] Warning: state values (name, params, path) were changed during transition process.');
                }
                _done(null, mergeStates(newState, state));
            }
            else {
                _done(null, state);
            }
        };
        var res = stepFn.call(null, state, fromState, done);
        if (isCancelled()) {
            done(null);
        }
        else if (typeof res === 'boolean') {
            done(res ? null : errBase);
        }
        else if (isState(res)) {
            done(null, res);
        }
        else if (res && typeof res.then === 'function') {
            res.then(function (resVal) {
                if (resVal instanceof Error)
                    done({ error: resVal }, null);
                else
                    done(null, resVal);
            }, function (err) {
                if (err instanceof Error) {
                    console.error(err.stack || err);
                    done(__assign$1(__assign$1({}, errBase), { promiseError: err }), null);
                }
                else {
                    done(typeof err === 'object'
                        ? __assign$1(__assign$1({}, errBase), err) : errBase, null);
                }
            });
        }
        // else: wait for done to be called
    };
    var next = function (err, state) {
        var _a;
        if (isCancelled()) {
            callback();
        }
        else if (err) {
            callback(err);
        }
        else {
            if (!remainingFunctions.length) {
                callback(null, state);
            }
            else {
                var isMapped = typeof remainingFunctions[0] === 'string';
                var errBase = errorKey && isMapped
                    ? (_a = {}, _a[errorKey] = remainingFunctions[0], _a) : {};
                var stepFn = isMapped
                    ? functions[remainingFunctions[0]]
                    : remainingFunctions[0];
                remainingFunctions = remainingFunctions.slice(1);
                processFn(stepFn, errBase, state, next);
            }
        }
    };
    next(null, toState);
}

function transition(router, toState, fromState, opts, callback) {
    var cancelled = false;
    var completed = false;
    var options = router.getOptions();
    var _a = router.getLifecycleFunctions(), canDeactivateFunctions = _a[0], canActivateFunctions = _a[1];
    var middlewareFunctions = router.getMiddlewareFunctions();
    var isCancelled = function () { return cancelled; };
    var cancel = function () {
        if (!cancelled && !completed) {
            cancelled = true;
            callback({ code: errorCodes.TRANSITION_CANCELLED }, null);
        }
    };
    var done = function (err, state) {
        completed = true;
        if (isCancelled()) {
            return;
        }
        if (!err && options.autoCleanUp) {
            var activeSegments_1 = nameToIDs(toState.name);
            Object.keys(canDeactivateFunctions).forEach(function (name) {
                if (activeSegments_1.indexOf(name) === -1)
                    router.clearCanDeactivate(name);
            });
        }
        callback(err, state || toState);
    };
    var makeError = function (base, err) { return (__assign$1(__assign$1({}, base), (err instanceof Object ? err : { error: err }))); };
    var isUnknownRoute = toState.name === constants.UNKNOWN_ROUTE;
    var asyncBase = { isCancelled: isCancelled, toState: toState, fromState: fromState };
    var _b = transitionPath(toState, fromState), toDeactivate = _b.toDeactivate, toActivate = _b.toActivate;
    var canDeactivate = !fromState || opts.forceDeactivate
        ? []
        : function (toState, fromState, cb) {
            var canDeactivateFunctionMap = toDeactivate
                .filter(function (name) { return canDeactivateFunctions[name]; })
                .reduce(function (fnMap, name) {
                var _a;
                return (__assign$1(__assign$1({}, fnMap), (_a = {}, _a[name] = canDeactivateFunctions[name], _a)));
            }, {});
            resolve(canDeactivateFunctionMap, __assign$1(__assign$1({}, asyncBase), { errorKey: 'segment' }), function (err) {
                return cb(err
                    ? makeError({ code: errorCodes.CANNOT_DEACTIVATE }, err)
                    : null);
            });
        };
    var canActivate = isUnknownRoute
        ? []
        : function (toState, fromState, cb) {
            var canActivateFunctionMap = toActivate
                .filter(function (name) { return canActivateFunctions[name]; })
                .reduce(function (fnMap, name) {
                var _a;
                return (__assign$1(__assign$1({}, fnMap), (_a = {}, _a[name] = canActivateFunctions[name], _a)));
            }, {});
            resolve(canActivateFunctionMap, __assign$1(__assign$1({}, asyncBase), { errorKey: 'segment' }), function (err) {
                return cb(err
                    ? makeError({ code: errorCodes.CANNOT_ACTIVATE }, err)
                    : null);
            });
        };
    var middleware = !middlewareFunctions.length
        ? []
        : function (toState, fromState, cb) {
            return resolve(middlewareFunctions, __assign$1({}, asyncBase), function (err, state) {
                return cb(err
                    ? makeError({ code: errorCodes.TRANSITION_ERR }, err)
                    : null, state || toState);
            });
        };
    var pipeline = []
        .concat(canDeactivate)
        .concat(canActivate)
        .concat(middleware);
    resolve(pipeline, asyncBase, done);
    return cancel;
}

var noop$1 = function () { };
function withNavigation(router) {
    var cancelCurrentTransition;
    router.navigate = navigate;
    router.navigate = navigate;
    router.navigateToDefault = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var opts = typeof args[0] === 'object' ? args[0] : {};
        var done = args.length === 2
            ? args[1]
            : typeof args[0] === 'function'
                ? args[0]
                : noop$1;
        var options = router.getOptions();
        if (options.defaultRoute) {
            return navigate(options.defaultRoute, options.defaultParams, opts, done);
        }
        return function () { };
    };
    router.cancel = function () {
        if (cancelCurrentTransition) {
            cancelCurrentTransition('navigate');
            cancelCurrentTransition = null;
        }
        return router;
    };
    function navigate() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var name = args[0];
        var lastArg = args[args.length - 1];
        var done = typeof lastArg === 'function' ? lastArg : noop$1;
        var params = typeof args[1] === 'object' ? args[1] : {};
        var opts = typeof args[2] === 'object' ? args[2] : {};
        if (!router.isStarted()) {
            done({ code: errorCodes.ROUTER_NOT_STARTED });
            return;
        }
        var route = router.buildState(name, params);
        if (!route) {
            var err = { code: errorCodes.ROUTE_NOT_FOUND };
            done(err);
            router.invokeEventListeners(constants.TRANSITION_ERROR, null, router.getState(), err);
            return;
        }
        var toState = router.makeState(route.name, route.params, router.buildPath(route.name, route.params), { params: route.meta, options: opts });
        var sameStates = router.getState()
            ? router.areStatesEqual(router.getState(), toState, false)
            : false;
        // Do not proceed further if states are the same and no reload
        // (no deactivation and no callbacks)
        if (sameStates && !opts.reload && !opts.force) {
            var err = { code: errorCodes.SAME_STATES };
            done(err);
            router.invokeEventListeners(constants.TRANSITION_ERROR, toState, router.getState(), err);
            return;
        }
        var fromState = router.getState();
        if (opts.skipTransition) {
            done(null, toState);
            return noop$1;
        }
        // Transition
        return router.transitionToState(toState, fromState, opts, function (err, state) {
            if (err) {
                if (err.redirect) {
                    var _a = err.redirect, name_1 = _a.name, params_1 = _a.params;
                    navigate(name_1, params_1, __assign$1(__assign$1({}, opts), { force: true, redirected: true }), done);
                }
                else {
                    done(err);
                }
            }
            else {
                router.invokeEventListeners(constants.TRANSITION_SUCCESS, state, fromState, opts);
                done(null, state);
            }
        });
    }
    router.transitionToState = function (toState, fromState, options, done) {
        if (options === void 0) { options = {}; }
        if (done === void 0) { done = noop$1; }
        router.cancel();
        router.invokeEventListeners(constants.TRANSITION_START, toState, fromState);
        cancelCurrentTransition = transition(router, toState, fromState, options, function (err, state) {
            cancelCurrentTransition = null;
            state = state || toState;
            if (err) {
                if (err.code === errorCodes.TRANSITION_CANCELLED) {
                    router.invokeEventListeners(constants.TRANSITION_CANCEL, toState, fromState);
                }
                else {
                    router.invokeEventListeners(constants.TRANSITION_ERROR, toState, fromState, err);
                }
                done(err);
            }
            else {
                router.setState(state);
                done(null, state);
            }
        });
        return cancelCurrentTransition;
    };
    return router;
}

var noop$1$1 = function () { };
function withRouterLifecycle(router) {
    var started = false;
    router.isStarted = function () { return started; };
    //@ts-ignore
    router.start = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var options = router.getOptions();
        var lastArg = args[args.length - 1];
        var done = typeof lastArg === 'function' ? lastArg : noop$1$1;
        var startPathOrState = typeof args[0] !== 'function' ? args[0] : undefined;
        if (started) {
            done({ code: errorCodes.ROUTER_ALREADY_STARTED });
            return router;
        }
        var startPath, startState;
        started = true;
        router.invokeEventListeners(constants.ROUTER_START);
        // callback
        var cb = function (err, state, invokeErrCb) {
            if (invokeErrCb === void 0) { invokeErrCb = true; }
            if (!err)
                router.invokeEventListeners(constants.TRANSITION_SUCCESS, state, null, { replace: true });
            if (err && invokeErrCb)
                router.invokeEventListeners(constants.TRANSITION_ERROR, state, null, err);
            done(err, state);
        };
        if (startPathOrState === undefined && !options.defaultRoute) {
            return cb({ code: errorCodes.NO_START_PATH_OR_STATE });
        }
        if (typeof startPathOrState === 'string') {
            startPath = startPathOrState;
        }
        else if (typeof startPathOrState === 'object') {
            startState = startPathOrState;
        }
        if (!startState) {
            // If no supplied start state, get start state
            startState =
                startPath === undefined ? null : router.matchPath(startPath);
            // Navigate to default function
            var navigateToDefault_1 = function () {
                return router.navigateToDefault({ replace: true }, done);
            };
            var redirect_1 = function (route) {
                return router.navigate(route.name, route.params, { replace: true, reload: true, redirected: true }, done);
            };
            var transitionToState = function (state) {
                router.transitionToState(state, router.getState(), {}, function (err, state) {
                    if (!err)
                        cb(null, state);
                    else if (err.redirect)
                        redirect_1(err.redirect);
                    else if (options.defaultRoute)
                        navigateToDefault_1();
                    else
                        cb(err, null, false);
                });
            };
            // If matched start path
            if (startState) {
                transitionToState(startState);
            }
            else if (options.defaultRoute) {
                // If default, navigate to default
                navigateToDefault_1();
            }
            else if (options.allowNotFound) {
                transitionToState(router.makeNotFoundState(startPath, { replace: true }));
            }
            else {
                // No start match, no default => do nothing
                cb({ code: errorCodes.ROUTE_NOT_FOUND, path: startPath }, null);
            }
        }
        else {
            // Initialise router with provided start state
            router.setState(startState);
            cb(null, startState);
        }
        return router;
    };
    router.stop = function () {
        if (started) {
            router.setState(null);
            started = false;
            router.invokeEventListeners(constants.ROUTER_STOP);
        }
        return router;
    };
    return router;
}

var toFunction = function (val) { return (typeof val === 'function' ? val : function () { return function () { return val; }; }); };
function withRouteLifecycle(router) {
    var canDeactivateFactories = {};
    var canActivateFactories = {};
    var canDeactivateFunctions = {};
    var canActivateFunctions = {};
    router.getLifecycleFactories = function () {
        return [canDeactivateFactories, canActivateFactories];
    };
    router.getLifecycleFunctions = function () {
        return [canDeactivateFunctions, canActivateFunctions];
    };
    router.canDeactivate = function (name, canDeactivateHandler) {
        var factory = toFunction(canDeactivateHandler);
        canDeactivateFactories[name] = factory;
        canDeactivateFunctions[name] = router.executeFactory(factory);
        return router;
    };
    router.clearCanDeactivate = function (name) {
        canDeactivateFactories[name] = undefined;
        canDeactivateFunctions[name] = undefined;
        return router;
    };
    router.canActivate = function (name, canActivateHandler) {
        var factory = toFunction(canActivateHandler);
        canActivateFactories[name] = factory;
        canActivateFunctions[name] = router.executeFactory(factory);
        return router;
    };
    return router;
}

var pipe = function () {
    var fns = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        fns[_i] = arguments[_i];
    }
    return function (arg) {
        return fns.reduce(function (prev, fn) { return fn(prev); }, arg);
    };
};
var createRouter = function (routes, options, dependencies) {
    if (routes === void 0) { routes = []; }
    if (options === void 0) { options = {}; }
    if (dependencies === void 0) { dependencies = {}; }
    var config = {
        decoders: {},
        encoders: {},
        defaultParams: {},
        forwardMap: {}
    };
    return pipe(withOptions(options), withDependencies(dependencies), withObservability, withState, withRouterLifecycle, withRouteLifecycle, withNavigation, withPlugins, withMiddleware, withRoutes(routes))({ config: config });
};

var createRouter$1 = createRouter;/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
}

var value = function (arg) { return function () { return arg; }; };
var noop = function () { };
var isBrowser = typeof window !== 'undefined' && window.history;
var getBase = function () { return window.location.pathname; };
var supportsPopStateOnHashChange = function () {
    return window.navigator.userAgent.indexOf('Trident') === -1;
};
var pushState = function (state, title, path) {
    return window.history.pushState(state, title, path);
};
var replaceState = function (state, title, path) {
    return window.history.replaceState(state, title, path);
};
var addPopstateListener = function (fn, opts) {
    var shouldAddHashChangeListener = opts.useHash && !supportsPopStateOnHashChange();
    window.addEventListener('popstate', fn);
    if (shouldAddHashChangeListener) {
        window.addEventListener('hashchange', fn);
    }
    return function () {
        window.removeEventListener('popstate', fn);
        if (shouldAddHashChangeListener) {
            window.removeEventListener('hashchange', fn);
        }
    };
};
var getLocation = function (opts) {
    var path = opts.useHash
        ? window.location.hash.replace(new RegExp('^#' + opts.hashPrefix), '')
        : window.location.pathname.replace(new RegExp('^' + opts.base), '');
    // Fix issue with browsers that don't URL encode characters (Edge)
    var correctedPath = safelyEncodePath(path);
    return (correctedPath || '/') + window.location.search;
};
var safelyEncodePath = function (path) {
    try {
        return encodeURI(decodeURI(path));
    }
    catch (_) {
        return path;
    }
};
var getState = function () { return window.history.state; };
var getHash = function () { return window.location.hash; };
var browser = {};
if (isBrowser) {
    browser = {
        getBase: getBase,
        pushState: pushState,
        replaceState: replaceState,
        addPopstateListener: addPopstateListener,
        getLocation: getLocation,
        getState: getState,
        getHash: getHash
    };
}
else {
    browser = {
        getBase: value(''),
        pushState: noop,
        replaceState: noop,
        addPopstateListener: noop,
        getLocation: value(''),
        getState: value(null),
        getHash: value('')
    };
}
var safeBrowser = browser;

var defaultOptions = {
    forceDeactivate: true,
    useHash: false,
    hashPrefix: '',
    base: '',
    mergeState: false,
    preserveHash: true
};
var source = 'popstate';
function browserPluginFactory(opts, browser) {
    if (browser === void 0) { browser = safeBrowser; }
    var options = __assign(__assign({}, defaultOptions), opts);
    var transitionOptions = {
        forceDeactivate: options.forceDeactivate,
        source: source
    };
    var removePopStateListener;
    return function browserPlugin(router) {
        var routerOptions = router.getOptions();
        var routerStart = router.start;
        router.buildUrl = function (route, params) {
            var base = options.base || '';
            var prefix = options.useHash ? "#" + options.hashPrefix : '';
            var path = router.buildPath(route, params);
            return base + prefix + path;
        };
        var urlToPath = function (url) {
            var match = url.match(/^(?:http|https):\/\/(?:[0-9a-z_\-.:]+?)(?=\/)(.*)$/);
            var path = match ? match[1] : url;
            var pathParts = path.match(/^(.+?)(#.+?)?(\?.+)?$/);
            if (!pathParts)
                throw new Error("[router5] Could not parse url " + url);
            var pathname = pathParts[1];
            var hash = pathParts[2] || '';
            var search = pathParts[3] || '';
            return ((options.useHash
                ? hash.replace(new RegExp('^#' + options.hashPrefix), '')
                : options.base
                    ? pathname.replace(new RegExp('^' + options.base), '')
                    : pathname) + search);
        };
        router.matchUrl = function (url) { return router.matchPath(urlToPath(url)); };
        router.start = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            if (args.length === 0 || typeof args[0] === 'function') {
                routerStart.apply(void 0, __spreadArrays([browser.getLocation(options)], args));
            }
            else {
                routerStart.apply(void 0, args);
            }
            return router;
        };
        router.replaceHistoryState = function (name, params, title) {
            if (params === void 0) { params = {}; }
            if (title === void 0) { title = ''; }
            var route = router.buildState(name, params);
            var state = router.makeState(route.name, route.params, router.buildPath(route.name, route.params), { params: route.meta });
            var url = router.buildUrl(name, params);
            router.lastKnownState = state;
            browser.replaceState(state, title, url);
        };
        function updateBrowserState(state, url, replace) {
            var trimmedState = state
                ? {
                    meta: state.meta,
                    name: state.name,
                    params: state.params,
                    path: state.path
                }
                : state;
            var finalState = options.mergeState === true
                ? __assign(__assign({}, browser.getState()), trimmedState) : trimmedState;
            if (replace)
                browser.replaceState(finalState, '', url);
            else
                browser.pushState(finalState, '', url);
        }
        function onPopState(evt) {
            var routerState = router.getState();
            // Do nothing if no state or if last know state is poped state (it should never happen)
            var newState = !evt.state || !evt.state.name;
            var state = newState
                ? router.matchPath(browser.getLocation(options), source)
                : router.makeState(evt.state.name, evt.state.params, evt.state.path, __assign(__assign({}, evt.state.meta), { source: source }), evt.state.meta.id);
            var defaultRoute = routerOptions.defaultRoute, defaultParams = routerOptions.defaultParams;
            if (!state) {
                // If current state is already the default route, we will have a double entry
                // Navigating back and forth will emit SAME_STATES error
                defaultRoute &&
                    router.navigateToDefault(__assign(__assign({}, transitionOptions), { reload: true, replace: true }));
                return;
            }
            if (routerState &&
                router.areStatesEqual(state, routerState, false)) {
                return;
            }
            router.transitionToState(state, routerState, transitionOptions, function (err, toState) {
                if (err) {
                    if (err.redirect) {
                        var _a = err.redirect, name_1 = _a.name, params = _a.params;
                        router.navigate(name_1, params, __assign(__assign({}, transitionOptions), { replace: true, force: true, redirected: true }));
                    }
                    else if (err.code === errorCodes.CANNOT_DEACTIVATE) {
                        var url = router.buildUrl(routerState.name, routerState.params);
                        if (!newState) {
                            // Keep history state unchanged but use current URL
                            updateBrowserState(state, url, true);
                        }
                        // else do nothing or history will be messed up
                        // TODO: history.back()?
                    }
                    else {
                        // Force navigation to default state
                        defaultRoute &&
                            router.navigate(defaultRoute, defaultParams, __assign(__assign({}, transitionOptions), { reload: true, replace: true }));
                    }
                }
                else {
                    router.invokeEventListeners(constants.TRANSITION_SUCCESS, toState, routerState, { replace: true });
                }
            });
        }
        function onStart() {
            if (options.useHash && !options.base) {
                // Guess base
                options.base = browser.getBase();
            }
            removePopStateListener = browser.addPopstateListener(onPopState, options);
        }
        function teardown() {
            if (removePopStateListener) {
                removePopStateListener();
                removePopStateListener = undefined;
            }
        }
        function onTransitionSuccess(toState, fromState, opts) {
            var historyState = browser.getState();
            var hasState = historyState &&
                historyState.meta &&
                historyState.name &&
                historyState.params;
            var statesAreEqual = fromState && router.areStatesEqual(fromState, toState, false);
            var replace = opts.replace || !hasState || statesAreEqual;
            var url = router.buildUrl(toState.name, toState.params);
            if (fromState === null &&
                options.useHash === false &&
                options.preserveHash === true) {
                url += browser.getHash();
            }
            updateBrowserState(toState, url, replace);
        }
        return {
            onStart: onStart,
            onStop: teardown,
            teardown: teardown,
            onTransitionSuccess: onTransitionSuccess,
            onPopState: onPopState
        };
    };
}class RouterService {
  static get router() {
    return this.router_;
  }
  static get route() {
    let route = null;
    const router = this.router_;
    if (router) {
      route = router.getState();
      // console.log('RouterService.get.route', route);
    }

    return route;
  }

  /*
  static event$_ = new Subject();
  static event$() {
  	const router = this.router_;
  	if (router) {
  		return from(router).pipe(
  			startWith({ route: router.getState(), previousRoute: null }),
  			tap(event => {
  				// console.log('RouterService.event$', event);
  				this.event$_.next(event);
  			}),
  		);
  	} else {
  		return EMPTY;
  	}
  }
  */

  static useBrowser(routes) {
    if (!(Array.isArray(routes) && routes.length)) {
      this.event$ = rxjs.EMPTY;
      return;
    }
    this.routes = routes;
    const router = createRouter$1(routes, {
      allowNotFound: false,
      autoCleanUp: true,
      defaultRoute: 'index',
      defaultParams: {},
      queryParams: {
        arrayFormat: 'default',
        nullFormat: 'default',
        booleanFormat: 'default'
      },
      queryParamsMode: 'default',
      trailingSlashMode: 'default',
      strictTrailingSlash: false,
      caseSensitive: false,
      urlParamsEncoding: 'default'
    });
    this.router_ = router;
    router.usePlugin(browserPluginFactory({
      useHash: false
    }));
    router.start();
    this.event$ = rxjs.from(router).pipe(operators.startWith({
      route: router.getState(),
      previousRoute: null
    })
    // tap(event => { console.log('RouterService.event$', event); }),
    );
  }

  static useBrowser$(routes) {
    this.useBrowser(routes);
    return this.event$;
  }
  static setRouterLink(routerLink, routeParams, options) {
    if (routerLink === void 0) {
      routerLink = 'it.access';
    }
    if (routeParams === void 0) {
      routeParams = null;
    }
    if (options === void 0) {
      options = {
        reload: true
      };
    }
    const router = this.router_;
    if (router) {
      // router.matchUrl(routerLink);
      try {
        router.navigate(routerLink, routeParams, options);
      } catch (error) {
        console.log('RouterService.setRouterLink.error', error);
      }
    }
    // console.log('RouterService.setRouterLink', router, routerLink, routeParams, options);
  }

  static replaceHistoryState(name, params) {
    const router = this.router_;
    if (router) {
      // router.matchUrl(routerLink);
      try {
        router.replaceHistoryState(name, params);
      } catch (error) {
        console.log('RouterService.replaceHistoryState.error', error);
      }
    }
  }
  static setCurrentParams(params) {
    const router = this.router_;
    if (router) {
      try {
        const route = this.route;
        if (route) {
          router.replaceHistoryState(route.name, params);
        }
      } catch (error) {
        console.log('RouterService.setCurrentParams.error', error);
      }
    }
  }
  static buildPath(route, params) {
    if (params === void 0) {
      params = null;
    }
    let path = null;
    const router = this.router_;
    if (router) {
      try {
        path = router.buildPath(route, params);
      } catch (error) {
        console.log('RouterService.buildPath.error', error);
      }
    }
    // console.log('RouterService.buildPath', path, route, params);
    // router.buildUrl(routeName, routeParams)
    return path;
  }
  static buildUrl(routeName, routeParams) {
    if (routeParams === void 0) {
      routeParams = null;
    }
    let url = null;
    const router = this.router_;
    if (router) {
      try {
        url = router.buildUrl(routeName, routeParams);
      } catch (error) {
        console.log('RouterService.buildUrl.error', error);
      }
    }
    // console.log('RouterService.buildUrl', url, routeName, routeParams);
    return url;
  }
  static isActive(name, params, strictEquality, ignoreQueryParams) {
    if (strictEquality === void 0) {
      strictEquality = false;
    }
    if (ignoreQueryParams === void 0) {
      ignoreQueryParams = true;
    }
    let active = false;
    const router = this.router_;
    if (router) {
      try {
        active = router.isActive(name, params, strictEquality, ignoreQueryParams);
      } catch (error) {
        console.log('RouterService.isActive.error', error);
      }
    }
    // console.log('RouterService.isActive', active, name, params, strictEquality, ignoreQueryParams);
    return active;
  }
}
RouterService.routes = [];
RouterService.router_ = null;class StateService {
  static set state(state) {
    this.state$.next(state);
  }
  static get state() {
    return this.state$.getValue();
  }
  static patchState(state) {
    state = Object.assign({}, this.state, state);
    this.state = state;
  }
}
StateService.state$ = new rxjs.BehaviorSubject({});const RoleType = {
  Publisher: 'publisher',
  Attendee: 'attendee',
  Streamer: 'streamer',
  Viewer: 'viewer',
  SmartDevice: 'smart-device',
  SelfService: 'self-service',
  Embed: 'embed'
};
class User {
  constructor(options) {
    if (options) {
      Object.assign(this, options);
    }
  }
}const MEETING_ID_VALIDATOR = /^\d{9}-\d{4}-\d{13}(-\d+)?$/;
class MeetingId {
  get roleIndex() {
    return MeetingId.getRoleIndex(this.role);
  }
  set roleIndex(roleIndex) {
    const roleIndex_ = MeetingId.getRoleIndex(this.role);
    if (roleIndex_ !== roleIndex) {
      const key = Object.keys(RoleType)[roleIndex];
      this.role = RoleType[key];
    }
  }
  constructor(options) {
    this.userId = StateService.state.user ? StateService.state.user.id : 0;
    this.role = StateService.state.role || RoleType.Viewer;
    this.timestamp = new Date().valueOf().toString();
    this.pathId = null;
    // this.timestamp = (performance.now() * 10000000000000).toString();
    if (typeof options === 'string') {
      if (options.match(MEETING_ID_VALIDATOR)) {
        options = MeetingId.decompose(options);
      } else {
        console.warn('MeetingId', 'invalid meetingId', options);
        return null;
      }
    }
    if (typeof options === 'object') {
      if (options.id) {
        this.id = options.id;
      }
      if (options.userId) {
        this.userId = options.userId;
      }
      if (options.role) {
        this.role = options.role;
      }
      if (options.roleIndex) {
        this.roleIndex = options.roleIndex;
      }
      if (options.timestamp) {
        this.timestamp = options.timestamp;
      }
      if (options.pathId) {
        this.pathId = options.pathId;
      }
    }
    // console.log('MeetingId', this);
  }

  toString() {
    return MeetingId.compose(this.userId, this.roleIndex, this.timestamp, this.pathId);
  }
  toRoles() {
    const userId = this.userId;
    const timestamp = this.timestamp;
    const pathId = this.pathId;
    return {
      id: MeetingId.compose(userId, MeetingId.getRoleIndex(RoleType.Publisher), timestamp, pathId),
      idAttendee: MeetingId.compose(userId, MeetingId.getRoleIndex(RoleType.Attendee), timestamp, pathId),
      idStreamer: MeetingId.compose(userId, MeetingId.getRoleIndex(RoleType.Streamer), timestamp, pathId),
      idViewer: MeetingId.compose(userId, MeetingId.getRoleIndex(RoleType.Viewer), timestamp, pathId),
      idSmartDevice: MeetingId.compose(userId, MeetingId.getRoleIndex(RoleType.SmartDevice), timestamp, pathId),
      idSelfService: MeetingId.compose(userId, MeetingId.getRoleIndex(RoleType.SelfService), timestamp, pathId)
    };
  }
  static compose(userId, roleIndex, timestamp, pathId) {
    return `${MeetingId.padded(userId, 9)}-${MeetingId.padded(roleIndex, 4)}-${timestamp}${pathId ? `-${pathId}` : ''}`;
  }
  static decompose(meetingId) {
    const components = meetingId.split('-');
    return {
      userId: parseInt(components[0]),
      roleIndex: parseInt(components[1]),
      timestamp: parseInt(components[2]),
      pathId: components[3] ? parseInt(components[3]) : null
    };
  }
  static generateMeetingId() {
    const meetingId = new MeetingId();
    return meetingId.toRoles();
  }
  static getRoleIndex(role) {
    return Object.keys(RoleType).reduce((p, c, i) => {
      return RoleType[c] === role ? i : p;
    }, -1);
  }
  static padded(num, size) {
    const s = '000000000000' + num;
    return s.substring(s.length - size);
  }
}class MeetingUrl {
  get meetingId() {
    return this.link ? new MeetingId(this.link) : null;
  }
  constructor(options) {
    /*
    this.link = LocationService.get('link') || null;
    this.name = LocationService.get('name') || null;
    this.firstName = LocationService.get('firstName') || null;
    this.lastName = LocationService.get('lastName') || null;
    this.email = LocationService.get('email') || null;
    this.role = LocationService.get('role') || null;
    this.viewId = LocationService.has('viewId') ? parseInt(LocationService.get('viewId')) : null;
    this.pathId = LocationService.has('pathId') ? parseInt(LocationService.get('pathId')) : null;
    this.embedViewId = LocationService.has('embedViewId') ? parseInt(LocationService.get('embedViewId')) : null;
    this.support = LocationService.has('support') ? (LocationService.get('support') === 'true') : false;
    */
    options = options || window.location.href;
    if (typeof options === 'string') {
      options = MeetingUrl.decompose(options);
    }
    if (typeof options === 'object') {
      Object.assign(this, options);
      if (options.user) {
        const name = MeetingUrl.getName(options.user);
        if (name) {
          this.name = name;
        }
        if (environment.flags.useExtendedUserInfo) {
          const firstName = MeetingUrl.getFirstName(options.user);
          if (firstName) {
            this.firstName = firstName;
          }
          const lastName = MeetingUrl.getLastName(options.user);
          if (lastName) {
            this.lastName = lastName;
          }
          const email = MeetingUrl.getEmail(options.user);
          if (email) {
            this.email = email;
          }
        }
      }
      if (options.name) {
        this.name = options.name;
      }
      if (environment.flags.useExtendedUserInfo) {
        if (options.firstName) {
          this.firstName = options.firstName;
        }
        if (options.lastName) {
          this.lastName = options.lastName;
        }
        if (options.email) {
          this.email = options.email;
        }
      }
    }
    this.link = this.link || null;
    this.name = this.name || null;
    this.firstName = this.firstName || null;
    this.lastName = this.lastName || null;
    this.email = this.email || null;
    this.role = this.role || null;
    this.viewId = this.viewId || null;
    this.pathId = this.pathId || null;
    this.embedViewId = this.embedViewId || null;
    this.support = this.support || false;
    // console.log('MeetingUrl', this);
  }

  toParams(shareable) {
    if (shareable === void 0) {
      shareable = false;
    }
    let params = {};
    if (this.link) {
      params.link = this.link;
    }
    if (environment.flags.useExtendedUserInfo) {
      if (this.firstName) {
        params.firstName = this.firstName;
      }
      if (this.lastName) {
        params.lastName = this.lastName;
      }
      if (this.email) {
        params.email = this.email;
      }
    } else {
      if (this.name) {
        params.name = this.name;
      }
    }
    if (this.role && !shareable) {
      params.role = this.role;
    }
    if (this.viewId) {
      params.viewId = this.viewId;
    }
    if (this.pathId) {
      params.pathId = this.pathId;
    }
    if (this.support) {
      params.support = this.support;
    }
    if (environment.flags.useEncryptedUrl) {
      params = {
        p: MeetingUrl.encrypt(params)
      };
    }
    return params;
  }
  toString(shareable) {
    if (shareable === void 0) {
      shareable = false;
    }
    let components;
    if (environment.flags.useExtendedUserInfo) {
      components = {
        link: this.link,
        firstName: this.firstName,
        lastName: this.lastName,
        email: this.email,
        role: shareable ? null : this.role,
        viewId: this.viewId,
        pathId: this.pathId,
        support: this.support
      };
    } else {
      components = {
        link: this.link,
        name: this.name,
        role: shareable ? null : this.role,
        viewId: this.viewId,
        pathId: this.pathId,
        support: this.support
      };
    }
    return MeetingUrl.compose(components);
  }
  toUrl() {
    const params = this.toParams();
    return MeetingUrl.getCurrentUrl(params);
  }
  toAccessCodeUrl() {
    const params = this.toParams();
    return MeetingUrl.getAccessCodeUrl(params);
  }
  toGuidedTourUrl() {
    const params = this.toParams();
    return MeetingUrl.getGuidedTourUrl(params);
  }
  copyToClipBoard(asAccessCode) {
    if (asAccessCode === void 0) {
      asAccessCode = false;
    }
    const input = document.createElement('input');
    input.style.position = 'absolute';
    input.style.top = '1000vh';
    // input.style.visibility = 'hidden';
    document.querySelector('body').appendChild(input);
    const params = this.toParams(true);
    input.value = window.location.origin + (asAccessCode ? MeetingUrl.getAccessCodeUrl(params) : MeetingUrl.getGuidedTourUrl(params));
    input.focus();
    input.select();
    input.setSelectionRange(0, 99999);
    document.execCommand('copy');
    input.parentNode.removeChild(input);
    alert(`link copiato!\n ${input.value}`);
  }
  replaceUrl() {
    RouterService.setCurrentParams(this.toParams());
  }
  static replaceWithOptions(options) {
    const currentOptions = MeetingUrl.decompose(window.location.href);
    const meetingUrl = new MeetingUrl(Object.assign(currentOptions, options));
    meetingUrl.replaceUrl();
    return meetingUrl;
  }
  static replaceWithUser(user) {
    return this.replaceWithOptions({
      user
    });
  }
  static replaceWithName(name) {
    return this.replaceWithOptions({
      name
    });
  }
  static replaceWithLink(link) {
    return this.replaceWithOptions({
      link
    });
  }
  static getCurrentUrl(params) {
    if (params === void 0) {
      params = null;
    }
    const route = RouterService.route;
    if (route) {
      const routeName = route.name;
      // console.log('MeetingUrl.getCurrentUrl', routeName);
      return RouterService.buildUrl(routeName, params);
    }
  }
  static getAccessCodeUrl(params) {
    if (params === void 0) {
      params = null;
    }
    const route = RouterService.route;
    if (route) {
      const routeName = `${route.params.lang}.accessCode`;
      // console.log('MeetingUrl.getAccessCodeUrl', routeName);
      return RouterService.buildUrl(routeName, params);
    }
  }
  static getGuidedTourUrl(params) {
    if (params === void 0) {
      params = null;
    }
    const route = RouterService.route;
    if (route) {
      const routeName = `${route.params.lang}.guidedTour`;
      // console.log('MeetingUrl.getGuidedTourUrl', routeName);
      return RouterService.buildUrl(routeName, params);
    }
  }
  static getName(user) {
    return user && user.firstName && user.lastName ? `${user.firstName} ${user.lastName}` : null;
  }
  static getFirstName(user) {
    return user && user.firstName ? user.firstName : null;
  }
  static getLastName(user) {
    return user && user.lastName ? user.lastName : null;
  }
  static getEmail(user) {
    return user && user.email ? user.email : null;
  }
  static compose(components) {
    if (environment.flags.useEncryptedUrl) {
      const p = MeetingUrl.encrypt(components);
      return `?p=${p}`;
    } else {
      components = Object.keys(components).map(key => {
        return {
          key,
          value: components[key]
        };
      }).filter(x => x.value != null && x.value !== false).map(x => `${x.key}=${x.value}`);
      return `?${components.join('&')}`;
    }
  }
  static decompose(url) {
    let components = {};
    if (environment.flags.useEncryptedUrl) {
      const params = new URLSearchParams(url.split('?')[1]);
      if (params.has('p')) {
        components = MeetingUrl.decrypt(params.get('p'));
      }
    } else if (url.indexOf('?') > -1) {
      const params = new URLSearchParams(url.split('?')[1]);
      params.forEach((value, key) => {
        switch (key) {
          case 'viewId':
          case 'pathId':
          case 'embedViewId':
            value = value ? parseInt(value) : null;
            break;
          case 'support':
            value = value ? value === 'true' : false;
            break;
        }
        components[key] = value;
      });
    }
    return components;
  }
  static decrypt(p) {
    return JSON.parse(window.atob(p));
  }
  static encrypt(params) {
    return window.btoa(JSON.stringify(params));
  }
  static validateParams(components) {
    if (environment.flags.useEncryptedUrl) {
      const p = MeetingUrl.encrypt(components);
      return {
        p
      };
    } else {
      return components;
    }
  }
}class RouterOutletStructure extends rxcomp.Structure {
  // host;
  // outlet;
  // element;
  // instance;
  // route$_ = new ReplaySubject(1);

  getFactory(route) {
    let factory = null;
    const routes = RouterService.routes;
    const originalRoute = routes.find(x => x.name === route.name);
    if (originalRoute) {
      factory = originalRoute.factory;
    }
    // console.log('RouterOutletStructure.getFactory', originalRoute, routes, route);
    return factory;
  }
  onInit() {
    this.route$().pipe(operators.switchMap(route => this.factory$(route)), operators.takeUntil(this.unsubscribe$)).subscribe(event => {
      // console.log('RouterOutletStructure.route$', event);
    });
    /*
    this.route$().pipe(
    	switchMap(snapshot => this.factory$(snapshot)),
    	takeUntil(this.unsubscribe$)
    ).subscribe(() => {
    	// console.log(`RouterOutletStructure ActivatedRoutes: ["${RouterService.flatRoutes.filter(x => x.snapshot).map(x => x.snapshot?.extractedUrl).join('", "')}"]`);
    });
    if (this.host) {
    	this.route$_.next(this.host.route.childRoute);
    }
    */
  }

  route$() {
    return RouterService.event$.pipe(operators.map(event => {
      const route = event.route;
      this.route = route;
      // console.log('RouterOutletStructure.route', route);
      return route;
    }));
    /*
    const routes = this.routes;
    // console.log('RouterOutletStructure.route$', routes);
    if (routes) {
    	return RouterService.useBrowser$(routes).pipe(
    		map(event => {
    			// console.log('RouterOutletStructure.route$', event);
    			return event.route;
    		}),
    	);
    } else {
    	return EMPTY;
    }
    */
  }

  factory$(route) {
    const factory = this.getFactory(route);
    // console.log('RouterOutletStructure.factory$', route, factory);
    const {
      module,
      node
    } = rxcomp.getContext(this);
    {
      this.factory_ = factory;
      return rxjs.of(factory).pipe(operators.tap(() => {
        if (this.element) {
          this.element.parentNode.removeChild(this.element);
          module.remove(this.element, this);
          this.element = undefined;
          this.instance = undefined;
        }
      }), operators.map(() => {
        if (factory && factory.meta.template) {
          let element = document.createElement('div');
          element.innerHTML = factory.meta.template;
          if (element.children.length === 1) {
            element = element.firstElementChild;
          }
          node.appendChild(element);
          const instance = module.makeInstance(element, factory, factory.meta.selector, this, undefined, {
            route
          });
          module.compile(element, instance);
          this.instance = instance;
          this.element = element;
          return {
            element,
            instance
          };
        }
      }));
    }
  }
  onChanges() {
    /*
    if (this.host) {
    	this.route$_.next(this.host.route.childRoute);
    }
    */
  }

  /*
  route$() {
  	const source = this.host ? this.route$_ : RouterService.route$;
  	return source.pipe(
  		filter((snapshot) => {
  			this.route_ = snapshot; // !!!
  			if (this.snapshot_ && snapshot && this.snapshot_.component === snapshot.component) {
  				this.snapshot_.next(snapshot);
  				return false;
  			} else {
  				this.snapshot_ = snapshot;
  				return true;
  			}
  		}),
  	);
  }
  */

  /*
  factory$(snapshot) {
  	const { module, node } = getContext(this);
  	const factory = snapshot.component;
  	if (this.factory_ !== factory) {
  		this.factory_ = factory;
  		return this.onLeave$_(snapshot, this.element, this.instance).pipe(
  			tap(() => {
  				if (this.element) {
  					this.element.parentNode.removeChild(this.element);
  					module.remove(this.element, this);
  					this.element = undefined;
  					this.instance = undefined;
  				}
  			}),
  			switchMap(() => {
  				if (snapshot && factory && factory.meta.template) {
  					let element = document.createElement('div');
  					element.innerHTML = factory.meta.template;
  					if (element.children.length === 1) {
  						element = element.firstElementChild;
  					}
  					node.appendChild(element);
  					const instance = module.makeInstance(element, factory, factory.meta.selector, this, undefined, { route: snapshot });
  					module.compile(element, instance);
  					this.instance = instance;
  					this.element = element;
  					snapshot.element = element;
  					return this.onOnce$_(snapshot, element, instance).pipe(
  						switchMap(() => {
  							return this.onEnter$_(snapshot, element, instance);
  						})
  					);
  				} else {
  					return of(void 0);
  				}
  			})
  		);
  	} else {
  		return of(void 0);
  	}
  }
  */

  /*
  onOnce$_(snapshot, element, instance) {
  	if (!transitionOnced() && instance instanceof View && element) {
  		transitionOnce();
  		const factory = instance.constructor;
  		const transition = factory.transitions.find((x) => x instanceof OnceTransition && x.matcher(snapshot.previousRoute?.path));
  		return transition ? asObservable([element, snapshot.previousRoute], transition.callback.bind(instance)) : of(void 0);
  	} else {
  		return of(void 0);
  	}
  }
  
  onEnter$_(snapshot, element, instance) {
  	if (instance instanceof View && element) {
  		const factory = instance.constructor;
  		const transition = factory.transitions.find((x) => x instanceof EnterTransition && x.matcher(snapshot.previousRoute?.path));
  		return transition ? asObservable([element, snapshot.previousRoute], transition.callback.bind(instance)) : of(void 0);
  	} else {
  		return of(void 0);
  	}
  }
  
  onLeave$_(snapshot, element, instance) {
  	if (instance instanceof View && element) {
  		const factory = instance.constructor;
  		const transition = factory.transitions.find((x) => x instanceof LeaveTransition && x.matcher(snapshot?.path));
  		return transition ? asObservable([element, snapshot], transition.callback.bind(instance)) : of(void 0);
  	} else {
  		return of(void 0);
  	}
  }
  */
}
RouterOutletStructure.meta = {
  selector: 'router-outlet,[router-outlet]',
  hosts: {
    host: RouterOutletStructure
  }
};// import { RouterService } from '../router/router.service';

class AccessCodeComponent extends rxcomp.Component {
  onInit() {
    this.state = {};
    const meetingUrl = new MeetingUrl();
    if (!meetingUrl.link) {
      // !!!
      // RouterService.setRouterLink(MeetingUrl.getGuidedTourUrl());
      window.location.href = window.location.origin + MeetingUrl.getGuidedTourUrl();
    } else {
      const url = meetingUrl.toGuidedTourUrl();
      const {
        node
      } = rxcomp.getContext(this);
      new QRious({
        element: node.querySelector('.qrcode'),
        value: url,
        size: 256
      });
    }
  }
}
AccessCodeComponent.meta = {
  selector: '[access-code-component]',
  hosts: {
    host: RouterOutletStructure
  },
  template: /* html */`
		<div class="page page--access-code">
			${CHUNK_BACKGROUND}
			<!-- access-code -->
			<div class="ui ui--info ui--info-centered">
				<div class="group--info">
					<div class="group--info__content stagger--childs">
						<div class="title" [innerHTML]="'access_code_title' | label"></div>
						<div class="picture">
							<canvas class="qrcode"></canvas>
						</div>
					</div>
				</div>
			</div>
			${CHUNK_LOGO}
			${CHUNK_CREDITS}
			${CHUNK_LANGUAGE}
		</div>
	`
};function ownKeys(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function (r) {
      return Object.getOwnPropertyDescriptor(e, r).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread2(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {
      _defineProperty(e, r, t[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
    });
  }
  return e;
}
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPrimitive(input, hint) {
  if (typeof input !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}class ControlsComponent extends rxcomp.Component {
  get group() {
    if (this.formGroup) {
      return this.formGroup;
    } else {
      if (!this.host) {
        throw 'missing form collection';
      }
      return this.host.control;
    }
  }
  getControl(name) {
    return this.group.get(name);
  }
}
ControlsComponent.meta = {
  selector: '[controls]',
  inputs: ['formGroup', 'fields'],
  hosts: {
    host: rxcompForm.FormAbstractCollectionDirective
  },
  template: /* html */`
		<div *for="let field of fields">
			<div *if="['text', 'email', 'url'].indexOf(field.type) !== -1" control-text [control]="getControl(field.name)" [label]="field.label | label"></div>
			<div *if="field.type == 'select'" control-select [control]="getControl(field.name)" [label]="field.label | label"></div>
			<div *if="field.type == 'custom-select'" control-custom-select [control]="getControl(field.name)" [label]="field.label | label"></div>
			<div *if="field.type == 'textarea'" control-textarea [control]="getControl(field.name)" [label]="field.label | label"></div>
			<div *if="field.type == 'checkbox'" control-checkbox [control]="getControl(field.name)" [label]="field.label | label"></div>
			<input *if="field.type == 'hidden'" [name]="field.name" [formControl]="getControl(field.name)" value="" type="text" style="display:none !important;" />
		</div>
	`
};
function fieldsToFormControls(fields) {
  const controls = fields.reduce((p, c, i) => {
    const validators = [];
    if (c.required) {
      validators.push(c.type === 'checkbox' ? rxcompForm.Validators.RequiredTrueValidator() : rxcompForm.Validators.RequiredValidator());
    }
    if (c.type === 'email') {
      validators.push(rxcompForm.Validators.EmailValidator());
    }
    if (c.type === 'url') {
      // eslint-disable-next-line no-useless-escape
      validators.push(rxcompForm.Validators.PatternValidator('(https?:\/\/(?:www\.|(?!www))[a-zA-Z0-9][a-zA-Z0-9-]+[a-zA-Z0-9]\.[^\s]{2,}|www\.[a-zA-Z0-9][a-zA-Z0-9-]+[a-zA-Z0-9]\.[^\s]{2,}|https?:\/\/(?:www\.|(?!www))[a-zA-Z0-9]+\.[^\s]{2,}|www\.[a-zA-Z0-9]+\.[^\s]{2,})'));
    }
    if (c.pattern != null) {
      validators.push(rxcompForm.Validators.PatternValidator(c.pattern));
    }
    p[c.name] = new rxcompForm.FormControl(c.value != null ? c.value : null, validators);
    if (c.type === 'select' || c.type === 'custom-select') {
      const options = (c.options || []).slice();
      options.unshift({
        id: null,
        name: 'select'
      }); // LabelPipe.transform('select')
      p[c.name].options = options;
    }
    return p;
  }, {});
  return controls;
}
function fieldsToFormGroup(fields) {
  return new rxcompForm.FormGroup(fieldsToFormControls(fields));
}
function patchFields(fields, form) {
  const testValues = fields.reduce((p, c, i) => {
    if (c.test) {
      p[c.name] = c.test;
    }
    return p;
  }, {});
  form.patch(testValues);
}class LabelPipe extends rxcomp.Pipe {
  static get labels() {
    return environment.labels;
  }
  static transform(key) {
    switch (key) {
      case '@copy':
        return this.getCopy();
    }
    const labels = LabelPipe.labels;
    let label = labels[key] != null ? labels[key] : key; // `#${key}#`;
    if (typeof label === 'string' && label.indexOf('@copy') !== -1) {
      label = label.replace('@copy', this.getCopy());
    }
    return label;
  }
  static getKeys() {
    for (var _len = arguments.length, keys = new Array(_len), _key = 0; _key < _len; _key++) {
      keys[_key] = arguments[_key];
    }
    return LabelPipe.transform(keys.map(x => x.replace('-', '_')).join('_'));
  }
  static getCopy() {
    return `©${new Date().getFullYear()}`;
  }
}
LabelPipe.meta = {
  name: 'label'
};class LocationService {
  static has(key) {
    const params = new URLSearchParams(window.location.search);
    // console.log('LocationService.has', params);
    return params.has(key);
  }
  static get(key) {
    const params = new URLSearchParams(window.location.search);
    // console.log('LocationService.get', params);
    return params.get(key);
  }
  static set(keyOrValue, value) {
    const params = new URLSearchParams(window.location.search);
    if (typeof keyOrValue === 'string') {
      params.set(keyOrValue, value);
    } else {
      params.set(keyOrValue, '');
    }
    this.pushParams(params);
    // console.log('LocationService.set', params, keyOrValue, value);
  }

  static delete(key) {
    const params = new URLSearchParams(window.location.search);
    // console.log('LocationService.has', params);
    if (params.has(key)) {
      params.delete(key);
      this.pushParams(params);
    }
  }
  static pushParams(params) {
    if (window.history && window.history.pushState) {
      const title = document.title;
      const url = `${window.location.href.split('?')[0]}?${params.toString()}`;
      window.history.pushState(params.toString(), title, url);
    }
  }
  static replace(from, to) {
    const history = window.history;
    if (history && history.replaceState) {
      const location = window.location;
      const title = document.title;
      if (location.pathname === '/') {
        const url = location.origin + to + location.search;
        history.replaceState(history.state, title, url);
      } else if (location.href.indexOf(from) !== -1) {
        const url = location.href.replace(from, to);
        history.replaceState(history.state, title, url);
      }
    }
  }
  static deserialize(key) {
    const encoded = this.get('params');
    return this.decode(key, encoded);
  }
  static serialize(keyOrValue, value) {
    const params = this.deserialize();
    const encoded = this.encode(keyOrValue, value, params);
    this.set('params', encoded);
  }
  static decode(key, encoded) {
    let decoded = null;
    if (encoded) {
      const json = window.atob(encoded);
      decoded = JSON.parse(json);
    }
    if (key && decoded) {
      decoded = decoded[key];
    }
    return decoded || null;
  }
  static encode(keyOrValue, value, params) {
    params = params || {};
    let encoded = null;
    if (typeof keyOrValue === 'string') {
      params[keyOrValue] = value;
    } else {
      params = keyOrValue;
    }
    const json = JSON.stringify(params);
    encoded = window.btoa(json);
    return encoded;
  }
}class LanguageService {
  static get lang() {
    return this.lang$.getValue();
  }
  static set lang(lang) {
    if (this.lang !== lang) {
      this.lang$.next(lang);
    }
  }
  static setAlternates(language, alternates) {
    this.languages = alternates;
    this.lang = language;
    // console.log('LanguageService.setAlternates', language, alternates);
  }

  static setRoute(route, routes) {
    const language = route.params.lang;
    // console.log('LanguageService.setRoute', route, route.path, language);
    const alternates = environment.languages.map(lang => {
      const title = lang === 'it' ? 'Italiano' : 'English';
      // eslint-disable-next-line no-useless-escape
      const alternateName = route.name.replace(new RegExp(`(^${language}$)|(^${language}\.)`), (match, g1, g2, offset) => {
        // console.log('LanguageService.match', match, g1, g2, offset);
        return g1 ? lang : `${lang}.`;
      });
      const alternate = routes.find(x => x.name === alternateName);
      // console.log('LanguageService.alternate', lang, alternateName, alternate);
      if (alternate) {
        return {
          name: alternate.name,
          params: route.params,
          href: alternate.path,
          lang: alternate.defaultParams.lang,
          title
        };
      } else {
        return null;
      }
    }).filter(x => x !== null);
    this.setAlternates(language, alternates);
  }
  static get hasLanguages() {
    return this.languages.length > 1;
  }
  static get activeLanguage() {
    return this.languages.find(language => language.lang === this.lang);
  }
  static getDefaultLanguages() {
    return environment.alternates || [];
  }
  static getDefaultLanguage() {
    return environment.defaultLanguage || (this.languages ? this.languages[0].lang : null);
  }
  static setLanguage(language) {
    this.lang = language.lang;
  }
  static setLanguage$(language) {
    if (typeof language === 'string') {
      language = this.languages.find(x => x.lang === language);
    }
    if (!language) {
      return;
    }
    const url = environment.flags.production ? `/api/${language.lang}/labels/` : `./api/${language.lang}/labels.json`;
    return rxjs.from(fetch(url).then(response => {
      return response.json();
    })).pipe(operators.tap(labels => {
      environment.labels = labels;
      RouterService.replaceHistoryState(language.name, language.params);
      const from = this.activeLanguage.href.split('?')[0];
      const to = language.href.split('?')[0];
      LocationService.replace(from, to);
      this.lang = language.lang;
    }));
    /*
    return of(language).pipe(
    	tap(language => {
    		// LabelPipe.setLabels();
    		LocationService.replace(this.activeLanguage.href, language.href);
    		this.lang = language.lang;
    	}),
    );
    */
  }

  static setLanguage$_(language) {
    return rxjs.from(fetch(language.href).then(response => {
      return response.text();
    })).pipe(operators.tap(html => {
      // console.log('html', html);
      const labelsMatch = /(window\.labels\s*=\s*\n*\s*\{((\{.+?\})|.)+?\})/gms.exec(html);
      if (labelsMatch) {
        // console.log('labels', labelsMatch[0]);
        new Function(labelsMatch[0]).call(window);
        LabelPipe.setLabels();
      }
      const bhereMatch = /(window\.bhere\s*=\s*\n*\s*\{((\{.+?\})|.)+?\})/gms.exec(html);
      if (bhereMatch) {
        // console.log('bhere', bhereMatch[0]);
        const data = {};
        new Function(bhereMatch[0].replace('window', 'this')).call(data);
        if (data.bhere) {
          Utils.merge(environment, data.bhere);
        }
      }
      LocationService.replace(this.activeLanguage.href, language.href);
      // console.log(environment.labels);
      this.lang = language.lang;
    }));
  }
  static toggleLanguages() {
    this.showLanguages = !this.showLanguages;
    this.pushChanges();
  }
}
LanguageService.languages = LanguageService.getDefaultLanguages();
LanguageService.lang$ = new rxjs.BehaviorSubject(LanguageService.getDefaultLanguage());class RoutePipe extends rxcomp.Pipe {
  static transform(key) {
    return key.replace(':lang', LanguageService.lang);
  }
}
RoutePipe.meta = {
  name: 'route'
};const USE_AUTODETECT = false;
const USE_VOLUME_INDICATOR = false;
const VIDEO_PROFILES = [
/*
['120p_1', 160, 120, 15, 65, false]],
['120p_3', 120, 120, 15, 50, false]],
['180p_1', 320, 180, 15, 140, false]],
['180p_3', 180, 180, 15, 100, false]],
['180p_4', 240, 180, 15, 120, false]],
['240p_1', 320, 240, 15, 200, false]],
['240p_3', 240, 240, 15, 140, false]],
['240p_4', 424, 240, 15, 220, false]],
['360p_1', 640, 360, 15, 400, false]],
['360p_3', 360, 360, 15, 260, false]],
['360p_4', 640, 360, 30, 600, false]],
['360p_6', 360, 360, 30, 400, false]],
['360p_7', 480, 360, 15, 320, false]],
['360p_8', 480, 360, 30, 490, false]],
['360p_9', 640, 360, 15, 800, false]],
['360p_10', 640, 360, 24, 800, false]],
['360p_11', 640, 360, 24, 1000, false]],
*/
['480p_1', 640, 480, 15, 500, true], ['480p_2', 640, 480, 30, 1000, true], ['480p_3', 480, 480, 15, 400, true], ['480p_4', 640, 480, 30, 750, true], ['480p_6', 480, 480, 30, 600, true], ['480p_8', 848, 480, 15, 610, true], ['480p_9', 848, 480, 30, 930, true], ['480p_10', 640, 480, 10, 400, true], ['720p_1', 1280, 720, 15, 1130, true], ['720p_2', 1280, 720, 30, 2000, true], ['720p_3', 1280, 720, 30, 1710, true], ['720p_5', 960, 720, 15, 910, true], ['720p_6', 960, 720, 30, 1380, true], ['1080p_1', 1920, 1080, 15, 2080, false], ['1080p_2', 1920, 1080, 30, 3000, false], ['1080p_3', 1920, 1080, 30, 3150, false], ['1080p_5', 1920, 1080, 60, 4780, false]];
const StreamQualities = VIDEO_PROFILES.map(a => {
  return {
    profile: a[0],
    resolution: {
      width: a[1],
      height: a[2]
    },
    frameRate: {
      min: a[3],
      max: a[3]
    },
    bitrate: {
      min: a[4],
      max: a[4]
    },
    compatible: a[5]
  };
});

/*
export const StreamQualities = [{
	// id: 1,
	// name: '4K 2160p 3840x2160',
	profile: '4K',
	resolution: {
		width: 3840,
		height: 2160
	},
	frameRate: {
		min: 15,
		max: 30
	},
	bitrate: {
		min: 8910,
		max: 13500
	}
}, {
	// id: 2,
	// name: 'HD 1440p 2560×1440',
	profile: '1440p',
	resolution: {
		width: 2560,
		height: 1440
	},
	frameRate: {
		min: 15,
		max: 30
	},
	bitrate: {
		min: 4850,
		max: 7350
	}
}, {
	// id: 3,
	// name: 'HD 1080p 1920x1080',
	profile: '1080p',
	resolution: {
		width: 1920,
		height: 1080
	},
	frameRate: {
		min: 15,
		max: 30
	},
	bitrate: {
		min: 2080,
		max: 4780
	}
}, {
	// id: 4,
	// name: 'LOW 720p 1280x720',
	profile: '720p_3',
	resolution: {
		width: 1280,
		height: 720
	},
	frameRate: {
		min: 15,
		max: 30
	},
	bitrate: {
		min: 1130,
		max: 1710
	}
}, {
	// id: 5,
	// name: 'LOWEST 240p 320x240',
	profile: '240p_1',
	resolution: {
		width: 320,
		height: 240
	},
	frameRate: {
		min: 15,
		max: 15
	},
	bitrate: {
		min: 140,
		max: 200
	}
}];
*/

function getStreamQuality(state) {
  let profile = environment.profiles.streamer;
  switch (state.role) {
    case RoleType.Publisher:
    case RoleType.SmartDevice:
      profile = environment.profiles.publisher || environment.profiles.streamer;
      break;
    case RoleType.Attendee:
      profile = environment.profiles.attendee || environment.profiles.streamer;
      break;
  }
  return StreamQualities.find(x => x.profile === profile);
}

/*
export function getStreamQuality(state) {
	const lowestQuality = StreamQualities[StreamQualities.length - 1];
	const highestQuality = environment.flags.maxQuality ? StreamQualities[0] : StreamQualities[StreamQualities.length - 2];
	return (state.role === RoleType.Publisher || state.role === RoleType.SmartDevice) ? highestQuality : lowestQuality;
}
*/

const AgoraStatus = {
  Idle: 'idle',
  Checklist: 'checklist',
  Link: 'link',
  Login: 'login',
  Name: 'name',
  Device: 'device',
  ShouldConnect: 'should-connect',
  Connecting: 'connecting',
  Connected: 'connected',
  Disconnected: 'disconnected'
};
const MessageType = {
  AddLike: 'addLike',
  AgoraEvent: 'agoraEvent',
  ChannelMembers: 'channelMembers',
  ChatMessage: 'chatMessage',
  ChatTypingBegin: 'chatTypingBegin',
  ChatTypingEnd: 'chatTypingEnd',
  ControlInfo: 'controlInfo',
  CurrentTimeMedia: 'currentTimeMedia',
  MenuToggle: 'menuToggle',
  Mode: 'mode',
  NavInfo: 'navInfo',
  NavLink: 'navLink',
  NavLinkClose: 'navLinkClose',
  NavToGrid: 'navToGrid',
  NavToView: 'navToView',
  Ping: 'ping',
  PlayMedia: 'playMedia',
  PlayModel: 'playModel',
  RemoteSilencing: 'remoteSilencing',
  RequestControl: 'requestControl',
  RequestControlDismiss: 'requestControlDismiss',
  RequestSpy: 'requestSpy',
  RequestSpyDismiss: 'requestSpyDismiss',
  SelectItem: 'selectItem',
  SetSnapshot: 'setSnapshot',
  ShowPanel: 'showPanel',
  SlideChange: 'slideChange',
  SupportRequest: 'supportRequest',
  SupportRequestAccepted: 'supportRequestAccepted',
  SupportRequestRejected: 'supportRequestRejected',
  VREnded: 'vrEnded',
  VRStarted: 'vrStarted',
  VRState: 'vrState',
  ZoomMedia: 'zoomMedia'
};
const UIMode = {
  VirtualTour: 'virtual-tour',
  LiveMeeting: 'live-meeting',
  SelfServiceTour: 'self-service-tour',
  Embed: 'embed',
  None: 'none'
};
class AgoraEvent {
  constructor(options) {
    Object.assign(this, options);
  }
}
class AgoraPeerEvent extends AgoraEvent {}
class AgoraRemoteEvent extends AgoraEvent {}
class AgoraUserInfoUpdateEvent extends AgoraEvent {}
class AgoraMuteVideoEvent extends AgoraEvent {}
class AgoraUnmuteVideoEvent extends AgoraEvent {}
class AgoraMuteAudioEvent extends AgoraEvent {}
class AgoraUnmuteAudioEvent extends AgoraEvent {}
class AgoraVolumeLevelsEvent extends AgoraEvent {}class HttpService {
  static http$(method, url, data, format) {
    const methods = ['POST', 'PUT', 'PATCH'];
    let response_ = null;
    // url = this.getUrl(url, format);
    return rxjs.from(fetch(url, {
      method: method,
      headers: {
        'Accept': 'application/json',
        'Content-Type': 'application/json'
      },
      body: methods.indexOf(method) !== -1 ? JSON.stringify(data) : undefined
    }).then(response => {
      response_ = response;
      // console.log(response);
      try {
        const contentType = response.headers.get('content-type');
        let typedResponse;
        if (contentType && contentType.indexOf('application/json') !== -1) {
          typedResponse = response.json();
        } else {
          typedResponse = response.text();
        }
        if (response.ok) {
          return typedResponse;
        } else {
          return typedResponse.then(data => {
            return Promise.reject(data);
          });
        }
      } catch (error) {
        if (response.ok) {
          console.warn('HttpService.http$', 'Cannot parse response');
          return Promise.resolve();
        } else {
          return Promise.reject(error);
        }
      }
    })).pipe(operators.catchError(error => {
      return rxjs.throwError(this.getError(error, response_));
    }));
  }

  /*
  // !!! todo mapping response.data
  static http$(method, url, data, format = 'json') {
  	const methods = ['POST', 'PUT', 'PATCH'];
  	const body = (data && methods.indexOf(method) !== -1) ? JSON.stringify(data) : undefined;
  	const queryString = (data && methods.indexOf(method) !== -1) ? Object.keys(data).map(function(key) {
  		return key + '=' + encodeURI(data[key]);
  	}).join('&') : undefined;
  	if (queryString) {
  		url = `${url}?${queryString}`;
  	}
  	let response_ = null;
  	return from(fetch(url, {
  		method: method,
  		headers: {
  			'Accept': 'application/json',
  			'Content-Type': 'application/json',
  		},
  		body: body,
  	}).then((response) => {
  		response_ = new HttpResponse(response);
  		try {
  			const contentType = response.headers.get('content-type');
  			let typedResponse;
  			if (contentType && format === 'json' && contentType.indexOf('application/json') !== -1) {
  				typedResponse = response.json();
  			} else if (format === 'blob') {
  				typedResponse = response.blob();
  			} else {
  				typedResponse = response.text();
  			}
  			return typedResponse.then(data => {
  				response_.data = data;
  				if (response.ok) {
  					return Promise.resolve(response_);
  				} else {
  					return Promise.reject(response_);
  				}
  			});
  		} catch(error) {
  			if (response.ok) {
  				console.warn('HttpService.http$', 'Cannot parse response');
  				return Promise.resolve(response_);
  			} else {
  				return Promise.reject(this.getError(error, response_));
  			}
  		}
  	})).pipe(
  		catchError(error => {
  			return throwError(this.getError(error, response_));
  		}),
  	);
  }
  */

  static get$(url, data, format) {
    const query = this.query(data);
    return this.http$('GET', `${url}${query}`, undefined, format);
  }
  static delete$(url) {
    return this.http$('DELETE', url);
  }
  static post$(url, data) {
    return this.http$('POST', url, data);
  }
  static put$(url, data) {
    return this.http$('PUT', url, data);
  }
  static patch$(url, data) {
    return this.http$('PATCH', url, data);
  }
  static query(data) {
    return ''; // todo
  }

  static getError(object, response) {
    let error = typeof object === 'object' ? object : {};
    if (!error.status) {
      error.status = response ? response.status : 0;
    }
    if (!error.statusCode) {
      error.statusCode = response ? response.status : 0;
    }
    if (!error.statusMessage) {
      error.statusMessage = response ? response.statusText : object;
    }
    // console.log('HttpService.getError', error, object);
    return error;
  }
}class UserService {
  static setUser(user) {
    this.user$.next(user);
  }
  static me$() {
    return HttpService.get$('/api/user/me').pipe(operators.map(user => this.mapUser(user)), operators.catchError(error => {
      // console.log('UserService.me$.error', error);
      if (error.status === 404 || error.statusCode === 404) {
        return rxjs.of(null);
      } else {
        throw error;
      }
    }), operators.switchMap(user => {
      this.setUser(user);
      return this.user$;
    }));
  }
  static login$(payload) {
    return HttpService.post$('/api/user/login', payload).pipe(operators.map(user => this.mapUser(user)), operators.tap(user => this.setUser(user)));
  }
  static logout$() {
    return HttpService.get$('/api/user/logout').pipe(operators.map(user => this.mapUser(user)), operators.tap(user => this.setUser(null)));
  }
  static guidedTour$(payload) {
    return HttpService.post$('/api/user/guided-tour', payload).pipe(operators.map(user => this.mapUser(user)), operators.tap(user => this.setUser(user)));
  }
  static selfServiceTour$(payload) {
    return HttpService.post$('/api/user/self-service-tour', payload).pipe(operators.map(user => this.mapUser(user)), operators.tap(user => this.setUser(user)));
  }
  static selfServiceSupportRequest$(user, meetingId, link) {
    const payload = {
      user,
      meetingId,
      link
    };
    return HttpService.post$('/api/user/self-service-support-request', payload).pipe(operators.tap(_ => {
      if (!environment.flags.production) {
        fetch(environment.template.email.supportRequest).then(response => response.text()).then(html => {
          html = html.replace('{{username}}', MeetingUrl.getName(user));
          html = html.replace('{{href}}', link);
          const parser = new DOMParser();
          const newDocument = parser.parseFromString(html, 'text/html');
          setTimeout(() => {
            // const newWindow = window.open(window.location.origin + environment.template.email.supportRequest, '_blank');
            const newWindow = window.open();
            newWindow.document.head.innerHTML = newDocument.querySelector('head').innerHTML;
            newWindow.document.body.innerHTML = newDocument.querySelector('body').innerHTML;
          }, 3000);
        });
      }
    }));
  }
  static resolve$(payload, status) {
    if (status === 'login') {
      return this.login$(payload);
    }
    if (status === 'guided-tour') {
      return this.guidedTour$(payload);
    }
    if (status === 'self-service-tour') {
      return this.selfServiceTour$(payload);
    }
  }
  static log$(payload) {
    return HttpService.post$('/api/user/log', payload);
  }
  static temporaryUser$(roleType) {
    if (roleType === void 0) {
      roleType = RoleType.Embed;
    }
    return rxjs.of({
      id: this.uuid(),
      type: roleType,
      username: roleType
      // firstName: 'Jhon',
      // lastName: 'Appleseed',
    }).pipe(operators.map(user => this.mapUser(user)), operators.switchMap(user => {
      // console.log('UserService.temporaryUser$', user);
      this.setUser(user);
      return this.user$;
    }));
  }
  static overrideUser$(roleType) {
    if (roleType === void 0) {
      roleType = RoleType.Embed;
    }
    return this.me$().pipe(operators.switchMap(user => {
      if (user) {
        user.type = roleType;
        user.username = roleType;
        return this.user$;
      }
      return this.temporaryUser$(roleType);
    }));
  }
  static uuid() {
    return new Date().getTime();
    // return parseInt(process.hrtime.bigint().toString());
  }

  /*
  static retrieve$(payload) {
  	return HttpService.post$('/api/user/retrievepassword', payload).pipe(
  		map((user) => this.mapUser(user)),
  	);
  }
  
  static register$(payload) {
  	return HttpService.post$('/api/user/register', payload).pipe(
  		map((user) => this.mapUser(user)),
  	);
  }
  
  static update(payload) {
  	return HttpService.post$('/api/user/updateprofile', payload).pipe(
  		map((user) => this.mapUser(user)),
  	);
  }
  */

  static mapUser(user) {
    return new User(user);
  }
  static getMode(role) {
    let mode;
    switch (role) {
      case RoleType.Attendee:
      case RoleType.Streamer:
      case RoleType.Viewer:
      case RoleType.Publisher:
        mode = UIMode.VirtualTour;
        break;
      case RoleType.SelfService:
        mode = UIMode.SelfServiceTour;
        break;
      case RoleType.SmartDevice:
        mode = UIMode.LiveMeeting;
        break;
      case RoleType.Embed:
        mode = UIMode.Embed;
        break;
      default:
        mode = UIMode.None;
    }
    // console.log('UserService.getMode', role, mode);
    return mode;
  }
}
UserService.user$ = new rxjs.BehaviorSubject(null);let UID$2 = 0;
class WebhookEvent {
  constructor(options) {
    if (options) {
      Object.assign(this, options);
    }
  }
  toJson() {
    return JSON.stringify(this);
  }
  static newEvent(action, data, extra) {
    console.log('WebhookEvent.newEvent', action, data, extra);
    const event = new WebhookEvent();
    const timestamp = new Date().getTime();
    event.timestamp = timestamp;
    event.id = `${timestamp}-${++UID$2}`;
    event.action = action;
    event.data = data;
    if (extra) {
      event.extra = typeof extra === 'string' ? JSON.parse(extra) : extra;
    }
    if (StateService.state.link) {
      // ( meetingId, userSessionId, userRole, fullName, itemId, skuId, action:InfoPoint  )
      event.meetingId = StateService.state.link;
      event.userSessionId = StateService.state.uid;
      event.userRole = StateService.state.role;
      event.fullName = StateService.state.name;
    }
    return event;
  }
  static parseEvent(event) {
    if (event && 'data' in event) {
      const message = typeof event.data === 'string' ? JSON.parse(event.data) : event.data;
      if ('action' in message) {
        return new WebhookEvent(message);
      } else {
        return null;
      }
    } else {
      return null;
    }
  }
}
class WebhookService {
  static internal$_(event) {
    return rxjs.of(event).pipe(operators.tap(event => {
      console.log('WebhookService.internal$_.postMessage', event);
      if (window.parent) {
        window.parent.postMessage(event.action, event.toJson());
      }
    }), operators.switchMap(event => {
      return this.event$_.pipe(operators.filter(event => event.id === event.id), operators.first());
    }), operators.map(response => {
      console.log('WebhookService.internal$_.handleResponse_', event, response);
      return this.handleResponse_(event, response);
    }), operators.catchError(error => {
      return this.handleError_(event, error);
    }));
  }
  static send$_(uri, event) {
    return HttpService.post$(uri, event).pipe(operators.map(response => {
      return this.handleResponse_(event, response);
    }), operators.catchError(error => {
      return this.handleError_(event, error);
    }));
  }
  static send$(action, payload, extra) {
    console.log('WebhookService.send$', action, payload, extra);
    if (this.enabled) {
      const event = WebhookEvent.newEvent(action, payload, extra);
      const uris = environment.webhook.uris;
      const observables = uris.map(x => x === 'internal' ? this.internal$_(event) : this.send$_(x, event));
      return rxjs.forkJoin(observables);
      /*
      return combineLatest(observables).pipe(
      	map(results => {
      		const result = results.find((x, i) => uris[i] !== 'internal');
      		return result;
      	}),
      );
      return merge(observables);
      */
    } else {
      return rxjs.of(null);
    }
  }
  static handleResponse_(event, remoteResponse) {
    console.log('WebhookService.handleResponse_', remoteResponse);
    const response = Object.assign({}, event);
    response.remoteStatus = 1;
    response.remoteResponse = remoteResponse;
    return response;
  }
  static handleError_(event, error) {
    const response = Object.assign({}, event);
    response.remoteStatus = 0;
    response.remoteError = error;
    return rxjs.of(response);
  }
  static get enabled() {
    const webhook = environment.webhook;
    const enabled = webhook && webhook.uris && webhook.uris.length > 0;
    if (enabled) {
      webhook.methods = webhook.methods || {};
      webhook.methods.nav = webhook.methods.nav || [];
    }
    return enabled;
  }
}
WebhookService.event$_ = rxjs.fromEvent(window, 'message').pipe(operators.map(event => {
  const parsedEvent = WebhookEvent.parseEvent(event);
  return parsedEvent;
}), operators.filter(x => x !== null), operators.shareReplay(1));class AccessComponent extends rxcomp.Component {
  onInit() {
    // console.log('AccessComponent.onInit');
    this.state = {
      status: 'access'
    };
    window.onSSOPopupClose = status => {
      if (status === 'success') {
        alert('Login Successful');
        UserService.me$().pipe(operators.first()).subscribe(user => {
          // console.log('AccessComponent.onInit.onSSOPopupClose', user);
          const routeUrl = RoutePipe.transform(':lang.selfServiceTour');
          const pathId = environment.pathMapper && environment.pathMapper.ssoLogin ? environment.pathMapper.ssoLogin(user) : null;
          if (pathId) {
            RouterService.setRouterLink(routeUrl, MeetingUrl.validateParams({
              pathId
            }));
          } else {
            RouterService.setRouterLink(routeUrl);
          }
        });
      } else {
        alert('Login Failed');
      }
    };
  }
  onSelfServiceTourRequest() {
    this.initRequestForm();
    this.state.status = 'self-service-tour';
    this.pushChanges();
    if (STATIC && window.navigator.userAgent.indexOf('OculusBrowser') !== -1) {
      this.test();
      this.onSubmit();
    }
  }
  onGuidedTourRequest() {
    this.initRequestForm();
    this.state.status = 'guided-tour';
    this.pushChanges();
  }
  onSSOLogin(event) {
    const loginUrl = `${location.protocol}//${location.host}/sso/login`;
    window.open(loginUrl, 'BHere | SSO Login', 'left=20,top=20,width=600,height=600,toolbar=1,resizable=0');
    event.preventDefault();
    return false;
  }
  onSSORegister(event) {
    const loginUrl = `${location.protocol}//${location.host}/sso/register`;
    window.open(loginUrl, 'BHere | SSO Register', 'left=20,top=20,width=600,height=600,toolbar=1,resizable=0');
    event.preventDefault();
    return false;
  }
  onGuidedTourAccess() {
    UserService.logout$().pipe(operators.first()).subscribe(() => {
      RouterService.setRouterLink(RoutePipe.transform(':lang.guidedTour'));
    });
  }
  onLogin() {
    this.initLoginForm();
    this.state.status = 'login';
    this.pushChanges();
  }
  initRequestForm() {
    if (this.formSubscription) {
      this.formSubscription.unsubscribe();
    }
    const data = this.data = environment.data || {
      roles: [{
        id: 1,
        name: 'Show room'
      }, {
        id: 2,
        name: 'Architetto'
      }, {
        id: 3,
        name: 'Interior designer'
      }, {
        id: 4,
        name: 'Privato'
      }, {
        id: 5,
        name: 'Altro'
      }]
    };
    const fields = this.fields = environment.fields || [{
      type: 'text',
      name: 'firstName',
      label: 'access_first_name',
      required: true,
      test: 'Jhon'
    }, {
      type: 'text',
      name: 'lastName',
      label: 'access_last_name',
      required: true,
      test: 'Appleseed'
    }, {
      type: 'email',
      name: 'email',
      label: 'access_email',
      required: true,
      test: 'jhonappleseed@gmail.com'
    }, {
      type: 'custom-select',
      name: 'role',
      label: 'access_role',
      required: true,
      options: data.roles,
      test: data.roles[0].id
    }, {
      type: 'checkbox',
      name: 'privacy',
      label: 'access_privacy_disclaimer',
      required: true,
      test: true
    }];
    fields.push({
      type: 'hidden',
      name: 'checkField',
      value: '',
      test: ''
    });
    if (environment.antiforgery) {
      fields.push({
        type: 'none',
        name: 'checkRequest',
        value: environment.antiforgery,
        test: environment.antiforgery
      });
    }
    const form = this.form = fieldsToFormGroup(fields);
    this.controls = form.controls;
    this.formSubscription = form.changes$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(changes => {
      this.pushChanges();
    });
    this.error = null;
  }
  initLoginForm() {
    if (this.formSubscription) {
      this.formSubscription.unsubscribe();
    }
    const form = this.form = new rxcompForm.FormGroup({
      username: new rxcompForm.FormControl(null, rxcompForm.Validators.RequiredValidator()),
      password: new rxcompForm.FormControl(null, rxcompForm.Validators.RequiredValidator()),
      checkRequest: window.antiforgery || '',
      checkField: ''
    });
    this.controls = form.controls;
    this.formSubscription = form.changes$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(changes => {
      this.pushChanges();
    });
    this.error = null;
  }
  test() {
    if (this.state.status === 'login') {
      this.form.patch({
        username: 'publisher',
        password: 'publisher',
        checkRequest: window.antiforgery || '',
        checkField: ''
      });
    } else {
      patchFields(this.fields, this.form);
    }
  }
  reset() {
    this.form.reset();
  }
  onBack() {
    this.state.status = 'access';
    this.pushChanges();
  }
  onSubmit() {
    if (this.form.valid) {
      this.form.submitted = true;
      const payload = this.form.value;
      const webhookPayload = _objectSpread2({}, payload);
      const controls = this.controls;
      Object.keys(webhookPayload).forEach(key => {
        if (controls[key].options) {
          const options = controls[key].options;
          webhookPayload[key] = options.find(option => option.id === webhookPayload[key]).name;
        }
      });
      const status = this.state.status;
      UserService.resolve$(payload, status).pipe(operators.first()).subscribe(user => {
        // console.log('AccessComponent.onSubmit', user);
        switch (status) {
          case 'guided-tour':
            this.onHandleHook('GuidedTour', webhookPayload).pipe(operators.first()).subscribe(response => {
              this.state.status = 'guided-tour-success';
              this.pushChanges();
            });
            break;
          case 'self-service-tour':
            this.onHandleHook('SelfServiceTour', webhookPayload).pipe(operators.first()).subscribe(response => {
              const routeUrl = RoutePipe.transform(':lang.selfServiceTour');
              const pathId = environment.pathMapper && environment.pathMapper.selfService ? environment.pathMapper.selfService(user) : null;
              if (pathId) {
                RouterService.setRouterLink(routeUrl, MeetingUrl.validateParams({
                  pathId
                }));
              } else {
                RouterService.setRouterLink(routeUrl);
              }
            });
            break;
          case 'login':
            RouterService.setRouterLink(RoutePipe.transform(':lang.guidedTour'));
            break;
        }
        this.form.reset();
      }, error => {
        console.log('AccessComponent.error', error);
        this.error = error;
        this.pushChanges();
      });
    } else {
      this.form.touched = true;
    }
  }
  isValid() {
    const isValid = this.form.valid;
    return isValid;
  }
  onHandleHook(action, values) {
    const payload = values;
    const extra = null;
    return WebhookService.send$(action, payload, extra);
  }
}
AccessComponent.meta = {
  selector: '[access-component]',
  hosts: {
    host: RouterOutletStructure
  },
  template: /*html*/`
		<div class="page page--access">
			<!-- background -->
			<div class="background" [class]="{ 'background--image': ('background.image' | env), 'background--video': ('background.video' | env) }" *if="state.status != 'connected'">
				<img [src]="'background.image' | env | asset" *if="'background.image' | env" />
				<video [src]="'background.video' | env | asset" *if="'background.video' | env" oncanplay="this.muted = true; this.classList.add('ready');" playsinline autoplay muted loop></video>
			</div>
			<!-- access -->
			<div class="ui ui--info ui--info-centered" *if="state.status == 'access'">
				<div class="group--info">
					<div class="group--info__content stagger--childs">
						<div class="title" [innerHTML]="'access_title' | label"></div>
						<div *if="'selfService' | flag">
							<button type="button" class="btn--next" (click)="onSelfServiceTourRequest($event)">
								<span [innerHTML]="'access_tour' | label"></span>
							</button>
						</div>
						<div *if="'guidedTourRequest' | flag">
							<div class="info" [innerHTML]="'access_or' | label"></div>
							<button type="button" class="btn--next" (click)="onGuidedTourRequest($event)">
								<span [innerHTML]="'access_guided_tour' | label"></span>
							</button>
						</div>
						<div *if="'guidedTourAccess' | flag">
							<div class="info" [innerHTML]="'access_has_meeting_id' | label"></div>
							<button type="button" class="btn--next" (click)="onGuidedTourAccess($event)">
								<span [innerHTML]="'access_guided_tour_cta' | label"></span>
							</button>
						</div>
						<div *if="'ssoLogin' | flag">
							<div class="info" [innerHTML]="'access_sso_login_info' | label"></div>
							<button type="button" class="btn--next" (click)="onSSOLogin($event)">
								<span [innerHTML]="'access_sso_login_cta' | label"></span>
							</button>
						</div>
						<div *if="'ssoRegister' | flag">
							<div class="info" [innerHTML]="'access_sso_register_info' | label"></div>
							<button type="button" class="btn--next" (click)="onSSORegister($event)">
								<span [innerHTML]="'access_sso_register_cta' | label"></span>
							</button>
						</div>
					</div>
				</div>
			</div>
			<!-- guided-tour -->
			<div class="ui ui--info" *if="state.status == 'self-service-tour' || state.status == 'guided-tour'">
				<div class="group--info">
					<form class="form" [formGroup]="form" (submit)="isValid() && onSubmit()" name="form" role="form" novalidate autocomplete="off">
						<div class="group--info__content stagger--childs">
							<div class="title" *if="state.status == 'self-service-tour'" [innerHTML]="'access_fill_fields' | label"></div>
							<div class="title" *if="state.status == 'guided-tour'" [innerHTML]="'access_guided_tour_request' | label"></div>
							<!-- controls -->
							<div controls [formGroup]="form" [fields]="fields"></div>
							<div class="group--error" *if="error">
								<span class="status-code" [innerHTML]="error.statusCode"></span>
								<span class="status-message" [innerHTML]="error.statusMessage"></span>
								<span class="friendly-message" [innerHTML]="error.friendlyMessage"></span>
							</div>
							<!-- <div class="info" *if="isValid()" [innerHTML]="'access_take_part' | label"></div> -->
							<button type="submit" class="btn--next" [class]="{ disabled: !isValid() }">
								<span *if="!form.submitted" [innerHTML]="'access_send' | label"></span>
								<span *if="form.submitted" [innerHTML]="'access_sent' | label"></span>
							</button>
							<button type="button" class="btn--mode" (click)="onBack($event)">
								<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#arrow-prev"></use></svg>
								<span [innerHTML]="'access_back' | label"></span>
							</button>
							<test-component [form]="form" (test)="test($event)" (reset)="reset($event)"></test-component>
						</div>
					</form>
				</div>
			</div>
			<!-- guided-tour success -->
			<div class="ui ui--info ui--info-centered" *if="state.status == 'guided-tour-success'">
				<div class="group--info">
					<div class="group--info__content stagger--childs">
						<div class="title" [innerHTML]="'access_request_sent' | label"></div>
						<div class="info" [innerHTML]="'access_info_request' | label"></div>
						<button type="button" class="btn--mode" (click)="onBack($event)">
							<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#arrow-prev"></use></svg>
							<span [innerHTML]="'access_back' | label"></span>
						</button>
					</div>
				</div>
			</div>
			<!-- login -->
			<div class="ui ui--info ui--info-centered" *if="state.status == 'login'">
				<div class="group--info">
					<form class="form" [formGroup]="form" (submit)="isValid() && onSubmit()" name="form" role="form" novalidate autocomplete="off">
						<div class="group--info__content stagger--childs">
							<div class="title" [innerHTML]="'access_login' | label"></div>
							<input name="checkField" [formControl]="controls.checkField" value="" type="text" style="display:none !important;" />
							<div control-text [control]="controls.username" [label]="'access_username' | label"></div>
							<div control-password [control]="controls.password" [label]="'access_password' | label"></div>
							<div class="group--error" *if="error">
								<span class="status-code" [innerHTML]="error.statusCode"></span>
								<span class="status-message" [innerHTML]="error.statusMessage"></span>
								<span class="friendly-message" [innerHTML]="error.friendlyMessage"></span>
							</div>
							<div class="info" *if="isValid()" [innerHTML]="'access_cta' | label"></div>
							<button type="submit" class="btn--next" [class]="{ disabled: !isValid() }">
								<span [innerHTML]="'access_cta' | label"></span>
							</button>
							<button type="button" class="btn--mode" (click)="onBack($event)">
								<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#arrow-prev"></use></svg>
								<span [innerHTML]="'access_back' | label"></span>
							</button>
							<test-component [form]="form" (test)="test($event)" (reset)="reset($event)"></test-component>
						</div>
					</form>
				</div>
			</div>
			<header>
				<!-- logo -->
				<div class="btn--logo" (click)="onBack($event)">
					<img [src]="'logo' | env" *if="'logo' | env" />
					<svg viewBox="0 0 270 98" *if="!('logo' | env)"><use xlink:href="#b-here"></use></svg>
				</div>
				${CHUNK_LANGUAGE}
			</header>
			<footer>
				<span class="group--colophon" *if="state.status != 'connected'">
					${CHUNK_CREDITS}
					${CHUNK_COPYRIGHT}
				</span>
				<!-- login -->
				<button type="button" class="btn--absolute" (click)="onLogin($event)" *if="state.status == 'access'">
					<span [innerHTML]="'access_cta' | label"></span> <svg class="lock" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#lock"></use></svg>
				</button>
			</footer>
		</div>
	`
};class EmojiService {
  static emoji$() {
    if (EmojiService.items_ != null) {
      return rxjs.of(EmojiService.items_);
    }
    return HttpService.get$(`${environment.assets}api/emoji/emoji.json`).pipe(operators.map(items => {
      // items = items.slice(0, Math.min(80, items.length));
      EmojiService.items_ = items;
      return items;
    }));
  }
}class AgoraChatEmojiComponent extends rxcomp.Component {
  onInit() {
    this.items = [];
    EmojiService.emoji$().pipe(operators.first()).subscribe(items => {
      setTimeout(() => {
        this.items = items;
        this.pushChanges();
      }, 1);
    });
  }
  onSelect(item) {
    this.emoji.next(item);
  }
  onClose(_) {
    this.close.next();
  }
}
AgoraChatEmojiComponent.meta = {
  selector: '[agora-chat-emoji]',
  outputs: ['emoji', 'close']
};class MessageService {
  static message(message) {
    this.message$.next(message);
  }
  static in(message) {
    // console.log('MessageService.in', message);
    this.in$.next(message);
  }
  static sendBack(message) {
    message = Object.assign({}, message, {
      remoteId: message.clientId
    });
    // console.log('MessageService.sendBack', message);
    this.in$.next(message);
  }
  static out(message) {
    this.out$.next(message);
  }
}
MessageService.message$ = new rxjs.ReplaySubject(1);
MessageService.in$ = new rxjs.ReplaySubject(1);
MessageService.send = MessageService.in;
MessageService.out$ = new rxjs.ReplaySubject(1);var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}var AgoraRTC_NProduction = {exports: {}};/**
 * AgoraWebSDK_N-v4.19.3-0-gb2ca8ca7 Copyright AgoraInc.
 */

(function (module, exports) {
!function(e,t){module.exports=t();}(commonjsGlobal,(function(){function e(e,t){return t.forEach((function(t){t&&"string"!=typeof t&&!Array.isArray(t)&&Object.keys(t).forEach((function(i){if("default"!==i&&!(i in e)){var n=Object.getOwnPropertyDescriptor(t,i);Object.defineProperty(e,i,n.get?n:{enumerable:!0,get:function(){return t[i]}});}}));})),Object.freeze(e)}let t=!0,i=!0;function n(e,t,i){const n=e.match(t);return n&&n.length>=i&&parseInt(n[i],10)}function r(e,t,i){if(!e.RTCPeerConnection)return;const n=e.RTCPeerConnection.prototype,r=n.addEventListener;n.addEventListener=function(e,n){if(e!==t)return r.apply(this,arguments);const s=e=>{const t=i(e);t&&(n.handleEvent?n.handleEvent(t):n(t));};return this._eventMap=this._eventMap||{},this._eventMap[t]||(this._eventMap[t]=new Map),this._eventMap[t].set(n,s),r.apply(this,[e,s])};const s=n.removeEventListener;n.removeEventListener=function(e,i){if(e!==t||!this._eventMap||!this._eventMap[t])return s.apply(this,arguments);if(!this._eventMap[t].has(i))return s.apply(this,arguments);const n=this._eventMap[t].get(i);return this._eventMap[t].delete(i),0===this._eventMap[t].size&&delete this._eventMap[t],0===Object.keys(this._eventMap).length&&delete this._eventMap,s.apply(this,[e,n])},Object.defineProperty(n,"on"+t,{get(){return this["_on"+t]},set(e){this["_on"+t]&&(this.removeEventListener(t,this["_on"+t]),delete this["_on"+t]),e&&this.addEventListener(t,this["_on"+t]=e);},enumerable:!0,configurable:!0});}function s(e){return "boolean"!=typeof e?new Error("Argument type: "+typeof e+". Please use a boolean."):(t=e,e?"adapter.js logging disabled":"adapter.js logging enabled")}function o(e){return "boolean"!=typeof e?new Error("Argument type: "+typeof e+". Please use a boolean."):(i=!e,"adapter.js deprecation warnings "+(e?"disabled":"enabled"))}function a(){if("object"==typeof window){if(t)return;"undefined"!=typeof console&&"function"==typeof console.log&&console.log.apply(console,arguments);}}function c(e,t){i&&console.warn(e+" is deprecated, please use "+t+" instead.");}function d(e){return "[object Object]"===Object.prototype.toString.call(e)}function l(e){return d(e)?Object.keys(e).reduce((function(t,i){const n=d(e[i]),r=n?l(e[i]):e[i],s=n&&!Object.keys(r).length;return void 0===r||s?t:Object.assign(t,{[i]:r})}),{}):e}function h(e,t,i){t&&!i.has(t.id)&&(i.set(t.id,t),Object.keys(t).forEach((n=>{n.endsWith("Id")?h(e,e.get(t[n]),i):n.endsWith("Ids")&&t[n].forEach((t=>{h(e,e.get(t),i);}));})));}function u(e,t,i){const n=i?"outbound-rtp":"inbound-rtp",r=new Map;if(null===t)return r;const s=[];return e.forEach((e=>{"track"===e.type&&e.trackIdentifier===t.id&&s.push(e);})),s.forEach((t=>{e.forEach((i=>{i.type===n&&i.trackId===t.id&&h(e,i,r);}));})),r}const p=a;function _(e,t){const i=e&&e.navigator;if(!i.mediaDevices)return;const n=function(e){if("object"!=typeof e||e.mandatory||e.optional)return e;const t={};return Object.keys(e).forEach((i=>{if("require"===i||"advanced"===i||"mediaSource"===i)return;const n="object"==typeof e[i]?e[i]:{ideal:e[i]};void 0!==n.exact&&"number"==typeof n.exact&&(n.min=n.max=n.exact);const r=function(e,t){return e?e+t.charAt(0).toUpperCase()+t.slice(1):"deviceId"===t?"sourceId":t};if(void 0!==n.ideal){t.optional=t.optional||[];let e={};"number"==typeof n.ideal?(e[r("min",i)]=n.ideal,t.optional.push(e),e={},e[r("max",i)]=n.ideal,t.optional.push(e)):(e[r("",i)]=n.ideal,t.optional.push(e));}void 0!==n.exact&&"number"!=typeof n.exact?(t.mandatory=t.mandatory||{},t.mandatory[r("",i)]=n.exact):["min","max"].forEach((e=>{void 0!==n[e]&&(t.mandatory=t.mandatory||{},t.mandatory[r(e,i)]=n[e]);}));})),e.advanced&&(t.optional=(t.optional||[]).concat(e.advanced)),t},r=function(e,r){if(t.version>=61)return r(e);if((e=JSON.parse(JSON.stringify(e)))&&"object"==typeof e.audio){const t=function(e,t,i){t in e&&!(i in e)&&(e[i]=e[t],delete e[t]);};t((e=JSON.parse(JSON.stringify(e))).audio,"autoGainControl","googAutoGainControl"),t(e.audio,"noiseSuppression","googNoiseSuppression"),e.audio=n(e.audio);}if(e&&"object"==typeof e.video){let s=e.video.facingMode;s=s&&("object"==typeof s?s:{ideal:s});const o=t.version<66;if(s&&("user"===s.exact||"environment"===s.exact||"user"===s.ideal||"environment"===s.ideal)&&(!i.mediaDevices.getSupportedConstraints||!i.mediaDevices.getSupportedConstraints().facingMode||o)){let t;if(delete e.video.facingMode,"environment"===s.exact||"environment"===s.ideal?t=["back","rear"]:"user"!==s.exact&&"user"!==s.ideal||(t=["front"]),t)return i.mediaDevices.enumerateDevices().then((i=>{let o=(i=i.filter((e=>"videoinput"===e.kind))).find((e=>t.some((t=>e.label.toLowerCase().includes(t)))));return !o&&i.length&&t.includes("back")&&(o=i[i.length-1]),o&&(e.video.deviceId=s.exact?{exact:o.deviceId}:{ideal:o.deviceId}),e.video=n(e.video),p("chrome: "+JSON.stringify(e)),r(e)}))}e.video=n(e.video);}return p("chrome: "+JSON.stringify(e)),r(e)},s=function(e){return t.version>=64?e:{name:{PermissionDeniedError:"NotAllowedError",PermissionDismissedError:"NotAllowedError",InvalidStateError:"NotAllowedError",DevicesNotFoundError:"NotFoundError",ConstraintNotSatisfiedError:"OverconstrainedError",TrackStartError:"NotReadableError",MediaDeviceFailedDueToShutdown:"NotAllowedError",MediaDeviceKillSwitchOn:"NotAllowedError",TabCaptureError:"AbortError",ScreenCaptureError:"AbortError",DeviceCaptureError:"AbortError"}[e.name]||e.name,message:e.message,constraint:e.constraint||e.constraintName,toString(){return this.name+(this.message&&": ")+this.message}}};if(i.getUserMedia=function(e,t,n){r(e,(e=>{i.webkitGetUserMedia(e,t,(e=>{n&&n(s(e));}));}));}.bind(i),i.mediaDevices.getUserMedia){const e=i.mediaDevices.getUserMedia.bind(i.mediaDevices);i.mediaDevices.getUserMedia=function(t){return r(t,(t=>e(t).then((e=>{if(t.audio&&!e.getAudioTracks().length||t.video&&!e.getVideoTracks().length)throw e.getTracks().forEach((e=>{e.stop();})),new DOMException("","NotFoundError");return e}),(e=>Promise.reject(s(e))))))};}}function E(e){e.MediaStream=e.MediaStream||e.webkitMediaStream;}function m(e){if("object"==typeof e&&e.RTCPeerConnection&&!("ontrack"in e.RTCPeerConnection.prototype)){Object.defineProperty(e.RTCPeerConnection.prototype,"ontrack",{get(){return this._ontrack},set(e){this._ontrack&&this.removeEventListener("track",this._ontrack),this.addEventListener("track",this._ontrack=e);},enumerable:!0,configurable:!0});const t=e.RTCPeerConnection.prototype.setRemoteDescription;e.RTCPeerConnection.prototype.setRemoteDescription=function(){return this._ontrackpoly||(this._ontrackpoly=t=>{t.stream.addEventListener("addtrack",(i=>{let n;n=e.RTCPeerConnection.prototype.getReceivers?this.getReceivers().find((e=>e.track&&e.track.id===i.track.id)):{track:i.track};const r=new Event("track");r.track=i.track,r.receiver=n,r.transceiver={receiver:n},r.streams=[t.stream],this.dispatchEvent(r);})),t.stream.getTracks().forEach((i=>{let n;n=e.RTCPeerConnection.prototype.getReceivers?this.getReceivers().find((e=>e.track&&e.track.id===i.id)):{track:i};const r=new Event("track");r.track=i,r.receiver=n,r.transceiver={receiver:n},r.streams=[t.stream],this.dispatchEvent(r);}));},this.addEventListener("addstream",this._ontrackpoly)),t.apply(this,arguments)};}else r(e,"track",(e=>(e.transceiver||Object.defineProperty(e,"transceiver",{value:{receiver:e.receiver}}),e)));}function f(e){if("object"==typeof e&&e.RTCPeerConnection&&!("getSenders"in e.RTCPeerConnection.prototype)&&"createDTMFSender"in e.RTCPeerConnection.prototype){const t=function(e,t){return {track:t,get dtmf(){return void 0===this._dtmf&&("audio"===t.kind?this._dtmf=e.createDTMFSender(t):this._dtmf=null),this._dtmf},_pc:e}};if(!e.RTCPeerConnection.prototype.getSenders){e.RTCPeerConnection.prototype.getSenders=function(){return this._senders=this._senders||[],this._senders.slice()};const i=e.RTCPeerConnection.prototype.addTrack;e.RTCPeerConnection.prototype.addTrack=function(e,n){let r=i.apply(this,arguments);return r||(r=t(this,e),this._senders.push(r)),r};const n=e.RTCPeerConnection.prototype.removeTrack;e.RTCPeerConnection.prototype.removeTrack=function(e){n.apply(this,arguments);const t=this._senders.indexOf(e);-1!==t&&this._senders.splice(t,1);};}const i=e.RTCPeerConnection.prototype.addStream;e.RTCPeerConnection.prototype.addStream=function(e){this._senders=this._senders||[],i.apply(this,[e]),e.getTracks().forEach((e=>{this._senders.push(t(this,e));}));};const n=e.RTCPeerConnection.prototype.removeStream;e.RTCPeerConnection.prototype.removeStream=function(e){this._senders=this._senders||[],n.apply(this,[e]),e.getTracks().forEach((e=>{const t=this._senders.find((t=>t.track===e));t&&this._senders.splice(this._senders.indexOf(t),1);}));};}else if("object"==typeof e&&e.RTCPeerConnection&&"getSenders"in e.RTCPeerConnection.prototype&&"createDTMFSender"in e.RTCPeerConnection.prototype&&e.RTCRtpSender&&!("dtmf"in e.RTCRtpSender.prototype)){const t=e.RTCPeerConnection.prototype.getSenders;e.RTCPeerConnection.prototype.getSenders=function(){const e=t.apply(this,[]);return e.forEach((e=>e._pc=this)),e},Object.defineProperty(e.RTCRtpSender.prototype,"dtmf",{get(){return void 0===this._dtmf&&("audio"===this.track.kind?this._dtmf=this._pc.createDTMFSender(this.track):this._dtmf=null),this._dtmf}});}}function g(e){if(!e.RTCPeerConnection)return;const t=e.RTCPeerConnection.prototype.getStats;e.RTCPeerConnection.prototype.getStats=function(){const[e,i,n]=arguments;if(arguments.length>0&&"function"==typeof e)return t.apply(this,arguments);if(0===t.length&&(0===arguments.length||"function"!=typeof e))return t.apply(this,[]);const r=function(e){const t={};return e.result().forEach((e=>{const i={id:e.id,timestamp:e.timestamp,type:{localcandidate:"local-candidate",remotecandidate:"remote-candidate"}[e.type]||e.type};e.names().forEach((t=>{i[t]=e.stat(t);})),t[i.id]=i;})),t},s=function(e){return new Map(Object.keys(e).map((t=>[t,e[t]])))};if(arguments.length>=2){const n=function(e){i(s(r(e)));};return t.apply(this,[n,e])}return new Promise(((e,i)=>{t.apply(this,[function(t){e(s(r(t)));},i]);})).then(i,n)};}function T(e){if(!("object"==typeof e&&e.RTCPeerConnection&&e.RTCRtpSender&&e.RTCRtpReceiver))return;if(!("getStats"in e.RTCRtpSender.prototype)){const t=e.RTCPeerConnection.prototype.getSenders;t&&(e.RTCPeerConnection.prototype.getSenders=function(){const e=t.apply(this,[]);return e.forEach((e=>e._pc=this)),e});const i=e.RTCPeerConnection.prototype.addTrack;i&&(e.RTCPeerConnection.prototype.addTrack=function(){const e=i.apply(this,arguments);return e._pc=this,e}),e.RTCRtpSender.prototype.getStats=function(){const e=this;return this._pc.getStats().then((t=>u(t,e.track,!0)))};}if(!("getStats"in e.RTCRtpReceiver.prototype)){const t=e.RTCPeerConnection.prototype.getReceivers;t&&(e.RTCPeerConnection.prototype.getReceivers=function(){const e=t.apply(this,[]);return e.forEach((e=>e._pc=this)),e}),r(e,"track",(e=>(e.receiver._pc=e.srcElement,e))),e.RTCRtpReceiver.prototype.getStats=function(){const e=this;return this._pc.getStats().then((t=>u(t,e.track,!1)))};}if(!("getStats"in e.RTCRtpSender.prototype)||!("getStats"in e.RTCRtpReceiver.prototype))return;const t=e.RTCPeerConnection.prototype.getStats;e.RTCPeerConnection.prototype.getStats=function(){if(arguments.length>0&&arguments[0]instanceof e.MediaStreamTrack){const e=arguments[0];let t,i,n;return this.getSenders().forEach((i=>{i.track===e&&(t?n=!0:t=i);})),this.getReceivers().forEach((t=>(t.track===e&&(i?n=!0:i=t),t.track===e))),n||t&&i?Promise.reject(new DOMException("There are more than one sender or receiver for the track.","InvalidAccessError")):t?t.getStats():i?i.getStats():Promise.reject(new DOMException("There is no sender or receiver for the track.","InvalidAccessError"))}return t.apply(this,arguments)};}function S(e){e.RTCPeerConnection.prototype.getLocalStreams=function(){return this._shimmedLocalStreams=this._shimmedLocalStreams||{},Object.keys(this._shimmedLocalStreams).map((e=>this._shimmedLocalStreams[e][0]))};const t=e.RTCPeerConnection.prototype.addTrack;e.RTCPeerConnection.prototype.addTrack=function(e,i){if(!i)return t.apply(this,arguments);this._shimmedLocalStreams=this._shimmedLocalStreams||{};const n=t.apply(this,arguments);return this._shimmedLocalStreams[i.id]?-1===this._shimmedLocalStreams[i.id].indexOf(n)&&this._shimmedLocalStreams[i.id].push(n):this._shimmedLocalStreams[i.id]=[i,n],n};const i=e.RTCPeerConnection.prototype.addStream;e.RTCPeerConnection.prototype.addStream=function(e){this._shimmedLocalStreams=this._shimmedLocalStreams||{},e.getTracks().forEach((e=>{if(this.getSenders().find((t=>t.track===e)))throw new DOMException("Track already exists.","InvalidAccessError")}));const t=this.getSenders();i.apply(this,arguments);const n=this.getSenders().filter((e=>-1===t.indexOf(e)));this._shimmedLocalStreams[e.id]=[e].concat(n);};const n=e.RTCPeerConnection.prototype.removeStream;e.RTCPeerConnection.prototype.removeStream=function(e){return this._shimmedLocalStreams=this._shimmedLocalStreams||{},delete this._shimmedLocalStreams[e.id],n.apply(this,arguments)};const r=e.RTCPeerConnection.prototype.removeTrack;e.RTCPeerConnection.prototype.removeTrack=function(e){return this._shimmedLocalStreams=this._shimmedLocalStreams||{},e&&Object.keys(this._shimmedLocalStreams).forEach((t=>{const i=this._shimmedLocalStreams[t].indexOf(e);-1!==i&&this._shimmedLocalStreams[t].splice(i,1),1===this._shimmedLocalStreams[t].length&&delete this._shimmedLocalStreams[t];})),r.apply(this,arguments)};}function R(e,t){if(!e.RTCPeerConnection)return;if(e.RTCPeerConnection.prototype.addTrack&&t.version>=65)return S(e);const i=e.RTCPeerConnection.prototype.getLocalStreams;e.RTCPeerConnection.prototype.getLocalStreams=function(){const e=i.apply(this);return this._reverseStreams=this._reverseStreams||{},e.map((e=>this._reverseStreams[e.id]))};const n=e.RTCPeerConnection.prototype.addStream;e.RTCPeerConnection.prototype.addStream=function(t){if(this._streams=this._streams||{},this._reverseStreams=this._reverseStreams||{},t.getTracks().forEach((e=>{if(this.getSenders().find((t=>t.track===e)))throw new DOMException("Track already exists.","InvalidAccessError")})),!this._reverseStreams[t.id]){const i=new e.MediaStream(t.getTracks());this._streams[t.id]=i,this._reverseStreams[i.id]=t,t=i;}n.apply(this,[t]);};const r=e.RTCPeerConnection.prototype.removeStream;function s(e,t){let i=t.sdp;return Object.keys(e._reverseStreams||[]).forEach((t=>{const n=e._reverseStreams[t],r=e._streams[n.id];i=i.replace(new RegExp(r.id,"g"),n.id);})),new RTCSessionDescription({type:t.type,sdp:i})}e.RTCPeerConnection.prototype.removeStream=function(e){this._streams=this._streams||{},this._reverseStreams=this._reverseStreams||{},r.apply(this,[this._streams[e.id]||e]),delete this._reverseStreams[this._streams[e.id]?this._streams[e.id].id:e.id],delete this._streams[e.id];},e.RTCPeerConnection.prototype.addTrack=function(t,i){if("closed"===this.signalingState)throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.","InvalidStateError");const n=[].slice.call(arguments,1);if(1!==n.length||!n[0].getTracks().find((e=>e===t)))throw new DOMException("The adapter.js addTrack polyfill only supports a single  stream which is associated with the specified track.","NotSupportedError");if(this.getSenders().find((e=>e.track===t)))throw new DOMException("Track already exists.","InvalidAccessError");this._streams=this._streams||{},this._reverseStreams=this._reverseStreams||{};const r=this._streams[i.id];if(r)r.addTrack(t),Promise.resolve().then((()=>{this.dispatchEvent(new Event("negotiationneeded"));}));else {const n=new e.MediaStream([t]);this._streams[i.id]=n,this._reverseStreams[n.id]=i,this.addStream(n);}return this.getSenders().find((e=>e.track===t))},["createOffer","createAnswer"].forEach((function(t){const i=e.RTCPeerConnection.prototype[t],n={[t](){const e=arguments;return arguments.length&&"function"==typeof arguments[0]?i.apply(this,[t=>{const i=s(this,t);e[0].apply(null,[i]);},t=>{e[1]&&e[1].apply(null,t);},arguments[2]]):i.apply(this,arguments).then((e=>s(this,e)))}};e.RTCPeerConnection.prototype[t]=n[t];}));const o=e.RTCPeerConnection.prototype.setLocalDescription;e.RTCPeerConnection.prototype.setLocalDescription=function(){return arguments.length&&arguments[0].type?(arguments[0]=function(e,t){let i=t.sdp;return Object.keys(e._reverseStreams||[]).forEach((t=>{const n=e._reverseStreams[t],r=e._streams[n.id];i=i.replace(new RegExp(n.id,"g"),r.id);})),new RTCSessionDescription({type:t.type,sdp:i})}(this,arguments[0]),o.apply(this,arguments)):o.apply(this,arguments)};const a=Object.getOwnPropertyDescriptor(e.RTCPeerConnection.prototype,"localDescription");Object.defineProperty(e.RTCPeerConnection.prototype,"localDescription",{get(){const e=a.get.apply(this);return ""===e.type?e:s(this,e)}}),e.RTCPeerConnection.prototype.removeTrack=function(e){if("closed"===this.signalingState)throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.","InvalidStateError");if(!e._pc)throw new DOMException("Argument 1 of RTCPeerConnection.removeTrack does not implement interface RTCRtpSender.","TypeError");if(!(e._pc===this))throw new DOMException("Sender was not created by this connection.","InvalidAccessError");let t;this._streams=this._streams||{},Object.keys(this._streams).forEach((i=>{this._streams[i].getTracks().find((t=>e.track===t))&&(t=this._streams[i]);})),t&&(1===t.getTracks().length?this.removeStream(this._reverseStreams[t.id]):t.removeTrack(e.track),this.dispatchEvent(new Event("negotiationneeded")));};}function C(e,t){!e.RTCPeerConnection&&e.webkitRTCPeerConnection&&(e.RTCPeerConnection=e.webkitRTCPeerConnection),e.RTCPeerConnection&&t.version<53&&["setLocalDescription","setRemoteDescription","addIceCandidate"].forEach((function(t){const i=e.RTCPeerConnection.prototype[t],n={[t](){return arguments[0]=new("addIceCandidate"===t?e.RTCIceCandidate:e.RTCSessionDescription)(arguments[0]),i.apply(this,arguments)}};e.RTCPeerConnection.prototype[t]=n[t];}));}function v(e,t){r(e,"negotiationneeded",(e=>{const i=e.target;if(!(t.version<72||i.getConfiguration&&"plan-b"===i.getConfiguration().sdpSemantics)||"stable"===i.signalingState)return e}));}var I=Object.freeze({__proto__:null,fixNegotiationNeeded:v,shimAddTrackRemoveTrack:R,shimAddTrackRemoveTrackWithNative:S,shimGetDisplayMedia:function(e,t){e.navigator.mediaDevices&&"getDisplayMedia"in e.navigator.mediaDevices||e.navigator.mediaDevices&&("function"==typeof t?e.navigator.mediaDevices.getDisplayMedia=function(i){return t(i).then((t=>{const n=i.video&&i.video.width,r=i.video&&i.video.height,s=i.video&&i.video.frameRate;return i.video={mandatory:{chromeMediaSource:"desktop",chromeMediaSourceId:t,maxFrameRate:s||3}},n&&(i.video.mandatory.maxWidth=n),r&&(i.video.mandatory.maxHeight=r),e.navigator.mediaDevices.getUserMedia(i)}))}:console.error("shimGetDisplayMedia: getSourceId argument is not a function"));},shimGetSendersWithDtmf:f,shimGetStats:g,shimGetUserMedia:_,shimMediaStream:E,shimOnTrack:m,shimPeerConnection:C,shimSenderReceiverGetStats:T});function y(e,t){const i=e&&e.navigator,n=e&&e.MediaStreamTrack;if(i.getUserMedia=function(e,t,n){c("navigator.getUserMedia","navigator.mediaDevices.getUserMedia"),i.mediaDevices.getUserMedia(e).then(t,n);},!(t.version>55&&"autoGainControl"in i.mediaDevices.getSupportedConstraints())){const e=function(e,t,i){t in e&&!(i in e)&&(e[i]=e[t],delete e[t]);},t=i.mediaDevices.getUserMedia.bind(i.mediaDevices);if(i.mediaDevices.getUserMedia=function(i){return "object"==typeof i&&"object"==typeof i.audio&&(i=JSON.parse(JSON.stringify(i)),e(i.audio,"autoGainControl","mozAutoGainControl"),e(i.audio,"noiseSuppression","mozNoiseSuppression")),t(i)},n&&n.prototype.getSettings){const t=n.prototype.getSettings;n.prototype.getSettings=function(){const i=t.apply(this,arguments);return e(i,"mozAutoGainControl","autoGainControl"),e(i,"mozNoiseSuppression","noiseSuppression"),i};}if(n&&n.prototype.applyConstraints){const t=n.prototype.applyConstraints;n.prototype.applyConstraints=function(i){return "audio"===this.kind&&"object"==typeof i&&(i=JSON.parse(JSON.stringify(i)),e(i,"autoGainControl","mozAutoGainControl"),e(i,"noiseSuppression","mozNoiseSuppression")),t.apply(this,[i])};}}}function A(e){"object"==typeof e&&e.RTCTrackEvent&&"receiver"in e.RTCTrackEvent.prototype&&!("transceiver"in e.RTCTrackEvent.prototype)&&Object.defineProperty(e.RTCTrackEvent.prototype,"transceiver",{get(){return {receiver:this.receiver}}});}function b(e,t){if("object"!=typeof e||!e.RTCPeerConnection&&!e.mozRTCPeerConnection)return;!e.RTCPeerConnection&&e.mozRTCPeerConnection&&(e.RTCPeerConnection=e.mozRTCPeerConnection),t.version<53&&["setLocalDescription","setRemoteDescription","addIceCandidate"].forEach((function(t){const i=e.RTCPeerConnection.prototype[t],n={[t](){return arguments[0]=new("addIceCandidate"===t?e.RTCIceCandidate:e.RTCSessionDescription)(arguments[0]),i.apply(this,arguments)}};e.RTCPeerConnection.prototype[t]=n[t];}));const i={inboundrtp:"inbound-rtp",outboundrtp:"outbound-rtp",candidatepair:"candidate-pair",localcandidate:"local-candidate",remotecandidate:"remote-candidate"},n=e.RTCPeerConnection.prototype.getStats;e.RTCPeerConnection.prototype.getStats=function(){const[e,r,s]=arguments;return n.apply(this,[e||null]).then((e=>{if(t.version<53&&!r)try{e.forEach((e=>{e.type=i[e.type]||e.type;}));}catch(t){if("TypeError"!==t.name)throw t;e.forEach(((t,n)=>{e.set(n,Object.assign({},t,{type:i[t.type]||t.type}));}));}return e})).then(r,s)};}function w(e){if("object"!=typeof e||!e.RTCPeerConnection||!e.RTCRtpSender)return;if(e.RTCRtpSender&&"getStats"in e.RTCRtpSender.prototype)return;const t=e.RTCPeerConnection.prototype.getSenders;t&&(e.RTCPeerConnection.prototype.getSenders=function(){const e=t.apply(this,[]);return e.forEach((e=>e._pc=this)),e});const i=e.RTCPeerConnection.prototype.addTrack;i&&(e.RTCPeerConnection.prototype.addTrack=function(){const e=i.apply(this,arguments);return e._pc=this,e}),e.RTCRtpSender.prototype.getStats=function(){return this.track?this._pc.getStats(this.track):Promise.resolve(new Map)};}function O(e){if("object"!=typeof e||!e.RTCPeerConnection||!e.RTCRtpSender)return;if(e.RTCRtpSender&&"getStats"in e.RTCRtpReceiver.prototype)return;const t=e.RTCPeerConnection.prototype.getReceivers;t&&(e.RTCPeerConnection.prototype.getReceivers=function(){const e=t.apply(this,[]);return e.forEach((e=>e._pc=this)),e}),r(e,"track",(e=>(e.receiver._pc=e.srcElement,e))),e.RTCRtpReceiver.prototype.getStats=function(){return this._pc.getStats(this.track)};}function N(e){e.RTCPeerConnection&&!("removeStream"in e.RTCPeerConnection.prototype)&&(e.RTCPeerConnection.prototype.removeStream=function(e){c("removeStream","removeTrack"),this.getSenders().forEach((t=>{t.track&&e.getTracks().includes(t.track)&&this.removeTrack(t);}));});}function D(e){e.DataChannel&&!e.RTCDataChannel&&(e.RTCDataChannel=e.DataChannel);}function P(e){if("object"!=typeof e||!e.RTCPeerConnection)return;const t=e.RTCPeerConnection.prototype.addTransceiver;t&&(e.RTCPeerConnection.prototype.addTransceiver=function(){this.setParametersPromises=[];let e=arguments[1]&&arguments[1].sendEncodings;void 0===e&&(e=[]),e=[...e];const i=e.length>0;i&&e.forEach((e=>{if("rid"in e){if(!/^[a-z0-9]{0,16}$/i.test(e.rid))throw new TypeError("Invalid RID value provided.")}if("scaleResolutionDownBy"in e&&!(parseFloat(e.scaleResolutionDownBy)>=1))throw new RangeError("scale_resolution_down_by must be >= 1.0");if("maxFramerate"in e&&!(parseFloat(e.maxFramerate)>=0))throw new RangeError("max_framerate must be >= 0.0")}));const n=t.apply(this,arguments);if(i){const{sender:t}=n,i=t.getParameters();(!("encodings"in i)||1===i.encodings.length&&0===Object.keys(i.encodings[0]).length)&&(i.encodings=e,t.sendEncodings=e,this.setParametersPromises.push(t.setParameters(i).then((()=>{delete t.sendEncodings;})).catch((()=>{delete t.sendEncodings;}))));}return n});}function L(e){if("object"!=typeof e||!e.RTCRtpSender)return;const t=e.RTCRtpSender.prototype.getParameters;t&&(e.RTCRtpSender.prototype.getParameters=function(){const e=t.apply(this,arguments);return "encodings"in e||(e.encodings=[].concat(this.sendEncodings||[{}])),e});}function k(e){if("object"!=typeof e||!e.RTCPeerConnection)return;const t=e.RTCPeerConnection.prototype.createOffer;e.RTCPeerConnection.prototype.createOffer=function(){return this.setParametersPromises&&this.setParametersPromises.length?Promise.all(this.setParametersPromises).then((()=>t.apply(this,arguments))).finally((()=>{this.setParametersPromises=[];})):t.apply(this,arguments)};}function M(e){if("object"!=typeof e||!e.RTCPeerConnection)return;const t=e.RTCPeerConnection.prototype.createAnswer;e.RTCPeerConnection.prototype.createAnswer=function(){return this.setParametersPromises&&this.setParametersPromises.length?Promise.all(this.setParametersPromises).then((()=>t.apply(this,arguments))).finally((()=>{this.setParametersPromises=[];})):t.apply(this,arguments)};}var U=Object.freeze({__proto__:null,shimAddTransceiver:P,shimCreateAnswer:M,shimCreateOffer:k,shimGetDisplayMedia:function(e,t){e.navigator.mediaDevices&&"getDisplayMedia"in e.navigator.mediaDevices||e.navigator.mediaDevices&&(e.navigator.mediaDevices.getDisplayMedia=function(i){if(!i||!i.video){const e=new DOMException("getDisplayMedia without video constraints is undefined");return e.name="NotFoundError",e.code=8,Promise.reject(e)}return !0===i.video?i.video={mediaSource:t}:i.video.mediaSource=t,e.navigator.mediaDevices.getUserMedia(i)});},shimGetParameters:L,shimGetUserMedia:y,shimOnTrack:A,shimPeerConnection:b,shimRTCDataChannel:D,shimReceiverGetStats:O,shimRemoveStream:N,shimSenderGetStats:w});function x(e){if("object"==typeof e&&e.RTCPeerConnection){if("getLocalStreams"in e.RTCPeerConnection.prototype||(e.RTCPeerConnection.prototype.getLocalStreams=function(){return this._localStreams||(this._localStreams=[]),this._localStreams}),!("addStream"in e.RTCPeerConnection.prototype)){const t=e.RTCPeerConnection.prototype.addTrack;e.RTCPeerConnection.prototype.addStream=function(e){this._localStreams||(this._localStreams=[]),this._localStreams.includes(e)||this._localStreams.push(e),e.getAudioTracks().forEach((i=>t.call(this,i,e))),e.getVideoTracks().forEach((i=>t.call(this,i,e)));},e.RTCPeerConnection.prototype.addTrack=function(e,...i){return i&&i.forEach((e=>{this._localStreams?this._localStreams.includes(e)||this._localStreams.push(e):this._localStreams=[e];})),t.apply(this,arguments)};}"removeStream"in e.RTCPeerConnection.prototype||(e.RTCPeerConnection.prototype.removeStream=function(e){this._localStreams||(this._localStreams=[]);const t=this._localStreams.indexOf(e);if(-1===t)return;this._localStreams.splice(t,1);const i=e.getTracks();this.getSenders().forEach((e=>{i.includes(e.track)&&this.removeTrack(e);}));});}}function V(e){if("object"==typeof e&&e.RTCPeerConnection&&("getRemoteStreams"in e.RTCPeerConnection.prototype||(e.RTCPeerConnection.prototype.getRemoteStreams=function(){return this._remoteStreams?this._remoteStreams:[]}),!("onaddstream"in e.RTCPeerConnection.prototype))){Object.defineProperty(e.RTCPeerConnection.prototype,"onaddstream",{get(){return this._onaddstream},set(e){this._onaddstream&&(this.removeEventListener("addstream",this._onaddstream),this.removeEventListener("track",this._onaddstreampoly)),this.addEventListener("addstream",this._onaddstream=e),this.addEventListener("track",this._onaddstreampoly=e=>{e.streams.forEach((e=>{if(this._remoteStreams||(this._remoteStreams=[]),this._remoteStreams.includes(e))return;this._remoteStreams.push(e);const t=new Event("addstream");t.stream=e,this.dispatchEvent(t);}));});}});const t=e.RTCPeerConnection.prototype.setRemoteDescription;e.RTCPeerConnection.prototype.setRemoteDescription=function(){const e=this;return this._onaddstreampoly||this.addEventListener("track",this._onaddstreampoly=function(t){t.streams.forEach((t=>{if(e._remoteStreams||(e._remoteStreams=[]),e._remoteStreams.indexOf(t)>=0)return;e._remoteStreams.push(t);const i=new Event("addstream");i.stream=t,e.dispatchEvent(i);}));}),t.apply(e,arguments)};}}function F(e){if("object"!=typeof e||!e.RTCPeerConnection)return;const t=e.RTCPeerConnection.prototype,i=t.createOffer,n=t.createAnswer,r=t.setLocalDescription,s=t.setRemoteDescription,o=t.addIceCandidate;t.createOffer=function(e,t){const n=arguments.length>=2?arguments[2]:arguments[0],r=i.apply(this,[n]);return t?(r.then(e,t),Promise.resolve()):r},t.createAnswer=function(e,t){const i=arguments.length>=2?arguments[2]:arguments[0],r=n.apply(this,[i]);return t?(r.then(e,t),Promise.resolve()):r};let a=function(e,t,i){const n=r.apply(this,[e]);return i?(n.then(t,i),Promise.resolve()):n};t.setLocalDescription=a,a=function(e,t,i){const n=s.apply(this,[e]);return i?(n.then(t,i),Promise.resolve()):n},t.setRemoteDescription=a,a=function(e,t,i){const n=o.apply(this,[e]);return i?(n.then(t,i),Promise.resolve()):n},t.addIceCandidate=a;}function B(e){const t=e&&e.navigator;if(t.mediaDevices&&t.mediaDevices.getUserMedia){const e=t.mediaDevices,i=e.getUserMedia.bind(e);t.mediaDevices.getUserMedia=e=>i(j(e));}!t.getUserMedia&&t.mediaDevices&&t.mediaDevices.getUserMedia&&(t.getUserMedia=function(e,i,n){t.mediaDevices.getUserMedia(e).then(i,n);}.bind(t));}function j(e){return e&&void 0!==e.video?Object.assign({},e,{video:l(e.video)}):e}function G(e){if(!e.RTCPeerConnection)return;const t=e.RTCPeerConnection;e.RTCPeerConnection=function(e,i){if(e&&e.iceServers){const t=[];for(let i=0;i<e.iceServers.length;i++){let n=e.iceServers[i];!n.hasOwnProperty("urls")&&n.hasOwnProperty("url")?(c("RTCIceServer.url","RTCIceServer.urls"),n=JSON.parse(JSON.stringify(n)),n.urls=n.url,delete n.url,t.push(n)):t.push(e.iceServers[i]);}e.iceServers=t;}return new t(e,i)},e.RTCPeerConnection.prototype=t.prototype,"generateCertificate"in t&&Object.defineProperty(e.RTCPeerConnection,"generateCertificate",{get:()=>t.generateCertificate});}function W(e){"object"==typeof e&&e.RTCTrackEvent&&"receiver"in e.RTCTrackEvent.prototype&&!("transceiver"in e.RTCTrackEvent.prototype)&&Object.defineProperty(e.RTCTrackEvent.prototype,"transceiver",{get(){return {receiver:this.receiver}}});}function H(e){const t=e.RTCPeerConnection.prototype.createOffer;e.RTCPeerConnection.prototype.createOffer=function(e){if(e){void 0!==e.offerToReceiveAudio&&(e.offerToReceiveAudio=!!e.offerToReceiveAudio);const t=this.getTransceivers().find((e=>"audio"===e.receiver.track.kind));!1===e.offerToReceiveAudio&&t?"sendrecv"===t.direction?t.setDirection?t.setDirection("sendonly"):t.direction="sendonly":"recvonly"===t.direction&&(t.setDirection?t.setDirection("inactive"):t.direction="inactive"):!0!==e.offerToReceiveAudio||t||this.addTransceiver("audio",{direction:"recvonly"}),void 0!==e.offerToReceiveVideo&&(e.offerToReceiveVideo=!!e.offerToReceiveVideo);const i=this.getTransceivers().find((e=>"video"===e.receiver.track.kind));!1===e.offerToReceiveVideo&&i?"sendrecv"===i.direction?i.setDirection?i.setDirection("sendonly"):i.direction="sendonly":"recvonly"===i.direction&&(i.setDirection?i.setDirection("inactive"):i.direction="inactive"):!0!==e.offerToReceiveVideo||i||this.addTransceiver("video",{direction:"recvonly"});}return t.apply(this,arguments)};}function K(e){"object"!=typeof e||e.AudioContext||(e.AudioContext=e.webkitAudioContext);}var Y=Object.freeze({__proto__:null,shimAudioContext:K,shimCallbacksAPI:F,shimConstraints:j,shimCreateOfferLegacy:H,shimGetUserMedia:B,shimLocalStreamsAPI:x,shimRTCIceServerUrls:G,shimRemoteStreamsAPI:V,shimTrackEventTransceiver:W}),q="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof commonjsGlobal?commonjsGlobal:"undefined"!=typeof self?self:{};function J(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e}var z={exports:{}};!function(e){const t={generateIdentifier:function(){return Math.random().toString(36).substring(2,12)}};t.localCName=t.generateIdentifier(),t.splitLines=function(e){return e.trim().split("\n").map((e=>e.trim()))},t.splitSections=function(e){return e.split("\nm=").map(((e,t)=>(t>0?"m="+e:e).trim()+"\r\n"))},t.getDescription=function(e){const i=t.splitSections(e);return i&&i[0]},t.getMediaSections=function(e){const i=t.splitSections(e);return i.shift(),i},t.matchPrefix=function(e,i){return t.splitLines(e).filter((e=>0===e.indexOf(i)))},t.parseCandidate=function(e){let t;t=0===e.indexOf("a=candidate:")?e.substring(12).split(" "):e.substring(10).split(" ");const i={foundation:t[0],component:{1:"rtp",2:"rtcp"}[t[1]]||t[1],protocol:t[2].toLowerCase(),priority:parseInt(t[3],10),ip:t[4],address:t[4],port:parseInt(t[5],10),type:t[7]};for(let e=8;e<t.length;e+=2)switch(t[e]){case"raddr":i.relatedAddress=t[e+1];break;case"rport":i.relatedPort=parseInt(t[e+1],10);break;case"tcptype":i.tcpType=t[e+1];break;case"ufrag":i.ufrag=t[e+1],i.usernameFragment=t[e+1];break;default:void 0===i[t[e]]&&(i[t[e]]=t[e+1]);}return i},t.writeCandidate=function(e){const t=[];t.push(e.foundation);const i=e.component;"rtp"===i?t.push(1):"rtcp"===i?t.push(2):t.push(i),t.push(e.protocol.toUpperCase()),t.push(e.priority),t.push(e.address||e.ip),t.push(e.port);const n=e.type;return t.push("typ"),t.push(n),"host"!==n&&e.relatedAddress&&e.relatedPort&&(t.push("raddr"),t.push(e.relatedAddress),t.push("rport"),t.push(e.relatedPort)),e.tcpType&&"tcp"===e.protocol.toLowerCase()&&(t.push("tcptype"),t.push(e.tcpType)),(e.usernameFragment||e.ufrag)&&(t.push("ufrag"),t.push(e.usernameFragment||e.ufrag)),"candidate:"+t.join(" ")},t.parseIceOptions=function(e){return e.substring(14).split(" ")},t.parseRtpMap=function(e){let t=e.substring(9).split(" ");const i={payloadType:parseInt(t.shift(),10)};return t=t[0].split("/"),i.name=t[0],i.clockRate=parseInt(t[1],10),i.channels=3===t.length?parseInt(t[2],10):1,i.numChannels=i.channels,i},t.writeRtpMap=function(e){let t=e.payloadType;void 0!==e.preferredPayloadType&&(t=e.preferredPayloadType);const i=e.channels||e.numChannels||1;return "a=rtpmap:"+t+" "+e.name+"/"+e.clockRate+(1!==i?"/"+i:"")+"\r\n"},t.parseExtmap=function(e){const t=e.substring(9).split(" ");return {id:parseInt(t[0],10),direction:t[0].indexOf("/")>0?t[0].split("/")[1]:"sendrecv",uri:t[1],attributes:t.slice(2).join(" ")}},t.writeExtmap=function(e){return "a=extmap:"+(e.id||e.preferredId)+(e.direction&&"sendrecv"!==e.direction?"/"+e.direction:"")+" "+e.uri+(e.attributes?" "+e.attributes:"")+"\r\n"},t.parseFmtp=function(e){const t={};let i;const n=e.substring(e.indexOf(" ")+1).split(";");for(let e=0;e<n.length;e++)i=n[e].trim().split("="),t[i[0].trim()]=i[1];return t},t.writeFmtp=function(e){let t="",i=e.payloadType;if(void 0!==e.preferredPayloadType&&(i=e.preferredPayloadType),e.parameters&&Object.keys(e.parameters).length){const n=[];Object.keys(e.parameters).forEach((t=>{void 0!==e.parameters[t]?n.push(t+"="+e.parameters[t]):n.push(t);})),t+="a=fmtp:"+i+" "+n.join(";")+"\r\n";}return t},t.parseRtcpFb=function(e){const t=e.substring(e.indexOf(" ")+1).split(" ");return {type:t.shift(),parameter:t.join(" ")}},t.writeRtcpFb=function(e){let t="",i=e.payloadType;return void 0!==e.preferredPayloadType&&(i=e.preferredPayloadType),e.rtcpFeedback&&e.rtcpFeedback.length&&e.rtcpFeedback.forEach((e=>{t+="a=rtcp-fb:"+i+" "+e.type+(e.parameter&&e.parameter.length?" "+e.parameter:"")+"\r\n";})),t},t.parseSsrcMedia=function(e){const t=e.indexOf(" "),i={ssrc:parseInt(e.substring(7,t),10)},n=e.indexOf(":",t);return n>-1?(i.attribute=e.substring(t+1,n),i.value=e.substring(n+1)):i.attribute=e.substring(t+1),i},t.parseSsrcGroup=function(e){const t=e.substring(13).split(" ");return {semantics:t.shift(),ssrcs:t.map((e=>parseInt(e,10)))}},t.getMid=function(e){const i=t.matchPrefix(e,"a=mid:")[0];if(i)return i.substring(6)},t.parseFingerprint=function(e){const t=e.substring(14).split(" ");return {algorithm:t[0].toLowerCase(),value:t[1].toUpperCase()}},t.getDtlsParameters=function(e,i){return {role:"auto",fingerprints:t.matchPrefix(e+i,"a=fingerprint:").map(t.parseFingerprint)}},t.writeDtlsParameters=function(e,t){let i="a=setup:"+t+"\r\n";return e.fingerprints.forEach((e=>{i+="a=fingerprint:"+e.algorithm+" "+e.value+"\r\n";})),i},t.parseCryptoLine=function(e){const t=e.substring(9).split(" ");return {tag:parseInt(t[0],10),cryptoSuite:t[1],keyParams:t[2],sessionParams:t.slice(3)}},t.writeCryptoLine=function(e){return "a=crypto:"+e.tag+" "+e.cryptoSuite+" "+("object"==typeof e.keyParams?t.writeCryptoKeyParams(e.keyParams):e.keyParams)+(e.sessionParams?" "+e.sessionParams.join(" "):"")+"\r\n"},t.parseCryptoKeyParams=function(e){if(0!==e.indexOf("inline:"))return null;const t=e.substring(7).split("|");return {keyMethod:"inline",keySalt:t[0],lifeTime:t[1],mkiValue:t[2]?t[2].split(":")[0]:void 0,mkiLength:t[2]?t[2].split(":")[1]:void 0}},t.writeCryptoKeyParams=function(e){return e.keyMethod+":"+e.keySalt+(e.lifeTime?"|"+e.lifeTime:"")+(e.mkiValue&&e.mkiLength?"|"+e.mkiValue+":"+e.mkiLength:"")},t.getCryptoParameters=function(e,i){return t.matchPrefix(e+i,"a=crypto:").map(t.parseCryptoLine)},t.getIceParameters=function(e,i){const n=t.matchPrefix(e+i,"a=ice-ufrag:")[0],r=t.matchPrefix(e+i,"a=ice-pwd:")[0];return n&&r?{usernameFragment:n.substring(12),password:r.substring(10)}:null},t.writeIceParameters=function(e){let t="a=ice-ufrag:"+e.usernameFragment+"\r\na=ice-pwd:"+e.password+"\r\n";return e.iceLite&&(t+="a=ice-lite\r\n"),t},t.parseRtpParameters=function(e){const i={codecs:[],headerExtensions:[],fecMechanisms:[],rtcp:[]},n=t.splitLines(e)[0].split(" ");i.profile=n[2];for(let r=3;r<n.length;r++){const s=n[r],o=t.matchPrefix(e,"a=rtpmap:"+s+" ")[0];if(o){const n=t.parseRtpMap(o),r=t.matchPrefix(e,"a=fmtp:"+s+" ");switch(n.parameters=r.length?t.parseFmtp(r[0]):{},n.rtcpFeedback=t.matchPrefix(e,"a=rtcp-fb:"+s+" ").map(t.parseRtcpFb),i.codecs.push(n),n.name.toUpperCase()){case"RED":case"ULPFEC":i.fecMechanisms.push(n.name.toUpperCase());}}}t.matchPrefix(e,"a=extmap:").forEach((e=>{i.headerExtensions.push(t.parseExtmap(e));}));const r=t.matchPrefix(e,"a=rtcp-fb:* ").map(t.parseRtcpFb);return i.codecs.forEach((e=>{r.forEach((t=>{e.rtcpFeedback.find((e=>e.type===t.type&&e.parameter===t.parameter))||e.rtcpFeedback.push(t);}));})),i},t.writeRtpDescription=function(e,i){let n="";n+="m="+e+" ",n+=i.codecs.length>0?"9":"0",n+=" "+(i.profile||"UDP/TLS/RTP/SAVPF")+" ",n+=i.codecs.map((e=>void 0!==e.preferredPayloadType?e.preferredPayloadType:e.payloadType)).join(" ")+"\r\n",n+="c=IN IP4 0.0.0.0\r\n",n+="a=rtcp:9 IN IP4 0.0.0.0\r\n",i.codecs.forEach((e=>{n+=t.writeRtpMap(e),n+=t.writeFmtp(e),n+=t.writeRtcpFb(e);}));let r=0;return i.codecs.forEach((e=>{e.maxptime>r&&(r=e.maxptime);})),r>0&&(n+="a=maxptime:"+r+"\r\n"),i.headerExtensions&&i.headerExtensions.forEach((e=>{n+=t.writeExtmap(e);})),n},t.parseRtpEncodingParameters=function(e){const i=[],n=t.parseRtpParameters(e),r=-1!==n.fecMechanisms.indexOf("RED"),s=-1!==n.fecMechanisms.indexOf("ULPFEC"),o=t.matchPrefix(e,"a=ssrc:").map((e=>t.parseSsrcMedia(e))).filter((e=>"cname"===e.attribute)),a=o.length>0&&o[0].ssrc;let c;const d=t.matchPrefix(e,"a=ssrc-group:FID").map((e=>e.substring(17).split(" ").map((e=>parseInt(e,10)))));d.length>0&&d[0].length>1&&d[0][0]===a&&(c=d[0][1]),n.codecs.forEach((e=>{if("RTX"===e.name.toUpperCase()&&e.parameters.apt){let t={ssrc:a,codecPayloadType:parseInt(e.parameters.apt,10)};a&&c&&(t.rtx={ssrc:c}),i.push(t),r&&(t=JSON.parse(JSON.stringify(t)),t.fec={ssrc:a,mechanism:s?"red+ulpfec":"red"},i.push(t));}})),0===i.length&&a&&i.push({ssrc:a});let l=t.matchPrefix(e,"b=");return l.length&&(l=0===l[0].indexOf("b=TIAS:")?parseInt(l[0].substring(7),10):0===l[0].indexOf("b=AS:")?1e3*parseInt(l[0].substring(5),10)*.95-16e3:void 0,i.forEach((e=>{e.maxBitrate=l;}))),i},t.parseRtcpParameters=function(e){const i={},n=t.matchPrefix(e,"a=ssrc:").map((e=>t.parseSsrcMedia(e))).filter((e=>"cname"===e.attribute))[0];n&&(i.cname=n.value,i.ssrc=n.ssrc);const r=t.matchPrefix(e,"a=rtcp-rsize");i.reducedSize=r.length>0,i.compound=0===r.length;const s=t.matchPrefix(e,"a=rtcp-mux");return i.mux=s.length>0,i},t.writeRtcpParameters=function(e){let t="";return e.reducedSize&&(t+="a=rtcp-rsize\r\n"),e.mux&&(t+="a=rtcp-mux\r\n"),void 0!==e.ssrc&&e.cname&&(t+="a=ssrc:"+e.ssrc+" cname:"+e.cname+"\r\n"),t},t.parseMsid=function(e){let i;const n=t.matchPrefix(e,"a=msid:");if(1===n.length)return i=n[0].substring(7).split(" "),{stream:i[0],track:i[1]};const r=t.matchPrefix(e,"a=ssrc:").map((e=>t.parseSsrcMedia(e))).filter((e=>"msid"===e.attribute));return r.length>0?(i=r[0].value.split(" "),{stream:i[0],track:i[1]}):void 0},t.parseSctpDescription=function(e){const i=t.parseMLine(e),n=t.matchPrefix(e,"a=max-message-size:");let r;n.length>0&&(r=parseInt(n[0].substring(19),10)),isNaN(r)&&(r=65536);const s=t.matchPrefix(e,"a=sctp-port:");if(s.length>0)return {port:parseInt(s[0].substring(12),10),protocol:i.fmt,maxMessageSize:r};const o=t.matchPrefix(e,"a=sctpmap:");if(o.length>0){const e=o[0].substring(10).split(" ");return {port:parseInt(e[0],10),protocol:e[1],maxMessageSize:r}}},t.writeSctpDescription=function(e,t){let i=[];return i="DTLS/SCTP"!==e.protocol?["m="+e.kind+" 9 "+e.protocol+" "+t.protocol+"\r\n","c=IN IP4 0.0.0.0\r\n","a=sctp-port:"+t.port+"\r\n"]:["m="+e.kind+" 9 "+e.protocol+" "+t.port+"\r\n","c=IN IP4 0.0.0.0\r\n","a=sctpmap:"+t.port+" "+t.protocol+" 65535\r\n"],void 0!==t.maxMessageSize&&i.push("a=max-message-size:"+t.maxMessageSize+"\r\n"),i.join("")},t.generateSessionId=function(){return Math.random().toString().substr(2,22)},t.writeSessionBoilerplate=function(e,i,n){let r;const s=void 0!==i?i:2;r=e||t.generateSessionId();return "v=0\r\no="+(n||"thisisadapterortc")+" "+r+" "+s+" IN IP4 127.0.0.1\r\ns=-\r\nt=0 0\r\n"},t.getDirection=function(e,i){const n=t.splitLines(e);for(let e=0;e<n.length;e++)switch(n[e]){case"a=sendrecv":case"a=sendonly":case"a=recvonly":case"a=inactive":return n[e].substring(2)}return i?t.getDirection(i):"sendrecv"},t.getKind=function(e){return t.splitLines(e)[0].split(" ")[0].substring(2)},t.isRejected=function(e){return "0"===e.split(" ",2)[1]},t.parseMLine=function(e){const i=t.splitLines(e)[0].substring(2).split(" ");return {kind:i[0],port:parseInt(i[1],10),protocol:i[2],fmt:i.slice(3).join(" ")}},t.parseOLine=function(e){const i=t.matchPrefix(e,"o=")[0].substring(2).split(" ");return {username:i[0],sessionId:i[1],sessionVersion:parseInt(i[2],10),netType:i[3],addressType:i[4],address:i[5]}},t.isValidSDP=function(e){if("string"!=typeof e||0===e.length)return !1;const i=t.splitLines(e);for(let e=0;e<i.length;e++)if(i[e].length<2||"="!==i[e].charAt(1))return !1;return !0},e.exports=t;}(z);var X=z.exports,Q=J(X),Z=e({__proto__:null,default:Q},[X]);function $(e){if(!e.RTCIceCandidate||e.RTCIceCandidate&&"foundation"in e.RTCIceCandidate.prototype)return;const t=e.RTCIceCandidate;e.RTCIceCandidate=function(e){if("object"==typeof e&&e.candidate&&0===e.candidate.indexOf("a=")&&((e=JSON.parse(JSON.stringify(e))).candidate=e.candidate.substr(2)),e.candidate&&e.candidate.length){const i=new t(e),n=Q.parseCandidate(e.candidate),r=Object.assign(i,n);return r.toJSON=function(){return {candidate:r.candidate,sdpMid:r.sdpMid,sdpMLineIndex:r.sdpMLineIndex,usernameFragment:r.usernameFragment}},r}return new t(e)},e.RTCIceCandidate.prototype=t.prototype,r(e,"icecandidate",(t=>(t.candidate&&Object.defineProperty(t,"candidate",{value:new e.RTCIceCandidate(t.candidate),writable:"false"}),t)));}function ee(e){!e.RTCIceCandidate||e.RTCIceCandidate&&"relayProtocol"in e.RTCIceCandidate.prototype||r(e,"icecandidate",(e=>{if(e.candidate){const t=Q.parseCandidate(e.candidate.candidate);"relay"===t.type&&(e.candidate.relayProtocol={0:"tls",1:"tcp",2:"udp"}[t.priority>>24]);}return e}));}function te(e,t){if(!e.RTCPeerConnection)return;"sctp"in e.RTCPeerConnection.prototype||Object.defineProperty(e.RTCPeerConnection.prototype,"sctp",{get(){return void 0===this._sctp?null:this._sctp}});const i=function(e){if(!e||!e.sdp)return !1;const t=Q.splitSections(e.sdp);return t.shift(),t.some((e=>{const t=Q.parseMLine(e);return t&&"application"===t.kind&&-1!==t.protocol.indexOf("SCTP")}))},n=function(e){const t=e.sdp.match(/mozilla...THIS_IS_SDPARTA-(\d+)/);if(null===t||t.length<2)return -1;const i=parseInt(t[1],10);return i!=i?-1:i},r=function(e){let i=65536;return "firefox"===t.browser&&(i=t.version<57?-1===e?16384:2147483637:t.version<60?57===t.version?65535:65536:2147483637),i},s=function(e,i){let n=65536;"firefox"===t.browser&&57===t.version&&(n=65535);const r=Q.matchPrefix(e.sdp,"a=max-message-size:");return r.length>0?n=parseInt(r[0].substr(19),10):"firefox"===t.browser&&-1!==i&&(n=2147483637),n},o=e.RTCPeerConnection.prototype.setRemoteDescription;e.RTCPeerConnection.prototype.setRemoteDescription=function(){if(this._sctp=null,"chrome"===t.browser&&t.version>=76){const{sdpSemantics:e}=this.getConfiguration();"plan-b"===e&&Object.defineProperty(this,"sctp",{get(){return void 0===this._sctp?null:this._sctp},enumerable:!0,configurable:!0});}if(i(arguments[0])){const e=n(arguments[0]),t=r(e),i=s(arguments[0],e);let o;o=0===t&&0===i?Number.POSITIVE_INFINITY:0===t||0===i?Math.max(t,i):Math.min(t,i);const a={};Object.defineProperty(a,"maxMessageSize",{get:()=>o}),this._sctp=a;}return o.apply(this,arguments)};}function ie(e){if(!e.RTCPeerConnection||!("createDataChannel"in e.RTCPeerConnection.prototype))return;function t(e,t){const i=e.send;e.send=function(){const n=arguments[0],r=n.length||n.size||n.byteLength;if("open"===e.readyState&&t.sctp&&r>t.sctp.maxMessageSize)throw new TypeError("Message too large (can send a maximum of "+t.sctp.maxMessageSize+" bytes)");return i.apply(e,arguments)};}const i=e.RTCPeerConnection.prototype.createDataChannel;e.RTCPeerConnection.prototype.createDataChannel=function(){const e=i.apply(this,arguments);return t(e,this),e},r(e,"datachannel",(e=>(t(e.channel,e.target),e)));}function ne(e){if(!e.RTCPeerConnection||"connectionState"in e.RTCPeerConnection.prototype)return;const t=e.RTCPeerConnection.prototype;Object.defineProperty(t,"connectionState",{get(){return {completed:"connected",checking:"connecting"}[this.iceConnectionState]||this.iceConnectionState},enumerable:!0,configurable:!0}),Object.defineProperty(t,"onconnectionstatechange",{get(){return this._onconnectionstatechange||null},set(e){this._onconnectionstatechange&&(this.removeEventListener("connectionstatechange",this._onconnectionstatechange),delete this._onconnectionstatechange),e&&this.addEventListener("connectionstatechange",this._onconnectionstatechange=e);},enumerable:!0,configurable:!0}),["setLocalDescription","setRemoteDescription"].forEach((e=>{const i=t[e];t[e]=function(){return this._connectionstatechangepoly||(this._connectionstatechangepoly=e=>{const t=e.target;if(t._lastConnectionState!==t.connectionState){t._lastConnectionState=t.connectionState;const i=new Event("connectionstatechange",e);t.dispatchEvent(i);}return e},this.addEventListener("iceconnectionstatechange",this._connectionstatechangepoly)),i.apply(this,arguments)};}));}function re(e,t){if(!e.RTCPeerConnection)return;if("chrome"===t.browser&&t.version>=71)return;if("safari"===t.browser&&t.version>=605)return;const i=e.RTCPeerConnection.prototype.setRemoteDescription;e.RTCPeerConnection.prototype.setRemoteDescription=function(t){if(t&&t.sdp&&-1!==t.sdp.indexOf("\na=extmap-allow-mixed")){const i=t.sdp.split("\n").filter((e=>"a=extmap-allow-mixed"!==e.trim())).join("\n");e.RTCSessionDescription&&t instanceof e.RTCSessionDescription?arguments[0]=new e.RTCSessionDescription({type:t.type,sdp:i}):t.sdp=i;}return i.apply(this,arguments)};}function se(e,t){if(!e.RTCPeerConnection||!e.RTCPeerConnection.prototype)return;const i=e.RTCPeerConnection.prototype.addIceCandidate;i&&0!==i.length&&(e.RTCPeerConnection.prototype.addIceCandidate=function(){return arguments[0]?("chrome"===t.browser&&t.version<78||"firefox"===t.browser&&t.version<68||"safari"===t.browser)&&arguments[0]&&""===arguments[0].candidate?Promise.resolve():i.apply(this,arguments):(arguments[1]&&arguments[1].apply(null),Promise.resolve())});}function oe(e,t){if(!e.RTCPeerConnection||!e.RTCPeerConnection.prototype)return;const i=e.RTCPeerConnection.prototype.setLocalDescription;i&&0!==i.length&&(e.RTCPeerConnection.prototype.setLocalDescription=function(){let e=arguments[0]||{};if("object"!=typeof e||e.type&&e.sdp)return i.apply(this,arguments);if(e={type:e.type,sdp:e.sdp},!e.type)switch(this.signalingState){case"stable":case"have-local-offer":case"have-remote-pranswer":e.type="offer";break;default:e.type="answer";}if(e.sdp||"offer"!==e.type&&"answer"!==e.type)return i.apply(this,[e]);return ("offer"===e.type?this.createOffer:this.createAnswer).apply(this).then((e=>i.apply(this,[e])))});}var ae=Object.freeze({__proto__:null,removeExtmapAllowMixed:re,shimAddIceCandidateNullOrEmpty:se,shimConnectionState:ne,shimMaxMessageSize:te,shimParameterlessSetLocalDescription:oe,shimRTCIceCandidate:$,shimRTCIceCandidateRelayProtocol:ee,shimSendThrowTypeError:ie});!function({window:e}={},t={shimChrome:!0,shimFirefox:!0,shimSafari:!0}){const i=a,r=function(e){const t={browser:null,version:null};if(void 0===e||!e.navigator)return t.browser="Not a browser.",t;const{navigator:i}=e;if(i.mozGetUserMedia)t.browser="firefox",t.version=n(i.userAgent,/Firefox\/(\d+)\./,1);else if(i.webkitGetUserMedia||!1===e.isSecureContext&&e.webkitRTCPeerConnection)t.browser="chrome",t.version=n(i.userAgent,/Chrom(e|ium)\/(\d+)\./,2);else {if(!e.RTCPeerConnection||!i.userAgent.match(/AppleWebKit\/(\d+)\./))return t.browser="Not a supported browser.",t;t.browser="safari",t.version=n(i.userAgent,/AppleWebKit\/(\d+)\./,1),t.supportsUnifiedPlan=e.RTCRtpTransceiver&&"currentDirection"in e.RTCRtpTransceiver.prototype;}return t}(e),c={browserDetails:r,commonShim:ae,extractVersion:n,disableLog:s,disableWarnings:o,sdp:Z};switch(r.browser){case"chrome":if(!I||!C||!t.shimChrome)return i("Chrome shim is not included in this adapter release."),c;if(null===r.version)return i("Chrome shim can not determine version, not shimming."),c;i("adapter.js shimming chrome."),c.browserShim=I,se(e,r),oe(e),_(e,r),E(e),C(e,r),m(e),R(e,r),f(e),g(e),T(e),v(e,r),$(e),ee(e),ne(e),te(e,r),ie(e),re(e,r);break;case"firefox":if(!U||!b||!t.shimFirefox)return i("Firefox shim is not included in this adapter release."),c;i("adapter.js shimming firefox."),c.browserShim=U,se(e,r),oe(e),y(e,r),b(e,r),A(e),N(e),w(e),O(e),D(e),P(e),L(e),k(e),M(e),$(e),ne(e),te(e,r),ie(e);break;case"safari":if(!Y||!t.shimSafari)return i("Safari shim is not included in this adapter release."),c;i("adapter.js shimming safari."),c.browserShim=Y,se(e,r),oe(e),G(e),H(e),F(e),x(e),V(e),W(e),B(e),K(e),$(e),ee(e),te(e,r),ie(e),re(e,r);break;default:i("Unsupported browser!");}}({window:"undefined"==typeof window?void 0:window});var ce=function(e){try{return !!e()}catch(e){return !0}},de=!ce((function(){var e=function(){}.bind();return "function"!=typeof e||e.hasOwnProperty("prototype")})),le=de,he=Function.prototype,ue=he.call,pe=le&&he.bind.bind(ue,ue),_e=le?pe:function(e){return function(){return ue.apply(e,arguments)}},Ee=_e({}.isPrototypeOf),me=function(e){return e&&e.Math==Math&&e},fe=me("object"==typeof globalThis&&globalThis)||me("object"==typeof window&&window)||me("object"==typeof self&&self)||me("object"==typeof q&&q)||function(){return this}()||q||Function("return this")(),ge=de,Te=Function.prototype,Se=Te.apply,Re=Te.call,Ce="object"==typeof Reflect&&Reflect.apply||(ge?Re.bind(Se):function(){return Re.apply(Se,arguments)}),ve=_e,Ie=ve({}.toString),ye=ve("".slice),Ae=function(e){return ye(Ie(e),8,-1)},be=Ae,we=_e,Oe=function(e){if("Function"===be(e))return we(e)},Ne="object"==typeof document&&document.all,De={all:Ne,IS_HTMLDDA:void 0===Ne&&void 0!==Ne},Pe=De.all,Le=De.IS_HTMLDDA?function(e){return "function"==typeof e||e===Pe}:function(e){return "function"==typeof e},ke={},Me=!ce((function(){return 7!=Object.defineProperty({},1,{get:function(){return 7}})[1]})),Ue=de,xe=Function.prototype.call,Ve=Ue?xe.bind(xe):function(){return xe.apply(xe,arguments)},Fe={},Be={}.propertyIsEnumerable,je=Object.getOwnPropertyDescriptor,Ge=je&&!Be.call({1:2},1);Fe.f=Ge?function(e){var t=je(this,e);return !!t&&t.enumerable}:Be;var We,He,Ke=function(e,t){return {enumerable:!(1&e),configurable:!(2&e),writable:!(4&e),value:t}},Ye=ce,qe=Ae,Je=Object,ze=_e("".split),Xe=Ye((function(){return !Je("z").propertyIsEnumerable(0)}))?function(e){return "String"==qe(e)?ze(e,""):Je(e)}:Je,Qe=function(e){return null==e},Ze=Qe,$e=TypeError,et=function(e){if(Ze(e))throw $e("Can't call method on "+e);return e},tt=Xe,it=et,nt=function(e){return tt(it(e))},rt=Le,st=De.all,ot=De.IS_HTMLDDA?function(e){return "object"==typeof e?null!==e:rt(e)||e===st}:function(e){return "object"==typeof e?null!==e:rt(e)},at={},ct=at,dt=fe,lt=Le,ht=function(e){return lt(e)?e:void 0},ut=function(e,t){return arguments.length<2?ht(ct[e])||ht(dt[e]):ct[e]&&ct[e][t]||dt[e]&&dt[e][t]},pt="undefined"!=typeof navigator&&String(navigator.userAgent)||"",_t=fe,Et=pt,mt=_t.process,ft=_t.Deno,gt=mt&&mt.versions||ft&&ft.version,Tt=gt&&gt.v8;Tt&&(He=(We=Tt.split("."))[0]>0&&We[0]<4?1:+(We[0]+We[1])),!He&&Et&&(!(We=Et.match(/Edge\/(\d+)/))||We[1]>=74)&&(We=Et.match(/Chrome\/(\d+)/))&&(He=+We[1]);var St=He,Rt=St,Ct=ce,vt=fe.String,It=!!Object.getOwnPropertySymbols&&!Ct((function(){var e=Symbol();return !vt(e)||!(Object(e)instanceof Symbol)||!Symbol.sham&&Rt&&Rt<41})),yt=It&&!Symbol.sham&&"symbol"==typeof Symbol.iterator,At=ut,bt=Le,wt=Ee,Ot=Object,Nt=yt?function(e){return "symbol"==typeof e}:function(e){var t=At("Symbol");return bt(t)&&wt(t.prototype,Ot(e))},Dt=String,Pt=function(e){try{return Dt(e)}catch(e){return "Object"}},Lt=Le,kt=Pt,Mt=TypeError,Ut=function(e){if(Lt(e))return e;throw Mt(kt(e)+" is not a function")},xt=Ut,Vt=Qe,Ft=function(e,t){var i=e[t];return Vt(i)?void 0:xt(i)},Bt=Ve,jt=Le,Gt=ot,Wt=TypeError,Ht={exports:{}},Kt=fe,Yt=Object.defineProperty,qt=function(e,t){try{Yt(Kt,e,{value:t,configurable:!0,writable:!0});}catch(i){Kt[e]=t;}return t},Jt="__core-js_shared__",zt=fe[Jt]||qt(Jt,{}),Xt=zt;(Ht.exports=function(e,t){return Xt[e]||(Xt[e]=void 0!==t?t:{})})("versions",[]).push({version:"3.31.1",mode:"pure",copyright:"© 2014-2023 Denis Pushkarev (zloirock.ru)",license:"https://github.com/zloirock/core-js/blob/v3.31.1/LICENSE",source:"https://github.com/zloirock/core-js"});var Qt=Ht.exports,Zt=et,$t=Object,ei=function(e){return $t(Zt(e))},ti=ei,ii=_e({}.hasOwnProperty),ni=Object.hasOwn||function(e,t){return ii(ti(e),t)},ri=_e,si=0,oi=Math.random(),ai=ri(1..toString),ci=function(e){return "Symbol("+(void 0===e?"":e)+")_"+ai(++si+oi,36)},di=Qt,li=ni,hi=ci,ui=It,pi=yt,_i=fe.Symbol,Ei=di("wks"),mi=pi?_i.for||_i:_i&&_i.withoutSetter||hi,fi=function(e){return li(Ei,e)||(Ei[e]=ui&&li(_i,e)?_i[e]:mi("Symbol."+e)),Ei[e]},gi=Ve,Ti=ot,Si=Nt,Ri=Ft,Ci=function(e,t){var i,n;if("string"===t&&jt(i=e.toString)&&!Gt(n=Bt(i,e)))return n;if(jt(i=e.valueOf)&&!Gt(n=Bt(i,e)))return n;if("string"!==t&&jt(i=e.toString)&&!Gt(n=Bt(i,e)))return n;throw Wt("Can't convert object to primitive value")},vi=TypeError,Ii=fi("toPrimitive"),yi=function(e,t){if(!Ti(e)||Si(e))return e;var i,n=Ri(e,Ii);if(n){if(void 0===t&&(t="default"),i=gi(n,e,t),!Ti(i)||Si(i))return i;throw vi("Can't convert object to primitive value")}return void 0===t&&(t="number"),Ci(e,t)},Ai=Nt,bi=function(e){var t=yi(e,"string");return Ai(t)?t:t+""},wi=ot,Oi=fe.document,Ni=wi(Oi)&&wi(Oi.createElement),Di=function(e){return Ni?Oi.createElement(e):{}},Pi=Di,Li=!Me&&!ce((function(){return 7!=Object.defineProperty(Pi("div"),"a",{get:function(){return 7}}).a})),ki=Me,Mi=Ve,Ui=Fe,xi=Ke,Vi=nt,Fi=bi,Bi=ni,ji=Li,Gi=Object.getOwnPropertyDescriptor;ke.f=ki?Gi:function(e,t){if(e=Vi(e),t=Fi(t),ji)try{return Gi(e,t)}catch(e){}if(Bi(e,t))return xi(!Mi(Ui.f,e,t),e[t])};var Wi=ce,Hi=Le,Ki=/#|\.prototype\./,Yi=function(e,t){var i=Ji[qi(e)];return i==Xi||i!=zi&&(Hi(t)?Wi(t):!!t)},qi=Yi.normalize=function(e){return String(e).replace(Ki,".").toLowerCase()},Ji=Yi.data={},zi=Yi.NATIVE="N",Xi=Yi.POLYFILL="P",Qi=Yi,Zi=Ut,$i=de,en=Oe(Oe.bind),tn=function(e,t){return Zi(e),void 0===t?e:$i?en(e,t):function(){return e.apply(t,arguments)}},nn={},rn=Me&&ce((function(){return 42!=Object.defineProperty((function(){}),"prototype",{value:42,writable:!1}).prototype})),sn=ot,on=String,an=TypeError,cn=function(e){if(sn(e))return e;throw an(on(e)+" is not an object")},dn=Me,ln=Li,hn=rn,un=cn,pn=bi,_n=TypeError,En=Object.defineProperty,mn=Object.getOwnPropertyDescriptor,fn="enumerable",gn="configurable",Tn="writable";nn.f=dn?hn?function(e,t,i){if(un(e),t=pn(t),un(i),"function"==typeof e&&"prototype"===t&&"value"in i&&Tn in i&&!i[Tn]){var n=mn(e,t);n&&n[Tn]&&(e[t]=i.value,i={configurable:gn in i?i[gn]:n[gn],enumerable:fn in i?i[fn]:n[fn],writable:!1});}return En(e,t,i)}:En:function(e,t,i){if(un(e),t=pn(t),un(i),ln)try{return En(e,t,i)}catch(e){}if("get"in i||"set"in i)throw _n("Accessors not supported");return "value"in i&&(e[t]=i.value),e};var Sn=nn,Rn=Ke,Cn=Me?function(e,t,i){return Sn.f(e,t,Rn(1,i))}:function(e,t,i){return e[t]=i,e},vn=fe,In=Ce,yn=Oe,An=Le,bn=ke.f,wn=Qi,On=at,Nn=tn,Dn=Cn,Pn=ni,Ln=function(e){var t=function(i,n,r){if(this instanceof t){switch(arguments.length){case 0:return new e;case 1:return new e(i);case 2:return new e(i,n)}return new e(i,n,r)}return In(e,this,arguments)};return t.prototype=e.prototype,t},kn=function(e,t){var i,n,r,s,o,a,c,d,l,h=e.target,u=e.global,p=e.stat,_=e.proto,E=u?vn:p?vn[h]:(vn[h]||{}).prototype,m=u?On:On[h]||Dn(On,h,{})[h],f=m.prototype;for(s in t)n=!(i=wn(u?s:h+(p?".":"#")+s,e.forced))&&E&&Pn(E,s),a=m[s],n&&(c=e.dontCallGetSet?(l=bn(E,s))&&l.value:E[s]),o=n&&c?c:t[s],n&&typeof a==typeof o||(d=e.bind&&n?Nn(o,vn):e.wrap&&n?Ln(o):_&&An(o)?yn(o):o,(e.sham||o&&o.sham||a&&a.sham)&&Dn(d,"sham",!0),Dn(m,s,d),_&&(Pn(On,r=h+"Prototype")||Dn(On,r,{}),Dn(On[r],s,o),e.real&&f&&(i||!f[s])&&Dn(f,s,o)));},Mn=Math.ceil,Un=Math.floor,xn=Math.trunc||function(e){var t=+e;return (t>0?Un:Mn)(t)},Vn=function(e){var t=+e;return t!=t||0===t?0:xn(t)},Fn=Vn,Bn=Math.max,jn=Math.min,Gn=function(e,t){var i=Fn(e);return i<0?Bn(i+t,0):jn(i,t)},Wn=Vn,Hn=Math.min,Kn=function(e){return e>0?Hn(Wn(e),9007199254740991):0},Yn=function(e){return Kn(e.length)},qn=nt,Jn=Gn,zn=Yn,Xn=function(e){return function(t,i,n){var r,s=qn(t),o=zn(s),a=Jn(n,o);if(e&&i!=i){for(;o>a;)if((r=s[a++])!=r)return !0}else for(;o>a;a++)if((e||a in s)&&s[a]===i)return e||a||0;return !e&&-1}},Qn={includes:Xn(!0),indexOf:Xn(!1)},Zn=Qn.includes;kn({target:"Array",proto:!0,forced:ce((function(){return !Array(1).includes()}))},{includes:function(e){return Zn(this,e,arguments.length>1?arguments[1]:void 0)}});var $n=at,er=function(e){return $n[e+"Prototype"]},tr=er("Array").includes,ir=ot,nr=Ae,rr=fi("match"),sr=function(e){var t;return ir(e)&&(void 0!==(t=e[rr])?!!t:"RegExp"==nr(e))},or=TypeError,ar={};ar[fi("toStringTag")]="z";var cr="[object z]"===String(ar),dr=cr,lr=Le,hr=Ae,ur=fi("toStringTag"),pr=Object,_r="Arguments"==hr(function(){return arguments}()),Er=dr?hr:function(e){var t,i,n;return void 0===e?"Undefined":null===e?"Null":"string"==typeof(i=function(e,t){try{return e[t]}catch(e){}}(t=pr(e),ur))?i:_r?hr(t):"Object"==(n=hr(t))&&lr(t.callee)?"Arguments":n},mr=Er,fr=String,gr=function(e){if("Symbol"===mr(e))throw TypeError("Cannot convert a Symbol value to a string");return fr(e)},Tr=fi("match"),Sr=kn,Rr=function(e){if(sr(e))throw or("The method doesn't accept regular expressions");return e},Cr=et,vr=gr,Ir=function(e){var t=/./;try{"/./"[e](t);}catch(i){try{return t[Tr]=!1,"/./"[e](t)}catch(e){}}return !1},yr=_e("".indexOf);Sr({target:"String",proto:!0,forced:!Ir("includes")},{includes:function(e){return !!~yr(vr(Cr(this)),vr(Rr(e)),arguments.length>1?arguments[1]:void 0)}});var Ar=er("String").includes,br=Ee,wr=tr,Or=Ar,Nr=Array.prototype,Dr=String.prototype,Pr=J((function(e){var t=e.includes;return e===Nr||br(Nr,e)&&t===Nr.includes?wr:"string"==typeof e||e===Dr||br(Dr,e)&&t===Dr.includes?Or:t})),Lr={exports:{}},kr=kn,Mr=Me,Ur=nn.f;kr({target:"Object",stat:!0,forced:Object.defineProperty!==Ur,sham:!Mr},{defineProperty:Ur});var xr=at.Object,Vr=Lr.exports=function(e,t,i){return xr.defineProperty(e,t,i)};xr.defineProperty.sham&&(Vr.sham=!0);var Fr=J(Lr.exports),Br=Ae,jr=Array.isArray||function(e){return "Array"==Br(e)},Gr=TypeError,Wr=bi,Hr=nn,Kr=Ke,Yr=function(e,t,i){var n=Wr(t);n in e?Hr.f(e,n,Kr(0,i)):e[n]=i;},qr=Le,Jr=zt,zr=_e(Function.toString);qr(Jr.inspectSource)||(Jr.inspectSource=function(e){return zr(e)});var Xr=Jr.inspectSource,Qr=_e,Zr=ce,$r=Le,es=Er,ts=Xr,is=function(){},ns=[],rs=ut("Reflect","construct"),ss=/^\s*(?:class|function)\b/,os=Qr(ss.exec),as=!ss.exec(is),cs=function(e){if(!$r(e))return !1;try{return rs(is,ns,e),!0}catch(e){return !1}},ds=function(e){if(!$r(e))return !1;switch(es(e)){case"AsyncFunction":case"GeneratorFunction":case"AsyncGeneratorFunction":return !1}try{return as||!!os(ss,ts(e))}catch(e){return !0}};ds.sham=!0;var ls=!rs||Zr((function(){var e;return cs(cs.call)||!cs(Object)||!cs((function(){e=!0;}))||e}))?ds:cs,hs=jr,us=ls,ps=ot,_s=fi("species"),Es=Array,ms=function(e){var t;return hs(e)&&(t=e.constructor,(us(t)&&(t===Es||hs(t.prototype))||ps(t)&&null===(t=t[_s]))&&(t=void 0)),void 0===t?Es:t},fs=function(e,t){return new(ms(e))(0===t?0:t)},gs=ce,Ts=St,Ss=fi("species"),Rs=kn,Cs=ce,vs=jr,Is=ot,ys=ei,As=Yn,bs=function(e){if(e>9007199254740991)throw Gr("Maximum allowed index exceeded");return e},ws=Yr,Os=fs,Ns=function(e){return Ts>=51||!gs((function(){var t=[];return (t.constructor={})[Ss]=function(){return {foo:1}},1!==t[e](Boolean).foo}))},Ds=St,Ps=fi("isConcatSpreadable"),Ls=Ds>=51||!Cs((function(){var e=[];return e[Ps]=!1,e.concat()[0]!==e})),ks=function(e){if(!Is(e))return !1;var t=e[Ps];return void 0!==t?!!t:vs(e)};Rs({target:"Array",proto:!0,arity:1,forced:!Ls||!Ns("concat")},{concat:function(e){var t,i,n,r,s,o=ys(this),a=Os(o,0),c=0;for(t=-1,n=arguments.length;t<n;t++)if(ks(s=-1===t?o:arguments[t]))for(r=As(s),bs(c+r),i=0;i<r;i++,c++)i in s&&ws(a,c,s[i]);else bs(c+1),ws(a,c++,s);return a.length=c,a}});var Ms={},Us={},xs=ni,Vs=nt,Fs=Qn.indexOf,Bs=Us,js=_e([].push),Gs=function(e,t){var i,n=Vs(e),r=0,s=[];for(i in n)!xs(Bs,i)&&xs(n,i)&&js(s,i);for(;t.length>r;)xs(n,i=t[r++])&&(~Fs(s,i)||js(s,i));return s},Ws=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"],Hs=Gs,Ks=Ws,Ys=Object.keys||function(e){return Hs(e,Ks)},qs=Me,Js=rn,zs=nn,Xs=cn,Qs=nt,Zs=Ys;Ms.f=qs&&!Js?Object.defineProperties:function(e,t){Xs(e);for(var i,n=Qs(t),r=Zs(t),s=r.length,o=0;s>o;)zs.f(e,i=r[o++],n[i]);return e};var $s,eo=ut("document","documentElement"),to=ci,io=Qt("keys"),no=function(e){return io[e]||(io[e]=to(e))},ro=cn,so=Ms,oo=Ws,ao=Us,co=eo,lo=Di,ho="prototype",uo="script",po=no("IE_PROTO"),_o=function(){},Eo=function(e){return "<"+uo+">"+e+"</"+uo+">"},mo=function(e){e.write(Eo("")),e.close();var t=e.parentWindow.Object;return e=null,t},fo=function(){try{$s=new ActiveXObject("htmlfile");}catch(e){}var e,t,i;fo="undefined"!=typeof document?document.domain&&$s?mo($s):(t=lo("iframe"),i="java"+uo+":",t.style.display="none",co.appendChild(t),t.src=String(i),(e=t.contentWindow.document).open(),e.write(Eo("document.F=Object")),e.close(),e.F):mo($s);for(var n=oo.length;n--;)delete fo[ho][oo[n]];return fo()};ao[po]=!0;var go=Object.create||function(e,t){var i;return null!==e?(_o[ho]=ro(e),i=new _o,_o[ho]=null,i[po]=e):i=fo(),void 0===t?i:so.f(i,t)},To={},So=Gs,Ro=Ws.concat("length","prototype");To.f=Object.getOwnPropertyNames||function(e){return So(e,Ro)};var Co={},vo=Gn,Io=Yn,yo=Yr,Ao=Array,bo=Math.max,wo=function(e,t,i){for(var n=Io(e),r=vo(t,n),s=vo(void 0===i?n:i,n),o=Ao(bo(s-r,0)),a=0;r<s;r++,a++)yo(o,a,e[r]);return o.length=a,o},Oo=Ae,No=nt,Do=To.f,Po=wo,Lo="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[];Co.f=function(e){return Lo&&"Window"==Oo(e)?function(e){try{return Do(e)}catch(e){return Po(Lo)}}(e):Do(No(e))};var ko={};ko.f=Object.getOwnPropertySymbols;var Mo=Cn,Uo=function(e,t,i,n){return n&&n.enumerable?e[t]=i:Mo(e,t,i),e},xo=nn,Vo=function(e,t,i){return xo.f(e,t,i)},Fo={},Bo=fi;Fo.f=Bo;var jo,Go,Wo,Ho=at,Ko=ni,Yo=Fo,qo=nn.f,Jo=function(e){var t=Ho.Symbol||(Ho.Symbol={});Ko(t,e)||qo(t,e,{value:Yo.f(e)});},zo=Ve,Xo=ut,Qo=fi,Zo=Uo,$o=function(){var e=Xo("Symbol"),t=e&&e.prototype,i=t&&t.valueOf,n=Qo("toPrimitive");t&&!t[n]&&Zo(t,n,(function(e){return zo(i,this)}),{arity:1});},ea=Er,ta=cr?{}.toString:function(){return "[object "+ea(this)+"]"},ia=cr,na=nn.f,ra=Cn,sa=ni,oa=ta,aa=fi("toStringTag"),ca=function(e,t,i,n){if(e){var r=i?e:e.prototype;sa(r,aa)||na(r,aa,{configurable:!0,value:t}),n&&!ia&&ra(r,"toString",oa);}},da=Le,la=fe.WeakMap,ha=da(la)&&/native code/.test(String(la)),ua=fe,pa=ot,_a=Cn,Ea=ni,ma=zt,fa=no,ga=Us,Ta="Object already initialized",Sa=ua.TypeError,Ra=ua.WeakMap;if(ha||ma.state){var Ca=ma.state||(ma.state=new Ra);Ca.get=Ca.get,Ca.has=Ca.has,Ca.set=Ca.set,jo=function(e,t){if(Ca.has(e))throw Sa(Ta);return t.facade=e,Ca.set(e,t),t},Go=function(e){return Ca.get(e)||{}},Wo=function(e){return Ca.has(e)};}else {var va=fa("state");ga[va]=!0,jo=function(e,t){if(Ea(e,va))throw Sa(Ta);return t.facade=e,_a(e,va,t),t},Go=function(e){return Ea(e,va)?e[va]:{}},Wo=function(e){return Ea(e,va)};}var Ia={set:jo,get:Go,has:Wo,enforce:function(e){return Wo(e)?Go(e):jo(e,{})},getterFor:function(e){return function(t){var i;if(!pa(t)||(i=Go(t)).type!==e)throw Sa("Incompatible receiver, "+e+" required");return i}}},ya=tn,Aa=Xe,ba=ei,wa=Yn,Oa=fs,Na=_e([].push),Da=function(e){var t=1==e,i=2==e,n=3==e,r=4==e,s=6==e,o=7==e,a=5==e||s;return function(c,d,l,h){for(var u,p,_=ba(c),E=Aa(_),m=ya(d,l),f=wa(E),g=0,T=h||Oa,S=t?T(c,f):i||o?T(c,0):void 0;f>g;g++)if((a||g in E)&&(p=m(u=E[g],g,_),e))if(t)S[g]=p;else if(p)switch(e){case 3:return !0;case 5:return u;case 6:return g;case 2:Na(S,u);}else switch(e){case 4:return !1;case 7:Na(S,u);}return s?-1:n||r?r:S}},Pa={forEach:Da(0),map:Da(1),filter:Da(2),some:Da(3),every:Da(4),find:Da(5),findIndex:Da(6),filterReject:Da(7)},La=kn,ka=fe,Ma=Ve,Ua=_e,xa=Me,Va=It,Fa=ce,Ba=ni,ja=Ee,Ga=cn,Wa=nt,Ha=bi,Ka=gr,Ya=Ke,qa=go,Ja=Ys,za=To,Xa=Co,Qa=ko,Za=ke,$a=nn,ec=Ms,tc=Fe,ic=Uo,nc=Vo,rc=Qt,sc=Us,oc=ci,ac=fi,cc=Fo,dc=Jo,lc=$o,hc=ca,uc=Ia,pc=Pa.forEach,_c=no("hidden"),Ec="Symbol",mc="prototype",fc=uc.set,gc=uc.getterFor(Ec),Tc=Object[mc],Sc=ka.Symbol,Rc=Sc&&Sc[mc],Cc=ka.TypeError,vc=ka.QObject,Ic=Za.f,yc=$a.f,Ac=Xa.f,bc=tc.f,wc=Ua([].push),Oc=rc("symbols"),Nc=rc("op-symbols"),Dc=rc("wks"),Pc=!vc||!vc[mc]||!vc[mc].findChild,Lc=xa&&Fa((function(){return 7!=qa(yc({},"a",{get:function(){return yc(this,"a",{value:7}).a}})).a}))?function(e,t,i){var n=Ic(Tc,t);n&&delete Tc[t],yc(e,t,i),n&&e!==Tc&&yc(Tc,t,n);}:yc,kc=function(e,t){var i=Oc[e]=qa(Rc);return fc(i,{type:Ec,tag:e,description:t}),xa||(i.description=t),i},Mc=function(e,t,i){e===Tc&&Mc(Nc,t,i),Ga(e);var n=Ha(t);return Ga(i),Ba(Oc,n)?(i.enumerable?(Ba(e,_c)&&e[_c][n]&&(e[_c][n]=!1),i=qa(i,{enumerable:Ya(0,!1)})):(Ba(e,_c)||yc(e,_c,Ya(1,{})),e[_c][n]=!0),Lc(e,n,i)):yc(e,n,i)},Uc=function(e,t){Ga(e);var i=Wa(t),n=Ja(i).concat(Bc(i));return pc(n,(function(t){xa&&!Ma(xc,i,t)||Mc(e,t,i[t]);})),e},xc=function(e){var t=Ha(e),i=Ma(bc,this,t);return !(this===Tc&&Ba(Oc,t)&&!Ba(Nc,t))&&(!(i||!Ba(this,t)||!Ba(Oc,t)||Ba(this,_c)&&this[_c][t])||i)},Vc=function(e,t){var i=Wa(e),n=Ha(t);if(i!==Tc||!Ba(Oc,n)||Ba(Nc,n)){var r=Ic(i,n);return !r||!Ba(Oc,n)||Ba(i,_c)&&i[_c][n]||(r.enumerable=!0),r}},Fc=function(e){var t=Ac(Wa(e)),i=[];return pc(t,(function(e){Ba(Oc,e)||Ba(sc,e)||wc(i,e);})),i},Bc=function(e){var t=e===Tc,i=Ac(t?Nc:Wa(e)),n=[];return pc(i,(function(e){!Ba(Oc,e)||t&&!Ba(Tc,e)||wc(n,Oc[e]);})),n};Va||(Sc=function(){if(ja(Rc,this))throw Cc("Symbol is not a constructor");var e=arguments.length&&void 0!==arguments[0]?Ka(arguments[0]):void 0,t=oc(e),i=function(e){this===Tc&&Ma(i,Nc,e),Ba(this,_c)&&Ba(this[_c],t)&&(this[_c][t]=!1),Lc(this,t,Ya(1,e));};return xa&&Pc&&Lc(Tc,t,{configurable:!0,set:i}),kc(t,e)},ic(Rc=Sc[mc],"toString",(function(){return gc(this).tag})),ic(Sc,"withoutSetter",(function(e){return kc(oc(e),e)})),tc.f=xc,$a.f=Mc,ec.f=Uc,Za.f=Vc,za.f=Xa.f=Fc,Qa.f=Bc,cc.f=function(e){return kc(ac(e),e)},xa&&nc(Rc,"description",{configurable:!0,get:function(){return gc(this).description}})),La({global:!0,constructor:!0,wrap:!0,forced:!Va,sham:!Va},{Symbol:Sc}),pc(Ja(Dc),(function(e){dc(e);})),La({target:Ec,stat:!0,forced:!Va},{useSetter:function(){Pc=!0;},useSimple:function(){Pc=!1;}}),La({target:"Object",stat:!0,forced:!Va,sham:!xa},{create:function(e,t){return void 0===t?qa(e):Uc(qa(e),t)},defineProperty:Mc,defineProperties:Uc,getOwnPropertyDescriptor:Vc}),La({target:"Object",stat:!0,forced:!Va},{getOwnPropertyNames:Fc}),lc(),hc(Sc,Ec),sc[_c]=!0;var jc=It&&!!Symbol.for&&!!Symbol.keyFor,Gc=kn,Wc=ut,Hc=ni,Kc=gr,Yc=Qt,qc=jc,Jc=Yc("string-to-symbol-registry"),zc=Yc("symbol-to-string-registry");Gc({target:"Symbol",stat:!0,forced:!qc},{for:function(e){var t=Kc(e);if(Hc(Jc,t))return Jc[t];var i=Wc("Symbol")(t);return Jc[t]=i,zc[i]=t,i}});var Xc=kn,Qc=ni,Zc=Nt,$c=Pt,ed=jc,td=Qt("symbol-to-string-registry");Xc({target:"Symbol",stat:!0,forced:!ed},{keyFor:function(e){if(!Zc(e))throw TypeError($c(e)+" is not a symbol");if(Qc(td,e))return td[e]}});var id=_e([].slice),nd=jr,rd=Le,sd=Ae,od=gr,ad=_e([].push),cd=kn,dd=ut,ld=Ce,hd=Ve,ud=_e,pd=ce,_d=Le,Ed=Nt,md=id,fd=function(e){if(rd(e))return e;if(nd(e)){for(var t=e.length,i=[],n=0;n<t;n++){var r=e[n];"string"==typeof r?ad(i,r):"number"!=typeof r&&"Number"!=sd(r)&&"String"!=sd(r)||ad(i,od(r));}var s=i.length,o=!0;return function(e,t){if(o)return o=!1,t;if(nd(this))return t;for(var n=0;n<s;n++)if(i[n]===e)return t}}},gd=It,Td=String,Sd=dd("JSON","stringify"),Rd=ud(/./.exec),Cd=ud("".charAt),vd=ud("".charCodeAt),Id=ud("".replace),yd=ud(1..toString),Ad=/[\uD800-\uDFFF]/g,bd=/^[\uD800-\uDBFF]$/,wd=/^[\uDC00-\uDFFF]$/,Od=!gd||pd((function(){var e=dd("Symbol")();return "[null]"!=Sd([e])||"{}"!=Sd({a:e})||"{}"!=Sd(Object(e))})),Nd=pd((function(){return '"\\udf06\\ud834"'!==Sd("\udf06\ud834")||'"\\udead"'!==Sd("\udead")})),Dd=function(e,t){var i=md(arguments),n=fd(t);if(_d(n)||void 0!==e&&!Ed(e))return i[1]=function(e,t){if(_d(n)&&(t=hd(n,this,Td(e),t)),!Ed(t))return t},ld(Sd,null,i)},Pd=function(e,t,i){var n=Cd(i,t-1),r=Cd(i,t+1);return Rd(bd,e)&&!Rd(wd,r)||Rd(wd,e)&&!Rd(bd,n)?"\\u"+yd(vd(e,0),16):e};Sd&&cd({target:"JSON",stat:!0,arity:3,forced:Od||Nd},{stringify:function(e,t,i){var n=md(arguments),r=ld(Od?Dd:Sd,null,n);return Nd&&"string"==typeof r?Id(r,Ad,Pd):r}});var Ld=ko,kd=ei;kn({target:"Object",stat:!0,forced:!It||ce((function(){Ld.f(1);}))},{getOwnPropertySymbols:function(e){var t=Ld.f;return t?t(kd(e)):[]}}),Jo("asyncIterator"),Jo("hasInstance"),Jo("isConcatSpreadable"),Jo("iterator"),Jo("match"),Jo("matchAll"),Jo("replace"),Jo("search"),Jo("species"),Jo("split");var Md=$o;Jo("toPrimitive"),Md();var Ud=ut,xd=ca;Jo("toStringTag"),xd(Ud("Symbol"),"Symbol"),Jo("unscopables"),ca(fe.JSON,"JSON",!0);var Vd,Fd,Bd,jd=at.Symbol,Gd={},Wd=Me,Hd=ni,Kd=Function.prototype,Yd=Wd&&Object.getOwnPropertyDescriptor,qd=Hd(Kd,"name"),Jd={EXISTS:qd,PROPER:qd&&"something"===function(){}.name,CONFIGURABLE:qd&&(!Wd||Wd&&Yd(Kd,"name").configurable)},zd=!ce((function(){function e(){}return e.prototype.constructor=null,Object.getPrototypeOf(new e)!==e.prototype})),Xd=ni,Qd=Le,Zd=ei,$d=zd,el=no("IE_PROTO"),tl=Object,il=tl.prototype,nl=$d?tl.getPrototypeOf:function(e){var t=Zd(e);if(Xd(t,el))return t[el];var i=t.constructor;return Qd(i)&&t instanceof i?i.prototype:t instanceof tl?il:null},rl=ce,sl=Le,ol=ot,al=go,cl=nl,dl=Uo,ll=fi("iterator"),hl=!1;[].keys&&("next"in(Bd=[].keys())?(Fd=cl(cl(Bd)))!==Object.prototype&&(Vd=Fd):hl=!0);var ul=!ol(Vd)||rl((function(){var e={};return Vd[ll].call(e)!==e}));sl((Vd=ul?{}:al(Vd))[ll])||dl(Vd,ll,(function(){return this}));var pl={IteratorPrototype:Vd,BUGGY_SAFARI_ITERATORS:hl},_l=pl.IteratorPrototype,El=go,ml=Ke,fl=ca,gl=Gd,Tl=function(){return this},Sl=_e,Rl=Ut,Cl=Le,vl=String,Il=TypeError,yl=function(e,t,i){try{return Sl(Rl(Object.getOwnPropertyDescriptor(e,t)[i]))}catch(e){}},Al=cn,bl=function(e){if("object"==typeof e||Cl(e))return e;throw Il("Can't set "+vl(e)+" as a prototype")},wl=Object.setPrototypeOf||("__proto__"in{}?function(){var e,t=!1,i={};try{(e=yl(Object.prototype,"__proto__","set"))(i,[]),t=i instanceof Array;}catch(e){}return function(i,n){return Al(i),bl(n),t?e(i,n):i.__proto__=n,i}}():void 0),Ol=kn,Nl=Ve,Dl=Jd,Pl=function(e,t,i,n){var r=t+" Iterator";return e.prototype=El(_l,{next:ml(+!n,i)}),fl(e,r,!1,!0),gl[r]=Tl,e},Ll=nl,kl=ca,Ml=Uo,Ul=Gd,xl=pl,Vl=Dl.PROPER,Fl=xl.BUGGY_SAFARI_ITERATORS,Bl=fi("iterator"),jl="keys",Gl="values",Wl="entries",Hl=function(){return this},Kl=function(e,t,i,n,r,s,o){Pl(i,t,n);var a,c,d,l=function(e){if(e===r&&E)return E;if(!Fl&&e in p)return p[e];switch(e){case jl:case Gl:case Wl:return function(){return new i(this,e)}}return function(){return new i(this)}},h=t+" Iterator",u=!1,p=e.prototype,_=p[Bl]||p["@@iterator"]||r&&p[r],E=!Fl&&_||l(r),m="Array"==t&&p.entries||_;if(m&&(a=Ll(m.call(new e)))!==Object.prototype&&a.next&&(kl(a,h,!0,!0),Ul[h]=Hl),Vl&&r==Gl&&_&&_.name!==Gl&&(u=!0,E=function(){return Nl(_,this)}),r)if(c={values:l(Gl),keys:s?E:l(jl),entries:l(Wl)},o)for(d in c)(Fl||u||!(d in p))&&Ml(p,d,c[d]);else Ol({target:t,proto:!0,forced:Fl||u},c);return o&&p[Bl]!==E&&Ml(p,Bl,E,{name:r}),Ul[t]=E,c},Yl=function(e,t){return {value:e,done:t}},ql=nt,Jl=Gd,zl=Ia;nn.f;var Xl=Kl,Ql=Yl,Zl="Array Iterator",$l=zl.set,eh=zl.getterFor(Zl);Xl(Array,"Array",(function(e,t){$l(this,{type:Zl,target:ql(e),index:0,kind:t});}),(function(){var e=eh(this),t=e.target,i=e.kind,n=e.index++;return !t||n>=t.length?(e.target=void 0,Ql(void 0,!0)):Ql("keys"==i?n:"values"==i?t[n]:[n,t[n]],!1)}),"values"),Jl.Arguments=Jl.Array;var th={CSSRuleList:0,CSSStyleDeclaration:0,CSSValueList:0,ClientRectList:0,DOMRectList:0,DOMStringList:0,DOMTokenList:1,DataTransferItemList:0,FileList:0,HTMLAllCollection:0,HTMLCollection:0,HTMLFormElement:0,HTMLSelectElement:0,MediaList:0,MimeTypeArray:0,NamedNodeMap:0,NodeList:1,PaintRequestList:0,Plugin:0,PluginArray:0,SVGLengthList:0,SVGNumberList:0,SVGPathSegList:0,SVGPointList:0,SVGStringList:0,SVGTransformList:0,SourceBufferList:0,StyleSheetList:0,TextTrackCueList:0,TextTrackList:0,TouchList:0},ih=fe,nh=Er,rh=Cn,sh=Gd,oh=fi("toStringTag");for(var ah in th){var ch=ih[ah],dh=ch&&ch.prototype;dh&&nh(dh)!==oh&&rh(dh,oh,ah),sh[ah]=sh.Array;}var lh=jd,hh=fi,uh=nn.f,ph=hh("metadata"),_h=Function.prototype;void 0===_h[ph]&&uh(_h,ph,{value:null}),Jo("dispose"),Jo("metadata");var Eh=lh;Jo("asyncDispose");var mh=_e,fh=ut("Symbol"),gh=fh.keyFor,Th=mh(fh.prototype.valueOf),Sh=fh.isRegisteredSymbol||function(e){try{return void 0!==gh(Th(e))}catch(e){return !1}};kn({target:"Symbol",stat:!0},{isRegisteredSymbol:Sh});for(var Rh=Qt,Ch=ut,vh=_e,Ih=Nt,yh=fi,Ah=Ch("Symbol"),bh=Ah.isWellKnownSymbol,wh=Ch("Object","getOwnPropertyNames"),Oh=vh(Ah.prototype.valueOf),Nh=Rh("wks"),Dh=0,Ph=wh(Ah),Lh=Ph.length;Dh<Lh;Dh++)try{var kh=Ph[Dh];Ih(Ah[kh])&&yh(kh);}catch(e){}var Mh=function(e){if(bh&&bh(e))return !0;try{for(var t=Oh(e),i=0,n=wh(Nh),r=n.length;i<r;i++)if(Nh[n[i]]==t)return !0}catch(e){}return !1};kn({target:"Symbol",stat:!0,forced:!0},{isWellKnownSymbol:Mh}),Jo("matcher"),Jo("observable"),kn({target:"Symbol",stat:!0,name:"isRegisteredSymbol"},{isRegistered:Sh}),kn({target:"Symbol",stat:!0,name:"isWellKnownSymbol",forced:!0},{isWellKnown:Mh}),Jo("metadataKey"),Jo("patternMatch"),Jo("replaceAll");var Uh=J(Eh),xh=_e,Vh=Vn,Fh=gr,Bh=et,jh=xh("".charAt),Gh=xh("".charCodeAt),Wh=xh("".slice),Hh=function(e){return function(t,i){var n,r,s=Fh(Bh(t)),o=Vh(i),a=s.length;return o<0||o>=a?e?"":void 0:(n=Gh(s,o))<55296||n>56319||o+1===a||(r=Gh(s,o+1))<56320||r>57343?e?jh(s,o):n:e?Wh(s,o,o+2):r-56320+(n-55296<<10)+65536}},Kh={codeAt:Hh(!1),charAt:Hh(!0)}.charAt,Yh=gr,qh=Ia,Jh=Kl,zh=Yl,Xh="String Iterator",Qh=qh.set,Zh=qh.getterFor(Xh);Jh(String,"String",(function(e){Qh(this,{type:Xh,string:Yh(e),index:0});}),(function(){var e,t=Zh(this),i=t.string,n=t.index;return n>=i.length?zh(void 0,!0):(e=Kh(i,n),t.index+=e.length,zh(e,!1))}));var $h=J(Fo.f("iterator"));function eu(e){return eu="function"==typeof Uh&&"symbol"==typeof $h?function(e){return typeof e}:function(e){return e&&"function"==typeof Uh&&e.constructor===Uh&&e!==Uh.prototype?"symbol":typeof e},eu(e)}var tu=J(Fo.f("toPrimitive"));function iu(e){var t=function(e,t){if("object"!==eu(e)||null===e)return e;var i=e[tu];if(void 0!==i){var n=i.call(e,t||"default");if("object"!==eu(n))return n;throw new TypeError("@@toPrimitive must return a primitive value.")}return ("string"===t?String:Number)(e)}(e,"string");return "symbol"===eu(t)?t:String(t)}function nu(e,t,i){return (t=iu(t))in e?Fr(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}var ru=er("Array").keys,su=Er,ou=ni,au=Ee,cu=ru,du=Array.prototype,lu={DOMTokenList:!0,NodeList:!0},hu=J((function(e){var t=e.keys;return e===du||au(du,e)&&t===du.keys||ou(lu,su(e))?cu:t})),uu=Pt,pu=TypeError,_u=wo,Eu=Math.floor,mu=function(e,t){var i=e.length,n=Eu(i/2);return i<8?fu(e,t):gu(e,mu(_u(e,0,n),t),mu(_u(e,n),t),t)},fu=function(e,t){for(var i,n,r=e.length,s=1;s<r;){for(n=s,i=e[s];n&&t(e[n-1],i)>0;)e[n]=e[--n];n!==s++&&(e[n]=i);}return e},gu=function(e,t,i,n){for(var r=t.length,s=i.length,o=0,a=0;o<r||a<s;)e[o+a]=o<r&&a<s?n(t[o],i[a])<=0?t[o++]:i[a++]:o<r?t[o++]:i[a++];return e},Tu=mu,Su=ce,Ru=function(e,t){var i=[][e];return !!i&&Su((function(){i.call(null,t||function(){return 1},1);}))},Cu=pt.match(/firefox\/(\d+)/i),vu=!!Cu&&+Cu[1],Iu=/MSIE|Trident/.test(pt),yu=pt.match(/AppleWebKit\/(\d+)\./),Au=!!yu&&+yu[1],bu=kn,wu=_e,Ou=Ut,Nu=ei,Du=Yn,Pu=function(e,t){if(!delete e[t])throw pu("Cannot delete property "+uu(t)+" of "+uu(e))},Lu=gr,ku=ce,Mu=Tu,Uu=Ru,xu=vu,Vu=Iu,Fu=St,Bu=Au,ju=[],Gu=wu(ju.sort),Wu=wu(ju.push),Hu=ku((function(){ju.sort(void 0);})),Ku=ku((function(){ju.sort(null);})),Yu=Uu("sort"),qu=!ku((function(){if(Fu)return Fu<70;if(!(xu&&xu>3)){if(Vu)return !0;if(Bu)return Bu<603;var e,t,i,n,r="";for(e=65;e<76;e++){switch(t=String.fromCharCode(e),e){case 66:case 69:case 70:case 72:i=3;break;case 68:case 71:i=4;break;default:i=2;}for(n=0;n<47;n++)ju.push({k:t+n,v:i});}for(ju.sort((function(e,t){return t.v-e.v})),n=0;n<ju.length;n++)t=ju[n].k.charAt(0),r.charAt(r.length-1)!==t&&(r+=t);return "DGBEFHACIJK"!==r}}));bu({target:"Array",proto:!0,forced:Hu||!Ku||!Yu||!qu},{sort:function(e){void 0!==e&&Ou(e);var t=Nu(this);if(qu)return void 0===e?Gu(t):Gu(t,e);var i,n,r=[],s=Du(t);for(n=0;n<s;n++)n in t&&Wu(r,t[n]);for(Mu(r,function(e){return function(t,i){return void 0===i?-1:void 0===t?1:void 0!==e?+e(t,i)||0:Lu(t)>Lu(i)?1:-1}}(e)),i=Du(r),n=0;n<i;)t[n]=r[n++];for(;n<s;)Pu(t,n++);return t}});var Ju=er("Array").sort,zu=Ee,Xu=Ju,Qu=Array.prototype,Zu=J((function(e){var t=e.sort;return e===Qu||zu(Qu,e)&&t===Qu.sort?Xu:t})),$u=ut,ep=To,tp=ko,ip=cn,np=_e([].concat),rp=$u("Reflect","ownKeys")||function(e){var t=ep.f(ip(e)),i=tp.f;return i?np(t,i(e)):t},sp=ni,op=rp,ap=ke,cp=nn,dp=ot,lp=Cn,hp=Error,up=_e("".replace),pp=String(hp("zxcasd").stack),_p=/\n\s*at [^:]*:[^\n]*/,Ep=_p.test(pp),mp=Ke,fp=!ce((function(){var e=Error("a");return !("stack"in e)||(Object.defineProperty(e,"stack",mp(1,7)),7!==e.stack)})),gp=Cn,Tp=function(e,t){if(Ep&&"string"==typeof e&&!hp.prepareStackTrace)for(;t--;)e=up(e,_p,"");return e},Sp=fp,Rp=Error.captureStackTrace,Cp=Gd,vp=fi("iterator"),Ip=Array.prototype,yp=Er,Ap=Ft,bp=Qe,wp=Gd,Op=fi("iterator"),Np=function(e){if(!bp(e))return Ap(e,Op)||Ap(e,"@@iterator")||wp[yp(e)]},Dp=Ve,Pp=Ut,Lp=cn,kp=Pt,Mp=Np,Up=TypeError,xp=Ve,Vp=cn,Fp=Ft,Bp=tn,jp=Ve,Gp=cn,Wp=Pt,Hp=function(e){return void 0!==e&&(Cp.Array===e||Ip[vp]===e)},Kp=Yn,Yp=Ee,qp=function(e,t){var i=arguments.length<2?Mp(e):t;if(Pp(i))return Lp(Dp(i,e));throw Up(kp(e)+" is not iterable")},Jp=Np,zp=function(e,t,i){var n,r;Vp(e);try{if(!(n=Fp(e,"return"))){if("throw"===t)throw i;return i}n=xp(n,e);}catch(e){r=!0,n=e;}if("throw"===t)throw i;if(r)throw n;return Vp(n),i},Xp=TypeError,Qp=function(e,t){this.stopped=e,this.result=t;},Zp=Qp.prototype,$p=function(e,t,i){var n,r,s,o,a,c,d,l=i&&i.that,h=!(!i||!i.AS_ENTRIES),u=!(!i||!i.IS_RECORD),p=!(!i||!i.IS_ITERATOR),_=!(!i||!i.INTERRUPTED),E=Bp(t,l),m=function(e){return n&&zp(n,"normal",e),new Qp(!0,e)},f=function(e){return h?(Gp(e),_?E(e[0],e[1],m):E(e[0],e[1])):_?E(e,m):E(e)};if(u)n=e.iterator;else if(p)n=e;else {if(!(r=Jp(e)))throw Xp(Wp(e)+" is not iterable");if(Hp(r)){for(s=0,o=Kp(e);o>s;s++)if((a=f(e[s]))&&Yp(Zp,a))return a;return new Qp(!1)}n=qp(e,r);}for(c=u?e.next:n.next;!(d=jp(c,n)).done;){try{a=f(d.value);}catch(e){zp(n,"throw",e);}if("object"==typeof a&&a&&Yp(Zp,a))return a}return new Qp(!1)},e_=gr,t_=kn,i_=Ee,n_=nl,r_=wl,s_=function(e,t,i){for(var n=op(t),r=cp.f,s=ap.f,o=0;o<n.length;o++){var a=n[o];sp(e,a)||i&&sp(i,a)||r(e,a,s(t,a));}},o_=go,a_=Cn,c_=Ke,d_=function(e,t){dp(t)&&"cause"in t&&lp(e,"cause",t.cause);},l_=function(e,t,i,n){Sp&&(Rp?Rp(e,t):gp(e,"stack",Tp(i,n)));},h_=$p,u_=function(e,t){return void 0===e?arguments.length<2?"":t:e_(e)},p_=fi("toStringTag"),__=Error,E_=[].push,m_=function(e,t){var i,n=i_(f_,this);r_?i=r_(__(),n?n_(this):f_):(i=n?this:o_(f_),a_(i,p_,"Error")),void 0!==t&&a_(i,"message",u_(t)),l_(i,m_,i.stack,1),arguments.length>2&&d_(i,arguments[2]);var r=[];return h_(e,E_,{that:r}),a_(i,"errors",r),i};r_?r_(m_,__):s_(m_,__,{name:!0});var f_=m_.prototype=o_(__.prototype,{constructor:c_(1,m_),message:c_(1,""),name:c_(1,"AggregateError")});t_({global:!0,constructor:!0,arity:2},{AggregateError:m_});var g_,T_,S_,R_,C_="undefined"!=typeof process&&"process"==Ae(process),v_=ut,I_=Vo,y_=Me,A_=fi("species"),b_=Ee,w_=TypeError,O_=ls,N_=Pt,D_=TypeError,P_=cn,L_=function(e){if(O_(e))return e;throw D_(N_(e)+" is not a constructor")},k_=Qe,M_=fi("species"),U_=function(e,t){var i,n=P_(e).constructor;return void 0===n||k_(i=P_(n)[M_])?t:L_(i)},x_=TypeError,V_=/(?:ipad|iphone|ipod).*applewebkit/i.test(pt),F_=fe,B_=Ce,j_=tn,G_=Le,W_=ni,H_=ce,K_=eo,Y_=id,q_=Di,J_=function(e,t){if(e<t)throw x_("Not enough arguments");return e},z_=V_,X_=C_,Q_=F_.setImmediate,Z_=F_.clearImmediate,$_=F_.process,eE=F_.Dispatch,tE=F_.Function,iE=F_.MessageChannel,nE=F_.String,rE=0,sE={},oE="onreadystatechange";H_((function(){g_=F_.location;}));var aE=function(e){if(W_(sE,e)){var t=sE[e];delete sE[e],t();}},cE=function(e){return function(){aE(e);}},dE=function(e){aE(e.data);},lE=function(e){F_.postMessage(nE(e),g_.protocol+"//"+g_.host);};Q_&&Z_||(Q_=function(e){J_(arguments.length,1);var t=G_(e)?e:tE(e),i=Y_(arguments,1);return sE[++rE]=function(){B_(t,void 0,i);},T_(rE),rE},Z_=function(e){delete sE[e];},X_?T_=function(e){$_.nextTick(cE(e));}:eE&&eE.now?T_=function(e){eE.now(cE(e));}:iE&&!z_?(R_=(S_=new iE).port2,S_.port1.onmessage=dE,T_=j_(R_.postMessage,R_)):F_.addEventListener&&G_(F_.postMessage)&&!F_.importScripts&&g_&&"file:"!==g_.protocol&&!H_(lE)?(T_=lE,F_.addEventListener("message",dE,!1)):T_=oE in q_("script")?function(e){K_.appendChild(q_("script"))[oE]=function(){K_.removeChild(this),aE(e);};}:function(e){setTimeout(cE(e),0);});var hE={set:Q_,clear:Z_},uE=function(){this.head=null,this.tail=null;};uE.prototype={add:function(e){var t={item:e,next:null},i=this.tail;i?i.next=t:this.head=t,this.tail=t;},get:function(){var e=this.head;if(e)return null===(this.head=e.next)&&(this.tail=null),e.item}};var pE,_E,EE,mE,fE,gE=uE,TE=/ipad|iphone|ipod/i.test(pt)&&"undefined"!=typeof Pebble,SE=/web0s(?!.*chrome)/i.test(pt),RE=fe,CE=tn,vE=ke.f,IE=hE.set,yE=gE,AE=V_,bE=TE,wE=SE,OE=C_,NE=RE.MutationObserver||RE.WebKitMutationObserver,DE=RE.document,PE=RE.process,LE=RE.Promise,kE=vE(RE,"queueMicrotask"),ME=kE&&kE.value;if(!ME){var UE=new yE,xE=function(){var e,t;for(OE&&(e=PE.domain)&&e.exit();t=UE.get();)try{t();}catch(e){throw UE.head&&pE(),e}e&&e.enter();};AE||OE||wE||!NE||!DE?!bE&&LE&&LE.resolve?((mE=LE.resolve(void 0)).constructor=LE,fE=CE(mE.then,mE),pE=function(){fE(xE);}):OE?pE=function(){PE.nextTick(xE);}:(IE=CE(IE,RE),pE=function(){IE(xE);}):(_E=!0,EE=DE.createTextNode(""),new NE(xE).observe(EE,{characterData:!0}),pE=function(){EE.data=_E=!_E;}),ME=function(e){UE.head||pE(),UE.add(e);};}var VE=ME,FE=function(e){try{return {error:!1,value:e()}}catch(e){return {error:!0,value:e}}},BE=fe.Promise,jE="object"==typeof Deno&&Deno&&"object"==typeof Deno.version,GE=!jE&&!C_&&"object"==typeof window&&"object"==typeof document,WE=fe,HE=BE,KE=Le,YE=Qi,qE=Xr,JE=fi,zE=GE,XE=jE,QE=St,ZE=HE&&HE.prototype,$E=JE("species"),em=!1,tm=KE(WE.PromiseRejectionEvent),im=YE("Promise",(function(){var e=qE(HE),t=e!==String(HE);if(!t&&66===QE)return !0;if(!ZE.catch||!ZE.finally)return !0;if(!QE||QE<51||!/native code/.test(e)){var i=new HE((function(e){e(1);})),n=function(e){e((function(){}),(function(){}));};if((i.constructor={})[$E]=n,!(em=i.then((function(){}))instanceof n))return !0}return !t&&(zE||XE)&&!tm})),nm={CONSTRUCTOR:im,REJECTION_EVENT:tm,SUBCLASSING:em},rm={},sm=Ut,om=TypeError,am=function(e){var t,i;this.promise=new e((function(e,n){if(void 0!==t||void 0!==i)throw om("Bad Promise constructor");t=e,i=n;})),this.resolve=sm(t),this.reject=sm(i);};rm.f=function(e){return new am(e)};var cm,dm,lm=kn,hm=C_,um=fe,pm=Ve,_m=Uo,Em=ca,mm=function(e){var t=v_(e);y_&&t&&!t[A_]&&I_(t,A_,{configurable:!0,get:function(){return this}});},fm=Ut,gm=Le,Tm=ot,Sm=function(e,t){if(b_(t,e))return e;throw w_("Incorrect invocation")},Rm=U_,Cm=hE.set,vm=VE,Im=function(e,t){try{1==arguments.length?console.error(e):console.error(e,t);}catch(e){}},ym=FE,Am=gE,bm=Ia,wm=BE,Om=nm,Nm=rm,Dm="Promise",Pm=Om.CONSTRUCTOR,Lm=Om.REJECTION_EVENT,km=bm.getterFor(Dm),Mm=bm.set,Um=wm&&wm.prototype,xm=wm,Vm=Um,Fm=um.TypeError,Bm=um.document,jm=um.process,Gm=Nm.f,Wm=Gm,Hm=!!(Bm&&Bm.createEvent&&um.dispatchEvent),Km="unhandledrejection",Ym=function(e){var t;return !(!Tm(e)||!gm(t=e.then))&&t},qm=function(e,t){var i,n,r,s=t.value,o=1==t.state,a=o?e.ok:e.fail,c=e.resolve,d=e.reject,l=e.domain;try{a?(o||(2===t.rejection&&Zm(t),t.rejection=1),!0===a?i=s:(l&&l.enter(),i=a(s),l&&(l.exit(),r=!0)),i===e.promise?d(Fm("Promise-chain cycle")):(n=Ym(i))?pm(n,i,c,d):c(i)):d(s);}catch(e){l&&!r&&l.exit(),d(e);}},Jm=function(e,t){e.notified||(e.notified=!0,vm((function(){for(var i,n=e.reactions;i=n.get();)qm(i,e);e.notified=!1,t&&!e.rejection&&Xm(e);})));},zm=function(e,t,i){var n,r;Hm?((n=Bm.createEvent("Event")).promise=t,n.reason=i,n.initEvent(e,!1,!0),um.dispatchEvent(n)):n={promise:t,reason:i},!Lm&&(r=um["on"+e])?r(n):e===Km&&Im("Unhandled promise rejection",i);},Xm=function(e){pm(Cm,um,(function(){var t,i=e.facade,n=e.value;if(Qm(e)&&(t=ym((function(){hm?jm.emit("unhandledRejection",n,i):zm(Km,i,n);})),e.rejection=hm||Qm(e)?2:1,t.error))throw t.value}));},Qm=function(e){return 1!==e.rejection&&!e.parent},Zm=function(e){pm(Cm,um,(function(){var t=e.facade;hm?jm.emit("rejectionHandled",t):zm("rejectionhandled",t,e.value);}));},$m=function(e,t,i){return function(n){e(t,n,i);}},ef=function(e,t,i){e.done||(e.done=!0,i&&(e=i),e.value=t,e.state=2,Jm(e,!0));},tf=function(e,t,i){if(!e.done){e.done=!0,i&&(e=i);try{if(e.facade===t)throw Fm("Promise can't be resolved itself");var n=Ym(t);n?vm((function(){var i={done:!1};try{pm(n,t,$m(tf,i,e),$m(ef,i,e));}catch(t){ef(i,t,e);}})):(e.value=t,e.state=1,Jm(e,!1));}catch(t){ef({done:!1},t,e);}}};Pm&&(Vm=(xm=function(e){Sm(this,Vm),fm(e),pm(cm,this);var t=km(this);try{e($m(tf,t),$m(ef,t));}catch(e){ef(t,e);}}).prototype,(cm=function(e){Mm(this,{type:Dm,done:!1,notified:!1,parent:!1,reactions:new Am,rejection:!1,state:0,value:void 0});}).prototype=_m(Vm,"then",(function(e,t){var i=km(this),n=Gm(Rm(this,xm));return i.parent=!0,n.ok=!gm(e)||e,n.fail=gm(t)&&t,n.domain=hm?jm.domain:void 0,0==i.state?i.reactions.add(n):vm((function(){qm(n,i);})),n.promise})),dm=function(){var e=new cm,t=km(e);this.promise=e,this.resolve=$m(tf,t),this.reject=$m(ef,t);},Nm.f=Gm=function(e){return e===xm||undefined===e?new dm(e):Wm(e)}),lm({global:!0,constructor:!0,wrap:!0,forced:Pm},{Promise:xm}),Em(xm,Dm,!1,!0),mm(Dm);var nf=fi("iterator"),rf=!1;try{var sf=0,of={next:function(){return {done:!!sf++}},return:function(){rf=!0;}};of[nf]=function(){return this},Array.from(of,(function(){throw 2}));}catch(e){}var af=BE,cf=function(e,t){if(!t&&!rf)return !1;var i=!1;try{var n={};n[nf]=function(){return {next:function(){return {done:i=!0}}}},e(n);}catch(e){}return i},df=nm.CONSTRUCTOR||!cf((function(e){af.all(e).then(void 0,(function(){}));})),lf=Ve,hf=Ut,uf=rm,pf=FE,_f=$p;kn({target:"Promise",stat:!0,forced:df},{all:function(e){var t=this,i=uf.f(t),n=i.resolve,r=i.reject,s=pf((function(){var i=hf(t.resolve),s=[],o=0,a=1;_f(e,(function(e){var c=o++,d=!1;a++,lf(i,t,e).then((function(e){d||(d=!0,s[c]=e,--a||n(s));}),r);})),--a||n(s);}));return s.error&&r(s.value),i.promise}});var Ef=kn,mf=nm.CONSTRUCTOR;BE&&BE.prototype,Ef({target:"Promise",proto:!0,forced:mf,real:!0},{catch:function(e){return this.then(void 0,e)}});var ff=Ve,gf=Ut,Tf=rm,Sf=FE,Rf=$p;kn({target:"Promise",stat:!0,forced:df},{race:function(e){var t=this,i=Tf.f(t),n=i.reject,r=Sf((function(){var r=gf(t.resolve);Rf(e,(function(e){ff(r,t,e).then(i.resolve,n);}));}));return r.error&&n(r.value),i.promise}});var Cf=Ve,vf=rm;kn({target:"Promise",stat:!0,forced:nm.CONSTRUCTOR},{reject:function(e){var t=vf.f(this);return Cf(t.reject,void 0,e),t.promise}});var If=cn,yf=ot,Af=rm,bf=function(e,t){if(If(e),yf(t)&&t.constructor===e)return t;var i=Af.f(e);return (0, i.resolve)(t),i.promise},wf=kn,Of=BE,Nf=nm.CONSTRUCTOR,Df=bf,Pf=ut("Promise"),Lf=!Nf;wf({target:"Promise",stat:!0,forced:true},{resolve:function(e){return Df(Lf&&this===Pf?Of:this,e)}});var kf=Ve,Mf=Ut,Uf=rm,xf=FE,Vf=$p;kn({target:"Promise",stat:!0,forced:df},{allSettled:function(e){var t=this,i=Uf.f(t),n=i.resolve,r=i.reject,s=xf((function(){var i=Mf(t.resolve),r=[],s=0,o=1;Vf(e,(function(e){var a=s++,c=!1;o++,kf(i,t,e).then((function(e){c||(c=!0,r[a]={status:"fulfilled",value:e},--o||n(r));}),(function(e){c||(c=!0,r[a]={status:"rejected",reason:e},--o||n(r));}));})),--o||n(r);}));return s.error&&r(s.value),i.promise}});var Ff=Ve,Bf=Ut,jf=ut,Gf=rm,Wf=FE,Hf=$p,Kf="No one promise resolved";kn({target:"Promise",stat:!0,forced:df},{any:function(e){var t=this,i=jf("AggregateError"),n=Gf.f(t),r=n.resolve,s=n.reject,o=Wf((function(){var n=Bf(t.resolve),o=[],a=0,c=1,d=!1;Hf(e,(function(e){var l=a++,h=!1;c++,Ff(n,t,e).then((function(e){h||d||(d=!0,r(e));}),(function(e){h||d||(h=!0,o[l]=e,--c||s(new i(o,Kf)));}));})),--c||s(new i(o,Kf));}));return o.error&&s(o.value),n.promise}});var Yf=kn,qf=BE,Jf=ce,zf=ut,Xf=Le,Qf=U_,Zf=bf,$f=qf&&qf.prototype;Yf({target:"Promise",proto:!0,real:!0,forced:!!qf&&Jf((function(){$f.finally.call({then:function(){}},(function(){}));}))},{finally:function(e){var t=Qf(this,zf("Promise")),i=Xf(e);return this.then(i?function(i){return Zf(t,e()).then((function(){return i}))}:e,i?function(i){return Zf(t,e()).then((function(){throw i}))}:e)}});var eg=at.Promise,tg=J(eg);const ig=()=>{};function ng(){const e={promise:void 0,isResolved:!1,isRejected:!1,isFinished:!1,resolve:void 0,reject:void 0,cancel:ig};return e.promise=new tg(((t,i)=>{e.resolve=i=>{e.isFinished||(e.isResolved=!0,e.isFinished=!0,t(i),e.value=i);},e.reject=t=>{e.isFinished||(e.isRejected=!0,e.isFinished=!0,i(t));};})),e}const rg=new Map,sg=new Map,og=new Map;var ag,cg;!function(e){e.WIN_10="Windows 10",e.WIN_81="Windows 8.1",e.WIN_8="Windows 8",e.WIN_7="Windows 7",e.WIN_VISTA="Windows Vista",e.WIN_SERVER_2003="Windows Server 2003",e.WIN_XP="Windows XP",e.WIN_2000="Windows 2000",e.ANDROID="Android",e.HARMONY_OS="HarmonyOS",e.OPEN_BSD="Open BSD",e.SUN_OS="Sun OS",e.LINUX="Linux",e.IOS="iOS",e.MAC_OS="Mac OS",e.QNX="QNX",e.UNIX="UNIX",e.BEOS="BeOS",e.OS_2="OS/2",e.SEARCH_BOT="Search Bot";}(ag||(ag={})),function(e){e.CHROME="Chrome",e.SAFARI="Safari",e.EDGE="Edge",e.FIREFOX="Firefox",e.OPERA="OPR",e.QQ="QQBrowser",e.WECHAT="MicroMessenger";}(cg||(cg={}));var dg={exports:{}};!function(e,t){!function(i,n){var r="function",s="undefined",o="object",a="string",c="major",d="model",l="name",h="type",u="vendor",p="version",_="architecture",E="console",m="mobile",f="tablet",g="smarttv",T="wearable",S="embedded",R="Amazon",C="Apple",v="ASUS",I="BlackBerry",y="Browser",A="Chrome",b="Firefox",w="Google",O="Huawei",N="LG",D="Microsoft",P="Motorola",L="Opera",k="Samsung",M="Sharp",U="Sony",x="Xiaomi",V="Zebra",F="Facebook",B="Chromium OS",j="Mac OS",G=function(e){for(var t={},i=0;i<e.length;i++)t[e[i].toUpperCase()]=e[i];return t},W=function(e,t){return typeof e===a&&-1!==H(t).indexOf(H(e))},H=function(e){return e.toLowerCase()},K=function(e,t){if(typeof e===a)return e=e.replace(/^\s\s*/,""),typeof t===s?e:e.substring(0,350)},Y=function(e,t){for(var i,s,a,c,d,l,h=0;h<t.length&&!d;){var u=t[h],p=t[h+1];for(i=s=0;i<u.length&&!d&&u[i];)if(d=u[i++].exec(e))for(a=0;a<p.length;a++)l=d[++s],typeof(c=p[a])===o&&c.length>0?2===c.length?typeof c[1]==r?this[c[0]]=c[1].call(this,l):this[c[0]]=c[1]:3===c.length?typeof c[1]!==r||c[1].exec&&c[1].test?this[c[0]]=l?l.replace(c[1],c[2]):n:this[c[0]]=l?c[1].call(this,l,c[2]):n:4===c.length&&(this[c[0]]=l?c[3].call(this,l.replace(c[1],c[2])):n):this[c]=l||n;h+=2;}},q=function(e,t){for(var i in t)if(typeof t[i]===o&&t[i].length>0){for(var r=0;r<t[i].length;r++)if(W(t[i][r],e))return "?"===i?n:i}else if(W(t[i],e))return "?"===i?n:i;return e},J={ME:"4.90","NT 3.11":"NT3.51","NT 4.0":"NT4.0",2e3:"NT 5.0",XP:["NT 5.1","NT 5.2"],Vista:"NT 6.0",7:"NT 6.1",8:"NT 6.2",8.1:"NT 6.3",10:["NT 6.4","NT 10.0"],RT:"ARM"},z={browser:[[/\b(?:crmo|crios)\/([\w\.]+)/i],[p,[l,"Chrome"]],[/edg(?:e|ios|a)?\/([\w\.]+)/i],[p,[l,"Edge"]],[/(opera mini)\/([-\w\.]+)/i,/(opera [mobiletab]{3,6})\b.+version\/([-\w\.]+)/i,/(opera)(?:.+version\/|[\/ ]+)([\w\.]+)/i],[l,p],[/opios[\/ ]+([\w\.]+)/i],[p,[l,L+" Mini"]],[/\bopr\/([\w\.]+)/i],[p,[l,L]],[/(kindle)\/([\w\.]+)/i,/(lunascape|maxthon|netfront|jasmine|blazer)[\/ ]?([\w\.]*)/i,/(avant |iemobile|slim)(?:browser)?[\/ ]?([\w\.]*)/i,/(ba?idubrowser)[\/ ]?([\w\.]+)/i,/(?:ms|\()(ie) ([\w\.]+)/i,/(flock|rockmelt|midori|epiphany|silk|skyfire|ovibrowser|bolt|iron|vivaldi|iridium|phantomjs|bowser|quark|qupzilla|falkon|rekonq|puffin|brave|whale(?!.+naver)|qqbrowserlite|qq|duckduckgo)\/([-\w\.]+)/i,/(weibo)__([\d\.]+)/i],[l,p],[/(?:\buc? ?browser|(?:juc.+)ucweb)[\/ ]?([\w\.]+)/i],[p,[l,"UC"+y]],[/microm.+\bqbcore\/([\w\.]+)/i,/\bqbcore\/([\w\.]+).+microm/i],[p,[l,"WeChat(Win) Desktop"]],[/micromessenger\/([\w\.]+)/i],[p,[l,"WeChat"]],[/konqueror\/([\w\.]+)/i],[p,[l,"Konqueror"]],[/trident.+rv[: ]([\w\.]{1,9})\b.+like gecko/i],[p,[l,"IE"]],[/yabrowser\/([\w\.]+)/i],[p,[l,"Yandex"]],[/(avast|avg)\/([\w\.]+)/i],[[l,/(.+)/,"$1 Secure "+y],p],[/\bfocus\/([\w\.]+)/i],[p,[l,b+" Focus"]],[/\bopt\/([\w\.]+)/i],[p,[l,L+" Touch"]],[/coc_coc\w+\/([\w\.]+)/i],[p,[l,"Coc Coc"]],[/dolfin\/([\w\.]+)/i],[p,[l,"Dolphin"]],[/coast\/([\w\.]+)/i],[p,[l,L+" Coast"]],[/miuibrowser\/([\w\.]+)/i],[p,[l,"MIUI "+y]],[/fxios\/([-\w\.]+)/i],[p,[l,b]],[/\bqihu|(qi?ho?o?|360)browser/i],[[l,"360 "+y]],[/(oculus|samsung|sailfish|huawei)browser\/([\w\.]+)/i],[[l,/(.+)/,"$1 "+y],p],[/(comodo_dragon)\/([\w\.]+)/i],[[l,/_/g," "],p],[/(electron)\/([\w\.]+) safari/i,/(tesla)(?: qtcarbrowser|\/(20\d\d\.[-\w\.]+))/i,/m?(qqbrowser|baiduboxapp|2345Explorer)[\/ ]?([\w\.]+)/i],[l,p],[/(metasr)[\/ ]?([\w\.]+)/i,/(lbbrowser)/i,/\[(linkedin)app\]/i],[l],[/((?:fban\/fbios|fb_iab\/fb4a)(?!.+fbav)|;fbav\/([\w\.]+);)/i],[[l,F],p],[/(kakao(?:talk|story))[\/ ]([\w\.]+)/i,/(naver)\(.*?(\d+\.[\w\.]+).*\)/i,/safari (line)\/([\w\.]+)/i,/\b(line)\/([\w\.]+)\/iab/i,/(chromium|instagram)[\/ ]([-\w\.]+)/i],[l,p],[/\bgsa\/([\w\.]+) .*safari\//i],[p,[l,"GSA"]],[/headlesschrome(?:\/([\w\.]+)| )/i],[p,[l,A+" Headless"]],[/ wv\).+(chrome)\/([\w\.]+)/i],[[l,A+" WebView"],p],[/droid.+ version\/([\w\.]+)\b.+(?:mobile safari|safari)/i],[p,[l,"Android "+y]],[/(chrome|omniweb|arora|[tizenoka]{5} ?browser)\/v?([\w\.]+)/i],[l,p],[/version\/([\w\.\,]+) .*mobile\/\w+ (safari)/i],[p,[l,"Mobile Safari"]],[/version\/([\w(\.|\,)]+) .*(mobile ?safari|safari)/i],[p,l],[/webkit.+?(mobile ?safari|safari)(\/[\w\.]+)/i],[l,[p,q,{"1.0":"/8",1.2:"/1",1.3:"/3","2.0":"/412","2.0.2":"/416","2.0.3":"/417","2.0.4":"/419","?":"/"}]],[/(webkit|khtml)\/([\w\.]+)/i],[l,p],[/(navigator|netscape\d?)\/([-\w\.]+)/i],[[l,"Netscape"],p],[/mobile vr; rv:([\w\.]+)\).+firefox/i],[p,[l,b+" Reality"]],[/ekiohf.+(flow)\/([\w\.]+)/i,/(swiftfox)/i,/(icedragon|iceweasel|camino|chimera|fennec|maemo browser|minimo|conkeror|klar)[\/ ]?([\w\.\+]+)/i,/(seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\/([-\w\.]+)$/i,/(firefox)\/([\w\.]+)/i,/(mozilla)\/([\w\.]+) .+rv\:.+gecko\/\d+/i,/(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|sleipnir|obigo|mosaic|(?:go|ice|up)[\. ]?browser)[-\/ ]?v?([\w\.]+)/i,/(links) \(([\w\.]+)/i,/panasonic;(viera)/i],[l,p],[/(cobalt)\/([\w\.]+)/i],[l,[p,/master.|lts./,""]]],cpu:[[/(?:(amd|x(?:(?:86|64)[-_])?|wow|win)64)[;\)]/i],[[_,"amd64"]],[/(ia32(?=;))/i],[[_,H]],[/((?:i[346]|x)86)[;\)]/i],[[_,"ia32"]],[/\b(aarch64|arm(v?8e?l?|_?64))\b/i],[[_,"arm64"]],[/\b(arm(?:v[67])?ht?n?[fl]p?)\b/i],[[_,"armhf"]],[/windows (ce|mobile); ppc;/i],[[_,"arm"]],[/((?:ppc|powerpc)(?:64)?)(?: mac|;|\))/i],[[_,/ower/,"",H]],[/(sun4\w)[;\)]/i],[[_,"sparc"]],[/((?:avr32|ia64(?=;))|68k(?=\))|\barm(?=v(?:[1-7]|[5-7]1)l?|;|eabi)|(?=atmel )avr|(?:irix|mips|sparc)(?:64)?\b|pa-risc)/i],[[_,H]]],device:[[/\b(sch-i[89]0\d|shw-m380s|sm-[ptx]\w{2,4}|gt-[pn]\d{2,4}|sgh-t8[56]9|nexus 10)/i],[d,[u,k],[h,f]],[/\b((?:s[cgp]h|gt|sm)-\w+|sc[g-]?[\d]+a?|galaxy nexus)/i,/samsung[- ]([-\w]+)/i,/sec-(sgh\w+)/i],[d,[u,k],[h,m]],[/\((ip(?:hone|od)[\w ]*);/i],[d,[u,C],[h,m]],[/\((ipad);[-\w\),; ]+apple/i,/applecoremedia\/[\w\.]+ \((ipad)/i,/\b(ipad)\d\d?,\d\d?[;\]].+ios/i],[d,[u,C],[h,f]],[/(macintosh);/i],[d,[u,C]],[/\b(sh-?[altvz]?\d\d[a-ekm]?)/i],[d,[u,M],[h,m]],[/\b((?:ag[rs][23]?|bah2?|sht?|btv)-a?[lw]\d{2})\b(?!.+d\/s)/i],[d,[u,O],[h,f]],[/(?:huawei|honor)([-\w ]+)[;\)]/i,/\b(nexus 6p|\w{2,4}e?-[atu]?[ln][\dx][012359c][adn]?)\b(?!.+d\/s)/i],[d,[u,O],[h,m]],[/\b(poco[\w ]+)(?: bui|\))/i,/\b; (\w+) build\/hm\1/i,/\b(hm[-_ ]?note?[_ ]?(?:\d\w)?) bui/i,/\b(redmi[\-_ ]?(?:note|k)?[\w_ ]+)(?: bui|\))/i,/\b(mi[-_ ]?(?:a\d|one|one[_ ]plus|note lte|max|cc)?[_ ]?(?:\d?\w?)[_ ]?(?:plus|se|lite)?)(?: bui|\))/i],[[d,/_/g," "],[u,x],[h,m]],[/\b(mi[-_ ]?(?:pad)(?:[\w_ ]+))(?: bui|\))/i],[[d,/_/g," "],[u,x],[h,f]],[/; (\w+) bui.+ oppo/i,/\b(cph[12]\d{3}|p(?:af|c[al]|d\w|e[ar])[mt]\d0|x9007|a101op)\b/i],[d,[u,"OPPO"],[h,m]],[/vivo (\w+)(?: bui|\))/i,/\b(v[12]\d{3}\w?[at])(?: bui|;)/i],[d,[u,"Vivo"],[h,m]],[/\b(rmx[12]\d{3})(?: bui|;|\))/i],[d,[u,"Realme"],[h,m]],[/\b(milestone|droid(?:[2-4x]| (?:bionic|x2|pro|razr))?:?( 4g)?)\b[\w ]+build\//i,/\bmot(?:orola)?[- ](\w*)/i,/((?:moto[\w\(\) ]+|xt\d{3,4}|nexus 6)(?= bui|\)))/i],[d,[u,P],[h,m]],[/\b(mz60\d|xoom[2 ]{0,2}) build\//i],[d,[u,P],[h,f]],[/((?=lg)?[vl]k\-?\d{3}) bui| 3\.[-\w; ]{10}lg?-([06cv9]{3,4})/i],[d,[u,N],[h,f]],[/(lm(?:-?f100[nv]?|-[\w\.]+)(?= bui|\))|nexus [45])/i,/\blg[-e;\/ ]+((?!browser|netcast|android tv)\w+)/i,/\blg-?([\d\w]+) bui/i],[d,[u,N],[h,m]],[/(ideatab[-\w ]+)/i,/lenovo ?(s[56]000[-\w]+|tab(?:[\w ]+)|yt[-\d\w]{6}|tb[-\d\w]{6})/i],[d,[u,"Lenovo"],[h,f]],[/(?:maemo|nokia).*(n900|lumia \d+)/i,/nokia[-_ ]?([-\w\.]*)/i],[[d,/_/g," "],[u,"Nokia"],[h,m]],[/(pixel c)\b/i],[d,[u,w],[h,f]],[/droid.+; (pixel[\daxl ]{0,6})(?: bui|\))/i],[d,[u,w],[h,m]],[/droid.+ (a?\d[0-2]{2}so|[c-g]\d{4}|so[-gl]\w+|xq-a\w[4-7][12])(?= bui|\).+chrome\/(?![1-6]{0,1}\d\.))/i],[d,[u,U],[h,m]],[/sony tablet [ps]/i,/\b(?:sony)?sgp\w+(?: bui|\))/i],[[d,"Xperia Tablet"],[u,U],[h,f]],[/ (kb2005|in20[12]5|be20[12][59])\b/i,/(?:one)?(?:plus)? (a\d0\d\d)(?: b|\))/i],[d,[u,"OnePlus"],[h,m]],[/(alexa)webm/i,/(kf[a-z]{2}wi)( bui|\))/i,/(kf[a-z]+)( bui|\)).+silk\//i],[d,[u,R],[h,f]],[/((?:sd|kf)[0349hijorstuw]+)( bui|\)).+silk\//i],[[d,/(.+)/g,"Fire Phone $1"],[u,R],[h,m]],[/(playbook);[-\w\),; ]+(rim)/i],[d,u,[h,f]],[/\b((?:bb[a-f]|st[hv])100-\d)/i,/\(bb10; (\w+)/i],[d,[u,I],[h,m]],[/(?:\b|asus_)(transfo[prime ]{4,10} \w+|eeepc|slider \w+|nexus 7|padfone|p00[cj])/i],[d,[u,v],[h,f]],[/ (z[bes]6[027][012][km][ls]|zenfone \d\w?)\b/i],[d,[u,v],[h,m]],[/(nexus 9)/i],[d,[u,"HTC"],[h,f]],[/(htc)[-;_ ]{1,2}([\w ]+(?=\)| bui)|\w+)/i,/(zte)[- ]([\w ]+?)(?: bui|\/|\))/i,/(alcatel|geeksphone|nexian|panasonic(?!(?:;|\.))|sony(?!-bra))[-_ ]?([-\w]*)/i],[u,[d,/_/g," "],[h,m]],[/droid.+; ([ab][1-7]-?[0178a]\d\d?)/i],[d,[u,"Acer"],[h,f]],[/droid.+; (m[1-5] note) bui/i,/\bmz-([-\w]{2,})/i],[d,[u,"Meizu"],[h,m]],[/(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus|dell|meizu|motorola|polytron)[-_ ]?([-\w]*)/i,/(hp) ([\w ]+\w)/i,/(asus)-?(\w+)/i,/(microsoft); (lumia[\w ]+)/i,/(lenovo)[-_ ]?([-\w]+)/i,/(jolla)/i,/(oppo) ?([\w ]+) bui/i],[u,d,[h,m]],[/(kobo)\s(ereader|touch)/i,/(archos) (gamepad2?)/i,/(hp).+(touchpad(?!.+tablet)|tablet)/i,/(kindle)\/([\w\.]+)/i,/(nook)[\w ]+build\/(\w+)/i,/(dell) (strea[kpr\d ]*[\dko])/i,/(le[- ]+pan)[- ]+(\w{1,9}) bui/i,/(trinity)[- ]*(t\d{3}) bui/i,/(gigaset)[- ]+(q\w{1,9}) bui/i,/(vodafone) ([\w ]+)(?:\)| bui)/i],[u,d,[h,f]],[/(surface duo)/i],[d,[u,D],[h,f]],[/droid [\d\.]+; (fp\du?)(?: b|\))/i],[d,[u,"Fairphone"],[h,m]],[/(u304aa)/i],[d,[u,"AT&T"],[h,m]],[/\bsie-(\w*)/i],[d,[u,"Siemens"],[h,m]],[/\b(rct\w+) b/i],[d,[u,"RCA"],[h,f]],[/\b(venue[\d ]{2,7}) b/i],[d,[u,"Dell"],[h,f]],[/\b(q(?:mv|ta)\w+) b/i],[d,[u,"Verizon"],[h,f]],[/\b(?:barnes[& ]+noble |bn[rt])([\w\+ ]*) b/i],[d,[u,"Barnes & Noble"],[h,f]],[/\b(tm\d{3}\w+) b/i],[d,[u,"NuVision"],[h,f]],[/\b(k88) b/i],[d,[u,"ZTE"],[h,f]],[/\b(nx\d{3}j) b/i],[d,[u,"ZTE"],[h,m]],[/\b(gen\d{3}) b.+49h/i],[d,[u,"Swiss"],[h,m]],[/\b(zur\d{3}) b/i],[d,[u,"Swiss"],[h,f]],[/\b((zeki)?tb.*\b) b/i],[d,[u,"Zeki"],[h,f]],[/\b([yr]\d{2}) b/i,/\b(dragon[- ]+touch |dt)(\w{5}) b/i],[[u,"Dragon Touch"],d,[h,f]],[/\b(ns-?\w{0,9}) b/i],[d,[u,"Insignia"],[h,f]],[/\b((nxa|next)-?\w{0,9}) b/i],[d,[u,"NextBook"],[h,f]],[/\b(xtreme\_)?(v(1[045]|2[015]|[3469]0|7[05])) b/i],[[u,"Voice"],d,[h,m]],[/\b(lvtel\-)?(v1[12]) b/i],[[u,"LvTel"],d,[h,m]],[/\b(ph-1) /i],[d,[u,"Essential"],[h,m]],[/\b(v(100md|700na|7011|917g).*\b) b/i],[d,[u,"Envizen"],[h,f]],[/\b(trio[-\w\. ]+) b/i],[d,[u,"MachSpeed"],[h,f]],[/\btu_(1491) b/i],[d,[u,"Rotor"],[h,f]],[/(shield[\w ]+) b/i],[d,[u,"Nvidia"],[h,f]],[/(sprint) (\w+)/i],[u,d,[h,m]],[/(kin\.[onetw]{3})/i],[[d,/\./g," "],[u,D],[h,m]],[/droid.+; (cc6666?|et5[16]|mc[239][23]x?|vc8[03]x?)\)/i],[d,[u,V],[h,f]],[/droid.+; (ec30|ps20|tc[2-8]\d[kx])\)/i],[d,[u,V],[h,m]],[/smart-tv.+(samsung)/i],[u,[h,g]],[/hbbtv.+maple;(\d+)/i],[[d,/^/,"SmartTV"],[u,k],[h,g]],[/(nux; netcast.+smarttv|lg (netcast\.tv-201\d|android tv))/i],[[u,N],[h,g]],[/(apple) ?tv/i],[u,[d,C+" TV"],[h,g]],[/crkey/i],[[d,A+"cast"],[u,w],[h,g]],[/droid.+aft(\w)( bui|\))/i],[d,[u,R],[h,g]],[/\(dtv[\);].+(aquos)/i,/(aquos-tv[\w ]+)\)/i],[d,[u,M],[h,g]],[/(bravia[\w ]+)( bui|\))/i],[d,[u,U],[h,g]],[/(mitv-\w{5}) bui/i],[d,[u,x],[h,g]],[/Hbbtv.*(technisat) (.*);/i],[u,d,[h,g]],[/\b(roku)[\dx]*[\)\/]((?:dvp-)?[\d\.]*)/i,/hbbtv\/\d+\.\d+\.\d+ +\([\w\+ ]*; *([\w\d][^;]*);([^;]*)/i],[[u,K],[d,K],[h,g]],[/\b(android tv|smart[- ]?tv|opera tv|tv; rv:)\b/i],[[h,g]],[/(ouya)/i,/(nintendo) ([wids3utch]+)/i],[u,d,[h,E]],[/droid.+; (shield) bui/i],[d,[u,"Nvidia"],[h,E]],[/(playstation [345portablevi]+)/i],[d,[u,U],[h,E]],[/\b(xbox(?: one)?(?!; xbox))[\); ]/i],[d,[u,D],[h,E]],[/((pebble))app/i],[u,d,[h,T]],[/(watch)(?: ?os[,\/]|\d,\d\/)[\d\.]+/i],[d,[u,C],[h,T]],[/droid.+; (glass) \d/i],[d,[u,w],[h,T]],[/droid.+; (wt63?0{2,3})\)/i],[d,[u,V],[h,T]],[/(quest( 2| pro)?)/i],[d,[u,F],[h,T]],[/(tesla)(?: qtcarbrowser|\/[-\w\.]+)/i],[u,[h,S]],[/droid .+?; ([^;]+?)(?: bui|\) applew).+? mobile safari/i],[d,[h,m]],[/droid .+?; ([^;]+?)(?: bui|\) applew).+?(?! mobile) safari/i],[d,[h,f]],[/\b((tablet|tab)[;\/]|focus\/\d(?!.+mobile))/i],[[h,f]],[/(phone|mobile(?:[;\/]| [ \w\/\.]*safari)|pda(?=.+windows ce))/i],[[h,m]],[/(android[-\w\. ]{0,9});.+buil/i],[d,[u,"Generic"]]],engine:[[/windows.+ edge\/([\w\.]+)/i],[p,[l,"EdgeHTML"]],[/webkit\/537\.36.+chrome\/(?!27)([\w\.]+)/i],[p,[l,"Blink"]],[/(presto)\/([\w\.]+)/i,/(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna)\/([\w\.]+)/i,/ekioh(flow)\/([\w\.]+)/i,/(khtml|tasman|links)[\/ ]\(?([\w\.]+)/i,/(icab)[\/ ]([23]\.[\d\.]+)/i],[l,p],[/rv\:([\w\.]{1,9})\b.+(gecko)/i],[p,l]],os:[[/microsoft (windows) (vista|xp)/i],[l,p],[/(windows) nt 6\.2; (arm)/i,/(windows (?:phone(?: os)?|mobile))[\/ ]?([\d\.\w ]*)/i,/(windows)[\/ ]?([ntce\d\. ]+\w)(?!.+xbox)/i],[l,[p,q,J]],[/(win(?=3|9|n)|win 9x )([nt\d\.]+)/i],[[l,"Windows"],[p,q,J]],[/ip[honead]{2,4}\b(?:.*os ([\w]+) like mac|; opera)/i,/cfnetwork\/.+darwin/i],[[p,/_/g,"."],[l,"iOS"]],[/(mac os x) ?([\w\. ]*)/i,/(macintosh|mac_powerpc\b)(?!.+haiku)/i],[[l,j],[p,/_/g,"."]],[/droid ([\w\.]+)\b.+(android[- ]x86|harmonyos)/i],[p,l],[/(android|webos|qnx|bada|rim tablet os|maemo|meego|sailfish)[-\/ ]?([\w\.]*)/i,/(blackberry)\w*\/([\w\.]*)/i,/(tizen|kaios)[\/ ]([\w\.]+)/i,/\((series40);/i],[l,p],[/\(bb(10);/i],[p,[l,I]],[/(?:symbian ?os|symbos|s60(?=;)|series60)[-\/ ]?([\w\.]*)/i],[p,[l,"Symbian"]],[/mozilla\/[\d\.]+ \((?:mobile|tablet|tv|mobile; [\w ]+); rv:.+ gecko\/([\w\.]+)/i],[p,[l,b+" OS"]],[/web0s;.+rt(tv)/i,/\b(?:hp)?wos(?:browser)?\/([\w\.]+)/i],[p,[l,"webOS"]],[/watch(?: ?os[,\/]|\d,\d\/)([\d\.]+)/i],[p,[l,"watchOS"]],[/crkey\/([\d\.]+)/i],[p,[l,A+"cast"]],[/(cros) [\w]+(?:\)| ([\w\.]+)\b)/i],[[l,B],p],[/panasonic;(viera)/i,/(netrange)mmh/i,/(nettv)\/(\d+\.[\w\.]+)/i,/(nintendo|playstation) ([wids345portablevuch]+)/i,/(xbox); +xbox ([^\);]+)/i,/\b(joli|palm)\b ?(?:os)?\/?([\w\.]*)/i,/(mint)[\/\(\) ]?(\w*)/i,/(mageia|vectorlinux)[; ]/i,/([kxln]?ubuntu|debian|suse|opensuse|gentoo|arch(?= linux)|slackware|fedora|mandriva|centos|pclinuxos|red ?hat|zenwalk|linpus|raspbian|plan 9|minix|risc os|contiki|deepin|manjaro|elementary os|sabayon|linspire)(?: gnu\/linux)?(?: enterprise)?(?:[- ]linux)?(?:-gnu)?[-\/ ]?(?!chrom|package)([-\w\.]*)/i,/(hurd|linux) ?([\w\.]*)/i,/(gnu) ?([\w\.]*)/i,/\b([-frentopcghs]{0,5}bsd|dragonfly)[\/ ]?(?!amd|[ix346]{1,2}86)([\w\.]*)/i,/(haiku) (\w+)/i],[l,p],[/(sunos) ?([\w\.\d]*)/i],[[l,"Solaris"],p],[/((?:open)?solaris)[-\/ ]?([\w\.]*)/i,/(aix) ((\d)(?=\.|\)| )[\w\.])*/i,/\b(beos|os\/2|amigaos|morphos|openvms|fuchsia|hp-ux)/i,/(unix) ?([\w\.]*)/i],[l,p]]},X=function(e,t){if(typeof e===o&&(t=e,e=n),!(this instanceof X))return new X(e,t).getResult();var E=typeof i!==s&&i.navigator?i.navigator:n,g=e||(E&&E.userAgent?E.userAgent:""),T=E&&E.userAgentData?E.userAgentData:n,S=t?function(e,t){var i={};for(var n in e)t[n]&&t[n].length%2==0?i[n]=t[n].concat(e[n]):i[n]=e[n];return i}(z,t):z;return this.getBrowser=function(){var e={};return e[l]=n,e[p]=n,Y.call(e,g,S.browser),e[c]=function(e){return typeof e===a?e.replace(/[^\d\.]/g,"").split(".")[0]:n}(e[p]),E&&E.brave&&typeof E.brave.isBrave==r&&(e[l]="Brave"),e},this.getCPU=function(){var e={};return e[_]=n,Y.call(e,g,S.cpu),e},this.getDevice=function(){var e={};return e[u]=n,e[d]=n,e[h]=n,Y.call(e,g,S.device),!e[h]&&T&&T.mobile&&(e[h]=m),"Macintosh"==e[d]&&E&&typeof E.standalone!==s&&E.maxTouchPoints&&E.maxTouchPoints>2&&(e[d]="iPad",e[h]=f),e},this.getEngine=function(){var e={};return e[l]=n,e[p]=n,Y.call(e,g,S.engine),e},this.getOS=function(){var e={};return e[l]=n,e[p]=n,Y.call(e,g,S.os),!e[l]&&T&&"Unknown"!=T.platform&&(e[l]=T.platform.replace(/chrome os/i,B).replace(/macos/i,j)),e},this.getResult=function(){return {ua:this.getUA(),browser:this.getBrowser(),engine:this.getEngine(),os:this.getOS(),device:this.getDevice(),cpu:this.getCPU()}},this.getUA=function(){return g},this.setUA=function(e){return g=typeof e===a&&e.length>350?K(e,350):e,this},this.setUA(g),this};X.VERSION="0.7.34",X.BROWSER=G([l,p,c]),X.CPU=G([_]),X.DEVICE=G([d,u,h,E,m,g,f,T,S]),X.ENGINE=X.OS=G([l,p]),e.exports&&(t=e.exports=X),t.UAParser=X;var Q=typeof i!==s&&(i.jQuery||i.Zepto);if(Q&&!Q.ua){var Z=new X;Q.ua=Z.getResult(),Q.ua.get=function(){return Z.getUA()},Q.ua.set=function(e){Z.setUA(e);var t=Z.getResult();for(var i in t)Q.ua[i]=t[i];};}}("object"==typeof window?window:q);}(dg,dg.exports);const lg=new(J(dg.exports));let hg=lg.getResult(),ug=null;function pg(e){if(!ug){e&&lg.setUA(e),hg=lg.getResult();const t=function(e){if("Blink"===e.engine.name&&"WeChat"!==e.browser.name)return cg.CHROME;switch(e.browser.name){case"Chrome Headless":case"Chrome":case"Chromium":return cg.CHROME;case"Safari":case"Mobile Safari":return cg.SAFARI;case"Edge":return cg.EDGE;case"Firefox":return cg.FIREFOX;case"QQBrowser":return cg.QQ;case"Opera":return cg.OPERA;case"WeChat":return cg.WECHAT;default:return e.browser.name||""}}(hg),i=function(e){let t;t="Blink"===e.engine.name?e.engine.version||"":e.browser.version||"";return t.split(".")[0]}(hg),n=function(e){if("Windows"===e.os.name)return e.os.version?e.os.name+" "+e.os.version:e.os.name;return e.os.name||""}(hg),r=hg.os.version;if(!(t&&i&&n&&r))return {name:t,version:i,os:n,osVersion:r};ug={name:t,version:i,os:n,osVersion:r};}return ug}function _g(){return pg().os}function Eg(){const e=pg();return "".concat(e.os," ").concat(e.osVersion)}function mg(){const e=pg();return !!("WebKit"===hg.engine.name&&e.os===ag.MAC_OS&&navigator.maxTouchPoints&&navigator.maxTouchPoints>0&&e.name!==cg.SAFARI||Cg()&&e.name!==cg.SAFARI)}function fg(){const e=pg();if(mg()){if(e.os===ag.MAC_OS)return !0;if(e.os===ag.IOS){const e=hg.os.version&&hg.os.version.split(".");if(e&&14===Number(e[0])&&e[1]&&Number(e[1])>=3)return !0;if(e&&Number(e[0])>14)return !0}}return !1}function gg(){return "WebKit"===hg.engine.name}function Tg(){return pg().name===cg.CHROME}function Sg(){return pg().name===cg.SAFARI}function Rg(){return pg().name===cg.FIREFOX}function Cg(){return pg().os===ag.IOS}function vg(e){const t=pg();return !(t.name!==cg.CHROME||!t.osVersion)&&Number(t.version)>=e}function Ig(e){const t=pg();return !(t.name!==cg.EDGE||!t.osVersion)&&Number(t.version)>=e}function yg(e){const t=pg();return !(t.name!==cg.OPERA||!t.osVersion)&&Number(t.version)>=e}function Ag(){const e=pg();return !(e.name!==cg.CHROME||!e.osVersion)&&Number(e.version)<=90}function bg(){const e=pg();if(e.os!==ag.IOS||!e.osVersion)return !1;const t=e.osVersion.split(".");return Number(t[0])<14||14===Number(t[0])&&Number(t[1])<=6}function wg(){const e=pg();if(e.os!==ag.IOS||!e.osVersion)return !1;const t=e.osVersion.split(".");return 15===Number(t[0])}function Og(){const e=pg();if(e.os!==ag.IOS||!e.osVersion)return !1;const t=e.osVersion.split(".");return 16===Number(t[0])}function Ng(){const e=pg();if(e.os!==ag.IOS||!e.osVersion)return !1;const t=e.osVersion.split(".");return 15===Number(t[0])&&Number(t[1])>=1}function Dg(){return Sg()&&navigator.maxTouchPoints>0}function Pg(){return pg().name===cg.WECHAT}function Lg(){return window.navigator.appVersion&&null!==window.navigator.appVersion.match(/Chrome\/([\w\W]*?)\./)&&window.navigator.appVersion.match(/Chrome\/([\w\W]*?)\./)[1]<=35}function kg(){const e=pg();if(e.name===cg.EDGE||e.name===cg.SAFARI)return !1;return !!navigator.userAgent.toLocaleLowerCase().match(/chrome\/[\d]./i)}function Mg(){return _g()===ag.ANDROID}function Ug(){const e=pg();return Mg()&&(e.name===cg.CHROME||e.name===cg.WECHAT||/chrome|chromium/i.test(navigator.userAgent))}var xg;!function(e){e.UNEXPECTED_ERROR="UNEXPECTED_ERROR",e.UNEXPECTED_RESPONSE="UNEXPECTED_RESPONSE",e.TIMEOUT="TIMEOUT",e.INVALID_PARAMS="INVALID_PARAMS",e.NOT_READABLE="NOT_READABLE",e.NOT_SUPPORTED="NOT_SUPPORTED",e.INVALID_OPERATION="INVALID_OPERATION",e.OPERATION_ABORTED="OPERATION_ABORTED",e.WEB_SECURITY_RESTRICT="WEB_SECURITY_RESTRICT",e.EXCHANGE_SDP_FAILED="EXCHANGE_SDP_FAILED",e.ADD_CANDIDATE_FAILED="ADD_CANDIDATE_FAILED",e.DATACHANNEL_FAILED="DATACHANNEL_FAILED",e.NETWORK_ERROR="NETWORK_ERROR",e.NETWORK_TIMEOUT="NETWORK_TIMEOUT",e.NETWORK_RESPONSE_ERROR="NETWORK_RESPONSE_ERROR",e.API_INVOKE_TIMEOUT="API_INVOKE_TIMEOUT",e.ENUMERATE_DEVICES_FAILED="ENUMERATE_DEVICES_FAILED",e.DEVICE_NOT_FOUND="DEVICE_NOT_FOUND",e.ELECTRON_IS_NULL="ELECTRON_IS_NULL",e.ELECTRON_DESKTOP_CAPTURER_GET_SOURCES_ERROR="ELECTRON_DESKTOP_CAPTURER_GET_SOURCES_ERROR",e.CHROME_PLUGIN_NO_RESPONSE="CHROME_PLUGIN_NO_RESPONSE",e.CHROME_PLUGIN_NOT_INSTALL="CHROME_PLUGIN_NOT_INSTALL",e.MEDIA_OPTION_INVALID="MEDIA_OPTION_INVALID",e.PERMISSION_DENIED="PERMISSION_DENIED",e.CONSTRAINT_NOT_SATISFIED="CONSTRAINT_NOT_SATISFIED",e.TRACK_IS_DISABLED="TRACK_IS_DISABLED",e.GET_VIDEO_ELEMENT_VISIBLE_ERROR="GET_VIDEO_ELEMENT_VISIBLE_ERROR",e.SHARE_AUDIO_NOT_ALLOWED="SHARE_AUDIO_NOT_ALLOWED",e.LOW_STREAM_ENCODING_ERROR="LOW_STREAM_ENCODING_ERROR",e.SET_ENCODING_PARAMETER_ERROR="SET_ENCODING_PARAMETER_ERROR",e.TRACK_STATE_UNREACHABLE="TRACK_STATE_UNREACHABLE",e.INVALID_UINT_UID_FROM_STRING_UID="INVALID_UINT_UID_FROM_STRING_UID",e.CAN_NOT_GET_PROXY_SERVER="CAN_NOT_GET_PROXY_SERVER",e.CAN_NOT_GET_GATEWAY_SERVER="CAN_NOT_GET_GATEWAY_SERVER",e.VOID_GATEWAY_ADDRESS="VOID_GATEWAY_ADDRESS",e.UID_CONFLICT="UID_CONFLICT",e.MULTI_UNILBS_RESPONSE_ERROR="MULTI_UNILBS_RESPONSE_ERROR",e.UPDATE_TICKET_FAILED="UPDATE_TICKET_FAILED",e.INVALID_LOCAL_TRACK="INVALID_LOCAL_TRACK",e.INVALID_TRACK="INVALID_TRACK",e.SENDER_NOT_FOUND="SENDER_NOT_FOUND",e.CREATE_OFFER_FAILED="CREATE_OFFER_FAILED",e.SET_ANSWER_FAILED="SET_ANSWER_FAILED",e.ICE_FAILED="ICE_FAILED",e.PC_CLOSED="PC_CLOSED",e.SENDER_REPLACE_FAILED="SENDER_REPLACE_FAILED",e.GET_LOCAL_CAPABILITIES_FAILED="GET_LOCAL_CAPABILITIES_FAILED",e.GET_LOCAL_CONNECTION_PARAMS_FAILED="GET_LOCAL_CONNECTION_PARAMS_FAILED",e.SUBSCRIBE_FAILED="SUBSCRIBE_FAILED",e.UNSUBSCRIBE_FAILED="UNSUBSCRIBE_FAILED",e.GATEWAY_P2P_LOST="GATEWAY_P2P_LOST",e.NO_ICE_CANDIDATE="NO_ICE_CANDIDATE",e.CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS="CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS",e.EXIST_DISABLED_VIDEO_TRACK="EXIST_DISABLED_VIDEO_TRACK",e.INVALID_REMOTE_USER="INVALID_REMOTE_USER",e.REMOTE_USER_IS_NOT_PUBLISHED="REMOTE_USER_IS_NOT_PUBLISHED",e.CUSTOM_REPORT_SEND_FAILED="CUSTOM_REPORT_SEND_FAILED",e.CUSTOM_REPORT_FREQUENCY_TOO_HIGH="CUSTOM_REPORT_FREQUENCY_TOO_HIGH",e.FETCH_AUDIO_FILE_FAILED="FETCH_AUDIO_FILE_FAILED",e.READ_LOCAL_AUDIO_FILE_ERROR="READ_LOCAL_AUDIO_FILE_ERROR",e.DECODE_AUDIO_FILE_FAILED="DECODE_AUDIO_FILE_FAILED",e.WS_ABORT="WS_ABORT",e.WS_DISCONNECT="WS_DISCONNECT",e.WS_ERR="WS_ERR",e.LIVE_STREAMING_TASK_CONFLICT="LIVE_STREAMING_TASK_CONFLICT",e.LIVE_STREAMING_INVALID_ARGUMENT="LIVE_STREAMING_INVALID_ARGUMENT",e.LIVE_STREAMING_INTERNAL_SERVER_ERROR="LIVE_STREAMING_INTERNAL_SERVER_ERROR",e.LIVE_STREAMING_PUBLISH_STREAM_NOT_AUTHORIZED="LIVE_STREAMING_PUBLISH_STREAM_NOT_AUTHORIZED",e.LIVE_STREAMING_TRANSCODING_NOT_SUPPORTED="LIVE_STREAMING_TRANSCODING_NOT_SUPPORTED",e.LIVE_STREAMING_CDN_ERROR="LIVE_STREAMING_CDN_ERROR",e.LIVE_STREAMING_INVALID_RAW_STREAM="LIVE_STREAMING_INVALID_RAW_STREAM",e.LIVE_STREAMING_WARN_STREAM_NUM_REACH_LIMIT="LIVE_STREAMING_WARN_STREAM_NUM_REACH_LIMIT",e.LIVE_STREAMING_WARN_FAILED_LOAD_IMAGE="LIVE_STREAMING_WARN_FAILED_LOAD_IMAGE",e.LIVE_STREAMING_WARN_FREQUENT_REQUEST="LIVE_STREAMING_WARN_FREQUENT_REQUEST",e.WEBGL_INTERNAL_ERROR="WEBGL_INTERNAL_ERROR",e.BEAUTY_PROCESSOR_INTERNAL_ERROR="BEAUTY_PROCESSOR_INTERNAL_ERROR",e.CROSS_CHANNEL_WAIT_STATUS_ERROR="CROSS_CHANNEL_WAIT_STATUS_ERROR",e.CROSS_CHANNEL_FAILED_JOIN_SRC="CROSS_CHANNEL_FAILED_JOIN_SEC",e.CROSS_CHANNEL_FAILED_JOIN_DEST="CROSS_CHANNEL_FAILED_JOIN_DEST",e.CROSS_CHANNEL_FAILED_PACKET_SENT_TO_DEST="CROSS_CHANNEL_FAILED_PACKET_SENT_TO_DEST",e.CROSS_CHANNEL_SERVER_ERROR_RESPONSE="CROSS_CHANNEL_SERVER_ERROR_RESPONSE",e.METADATA_OUT_OF_RANGE="METADATA_OUT_OF_RANGE",e.LOCAL_AEC_ERROR="LOCAL_AEC_ERROR",e.INVALID_PLUGIN="INVALID_PLUGIN",e.DISCONNECT_P2P="DISCONNECT_P2P",e.INIT_WEBSOCKET_TIMEOUT="INIT_WEBSOCKET_TIMEOUT",e.CONVERTING_IMAGEDATA_TO_BLOB_FAILED="CONVERTING_IMAGEDATA_TO_BLOB_FAILED",e.CONVERTING_VIDEO_FRAME_TO_BLOB_FAILED="CONVERTING_VIDEO_FRAME_TO_BLOB_FAILED",e.INIT_DATACHANNEL_TIMEOUT="INIT_DATACHANNEL_TIMEOUT",e.DATACHANNEL_CONNECTION_TIMEOUT="DATACHANNEL_CONNECTION_TIMEOUT",e.PROHIBITED_OPERATION="PROHIBITED_OPERATION",e.IMAGE_MODERATION_UPLOAD_FAILED="IMAGE_MODERATION_UPLOAD_FAILED";}(xg||(xg={}));let Vg=class extends Error{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"",i=arguments.length>2?arguments[2]:void 0;super(t),nu(this,"code",void 0),nu(this,"message",void 0),nu(this,"data",void 0),nu(this,"name","AgoraRTCException"),this.code=e,this.message="AgoraRTCError ".concat(this.code,": ").concat(t),this.data=i;}toString(){return this.data?"data: ".concat(JSON.stringify(this.data),"\n").concat(this.stack):"".concat(this.stack)}print(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"error",t=arguments.length>1?arguments[1]:void 0;return "error"===e&&(t||console).error(this.toString()),"warning"===e&&(t||console).warn(this.toString()),this}throw(e){throw this.print("error",e),this}};function Fg(e,t){if("boolean"!=typeof e)throw new Vg(xg.INVALID_PARAMS,"Invalid ".concat(t,": The value is of the boolean type."))}function Bg(e,t,i){if(Pr(i).call(i,e))return;throw new Vg(xg.INVALID_PARAMS,"".concat(t," can only be set as ").concat(JSON.stringify(i)))}function jg(e,t){let i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1e4;if(e<i||e>n||(!(arguments.length>4&&void 0!==arguments[4])||arguments[4])&&!function(e){return "number"==typeof e&&e%1==0}(e)){throw new Vg(xg.INVALID_PARAMS,"invalid ".concat(t,": the value range is [").concat(i,", ").concat(n,"]. integer only"))}}function Gg(e,t){if("number"!=typeof e){if(!(e.min||e.max||e.ideal||e.exact)){throw new Vg(xg.INVALID_PARAMS,"".concat(t," is not a valid ConstrainLong"))}void 0!==e.min&&jg(e.min,"".concat(t,".min"),0,1/0),void 0!==e.max&&jg(e.max,"".concat(t,".max"),1,1/0),void 0!==e.exact&&jg(e.exact,"".concat(t,".exact"),1,1/0),void 0!==e.ideal&&jg(e.ideal,"".concat(t,".ideal"),1,1/0);}else jg(e,t,1,1/0);}function Wg(e,t){let i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:255,r=!(arguments.length>4&&void 0!==arguments[4])||arguments[4];if(null==e)throw new Vg(xg.INVALID_PARAMS,"".concat(t||"param"," cannot be empty"));if(!Yg(e,i,n,r))throw new Vg(xg.INVALID_PARAMS,"Invalid ".concat(t||"string param",": Length of the string: [").concat(i,",").concat(n,"].").concat(r?" ASCII characters only.":""))}function Hg(e,t){if(!Array.isArray(e))throw new Vg(xg.INVALID_PARAMS,"".concat(t," should be an array"))}function Kg(e){return null==e}function Yg(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:255,n=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];return "string"==typeof e&&e.length<=i&&e.length>=t&&(!n||function(e){if("string"!=typeof e)return !1;for(let t=0;t<e.length;t+=1){const i=e.charCodeAt(t);if(i<0||i>255)return !1}return !0}(e))}function qg(e,t,i){if("getBigUint64"in DataView.prototype)return e.getBigUint64(t,i);const n=e.getUint32(t,i),r=e.getUint32(t+4,i),s=Number(!!i),o=Number(!i);return BigInt(n*o+r*s)<<BigInt(32)|BigInt(n*s+r*o)}function Jg(e,t,i,n){if("setBigUint64"in DataView.prototype)return e.setBigUint64(t,i,n);const r=Number(i>>BigInt(32)),s=Number(i&BigInt(4294967295));n?(e.setUint32(t+4,r,n),e.setUint32(t,s,n)):(e.setUint32(t,r,n),e.setUint32(t+4,s,n));}var zg,Xg;!function(e){e.COVERED="COVERED",e.POSITION="POSITION",e.SIZE="SIZE",e.STYLE="STYLE";}(zg||(zg={})),function(e){e.UNMOUNTED="UNMOUNTED",e.INVALID_HTML_ELEMENT="INVALID_HTML_ELEMENT";}(Xg||(Xg={}));const Qg=new class{constructor(){nu(this,"_clientSize",null),nu(this,"getClientWidth",(()=>document.documentElement?document.documentElement.clientWidth:document.body.clientWidth)),nu(this,"getClientHeight",(()=>document.documentElement?document.documentElement.clientHeight:document.body.clientHeight)),nu(this,"getStyle",(e=>window.getComputedStyle(e,null))),nu(this,"checkCssVisibleProperty",(e=>{var t;let i=!0;const n=this.getStyle(e),{display:r,visibility:s,opacity:o,filter:a}=n;if(("none"===r||Pr(t=["hidden","collapse"]).call(t,s)||Number(o)<.1)&&(i=!1),!i)return !1;if(a){a.split(" ").filter((e=>{var t;const i=e.split("(")[0];return Pr(t=["brightness","blur","opacity"]).call(t,i)})).map((e=>{const[t,i]=e.split(/\(|\)/);return [t,Number(i.match(/^[0-9\.]+/))]})).forEach((e=>{const[t,n]=e;switch(t){case"brightness":(n<.1||n>3)&&(i=!1);break;case"blur":n>3&&(i=!1);break;case"opacity":n<.1&&(i=!1);}}));}return i})),nu(this,"checkPropertyUpToAllParentNodes",((e,t)=>{let i=!0,n=!0;const r=e=>t(e);let s=e;for(;s&&n;){r(s)||(i=!1,n=!1),s=s.parentElement,s||(n=!1);}return i})),nu(this,"checkActualCssVisibleIncludeInherit",(e=>this.checkPropertyUpToAllParentNodes(e,this.checkCssVisibleProperty))),nu(this,"getSizeAboutClient",(e=>{const{width:t,height:i,left:n,right:r,top:s,bottom:o}=e.getBoundingClientRect(),a=this.getClientWidth(),c=this.getClientHeight();return {width:t,height:i,left:n,right:r,top:s,bottom:o,clientWidth:a,clientHeight:c,clientMin:Math.min(a,c)}})),nu(this,"checkActualSize",(()=>{const{width:e,height:t,clientMin:i}=this._clientSize;return this.checkSizeIsVisible(e,t,i)})),nu(this,"elementFromPoint",((e,t)=>document.elementFromPoint?document.elementFromPoint(e,t):null)),nu(this,"checkCoverForAPoint",((e,t,i)=>{const n=this.elementFromPoint(e,t);return null!==n&&n!==i})),nu(this,"getPointPositionList",(()=>{const{width:e,height:t,left:i,top:n}=this._clientSize,r=e/6,s=t/6,o=[],a=10**6;for(let e=0;e<5;e++)for(let t=0;t<5;t++){const c=(i*a+(0===e?.1:4===e?(r*e*a-1e5)/a:r*e)*a)/a,d=(n*a+(0===t?.1:4===t?(s*t*a-1e5)/a:s*t)*a)/a;o.push({x:c,y:d});}return [...o]})),nu(this,"checkElementCover",(e=>this.getPointPositionList().map((t=>this.checkCoverForAPoint(t.x,t.y,e))).filter((e=>!!e)).length>6)),nu(this,"checkSizeIsVisible",((e,t,i)=>(e>50||i/e<=10)&&(t>50||i/t<=10))),nu(this,"checkSizeOfPartInClient",(()=>{const{left:e,right:t,top:i,bottom:n,clientHeight:r,clientWidth:s,clientMin:o}=this._clientSize;let a,c,d,l;if(e<0)a=0;else {if(!(e<s))return !1;a=e;}if(t<0)return !1;if(c=t<s?t:s,i<0)d=0;else {if(!(i<r))return !1;d=i;}if(n<0)return !1;l=n<r?n:r;const h=c-a,u=l-d;return this.checkSizeIsVisible(h,u,o)})),nu(this,"returnHiddenResult",(e=>(this._clientSize=null,{visible:!1,reason:e}))),nu(this,"checkOneElementVisible",(e=>{if(e instanceof HTMLElement){if(this.checkElementIsMountedOnDom(e)){if(this.checkActualCssVisibleIncludeInherit(e)){if(this._clientSize=this.getSizeAboutClient(e),this.checkElementCover(e))return this.returnHiddenResult(zg.COVERED);{const e=this.checkActualSize(),t=this.checkSizeOfPartInClient();return e&&!t?this.returnHiddenResult(zg.POSITION):e?(this._clientSize=null,{visible:!0}):this.returnHiddenResult(zg.SIZE)}}return this.returnHiddenResult(zg.STYLE)}return this.returnHiddenResult(Xg.UNMOUNTED)}return this.returnHiddenResult(Xg.INVALID_HTML_ELEMENT)})),nu(this,"checkElementIsMountedOnDom",(e=>this.checkPropertyUpToAllParentNodes(e,(e=>"HTML"!==e.nodeName.toUpperCase()?null!==e.parentElement:!!document.documentElement))));}};function Zg(e){return (new TextEncoder).encode(e)}const $g=function(e,t){const i=new Uint8Array(e.byteLength+t.byteLength);return i.set(new Uint8Array(e),0),i.set(new Uint8Array(t),e.byteLength),i};const eT=async e=>{const t=function(e){const t=window.atob(e),i=new Uint8Array(new ArrayBuffer(t.length));for(let e=0;e<t.length;e+=1)i[e]=t.charCodeAt(e);return i}("MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDCMnXAHkKIGAM+x4N22gCI+Wyu\nSTM9ztkT3uYslTT2PuKmZfPzhH6kVdO7PTjGCOZnAsyb3oTtWat0KcxQ4jxvqQV+\nHvYl3iI1Yd4vl2c3qRMJPLtRDfNxa2Mcxgq7e9aEUibzdd0st+OJAy3tOj/Y0aVy\nxQiYDz3vqa6bP29adwIDAQAB"),i=await window.crypto.subtle.importKey("spki",t,{name:"RSA-OAEP",hash:"SHA-256"},!0,["encrypt"]),n=Zg(e),r=await window.crypto.subtle.encrypt({name:"RSA-OAEP"},i,n);return function(e){let t="";for(let i=0;i<e.length;i+=1)t+=String.fromCharCode(e[i]);return window.btoa(t)}(new Uint8Array(r))},tT=async e=>function(e,t){let i="";return new Uint8Array(e).forEach((e=>{i+=e.toString(t).padStart(2,"0");})),i}(await crypto.subtle.digest("SHA-256",Zg(e)),16);class iT{constructor(){nu(this,"_events",{}),nu(this,"addListener",this.on);}getListeners(e){return this._events[e]?this._events[e].map((e=>e.listener)):[]}on(e,t){this._events[e]||(this._events[e]=[]);const i=this._events[e];-1===this._indexOfListener(i,t)&&i.push({listener:t,once:!1});}once(e,t){this._events[e]||(this._events[e]=[]);const i=this._events[e];-1===this._indexOfListener(i,t)&&i.push({listener:t,once:!0});}off(e,t){if(!this._events[e])return;const i=this._events[e],n=this._indexOfListener(i,t);-1!==n&&i.splice(n,1),0===this._events[e].length&&delete this._events[e];}removeAllListeners(e){e?delete this._events[e]:this._events={};}emit(e){this._events[e]||(this._events[e]=[]);const t=this._events[e].map((e=>e));for(var i=arguments.length,n=new Array(i>1?i-1:0),r=1;r<i;r++)n[r-1]=arguments[r];for(let i=0;i<t.length;i+=1){const r=t[i];r.once&&this.off(e,r.listener),r.listener.apply(this,n||[]);}}safeEmit(e){for(var t=arguments.length,i=new Array(t>1?t-1:0),n=1;n<t;n++)i[n-1]=arguments[n];[...this._events[e]||[]].forEach((t=>{t.once&&this.off(e,t.listener);try{t.listener.apply(this,i);}catch(t){console.error("safeEmit event:".concat(e," error ").concat(null==t?void 0:t.toString()));}}));}_indexOfListener(e,t){let i=e.length;for(;i--;)if(e[i].listener===t)return i;return -1}}let nT=null;function rT(){if(nT)return nT;if(window.electron)return nT=window.electron;if(!window.require)return null;try{return nT=window.require("electron"),nT}catch(e){return null}}var sT,oT,aT,cT,dT,lT,hT,uT;function pT(e){return jg(e.timeout,"config.timeout",0,1e5),jg(e.timeoutFactor,"config.timeoutFactor",0,100,!1),jg(e.maxRetryCount,"config.maxRetryConfig",0,1/0),jg(e.maxRetryTimeout,"config.maxRetryTimeout",0,1/0),!0}function _T(e){if(!Array.isArray(e)||e.length<1)return !1;try{e.forEach((e=>{if(!e.urls)throw Error()}));}catch(e){return !1}return !0}function ET(e){return Wg(e.turnServerURL,"turnServerURL"),Wg(e.username,"username"),Wg(e.password,"password"),e.udpport&&jg(e.udpport,"udpport",1,99999,!0),e.forceturn&&Fg(e.forceturn,"forceturn"),e.security&&Fg(e.security,"security"),e.tcpport&&jg(e.tcpport,"tcpport",1,99999,!0),!0}function mT(e){return void 0!==e.level&&Bg(e.level,"level",[1,2,3]),void 0!==e.delay&&jg(e.delay,"delay",0,3e3,!0),!0}function fT(e,t){for(var i=arguments.length,n=new Array(i>2?i-2:0),r=2;r<i;r++)n[r-2]=arguments[r];return 0===e.getListeners(t).length?tg.reject(new Vg(xg.UNEXPECTED_ERROR,"can not emit promise")):new tg(((i,r)=>{e.emit(t,...n,i,r);}))}function gT(e,t){if(0===e.getListeners(t).length)return tg.resolve();for(var i=arguments.length,n=new Array(i>2?i-2:0),r=2;r<i;r++)n[r-2]=arguments[r];return fT(e,t,...n)}function TT(e,t){if(0===e.getListeners(t).length)return null;for(var i=arguments.length,n=new Array(i>2?i-2:0),r=2;r<i;r++)n[r-2]=arguments[r];return ST(e,t,...n)}function ST(e,t){let i=null,n=null;for(var r=arguments.length,s=new Array(r>2?r-2:0),o=2;o<r;o++)s[o-2]=arguments[o];if(e.emit(t,...s,(e=>{i=e;}),(e=>{n=e;})),null!==n)throw n;if(null===i)throw new Vg(xg.UNEXPECTED_ERROR,"handler is not sync");return i}!function(e){e.CREATE_CLIENT="createClient",e.CHECK_SYSTEM_REQUIREMENTS="checkSystemRequirements",e.SET_AREA="setArea",e.CHECK_VIDEO_TRACK_IS_ACTIVE="checkVideoTrackIsActive",e.CHECK_AUDIO_TRACK_IS_ACTIVE="checkAudioTrackIsActive",e.CREATE_MIC_AUDIO_TRACK="createMicrophoneAudioTrack",e.CREATE_CUSTOM_AUDIO_TRACK="createCustomAudioTrack",e.CREATE_BUFFER_AUDIO_TRACK="createBufferSourceAudioTrack",e.CREATE_CAM_VIDEO_TRACK="createCameraVideoTrack",e.CREATE_CUSTOM_VIDEO_TRACK="createCustomVideoTrack",e.CREATE_MIC_AND_CAM_TRACKS="createMicrophoneAndCameraTracks",e.CREATE_SCREEN_VIDEO_TRACK="createScreenVideoTrack",e.SET_ENCRYPTION_CONFIG="Client.setEncryptionConfig",e.START_PROXY_SERVER="Client.startProxyServer",e.STOP_PROXY_SERVER="Client.stopProxyServer",e.SET_PROXY_SERVER="Client.setProxyServer",e.SET_TURN_SERVER="Client.setTurnServer",e.SET_CLIENT_ROLE="Client.setClientRole",e.SET_LOW_STREAM_PARAMETER="Client.setLowStreamParameter",e.ENABLE_DUAL_STREAM="Client.enableDualStream",e.DISABLE_DUAL_STREAM="Client.disableDualStream",e.JOIN="Client.join",e.LEAVE="Client.leave",e.PUBLISH="Client.publish",e.UNPUBLISH="Client.unpublish",e.SUBSCRIBE="Client.subscribe",e.MASS_SUBSCRIBE="Client.massSubscribe",e.MASS_UNSUBSCRIBE="Client.massUnsubscribe",e.UNSUBSCRIBE="Client.unsubscribe",e.RENEW_TOKEN="Client.renewToken",e.SET_REMOTE_VIDEO_STREAM_TYPE="Client.setRemoteVideoStreamType",e.SET_STREAM_FALLBACK_OPTION="Client.setStreamFallbackOption",e.ENABLE_AUDIO_VOLUME_INDICATOR="Client.enableAudioVolumeIndicator",e.SEND_CUSTOM_REPORT_MESSAGE="Client.sendCustomReportMessage",e.INSPECT_VIDEO_CONTENT="Client.inspectVideoContent",e.STOP_INSPECT_VIDEO_CONTENT="Client.stopInspectVideoContent",e.JOIN_FALLBACK_TO_PROXY="Client._joinFallbackToProxy",e.DATACHANNEL_FAILBACK="Client._datachannelFailback",e.ON_LIVE_STREAM_WARNING="Client.onLiveStreamWarning",e.ON_LIVE_STREAM_ERROR="Client.onLiveStreamingError",e.START_LIVE_STREAMING="Client.startLiveStreaming",e.SET_LIVE_TRANSCODING="Client.setLiveTranscoding",e.STOP_LIVE_STREAMING="Client.stopLiveStreaming",e.ADD_INJECT_STREAM_URL="Client.addInjectStreamUrl",e.REMOVE_INJECT_STREAM_URL="Client.removeInjectStreamUrl",e.START_CHANNEL_MEDIA_RELAY="Client.startChannelMediaRelay",e.UPDATE_CHANNEL_MEDIA_RELAY="Client.updateChannelMediaRelay",e.STOP_CHANNEL_MEDIA_RELAY="Client.stopChannelMediaRelay",e.REQUEST_CONFIG_DISTRIBUTE="_config-distribute-request",e.SET_CONFIG_DISTRIBUTE="_configDistribute",e.LOCAL_TRACK_SET_MUTED="LocalTrack.setMute",e.LOCAL_AUDIO_TRACK_PLAY="LocalAudioTrack.play",e.LOCAL_AUDIO_TRACK_PLAY_IN_ELEMENT="LocalAudioTrack.playInElement",e.LOCAL_AUDIO_TRACK_STOP="LocalAudioTrack.stop",e.LOCAL_AUDIO_TRACK_SET_VOLUME="LocalAudioTrack.setVolume",e.MIC_AUDIO_TRACK_SET_DEVICE="MicrophoneAudioTrack.setDevice",e.BUFFER_AUDIO_TRACK_START="BufferSourceAudioTrack.startProcessAudioBuffer",e.BUFFER_AUDIO_TRACK_STOP="BufferSourceAudioTrack.stopProcessAudioBuffer",e.BUFFER_AUDIO_TRACK_PAUSE="BufferSourceAudioTrack.pauseProcessAudioBuffer",e.BUFFER_AUDIO_TRACK_RESUME="BufferSourceAudioTrack.resumeProcessAudioBuffer",e.BUFFER_AUDIO_TRACK_SEEK="BufferSourceAudioTrack.seekAudioBuffer",e.LOCAL_VIDEO_TRACK_PLAY="LocalVideoTrack.play",e.LOCAL_VIDEO_TRACK_STOP="LocalVideoTrack.stop",e.LOCAL_VIDEO_TRACK_GET_VIDEO_VISIBLE="LocalVideoTrack.getVideoElementVisibleStatus",e.LOCAL_VIDEO_TRACK_BEAUTY="LocalVideoTrack.setBeautyEffect",e.CAM_VIDEO_TRACK_SET_DEVICE="CameraVideoTrack.setDevice",e.CAM_VIDEO_TRACK_SET_ENCODER_CONFIG="CameraVideoTrack.setEncoderConfiguration",e.REMOTE_VIDEO_TRACK_PLAY="RemoteVideoTrack.play",e.REMOTE_VIDEO_TRACK_STOP="RemoteVideoTrack.stop",e.REMOTE_VIDEO_TRACK_GET_VIDEO_VISIBLE="RemoteVideoTrack.getVideoElementVisibleStatus",e.REMOTE_AUDIO_TRACK_PLAY="RemoteAudioTrack.play",e.REMOTE_AUDIO_TRACK_STOP="RemoteAudioTrack.stop",e.REMOTE_AUDIO_SET_VOLUME="RemoteAudioTrack.setVolume",e.REMOTE_AUDIO_SET_OUTPUT_DEVICE="RemoteAudioTrack.setOutputDevice",e.GET_MEDIA_STREAM_TRACK="Track.getMediaStreamTrack",e.STREAM_TYPE_CHANGE="streamTypeChange",e.CONNECTION_STATE_CHANGE="connectionStateChange",e.LOAD_CONFIG_FROM_LOCALSTORAGE="loadConfigFromLocalStorage",e.IMAGE_MODERATION_UPLOAD="imageModerationUpload";}(sT||(sT={})),function(e){e.TRACER="tracer";}(oT||(oT={})),function(e){e[e.AUDIENCE_LEVEL_LOW_LATENCY=1]="AUDIENCE_LEVEL_LOW_LATENCY",e[e.AUDIENCE_LEVEL_ULTRA_LOW_LATENCY=2]="AUDIENCE_LEVEL_ULTRA_LOW_LATENCY",e[e.AUDIENCE_LEVEL_SYNC_LATENCY=3]="AUDIENCE_LEVEL_SYNC_LATENCY";}(aT||(aT={})),function(e){e.LEAVE="LEAVE",e.NETWORK_ERROR="NETWORK_ERROR",e.SERVER_ERROR="SERVER_ERROR",e.UID_BANNED="UID_BANNED",e.IP_BANNED="IP_BANNED",e.CHANNEL_BANNED="CHANNEL_BANNED",e.FALLBACK="FALLBACK",e.LICENSE_MISSING="LICENSE_MISSING",e.LICENSE_EXPIRED="LICENSE_EXPIRED",e.LICENSE_MINUTES_EXCEEDED="LICENSE_MINUTES_EXCEEDED",e.LICENSE_PERIOD_INVALID="LICENSE_PERIOD_INVALID",e.LICENSE_MULTIPLE_SDK_SERVICE="LICENSE_MULTIPLE_SDK_SERVICE",e.LICENSE_ILLEGAL="LICENSE_ILLEGAL",e.TOKEN_EXPIRE="TOKEN_EXPIRE";}(cT||(cT={})),function(e){e.CONNECTION_STATE_CHANGE="connection-state-change",e.MEDIA_RECONNECT_START="media-reconnect-start",e.MEDIA_RECONNECT_END="media-reconnect-end",e.IS_USING_CLOUD_PROXY="is-using-cloud-proxy",e.USER_JOINED="user-joined",e.USER_LEAVED="user-left",e.USER_PUBLISHED="user-published",e.USER_UNPUBLISHED="user-unpublished",e.USER_INFO_UPDATED="user-info-updated",e.CLIENT_BANNED="client-banned",e.CHANNEL_MEDIA_RELAY_STATE="channel-media-relay-state",e.CHANNEL_MEDIA_RELAY_EVENT="channel-media-relay-event",e.VOLUME_INDICATOR="volume-indicator",e.CRYPT_ERROR="crypt-error",e.ON_TOKEN_PRIVILEGE_WILL_EXPIRE="token-privilege-will-expire",e.ON_TOKEN_PRIVILEGE_DID_EXPIRE="token-privilege-did-expire",e.NETWORK_QUALITY="network-quality",e.STREAM_TYPE_CHANGED="stream-type-changed",e.STREAM_FALLBACK="stream-fallback",e.RECEIVE_METADATA="receive-metadata",e.STREAM_MESSAGE="stream-message",e.LIVE_STREAMING_ERROR="live-streaming-error",e.LIVE_STREAMING_WARNING="live-streaming-warning",e.INJECT_STREAM_STATUS="stream-inject-status",e.EXCEPTION="exception",e.ERROR="error",e.P2P_LOST="p2p_lost",e.JOIN_FALLBACK_TO_PROXY="join-fallback-to-proxy",e.CHANNEL_FALLBACK_TO_WEBSOCKET="channel-fallback-to-websocket",e.MEDIA_CONNECTION_TYPE_CHANGE="media-connection-type-change",e.PUBLISHED_USER_LIST="published-user-list",e.CONTENT_INSPECT_CONNECTION_STATE_CHANGE="content-inspect-connection-state-change",e.CONTENT_INSPECT_ERROR="content-inspect-error",e.CONTENT_INSPECT_RESULT="content-inspect-result",e.IMAGE_MODERATION_CONNECTION_STATE_CHANGE="image-moderation-connection-state-change";}(dT||(dT={})),function(e){e.NETWORK_ERROR="NETWORK_ERROR",e.SERVER_ERROR="SERVER_ERROR",e.MULTI_IP="MULTI_IP",e.TIMEOUT="TIMEOUT",e.OFFLINE="OFFLINE",e.LEAVE="LEAVE",e.P2P_FAILED="P2P_FAILED",e.FALLBACK="FALLBACK";}(lT||(lT={})),function(e){e.ONLINE="ONLINE",e.OFFLINE="OFFLINE";}(hT||(hT={})),function(e){e.NETWORK_STATE_CHANGE="NETWORK_STATE_CHANGE",e.ONLINE="ONLINE",e.OFFLINE="OFFLINE";}(uT||(uT={}));const RT=new class extends iT{set networkState(e){this.emit(uT.NETWORK_STATE_CHANGE,e,this._networkState),e===hT.ONLINE?this.emit(uT.ONLINE):e===hT.OFFLINE&&(this.onlineWaiter=new tg((e=>{this.once(uT.ONLINE,(()=>{this.onlineWaiter=void 0,e(hT.ONLINE);}));})),this.emit(uT.OFFLINE)),this._networkState=e;}get networkState(){return this._networkState}get isOnline(){return this._networkState===hT.ONLINE}constructor(){super(),nu(this,"_moduleName","network-indicator"),nu(this,"_networkState",hT.ONLINE),nu(this,"onlineWaiter",void 0),window.addEventListener("online",(()=>{this.networkState=hT.ONLINE;})),window.addEventListener("offline",(()=>{this.networkState=hT.OFFLINE;}));}};function CT(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n);}return i}function vT(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?CT(Object(i),!0).forEach((function(t){nu(e,t,i[t]);})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):CT(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t));}));}return e}function IT(e,t){const i=e.indexOf(t);-1!==i&&e.splice(i,1);}function yT(e){const t=[];return e.forEach((e=>{-1===t.indexOf(e)&&t.push(e);})),t}function AT(e){void 0!==tg?tg.resolve().then(e):setTimeout(e,0);}function bT(e){return JSON.parse(JSON.stringify(e))}function wT(e){try{return bT(e)}catch(t){return e}}const OT={};function NT(e,t){OT[t]||(OT[t]=!0,e());}function DT(e){const t=window.atob(e),i=new Uint8Array(new ArrayBuffer(t.length));for(let e=0;e<t.length;e+=1)i[e]=t.charCodeAt(e);return i}function PT(e){let t="";for(let i=0;i<e.length;i+=1)t+=String.fromCharCode(e[i]);return window.btoa(t)}function LT(e){return window.TextEncoder?(new TextEncoder).encode(e).length:e.length}function kT(e){let t=0;return /DingTalk/i.test(navigator.userAgent)&&e.realFormData&&(e=e.realFormData),e.forEach((e=>{t+="string"==typeof e?LT(e):e.size;})),t+138}function MT(e){const t=new Vg(xg.TIMEOUT,"timeout");return new tg(((i,n)=>{window.setTimeout((()=>n(t)),e);}))}function UT(e){return new tg((t=>{window.setTimeout(t,e);}))}function xT(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:7,t=arguments.length>1?arguments[1]:void 0;const i=Math.random().toString(16).substr(2,e).toLowerCase();return i.length===e?"".concat(t).concat(i):"".concat(t).concat(i)+xT(e-i.length,"")}function VT(){return xT(32,"").toUpperCase()}const FT=()=>{};const BT=new class{constructor(){nu(this,"fnMap",new Map);}throttleByKey(e,t,i,n){for(var r=arguments.length,s=new Array(r>4?r-4:0),o=4;o<r;o++)s[o-4]=arguments[o];if(this.fnMap.has(t)){const r=this.fnMap.get(t);if(r.threshold!==i){r.fn(...r.args),clearTimeout(r.timer);const o=window.setTimeout((()=>{const e=this.fnMap.get(t);e&&e.fn(...e.args),this.fnMap.delete(t);}),i);this.fnMap.set(t,{fn:e,threshold:i,timer:o,args:s,skipFn:n});}else r.skipFn&&r.skipFn(...r.args),this.fnMap.set(t,vT(vT({},r),{},{fn:e,args:s,skipFn:n}));}else {const r=window.setTimeout((()=>{const e=this.fnMap.get(t);e&&e.fn(...e.args),this.fnMap.delete(t);}),i);this.fnMap.set(t,{fn:e,threshold:i,timer:r,args:s,skipFn:n});}}},jT=BT.throttleByKey.bind(BT);function GT(e){return "object"==typeof e&&null!==e&&!(e instanceof RegExp)}function WT(e,t){if(!GT(e)||!GT(t))return t;if(Array.isArray(e)&&!Array.isArray(t)||!Array.isArray(e)&&Array.isArray(t))return t;if(Array.isArray(t)&&Array.isArray(e)){const i=[...e];for(let n=0;n<t.length;n++)i[n]=WT(e[n],t[n]);return i}{const i=vT({},e);for(const n in t)Object.prototype.hasOwnProperty.call(t,n)&&(Object.prototype.hasOwnProperty.call(e,n)?i[n]=WT(e[n],t[n]):i[n]=t[n]);return i}}let HT=1,KT=console;class YT{static setLogger(e){KT=e;}constructor(e){nu(this,"lockingPromise",tg.resolve()),nu(this,"locks",0),nu(this,"name",""),nu(this,"lockId",void 0),this.lockId=HT++,e&&(this.name=e),KT.debug("[lock-".concat(this.name,"-").concat(this.lockId,"] is created."));}get isLocked(){return this.locks>0}lock(e){let t;this.locks+=1,KT.debug("[lock-".concat(this.name,"-").concat(this.lockId,"] is locked, current queue ").concat(this.locks,". ").concat("string"==typeof e?e:""));const i=new tg((i=>{t=()=>{this.locks-=1,KT.debug("[lock-".concat(this.name,"-").concat(this.lockId,"] is not locked, current queue ").concat(this.locks,". ").concat("string"==typeof e?e:"")),i();};})),n=this.lockingPromise.then((()=>t));return this.lockingPromise=this.lockingPromise.then((()=>i)),n}}function qT(e,t){return function(i,n,r){const s=r.value;if("function"!=typeof s)throw new Error("Cannot use mutex on object property.");return r.value=async function(){const i=this[t];if(!i)throw new Error("mutex property key ".concat(t," doesn't exist on ").concat(e));const r=await i.lock("From ".concat(e,".").concat(n));try{for(var o=arguments.length,a=new Array(o),c=0;c<o;c++)a[c]=arguments[c];return await s.apply(this,a)}finally{r();}},r}}const JT={timeout:500,timeoutFactor:1.5,maxRetryCount:1/0,maxRetryTimeout:1e4};function zT(e,t){const i=Math.floor(t.timeout*Math.pow(t.timeoutFactor,e));return Math.min(t.maxRetryTimeout,i)}function XT(e,t,i,n){const r=Object.assign({},JT,n);let s=r.timeout;const o=async()=>{await function(e){return new tg((t=>{window.setTimeout(t,e);}))}(s),s*=r.timeoutFactor,s=Math.min(r.maxRetryTimeout,s);};let a=!1;const c=new tg((async(n,s)=>{t=t||(()=>!1),i=i||(()=>!0);for(let c=0;c<r.maxRetryCount;c+=1){if(a)return s(new Vg(xg.OPERATION_ABORTED));try{const i=await e();if(!t(i,c))return n(i);if(c+1===r.maxRetryCount)return n(i);await o();}catch(e){if(!i(e,c))return s(e);if(c+1===r.maxRetryCount)return s(e);await o();}}}));return c.cancel=()=>a=!0,c}var QT=Ut,ZT=ei,$T=Xe,eS=Yn,tS=TypeError,iS=function(e){return function(t,i,n,r){QT(i);var s=ZT(t),o=$T(s),a=eS(s),c=e?a-1:0,d=e?-1:1;if(n<2)for(;;){if(c in o){r=o[c],c+=d;break}if(c+=d,e?c<0:a<=c)throw tS("Reduce of empty array with no initial value")}for(;e?c>=0:a>c;c+=d)c in o&&(r=i(r,o[c],c,s));return r}},nS={left:iS(!1),right:iS(!0)}.left;kn({target:"Array",proto:!0,forced:!C_&&St>79&&St<83||!Ru("reduce")},{reduce:function(e){var t=arguments.length;return nS(this,e,t,t>1?arguments[1]:void 0)}});var rS=er("Array").reduce,sS=Ee,oS=rS,aS=Array.prototype,cS=J((function(e){var t=e.reduce;return e===aS||sS(aS,e)&&t===aS.reduce?oS:t}));let dS=class{constructor(e){nu(this,"input",[]),nu(this,"size",void 0),this.size=e;}add(e){this.input.push(e),this.input.length>this.size&&this.input.splice(0,1);}mean(){var e;return 0===this.input.length?0:cS(e=this.input).call(e,((e,t)=>e+t))/this.input.length}};var lS,hS={exports:{}},uS=function(e,t){return function(){for(var i=new Array(arguments.length),n=0;n<i.length;n++)i[n]=arguments[n];return e.apply(t,i)}},pS=uS,_S=Object.prototype.toString,ES=(lS=Object.create(null),function(e){var t=_S.call(e);return lS[t]||(lS[t]=t.slice(8,-1).toLowerCase())});function mS(e){return e=e.toLowerCase(),function(t){return ES(t)===e}}function fS(e){return Array.isArray(e)}function gS(e){return void 0===e}var TS=mS("ArrayBuffer");function SS(e){return null!==e&&"object"==typeof e}function RS(e){if("object"!==ES(e))return !1;var t=Object.getPrototypeOf(e);return null===t||t===Object.prototype}var CS=mS("Date"),vS=mS("File"),IS=mS("Blob"),yS=mS("FileList");function AS(e){return "[object Function]"===_S.call(e)}var bS=mS("URLSearchParams");function wS(e,t){if(null!=e)if("object"!=typeof e&&(e=[e]),fS(e))for(var i=0,n=e.length;i<n;i++)t.call(null,e[i],i,e);else for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&t.call(null,e[r],r,e);}var OS,NS=(OS="undefined"!=typeof Uint8Array&&Object.getPrototypeOf(Uint8Array),function(e){return OS&&e instanceof OS}),DS={isArray:fS,isArrayBuffer:TS,isBuffer:function(e){return null!==e&&!gS(e)&&null!==e.constructor&&!gS(e.constructor)&&"function"==typeof e.constructor.isBuffer&&e.constructor.isBuffer(e)},isFormData:function(e){var t="[object FormData]";return e&&("function"==typeof FormData&&e instanceof FormData||_S.call(e)===t||AS(e.toString)&&e.toString()===t)},isArrayBufferView:function(e){return "undefined"!=typeof ArrayBuffer&&ArrayBuffer.isView?ArrayBuffer.isView(e):e&&e.buffer&&TS(e.buffer)},isString:function(e){return "string"==typeof e},isNumber:function(e){return "number"==typeof e},isObject:SS,isPlainObject:RS,isUndefined:gS,isDate:CS,isFile:vS,isBlob:IS,isFunction:AS,isStream:function(e){return SS(e)&&AS(e.pipe)},isURLSearchParams:bS,isStandardBrowserEnv:function(){return ("undefined"==typeof navigator||"ReactNative"!==navigator.product&&"NativeScript"!==navigator.product&&"NS"!==navigator.product)&&("undefined"!=typeof window&&"undefined"!=typeof document)},forEach:wS,merge:function e(){var t={};function i(i,n){RS(t[n])&&RS(i)?t[n]=e(t[n],i):RS(i)?t[n]=e({},i):fS(i)?t[n]=i.slice():t[n]=i;}for(var n=0,r=arguments.length;n<r;n++)wS(arguments[n],i);return t},extend:function(e,t,i){return wS(t,(function(t,n){e[n]=i&&"function"==typeof t?pS(t,i):t;})),e},trim:function(e){return e.trim?e.trim():e.replace(/^\s+|\s+$/g,"")},stripBOM:function(e){return 65279===e.charCodeAt(0)&&(e=e.slice(1)),e},inherits:function(e,t,i,n){e.prototype=Object.create(t.prototype,n),e.prototype.constructor=e,i&&Object.assign(e.prototype,i);},toFlatObject:function(e,t,i){var n,r,s,o={};t=t||{};do{for(r=(n=Object.getOwnPropertyNames(e)).length;r-- >0;)o[s=n[r]]||(t[s]=e[s],o[s]=!0);e=Object.getPrototypeOf(e);}while(e&&(!i||i(e,t))&&e!==Object.prototype);return t},kindOf:ES,kindOfTest:mS,endsWith:function(e,t,i){e=String(e),(void 0===i||i>e.length)&&(i=e.length),i-=t.length;var n=e.indexOf(t,i);return -1!==n&&n===i},toArray:function(e){if(!e)return null;var t=e.length;if(gS(t))return null;for(var i=new Array(t);t-- >0;)i[t]=e[t];return i},isTypedArray:NS,isFileList:yS},PS=DS;function LS(e){return encodeURIComponent(e).replace(/%3A/gi,":").replace(/%24/g,"$").replace(/%2C/gi,",").replace(/%20/g,"+").replace(/%5B/gi,"[").replace(/%5D/gi,"]")}var kS=function(e,t,i){if(!t)return e;var n;if(i)n=i(t);else if(PS.isURLSearchParams(t))n=t.toString();else {var r=[];PS.forEach(t,(function(e,t){null!=e&&(PS.isArray(e)?t+="[]":e=[e],PS.forEach(e,(function(e){PS.isDate(e)?e=e.toISOString():PS.isObject(e)&&(e=JSON.stringify(e)),r.push(LS(t)+"="+LS(e));})));})),n=r.join("&");}if(n){var s=e.indexOf("#");-1!==s&&(e=e.slice(0,s)),e+=(-1===e.indexOf("?")?"?":"&")+n;}return e},MS=DS;function US(){this.handlers=[];}US.prototype.use=function(e,t,i){return this.handlers.push({fulfilled:e,rejected:t,synchronous:!!i&&i.synchronous,runWhen:i?i.runWhen:null}),this.handlers.length-1},US.prototype.eject=function(e){this.handlers[e]&&(this.handlers[e]=null);},US.prototype.forEach=function(e){MS.forEach(this.handlers,(function(t){null!==t&&e(t);}));};var xS,VS,FS=US,BS=DS;function jS(){if(VS)return xS;VS=1;var e=DS;function t(e,t,i,n,r){Error.call(this),this.message=e,this.name="AxiosError",t&&(this.code=t),i&&(this.config=i),n&&(this.request=n),r&&(this.response=r);}e.inherits(t,Error,{toJSON:function(){return {message:this.message,name:this.name,description:this.description,number:this.number,fileName:this.fileName,lineNumber:this.lineNumber,columnNumber:this.columnNumber,stack:this.stack,config:this.config,code:this.code,status:this.response&&this.response.status?this.response.status:null}}});var i=t.prototype,n={};return ["ERR_BAD_OPTION_VALUE","ERR_BAD_OPTION","ECONNABORTED","ETIMEDOUT","ERR_NETWORK","ERR_FR_TOO_MANY_REDIRECTS","ERR_DEPRECATED","ERR_BAD_RESPONSE","ERR_BAD_REQUEST","ERR_CANCELED"].forEach((function(e){n[e]={value:e};})),Object.defineProperties(t,n),Object.defineProperty(i,"isAxiosError",{value:!0}),t.from=function(n,r,s,o,a,c){var d=Object.create(i);return e.toFlatObject(n,d,(function(e){return e!==Error.prototype})),t.call(d,n.message,r,s,o,a),d.name=n.name,c&&Object.assign(d,c),d},xS=t}var GS,WS,HS,KS,YS,qS,JS={silentJSONParsing:!0,forcedJSONParsing:!0,clarifyTimeoutError:!1};function zS(){if(WS)return GS;WS=1;var e=DS;return GS=function(t,i){i=i||new FormData;var n=[];function r(t){return null===t?"":e.isDate(t)?t.toISOString():e.isArrayBuffer(t)||e.isTypedArray(t)?"function"==typeof Blob?new Blob([t]):Buffer.from(t):t}return function t(s,o){if(e.isPlainObject(s)||e.isArray(s)){if(-1!==n.indexOf(s))throw Error("Circular reference detected in "+o);n.push(s),e.forEach(s,(function(n,s){if(!e.isUndefined(n)){var a,c=o?o+"."+s:s;if(n&&!o&&"object"==typeof n)if(e.endsWith(s,"{}"))n=JSON.stringify(n);else if(e.endsWith(s,"[]")&&(a=e.toArray(n)))return void a.forEach((function(t){!e.isUndefined(t)&&i.append(c,r(t));}));t(n,c);}})),n.pop();}else i.append(o,r(s));}(t),i},GS}function XS(){if(KS)return HS;KS=1;var e=jS();return HS=function(t,i,n){var r=n.config.validateStatus;n.status&&r&&!r(n.status)?i(new e("Request failed with status code "+n.status,[e.ERR_BAD_REQUEST,e.ERR_BAD_RESPONSE][Math.floor(n.status/100)-4],n.config,n.request,n)):t(n);}}function QS(){if(qS)return YS;qS=1;var e=DS;return YS=e.isStandardBrowserEnv()?{write:function(t,i,n,r,s,o){var a=[];a.push(t+"="+encodeURIComponent(i)),e.isNumber(n)&&a.push("expires="+new Date(n).toGMTString()),e.isString(r)&&a.push("path="+r),e.isString(s)&&a.push("domain="+s),!0===o&&a.push("secure"),document.cookie=a.join("; ");},read:function(e){var t=document.cookie.match(new RegExp("(^|;\\s*)("+e+")=([^;]*)"));return t?decodeURIComponent(t[3]):null},remove:function(e){this.write(e,"",Date.now()-864e5);}}:{write:function(){},read:function(){return null},remove:function(){}},YS}var ZS,$S,eR,tR,iR,nR,rR,sR,oR,aR,cR,dR,lR=function(e){return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(e)},hR=function(e,t){return t?e.replace(/\/+$/,"")+"/"+t.replace(/^\/+/,""):e},uR=function(e,t){return e&&!lR(t)?hR(e,t):t};function pR(){if($S)return ZS;$S=1;var e=DS,t=["age","authorization","content-length","content-type","etag","expires","from","host","if-modified-since","if-unmodified-since","last-modified","location","max-forwards","proxy-authorization","referer","retry-after","user-agent"];return ZS=function(i){var n,r,s,o={};return i?(e.forEach(i.split("\n"),(function(i){if(s=i.indexOf(":"),n=e.trim(i.substr(0,s)).toLowerCase(),r=e.trim(i.substr(s+1)),n){if(o[n]&&t.indexOf(n)>=0)return;o[n]="set-cookie"===n?(o[n]?o[n]:[]).concat([r]):o[n]?o[n]+", "+r:r;}})),o):o},ZS}function _R(){if(tR)return eR;tR=1;var e=DS;return eR=e.isStandardBrowserEnv()?function(){var t,i=/(msie|trident)/i.test(navigator.userAgent),n=document.createElement("a");function r(e){var t=e;return i&&(n.setAttribute("href",t),t=n.href),n.setAttribute("href",t),{href:n.href,protocol:n.protocol?n.protocol.replace(/:$/,""):"",host:n.host,search:n.search?n.search.replace(/^\?/,""):"",hash:n.hash?n.hash.replace(/^#/,""):"",hostname:n.hostname,port:n.port,pathname:"/"===n.pathname.charAt(0)?n.pathname:"/"+n.pathname}}return t=r(window.location.href),function(i){var n=e.isString(i)?r(i):i;return n.protocol===t.protocol&&n.host===t.host}}():function(){return !0}}function ER(){if(nR)return iR;nR=1;var e=jS();function t(t){e.call(this,null==t?"canceled":t,e.ERR_CANCELED),this.name="CanceledError";}return DS.inherits(t,e,{__CANCEL__:!0}),iR=t}function mR(){return sR||(sR=1,rR=function(e){var t=/^([-+\w]{1,25})(:?\/\/|:)/.exec(e);return t&&t[1]||""}),rR}function fR(){if(aR)return oR;aR=1;var e=DS,t=XS(),i=QS(),n=kS,r=uR,s=pR(),o=_R(),a=JS,c=jS(),d=ER(),l=mR();return oR=function(h){return new Promise((function(u,p){var _,E=h.data,m=h.headers,f=h.responseType;function g(){h.cancelToken&&h.cancelToken.unsubscribe(_),h.signal&&h.signal.removeEventListener("abort",_);}e.isFormData(E)&&e.isStandardBrowserEnv()&&delete m["Content-Type"];var T=new XMLHttpRequest;if(h.auth){var S=h.auth.username||"",R=h.auth.password?unescape(encodeURIComponent(h.auth.password)):"";m.Authorization="Basic "+btoa(S+":"+R);}var C=r(h.baseURL,h.url);function v(){if(T){var e="getAllResponseHeaders"in T?s(T.getAllResponseHeaders()):null,i={data:f&&"text"!==f&&"json"!==f?T.response:T.responseText,status:T.status,statusText:T.statusText,headers:e,config:h,request:T};t((function(e){u(e),g();}),(function(e){p(e),g();}),i),T=null;}}if(T.open(h.method.toUpperCase(),n(C,h.params,h.paramsSerializer),!0),T.timeout=h.timeout,"onloadend"in T?T.onloadend=v:T.onreadystatechange=function(){T&&4===T.readyState&&(0!==T.status||T.responseURL&&0===T.responseURL.indexOf("file:"))&&setTimeout(v);},T.onabort=function(){T&&(p(new c("Request aborted",c.ECONNABORTED,h,T)),T=null);},T.onerror=function(){p(new c("Network Error",c.ERR_NETWORK,h,T,T)),T=null;},T.ontimeout=function(){var e=h.timeout?"timeout of "+h.timeout+"ms exceeded":"timeout exceeded",t=h.transitional||a;h.timeoutErrorMessage&&(e=h.timeoutErrorMessage),p(new c(e,t.clarifyTimeoutError?c.ETIMEDOUT:c.ECONNABORTED,h,T)),T=null;},e.isStandardBrowserEnv()){var I=(h.withCredentials||o(C))&&h.xsrfCookieName?i.read(h.xsrfCookieName):void 0;I&&(m[h.xsrfHeaderName]=I);}"setRequestHeader"in T&&e.forEach(m,(function(e,t){void 0===E&&"content-type"===t.toLowerCase()?delete m[t]:T.setRequestHeader(t,e);})),e.isUndefined(h.withCredentials)||(T.withCredentials=!!h.withCredentials),f&&"json"!==f&&(T.responseType=h.responseType),"function"==typeof h.onDownloadProgress&&T.addEventListener("progress",h.onDownloadProgress),"function"==typeof h.onUploadProgress&&T.upload&&T.upload.addEventListener("progress",h.onUploadProgress),(h.cancelToken||h.signal)&&(_=function(e){T&&(p(!e||e&&e.type?new d:e),T.abort(),T=null);},h.cancelToken&&h.cancelToken.subscribe(_),h.signal&&(h.signal.aborted?_():h.signal.addEventListener("abort",_))),E||(E=null);var y=l(C);y&&-1===["http","https","file"].indexOf(y)?p(new c("Unsupported protocol "+y+":",c.ERR_BAD_REQUEST,h)):T.send(E);}))},oR}var gR=DS,TR=function(e,t){BS.forEach(e,(function(i,n){n!==t&&n.toUpperCase()===t.toUpperCase()&&(e[t]=i,delete e[n]);}));},SR=jS(),RR=JS,CR=zS(),vR={"Content-Type":"application/x-www-form-urlencoded"};function IR(e,t){!gR.isUndefined(e)&&gR.isUndefined(e["Content-Type"])&&(e["Content-Type"]=t);}var yR,AR={transitional:RR,adapter:(("undefined"!=typeof XMLHttpRequest||"undefined"!=typeof process&&"[object process]"===Object.prototype.toString.call(process))&&(yR=fR()),yR),transformRequest:[function(e,t){if(TR(t,"Accept"),TR(t,"Content-Type"),gR.isFormData(e)||gR.isArrayBuffer(e)||gR.isBuffer(e)||gR.isStream(e)||gR.isFile(e)||gR.isBlob(e))return e;if(gR.isArrayBufferView(e))return e.buffer;if(gR.isURLSearchParams(e))return IR(t,"application/x-www-form-urlencoded;charset=utf-8"),e.toString();var i,n=gR.isObject(e),r=t&&t["Content-Type"];if((i=gR.isFileList(e))||n&&"multipart/form-data"===r){var s=this.env&&this.env.FormData;return CR(i?{"files[]":e}:e,s&&new s)}return n||"application/json"===r?(IR(t,"application/json"),function(e,t,i){if(gR.isString(e))try{return (t||JSON.parse)(e),gR.trim(e)}catch(e){if("SyntaxError"!==e.name)throw e}return (i||JSON.stringify)(e)}(e)):e}],transformResponse:[function(e){var t=this.transitional||AR.transitional,i=t&&t.silentJSONParsing,n=t&&t.forcedJSONParsing,r=!i&&"json"===this.responseType;if(r||n&&gR.isString(e)&&e.length)try{return JSON.parse(e)}catch(e){if(r){if("SyntaxError"===e.name)throw SR.from(e,SR.ERR_BAD_RESPONSE,this,null,this.response);throw e}}return e}],timeout:0,xsrfCookieName:"XSRF-TOKEN",xsrfHeaderName:"X-XSRF-TOKEN",maxContentLength:-1,maxBodyLength:-1,env:{FormData:dR?cR:(dR=1,cR=null)},validateStatus:function(e){return e>=200&&e<300},headers:{common:{Accept:"application/json, text/plain, */*"}}};gR.forEach(["delete","get","head"],(function(e){AR.headers[e]={};})),gR.forEach(["post","put","patch"],(function(e){AR.headers[e]=gR.merge(vR);}));var bR,wR,OR=AR,NR=DS,DR=OR;function PR(){return wR?bR:(wR=1,bR=function(e){return !(!e||!e.__CANCEL__)})}var LR=DS,kR=function(e,t,i){var n=this||DR;return NR.forEach(i,(function(i){e=i.call(n,e,t);})),e},MR=PR(),UR=OR,xR=ER();function VR(e){if(e.cancelToken&&e.cancelToken.throwIfRequested(),e.signal&&e.signal.aborted)throw new xR}var FR,BR,jR=DS,GR=function(e,t){t=t||{};var i={};function n(e,t){return jR.isPlainObject(e)&&jR.isPlainObject(t)?jR.merge(e,t):jR.isPlainObject(t)?jR.merge({},t):jR.isArray(t)?t.slice():t}function r(i){return jR.isUndefined(t[i])?jR.isUndefined(e[i])?void 0:n(void 0,e[i]):n(e[i],t[i])}function s(e){if(!jR.isUndefined(t[e]))return n(void 0,t[e])}function o(i){return jR.isUndefined(t[i])?jR.isUndefined(e[i])?void 0:n(void 0,e[i]):n(void 0,t[i])}function a(i){return i in t?n(e[i],t[i]):i in e?n(void 0,e[i]):void 0}var c={url:s,method:s,data:s,baseURL:o,transformRequest:o,transformResponse:o,paramsSerializer:o,timeout:o,timeoutMessage:o,withCredentials:o,adapter:o,responseType:o,xsrfCookieName:o,xsrfHeaderName:o,onUploadProgress:o,onDownloadProgress:o,decompress:o,maxContentLength:o,maxBodyLength:o,beforeRedirect:o,transport:o,httpAgent:o,httpsAgent:o,cancelToken:o,socketPath:o,responseEncoding:o,validateStatus:a};return jR.forEach(Object.keys(e).concat(Object.keys(t)),(function(e){var t=c[e]||r,n=t(e);jR.isUndefined(n)&&t!==a||(i[e]=n);})),i};function WR(){return BR?FR:(BR=1,FR={version:"0.27.2"})}var HR=WR().version,KR=jS(),YR={};["object","boolean","number","function","string","symbol"].forEach((function(e,t){YR[e]=function(i){return typeof i===e||"a"+(t<1?"n ":" ")+e};}));var qR={};YR.transitional=function(e,t,i){function n(e,t){return "[Axios v"+HR+"] Transitional option '"+e+"'"+t+(i?". "+i:"")}return function(i,r,s){if(!1===e)throw new KR(n(r," has been removed"+(t?" in "+t:"")),KR.ERR_DEPRECATED);return t&&!qR[r]&&(qR[r]=!0,console.warn(n(r," has been deprecated since v"+t+" and will be removed in the near future"))),!e||e(i,r,s)}};var JR,zR,XR,QR,ZR,$R,eC={assertOptions:function(e,t,i){if("object"!=typeof e)throw new KR("options must be an object",KR.ERR_BAD_OPTION_VALUE);for(var n=Object.keys(e),r=n.length;r-- >0;){var s=n[r],o=t[s];if(o){var a=e[s],c=void 0===a||o(a,s,e);if(!0!==c)throw new KR("option "+s+" must be "+c,KR.ERR_BAD_OPTION_VALUE)}else if(!0!==i)throw new KR("Unknown option "+s,KR.ERR_BAD_OPTION)}},validators:YR},tC=DS,iC=kS,nC=FS,rC=function(e){return VR(e),e.headers=e.headers||{},e.data=kR.call(e,e.data,e.headers,e.transformRequest),e.headers=LR.merge(e.headers.common||{},e.headers[e.method]||{},e.headers),LR.forEach(["delete","get","head","post","put","patch","common"],(function(t){delete e.headers[t];})),(e.adapter||UR.adapter)(e).then((function(t){return VR(e),t.data=kR.call(e,t.data,t.headers,e.transformResponse),t}),(function(t){return MR(t)||(VR(e),t&&t.response&&(t.response.data=kR.call(e,t.response.data,t.response.headers,e.transformResponse))),Promise.reject(t)}))},sC=GR,oC=uR,aC=eC,cC=aC.validators;function dC(e){this.defaults=e,this.interceptors={request:new nC,response:new nC};}dC.prototype.request=function(e,t){"string"==typeof e?(t=t||{}).url=e:t=e||{},(t=sC(this.defaults,t)).method?t.method=t.method.toLowerCase():this.defaults.method?t.method=this.defaults.method.toLowerCase():t.method="get";var i=t.transitional;void 0!==i&&aC.assertOptions(i,{silentJSONParsing:cC.transitional(cC.boolean),forcedJSONParsing:cC.transitional(cC.boolean),clarifyTimeoutError:cC.transitional(cC.boolean)},!1);var n=[],r=!0;this.interceptors.request.forEach((function(e){"function"==typeof e.runWhen&&!1===e.runWhen(t)||(r=r&&e.synchronous,n.unshift(e.fulfilled,e.rejected));}));var s,o=[];if(this.interceptors.response.forEach((function(e){o.push(e.fulfilled,e.rejected);})),!r){var a=[rC,void 0];for(Array.prototype.unshift.apply(a,n),a=a.concat(o),s=Promise.resolve(t);a.length;)s=s.then(a.shift(),a.shift());return s}for(var c=t;n.length;){var d=n.shift(),l=n.shift();try{c=d(c);}catch(e){l(e);break}}try{s=rC(c);}catch(e){return Promise.reject(e)}for(;o.length;)s=s.then(o.shift(),o.shift());return s},dC.prototype.getUri=function(e){e=sC(this.defaults,e);var t=oC(e.baseURL,e.url);return iC(t,e.params,e.paramsSerializer)},tC.forEach(["delete","get","head","options"],(function(e){dC.prototype[e]=function(t,i){return this.request(sC(i||{},{method:e,url:t,data:(i||{}).data}))};})),tC.forEach(["post","put","patch"],(function(e){function t(t){return function(i,n,r){return this.request(sC(r||{},{method:e,headers:t?{"Content-Type":"multipart/form-data"}:{},url:i,data:n}))}}dC.prototype[e]=t(),dC.prototype[e+"Form"]=t(!0);}));var lC=DS,hC=uS,uC=dC,pC=GR;var _C=function e(t){var i=new uC(t),n=hC(uC.prototype.request,i);return lC.extend(n,uC.prototype,i),lC.extend(n,i),n.create=function(i){return e(pC(t,i))},n}(OR);_C.Axios=uC,_C.CanceledError=ER(),_C.CancelToken=function(){if(zR)return JR;zR=1;var e=ER();function t(t){if("function"!=typeof t)throw new TypeError("executor must be a function.");var i;this.promise=new Promise((function(e){i=e;}));var n=this;this.promise.then((function(e){if(n._listeners){var t,i=n._listeners.length;for(t=0;t<i;t++)n._listeners[t](e);n._listeners=null;}})),this.promise.then=function(e){var t,i=new Promise((function(e){n.subscribe(e),t=e;})).then(e);return i.cancel=function(){n.unsubscribe(t);},i},t((function(t){n.reason||(n.reason=new e(t),i(n.reason));}));}return t.prototype.throwIfRequested=function(){if(this.reason)throw this.reason},t.prototype.subscribe=function(e){this.reason?e(this.reason):this._listeners?this._listeners.push(e):this._listeners=[e];},t.prototype.unsubscribe=function(e){if(this._listeners){var t=this._listeners.indexOf(e);-1!==t&&this._listeners.splice(t,1);}},t.source=function(){var e;return {token:new t((function(t){e=t;})),cancel:e}},JR=t}(),_C.isCancel=PR(),_C.VERSION=WR().version,_C.toFormData=zS(),_C.AxiosError=jS(),_C.Cancel=_C.CanceledError,_C.all=function(e){return Promise.all(e)},_C.spread=QR?XR:(QR=1,XR=function(e){return function(t){return e.apply(null,t)}}),_C.isAxiosError=function(){if($R)return ZR;$R=1;var e=DS;return ZR=function(t){return e.isObject(t)&&!0===t.isAxiosError}}(),hS.exports=_C,hS.exports.default=_C;var EC=J(hS.exports);function mC(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n);}return i}function fC(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?mC(Object(i),!0).forEach((function(t){nu(e,t,i[t]);})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):mC(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t));}));}return e}let gC,TC=0,SC=0;function RC(e,t,i,n){return new tg(((r,s)=>{t.responseType=t.responseType||"json",t.data&&!i?(t.data=JSON.stringify(t.data),TC+=LT(t.data)):i&&(t.data.size?TC+=t.data.size:t.data instanceof FormData?TC+=kT(t.data):TC+=LT(JSON.stringify(t.data))),t.headers=t.headers||{},t.headers["Content-Type"]=t.headers["Content-Type"]||"application/json",t.method="POST",t.url=e,EC.request(t).then((e=>{"string"==typeof e.data?SC+=LT(e.data):e.data instanceof ArrayBuffer||e.data instanceof Uint8Array?SC+=e.data.byteLength:SC+=LT(JSON.stringify(e.data)),n&&r({data:e.data,headers:e.headers}),r(e.data);})).catch((e=>{EC.isCancel(e)?s(new Vg(xg.OPERATION_ABORTED,"cancel token canceled")):"ECONNABORTED"===e.code?s(new Vg(xg.NETWORK_TIMEOUT,e.message)):e.response?s(new Vg(xg.NETWORK_RESPONSE_ERROR,e.response.status)):s(new Vg(xg.NETWORK_ERROR,e.message));}));}))}async function CC(e,t){const i=new Blob([t.data],{type:"buffer"});return await RC(e,fC(fC({},t),{},{data:i,headers:{"Content-Type":"application/octet-stream"}}),!0)}const vC=()=>"HTTPS"===(gC||gC||(gC=(window.location.protocol.split(":")[0]||"").toUpperCase(),gC)),IC=()=>void 0!==window.isSecureContext;function yC(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n);}return i}function AC(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?yC(Object(i),!0).forEach((function(t){nu(e,t,i[t]);})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):yC(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t));}));}return e}var bC;!function(e){e.SET_SESSION_ID="SET_SESSION_ID",e.SET_P2P_ID="SET_P2P_id",e.SET_DC_ID="SET_DC_id",e.SET_UID="SET_UID",e.SET_PUB_ID="SET_PUB_ID",e.SET_CLOUD_PROXY_SERVER_MODE="SET_CLOUD_PROXY_SERVER_MODE",e.KEY_METRIC_CLIENT_CREATED="KEY_METRIC_CLIENT_CREATED",e.KEY_METRIC_JOIN_START="KEY_METRIC_JOIN_START",e.AVOID_JOIN_START="AVOID_JOIN_START",e.KEY_METRIC_JOIN_END="KEY_METRIC_JOIN_END",e.KEY_METRIC_REQUEST_AP_START="KEY_METRIC_REQUEST_AP_START",e.KEY_METRIC_REQUEST_AP_END="KEY_METRIC_REQUEST_AP_END",e.KEY_METRIC_JOIN_GATEWAY_START="KEY_METRIC_JOIN_GATEWAY_START",e.KEY_METRIC_JOIN_GATEWAY_END="KEY_METRIC_JOIN_GATEWAY_END",e.KEY_METRIC_PEER_CONNECTION_START="KEY_METRIC_PEER_CONNECTION_START",e.KEY_METRIC_PEER_CONNECTION_END="KEY_METRIC_PEER_CONNECTION_END",e.KEY_METRIC_DESCRIPTION_START="KEY_METRIC_DESCRIPTION_START",e.KEY_METRIC_ICE_CONNECTION_END="KEY_METRIC_ICE_CONNECTION_END",e.KEY_METRIC_SIGNAL_CHANNEL_OPEN="KEY_METRIC_SIGNAL_CHANNEL_OPEN",e.KEY_METRIC_PUBLISH="KEY_METRIC_PUBLISH",e.KEY_METRIC_SUBSCRIBE="KEY_METRIC_SUBSCRIBE",e.RECORD_JOIN_CHANNEL_SERVICE="RECORD_JOIN_CHANNEL_SERVICE",e.RESET_JOIN_CHANNEL_SERVICE_RECORDS="RESET_JOIN_CHANNEL_SERVICE_RECORDS",e.RESET_KEY_METRICS="RESET_KEY_METRICS",e.SET_USE_DATACHANNEL="SET_USE_DATACHANNEL",e.SET_USE_P2P="SET_USE_P2P";}(bC||(bC={}));class wC{constructor(e,t,i,n){nu(this,"state",void 0),this.state={codec:e,audioCodec:t,mode:i,clientId:n,sessionId:null,p2pId:0,dcId:0,pubId:0,subId:0,avoidJoinStart:0,keyMetrics:{publish:[],subscribe:[]},joinChannelServiceRecords:[],cloudProxyServerMode:"disabled",useDataChannel:!1,useP2P:!1};}dispatch(e){this.state=function(e,t){switch(t.type){case bC.SET_SESSION_ID:return AC(AC({},e),{},{sessionId:t.sessionId});case bC.SET_P2P_ID:return AC(AC({},e),{},{p2pId:t.p2pId});case bC.SET_UID:return AC(AC({},e),{},{uid:t.uid});case bC.SET_PUB_ID:return AC(AC({},e),{},{pubId:t.pubId});case bC.KEY_METRIC_CLIENT_CREATED:return AC(AC({},e),{},{keyMetrics:AC(AC({},e.keyMetrics),{},{clientCreated:t.metric})});case bC.KEY_METRIC_JOIN_START:return AC(AC({},e),{},{keyMetrics:AC(AC({},e.keyMetrics),{},{joinStart:t.metric})});case bC.AVOID_JOIN_START:return AC(AC({},e),{},{avoidJoinStart:t.avoidJoinStart});case bC.KEY_METRIC_JOIN_END:return AC(AC({},e),{},{keyMetrics:AC(AC({},e.keyMetrics),{},{joinEnd:t.metric})});case bC.KEY_METRIC_REQUEST_AP_START:return AC(AC({},e),{},{keyMetrics:AC(AC({},e.keyMetrics),{},{requestAPStart:t.metric})});case bC.KEY_METRIC_REQUEST_AP_END:return AC(AC({},e),{},{keyMetrics:AC(AC({},e.keyMetrics),{},{requestAPEnd:t.metric})});case bC.KEY_METRIC_JOIN_GATEWAY_START:return AC(AC({},e),{},{keyMetrics:AC(AC({},e.keyMetrics),{},{joinGatewayStart:t.metric})});case bC.KEY_METRIC_JOIN_GATEWAY_END:return AC(AC({},e),{},{keyMetrics:AC(AC({},e.keyMetrics),{},{joinGatewayEnd:t.metric})});case bC.KEY_METRIC_PEER_CONNECTION_START:return AC(AC({},e),{},{keyMetrics:AC(AC({},e.keyMetrics),{},{peerConnectionStart:t.metric})});case bC.KEY_METRIC_PEER_CONNECTION_END:return AC(AC({},e),{},{keyMetrics:AC(AC({},e.keyMetrics),{},{peerConnectionEnd:t.metric})});case bC.KEY_METRIC_DESCRIPTION_START:return AC(AC({},e),{},{keyMetrics:AC(AC({},e.keyMetrics),{},{descriptionStart:t.metric})});case bC.KEY_METRIC_SIGNAL_CHANNEL_OPEN:return AC(AC({},e),{},{keyMetrics:AC(AC({},e.keyMetrics),{},{signalChannelOpen:t.metric})});case bC.KEY_METRIC_ICE_CONNECTION_END:return AC(AC({},e),{},{keyMetrics:AC(AC({},e.keyMetrics),{},{iceConnectionEnd:t.metric})});case bC.KEY_METRIC_PUBLISH:{const i=e.keyMetrics.publish,n=i.findIndex((e=>e.trackId===t.metric.trackId));return -1!==n?(i[n]=AC(AC({},i[n]),t.metric),AC(AC({},e),{},{keyMetrics:AC(AC({},e.keyMetrics),{},{publish:[...i]})})):AC(AC({},e),{},{keyMetrics:AC(AC({},e.keyMetrics),{},{publish:[...e.keyMetrics.publish,t.metric]})})}case bC.KEY_METRIC_SUBSCRIBE:{const i=e.keyMetrics.subscribe,n=i.findIndex((e=>e.userId===t.metric.userId&&e.type===t.metric.type));return -1!==n?(i[n]=AC(AC({},i[n]),t.metric),AC(AC({},e),{},{keyMetrics:AC(AC({},e.keyMetrics),{},{subscribe:[...i]})})):AC(AC({},e),{},{keyMetrics:AC(AC({},e.keyMetrics),{},{subscribe:[...e.keyMetrics.subscribe,t.metric]})})}case bC.SET_CLOUD_PROXY_SERVER_MODE:return e.cloudProxyServerMode=t.mode,e;case bC.RECORD_JOIN_CHANNEL_SERVICE:return "number"!=typeof t.index?e.joinChannelServiceRecords=[...e.joinChannelServiceRecords,t.record]:(e.joinChannelServiceRecords[t.index]=AC(AC({},e.joinChannelServiceRecords[t.index]),t.record),e.joinChannelServiceRecords=[...e.joinChannelServiceRecords]),e;case bC.RESET_JOIN_CHANNEL_SERVICE_RECORDS:return e.joinChannelServiceRecords=[],e;case bC.RESET_KEY_METRICS:return e.keyMetrics={publish:[],subscribe:[]},e;case bC.SET_USE_DATACHANNEL:return AC(AC({},e),{},{useDataChannel:t.val});case bC.SET_USE_P2P:return AC(AC({},e),{},{useP2P:t.val});default:return e}}(this.state,e);}set sessionId(e){this.dispatch({type:bC.SET_SESSION_ID,sessionId:e});}get sessionId(){return this.state.sessionId}set codec(e){this.state.codec=e;}get codec(){return this.state.codec}get audioCodec(){return this.state.audioCodec}get clientId(){return this.state.clientId}set p2pId(e){this.dispatch({type:bC.SET_P2P_ID,p2pId:e});}get p2pId(){return this.state.p2pId}set dcId(e){this.dispatch({type:bC.SET_DC_ID,dcId:e});}get dcId(){return this.state.dcId}set uid(e){this.dispatch({type:bC.SET_UID,uid:e});}get uid(){return this.state.uid}set pubId(e){this.dispatch({type:bC.SET_PUB_ID,pubId:e});}get pubId(){return this.state.pubId}set cloudProxyServerMode(e){this.dispatch({type:bC.SET_CLOUD_PROXY_SERVER_MODE,mode:e});}get cloudProxyServerMode(){return this.state.cloudProxyServerMode}set useDataChannel(e){this.dispatch({type:bC.SET_USE_DATACHANNEL,val:e});}get useDataChannel(){return this.state.useDataChannel}set useP2P(e){this.dispatch({type:bC.SET_USE_P2P,val:e});}get useP2P(){return this.state.useP2P}clientCreated(){this.dispatch({type:bC.KEY_METRIC_CLIENT_CREATED,metric:Date.now()});}joinStart(){this.dispatch({type:bC.KEY_METRIC_JOIN_START,metric:Date.now()});}joinEnd(){this.dispatch({type:bC.KEY_METRIC_JOIN_END,metric:Date.now()});}requestAPStart(){this.dispatch({type:bC.KEY_METRIC_REQUEST_AP_START,metric:Date.now()});}requestAPEnd(){this.dispatch({type:bC.KEY_METRIC_REQUEST_AP_END,metric:Date.now()});}joinGatewayStart(){this.dispatch({type:bC.KEY_METRIC_JOIN_GATEWAY_START,metric:Date.now()});}joinGatewayEnd(){this.dispatch({type:bC.KEY_METRIC_JOIN_GATEWAY_END,metric:Date.now()});}peerConnectionStart(){this.dispatch({type:bC.KEY_METRIC_PEER_CONNECTION_START,metric:Date.now()});}peerConnectionEnd(){this.dispatch({type:bC.KEY_METRIC_PEER_CONNECTION_END,metric:Date.now()});}descriptionStart(){this.dispatch({type:bC.KEY_METRIC_DESCRIPTION_START,metric:Date.now()});}signalChannelOpen(){this.dispatch({type:bC.KEY_METRIC_SIGNAL_CHANNEL_OPEN,metric:Date.now()});}iceConnectionEnd(){this.dispatch({type:bC.KEY_METRIC_ICE_CONNECTION_END,metric:Date.now()});}publish(e,t,i,n){this.dispatch({type:bC.KEY_METRIC_PUBLISH,metric:AC(AC({trackId:e,type:t},i&&{publishStart:i}),n&&{publishEnd:n})});}subscribe(e,t,i,n,r,s,o){this.dispatch({type:bC.KEY_METRIC_SUBSCRIBE,metric:AC(AC(AC(AC(AC({userId:e,type:t},i&&{subscribeStart:i}),n&&{subscribeEnd:n}),r&&{firstFrame:r}),s&&{streamAdded:s}),o&&{firstDecoded:o})});}massSubscribe(e,t,i,n){e.forEach((e=>{this.dispatch({type:bC.KEY_METRIC_SUBSCRIBE,metric:AC(AC(AC({userId:e.userId,type:e.type},t&&{subscribeStart:t}),i&&{subscribeEnd:i}),n&&{firstFrame:n})});}));}get keyMetrics(){return this.state.keyMetrics}recordJoinChannelService(e,t){"gateway"===e.service&&Array.isArray(e.urls)&&(e.urls=e.urls.map((e=>e.replace(/(\d+)-\d+-\d+-(\d+)/,"$1-*-*-$2"))));try{return "number"!=typeof t?(this.dispatch({type:bC.RECORD_JOIN_CHANNEL_SERVICE,record:AC(AC({},e),{},{sessionId:this.sessionId,cloudProxyMode:this.cloudProxyServerMode,uid:this.uid})}),this.state.joinChannelServiceRecords.length-1):(t<0||t>=this.state.joinChannelServiceRecords.length||this.dispatch({type:bC.RECORD_JOIN_CHANNEL_SERVICE,record:e,index:t}),t)}catch(e){return 0}}resetJoinChannelServiceRecords(){this.dispatch({type:bC.RESET_JOIN_CHANNEL_SERVICE_RECORDS});}resetKeyMetrics(){this.dispatch({type:bC.RESET_KEY_METRICS});}get joinChannelServiceRecords(){try{return this.state.joinChannelServiceRecords}catch(e){return []}}get avoidJoinStart(){return this.state.avoidJoinStart}set avoidJoinStart(e){this.dispatch({type:bC.AVOID_JOIN_START,avoidJoinStart:e});}}const OC=function(e){if(e.match(/[0-9]+\.[0-9]+\.[0-9]+$/))return e;const t=e.match(/([0-9]+\.[0-9]+\.[0-9]+)\-alpha\.([0-9]+)/);if(t&&t[1]&&t[2]){const e=t[1],i=t[2];return "".concat(e,".").concat(i)}const i=e.match(/([0-9]+\.[0-9]+\.[0-9]+)\-special\.([0-9]+)/);if(i&&i[1]&&i[2]){const e=i[1],t=i[2];return "".concat(e,".").concat(100*(Number(t)+1))}return "4.0.0.999"}("4.19.3"),NC=function(){try{return !0===JSON.parse("true")}catch(e){return !0}}(),DC="v4.19.3-0-gb2ca8ca7(11/2/2023, 2:57:33 PM)",PC={PROCESS_ID:"",ENCRYPT_AES:!0,AREAS:["CHINA","GLOBAL"],WEBCS_DOMAIN:["webrtc2-ap-web-1.agora.io","webrtc2-2.ap.sd-rtn.com"],WEBCS_DOMAIN_BACKUP_LIST:["webrtc2-ap-web-3.agora.io","webrtc2-4.ap.sd-rtn.com"],PROXY_CS:["ap-proxy-1.agora.io","ap-proxy-2.agora.io"],CDS_AP:["cds-ap-web-1.agora.io","cds-web-2.ap.sd-rtn.com","cds-ap-web-3.agora.io","cds-web-4.ap.sd-rtn.com"],ACCOUNT_REGISTER:["sua-ap-web-1.agora.io","sua-web-2.ap.sd-rtn.com","sua-ap-web-3.agora.io","sua-web-4.ap.sd-rtn.com"],UAP_AP:["uap-ap-web-1.agora.io","uap-web-2.ap.sd-rtn.com","uap-ap-web-3.agora.io","uap-web-4.ap.sd-rtn.com"],LOG_UPLOAD_SERVER:"logservice.agora.io",EVENT_REPORT_DOMAIN:"statscollector-1.agora.io",EVENT_REPORT_BACKUP_DOMAIN:"web-2.statscollector.sd-rtn.com",ENABLE_EVENT_REPORT:!0,GATEWAY_ADDRESS:[],GATEWAY_WSS_ADDRESS:"",LIVE_STREAMING_ADDRESS:"",HTTP_CONNECT_TIMEOUT:5e3,SIGNAL_REQUEST_TIMEOUT:1e4,REPORT_STATS:!0,UPLOAD_LOG:!1,NOT_REPORT_EVENT:[],SUBSCRIBE_TWCC:!1,PUBLISH_TWCC:!1,PING_PONG_TIME_OUT:10,WEBSOCKET_TIMEOUT_MIN:1e4,EVENT_REPORT_SEND_INTERVAL:3e3,CONFIG_DISTRIBUTE_INTERVAL:3e5,ENABLE_CONFIG_DISTRIBUTE:!0,CANDIDATE_TIMEOUT:5e3,SHOW_REPORT_INVOKER_LOG:!1,JOIN_EXTEND:"",PUB_EXTEND:"",SUB_EXTEND:"",FORCE_TURN:!1,TURN_ENABLE_TCP:!0,TURN_ENABLE_UDP:!0,MAX_UPLOAD_CACHE:50,UPLOAD_CACHE_INTERVAL:2e3,AJAX_REQUEST_CONCURRENT:3,REPORT_APP_SCENARIO:void 0,GATEWAY_DOMAINS:["edge.agora.io","edge.sd-rtn.com"],WORKER_DOMAIN:"edge.agora.io",TURN_DOMAIN:"edge.agora.io",EVENT_REPORT_RETRY:!0,CHROME_FORCE_PLAN_B:!1,AUDIO_SOURCE_VOLUME_UPDATE_INTERVAL:400,AUDIO_SOURCE_AVG_VOLUME_DURATION:3e3,AUDIO_VOLUME_INDICATION_INTERVAL:2e3,VOLUME_VOICE_WEIGHT:10,GET_VOLUME_OF_MUTED_AUDIO_TRACK:!1,STATS_UPDATE_INTERVAL:250,NORMAL_EVENT_QUEUE_CAPACITY:100,CUSTOM_REPORT:!0,CUSTOM_REPORT_LIMIT:20,PROXY_SERVER_TYPE2:"webnginx-proxy.agora.io",PROXY_SERVER_TYPE3:["webrtc-cloud-proxy.sd-rtn.com","webrtc-cloud-proxy.agora.io"],CUSTOM_PUB_ANSWER_MODIFIER:null,CUSTOM_SUB_ANSWER_MODIFIER:null,CUSTOM_PUB_OFFER_MODIFIER:null,CUSTOM_SUB_OFFER_MODIFIER:null,DSCP_TYPE:"high",REMOVE_NEW_CODECS:!0,FRAGEMENT_LENGTH:3,WEBSOCKET_COMPRESS:!1,SIMULCAST:!1,PRELOAD_MEDIA_COUNT:0,USE_PUB_RTX:!1,USE_SUB_RTX:!1,CHECK_VIDEO_VISIBLE_INTERVAL:3e4,CHECK_LOCAL_STATS_INTERVAL:100,PROFILE_SWITCH_INTERVAL:2e3,UNSUPPORTED_VIDEO_CODEC:[],ENUMERATE_DEVICES_INTERVAL:!1,ENUMERATE_DEVICES_INTERVAL_TIME:1e4,USE_NEW_TOKEN:!1,CLOSE_AFB_FOR_LOCAL_AP:!0,JOIN_MAX_CONCURRENCY:6,JOIN_WITH_FALLBACK_SIGNAL_PROXY:!0,JOIN_WITH_FALLBACK_MEDIA_PROXY:!0,JOIN_WITH_FALLBACK_MEDIA_PROXY_FORCE:!1,JOIN_GATEWAY_TRY_443PORT_DURATION:2e3,JOIN_GATEWAY_USE_443PORT_ONLY:!1,JOIN_GATEWAY_USE_DUAL_DOMAIN:!0,JOIN_GATEWAY_FALLBACK_PORT:443,USE_TURN_SERVER_OF_GATEWAY:!1,H264_PROFILE_LEVEL_ID:"",USE_NEW_LOG:!1,LOG_VERSION:3,MEDIA_DEVICE_CONSTRAINTS:null,ENCRYPT_PROXY_USERNAME_AND_PSW:!0,SDP_LOGGING:!1,CSP_DETECTED_HOSTNAME_LIST:["agora.io","sd-rtn.com"],REMOTE_AUDIO_TRACK_USES_WEB_AUDIO:!1,LOCAL_AUDIO_TRACK_USES_WEB_AUDIO:!0,BITRATE_ADAPTER_TYPE:"STANDARD_BITRATE",AI_DENOISER_PARAMETERS:{},ADJUST_3A_FROM_PLUGINS:!0,RAISE_H264_BASELINE_PRIORITY:!0,FILTER_SEND_H264_BASELINE:!1,ENABLE_PUBLISHED_USER_LIST:!0,MAX_SUBSCRIPTION:50,X_GOOGLE_START_BITRATE:void 0,NEW_REPORT_SERVER:!1,NEW_REPORT_SERVER_DOMAINS:["data-reporting.agora.io","data-reporting.agora.io"],VIDEO_INSPECT_WORKER_MESSAGE_LENGTH_LIMIT:3e5,VIDEO_INSPECT_INTERVAL_MINIMUM:1e3,VIDEO_INSPECT_QUALITY_RATIO:.9,VIDEO_INSPECT_WORKER_MANAGER_HOST:"edge.agora.io",VIDEO_INSPECT_WORKER_MANAGER_PORT:"",VIDEO_INSPECT_WORKER_PORT:"",SHOW_VIDEO_INSPECT_WORKER_MESSAGE:!1,STATS_COLLECTOR_PORT:443,FORCE_TURN_TCP:!1,SUBSCRIBE_AUDIO_FILTER_TOPN:void 0,ENABLE_PUBLISH_AUDIO_FILTER:void 0,DISABLE_FEC:void 0,WEBAUDIO_INIT_OPTIONS:void 0,FILTER_VIDEO_FEC:!0,FILTER_AUDIO_FEC:!1,CHROME_DUAL_STREAM_USE_ENCODING:!0,DISABLE_DUAL_STREAM_USE_ENCODING:!1,EXTENSION_USAGE_UPLOAD_INTERVAL:1e4,ICE_RESTART:!0,ICE_RESTART_INTERVAL:1e4,NEW_ICE_RESTART:!1,ENABLE_USER_LICENSE_CHECK:!0,SIGNAL_CHANNEL:0,TRANSMITTER_INITIAL_RTT:30,TRANSMITTER_INITIAL_RTO:30,TRANSMITTER_MAX_BATCH_ACK_COUNT:2,TRANSMITTER_MAX_RTO:500,DATACHANNEL_COMPRESS:!1,FINGERPRINT:null,DC_JOIN_WITH_FAILBACK:5e3,ENABLE_VIDEO_FRAME_CALLBACK:!0,VIDEO_FREEZE_DURATION:500,SPATIALIZER_PARAMETERS:{},UPLOAD_LOG_INTERVAL:3e3,UPLOAD_LOG_REQUEST_RETRY_INTERVAL:2e3,UPLOAD_LOG_REQUEST_MAX_RETRY_INTERVAL:2e4,UPLOAD_LOG_TRY_INTERVAL_WHILE_OFF:5e3,UPLOAD_LOG_RETRY_INTERVAL_V1:1e4,UPLOAD_LOG_TWICE_RETRY_INTERVAL_V1:200,UPLOAD_LOG_LENGTH_EACH_TIME:10,APP_TYPE:0,DISABLE_WEBAUDIO:!1,CHANNEL_MEDIA_RELAY_SERVERS:void 0,KEEP_LAST_FRAME:!0,FORWARD_P2P_CREATION:!0,SYNC_GROUP:!0,BLOCK_LOCAL_CLIENT:!1,AP_AREA:!0,SVC:[],ENABLE_ENCODED_TRANSFORM:!1,IMAGE_MODERATION_WORKER_HOST:"edge.agora.io",IMAGE_MODERATION_WORKER_MESSAGE_LENGTH_LIMIT:3e5,IMAGE_MODERATION_INTERVAL_MINIMUM:1e3,SHOW_IMAGE_MODERATION_WORKER_MESSAGE:!1,IMAGE_MODERATION_QUALITY_RATIO:.9,IMAGE_MODERATION_UPLOAD_REPORT_INTERVAL:5e3,SHOW_GLOBAL_CLIENT_LIST:!1,RTM2_FLAG:void 0,AP_RTM:!1,ENABLE_DATASTREAM_2:!1,DATASTREAM_MAX_RETRANSMITS:10,ENABLE_USER_AUTO_REBALANCE_CHECK:!0,ENABLE_INSTANT_VIDEO:!1,ENABLE_NTP_REPORT:!1,USE_XR:!1,TCP_CANDIDATE_ONLY:!1,EXTERNAL_SIGNAL_REQUEST_TIMEOUT:1e4,P2P:!1,SHOW_P2P_LOG:!1,ACCOUNT_REGISTER_RETRY_TIMEOUT:1,ACCOUNT_REGISTER_RETRY_RATIO:2,ACCOUNT_REGISTER_RETRY_TIMEOUT_MAX:6e4,ACCOUNT_REGISTER_RETRY_COUNT_MAX:1e5,AUDIO_CONTEXT:null,WEBCS_BACKUP_CONNECT_TIMEOUT:6e3,PLAYER_STATE_DEFER:2e3,SIGNAL_REQUEST_WATCH_INTERVAL:1e3,FILEPATH_LENMAX:255,DUALSTREAM_OPERATION_CHECK:!0,MEDIA_ELEMENT_EXISTS_DEPTH:3,SHIM_CANDIDATE:!1,LEAVE_MSG_TIMEOUT:2e3,STATS_FILTER:{transportId:!0,googTrackId:!0},FILTER_VIDEO_CODEC:[]};function LC(e,t,i){var n,r;Pr(n=Object.keys(PC)).call(n,e)&&(!i&&Pr(r=Object.keys(MC)).call(r,e)||(PC[e]=t));}function kC(e){return PC[e]}const MC={};var UC,xC;!function(e){e.h264="h264",e.h265="h265",e.vp8="vp8",e.vp9="vp9",e.av1="av1";}(UC||(UC={})),function(e){e.opus="opus",e.pcma="pcma",e.pcmu="pcmu",e.g722="g722";}(xC||(xC={}));const VC=new class extends iT{reportLogUploadError(e){this.emit("REPORT_LOG_UPLOAD",e);}};class FC{constructor(e){nu(this,"logger",void 0),nu(this,"prefixLists",[]),this.logger=e;}debug(){for(var e=arguments.length,t=new Array(e),i=0;i<e;i++)t[i]=arguments[i];this.logger.debug(...this.prefixLists,...t);}info(){for(var e=arguments.length,t=new Array(e),i=0;i<e;i++)t[i]=arguments[i];this.logger.info(...this.prefixLists,...t);}warning(){for(var e=arguments.length,t=new Array(e),i=0;i<e;i++)t[i]=arguments[i];this.logger.warning(...this.prefixLists,...t);}error(){for(var e=arguments.length,t=new Array(e),i=0;i<e;i++)t[i]=arguments[i];this.logger.error(...this.prefixLists,...t);}prefix(e){return this.prefixLists.push(e),this}popPrefix(){return this.prefixLists.pop(),this}}function BC(){const e=new Date;return e.toTimeString().split(" ")[0]+":"+e.getMilliseconds()}function jC(){const e=new Date,t=/((\d+:){2}\d+)/.exec((new Date).toUTCString());return t?(null==t?void 0:t[0])+":"+e.getUTCMilliseconds():e.toTimeString().split(" ")[0]+":"+e.getMilliseconds()}const GC={DEBUG:0,INFO:1,WARNING:2,ERROR:3,NONE:4},WC=Date.now(),HC=e=>{for(const t in GC)if(Object.prototype.hasOwnProperty.call(GC,t)&&GC[t]===e)return t;return "DEFAULT"};const KC=new class{constructor(){nu(this,"proxyServerURL",void 0),nu(this,"logLevel",GC.DEBUG),nu(this,"uploadState","collecting"),nu(this,"uploadLogWaitingList",[]),nu(this,"uploadLogUploadingList",[]),nu(this,"uploadErrorCount",0),nu(this,"currentLogID",0),nu(this,"url",void 0),nu(this,"extLog",((e,t)=>{this.appendLogToWaitingList(e,...t);}));}debug(){for(var e=arguments.length,t=new Array(e),i=0;i<e;i++)t[i]=arguments[i];const n=[GC.DEBUG].concat(t);this.log.apply(this,n);}info(){for(var e=arguments.length,t=new Array(e),i=0;i<e;i++)t[i]=arguments[i];const n=[GC.INFO].concat(t);this.log.apply(this,n);}warning(){for(var e=arguments.length,t=new Array(e),i=0;i<e;i++)t[i]=arguments[i];const n=[GC.WARNING].concat(t);this.log.apply(this,n);}warn(){this.warning(...arguments);}error(){for(var e=arguments.length,t=new Array(e),i=0;i<e;i++)t[i]=arguments[i];const n=[GC.ERROR].concat(t);this.log.apply(this,n);}upload(){for(var e=arguments.length,t=new Array(e),i=0;i<e;i++)t[i]=arguments[i];const n=[GC.DEBUG].concat(t);this.uploadLog.apply(this,n);}setLogLevel(e){e=Math.min(Math.max(0,e),4),this.logLevel=e;}enableLogUpload(){LC("UPLOAD_LOG",!0);}disableLogUpload(){LC("UPLOAD_LOG",!1),this.uploadLogUploadingList=[],this.uploadLogWaitingList=[];}setProxyServer(e){this.proxyServerURL=e;}prefix(e){return new FC(this).prefix(e)}log(){for(var e=arguments.length,t=new Array(e),i=0;i<e;i++)t[i]=arguments[i];if(Date.now()-WC<100)return void setTimeout((()=>{this.log(...t);}),Date.now()-WC);const n=Math.max(0,Math.min(4,t[0]));if(t[0]=BC()+" Agora-SDK [".concat(HC(n),"]:"),this.appendLogToWaitingList(n,...t),n<this.logLevel)return;const r=BC()+" %cAgora-SDK [".concat(HC(n),"]:");let s=[];if(!kC("USE_NEW_LOG"))switch(n){case GC.DEBUG:s=[r,"color: #64B5F6;"].concat(t.slice(1)),console.log.apply(console,s);break;case GC.INFO:s=[r,"color: #1E88E5; font-weight: bold;"].concat(t.slice(1)),console.log.apply(console,s);break;case GC.WARNING:s=[r,"color: #FB8C00; font-weight: bold;"].concat(t.slice(1)),console.warn.apply(console,s);break;case GC.ERROR:s=[r,"color: #B00020; font-weight: bold;"].concat(t.slice(1)),console.error.apply(console,s);}}uploadLog(){for(var e=arguments.length,t=new Array(e),i=0;i<e;i++)t[i]=arguments[i];if(Date.now()-WC<100)return void setTimeout((()=>{this.uploadLog(...t);}),Date.now()-WC);const n=Math.max(0,Math.min(4,t[0]));t[0]=BC()+" Agora-SDK [".concat(HC(n),"]:"),this.appendLogToWaitingList(n,...t);}appendLogToWaitingList(e){if(!kC("UPLOAD_LOG"))return;for(var t=arguments.length,i=new Array(t>1?t-1:0),n=1;n<t;n++)i[n-1]=arguments[n];Array.isArray(i[0])?i[0][0]=jC()+" Agora-SDK [".concat(HC(e),"]:"):i[0]=jC()+" Agora-SDK [".concat(HC(e),"]:");let r="";i.forEach((e=>{"object"==typeof e&&(e=JSON.stringify(e)),r+="".concat(e," ");})),this.uploadLogWaitingList.push({payload_str:r,log_level:e,log_item_id:this.currentLogID++}),"uploading"===this.uploadState&&0===this.uploadLogUploadingList.length&&this.uploadLogInterval();}startUpload(){this.uploadState="uploading",0===this.uploadLogUploadingList.length&&this.uploadLogInterval();}async uploadLogs(){const e=this.uploadLogUploadingList,t={sdk_version:OC,process_id:kC("PROCESS_ID"),payload:JSON.stringify(e)};return XT((async()=>{const e=await EC.post(this.url||(this.proxyServerURL?"https://".concat(this.proxyServerURL,"/ls/?h=").concat(kC("LOG_UPLOAD_SERVER"),"&p=443&d=upload/v1"):"https://".concat(kC("LOG_UPLOAD_SERVER"),"/upload/v1")),t,{responseType:"text"});if("OK"!==e.data){const t=new Error("unexpected upload log response");throw t.response=e,t}}),(()=>(this.uploadLogUploadingList=[],!1)),(e=>(e.response?VC.reportLogUploadError({status:e.response.status,data:e.response.data,headers:e.response.headers,message:e.message}):e.request?VC.reportLogUploadError({status:e.request.status,message:e.message}):VC.reportLogUploadError({status:-1,message:e.message}),!0)),{timeout:kC("UPLOAD_LOG_REQUEST_RETRY_INTERVAL"),maxRetryTimeout:kC("UPLOAD_LOG_REQUEST_MAX_RETRY_INTERVAL")})}uploadLogInterval(){0===this.uploadLogUploadingList.length&&0===this.uploadLogWaitingList.length||(0===this.uploadLogUploadingList.length&&(this.uploadLogUploadingList=this.uploadLogWaitingList.splice(0,kC("UPLOAD_LOG_LENGTH_EACH_TIME"))),this.uploadLogs().then((()=>{this.uploadErrorCount=0,this.uploadLogWaitingList.length>0&&window.setTimeout((()=>this.uploadLogInterval()),kC("UPLOAD_LOG_INTERVAL"));})).catch((e=>{this.uploadErrorCount+=1,this.uploadErrorCount<2?window.setTimeout((()=>this.uploadLogInterval()),kC("UPLOAD_LOG_TWICE_RETRY_INTERVAL_V1")):window.setTimeout((()=>this.uploadLogInterval()),kC("UPLOAD_LOG_RETRY_INTERVAL_V1"));})));}};var YC,qC;function JC(e){return Wg(e.reportId,"params.reportId",0,100,!1),Wg(e.category,"params.category",0,100,!1),Wg(e.event,"params.event",0,100,!1),Wg(e.label,"params.label",0,100,!1),jg(e.value,"params.value",Number.MIN_SAFE_INTEGER,Number.MAX_SAFE_INTEGER,!1),!0}!function(e){e.FREE="free",e.UPLOADING="uploading";}(YC||(YC={})),function(e){e[e.MISC=0]="MISC",e[e.INTERNAL_EVENT=1]="INTERNAL_EVENT",e[e.PUBLIC_EVENT=2]="PUBLIC_EVENT",e[e.WEB_EVENT=3]="WEB_EVENT",e[e.INTERNAL_API=4]="INTERNAL_API",e[e.WEB_API=5]="WEB_API",e[e.PUBLIC_API=6]="PUBLIC_API";}(qC||(qC={}));const zC={sid:"",lts:0,success:null,cname:null,uid:null,peer:null,cid:null,elapse:null,extend:null,vid:0};var XC,QC,ZC,$C;function ev(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n);}return i}function tv(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?ev(Object(i),!0).forEach((function(t){nu(e,t,i[t]);})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):ev(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t));}));}return e}!function(e){e.PUBLISH="publish",e.SUBSCRIBE="subscribe",e.WS_COMPRESSOR_INIT="ws_compressor_init",e.SESSION_INIT="session_init",e.JOIN_CHOOSE_SERVER="join_choose_server",e.REQ_USER_ACCOUNT="req_user_account",e.JOIN_GATEWAY="join_gateway",e.REJOIN_GATEWAY="rejoin_gateway",e.STREAM_SWITCH="stream_switch",e.REQUEST_PROXY_WORKER_MANAGER="request_proxy_worker_manager",e.REQUEST_PROXY_APPCENTER="request_proxy_appcenter",e.FIRST_VIDEO_RECEIVED="first_video_received",e.FIRST_AUDIO_RECEIVED="first_audio_received",e.FIRST_VIDEO_DECODE="first_video_decode",e.FIRST_AUDIO_DECODE="first_audio_decode",e.ON_ADD_AUDIO_STREAM="on_add_audio_stream",e.ON_ADD_VIDEO_STREAM="on_add_video_stream",e.ON_UPDATE_STREAM="on_update_stream",e.ON_REMOVE_STREAM="on_remove_stream",e.USER_ANALYTICS="req_user_analytics",e.PC_STATS="pc_stats";}(XC||(XC={})),function(e){e.SESSION="io.agora.pb.Wrtc.Session",e.JOIN_CHOOSE_SERVER="io.agora.pb.Wrtc.JoinChooseServer",e.REQ_USER_ACCOUNT="io.agora.pb.Wrtc.ReqUserAccount",e.JOIN_GATEWAY="io.agora.pb.Wrtc.JoinGateway",e.RE_JOIN_GATEWAY="io.agora.pb.Wrtc.ReJoinGateway",e.PUBLISH="io.agora.pb.Wrtc.Publish",e.SUBSCRIBE="io.agora.pb.Wrtc.Subscribe",e.WS_COMPRESSOR_INIT="io.agora.pb.Wrtc.WsCompressorInit",e.STREAM_SWITCH="io.agora.pb.Wrtc.StreamSwitch",e.AUDIO_SENDING_STOPPED="io.agora.pb.Wrtc.AudioSendingStopped",e.VIDEO_SENDING_STOPPED="io.agora.pb.Wrtc.VideoSendingStopped",e.REQUEST_PROXY_APPCENTER="io.agora.pb.Wrtc.RequestProxyAppCenter",e.REQUEST_PROXY_WORKER_MANAGER="io.agora.pb.Wrtc.RequestProxyWorkerManager",e.API_INVOKE="io.agora.pb.Wrtc.ApiInvoke",e.FIRST_VIDEO_RECEIVED="io.agora.pb.Wrtc.FirstVideoReceived",e.FIRST_AUDIO_RECEIVED="io.agora.pb.Wrtc.FirstAudioReceived",e.FIRST_VIDEO_DECODE="io.agora.pb.Wrtc.FirstVideoDecode",e.FIRST_AUDIO_DECODE="io.agora.pb.Wrtc.FirstAudioDecode",e.ON_ADD_AUDIO_STREAM="io.agora.pb.Wrtc.OnAddAudioStream",e.ON_ADD_VIDEO_STREAM="io.agora.pb.Wrtc.OnAddVideoStream",e.ON_UPDATE_STREAM="io.agora.pb.Wrtc.OnUpdateStream",e.ON_REMOVE_STREAM="io.agora.pb.Wrtc.OnRemoveStream",e.JOIN_CHANNEL_TIMEOUT="io.agora.pb.Wrtc.JoinChannelTimeout",e.PEER_PUBLISH_STATUS="io.agora.pb.Wrtc.PeerPublishStatus",e.WORKER_EVENT="io.agora.pb.Wrtc.WorkerEvent",e.AP_WORKER_EVENT="io.agora.pb.Wrtc.APWorkerEvent",e.JOIN_WEB_PROXY_AP="io.agora.pb.Wrtc.JoinWebProxyAP",e.WEBSOCKET_QUIT="io.agora.pb.Wrtc.WebSocketQuit",e.USER_ANALYTICS="io.agora.pb.Wrtc.UserAnalytics",e.AUTOPLAY_FAILED="io.agora.pb.Wrtc.AutoplayFailed",e.PC_STATS="io.agora.pb.Wrtc.PCStats";}(QC||(QC={})),function(e){e[e.WORKER_EVENT=156]="WORKER_EVENT",e[e.AP_WORKER_EVENT=160]="AP_WORKER_EVENT";}(ZC||(ZC={})),function(e){e[e.SESSION=26]="SESSION",e[e.JOIN_CHOOSE_SERVER=27]="JOIN_CHOOSE_SERVER",e[e.REQ_USER_ACCOUNT=196]="REQ_USER_ACCOUNT",e[e.JOIN_GATEWAY=28]="JOIN_GATEWAY",e[e.PUBLISH=30]="PUBLISH",e[e.SUBSCRIBE=29]="SUBSCRIBE",e[e.WS_COMPRESSOR_INIT=9430]="WS_COMPRESSOR_INIT",e[e.STREAM_SWITCH=32]="STREAM_SWITCH",e[e.AUDIO_SENDING_STOPPED=33]="AUDIO_SENDING_STOPPED",e[e.VIDEO_SENDING_STOPPED=34]="VIDEO_SENDING_STOPPED",e[e.REQUEST_PROXY_APPCENTER=35]="REQUEST_PROXY_APPCENTER",e[e.REQUEST_PROXY_WORKER_MANAGER=36]="REQUEST_PROXY_WORKER_MANAGER",e[e.API_INVOKE=41]="API_INVOKE",e[e.FIRST_VIDEO_RECEIVED=348]="FIRST_VIDEO_RECEIVED",e[e.FIRST_AUDIO_RECEIVED=349]="FIRST_AUDIO_RECEIVED",e[e.FIRST_VIDEO_DECODE=350]="FIRST_VIDEO_DECODE",e[e.FIRST_AUDIO_DECODE=351]="FIRST_AUDIO_DECODE",e[e.ON_ADD_AUDIO_STREAM=352]="ON_ADD_AUDIO_STREAM",e[e.ON_ADD_VIDEO_STREAM=353]="ON_ADD_VIDEO_STREAM",e[e.ON_UPDATE_STREAM=356]="ON_UPDATE_STREAM",e[e.ON_REMOVE_STREAM=355]="ON_REMOVE_STREAM",e[e.JOIN_CHANNEL_TIMEOUT=407]="JOIN_CHANNEL_TIMEOUT",e[e.PEER_PUBLISH_STATUS=408]="PEER_PUBLISH_STATUS",e[e.WORKER_EVENT=156]="WORKER_EVENT",e[e.AP_WORKER_EVENT=160]="AP_WORKER_EVENT",e[e.JOIN_WEB_PROXY_AP=700]="JOIN_WEB_PROXY_AP",e[e.WEBSOCKET_QUIT=671]="WEBSOCKET_QUIT",e[e.USER_ANALYTICS=1e4]="USER_ANALYTICS",e[e.AUTOPLAY_FAILED=9178]="AUTOPLAY_FAILED";}($C||($C={}));class iv{constructor(){nu(this,"baseInfoMap",new Map),nu(this,"proxyServer",void 0),nu(this,"eventUploadTimer",void 0),nu(this,"setSessionIdTimer",void 0),nu(this,"url",void 0),nu(this,"backupUrl",void 0),nu(this,"_appId",void 0),nu(this,"keyEventUploadPendingItems",[]),nu(this,"normalEventUploadPendingItems",[]),nu(this,"apiInvokeUploadPendingItems",[]),nu(this,"apiInvokeCount",0),nu(this,"ltsList",[]),nu(this,"lastSendNormalEventTime",Date.now()),nu(this,"customReportCounterTimer",void 0),nu(this,"customReportCount",0),nu(this,"extApiInvoke",(async e=>{for(const t of e){const e=tv(tv({},t),{},{sid:null,invokeId:++this.apiInvokeCount,tag:oT.TRACER});this.sendApiInvoke(e);}})),this.eventUploadTimer=window.setInterval(this.doSend.bind(this),kC("EVENT_REPORT_SEND_INTERVAL")),this.setSessionIdTimer=window.setInterval(this.appendSessionId.bind(this),kC("EVENT_REPORT_SEND_INTERVAL"));}getBaseInfoBySessionId(e){return this.baseInfoMap.get(e)}adjustSessionStartTime(e){if(!this.baseInfoMap.has(e)&&!this.baseInfoMap.get(e))return void KC.error("adjust session ".concat(e," start time, sid is not exist or info is undefined"));const t=this.baseInfoMap.get(e),i=Date.now(),n=t.startTime;t.startTime=i,KC.debug("rewrite session ".concat(e," startTime: ").concat(i," , ").concat(i-n,"ms")),this.baseInfoMap.set(e,t);}setAppId(e){this._appId=e;}reportApiInvoke(e,t,i){t.timeout=t.timeout||6e4,t.reportResult=void 0===t.reportResult||t.reportResult;const n=Date.now();this.apiInvokeCount+=1;const r=this.apiInvokeCount,s=()=>({tag:t.tag,invokeId:r,sid:e,name:t.name,apiInvokeTime:n,options:t.options,states:t.states||null}),o=!!kC("SHOW_REPORT_INVOKER_LOG");o&&KC.info("".concat(t.name," start"),t.options);let a=!1;UT(t.timeout).then((()=>{a||(this.sendApiInvoke(tv(tv({},s()),{},{error:xg.API_INVOKE_TIMEOUT,success:!1})),KC.debug("".concat(t.name," timeout")));}));const c=new Vg(xg.UNEXPECTED_ERROR,"".concat(t.name,": this api invoke is end"));return {onSuccess:e=>{const n=()=>{if(a)throw c;return a=!0,this.sendApiInvoke(tv(tv({},s()),{},{success:!0},t.reportResult&&{result:e})),o&&KC.info("".concat(t.name," onSuccess")),e};return i?jT(n,t.name+"Success",i,(()=>a=!0)):n()},onError:e=>{const n=()=>{if(a)throw e;a=!0,this.sendApiInvoke(tv(tv({},s()),{},{success:!1,error:e})),o&&KC.info("".concat(t.name," onFailure"),e.toString());};return i?jT(n,t.name+"Error",i,(()=>a=!0)):n()}}}sessionInit(e,t){if(this.baseInfoMap.has(e))return;const i=Date.now(),n=this.createBaseInfo(e,i);n.cname=t.cname;const r=Object.assign({},{willUploadConsoleLog:kC("UPLOAD_LOG"),maxTouchPoints:navigator.maxTouchPoints,areaVersion:NC?"global":"oversea",areas:kC("AREAS")&&kC("AREAS").join(",")},t.extend),s=Date.now(),o=tv(tv({},n),{},{eventType:XC.SESSION_INIT,appid:t.appid,browser:navigator.userAgent,build:DC,lts:s,elapse:s-i,extend:JSON.stringify(r),mode:t.mode,process:kC("PROCESS_ID"),appType:kC("APP_TYPE"),success:!0,version:OC});this.send({type:QC.SESSION,data:o},!0);}joinChooseServer(e,t){const i=this.baseInfoMap.get(e);if(!i)return;const n=i.info,r=Date.now(),s=tv(tv({},n),{},{eventType:XC.JOIN_CHOOSE_SERVER,lts:r,eventElapse:r-t.lts,chooseServerAddr:t.csAddr,errorCode:t.ec,elapse:r-i.startTime,success:t.succ,chooseServerAddrList:JSON.stringify(t.serverList),uid:t.uid?parseInt(t.uid):null,cid:t.cid?parseInt(t.cid):null,chooseServerIp:t.csIp||"",opid:t.opid,unilbsServerIds:t.unilbsServerIds,extend:t.extend||void 0,isHttp3:t.isHttp3});this.send({type:QC.JOIN_CHOOSE_SERVER,data:s},!0);}reqUserAccount(e,t){const i=this.baseInfoMap.get(e);if(!i)return;const n=i.info,r=Date.now(),s=tv(tv({},n),{},{eventType:XC.REQ_USER_ACCOUNT,lts:r,success:t.success,serverAddress:t.serverAddr,stringUid:t.stringUid,uid:t.uid,errorCode:t.errorCode,elapse:r-i.startTime,eventElapse:r-t.lts,extend:JSON.stringify(t.extend)});this.send({type:QC.REQ_USER_ACCOUNT,data:s},!0);}joinGateway(e,t){const i=this.baseInfoMap.get(e);if(!i)return;const n=i.info;t.vid&&(n.vid=t.vid),n.uid=t.uid,n.cid=t.cid;const r=Date.now(),{firstSuccess:s,avoidJoinStartTime:o,isProxy:a,addr:c}=t,d=r-(s&&o?o:i.startTime),l=tv(tv({},n),{},{eventType:XC.JOIN_GATEWAY,lts:r,gatewayAddr:t.addr,success:t.succ,errorCode:t.ec,elapse:d,eventElapse:r-t.lts,firstSuccess:s,signalChannel:t.signalChannel}),h=l.success?1:0;if(t.succ&&(i.lastJoinSuccessTime=r),s)this.send({type:QC.JOIN_GATEWAY,data:l},!0);else {let e;if(c)if(a){const t=c.match(/h=(\d{1,3}-){3}\d{1,3}/g),i=c.match(/p=[0-9]{1,6}/g);e={isSuccess:h,gatewayIp:t&&t.length?t[0].split("=")[1].replace(/-/g,"."):"",port:i&&i.length?i[0].split("=")[1]:"",isProxy:a?1:0};}else {const t=c.match(/wss:\/\/(\d{1,3}-){3}\d{1,3}/g),i=c.match(/(:|p=)[0-9]{1,6}/g);e={isSuccess:h,gatewayIp:t&&t.length?t[0].split("//")[1].replace(/-/g,"."):"",port:i&&i.length?i[0].split(/:|p=/g)[1]:"",isProxy:a?1:0};}else e={isSuccess:h,gatewayIp:"",port:"",isProxy:a?1:0};delete l.success,delete l.eventType,delete l.firstSuccess,l.vid=Number(l.vid);const t=Object.assign({},l,e,{eventType:XC.REJOIN_GATEWAY});this.send({type:QC.RE_JOIN_GATEWAY,data:t},!0);}}joinChannelTimeout(e,t){const i=this.baseInfoMap.get(e);if(!i)return;const n=Date.now(),r=tv(tv({},i.info),{},{lts:n,timeout:t,elapse:n-i.startTime});this.send({type:QC.JOIN_CHANNEL_TIMEOUT,data:r},!0);}publish(e,t){const i=this.baseInfoMap.get(e);if(!i)return;const n=i.info,r=Date.now(),s=tv(tv({},n),{},{eventType:XC.PUBLISH,lts:r,eventElapse:t.eventElapse,elapse:r-i.startTime,success:t.succ,errorCode:t.ec,videoName:t.videoName,audioName:t.audioName,screenName:t.screenName,screenshare:t.screenshare,audio:t.audio,video:t.video,p2pid:t.p2pid,publishRequestid:t.publishRequestid});this.send({type:QC.PUBLISH,data:s},!0);}subscribe(e,t,i){const n=this.baseInfoMap.get(e);if(!n)return;const r=n.info,s=Date.now(),o=tv(tv({},r),{},{eventType:XC.SUBSCRIBE,lts:s,eventElapse:t.eventElapse,elapse:s-n.startTime,success:t.succ,errorCode:t.ec,video:t.video,audio:t.audio,subscribeRequestid:t.subscribeRequestid,p2pid:t.p2pid},i&&{extend:JSON.stringify({isMassSubscribe:!0})});"string"==typeof t.peerid?o.peerSuid=t.peerid:o.peer=t.peerid,this.send({type:QC.SUBSCRIBE,data:o},!0);}wsCompressorInit(e){var t;const i=[...hu(t=this.baseInfoMap).call(t)],n=i.length?i[0]:"UnableToGetSid",r=this.baseInfoMap.get(n);if(!r)return;const s=r.info,o=Date.now(),a=tv(tv({},s),{},{eventType:XC.WS_COMPRESSOR_INIT,lts:o,eventElapse:e.eventElapse,elapse:o-r.startTime,status:e.status?1:2});this.send({type:QC.WS_COMPRESSOR_INIT,data:a},!0);}firstRemoteVideoDecode(e,t,i,n){const r=this.baseInfoMap.get(e);if(!r)return;const s=r.info,o=Date.now(),a=tv(tv(tv({},s),n),{},{elapse:o-r.startTime,eventType:t,lts:o,firstDecodeFrame:Math.max(o-r.startTime,0),apEnd:Math.max(n.apEnd-r.startTime,0),apStart:Math.max(n.apStart-r.startTime,0),joinGwEnd:Math.max(n.joinGwEnd-r.startTime,0),joinGwStart:Math.max(n.joinGwStart-r.startTime,0),pcEnd:Math.max(n.pcEnd-r.startTime,0),pcStart:Math.max(n.pcStart-r.startTime,0),subscriberEnd:Math.max(n.subscriberEnd-r.startTime,0),subscriberStart:Math.max(n.subscriberStart-r.startTime,0),videoAddNotify:Math.max(n.videoAddNotify-r.startTime,0)});this.send({type:i,data:a},!0);}firstRemoteFrame(e,t,i,n){const r=this.baseInfoMap.get(e);if(!r)return;const s=r.info,o=Date.now(),a=tv(tv(tv({},s),n),{},{elapse:o-r.startTime,eventType:t,lts:o});this.send({type:i,data:a},!0);}pcStats(e,t){const i=this.baseInfoMap.get(e);if(!i)return;const n=i.info,r=Date.now(),s=tv(tv(tv({},n),t),{},{vid:void 0===n.vid?0:Number(n.vid),elapse:r-i.startTime,eventType:XC.PC_STATS,lts:r});this.send({type:QC.PC_STATS,data:s},!0);}updateRemoteRTPCapabilities(e,t){this.reportApiInvoke(e,{name:"Client.updateRemoteRTPCapabilities",options:t,tag:oT.TRACER}).onSuccess();}onGatewayStream(e,t,i,n){const r=this.baseInfoMap.get(e);if(!r)return;const s=r.info,o=Date.now(),a=tv(tv(tv({},s),n),{},{eventType:t,lts:o});this.send({type:i,data:a},!0);}streamSwitch(e,t){const i=this.baseInfoMap.get(e);if(!i)return;const n=i.info,r=Date.now(),s=tv(tv({},n),{},{eventType:XC.STREAM_SWITCH,lts:r,isDual:t.isdual,elapse:r-i.startTime,success:t.succ});this.send({type:QC.STREAM_SWITCH,data:s},!0);}requestProxyAppCenter(e,t){const i=this.baseInfoMap.get(e);if(!i)return;const n=i.info,r=Date.now(),s=tv(tv({},n),{},{eventType:XC.REQUEST_PROXY_APPCENTER,lts:r,eventElapse:r-t.lts,elapse:r-i.startTime,APAddr:t.APAddr,workerManagerList:t.workerManagerList,response:t.response,errorCode:t.ec,success:t.succ});this.send({type:QC.REQUEST_PROXY_APPCENTER,data:s},!0);}requestProxyWorkerManager(e,t){const i=this.baseInfoMap.get(e);if(!i)return;const n=i.info,r=Date.now(),s=tv(tv({},n),{},{eventType:XC.REQUEST_PROXY_WORKER_MANAGER,lts:r,eventElapse:r-t.lts,elapse:r-i.startTime,workerManagerAddr:t.workerManagerAddr,response:t.response,errorCode:t.ec,success:t.succ});this.send({type:QC.REQUEST_PROXY_WORKER_MANAGER,data:s},!0);}setProxyServer(e){this.proxyServer=e,e?KC.debug("reportProxyServerurl: ".concat(e)):KC.debug("disable reportProxyServerurl: ".concat(e));}peerPublishStatus(e,t){const i=this.baseInfoMap.get(e);if(!i)return;const n=i.info,r=Date.now(),s=tv(tv({},n),{},{subscribeElapse:t.subscribeElapse,peer:t.peer,peerPublishDuration:Math.max(t.audioPublishDuration,t.videoPublishDuration),audiotag:t.audioPublishDuration>0?1:-1,videotag:t.videoPublishDuration>0?1:-1,lts:r,elapse:r-i.startTime,joinChannelSuccessElapse:r-(i.lastJoinSuccessTime||r),peerPublishDurationVideo:t.videoPublishDuration,peerPublishDurationAudio:t.audioPublishDuration});this.send({type:QC.PEER_PUBLISH_STATUS,data:s},!0);}workerEvent(e,t){const i=this.baseInfoMap.get(e);if(!i)return;const n=i.info,r=Date.now(),s=function(e,t,i){const n=e[t];if(!n||"string"!=typeof n)return [e];e[t]="";const r=LT(JSON.stringify(e));let s=0;const o=[];let a=0;for(let c=0;c<n.length;c++)a+=n.charCodeAt(c)<=127?1:3,a<=i-r||(o[o.length]=vT(vT({},e),{},{[t]:n.substring(s,c)}),s=c,a=n.charCodeAt(c)<=127?1:3);return s!==n.length-1&&(o[o.length]=vT(vT({},e),{},{[t]:n.substring(s)})),o}(tv(tv(tv({},n),t),{},{elapse:r-i.startTime,lts:r,productType:"WebRTC"}),"payload",1300);s.forEach((e=>this.send({type:QC.WORKER_EVENT,data:e},!0)));}apworkerEvent(e,t){const i=this.baseInfoMap.get(e);if(!i)return;const n=i.info,r=Date.now(),s=tv(tv(tv({},n),t),{},{elapse:r-i.startTime,lts:r});this.send({type:QC.AP_WORKER_EVENT,data:s},!0);}joinWebProxyAP(e,t){const i=this.baseInfoMap.get(e);if(!i)return;const n=i.info,r=Date.now(),s=tv(tv(tv({},n),t),{},{elapse:r-i.startTime,lts:r,extend:t.extend||void 0});this.send({type:QC.JOIN_WEB_PROXY_AP,data:s},!0);}WebSocketQuit(e,t){const i=this.baseInfoMap.get(e);if(!i)return;const n=i.info,r=Date.now(),s=tv(tv(tv({},n),t),{},{elapse:r-i.startTime,lts:r});this.send({type:QC.WEBSOCKET_QUIT,data:s},!0);}async sendCustomReportMessage(e,t){if(this.customReportCount+=t.length,this.customReportCount>kC("CUSTOM_REPORT_LIMIT"))throw new Vg(xg.CUSTOM_REPORT_FREQUENCY_TOO_HIGH);this.customReportCounterTimer||(this.customReportCounterTimer=window.setInterval((()=>{this.customReportCount=0;}),5e3));const i=Date.now(),n=t.map((t=>({type:QC.USER_ANALYTICS,data:tv(tv({sid:e},t),{},{lts:i})})));try{kC("NEW_REPORT_SERVER")?await this.postDataToStatsCollector2(n):await this.postDataToStatsCollector(n);}catch(e){throw KC.error("send custom report message failed",e.toString()),new Vg(xg.CUSTOM_REPORT_SEND_FAILED,e.message)}}sendApiInvoke(e){const t=kC("NOT_REPORT_EVENT");if(e.tag&&Pr(t)&&Pr(t).call(t,e.tag))return !1;if(null===e.sid)return this.apiInvokeUploadPendingItems.push(e),!1;const i=this.baseInfoMap.get(e.sid);if(!i)return this.apiInvokeUploadPendingItems.push(e),!1;const{cname:n,uid:r,cid:s}=i.info;let o;if(e.lts=e.lts||Date.now(),e.error)if(e.error instanceof Vg){const{code:t,message:i}=e.error;o=t||(i||e.error.toString());}else o=e.error.toString();const a={invokeId:e.invokeId,sid:e.sid,cname:n,cid:s,uid:r,lts:e.lts,success:e.success,elapse:e.lts-i.startTime,execElapse:e.lts-e.apiInvokeTime,apiName:e.name,options:e.options?JSON.stringify(e.options):void 0,execStates:e.states?JSON.stringify(e.states):void 0,execResult:e.result?JSON.stringify(e.result):void 0,errorCode:e.error?o:void 0,errorMsg:e.error?JSON.stringify(e.error):void 0};return this.send({type:QC.API_INVOKE,data:a},!1),!0}appendSessionId(){iv.__CLIENT_LIST__.forEach((e=>{if(e._sessionId){const t=this.apiInvokeUploadPendingItems.length;for(let i=0;i<t;i++){const t=this.apiInvokeUploadPendingItems.shift();t&&(t.sid=e._sessionId,this.sendApiInvoke(Object.assign({},t)));}}}));}send(e,t){if(t)return this.keyEventUploadPendingItems.push(e),void this.sendItems(this.keyEventUploadPendingItems,!0);this.normalEventUploadPendingItems.push(e),this.normalEventUploadPendingItems.length>kC("NORMAL_EVENT_QUEUE_CAPACITY")&&this.normalEventUploadPendingItems.splice(0,1),this.normalEventUploadPendingItems.length>=10&&this.sendItems(this.normalEventUploadPendingItems,!1);}doSend(){this.keyEventUploadPendingItems.length>0&&this.sendItems(this.keyEventUploadPendingItems,!0),this.normalEventUploadPendingItems.length>0&&Date.now()-this.lastSendNormalEventTime>=5e3&&this.sendItems(this.normalEventUploadPendingItems,!1);}sendItems(e,t){const i=[],n=[];for(;e.length;){const t=e.shift();i.length<20?i.push(t):n.push(t);}e.push(...n);for(const e of [...i]){var r;if(-1!==this.ltsList.indexOf(e.data.lts))e.data.lts=this.ltsList[this.ltsList.length-1]+1,this.ltsList.push(e.data.lts);else this.ltsList.push(e.data.lts),Zu(r=this.ltsList).call(r,((e,t)=>e-t));}t||(this.lastSendNormalEventTime=Date.now());return kC("ENABLE_EVENT_REPORT")?(i.length&&(kC("NEW_REPORT_SERVER")?this.postDataToStatsCollector2(i):this.postDataToStatsCollector(i)).catch((e=>i=>{kC("EVENT_REPORT_RETRY")&&(t?this.keyEventUploadPendingItems=this.keyEventUploadPendingItems.concat(e):(this.normalEventUploadPendingItems=this.normalEventUploadPendingItems.concat(e),this.normalEventUploadPendingItems.length>kC("NORMAL_EVENT_QUEUE_CAPACITY")&&(this.normalEventUploadPendingItems.splice(0,this.normalEventUploadPendingItems.length-kC("NORMAL_EVENT_QUEUE_CAPACITY")),KC.warning("report: drop normal events"))));})(i)),e):e}async postDataToStatsCollector2(e){RT.networkState===hT.OFFLINE&&await tg.race([RT.onlineWaiter,UT(2*JT.maxRetryTimeout)]);const t=e=>{let t=new Uint8Array;return e.forEach((e=>{const i=Zg(JSON.stringify(e.data)),n=new ArrayBuffer(5),r=(e=>{let t=0;return Object.entries(QC).forEach((i=>{let[n,r]=i;r===e.type&&(t=EventNameToID[n]);})),t})(e),s=new DataView(n);s.setUint16(0,i.byteLength,!0),s.setUint8(2,255&r),s.setUint8(3,r>>>8&255),s.setUint8(4,r>>>16&255),t=$g(t,new Uint8Array(n)),t=$g(t,i);})),t},i="event";let n=this.proxyServer?"https://".concat(this.proxyServer,"/rs/?h=").concat(kC("NEW_REPORT_SERVER_DOMAINS")[0],"&p=443&d=").concat(i):"https://".concat(kC("NEW_REPORT_SERVER_DOMAINS")[0],"/").concat(i);for(let r=0;r<2;r+=1){1===r&&(n=this.proxyServer?"https://".concat(this.proxyServer,"/rs/?h=").concat(kC("NEW_REPORT_SERVER_DOMAINS")[1],"&p=443&d=").concat(i):"https://".concat(kC("NEW_REPORT_SERVER_DOMAINS")[1],"/").concat(i));try{await RC(n,{timeout:1e4,data:t(e),headers:tv(tv({biz:"webrtc",sendts:Math.round(Date.now()/1e3),debug:"false"},this._appId&&{appid:this._appId}),{},{"Content-Type":"application/octet-stream"})},!0);}catch(e){if(1===r)throw e;continue}return}}async postDataToStatsCollector(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const i={msgType:"EventMessages",sentTs:Math.round(Date.now()/1e3),payloads:e.map((e=>JSON.stringify(e))),vid:(e=>{const t=e&&e.data.sid&&this.baseInfoMap.get(e.data.sid);return t&&t.info.vid&&+t.info.vid||0})(e[0])};RT.networkState===hT.OFFLINE&&await tg.race([RT.onlineWaiter,UT(2*JT.maxRetryTimeout)]);const n=t?"/events/proto-raws":"/events/messages";let r=this.url||(this.proxyServer?"https://".concat(this.proxyServer,"/rs/?h=").concat(kC("EVENT_REPORT_DOMAIN"),"&p=").concat(kC("STATS_COLLECTOR_PORT"),"&d=").concat(n):"https://".concat(kC("EVENT_REPORT_DOMAIN"),":").concat(kC("STATS_COLLECTOR_PORT")).concat(n));for(let e=0;e<2;e+=1){1===e&&(r=this.backupUrl||(this.proxyServer?"https://".concat(this.proxyServer,"/rs/?h=").concat(kC("EVENT_REPORT_BACKUP_DOMAIN"),"&p=").concat(kC("STATS_COLLECTOR_PORT"),"&d=").concat(n):"https://".concat(kC("EVENT_REPORT_BACKUP_DOMAIN"),":").concat(kC("STATS_COLLECTOR_PORT")).concat(n)));try{t?await CC(r,{timeout:1e4,data:i}):await RC(r,{timeout:1e4,data:i});}catch(t){if(1===e)throw t;continue}return}}createBaseInfo(e,t){const i=Object.assign({},zC);return i.sid=e,this.baseInfoMap.set(e,{info:i,startTime:t}),i}reportResourceTiming(e,t){const i=performance.getEntriesByName(e),n=i[i.length-1];n&&this.reportApiInvoke(t,{name:"Client.resourceTiming",options:n,tag:oT.TRACER}).onSuccess();}}function nv(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return function(t,i,n){const r=n.value;if("function"==typeof r){const s=e.className||t.__className__||("AgoraRTCClient"===t.constructor.name?"Client":t.constructor.name);n.value=function(){for(var t=arguments.length,n=new Array(t),o=0;o<t;o++)n[o]=arguments[o];let a=n;if(e.argsMap)try{a=e.argsMap(this,...n);}catch(e){KC.warning(e),a=[];}try{JSON.stringify(a);}catch(e){KC.warning("arguments for method ".concat(s,".").concat(String(i)," not serializable for apiInvoke.")),a=[];}const c=(e.report||rv).reportApiInvoke(this._sessionId||null,{name:"".concat(s,".").concat(String(i)),options:a,tag:oT.TRACER,reportResult:e.reportResult},e.throttleTime);try{const t=r.apply(this,n);return t instanceof tg?t.then((t=>(c.onSuccess(e.reportResult&&t),t))).catch((e=>{throw c.onError(e),e})):(c.onSuccess(e.reportResult&&t),t)}catch(e){throw c.onError(e),e}};}return n}}nu(iv,"__CLIENT_LIST__",[]);const rv=new iv;VC.on("REPORT_LOG_UPLOAD",(e=>{e.networkState=RT.networkState,rv.reportApiInvoke(null,{name:"logUploadError",options:e,tag:oT.TRACER});}));const sv=["CHINA","GLOBAL"],ov=function(){const e="us".concat("erna","me"),t="pa".concat("sswo","rd"),i=["t","s","t"];i.splice(1,0,"e");const n=i.join(""),r=[];for(let e=0;e<6;e++)r.push("1");const s=r.join(""),o={};return o[e]=n,o[t]=s,Object.assign(o,{turnServerURL:"",tcpport:3433,udpport:3478,forceturn:!1})}();window.DEFAULT_TURN_CONFIG=ov,NC||(PC.WEBCS_DOMAIN=["ap-web-1-oversea.agora.io","ap-web-1-north-america.agora.io"],PC.WEBCS_DOMAIN_BACKUP_LIST=["ap-web-2-oversea.agora.io","ap-web-2-north-america.agora.io"],PC.PROXY_CS=["proxy-ap-web-oversea.agora.io","proxy-ap-web-america.agora.io"],PC.CDS_AP=["cds-ap-web-oversea.agora.io","cds-ap-web-america.agora.io","cds-ap-web-america2.agora.io"],PC.ACCOUNT_REGISTER=["sua-ap-web-oversea.agora.io","sua-ap-web-america.agora.io","sua-ap-web-america2.agora.io"],PC.UAP_AP=["uap-ap-web-oversea.agora.io","uap-ap-web-america.agora.io","uap-ap-web-america2.agora.io"],PC.LOG_UPLOAD_SERVER="logservice-oversea.agora.io",PC.EVENT_REPORT_DOMAIN="statscollector-1-oversea.agora.io",PC.EVENT_REPORT_BACKUP_DOMAIN="statscollector-2-oversea.agora.io",PC.PROXY_SERVER_TYPE3="webrtc-cloud-proxy.agora.io",PC.AREAS=["NORTH_AMERICA","OVERSEA"]);const av=[[0,1,2,3,4,5,5],[0,2,2,3,4,5,5],[0,3,3,3,4,5,5],[0,4,4,4,4,5,5],[0,5,5,5,5,5,5]],cv=[];function dv(e,t){return !!t&&cv.some((i=>i.uid===e&&i.channelName===t))}iv.__CLIENT_LIST__=cv;var lv,hv,uv,pv,_v,Ev,mv,fv,gv,Tv,Sv,Rv,Cv,vv,Iv,yv,Av,bv=er("Array").values,wv=Er,Ov=ni,Nv=Ee,Dv=bv,Pv=Array.prototype,Lv={DOMTokenList:!0,NodeList:!0},kv=J((function(e){var t=e.values;return e===Pv||Nv(Pv,e)&&t===Pv.values||Ov(Lv,wv(e))?Dv:t}));function Mv(e,t,i,n){var r,s=arguments.length,o=s<3?t:null===n?n=Object.getOwnPropertyDescriptor(t,i):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)o=Reflect.decorate(e,t,i,n);else for(var a=e.length-1;a>=0;a--)(r=e[a])&&(o=(s<3?r(o):s>3?r(t,i,o):r(t,i))||o);return s>3&&o&&Object.defineProperty(t,i,o),o}function Uv(e,t){if("object"==typeof Reflect&&"function"==typeof Reflect.metadata)return Reflect.metadata(e,t)}!function(e){e.L1T1="L1T1",e.L1T2="L1T2",e.L1T3="L1T3",e.L2T1_KEY="L2T1_KEY",e.L2T2_KEY="L2T2_KEY",e.L2T3_KEY="L2T3_KEY",e.L3T1_KEY="L3T1_KEY",e.L3T2_KEY="L3T2_KEY",e.L3T3_KEY="L3T3_KEY";}(lv||(lv={})),function(e){e.CERTIFICATE="certificate",e.CODEC="codec",e.CANDIDATE_PAIR="candidate-pair",e.LOCAL_CANDIDATE="local-candidate",e.REMOTE_CANDIDATE="remote-candidate",e.INBOUND="inbound-rtp",e.TRACK="track",e.OUTBOUND="outbound-rtp",e.PC="peer-connection",e.REMOTE_INBOUND="remote-inbound-rtp",e.REMOTE_OUTBOUND="remote-outbound-rtp",e.TRANSPORT="transport",e.CSRC="csrc",e.DATA_CHANNEL="data-channel",e.STREAM="stream",e.SENDER="sender",e.RECEIVER="receiver";}(hv||(hv={})),function(e){e[e.ACCESS_POINT=101]="ACCESS_POINT",e[e.UNILBS=201]="UNILBS",e[e.STRING_UID_ALLOCATOR=901]="STRING_UID_ALLOCATOR";}(uv||(uv={})),function(e){e[e.IIIEGAL_APPID=1]="IIIEGAL_APPID",e[e.IIIEGAL_UID=2]="IIIEGAL_UID",e[e.INTERNAL_ERROR=3]="INTERNAL_ERROR";}(pv||(pv={})),function(e){e[e.INVALID_VENDOR_KEY=5]="INVALID_VENDOR_KEY",e[e.INVALID_CHANNEL_NAME=7]="INVALID_CHANNEL_NAME",e[e.INTERNAL_ERROR=8]="INTERNAL_ERROR",e[e.NO_AUTHORIZED=9]="NO_AUTHORIZED",e[e.DYNAMIC_KEY_TIMEOUT=10]="DYNAMIC_KEY_TIMEOUT",e[e.NO_ACTIVE_STATUS=11]="NO_ACTIVE_STATUS",e[e.DYNAMIC_KEY_EXPIRED=13]="DYNAMIC_KEY_EXPIRED",e[e.STATIC_USE_DYNAMIC_KEY=14]="STATIC_USE_DYNAMIC_KEY",e[e.DYNAMIC_USE_STATIC_KEY=15]="DYNAMIC_USE_STATIC_KEY",e[e.USER_OVERLOAD=16]="USER_OVERLOAD",e[e.FORBIDDEN_REGION=18]="FORBIDDEN_REGION",e[e.CANNOT_MEET_AREA_DEMAND=19]="CANNOT_MEET_AREA_DEMAND";}(_v||(_v={})),function(e){e[e.NO_FLAG_SET=100]="NO_FLAG_SET",e[e.FLAG_SET_BUT_EMPTY=101]="FLAG_SET_BUT_EMPTY",e[e.INVALID_FALG_SET=102]="INVALID_FALG_SET",e[e.FLAG_SET_BUT_NO_RE=103]="FLAG_SET_BUT_NO_RE",e[e.INVALID_SERVICE_ID=104]="INVALID_SERVICE_ID",e[e.NO_SERVICE_AVAILABLE=200]="NO_SERVICE_AVAILABLE",e[e.NO_SERVICE_AVAILABLE_P2P=201]="NO_SERVICE_AVAILABLE_P2P",e[e.NO_SERVICE_AVAILABLE_VOICE=202]="NO_SERVICE_AVAILABLE_VOICE",e[e.NO_SERVICE_AVAILABLE_WEBRTC=203]="NO_SERVICE_AVAILABLE_WEBRTC",e[e.NO_SERVICE_AVAILABLE_CDS=204]="NO_SERVICE_AVAILABLE_CDS",e[e.NO_SERVICE_AVAILABLE_CDN=205]="NO_SERVICE_AVAILABLE_CDN",e[e.NO_SERVICE_AVAILABLE_TDS=206]="NO_SERVICE_AVAILABLE_TDS",e[e.NO_SERVICE_AVAILABLE_REPORT=207]="NO_SERVICE_AVAILABLE_REPORT",e[e.NO_SERVICE_AVAILABLE_APP_CENTER=208]="NO_SERVICE_AVAILABLE_APP_CENTER",e[e.NO_SERVICE_AVAILABLE_ENV0=209]="NO_SERVICE_AVAILABLE_ENV0",e[e.NO_SERVICE_AVAILABLE_VOET=210]="NO_SERVICE_AVAILABLE_VOET",e[e.NO_SERVICE_AVAILABLE_STRING_UID=211]="NO_SERVICE_AVAILABLE_STRING_UID",e[e.NO_SERVICE_AVAILABLE_WEBRTC_UNILBS=212]="NO_SERVICE_AVAILABLE_WEBRTC_UNILBS",e[e.NO_SERVICE_AVAILABLE_UNILBS_FLV=213]="NO_SERVICE_AVAILABLE_UNILBS_FLV";}(Ev||(Ev={})),function(e){e[e.K_TIMESTAMP_EXPIRED=2]="K_TIMESTAMP_EXPIRED",e[e.K_CHANNEL_PERMISSION_INVALID=3]="K_CHANNEL_PERMISSION_INVALID",e[e.K_CERTIFICATE_INVALID=4]="K_CERTIFICATE_INVALID",e[e.K_CHANNEL_NAME_EMPTY=5]="K_CHANNEL_NAME_EMPTY",e[e.K_CHANNEL_NOT_FOUND=6]="K_CHANNEL_NOT_FOUND",e[e.K_TICKET_INVALID=7]="K_TICKET_INVALID",e[e.K_CHANNEL_CONFLICTED=8]="K_CHANNEL_CONFLICTED",e[e.K_SERVICE_NOT_READY=9]="K_SERVICE_NOT_READY",e[e.K_SERVICE_TOO_HEAVY=10]="K_SERVICE_TOO_HEAVY",e[e.K_UID_BANNED=14]="K_UID_BANNED",e[e.K_IP_BANNED=15]="K_IP_BANNED",e[e.K_CHANNEL_BANNED=16]="K_CHANNEL_BANNED",e[e.K_AUTO_REBALANCE=28]="K_AUTO_REBALANCE",e[e.WARN_NO_AVAILABLE_CHANNEL=103]="WARN_NO_AVAILABLE_CHANNEL",e[e.WARN_LOOKUP_CHANNEL_TIMEOUT=104]="WARN_LOOKUP_CHANNEL_TIMEOUT",e[e.WARN_LOOKUP_CHANNEL_REJECTED=105]="WARN_LOOKUP_CHANNEL_REJECTED",e[e.WARN_OPEN_CHANNEL_TIMEOUT=106]="WARN_OPEN_CHANNEL_TIMEOUT",e[e.WARN_OPEN_CHANNEL_REJECTED=107]="WARN_OPEN_CHANNEL_REJECTED",e[e.WARN_REQUEST_DEFERRED=108]="WARN_REQUEST_DEFERRED",e[e.ERR_DYNAMIC_KEY_TIMEOUT=109]="ERR_DYNAMIC_KEY_TIMEOUT",e[e.ERR_NO_AUTHORIZED=110]="ERR_NO_AUTHORIZED",e[e.ERR_VOM_SERVICE_UNAVAILABLE=111]="ERR_VOM_SERVICE_UNAVAILABLE",e[e.ERR_NO_CHANNEL_AVAILABLE_CODE=112]="ERR_NO_CHANNEL_AVAILABLE_CODE",e[e.ERR_MASTER_VOCS_UNAVAILABLE=114]="ERR_MASTER_VOCS_UNAVAILABLE",e[e.ERR_INTERNAL_ERROR=115]="ERR_INTERNAL_ERROR",e[e.ERR_NO_ACTIVE_STATUS=116]="ERR_NO_ACTIVE_STATUS",e[e.ERR_INVALID_UID=117]="ERR_INVALID_UID",e[e.ERR_DYNAMIC_KEY_EXPIRED=118]="ERR_DYNAMIC_KEY_EXPIRED",e[e.ERR_STATIC_USE_DYANMIC_KE=119]="ERR_STATIC_USE_DYANMIC_KE",e[e.ERR_DYNAMIC_USE_STATIC_KE=120]="ERR_DYNAMIC_USE_STATIC_KE",e[e.ERR_NO_VOCS_AVAILABLE=2e3]="ERR_NO_VOCS_AVAILABLE",e[e.ERR_NO_VOS_AVAILABLE=2001]="ERR_NO_VOS_AVAILABLE",e[e.ERR_JOIN_CHANNEL_TIMEOUT=2002]="ERR_JOIN_CHANNEL_TIMEOUT",e[e.ERR_REPEAT_JOIN_CHANNEL=2003]="ERR_REPEAT_JOIN_CHANNEL",e[e.ERR_JOIN_BY_MULTI_IP=2004]="ERR_JOIN_BY_MULTI_IP",e[e.ERR_NOT_JOINED=2011]="ERR_NOT_JOINED",e[e.ERR_REPEAT_JOIN_REQUEST=2012]="ERR_REPEAT_JOIN_REQUEST",e[e.ERR_INVALID_VENDOR_KEY=2013]="ERR_INVALID_VENDOR_KEY",e[e.ERR_INVALID_CHANNEL_NAME=2014]="ERR_INVALID_CHANNEL_NAME",e[e.ERR_INVALID_STRINGUID=2015]="ERR_INVALID_STRINGUID",e[e.ERR_TOO_MANY_USERS=2016]="ERR_TOO_MANY_USERS",e[e.ERR_SET_CLIENT_ROLE_TIMEOUT=2017]="ERR_SET_CLIENT_ROLE_TIMEOUT",e[e.ERR_SET_CLIENT_ROLE_NO_PERMISSION=2018]="ERR_SET_CLIENT_ROLE_NO_PERMISSION",e[e.ERR_SET_CLIENT_ROLE_ALREADY_IN_USE=2019]="ERR_SET_CLIENT_ROLE_ALREADY_IN_USE",e[e.ERR_PUBLISH_REQUEST_INVALID=2020]="ERR_PUBLISH_REQUEST_INVALID",e[e.ERR_SUBSCRIBE_REQUEST_INVALID=2021]="ERR_SUBSCRIBE_REQUEST_INVALID",e[e.ERR_NOT_SUPPORTED_MESSAGE=2022]="ERR_NOT_SUPPORTED_MESSAGE",e[e.ERR_ILLEAGAL_PLUGIN=2023]="ERR_ILLEAGAL_PLUGIN",e[e.ERR_REJOIN_TOKEN_INVALID=2024]="ERR_REJOIN_TOKEN_INVALID",e[e.ERR_REJOIN_USER_NOT_JOINED=2025]="ERR_REJOIN_USER_NOT_JOINED",e[e.ERR_INVALID_OPTIONAL_INFO=2027]="ERR_INVALID_OPTIONAL_INFO",e[e.ILLEGAL_AES_PASSWORD=2028]="ILLEGAL_AES_PASSWORD",e[e.ILLEGAL_CLIENT_ROLE_LEVEL=2029]="ILLEGAL_CLIENT_ROLE_LEVEL",e[e.ERR_TOO_MANY_BROADCASTERS=2031]="ERR_TOO_MANY_BROADCASTERS",e[e.ERR_TOO_MANY_SUBSCRIBERS=2032]="ERR_TOO_MANY_SUBSCRIBERS",e[e.ERR_LICENSE_MISSING=32769]="ERR_LICENSE_MISSING",e[e.ERR_LICENSE_EXPIRED=32771]="ERR_LICENSE_EXPIRED",e[e.ERR_LICENSE_MINUTES_EXCEEDED=32773]="ERR_LICENSE_MINUTES_EXCEEDED",e[e.ERR_LICENSE_PERIOD_INVALID=32774]="ERR_LICENSE_PERIOD_INVALID",e[e.ERR_LICENSE_MULTIPLE_SDK_SERVICE=32778]="ERR_LICENSE_MULTIPLE_SDK_SERVICE",e[e.ERR_LICENSE_ILLEGAL=32783]="ERR_LICENSE_ILLEGAL",e[e.ERR_TEST_RECOVER=9e3]="ERR_TEST_RECOVER",e[e.ERR_TEST_TRYNEXT=9001]="ERR_TEST_TRYNEXT",e[e.ERR_TEST_RETRY=9002]="ERR_TEST_RETRY";}(mv||(mv={})),function(e){e.CONNECTING="connecting",e.CONNECTED="connected",e.RECONNECTING="reconnecting",e.CLOSED="closed";}(fv||(fv={})),function(e){e.WS_CONNECTED="ws_connected",e.WS_RECONNECTING="ws_reconnecting",e.WS_CLOSED="ws_closed",e.WS_RECONNECT_WAITTING_FINISH="ws_reconnect_waitting_finish",e.WS_RECONNECT_CREATE_CONNECTION="ws_reconnect_create_connection",e.ON_BINARY_DATA="on_binary_data",e.REQUEST_RECOVER="request_recover",e.REQUEST_JOIN_INFO="request_join_info",e.REQUEST_REJOIN_INFO="req_rejoin_info",e.IS_P2P_DISCONNECTED="is_p2p_dis",e.DISCONNECT_P2P="dis_p2p",e.ABORT_P2P_EXECUTION="abort_p2p_execution",e.NEED_RENEW_SESSION="need-sid",e.REPORT_JOIN_GATEWAY="report_join_gateway",e.REQUEST_TIMEOUT="request_timeout",e.REQUEST_SUCCESS="request_success",e.JOIN_RESPONSE="join_response",e.DATACHANNEL_PRECONNECT="datachannel_preconnect",e.DATACHANNEL_CONNECTING="datachannel_connecting",e.DATACHANNEL_FAILBACK="datachannel_failback",e.P2P_START="p2p_start",e.P2P_CONNECTION="p2p_connection",e.P2P_REMOTE_CANDIDATE_UPDATE="p2p_remote_candidate_update",e.P2P_SUBSCRIBE="p2p_subscribe",e.P2P_UNSUBSCRIBE="p2p_unsubscribe",e.P2P_EXCHANGE_SDP="p2p_exchange_sdp",e.P2P_ON_ADD_VIDEO_STREAM="p2p_on_add_video_stream",e.P2P_ON_ADD_AUDIO_STREAM="p2p_on_add_audio_stream";}(gv||(gv={})),function(e){e.PING="ping",e.PING_BACK="ping_back",e.JOIN="join_v3",e.REJOIN="rejoin_v3",e.LEAVE="leave",e.SET_CLIENT_ROLE="set_client_role",e.PUBLISH="publish",e.PUBLISH_DATASTREAM="publish_datastream",e.UNPUBLISH="unpublish",e.UNPUBLISH_DATASTREAM="unpublish_datastream",e.SUBSCRIBE="subscribe",e.SUBSCRIBE_DATASTREAM="subscribe_datastream",e.SUBSCRIBE_STREAMS="subscribe_streams",e.UNSUBSCRIBE="unsubscribe",e.UNSUBSCRIBE_DATASTREAM="unsubscribe_datastream",e.UNSUBSCRIBE_STREAMS="unsubscribe_streams",e.SUBSCRIBE_CHANGE="subscribe_change",e.TRAFFIC_STATS="traffic_stats",e.RENEW_TOKEN="renew_token",e.SWITCH_VIDEO_STREAM="switch_video_stream",e.DEFAULT_VIDEO_STREAM="default_video_stream",e.SET_FALLBACK_OPTION="set_fallback_option",e.GATEWAY_INFO="gateway_info",e.CONTROL="control",e.SEND_METADATA="send_metadata",e.DATA_STREAM="data_stream",e.PICK_SVC_LAYER="pick_svc_layer",e.RESTART_ICE="restart_ice",e.CONNECT_PC="connect_pc",e.SET_VIDEO_PROFILE="set_video_profile",e.SET_PARAMETER="set_parameter",e.SET_RTM2_FLAG="set_rtm2_flag";}(Tv||(Tv={})),function(e){e.PUBLISH_STATS="publish_stats",e.PUBLISH_RELATED_STATS="publish_related_stats",e.SUBSCRIBE_STATS="subscribe_stats",e.SUBSCRIBE_RELATED_STATS="subscribe_related_stats",e.WS_INFLATE_DATA_LENGTH="ws_inflate_data_length",e.DENOISER_STATS="denoiser_stats",e.TRANSPORT_STATS="transport_stats",e.EXTENSION_USAGE_STATS="extension_usage_stats";}(Sv||(Sv={})),function(e){e.ON_USER_ONLINE="on_user_online",e.ON_USER_OFFLINE="on_user_offline",e.ON_STREAM_FALLBACK_UPDATE="on_stream_fallback_update",e.ON_PUBLISH_STREAM="on_publish_stream",e.ON_UPLINK_STATS="on_uplink_stats",e.ON_P2P_LOST="on_p2p_lost",e.ON_REMOVE_STREAM="on_remove_stream",e.ON_ADD_AUDIO_STREAM="on_add_audio_stream",e.ON_ADD_VIDEO_STREAM="on_add_video_stream",e.ON_TOKEN_PRIVILEGE_WILL_EXPIRE="on_token_privilege_will_expire",e.ON_TOKEN_PRIVILEGE_DID_EXPIRE="on_token_privilege_did_expire",e.ON_USER_BANNED="on_user_banned",e.ON_USER_LICENSE_BANNED="on_user_license_banned",e.ON_NOTIFICATION="on_notification",e.ON_CRYPT_ERROR="on_crypt_error",e.MUTE_AUDIO="mute_audio",e.MUTE_VIDEO="mute_video",e.UNMUTE_AUDIO="unmute_audio",e.UNMUTE_VIDEO="unmute_video",e.ON_P2P_OK="on_p2p_ok",e.RECEIVE_METADATA="receive_metadata",e.ON_DATA_STREAM="on_data_stream",e.ON_RTP_CAPABILITY_CHANGE="on_rtp_capability_change",e.ON_REMOTE_DATASTREAM_UPDATE="on_remote_datastream_update",e.ON_REMOTE_FULL_DATASTREAM_INFO="on_remote_full_datastream_info",e.ENABLE_LOCAL_VIDEO="enable_local_video",e.DISABLE_LOCAL_VIDEO="disable_local_video",e.ENABLE_LOCAL_AUDIO="enable_local_audio",e.DISABLE_LOCAL_AUDIO="disable_local_audio",e.ON_PUBLISHED_USER_LIST="on_published_user_list";}(Rv||(Rv={})),function(e){e.CONNECTION_STATE_CHANGE="CONNECTION_STATE_CHANGE",e.NEED_ANSWER="NEED_ANSWER",e.NEED_RENEGOTIATE="NEED_RENEGOTIATE",e.P2P_LOST="P2P_LOST",e.GATEWAY_P2P_LOST="GATEWAY_P2P_LOST",e.NEED_UNPUB="NEED_UNPUB",e.NEED_UNSUB="NEED_UNSUB",e.NEED_UPLOAD="NEED_UPLOAD",e.NEED_CONTROL="NEED_CONTROL",e.START_RECONNECT="START_RECONNECT",e.END_RECONNECT="END_RECONNECT",e.NEED_SIGNAL_RTT="NEED_SIGNAL_RTT";}(Cv||(Cv={})),function(e){e.SEND_ONLY="SEND_ONLY",e.RECEIVE_ONLY="RECEIVE_ONLY";}(vv||(vv={})),function(e){e.CONNECTED="websocket:connected",e.RECONNECTING="websocket:reconnecting",e.WILL_RECONNECT="websocket:will_reconnect",e.CLOSED="websocket:closed",e.FAILED="websocket:failed",e.ON_MESSAGE="websocket:on_message",e.REQUEST_NEW_URLS="websocket:request_new_urls",e.RECONNECT_WAITTING_FINISH="websocket:reconnect_waitting_finish",e.RECONNECT_CREATE_CONNECTION="websocket:reconnect_create_connection",e.ON_TOKEN_PRIVILEGE_DID_EXPIRE="websocket:on_token_privilege_did_expire";}(Iv||(Iv={}));class xv extends Vg{constructor(e){super(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:"",arguments.length>2?arguments[2]:void 0),nu(this,"name","AgoraRTCException");}print(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"error";return super.print(e,KC)}throw(){super.throw(KC);}}function Vv(e){if("string"!=typeof e||!/^[a-zA-Z0-9 \!\#\$\%\&\(\)\+\-\:\;\<\=\.\>\?\@\[\]\^\_\{\}\|\~\,]{1,64}$/.test(e))throw KC.error("Invalid Channel Name ".concat(e)),new xv(xg.INVALID_PARAMS,"The length must be within 64 bytes. The supported characters: a-z,A-Z,0-9,space,!, #, $, %, &, (, ), +, -, :, ;, <, =, ., >, ?, @, [, ], ^, _,  {, }, |, ~, ,")}function Fv(e){if(!(t=e,"number"==typeof t&&Math.floor(t)===t&&0<=t&&t<=4294967295||Yg(e,1,255)))throw new xv(xg.INVALID_PARAMS,"[String uid] Length of the string: [1,255]. ASCII characters only. [Number uid] The value range is [0,10000]");var t;"string"==typeof e&&KC.warn("You input a string as the user ID, to ensure better end-user experience, Agora highly suggests not using a string as the user ID.");}!function(e){e.TRANSCODE="mix_streaming",e.RAW="raw_streaming",e.INJECT="inject_streaming";}(yv||(yv={})),function(e){e[e.INJECT_STREAM_STATUS_START_SUCCESS=0]="INJECT_STREAM_STATUS_START_SUCCESS",e[e.INJECT_STREAM_STATUS_START_ALREADY_EXISTS=1]="INJECT_STREAM_STATUS_START_ALREADY_EXISTS",e[e.INJECT_STREAM_STATUS_START_UNAUTHORIZED=2]="INJECT_STREAM_STATUS_START_UNAUTHORIZED",e[e.INJECT_STREAM_STATUS_START_TIMEOUT=3]="INJECT_STREAM_STATUS_START_TIMEOUT",e[e.INJECT_STREAM_STATUS_START_FAILED=4]="INJECT_STREAM_STATUS_START_FAILED",e[e.INJECT_STREAM_STATUS_STOP_SUCCESS=5]="INJECT_STREAM_STATUS_STOP_SUCCESS",e[e.INJECT_STREAM_STATUS_STOP_NOT_FOUND=6]="INJECT_STREAM_STATUS_STOP_NOT_FOUND",e[e.INJECT_STREAM_STATUS_STOP_UNAUTHORIZED=7]="INJECT_STREAM_STATUS_STOP_UNAUTHORIZED",e[e.INJECT_STREAM_STATUS_STOP_TIMEOUT=8]="INJECT_STREAM_STATUS_STOP_TIMEOUT",e[e.INJECT_STREAM_STATUS_STOP_FAILED=9]="INJECT_STREAM_STATUS_STOP_FAILED",e[e.INJECT_STREAM_STATUS_BROKEN=10]="INJECT_STREAM_STATUS_BROKEN";}(Av||(Av={}));const Bv={alpha:1,height:640,width:360,x:0,y:0,zOrder:0,audioChannel:0},jv={x:0,y:0,width:160,height:160,zOrder:255,alpha:1};function Gv(e,t){Wg(e.url,"".concat(t,".url"),1,1e3,!1),Kg(e.x)||jg(e.x,"".concat(t,".x"),0,1e4),Kg(e.y)||jg(e.y,"".concat(t,".y"),0,1e4),Kg(e.width)||jg(e.width,"".concat(t,".width"),0,1e4),Kg(e.height)||jg(e.height,"".concat(t,".height"),0,1e4),Kg(e.zOrder)||jg(e.zOrder,"".concat(t,".zOrder"),0,255),Kg(e.alpha)||jg(e.alpha,"".concat(t,".alpha"),0,1,!1);}const Wv={audioBitrate:48,audioChannels:1,audioSampleRate:48e3,backgroundColor:0,height:360,lowLatency:!1,videoBitrate:400,videoCodecProfile:100,videoCodecType:1,videoFrameRate:15,videoGop:30,width:640,images:[],userConfigs:[],userConfigExtraInfo:""},Hv={audioBitrate:48,audioChannels:2,audioVolume:100,audioSampleRate:48e3,height:0,width:0,videoBitrate:400,videoFramerate:15,videoGop:30};var Kv,Yv,qv,Jv,zv,Xv,Qv,Zv,$v,eI,tI,iI,nI,rI;function sI(e){if(!e.channelName)throw new xv(xg.INVALID_PARAMS,"invalid channelName in info");if("number"!=typeof e.uid)throw new xv(xg.INVALID_PARAMS,"invalid uid in info, uid must be a number");return e.token&&Wg(e.token,"info.token",1,2047),Fv(e.uid),Vv(e.channelName),!0}!function(e){e.WARNING="@live_uap-warning",e.ERROR="@line_uap-error",e.PUBLISH_STREAM_STATUS="@live_uap-publish-status",e.INJECT_STREAM_STATUS="@live_uap-inject-status",e.WORKER_STATUS="@live_uap-worker-status",e.REQUEST_NEW_ADDRESS="@live_uap-request-address";}(Kv||(Kv={})),function(e){e.REQUEST_WORKER_MANAGER_LIST="@live_req_worker_manager";}(Yv||(Yv={})),function(e){e[e.LIVE_STREAM_RESPONSE_SUCCEED=200]="LIVE_STREAM_RESPONSE_SUCCEED",e[e.LIVE_STREAM_RESPONSE_ALREADY_EXISTS_STREAM=454]="LIVE_STREAM_RESPONSE_ALREADY_EXISTS_STREAM",e[e.LIVE_STREAM_RESPONSE_TRANSCODING_PARAMETER_ERROR=450]="LIVE_STREAM_RESPONSE_TRANSCODING_PARAMETER_ERROR",e[e.LIVE_STREAM_RESPONSE_BAD_STREAM=451]="LIVE_STREAM_RESPONSE_BAD_STREAM",e[e.LIVE_STREAM_RESPONSE_WM_PARAMETER_ERROR=400]="LIVE_STREAM_RESPONSE_WM_PARAMETER_ERROR",e[e.LIVE_STREAM_RESPONSE_WM_WORKER_NOT_EXIST=404]="LIVE_STREAM_RESPONSE_WM_WORKER_NOT_EXIST",e[e.LIVE_STREAM_RESPONSE_NOT_AUTHORIZED=456]="LIVE_STREAM_RESPONSE_NOT_AUTHORIZED",e[e.LIVE_STREAM_RESPONSE_FAILED_LOAD_IMAGE=457]="LIVE_STREAM_RESPONSE_FAILED_LOAD_IMAGE",e[e.LIVE_STREAM_RESPONSE_REQUEST_TOO_OFTEN=429]="LIVE_STREAM_RESPONSE_REQUEST_TOO_OFTEN",e[e.LIVE_STREAM_RESPONSE_NOT_FOUND_PUBLISH=452]="LIVE_STREAM_RESPONSE_NOT_FOUND_PUBLISH",e[e.LIVE_STREAM_RESPONSE_NOT_SUPPORTED=453]="LIVE_STREAM_RESPONSE_NOT_SUPPORTED",e[e.LIVE_STREAM_RESPONSE_MAX_STREAM_NUM=455]="LIVE_STREAM_RESPONSE_MAX_STREAM_NUM",e[e.LIVE_STREAM_RESPONSE_INTERNAL_SERVER_ERROR=500]="LIVE_STREAM_RESPONSE_INTERNAL_SERVER_ERROR",e[e.LIVE_STREAM_RESPONSE_WORKER_LOST=501]="LIVE_STREAM_RESPONSE_WORKER_LOST",e[e.LIVE_STREAM_RESPONSE_RESOURCE_LIMIT=502]="LIVE_STREAM_RESPONSE_RESOURCE_LIMIT",e[e.LIVE_STREAM_RESPONSE_WORKER_QUIT=503]="LIVE_STREAM_RESPONSE_WORKER_QUIT",e[e.ERROR_FAIL_SEND_MESSAGE=504]="ERROR_FAIL_SEND_MESSAGE",e[e.PUBLISH_STREAM_STATUS_ERROR_RTMP_HANDSHAKE=30]="PUBLISH_STREAM_STATUS_ERROR_RTMP_HANDSHAKE",e[e.PUBLISH_STREAM_STATUS_ERROR_RTMP_CONNECT=31]="PUBLISH_STREAM_STATUS_ERROR_RTMP_CONNECT",e[e.PUBLISH_STREAM_STATUS_ERROR_RTMP_PUBLISH=32]="PUBLISH_STREAM_STATUS_ERROR_RTMP_PUBLISH",e[e.PUBLISH_STREAM_STATUS_ERROR_PUBLISH_BROKEN=33]="PUBLISH_STREAM_STATUS_ERROR_PUBLISH_BROKEN";}(qv||(qv={})),function(e){e.CONNECT_FAILED="connect failed",e.CONNECT_TIMEOUT="connect timeout",e.WS_DISCONNECTED="websocket disconnected",e.REQUEST_TIMEOUT="request timeout",e.REQUEST_FAILED="request failed",e.WAIT_STATUS_TIMEOUT="wait status timeout",e.WAIT_STATUS_ERROR="wait status error",e.BAD_STATE="bad state",e.WS_ABORT="ws abort",e.AP_REQUEST_TIMEOUT="AP request timeout",e.AP_JSON_PARSE_ERROR="AP json parse error",e.AP_REQUEST_ERROR="AP request error",e.AP_REQUEST_ABORT="AP request abort";}(Jv||(Jv={})),function(e){e[e.SetSdkProfile=0]="SetSdkProfile",e[e.SetSourceChannel=1]="SetSourceChannel",e[e.SetSourceUserId=2]="SetSourceUserId",e[e.SetDestChannel=3]="SetDestChannel",e[e.StartPacketTransfer=4]="StartPacketTransfer",e[e.StopPacketTransfer=5]="StopPacketTransfer",e[e.UpdateDestChannel=6]="UpdateDestChannel",e[e.Reconnect=7]="Reconnect",e[e.SetVideoProfile=8]="SetVideoProfile";}(zv||(zv={})),function(e){e.NETWORK_DISCONNECTED="NETWORK_DISCONNECTED",e.NETWORK_CONNECTED="NETWORK_CONNECTED",e.PACKET_JOINED_SRC_CHANNEL="PACKET_JOINED_SRC_CHANNEL",e.PACKET_JOINED_DEST_CHANNEL="PACKET_JOINED_DEST_CHANNEL",e.PACKET_SENT_TO_DEST_CHANNEL="PACKET_SENT_TO_DEST_CHANNEL",e.PACKET_RECEIVED_VIDEO_FROM_SRC="PACKET_RECEIVED_VIDEO_FROM_SRC",e.PACKET_RECEIVED_AUDIO_FROM_SRC="PACKET_RECEIVED_AUDIO_FROM_SRC",e.PACKET_UPDATE_DEST_CHANNEL="PACKET_UPDATE_DEST_CHANNEL",e.PACKET_UPDATE_DEST_CHANNEL_REFUSED="PACKET_UPDATE_DEST_CHANNEL_REFUSED",e.PACKET_UPDATE_DEST_CHANNEL_NOT_CHANGE="PACKET_UPDATE_DEST_CHANNEL_NOT_CHANGE";}(Xv||(Xv={})),function(e){e.RELAY_STATE_IDLE="RELAY_STATE_IDLE",e.RELAY_STATE_CONNECTING="RELAY_STATE_CONNECTING",e.RELAY_STATE_RUNNING="RELAY_STATE_RUNNING",e.RELAY_STATE_FAILURE="RELAY_STATE_FAILURE";}(Qv||(Qv={})),function(e){e.RELAY_OK="RELAY_OK",e.SERVER_CONNECTION_LOST="SERVER_CONNECTION_LOST",e.SRC_TOKEN_EXPIRED="SRC_TOKEN_EXPIRED",e.DEST_TOKEN_EXPIRED="DEST_TOKEN_EXPIRED";}(Zv||(Zv={})),function(e){e.High="high",e.Low="low",e.Audio="audio",e.Screen="screen",e.ScreenLow="screen_low";}($v||($v={})),function(e){e.DISCONNECT="disconnect",e.CONNECTION_STATE_CHANGE="connection-state-change",e.NETWORK_QUALITY="network-quality",e.STREAM_TYPE_CHANGE="stream-type-change",e.IS_P2P_DISCONNECTED="is-p2p-dis",e.DISCONNECT_P2P="dis-p2p",e.REQUEST_NEW_GATEWAY_LIST="req-gate-url",e.NEED_RENEW_SESSION="need-sid",e.REQUEST_P2P_CONNECTION_PARAMS="request-p2p-connection-params",e.JOIN_RESPONSE="join-response",e.REQUEST_DC_CONNECTION_PARAMS="request-dc-connection-params",e.RESET_CONNECTION_EVENTS="reset-connection-events",e.DATACHANNEL_PRECONNECT="datachannel_preconnect",e.DATACHANNEL_FAILBACK="datachannel_failback",e.RESET_SIGNAL="reset-signal";}(eI||(eI={})),function(e){e.P2P_DISCONNECTED="P2P_DISCONNECTED",e.A_ROUND_WS_FAILED="A_ROUND_WS_FAILED",e.TIMEOUT="TIMEOUT",e.UNKNOWN_REASON="UNKNOWN_REASON";}(tI||(tI={})),function(e){e[e.Nothing=0]="Nothing",e[e.Audio=1]="Audio",e[e.LwoVideo=2]="LwoVideo",e[e.Video=4]="Video",e[e.Data=8]="Data",e[e.DataStream0=256]="DataStream0",e[e.DataStream1=512]="DataStream1",e[e.DataStream2=1024]="DataStream2",e[e.DataStream3=2048]="DataStream3",e[e.DataStream4=4096]="DataStream4",e[e.DataStream5=8192]="DataStream5",e[e.DataStream6=16384]="DataStream6",e[e.DataStream7=32768]="DataStream7";}(iI||(iI={})),function(e){e[e.websocket=0]="websocket",e[e.datachannel=1]="datachannel";}(nI||(nI={})),function(e){e.CHINA="CHINA",e.ASIA="ASIA",e.NORTH_AMERICA="NORTH_AMERICA",e.EUROPE="EUROPE",e.JAPAN="JAPAN",e.INDIA="INDIA",e.KOREA="KOREA",e.HKMC="HKMC",e.US="US",e.OCEANIA="OCEANIA",e.SOUTH_AMERICA="SOUTH_AMERICA",e.AFRICA="AFRICA",e.OVERSEA="OVERSEA",e.GLOBAL="GLOBAL",e.EXTENSIONS="EXTENSIONS";}(rI||(rI={}));const oI=[rI.AFRICA,rI.ASIA,rI.CHINA,rI.EUROPE,rI.GLOBAL,rI.INDIA,rI.JAPAN,rI.NORTH_AMERICA,rI.OCEANIA,rI.OVERSEA,rI.SOUTH_AMERICA];var aI;!function(e){e.CHINA="CN",e.ASIA="AS",e.NORTH_AMERICA="NA",e.EUROPE="EU",e.JAPAN="JP",e.INDIA="IN",e.KOREA="KR",e.HKMC="HK",e.US="US",e.OCEANIA="OC",e.SOUTH_AMERICA="SA",e.AFRICA="AF",e.OVERSEA="OVERSEA",e.GLOBAL="GLOBAL",e.EXTENSIONS="GLOBAL";}(aI||(aI={}));const cI={CHINA:{},ASIA:{CODE:aI.ASIA,WEBCS_DOMAIN:["ap-web-1-asia.agora.io"],WEBCS_DOMAIN_BACKUP_LIST:["ap-web-2-asia.agora.io"],PROXY_CS:["proxy-ap-web-asia.agora.io"],CDS_AP:["cds-ap-web-asia.agora.io","cds-ap-web-asia2.agora.io"],ACCOUNT_REGISTER:["sua-ap-web-asia.agora.io","sua-ap-web-asia2.agora.io"],UAP_AP:["uap-ap-web-asia.agora.io","uap-ap-web-asia2.agora.io"],EVENT_REPORT_DOMAIN:["statscollector-1-asia.agora.io"],EVENT_REPORT_BACKUP_DOMAIN:["statscollector-2-asia.agora.io"],LOG_UPLOAD_SERVER:["logservice-asia.agora.io"],PROXY_SERVER_TYPE3:["southeast-asia.webrtc-cloud-proxy.sd-rtn.com"]},NORTH_AMERICA:{CODE:aI.NORTH_AMERICA,WEBCS_DOMAIN:["ap-web-1-north-america.agora.io"],WEBCS_DOMAIN_BACKUP_LIST:["ap-web-2-north-america.agora.io"],PROXY_CS:["proxy-ap-web-america.agora.io"],CDS_AP:["cds-ap-web-america.agora.io","cds-ap-web-america2.agora.io"],ACCOUNT_REGISTER:["sua-ap-web-america.agora.io","sua-ap-web-america2.agora.io"],UAP_AP:["uap-ap-web-america.agora.io","uap-ap-web-america2.agora.io"],EVENT_REPORT_DOMAIN:["statscollector-1-north-america.agora.io"],EVENT_REPORT_BACKUP_DOMAIN:["statscollector-2-north-america.agora.io"],LOG_UPLOAD_SERVER:["logservice-north-america.agora.io"],PROXY_SERVER_TYPE3:["east-usa.webrtc-cloud-proxy.sd-rtn.com"]},EUROPE:{CODE:aI.EUROPE,WEBCS_DOMAIN:["ap-web-1-europe.agora.io"],WEBCS_DOMAIN_BACKUP_LIST:["ap-web-2-europe.agora.io"],PROXY_CS:["proxy-ap-web-europe.agora.io"],CDS_AP:["cds-ap-web-europe.agora.io","cds-ap-web-europe2.agora.io"],ACCOUNT_REGISTER:["sua-ap-web-europe.agora.io","sua-ap-web-europe.agora.io"],UAP_AP:["uap-ap-web-europe.agora.io","uap-ap-web-europe2.agora.io"],EVENT_REPORT_DOMAIN:["statscollector-1-europe.agora.io"],EVENT_REPORT_BACKUP_DOMAIN:["statscollector-2-europe.agora.io"],LOG_UPLOAD_SERVER:["logservice-europe.agora.io"],PROXY_SERVER_TYPE3:["europe.webrtc-cloud-proxy.sd-rtn.com"]},JAPAN:{CODE:aI.JAPAN,WEBCS_DOMAIN:["ap-web-1-japan.agora.io"],WEBCS_DOMAIN_BACKUP_LIST:["ap-web-2-japan.agora.io"],PROXY_CS:["proxy-ap-web-japan.agora.io"],CDS_AP:["cds-ap-web-japan.agora.io","cds-ap-web-japan2.agora.io"],ACCOUNT_REGISTER:["sua-ap-web-japan.agora.io","sua-ap-web-japan2.agora.io"],UAP_AP:["uap-ap-web-japan.agora.io","\tuap-ap-web-japan2.agora.io"],EVENT_REPORT_DOMAIN:["statscollector-1-japan.agora.io"],EVENT_REPORT_BACKUP_DOMAIN:["statscollector-2-japan.agora.io"],LOG_UPLOAD_SERVER:["logservice-japan.agora.io"],PROXY_SERVER_TYPE3:["japan.webrtc-cloud-proxy.sd-rtn.com"]},INDIA:{CODE:aI.INDIA,WEBCS_DOMAIN:["ap-web-1-india.agora.io"],WEBCS_DOMAIN_BACKUP_LIST:["ap-web-2-india.agora.io"],PROXY_CS:["proxy-ap-web-india.agora.io"],CDS_AP:["cds-ap-web-india.agora.io","cds-ap-web-india2.agora.io"],ACCOUNT_REGISTER:["sua-ap-web-india.agora.io","sua-ap-web-india2.agora.io"],UAP_AP:["uap-ap-web-india.agora.io","uap-ap-web-india2.agora.io"],EVENT_REPORT_DOMAIN:["statscollector-1-india.agora.io"],EVENT_REPORT_BACKUP_DOMAIN:["statscollector-2-india.agora.io"],LOG_UPLOAD_SERVER:["logservice-india.agora.io"],PROXY_SERVER_TYPE3:["india.webrtc-cloud-proxy.sd-rtn.com"]},KOREA:{CODE:aI.KOREA,WEBCS_DOMAIN:["ap-web-1-korea.agora.io"],WEBCS_DOMAIN_BACKUP_LIST:["ap-web-2-korea.agora.io"],PROXY_CS:["proxy-ap-web-korea.agora.io"],CDS_AP:["cds-ap-web-korea.agora.io","cds-ap-web-korea2.agora.io"],ACCOUNT_REGISTER:["sua-ap-web-korea.agora.io","sua-ap-web-korea2.agora.io"],UAP_AP:["uap-ap-web-korea.agora.io","uap-ap-web-korea2.agora.io"],EVENT_REPORT_DOMAIN:["statscollector-1-korea.agora.io"],EVENT_REPORT_BACKUP_DOMAIN:["statscollector-2-korea.agora.io"],LOG_UPLOAD_SERVER:["logservice-korea.agora.io"],PROXY_SERVER_TYPE3:["korea.webrtc-cloud-proxy.sd-rtn.com"]},HKMC:{CODE:aI.HKMC,WEBCS_DOMAIN:["ap-web-1-hkmc.agora.io"],WEBCS_DOMAIN_BACKUP_LIST:["ap-web-2-hkmc.agora.io"],PROXY_CS:["proxy-ap-web-hkmc.agora.io"],CDS_AP:["cds-ap-web-hkmc.agora.io","cds-ap-web-hkmc2.agora.io"],ACCOUNT_REGISTER:["sua-ap-web-hkmc.agora.io","sua-ap-web-hkmc2.agora.io"],UAP_AP:["uap-ap-web-hkmc.agora.io","uap-ap-web-hkmc2.agora.io"],EVENT_REPORT_DOMAIN:["statscollector-1-hkmc.agora.io"],EVENT_REPORT_BACKUP_DOMAIN:["statscollector-2-hkmc.agora.io"],LOG_UPLOAD_SERVER:["logservice-hkmc.agora.io"],PROXY_SERVER_TYPE3:["hkmc.webrtc-cloud-proxy.sd-rtn.com"]},US:{CODE:aI.US,WEBCS_DOMAIN:["ap-web-1-us.agora.io"],WEBCS_DOMAIN_BACKUP_LIST:["ap-web-2-us.agora.io"],PROXY_CS:["proxy-ap-web-us.agora.io"],CDS_AP:["cds-ap-web-us.agora.io","cds-ap-web-us2.agora.io"],ACCOUNT_REGISTER:["sua-ap-web-us.agora.io","sua-ap-web-us2.agora.io"],UAP_AP:["uap-ap-web-us.agora.io","uap-ap-web-us2.agora.io"],EVENT_REPORT_DOMAIN:["statscollector-1-us.agora.io"],EVENT_REPORT_BACKUP_DOMAIN:["statscollector-2-us.agora.io"],LOG_UPLOAD_SERVER:["logservice-us.agora.io"],PROXY_SERVER_TYPE3:["us.webrtc-cloud-proxy.sd-rtn.com"]},OVERSEA:{CODE:aI.OVERSEA,WEBCS_DOMAIN:["ap-web-1-oversea.agora.io"],WEBCS_DOMAIN_BACKUP_LIST:["ap-web-2-oversea.agora.io"],PROXY_CS:["proxy-ap-web-oversea.agora.io"],CDS_AP:["cds-ap-web-oversea.agora.io"],ACCOUNT_REGISTER:["sua-ap-web-oversea.agora.io"],UAP_AP:["uap-ap-web-oversea.agora.io"],EVENT_REPORT_DOMAIN:["statscollector-1-oversea.agora.io"],EVENT_REPORT_BACKUP_DOMAIN:["statscollector-2-oversea.agora.io"],LOG_UPLOAD_SERVER:["logservice-oversea.agora.io"],PROXY_SERVER_TYPE3:["webrtc-cloud-proxy.agora.io"]},GLOBAL:{CODE:aI.GLOBAL,WEBCS_DOMAIN:["webrtc2-ap-web-1.agora.io"],WEBCS_DOMAIN_BACKUP_LIST:["webrtc2-ap-web-3.agora.io"],PROXY_CS:["ap-proxy-1.agora.io","ap-proxy-2.agora.io"],CDS_AP:["cds-ap-web-1.agora.io","cds-ap-web-3.agora.io"],ACCOUNT_REGISTER:["sua-ap-web-1.agora.io","sua-ap-web-3.agora.io"],UAP_AP:["uap-ap-web-1.agora.io","uap-ap-web-3.agora.io"],EVENT_REPORT_DOMAIN:["statscollector-1.agora.io"],EVENT_REPORT_BACKUP_DOMAIN:["statscollector-2.agora.io"],LOG_UPLOAD_SERVER:["logservice.agora.io"],PROXY_SERVER_TYPE3:["webrtc-cloud-proxy.sd-rtn.com"]},OCEANIA:{CODE:aI.OCEANIA,WEBCS_DOMAIN:["ap-web-1-oceania.agora.io"],WEBCS_DOMAIN_BACKUP_LIST:["ap-web-2-oceania.agora.io"],PROXY_CS:["proxy-ap-web-oceania.agora.io"],CDS_AP:["cds-ap-web-oceania.agora.io","cds-ap-web-oceania2.agora.io"],ACCOUNT_REGISTER:["sua-ap-web-oceania.agora.io","sua-ap-web-oceania2.agora.io"],UAP_AP:["uap-ap-web-oceania.agora.io","uap-ap-web-oceania2.agora.io"],EVENT_REPORT_DOMAIN:["statscollector-1-oceania.agora.io"],EVENT_REPORT_BACKUP_DOMAIN:["statscollector-2-oceania.agora.io"],LOG_UPLOAD_SERVER:["logservice-oceania.agora.io"],PROXY_SERVER_TYPE3:["oceania.webrtc-cloud-proxy.sd-rtn.com"]},SOUTH_AMERICA:{CODE:aI.SOUTH_AMERICA,WEBCS_DOMAIN:["ap-web-1-south-america.agora.io"],WEBCS_DOMAIN_BACKUP_LIST:["ap-web-2-south-america.agora.io"],PROXY_CS:["proxy-ap-web-south-america.agora.io"],CDS_AP:["cds-ap-web-south-america.agora.io","cds-ap-web-south-america2.agora.io"],ACCOUNT_REGISTER:["sua-ap-web-south-america.agora.io","sua-ap-web-south-america2.agora.io"],UAP_AP:["uap-ap-web-south-america.agora.io","uap-ap-web-south-america2.agora.io"],EVENT_REPORT_DOMAIN:["statscollector-1-south-america.agora.io"],EVENT_REPORT_BACKUP_DOMAIN:["statscollector-2-south-america.agora.io"],LOG_UPLOAD_SERVER:["logservice-south-america.agora.io"],PROXY_SERVER_TYPE3:["south-america.webrtc-cloud-proxy.sd-rtn.com"]},AFRICA:{CODE:aI.AFRICA,WEBCS_DOMAIN:["ap-web-1-africa.agora.io"],WEBCS_DOMAIN_BACKUP_LIST:["ap-web-2-africa.agora.io"],PROXY_CS:["proxy-ap-web-africa.agora.io"],CDS_AP:["cds-ap-web-africa.agora.io","cds-ap-web-africa2.agora.io"],ACCOUNT_REGISTER:["sua-ap-web-africa.agora.io","sua-ap-web-africa2.agora.io"],UAP_AP:["uap-ap-web-africa.agora.io","uap-ap-web-africa2.agora.io"],EVENT_REPORT_DOMAIN:["statscollector-1-africa.agora.io"],EVENT_REPORT_BACKUP_DOMAIN:["statscollector-2-africa.agora.io"],LOG_UPLOAD_SERVER:["logservice-south-africa.agora.io"],PROXY_SERVER_TYPE3:["africa.webrtc-cloud-proxy.sd-rtn.com"]},EXTENSIONS:{}};var dI,lI,hI,uI,pI,_I,EI,mI,fI,gI,TI,SI,RI,CI,vI,II,yI,AI,bI,wI,OI,NI;NC&&(cI.CHINA={CODE:aI.CHINA,WEBCS_DOMAIN:["webrtc2-2.ap.sd-rtn.com"],WEBCS_DOMAIN_BACKUP_LIST:["webrtc2-4.ap.sd-rtn.com"],PROXY_CS:["proxy-web.ap.sd-rtn.com"],CDS_AP:["cds-web-2.ap.sd-rtn.com","cds-web-4.ap.sd-rtn.com"],ACCOUNT_REGISTER:["sua-web-2.ap.sd-rtn.com","sua-web-4.ap.sd-rtn.com"],UAP_AP:["uap-web-2.ap.sd-rtn.com","uap-web-4.ap.sd-rtn.com"],EVENT_REPORT_DOMAIN:["web-3.statscollector.sd-rtn.com"],EVENT_REPORT_BACKUP_DOMAIN:["web-4.statscollector.sd-rtn.com"],LOG_UPLOAD_SERVER:["logservice-china.agora.io"],PROXY_SERVER_TYPE3:["east-cn.webrtc-cloud-proxy.sd-rtn.com"]}),function(e){e.UPDATE_BITRATE_LIMIT="update_bitrate_limit";}(dI||(dI={}));class DI extends iT{constructor(e,t){super(),nu(this,"onICEConnectionStateChange",void 0),nu(this,"onConnectionStateChange",void 0),nu(this,"onDTLSTransportStateChange",void 0),nu(this,"onDTLSTransportError",void 0),nu(this,"onICETransportStateChange",void 0),nu(this,"onFirstAudioReceived",void 0),nu(this,"onFirstVideoReceived",void 0),nu(this,"onFirstAudioDecoded",void 0),nu(this,"onFirstVideoDecoded",void 0),nu(this,"onFirstVideoDecodedTimeout",void 0),nu(this,"onSelectedLocalCandidateChanged",void 0),nu(this,"onSelectedRemoteCandidateChanged",void 0);}}class PI extends DI{constructor(e,t){super(e,t);}}!function(e){e.SEND="sendonly",e.RECV="recvonly",e.SENDRECV="sendrecv",e.INACTIVE="inactive";}(lI||(lI={})),function(e){e.VIDEO="video",e.AUDIO="audio";}(hI||(hI={})),function(e){e[e.UDP=0]="UDP",e[e.TCP=1]="TCP",e[e.RELAY=2]="RELAY";}(uI||(uI={})),function(e){e[e.FIRST_CONNECTION=0]="FIRST_CONNECTION",e[e.TCP_RESTART=1]="TCP_RESTART",e[e.RELAY_RESTART=2]="RELAY_RESTART",e[e.OLD_FIRST_CONNECTION=10]="OLD_FIRST_CONNECTION",e[e.OLD_RESTART=11]="OLD_RESTART",e[e.DISCONNECTED_OR_FAILED=20]="DISCONNECTED_OR_FAILED";}(pI||(pI={})),function(e){e.LocalVideoTrack="videoTrack",e.LocalAudioTrack="audioTrack",e.LocalVideoLowTrack="videoLowTrack";}(_I||(_I={})),function(e){e.New="new",e.Connected="connected",e.Reconnecting="reconnecting",e.Disconnected="disconnected";}(EI||(EI={})),function(e){e.StateChange="stateChange",e.IceConnectionStateChange="iceConnectionStateChange",e.RequestMuteLocal="requestMuteLocal",e.RequestUnmuteLocal="requestUnmuteLocal",e.RequestRePublish="requestRePublish",e.RequestRePublishDataChannel="requestRePublishDataChannel",e.RequestReSubscribe="requestReSubscribe",e.RequestUploadStats="requestUploadStats",e.MediaReconnectStart="MediaReconnectStart",e.MediaReconnectEnd="MediaReconnectEnd",e.NeedSignalRTT="NeedSignalRTT",e.RequestRestartICE="RequestRestartIce",e.PeerConnectionStateChange="PeerConnectionStateChange",e.RequestReconnect="RequestReconnect",e.RequestReconnectPC="RequestReconnectPC",e.RequestUnpublishForReconnectPC="RequestUnpublishForReconnectPC",e.P2PLost="P2PLost",e.UpdateVideoEncoder="UpdateVideoEncoder",e.ConnectionTypeChange="ConnectionTypeChange",e.RequestLowStreamParameter="RequestLowStreamParameter",e.QueryClientConnectionState="QueryClientConnectionState",e.LocalCandidate="LocalCandidate",e.RequestP2PMuteLocal="requestP2PMuteLocal",e.RequestP2PPublish="RequestP2PPublish",e.RequestP2PUnPublish="RequestP2PUnPublish",e.RequestP2PUnmuteRemote="RequestP2PUnmuteRemote",e.RequestP2PMuteRemote="RequestP2PMuteRemote",e.RequestP2PRestartICE="RequestP2PRestartICE";}(mI||(mI={})),function(e){e.MUTE_LOCAL_VIDEO="mute_local_video",e.MUTE_LOCAL_AUDIO="mute_local_audio",e.UNMUTE_LOCAL_VIDEO="unmute_local_video",e.UNMUTE_LOCAL_AUDIO="unmute_local_audio",e.MUTE_REMOTE_VIDEO="mute_remote_video",e.MUTE_REMOTE_AUDIO="mute_remote_audio",e.UNMUTE_REMOTE_VIDEO="unmute_remote_video",e.UNMUTE_REMOTE_AUDIO="unmute_remote_audio";}(fI||(fI={})),function(e){e.CONNECTING="CONNECTING",e.RECONNECTING="RECONNECTING",e.CONNECTED="CONNECTED",e.CLOSED="CLOSED";}(gI||(gI={})),function(e){e[e.CONNECT_AP=0]="CONNECT_AP",e[e.AP_CONNECTED=1]="AP_CONNECTED",e[e.CONNECT_WORKER_MANAGER=2]="CONNECT_WORKER_MANAGER",e[e.WORKER_MANAGER_CONNECTED=3]="WORKER_MANAGER_CONNECTED",e[e.GET_WORKER_MANAGER_RESPONSE=4]="GET_WORKER_MANAGER_RESPONSE",e[e.CONNECT_WORKER=5]="CONNECT_WORKER",e[e.WORKER_CONNECTED=6]="WORKER_CONNECTED",e[e.CLOSED=7]="CLOSED";}(TI||(TI={})),function(e){e.CONNECTION_STATE_CHANGE="connection-state-change",e.STATE_CHANGE="state-change",e.INSPECT_RESULT="inspect-result",e.CLIENT_LOCAL_VIDEO_TRACK="client-local-video-track",e.REQUEST_NEW_WORKER_URL="request-new-worker-url";}(SI||(SI={})),function(e){e.NETWORK_ERROR="NETWORK_ERROR",e.SERVER_ERROR="SERVER_ERROR",e.MULTI_IP="MULTI_IP",e.TIMEOUT="TIMEOUT",e.OFFLINE="OFFLINE",e.LEAVE="LEAVE",e.P2P_FAILED="P2P_FAILED",e.FALLBACK="FALLBACK";}(RI||(RI={})),function(e){e.CONNECTED="transmitter:connected",e.RECONNECTING="transmitter:reconnecting",e.WILL_RECONNECT="transmitter:will_reconnect",e.CLOSED="transmitter:closed",e.FAILED="transmitter:failed",e.ON_MESSAGE="transmitter:on_message",e.REQUEST_NEW_URLS="transmitter:request_new_urls",e.RECONNECT_WAITTING_FINISH="transmitter:reconnect_waitting_finish",e.RECONNECT_CREATE_CONNECTION="transmitter:reconnect_create_connection",e.ON_TOKEN_PRIVILEGE_DID_EXPIRE="transmitter:on_token_privilege_did_expire",e.TO_CONNECT_DATACHANNEL="transmitter:to_connect_datachannel",e.FAILBACK="transmitter:failback";}(CI||(CI={})),function(e){e.CAMERA_CHANGED="camera-changed",e.MICROPHONE_CHANGED="microphone-changed",e.PLAYBACK_DEVICE_CHANGED="playback-device-changed",e.AUDIO_AUTOPLAY_FAILED="audio-autoplay-failed",e.AUTOPLAY_FAILED="autoplay-failed",e.SECURITY_POLICY_VIOLATION="security-policy-violation";}(vI||(vI={})),function(e){e[e.APP_TYPE_INVALID_VALUE=-1]="APP_TYPE_INVALID_VALUE",e[e.APP_TYPE_NATIVE=0]="APP_TYPE_NATIVE",e[e.APP_TYPE_NATIVE_COCOS=1]="APP_TYPE_NATIVE_COCOS",e[e.APP_TYPE_NATIVE_UNITY=2]="APP_TYPE_NATIVE_UNITY",e[e.APP_TYPE_NATIVE_ELECTRON=3]="APP_TYPE_NATIVE_ELECTRON",e[e.APP_TYPE_NATIVE_FLUTTER=4]="APP_TYPE_NATIVE_FLUTTER",e[e.APP_TYPE_NATIVE_UNREAL=5]="APP_TYPE_NATIVE_UNREAL",e[e.APP_TYPE_NATIVE_XAMARIN=6]="APP_TYPE_NATIVE_XAMARIN",e[e.APP_TYPE_NATIVE_API_CLOUD=7]="APP_TYPE_NATIVE_API_CLOUD",e[e.APP_TYPE_NATIVE_REACT_NATIVE=8]="APP_TYPE_NATIVE_REACT_NATIVE",e[e.APP_TYPE_NATIVE_PYTHON=9]="APP_TYPE_NATIVE_PYTHON",e[e.APP_TYPE_NATIVE_COCOS_CREATOR=10]="APP_TYPE_NATIVE_COCOS_CREATOR",e[e.APP_TYPE_NATIVE_RUST=11]="APP_TYPE_NATIVE_RUST",e[e.APP_TYPE_NATIVE_C_SHARP=12]="APP_TYPE_NATIVE_C_SHARP",e[e.APP_TYPE_NATIVE_CEF=13]="APP_TYPE_NATIVE_CEF",e[e.APP_TYPE_NATIVE_UNI_APP=14]="APP_TYPE_NATIVE_UNI_APP",e[e.APP_TYPE_WEBRTC=1e3]="APP_TYPE_WEBRTC",e[e.APP_TYPE_WEBRTC_REACT=1001]="APP_TYPE_WEBRTC_REACT",e[e.APP_TYPE_WEBRTC_VUE=1002]="APP_TYPE_WEBRTC_VUE",e[e.APP_TYPE_WEBRTC_ANGULAR=1003]="APP_TYPE_WEBRTC_ANGULAR";}(II||(II={})),function(e){e.CONNECTING="CONNECTING",e.RECONNECTING="RECONNECTING",e.CONNECTED="CONNECTED",e.CLOSED="CLOSED";}(yI||(yI={})),function(e){e.CONNECTION_STATE_CHANGE="connection-state-change",e.STATE_CHANGE="state-change",e.INSPECT_RESULT="inspect-result",e.CLIENT_LOCAL_VIDEO_TRACK="client-local-video-track",e.REQUEST_NEW_WORKER_URL="request-new-worker-url";}(AI||(AI={})),function(e){e[e.CONNECT_AP=0]="CONNECT_AP",e[e.AP_CONNECTED=1]="AP_CONNECTED",e[e.CONNECT_WORKER_MANAGER=2]="CONNECT_WORKER_MANAGER",e[e.WORKER_MANAGER_CONNECTED=3]="WORKER_MANAGER_CONNECTED",e[e.GET_WORKER_MANAGER_RESPONSE=4]="GET_WORKER_MANAGER_RESPONSE",e[e.CONNECT_WORKER=5]="CONNECT_WORKER",e[e.WORKER_CONNECTED=6]="WORKER_CONNECTED",e[e.CLOSED=7]="CLOSED";}(bI||(bI={})),function(e){e.CALL="call",e.CANDIDATE="candidate",e.PUBLISH="publish",e.UNPUBLISH="unpublish",e.SUBSCRIBE="subscribe",e.UNSUBSCRIBE="unsubscribe",e.CONTROL="control",e.RESTART_ICE="restart_ice",e.ACK="ack",e.JOIN="join",e.EXCHANGE_SDP="exchange_sdp",e.DO_SUBSCRIBE="do_subscribe",e.DO_UNSUBSCRIBE="do_unsubscribe";}(wI||(wI={})),function(e){e.MUTE_LOCAL_AUDIO="mute_local_audio",e.MUTE_LOCAL_VIDEO="mute_local_video",e.UNMUTE_LOCAL_AUDIO="unmute_local_audio",e.UNMUTE_LOCAL_VIDEO="unmute_local_video";}(OI||(OI={})),function(e){e[e.SUCCESS=1]="SUCCESS",e[e.FAILED=0]="FAILED";}(NI||(NI={}));const LI={[uv.ACCESS_POINT]:{[Ev.NO_FLAG_SET]:{desc:"flag is zero",retry:!1},[Ev.FLAG_SET_BUT_EMPTY]:{desc:"flag is empty",retry:!1},[Ev.INVALID_FALG_SET]:{desc:"invalid flag",retry:!1},[Ev.FLAG_SET_BUT_NO_RE]:{desc:"flag set unilbs but no request",retry:!1},[Ev.INVALID_SERVICE_ID]:{desc:"invalid service id",retry:!1},[Ev.NO_SERVICE_AVAILABLE]:{desc:"no service available",retry:!0},[Ev.NO_SERVICE_AVAILABLE_P2P]:{desc:"no unilbs p2p service available",retry:!0},[Ev.NO_SERVICE_AVAILABLE_VOICE]:{desc:"no unilbs voice service available",retry:!0},[Ev.NO_SERVICE_AVAILABLE_WEBRTC]:{desc:"no unilbs webrtc service available",retry:!0},[Ev.NO_SERVICE_AVAILABLE_CDS]:{desc:"no cds service available",retry:!0},[Ev.NO_SERVICE_AVAILABLE_CDN]:{desc:"no cdn dispatcher service available",retry:!0},[Ev.NO_SERVICE_AVAILABLE_TDS]:{desc:"no tds service available",retry:!0},[Ev.NO_SERVICE_AVAILABLE_REPORT]:{desc:"no unilbs report service available",retry:!0},[Ev.NO_SERVICE_AVAILABLE_APP_CENTER]:{desc:"no app center service available",retry:!0},[Ev.NO_SERVICE_AVAILABLE_ENV0]:{desc:"no unilbs sig env0 service available",retry:!0},[Ev.NO_SERVICE_AVAILABLE_VOET]:{desc:"no unilbs voet service available",retry:!0},[Ev.NO_SERVICE_AVAILABLE_STRING_UID]:{desc:"no string uid service available",retry:!0},[Ev.NO_SERVICE_AVAILABLE_WEBRTC_UNILBS]:{desc:"no webrtc unilbs service available",retry:!0}},[uv.UNILBS]:{[_v.INVALID_VENDOR_KEY]:{desc:"invalid vendor key, can not find appid",retry:!1},[_v.INVALID_CHANNEL_NAME]:{desc:"invalid channel name",retry:!1},[_v.INTERNAL_ERROR]:{desc:"unilbs internal error",retry:!1},[_v.NO_AUTHORIZED]:{desc:"invalid token, authorized failed",retry:!1},[_v.DYNAMIC_KEY_TIMEOUT]:{desc:"dynamic key or token timeout",retry:!1},[_v.NO_ACTIVE_STATUS]:{desc:"no active status",retry:!1},[_v.DYNAMIC_KEY_EXPIRED]:{desc:"dynamic key expired",retry:!1},[_v.STATIC_USE_DYNAMIC_KEY]:{desc:"static use dynamic key",retry:!1},[_v.DYNAMIC_USE_STATIC_KEY]:{desc:"dynamic use static key",retry:!1},[_v.USER_OVERLOAD]:{desc:"amount of users over load",retry:!1},[_v.FORBIDDEN_REGION]:{desc:"the request is forbidden in this area",retry:!1},[_v.CANNOT_MEET_AREA_DEMAND]:{desc:"unable to allocate services in this area",retry:!1}},[uv.STRING_UID_ALLOCATOR]:{[pv.IIIEGAL_APPID]:{desc:"invalid appid",retry:!1},[pv.IIIEGAL_UID]:{desc:"invalid string uid",retry:!1},[pv.INTERNAL_ERROR]:{desc:"string uid allocator internal error",retry:!0}}};function kI(e){const t=LI[Math.floor(e/1e4)];if(!t)return {desc:"unkonw error",retry:!1};const i=t[e%1e4];if(!i){if(Math.floor(e/1e4)===uv.ACCESS_POINT){const t=e%1e4;if("1"===t.toString()[0])return {desc:e.toString(),retry:!1};if("2"===t.toString()[0])return {desc:e.toString(),retry:!0}}return {desc:"unkonw error",retry:!1}}return i}const MI={[mv.K_TIMESTAMP_EXPIRED]:{desc:"K_TIMESTAMP_EXPIRED",action:"failed"},[mv.K_CHANNEL_PERMISSION_INVALID]:{desc:"K_CHANNEL_PERMISSION_INVALID",action:"failed"},[mv.K_CERTIFICATE_INVALID]:{desc:"K_CERTIFICATE_INVALID",action:"failed"},[mv.K_CHANNEL_NAME_EMPTY]:{desc:"K_CHANNEL_NAME_EMPTY",action:"failed"},[mv.K_CHANNEL_NOT_FOUND]:{desc:"K_CHANNEL_NOT_FOUND",action:"failed"},[mv.K_TICKET_INVALID]:{desc:"K_TICKET_INVALID",action:"failed"},[mv.K_CHANNEL_CONFLICTED]:{desc:"K_CHANNEL_CONFLICTED",action:"failed"},[mv.K_SERVICE_NOT_READY]:{desc:"K_SERVICE_NOT_READY",action:"tryNext"},[mv.K_SERVICE_TOO_HEAVY]:{desc:"K_SERVICE_TOO_HEAVY",action:"tryNext"},[mv.K_UID_BANNED]:{desc:"K_UID_BANNED",action:"failed"},[mv.K_IP_BANNED]:{desc:"K_IP_BANNED",action:"failed"},[mv.K_AUTO_REBALANCE]:{desc:"k_AUTO_REBALANCE",action:"recover"},[mv.ERR_INVALID_VENDOR_KEY]:{desc:"ERR_INVALID_VENDOR_KEY",action:"failed"},[mv.ERR_INVALID_CHANNEL_NAME]:{desc:"ERR_INVALID_CHANNEL_NAME",action:"failed"},[mv.WARN_NO_AVAILABLE_CHANNEL]:{desc:"WARN_NO_AVAILABLE_CHANNEL",action:"failed"},[mv.WARN_LOOKUP_CHANNEL_TIMEOUT]:{desc:"WARN_LOOKUP_CHANNEL_TIMEOUT",action:"tryNext"},[mv.WARN_LOOKUP_CHANNEL_REJECTED]:{desc:"WARN_LOOKUP_CHANNEL_REJECTED",action:"failed"},[mv.WARN_OPEN_CHANNEL_TIMEOUT]:{desc:"WARN_OPEN_CHANNEL_TIMEOUT",action:"tryNext"},[mv.WARN_OPEN_CHANNEL_REJECTED]:{desc:"WARN_OPEN_CHANNEL_REJECTED",action:"failed"},[mv.WARN_REQUEST_DEFERRED]:{desc:"WARN_REQUEST_DEFERRED",action:"failed"},[mv.ERR_DYNAMIC_KEY_TIMEOUT]:{desc:"ERR_DYNAMIC_KEY_TIMEOUT",action:"failed"},[mv.ERR_NO_AUTHORIZED]:{desc:"ERR_NO_AUTHORIZED",action:"failed"},[mv.ERR_VOM_SERVICE_UNAVAILABLE]:{desc:"ERR_VOM_SERVICE_UNAVAILABLE",action:"tryNext"},[mv.ERR_NO_CHANNEL_AVAILABLE_CODE]:{desc:"ERR_NO_CHANNEL_AVAILABLE_CODE",action:"failed"},[mv.ERR_MASTER_VOCS_UNAVAILABLE]:{desc:"ERR_MASTER_VOCS_UNAVAILABLE",action:"tryNext"},[mv.ERR_INTERNAL_ERROR]:{desc:"ERR_INTERNAL_ERROR",action:"tryNext"},[mv.ERR_NO_ACTIVE_STATUS]:{desc:"ERR_NO_ACTIVE_STATUS",action:"failed"},[mv.ERR_INVALID_UID]:{desc:"ERR_INVALID_UID",action:"failed"},[mv.ERR_DYNAMIC_KEY_EXPIRED]:{desc:"ERR_DYNAMIC_KEY_EXPIRED",action:"failed"},[mv.ERR_STATIC_USE_DYANMIC_KE]:{desc:"ERR_STATIC_USE_DYANMIC_KE",action:"failed"},[mv.ERR_DYNAMIC_USE_STATIC_KE]:{desc:"ERR_DYNAMIC_USE_STATIC_KE",action:"failed"},[mv.ERR_NO_VOCS_AVAILABLE]:{desc:"ERR_NO_VOCS_AVAILABLE",action:"tryNext"},[mv.ERR_NO_VOS_AVAILABLE]:{desc:"ERR_NO_VOS_AVAILABLE",action:"tryNext"},[mv.ERR_JOIN_CHANNEL_TIMEOUT]:{desc:"ERR_JOIN_CHANNEL_TIMEOUT",action:"tryNext"},[mv.ERR_JOIN_BY_MULTI_IP]:{desc:"ERR_JOIN_BY_MULTI_IP",action:"recover"},[mv.ERR_NOT_JOINED]:{desc:"ERR_NOT_JOINED",action:"failed"},[mv.ERR_REPEAT_JOIN_REQUEST]:{desc:"ERR_REPEAT_JOIN_REQUEST",action:"quit"},[mv.ERR_REPEAT_JOIN_CHANNEL]:{desc:"ERR_REPEAT_JOIN_CHANNEL",action:"quit"},[mv.ERR_INVALID_STRINGUID]:{desc:"ERR_INVALID_STRINGUID",action:"failed"},[mv.ERR_TOO_MANY_USERS]:{desc:"ERR_TOO_MANY_USERS",action:"tryNext"},[mv.ERR_SET_CLIENT_ROLE_TIMEOUT]:{desc:"ERR_SET_CLIENT_ROLE_TIMEOUT",action:"failed"},[mv.ERR_SET_CLIENT_ROLE_NO_PERMISSION]:{desc:"ERR_SET_CLIENT_ROLE_TIMEOUT",action:"failed"},[mv.ERR_SET_CLIENT_ROLE_ALREADY_IN_USE]:{desc:"ERR_SET_CLIENT_ROLE_ALREADY_IN_USE",action:"success"},[mv.ERR_PUBLISH_REQUEST_INVALID]:{desc:"ERR_PUBLISH_REQUEST_INVALID",action:"failed"},[mv.ERR_SUBSCRIBE_REQUEST_INVALID]:{desc:"ERR_SUBSCRIBE_REQUEST_INVALID",action:"failed"},[mv.ERR_NOT_SUPPORTED_MESSAGE]:{desc:"ERR_NOT_SUPPORTED_MESSAGE",action:"failed"},[mv.ERR_ILLEAGAL_PLUGIN]:{desc:"ERR_ILLEAGAL_PLUGIN",action:"failed"},[mv.ILLEGAL_CLIENT_ROLE_LEVEL]:{desc:"ILLEGAL_CLIENT_ROLE_LEVEL",action:"failed"},[mv.ERR_REJOIN_TOKEN_INVALID]:{desc:"ERR_REJOIN_TOKEN_INVALID",action:"failed"},[mv.ERR_REJOIN_USER_NOT_JOINED]:{desc:"ERR_REJOIN_NOT_JOINED",action:"failed"},[mv.ERR_INVALID_OPTIONAL_INFO]:{desc:"ERR_INVALID_OPTIONAL_INFO",action:"quit"},[mv.ERR_TEST_RECOVER]:{desc:"ERR_TEST_RECOVER",action:"recover"},[mv.ERR_TEST_TRYNEXT]:{desc:"ERR_TEST_TRYNEXT",action:"recover"},[mv.ERR_TEST_RETRY]:{desc:"ERR_TEST_RETRY",action:"recover"},[mv.ILLEGAL_AES_PASSWORD]:{desc:"ERR_TEST_RETRY",action:"failed"},[mv.ERR_TOO_MANY_BROADCASTERS]:{desc:"ERR_TOO_MANY_BROADCASTERS",action:"failed"},[mv.ERR_TOO_MANY_SUBSCRIBERS]:{desc:"ERR_TOO_MANY_SUBSCRIBERS",action:"failed"},[mv.ERR_LICENSE_ILLEGAL]:{desc:"ERR_LICENSE_ILLEGAL",action:"quit"},[mv.ERR_LICENSE_MISSING]:{desc:"ERR_LICENSE_MISSING",action:"quit"},[mv.ERR_LICENSE_EXPIRED]:{desc:"ERR_LICENSE_EXPIRED",action:"quit"},[mv.ERR_LICENSE_MINUTES_EXCEEDED]:{desc:"ERR_LICENSE_MINUTES_EXCEEDED",action:"quit"},[mv.ERR_LICENSE_PERIOD_INVALID]:{desc:"ERR_LICENSE_PERIOD_INVALID",action:"quit"},[mv.ERR_LICENSE_MULTIPLE_SDK_SERVICE]:{desc:"ERR_LICENSE_MULTIPLE_SDK_SERVICE",action:"quit"}};function UI(e){const t=MI[e];return t||{desc:"UNKNOW_ERROR_".concat(e),action:"failed"}}function xI(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n);}return i}function VI(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?xI(Object(i),!0).forEach((function(t){nu(e,t,i[t]);})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):xI(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t));}));}return e}function FI(e){return e.every((e=>e.readyState===WebSocket.CLOSED||e.readyState===WebSocket.CLOSING))}function BI(e,t){if("string"==typeof e)return e;const{proxy:i,host:n,port:r}=e;if(t){const e=kC("JOIN_GATEWAY_FALLBACK_PORT")||443;return 443===e?"wss://".concat(n,"/ws/?p=").concat(Number(r)+150):"wss://".concat(n,":").concat(e,"/ws/?p=").concat(Number(r)+150)}return i?"wss://".concat(i,"/ws/?h=").concat(n,"&p=").concat(r):"wss://".concat(n,":").concat(r)}const jI=/wss:\/\/(.+)\/ws\/\?h=(.+)&p=([0-9]+)\/?/,GI=/wss:\/\/(.+)\/ws\/\?p=([0-9]+)\/?/,WI=/wss:\/\/(.+):([0-9]+)\/?/,HI=/wss:\/\/(.[^\/]+)\/?/;let KI=0;class YI{constructor(e,t){nu(this,"id",0),nu(this,"store",void 0),nu(this,"recordIndex",void 0),nu(this,"websockets",[]),nu(this,"try443PortDuration",2e3),nu(this,"forceCloseWSDuration",5e3),nu(this,"try443PortTimeout",null),nu(this,"forceCloseTimeout",null),nu(this,"isTry443PortFailed",!1),nu(this,"isNormalPortFailed",!1),nu(this,"useDoubleDomain",!1),nu(this,"useProxy",!1),nu(this,"startTime",Date.now()),this.id=++KI,this.try443PortDuration=kC("JOIN_GATEWAY_TRY_443PORT_DURATION")||2e3,this.forceCloseWSDuration=e||5e3,this.store=t;}closeAllWebsockets(){this.websockets.forEach((e=>{e.onopen=null,e.onclose=null,e.onmessage=null,e.close();})),this.websockets.length=0;}clearTimeout(){this.forceCloseTimeout&&clearTimeout(this.forceCloseTimeout),this.try443PortTimeout&&clearTimeout(this.try443PortTimeout);}logger(){var e;const t=Date.now()-this.startTime;for(var i=arguments.length,n=new Array(i),r=0;r<i;r++)n[r]=arguments[r];KC.debug("[choose-best-ws ".concat(null===(e=this.store)||void 0===e?void 0:e.clientId," ").concat(this.id,"] ").concat(t,"ms:"),...n);}createWebSocket(e,t,i){this.logger("createWebSocket:",e,{isTry443Port:t,hasTimeoutDetection:i});const n=kC("GATEWAY_DOMAINS"),r=Date.now(),s=[],o=n.find((t=>{var i;return Pr(i=e.host).call(i,t)}));o||(this.useDoubleDomain=!1);const a=[];if(this.useDoubleDomain)n.forEach((i=>{a.push(BI(VI(VI({},e),{},{host:e.host.replace(o,i)}),t));}));else {const i=VI({},e);if(t&&o){const e=n.find((e=>e!==o));e&&(i.host=i.host.replace(o,e));}a.push(BI(i,t));}try{a.forEach((e=>{const t=new WebSocket(e);t.binaryType="arraybuffer",s.push(t),this.logger("ws is connecting:",t.url);}));}catch(n){if(this.logger("ws create failed"),s.forEach((e=>e.close())),s.length=0,this.useDoubleDomain)return this.useDoubleDomain=!1,this.createWebSocket(e,t,i);if(!t&&443!==Number(e.port))return this.createWebSocket(e,!0,i);throw new xv(xg.WS_ERR,"init websocket failed! Error: ".concat(n.toString()))}const c=ng();this.store&&this.store.recordJoinChannelService({urls:s.map((e=>e.url)),service:"gateway"},this.recordIndex),s.forEach((e=>{e.onopen=()=>{this.logger("onopen: ws ".concat(e.url," open cost ").concat(Date.now()-r,"ms")),this.websockets.forEach((t=>{t!==e&&(t.onopen=null,t.onclose=null,t.onmessage=null,t.close(),this.logger("close backup websocket: ".concat(t.url)));})),this.websockets.length=0,c.resolve(e);},e.onclose=i=>{this.logger("onclose: ws ".concat(e.url," closed cost ").concat(Date.now()-r,"ms state: ").concat(e.readyState)),t?this.isTry443PortFailed=FI(s):this.isNormalPortFailed=FI(s),this.logger("443: ".concat(this.useProxy?"not try":this.isTry443PortFailed?"failed":"trying"," 47xx: ").concat(this.isNormalPortFailed?"failed":"trying")),(t&&this.isTry443PortFailed||!t&&(this.isTry443PortFailed||this.useProxy)&&this.isNormalPortFailed)&&(this.logger("onclose: all websocket is closed, ".concat(i.reason)),c.reject({code:i.code,reason:tI.A_ROUND_WS_FAILED}));},e.onmessage=t=>this.logger("".concat(e.url," onmessage: ").concat(t.data));})),this.websockets.push(...s);return i||(()=>{const i=()=>{this.logger("5s timeout close un-opens, isWebsocket created: ",c.isResolved),this.websockets.forEach((e=>e.readyState!==WebSocket.OPEN&&e.close()));};if(t||this.useProxy)return this.logger("add 5s timeout at ".concat(t?"try-443":"proxy"," condition")),this.forceCloseTimeout=window.setTimeout(i,this.forceCloseWSDuration);this.try443PortTimeout=window.setTimeout((()=>{if(this.logger("2s timeout, isWebsocket created: ",c.isResolved),c.isResolved)return i();pg().os===ag.MAC_OS&&Rg()&&i(),this.createWebSocket(e,!0,!0).then((e=>c.resolve(e))).catch((e=>{this.isNormalPortFailed&&c.reject(e),this.logger("try 443 port to create ws failed");})),this.forceCloseTimeout=window.setTimeout(i,this.forceCloseWSDuration);}),this.try443PortDuration);})(),c.promise}chooseBestWebsocket(e,t,i,n){return this.useDoubleDomain=!!t,"string"==typeof e&&(e=function(e){let t,i,n;return [,t,i,n]=e.match(jI)||[],t||([,i,n]=e.match(GI)||[]),i&&n||([,i,n]=e.match(WI)||[]),i&&n||([,i]=e.match(HI)||[]),i||KC.warning("un-destructible url: ",e),{proxy:t,host:i,port:n||"443"}}(e)),this.recordIndex=n,this.useProxy=!!e.proxy,i&&this.useProxy&&(KC.warn("cannot use 443 only when use proxy"),i=!1),this.createWebSocket(e,!!i,!1).finally((()=>this.clearTimeout()))}}function qI(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n);}return i}class JI extends iT{get url(){return this.websocket&&this.websocket.url||null}get reconnectMode(){return this._reconnectMode}set reconnectMode(e){var t;Pr(t=["tryNext","recover"]).call(t,e)&&this.resetReconnectCount(e),this._reconnectMode=e;}get state(){return this._state}set state(e){e!==this._state&&(this._state=e,"reconnecting"===this._state?this.emit(Iv.RECONNECTING,this.reconnectReason):"connected"===this._state?this.emit(Iv.CONNECTED):"closed"===this._state?this.emit(Iv.CLOSED):"failed"===this._state&&this.emit(Iv.FAILED));}resetReconnectCount(e){KC.debug("websocket reset reconnect count, reason: "+e),this.reconnectCount=0;}constructor(e,t){let i=arguments.length>2&&void 0!==arguments[2]&&arguments[2],n=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=arguments.length>4&&void 0!==arguments[4]&&arguments[4],s=arguments.length>5?arguments[5]:void 0;super(),nu(this,"connectionID",0),nu(this,"currentURLIndex",0),nu(this,"urls",[]),nu(this,"_reconnectMode","tryNext"),nu(this,"reconnectReason",void 0),nu(this,"_initMutex",new YT("websocket")),nu(this,"name",void 0),nu(this,"_state","closed"),nu(this,"reconnectInterrupter",void 0),nu(this,"websocket",void 0),nu(this,"retryConfig",void 0),nu(this,"reconnectCount",0),nu(this,"forceCloseTimeout",5e3),nu(this,"onlineReconnectListener",void 0),nu(this,"useCompress",void 0),nu(this,"tryDoubleDomain",!1),nu(this,"use443PortOnly",!1),nu(this,"wsInflateLength",0),nu(this,"wsDeflateLength",0),nu(this,"closeEstablishingWs",(()=>{})),nu(this,"store",void 0),nu(this,"joinGatewayRecordIndex",void 0),this.store=s,this.name=e,this.retryConfig=function(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?qI(Object(i),!0).forEach((function(t){nu(e,t,i[t]);})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):qI(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t));}));}return e}({},t),this.useCompress=i,this.tryDoubleDomain=n,this.use443PortOnly=r;const{timeout:o,timeoutFactor:a}=t,c=Math.max(300,Math.floor(3*o/5)),d=Math.max(1.2,Math.floor(8*a)/10);hT.ONLINE&&(this.retryConfig.timeout=c,this.retryConfig.timeoutFactor=d),RT.on(uT.NETWORK_STATE_CHANGE,((e,t)=>{e!==t&&(this.resetReconnectCount("network state change: ".concat(t," -> ").concat(e)),e===hT.ONLINE?(this.retryConfig.timeout=c,this.retryConfig.timeoutFactor=d):(this.retryConfig.timeout=o,this.retryConfig.timeoutFactor=a));}));}getConnection(){return this.websocket||void 0}async init(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:5e3;const i=await this._initMutex.lock();this.forceCloseTimeout=t,this.urls=e,this.state="connecting";try{const e=ng(),t=this.urls[this.currentURLIndex];this.createWebSocketConnection(t).then(e.resolve).catch(e.reject),this.once(Iv.CLOSED,(()=>{e.reject(new Vg(xg.WS_DISCONNECT));})),this.once(Iv.CONNECTED,e.resolve),await e.promise;}catch(e){}finally{i();}}close(e,t){if(this.currentURLIndex=0,this.resetReconnectCount("close"),this.reconnectInterrupter&&this.reconnectInterrupter(),this.websocket){this.websocket.onclose=null,this.websocket.onopen=null,this.websocket.onmessage=null;const e=this.websocket;t?setTimeout((()=>e.close()),500):e.close(),this.websocket=void 0;}this.state=e?"failed":"closed",this.closeEstablishingWs&&this.closeEstablishingWs();}reconnect(e,t){if(!this.websocket)return void KC.warning("[".concat(this.name,"] can not reconnect, no websocket"));void 0!==e&&(this.reconnectMode=e),KC.debug("[".concat(this.name,"] reconnect is triggered initiative")),"number"==typeof this.joinGatewayRecordIndex&&this.store&&this.store.recordJoinChannelService({status:"error",errors:[new Error(t)]},this.joinGatewayRecordIndex);const i=this.websocket.onclose;this.websocket.onclose=null,this.websocket.close(),i&&i.bind(this.websocket)({code:9999,reason:t});}sendMessage(e){let t=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(!this.websocket||this.websocket.readyState!==WebSocket.OPEN)throw new Vg(xg.WS_ABORT,"websocket is not ready");try{t||(e=JSON.stringify(e)),this.websocket.send(e);}catch(e){throw new Vg(xg.WS_ERR,"send websocket message error"+e.toString())}}setWsInflateData(e){this.wsDeflateLength=this.wsDeflateLength+e.originLength,this.wsInflateLength=this.wsInflateLength+e.compressedLength;}getWsInflateData(){const e=this.wsInflateLength,t=this.wsDeflateLength;return this.clearWsInflateData(),{wsInflateLength:e,wsDeflateLength:t}}clearWsInflateData(){this.wsInflateLength=0,this.wsDeflateLength=0;}async createWebSocketConnection(e){var t;const i=ng();this.connectionID+=1,this.joinGatewayRecordIndex=void 0;const n=e=>{var t;null===(t=this.store)||void 0===t||t.signalChannelOpen(),KC.debug("[".concat(this.name,"] websocket opened:"),e),this.reconnectMode="retry",this.state="connected",this.resetReconnectCount("opened"),i.resolve();},r=async e=>{var t;if(KC.debug("[".concat(this.name,"] websocket close ").concat(null===(t=this.websocket)||void 0===t?void 0:t.url,", code: ").concat(e.code,", reason: ").concat(e.reason,", current mode: ").concat(this.reconnectMode)),this.reconnectCount>=this.retryConfig.maxRetryCount)i.reject(new Vg(xg.WS_DISCONNECT,"websocket close: ".concat(e.code))),this.close();else {"connected"===this.state&&(this.reconnectReason=e.reason,this.state="reconnecting");const t=TT(this,Iv.WILL_RECONNECT,this.reconnectMode,e.reason)||this.reconnectMode,n=await this.reconnectWithAction(t);if("closed"===this.state)return void KC.debug("[".concat(this.connectionID,"] ws is closed, no need to reconnect"));if(!n)return i.reject(new Vg(xg.WS_DISCONNECT,"websocket reconnect failed: ".concat(e.code))),this.close(!0);i.resolve();}},s=e=>{this.emit(Iv.ON_MESSAGE,e);},o=e=>{KC.warn("[".concat(this.connectionID,"] ws open error ").concat(e));};this.websocket&&(this.websocket.onclose=null,this.websocket.close()),kC("GATEWAY_WSS_ADDRESS")&&this.name.startsWith("gateway")&&(e=kC("GATEWAY_WSS_ADDRESS")),KC.debug("[".concat(this.name,"] start connect, url:"),e);const a=null===(t=this.store)||void 0===t?void 0:t.recordJoinChannelService({startTs:Date.now(),status:"pending",service:"gateway"});try{var c;const t=await this.chooseBestWebsocketConnection(e);this.websocket=t,n&&n(this.websocket.url),this.websocket.onclose=r,this.websocket.onmessage=s,this.websocket.onerror=o,null===(c=this.store)||void 0===c||c.recordJoinChannelService({endTs:Date.now(),status:"success"},a),this.joinGatewayRecordIndex=a;}catch(e){const t="closed"===this.state,n=e instanceof Vg,s=n&&e.code===xg.WS_ABORT,o=n&&e.code===xg.WS_ERR,c=n?e.message:e&&(e.reason||e.toString());KC.warning("[choose-best-ws] chooseBestWebsocket error: ".concat(c)),this.store&&this.store.recordJoinChannelService({endTs:Date.now(),status:s?"aborted":"error",errors:[e]},a),t||o?(i.reject(t?new Vg(xg.WS_DISCONNECT,"websocket is closed: ".concat(c)):new Vg(xg.WS_ERR,"init websocket failed: ".concat(c))),o&&KC.error("[".concat(this.name,"] init websocket failed: ").concat(c))):r&&r(e);}return i.promise}async reconnectWithAction(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];if(this.reconnectCount>=this.retryConfig.maxRetryCount)return !1;if(0===this.urls.length)return !1;if("closed"===this.state)return !1;KC.warning("[choose-best-ws] action: =>",e),this.onlineReconnectListener||RT.isOnline||!RT.onlineWaiter||(this.onlineReconnectListener=RT.onlineWaiter.then((()=>{this.onlineReconnectListener=void 0;})));let i=!0;if(this.reconnectInterrupter=()=>i=!1,t){const t=zT(this.reconnectCount,this.retryConfig);KC.debug("[".concat(this.name,"] wait ").concat(t,"ms to reconnect websocket, mode: ").concat(e)),await tg.race([UT(t),this.onlineReconnectListener||new tg((()=>{}))]);}if("closed"===this._state||!i)return !1;this.reconnectCount+=1;const n=async(e,t)=>{this.emit(Iv.RECONNECT_CREATE_CONNECTION,t),await this.createWebSocketConnection(e);};try{if("retry"===e)this.emit(Iv.RECONNECT_WAITTING_FINISH,e),await n(this.urls[this.currentURLIndex],e);else if("tryNext"===e){if(this.currentURLIndex+=1,this.currentURLIndex>=this.urls.length)return this.reconnectWithAction("recover",!1);KC.debug("[".concat(this.name,"] websocket url length: ").concat(this.urls.length," current index: ").concat(this.currentURLIndex)),this.emit(Iv.RECONNECT_WAITTING_FINISH,e),await n(this.urls[this.currentURLIndex],e);}else "recover"===e&&(KC.debug("[".concat(this.name,"] request new urls")),this.resetReconnectCount("recover mode"),this.emit(Iv.RECONNECT_WAITTING_FINISH,e),this.urls=await fT(this,Iv.REQUEST_NEW_URLS),this.currentURLIndex=0,await n(this.urls[this.currentURLIndex],e));}catch(i){var r;KC.error("[".concat(this.name,"] reconnect failed ").concat(i&&i.toString()));const n=null==i||null===(r=i.data)||void 0===r?void 0:r.desc;return Array.isArray(n)&&Pr(n).call(n,"dynamic key expired")?(this.emit(Iv.ON_TOKEN_PRIVILEGE_DID_EXPIRE),!1):this.reconnectWithAction(e,t)}return !0}}class zI extends JI{constructor(e,t){super(e,t,arguments.length>2&&void 0!==arguments[2]&&arguments[2],arguments.length>3&&void 0!==arguments[3]&&arguments[3],arguments.length>4&&void 0!==arguments[4]&&arguments[4],arguments.length>5?arguments[5]:void 0);}async chooseBestWebsocketConnection(e,t){const i=ng(),n=function(e,t){return new YI(e,t)}(this.forceCloseTimeout,this.store);this.closeEstablishingWs=()=>{KC.debug("[choose-best-ws] close establishing websockets"),n.closeAllWebsockets(),i.reject(new Vg(xg.WS_ABORT,"choose best websocket aborted"));};const r=kC("GATEWAY_DOMAINS");return KC.debug("[choose-best-ws] currentDomain: ",e,", domains: ",r,"total: ".concat(this.urls.length),"current: ".concat(this.currentURLIndex+1)),n.chooseBestWebsocket(e,this.tryDoubleDomain,this.use443PortOnly,t).then(i.resolve).catch(i.reject),i.promise.finally((()=>{this.closeEstablishingWs=void 0;}))}}class XI extends JI{constructor(e,t){super(e,t,arguments.length>2&&void 0!==arguments[2]&&arguments[2],arguments.length>3&&void 0!==arguments[3]&&arguments[3],arguments.length>4&&void 0!==arguments[4]&&arguments[4],arguments.length>5?arguments[5]:void 0);}async chooseBestWebsocketConnection(e,t){return new tg(((i,n)=>{let r=!1;const s=[];this.closeEstablishingWs=()=>{KC.debug("[choose-best-ws] close establishing websockets"),s.forEach((e=>{e.onclose=null,e.onopen=null,e.onmessage=null,e.close();})),n(new Vg(xg.WS_ABORT,"choose best websocket aborted"));};const o=kC("GATEWAY_DOMAINS");let a;const c=e.indexOf("?h="),d=o.find((t=>-1!==c?Pr(e).call(e,t,c):Pr(e).call(e,t)));KC.debug("[choose-best-ws] currentDomain: ",d,", domains: ",o);let l=!this.tryDoubleDomain||!d;if(!l&&d){var h;const u=Date.now();try{o.forEach((t=>{const i=-1===c?e.replace(d,t):e.substr(0,c)+e.substr(c).replace(d,t),n=new WebSocket(i);n.binaryType="arraybuffer",s.push(n),KC.debug("[choose-best-ws] ws is connecting:",n.url);}));}catch(e){for(KC.debug("[choose-best-ws] ws create failed, fallback to single url"),s.forEach((e=>e.close()));s.length;)s.pop();l=!0;}null===(h=this.store)||void 0===h||h.recordJoinChannelService({urls:s.map((e=>e.url)),service:"gateway"},t),s.forEach((e=>{e.onopen=()=>{if(r)return;const t=Date.now()-u;KC.debug("[choose-best-ws] ws open cost ".concat(t,"ms")),s.filter((t=>t!==e)).forEach((e=>{KC.debug("[choose-best-ws]close backup websocket: ".concat(e.url)),e.close();})),r=!0,i(e);},e.onclose=e=>{if(a=e,r)return;s.find((e=>!(e.readyState===WebSocket.CLOSED||e.readyState===WebSocket.CLOSING)))||(KC.debug("[choose-best-ws] all websocket is closed"),r=!0,n(a));},e.onmessage=t=>{KC.debug("[choose-best-ws]".concat(e.url," onmessage: ").concat(t.data));};})),UT(this.forceCloseTimeout).then((()=>{s.forEach((e=>{e.readyState!==WebSocket.OPEN&&e.close();}));}));}if(l){var u;let r;KC.debug("[choose-best-ws] use single url: ",e),null===(u=this.store)||void 0===u||u.recordJoinChannelService({urls:[e],service:"gateway"},t);try{r=new WebSocket(e),s.push(r),r.binaryType="arraybuffer";}catch(e){const t=new Vg(xg.WS_ERR,"init websocket failed! Error: ".concat(e.toString()));return KC.error("[".concat(this.name,"]").concat(t)),void n(t)}r.onopen=()=>{i(r);},r.onclose=e=>{n(e);},r.onmessage=e=>{KC.debug("[choose-best-ws]".concat(r.url," onmessage: ").concat(e.data));},UT(this.forceCloseTimeout).then((()=>{r&&r.readyState!==WebSocket.OPEN&&r.close();}));}})).then((e=>(this.closeEstablishingWs=void 0,e))).catch((e=>{throw this.closeEstablishingWs=void 0,e}))}}class QI extends iT{get connectionState(){return this._connectionState}set connectionState(e){e!==this._connectionState&&(this._connectionState=e,e===fv.CONNECTED?this.emit(gv.WS_CONNECTED):e===fv.RECONNECTING?this.emit(gv.WS_RECONNECTING,this._websocketReconnectReason):e===fv.CLOSED&&this.emit(gv.WS_CLOSED,this._disconnectedReason));}get currentURLIndex(){return this.websocket.currentURLIndex}get url(){return this.websocket&&this.websocket.url||null}get rtt(){return this.rttRolling.mean()}constructor(e,t){super(),nu(this,"_disconnectedReason",void 0),nu(this,"_websocketReconnectReason",void 0),nu(this,"_connectionState",fv.CLOSED),nu(this,"reconnectToken",void 0),nu(this,"websocket",void 0),nu(this,"openConnectionTime",void 0),nu(this,"clientId",void 0),nu(this,"lastMsgTime",Date.now()),nu(this,"uploadCache",[]),nu(this,"uploadCacheInterval",void 0),nu(this,"rttRolling",new dS(5)),nu(this,"pingpongTimer",void 0),nu(this,"wsInflateDataTimer",void 0),nu(this,"pingpongTimeoutCount",0),nu(this,"joinResponse",void 0),nu(this,"multiIpOption",void 0),nu(this,"initError",void 0),nu(this,"spec",void 0),nu(this,"store",void 0),nu(this,"onWebsocketMessage",(e=>{if(e.data instanceof ArrayBuffer)return void this.emit(gv.ON_BINARY_DATA,e.data);const t=JSON.parse(e.data);if(this.lastMsgTime=Date.now(),Object.prototype.hasOwnProperty.call(t,"_id")){const e="res-@".concat(t._id);this.emit(e,t._result,t._message);}else if(Object.prototype.hasOwnProperty.call(t,"_type")){if(this.emit(t._type,t._message),t._type===Rv.ON_NOTIFICATION&&this.handleNotification(t._message),t._type===Rv.ON_USER_BANNED)switch(t._message.error_code){case 14:this.close(cT.UID_BANNED);break;case 15:this.close(cT.IP_BANNED);break;case 16:this.close(cT.CHANNEL_BANNED);}if(t._type===Rv.ON_USER_LICENSE_BANNED)switch(t._message.error_code){case mv.ERR_LICENSE_MISSING:this.close(cT.LICENSE_MISSING);break;case mv.ERR_LICENSE_EXPIRED:this.close(cT.LICENSE_EXPIRED);break;case mv.ERR_LICENSE_MINUTES_EXCEEDED:this.close(cT.LICENSE_MINUTES_EXCEEDED);break;case mv.ERR_LICENSE_PERIOD_INVALID:this.close(cT.LICENSE_PERIOD_INVALID);break;case mv.ERR_LICENSE_MULTIPLE_SDK_SERVICE:this.close(cT.LICENSE_MULTIPLE_SDK_SERVICE);break;case mv.ERR_LICENSE_ILLEGAL:this.close(cT.LICENSE_ILLEGAL);break;default:this.close();}}})),this.clientId=e.clientId,this.spec=e,this.store=t,this.websocket=new zI("gateway-".concat(this.clientId),this.spec.retryConfig,!0,kC("JOIN_GATEWAY_USE_DUAL_DOMAIN"),kC("JOIN_GATEWAY_USE_443PORT_ONLY"),t),this.handleWebsocketEvents(),window.addEventListener("offline",(()=>{this.connectionState===fv.CONNECTED&&this.reconnect("retry",lT.OFFLINE);}));}async request(e,t,i,n){const r=xT(6,""),s={_id:r,_type:e,_message:t},o=this.websocket.connectionID,a=()=>new tg(((t,i)=>{if(this.connectionState===fv.CONNECTED)return t();const n=()=>{this.off(gv.WS_CLOSED,r),t();},r=()=>{this.off(gv.WS_CONNECTED,n),i(new xv(xg.WS_ABORT));};this.once(gv.WS_CONNECTED,n),this.once(gv.WS_CLOSED,r),e!==Tv.PUBLISH&&e!==Tv.SUBSCRIBE&&e!==Tv.UNSUBSCRIBE&&e!==Tv.UNPUBLISH&&e!==Tv.CONTROL&&e!==Tv.RESTART_ICE||this.once(gv.DISCONNECT_P2P,(()=>{i(new xv(xg.DISCONNECT_P2P));})),e!==Tv.PUBLISH&&e!==Tv.RESTART_ICE||this.once(gv.ABORT_P2P_EXECUTION,(()=>{i(new xv(xg.DISCONNECT_P2P));}));}));if(this.connectionState!==fv.CONNECTING&&this.connectionState!==fv.RECONNECTING||e===Tv.JOIN||e===Tv.REJOIN||await a(),this.websocket.sendMessage(s,!0),n)return;const c=new tg(((i,n)=>{let s=!1;const a=(n,r)=>{s=!0,i({isSuccess:"success"===n,message:r||{}}),this.off(gv.WS_CLOSED,c),this.off(gv.WS_RECONNECTING,c),this.emit(gv.REQUEST_SUCCESS,e,t);};this.once("res-@".concat(r),a);const c=()=>{n(new xv(xg.WS_ABORT,"type: ".concat(e))),this.off(gv.WS_CLOSED,c),this.off(gv.WS_RECONNECTING,c),this.off("res-@".concat(r),a);};this.once(gv.WS_CLOSED,c),this.once(gv.WS_RECONNECTING,c),UT(kC("SIGNAL_REQUEST_TIMEOUT")).then((()=>{this.websocket.connectionID!==o||s||(KC.warning("[".concat(this.clientId,"] ws request timeout, type: ").concat(e)),this.emit(gv.REQUEST_TIMEOUT,e,t));}));}));let d=null;try{d=await c;}catch(n){if(this.connectionState===fv.CLOSED||e===Tv.LEAVE)throw new xv(xg.WS_ABORT);return !this.spec.forceWaitGatewayResponse||i?n.throw():e===Tv.JOIN||e===Tv.REJOIN?null:(await a(),await this.request(e,t))}if(d.isSuccess)return d.message;const l=Number(d.message.error_code||d.message.code),h=UI(l),u=new xv(xg.UNEXPECTED_RESPONSE,"".concat(h.desc,": ").concat(d.message.error_str),{code:l,data:d.message});return "success"===h.action?d.message:(KC.warning("[".concat(this.clientId,"] [").concat(this.websocket.connectionID,"] unexpected response from type ").concat(e,", error_code: ").concat(l,", message: ").concat(h.desc,", action: ").concat(h.action)),l===mv.ERR_TOO_MANY_BROADCASTERS?e===Tv.JOIN||e===Tv.REJOIN?(this.initError=u,this.close(),u.throw()):u.throw():"failed"===h.action?u.throw():"quit"===h.action?(this.initError=u,this.close(),u.throw()):(l===mv.ERR_JOIN_BY_MULTI_IP?(this.multiIpOption=d.message.option,KC.warning("[".concat(this.clientId,"] detect multi ip, recover")),this.reconnect("recover",lT.MULTI_IP)):this.reconnect(h.action,lT.SERVER_ERROR),e===Tv.JOIN||e===Tv.REJOIN?null:await this.request(e,t)))}waitMessage(e,t){return new tg((i=>{const n=r=>{(!t||t(r))&&(this.off(e,n),i(r));};this.on(e,n);}))}upload(e,t){const i={_type:e,_message:t};try{this.websocket.sendMessage(i);}catch(e){const t=kC("MAX_UPLOAD_CACHE")||50;this.uploadCache.push(i),this.uploadCache.length>t&&this.uploadCache.splice(0,1),this.uploadCache.length>0&&!this.uploadCacheInterval&&(this.uploadCacheInterval=window.setInterval((()=>{if(this.connectionState!==fv.CONNECTED)return;const e=this.uploadCache.splice(0,1)[0];0===this.uploadCache.length&&(window.clearInterval(this.uploadCacheInterval),this.uploadCacheInterval=void 0),this.upload(e._type,e._message);}),kC("UPLOAD_CACHE_INTERVAL")||2e3));}}send(e,t){const i={_type:e,_message:t};this.websocket.sendMessage(i);}init(e,t){return this.initError=void 0,this.multiIpOption=void 0,this.joinResponse=void 0,this.reconnectToken=void 0,this.openConnectionTime=void 0,new tg(((t,i)=>{this.once(gv.WS_CONNECTED,(()=>t(this.joinResponse))),this.once(gv.WS_CLOSED,(()=>i(this.initError||new xv(xg.WS_ABORT)))),this.connectionState=fv.CONNECTING,this.websocket.init(e).catch(i),this.wsInflateDataTimer&&window.clearInterval(this.wsInflateDataTimer),this.wsInflateDataTimer=window.setInterval((()=>{this.handleWsInflateData();}),2e4);}))}close(e){this.pingpongTimer&&(this.pingpongTimeoutCount=0,window.clearInterval(this.pingpongTimer),this.pingpongTimer=void 0),this.wsInflateDataTimer&&(this.handleWsInflateData(),window.clearInterval(this.wsInflateDataTimer),this.wsInflateDataTimer=void 0),this.reconnectToken=void 0,this.joinResponse=void 0,this._disconnectedReason=e||cT.LEAVE,this.connectionState=fv.CLOSED,KC.debug("[".concat(this.clientId,"] ")+"will close websocket in signal"),this.websocket.close(),e===cT.FALLBACK&&(this.websocket.removeAllListeners(),this.websocket=new zI("gateway-".concat(this.clientId),this.spec.retryConfig,!0,kC("JOIN_GATEWAY_USE_DUAL_DOMAIN"),kC("JOIN_GATEWAY_USE_443PORT_ONLY"),this.store),this.handleWebsocketEvents());}async join(){if(!this.joinResponse){this.emit(gv.ABORT_P2P_EXECUTION);const e=await fT(this,gv.REQUEST_JOIN_INFO),t=await this.request(Tv.JOIN,e);if(!t)return this.emit(gv.REPORT_JOIN_GATEWAY,tI.TIMEOUT,this.url||""),!1;this.joinResponse=t,this.emit(gv.JOIN_RESPONSE,this.joinResponse),this.reconnectToken=this.joinResponse.rejoin_token;}return this.connectionState=fv.CONNECTED,this.pingpongTimer&&window.clearInterval(this.pingpongTimer),this.pingpongTimer=window.setInterval(this.handlePingPong.bind(this),3e3),!0}async rejoin(){if(!this.reconnectToken)throw new xv(xg.UNEXPECTED_ERROR,"can not rejoin, no rejoin token");const e=ST(this,gv.REQUEST_REJOIN_INFO);e.token=this.reconnectToken;const t=await this.request(Tv.REJOIN,e);return !!t&&(this.connectionState=fv.CONNECTED,this.pingpongTimer&&window.clearInterval(this.pingpongTimer),this.pingpongTimer=window.setInterval(this.handlePingPong.bind(this),3e3),t.peers&&t.peers.forEach((e=>{this.emit(Rv.ON_USER_ONLINE,{uid:e.uid}),e.audio&&this.emit(Rv.ON_ADD_AUDIO_STREAM,{uid:e.uid,uint_id:e.uint_id,audio:!0,ssrcId:e.audio_ssrc}),e.video&&this.emit(Rv.ON_ADD_VIDEO_STREAM,{uid:e.uid,uint_id:e.uint_id,video:!0,ssrcId:e.video_ssrc}),e.audio_mute?this.emit(Rv.MUTE_AUDIO,{uid:e.uid}):this.emit(Rv.UNMUTE_AUDIO,{uid:e.uid}),e.video_mute?this.emit(Rv.MUTE_VIDEO,{uid:e.uid}):this.emit(Rv.UNMUTE_VIDEO,{uid:e.uid}),e.audio_enable_local?this.emit(Rv.ENABLE_LOCAL_AUDIO,{uid:e.uid}):this.emit(Rv.DISABLE_LOCAL_AUDIO,{uid:e.uid}),e.video_enable_local?this.emit(Rv.ENABLE_LOCAL_VIDEO,{uid:e.uid}):this.emit(Rv.DISABLE_LOCAL_VIDEO,{uid:e.uid}),e.audio||e.video||this.emit(Rv.ON_REMOVE_STREAM,{uid:e.uid,uint_id:e.uint_id});})),!0)}reconnect(e,t){this.pingpongTimer&&(this.pingpongTimeoutCount=0,window.clearInterval(this.pingpongTimer),this.pingpongTimer=void 0),this.websocket.reconnect(e,t);}handleNotification(e){KC.debug("[".concat(this.clientId,"] receive notification: "),e);const t=UI(e.code);if("success"!==t.action){if("failed"!==t.action)return "quit"===t.action?("ERR_REPEAT_JOIN_CHANNEL"===t.desc&&this.close(cT.UID_BANNED),void this.close()):void this.reconnect(t.action,lT.SERVER_ERROR);KC.error("[".concat(this.clientId,"] ignore error: "),t.desc);}}handlePingPong(){if(!this.websocket||"connected"!==this.websocket.state)return;this.pingpongTimeoutCount>0&&this.rttRolling.add(3e3),this.pingpongTimeoutCount+=1;const e=kC("PING_PONG_TIME_OUT"),t=Date.now();this.pingpongTimeoutCount>=e&&(KC.warning("[".concat(this.clientId,"] PING-PONG Timeout. Last Socket Message: ").concat(t-this.lastMsgTime,"ms")),t-this.lastMsgTime>kC("WEBSOCKET_TIMEOUT_MIN"))?this.reconnect("retry",lT.TIMEOUT):this.request(Tv.PING,void 0,!0).then((()=>{this.pingpongTimeoutCount=0;const e=Date.now()-t;this.rttRolling.add(e),kC("REPORT_STATS")&&this.send(Tv.PING_BACK,{pingpongElapse:e});})).catch((e=>{}));}handleWsInflateData(){const{wsInflateLength:e,wsDeflateLength:t}=this.websocket.getWsInflateData();0!==e&&0!==t&&this.upload(Sv.WS_INFLATE_DATA_LENGTH,{ws_deflate_length:t,ws_inflate_length:e});}handleWebsocketEvents(){this.websocket.on(Iv.RECONNECT_WAITTING_FINISH,(e=>{this.emit(gv.WS_RECONNECT_WAITTING_FINISH,e);})),this.websocket.on(Iv.RECONNECT_CREATE_CONNECTION,(e=>{this.emit(gv.WS_RECONNECT_CREATE_CONNECTION,e);})),this.websocket.on(Iv.ON_MESSAGE,this.onWebsocketMessage),this.websocket.on(Iv.CLOSED,(()=>{this.connectionState=fv.CLOSED;})),this.websocket.on(Iv.FAILED,(()=>{this._disconnectedReason=cT.NETWORK_ERROR,this.connectionState=fv.CLOSED;})),this.websocket.on(Iv.RECONNECTING,(e=>{this._websocketReconnectReason=e,this.joinResponse=void 0,this.connectionState===fv.CONNECTED?this.connectionState=fv.RECONNECTING:this.connectionState=fv.CONNECTING;})),this.websocket.on(Iv.WILL_RECONNECT,((e,t,i)=>{const n=ST(this,gv.IS_P2P_DISCONNECTED),r=n||"retry"!==e;n&&"retry"===e&&(KC.debug("".concat(this.clientId," reconnect mode is retry, but p2p lost, change to tryNext")),e="tryNext",t=tI.P2P_DISCONNECTED),r&&(KC.debug("".concat(this.clientId," will renewSession, reconnect mode: ").concat(e)),this.emit(gv.REPORT_JOIN_GATEWAY,t||tI.UNKNOWN_REASON,this.url||""),this.reconnectToken=void 0,this.emit(gv.NEED_RENEW_SESSION),this.emit(gv.DISCONNECT_P2P)),i(e);})),this.websocket.on(Iv.CONNECTED,(()=>{this.openConnectionTime=Date.now(),this.reconnectToken?this.rejoin().catch((e=>{KC.warning("[".concat(this.clientId,"] rejoin failed ").concat(e)),this.reconnect("tryNext",lT.SERVER_ERROR);})):this.join().catch((e=>{if(this.emit(gv.REPORT_JOIN_GATEWAY,e.message||e.code||tI.UNKNOWN_REASON,this.url||""),e instanceof xv&&e.code===xg.UNEXPECTED_RESPONSE&&e.data.code===mv.ERR_NO_AUTHORIZED)return KC.warning("[".concat(this.clientId,"] reconnect no authorized, recover")),void this.reconnect("recover",lT.SERVER_ERROR);KC.error("[".concat(this.clientId,"] join gateway request failed"),e.toString()),this.spec.forceWaitGatewayResponse?this.reconnect("tryNext",lT.SERVER_ERROR):(this.initError=e,this.close());}));})),this.websocket.on(Iv.REQUEST_NEW_URLS,((e,t)=>{fT(this,gv.REQUEST_RECOVER,this.multiIpOption).then(e).catch(t);})),this.websocket.on(Iv.ON_TOKEN_PRIVILEGE_DID_EXPIRE,(()=>{this.emit(Rv.ON_TOKEN_PRIVILEGE_DID_EXPIRE);}));}}var ZI="\t\n\v\f\r                　\u2028\u2029\ufeff",$I=et,ey=gr,ty=ZI,iy=_e("".replace),ny=RegExp("^["+ty+"]+"),ry=RegExp("(^|[^"+ty+"])["+ty+"]+$"),sy=function(e){return function(t){var i=ey($I(t));return 1&e&&(i=iy(i,ny,"")),2&e&&(i=iy(i,ry,"$1")),i}},oy={start:sy(1),end:sy(2),trim:sy(3)},ay=Jd.PROPER,cy=ce,dy=ZI,ly=oy.trim;kn({target:"String",proto:!0,forced:function(e){return cy((function(){return !!dy[e]()||"​᠎"!=="​᠎"[e]()||ay&&dy[e].name!==e}))}("trim")},{trim:function(){return ly(this)}});var hy,uy,py=er("String").trim,_y=Ee,Ey=py,my=String.prototype,fy=J((function(e){var t=e.trim;return "string"==typeof e||e===my||_y(my,e)&&t===my.trim?Ey:t}));function gy(e,t,i){return {sampleRate:e,stereo:t,bitrate:i}}function Ty(e,t,i,n,r){return {width:e,height:t,frameRate:i,bitrateMin:n,bitrateMax:r}}function Sy(e,t,i,n,r){return {width:{max:e},height:{max:t},frameRate:i,bitrateMin:n,bitrateMax:r}}function Ry(e,t){return {numSpatialLayers:e,numTemporalLayers:t}}!function(e){e[e.CHOOSE_SERVER=11]="CHOOSE_SERVER",e[e.CLOUD_PROXY=18]="CLOUD_PROXY",e[e.CLOUD_PROXY_5=20]="CLOUD_PROXY_5",e[e.CLOUD_PROXY_FALLBACK=26]="CLOUD_PROXY_FALLBACK";}(hy||(hy={})),function(e){e.IOS_15_16_INTERRUPTION_START="ios15_16-interruption-start",e.IOS_15_16_INTERRUPTION_END="ios15_16-interruption-end",e.IOS_INTERRUPTION_START="ios-interruption-start",e.IOS_INTERRUPTION_END="ios-interruption-end",e.STATE_CHANGE="state-change";}(uy||(uy={}));const Cy={"90p":Ty(160,90),"90p_1":Ty(160,90),"120p":Ty(160,120,15,30,65),"120p_1":Ty(160,120,15,30,65),"120p_3":Ty(120,120,15,30,50),"120p_4":Ty(212,120),"180p":Ty(320,180,15,30,140),"180p_1":Ty(320,180,15,30,140),"180p_3":Ty(180,180,15,30,100),"180p_4":Ty(240,180,15,30,120),"240p":Ty(320,240,15,40,200),"240p_1":Ty(320,240,15,40,200),"240p_3":Ty(240,240,15,40,140),"240p_4":Ty(424,240,15,40,220),"360p":Ty(640,360,15,80,400),"360p_1":Ty(640,360,15,80,400),"360p_3":Ty(360,360,15,80,260),"360p_4":Ty(640,360,30,80,600),"360p_6":Ty(360,360,30,80,400),"360p_7":Ty(480,360,15,80,320),"360p_8":Ty(480,360,30,80,490),"360p_9":Ty(640,360,15,80,800),"360p_10":Ty(640,360,24,80,800),"360p_11":Ty(640,360,24,80,1e3),"480p":Ty(640,480,15,100,500),"480p_1":Ty(640,480,15,100,500),"480p_2":Ty(640,480,30,100,1e3),"480p_3":Ty(480,480,15,100,400),"480p_4":Ty(640,480,30,100,750),"480p_6":Ty(480,480,30,100,600),"480p_8":Ty(848,480,15,100,610),"480p_9":Ty(848,480,30,100,930),"480p_10":Ty(640,480,10,100,400),"720p":Ty(1280,720,15,120,1130),"720p_auto":Ty(1280,720,30,900,3e3),"720p_1":Ty(1280,720,15,120,1130),"720p_2":Ty(1280,720,30,120,2e3),"720p_3":Ty(1280,720,30,120,1710),"720p_5":Ty(960,720,15,120,910),"720p_6":Ty(960,720,30,120,1380),"1080p":Ty(1920,1080,15,120,2080),"1080p_1":Ty(1920,1080,15,120,2080),"1080p_2":Ty(1920,1080,30,120,3e3),"1080p_3":Ty(1920,1080,30,120,3150),"1080p_5":Ty(1920,1080,60,120,4780),"1440p":Ty(2560,1440,30,120,4850),"1440p_1":Ty(2560,1440,30,120,4850),"1440p_2":Ty(2560,1440,60,120,7350),"4k":Ty(3840,2160,30,120,8910),"4k_1":Ty(3840,2160,30,120,8910),"4k_3":Ty(3840,2160,60,120,13500)},vy=[{scaleResolutionDownBy:2,width:1280,height:720,frameRate:30,bitrateMin:300,bitrateMax:900},{scaleResolutionDownBy:1.333333,width:1280,height:720,frameRate:30,bitrateMin:600,bitrateMax:2e3},{scaleResolutionDownBy:1,width:1280,height:720,frameRate:30,bitrateMin:900,bitrateMax:3e3}],Iy={"480p":Sy(640,480,5),"480p_1":Sy(640,480,5),"480p_2":Sy(640,480,30),"480p_3":Sy(640,480,15),"720p":Sy(1280,720,5),"720p_auto":Ty(1280,720,30,900,3e3),"720p_1":Sy(1280,720,5),"720p_2":Sy(1280,720,30),"720p_3":Sy(1280,720,15),"1080p":Sy(1920,1080,5),"1080p_1":Sy(1920,1080,5),"1080p_2":Sy(1920,1080,30),"1080p_3":Sy(1920,1080,15)},yy={"1SL1TL":Ry(1,1),"3SL3TL":Ry(3,3),"2SL3TL":Ry(2,3)};function Ay(e){return e||(e="480p_1"),"string"==typeof e?Object.assign({},Cy[e]):e}function by(e){return "string"==typeof e?Object.assign({},Iy[e]):e}function wy(e){return "string"==typeof e?Object.assign({},yy[e]):e}const Oy={speech_low_quality:gy(16e3,!1),speech_standard:gy(32e3,!1,18),music_standard:gy(48e3,!1),standard_stereo:gy(48e3,!0,56),high_quality:gy(48e3,!1,128),high_quality_stereo:gy(48e3,!0,192)};function Ny(e){return "string"==typeof e?Object.assign({},Oy[e]):e}const Dy=[];function Py(e){return Bg(e,"mediaSource",["screen","window","application"]),!0}var Ly,ky,My,Uy,xy,Vy,Fy,By,jy,Gy;!function(e){e.NEED_RENEGOTIATE="@need_renegotiate",e.NEED_REPLACE_TRACK="@need_replace_track",e.NEED_CLOSE="@need_close",e.NEED_ENABLE_TRACK="@need_enable_track",e.NEED_DISABLE_TRACK="@need_disable_track",e.NEED_SESSION_ID="@need_sid",e.SET_OPTIMIZATION_MODE="@set_optimization_mode",e.GET_STATS="@get_stats",e.GET_RTC_STATS="@get_rtc_stats",e.GET_LOW_VIDEO_TRACK="@get_low_video_track",e.NEED_RESET_REMOTE_SDP="@need_reset_remote_sdp",e.NEED_UPDATE_VIDEO_ENCODER="@need_update_video_encoder",e.NEED_MUTE_TRACK="@need_mute_track",e.NEED_UNMUTE_TRACK="@need_unmute_track";}(Ly||(Ly={})),function(e){e.SCREEN_TRACK="screen_track",e.CUSTOM_TRACK="custome_track",e.LOW_STREAM="low_stream";}(ky||(ky={})),function(e){e[e.HIGH_STREAM=0]="HIGH_STREAM",e[e.LOW_STREAM=1]="LOW_STREAM";}(My||(My={})),function(e){e[e.HIGH_STREAM=0]="HIGH_STREAM",e[e.LOW_STREAM=1]="LOW_STREAM";}(Uy||(Uy={})),function(e){e[e.DISABLE=0]="DISABLE",e[e.LOW_STREAM=1]="LOW_STREAM",e[e.AUDIO_ONLY=2]="AUDIO_ONLY";}(xy||(xy={})),function(e){e.TRANSCEIVER_UPDATED="transceiver-updated";}(Vy||(Vy={})),function(e){e.SOURCE_STATE_CHANGE="source-state-change",e.TRACK_ENDED="track-ended",e.BEAUTY_EFFECT_OVERLOAD="beauty-effect-overload",e.VIDEO_ELEMENT_VISIBLE_STATUS="video-element-visible-status",e.CLOSED="closed";}(Fy||(Fy={})),function(e){e.FIRST_FRAME_DECODED="first-frame-decoded",e.VIDEO_ELEMENT_VISIBLE_STATUS="video-element-visible-status";}(By||(By={})),function(e){e.AUDIO_SOURCE_STATE_CHANGE="audio_source_state_change",e.RECEIVE_TRACK_BUFFER="receive_track_buffer",e.ON_AUDIO_BUFFER="on_audio_buffer",e.UPDATE_SOURCE="update_source";}(jy||(jy={})),function(e){e.UPDATE_TRACK_SOURCE="update-track-source";}(Gy||(Gy={}));const Wy={sendVolumeLevel:0,sendBitrate:0,sendBytes:0,sendPackets:0,sendPacketsLost:0,sendJitterMs:0,sendRttMs:0,currentPacketLossRate:0},Hy={sendBytes:0,sendBitrate:0,sendPackets:0,sendPacketsLost:0,sendJitterMs:0,sendRttMs:0,sendResolutionHeight:0,sendResolutionWidth:0,captureResolutionHeight:0,captureResolutionWidth:0,targetSendBitrate:0,totalDuration:0,totalFreezeTime:0,currentPacketLossRate:0},Ky={transportDelay:0,end2EndDelay:0,receiveBitrate:0,receiveLevel:0,receiveBytes:0,receiveDelay:0,receivePackets:0,receivePacketsLost:0,totalDuration:0,totalFreezeTime:0,freezeRate:0,packetLossRate:0,currentPacketLossRate:0,publishDuration:-1},Yy={uplinkNetworkQuality:0,downlinkNetworkQuality:0},qy={transportDelay:0,end2EndDelay:0,receiveBitrate:0,receiveBytes:0,receiveDelay:0,receivePackets:0,receivePacketsLost:0,receiveResolutionHeight:0,receiveResolutionWidth:0,totalDuration:0,totalFreezeTime:0,freezeRate:0,packetLossRate:0,currentPacketLossRate:0,publishDuration:-1};var Jy,zy,Xy,Qy,Zy;!function(e){e.ON_TRACK="on_track",e.ON_NODE="on_node";}(Jy||(Jy={})),function(e){e.REQUEST_UPDATE_CONSTRAINTS="request_update_constraints",e.REQUEST_CONSTRAINTS="request_constraints";}(zy||(zy={})),function(e){e.IDLE="IDLE",e.INITING="INITING",e.INITEND="INITEND";}(Xy||(Xy={})),function(e){e.STATE_CHANGE="state_change",e.RECORDING_DEVICE_CHANGED="recordingDeviceChanged",e.PLAYOUT_DEVICE_CHANGED="playoutDeviceChanged",e.CAMERA_DEVICE_CHANGED="cameraDeviceChanged";}(Qy||(Qy={})),function(e){e.NONE="none",e.INIT="init",e.CANPLAY="canplay",e.PLAYING="playing",e.PAUSED="paused",e.SUSPEND="suspend",e.STALLED="stalled",e.WAITING="waiting",e.ERROR="error",e.DESTROYED="destroyed",e.ABORT="abort",e.ENDED="ended",e.EMPTIED="emptied",e.LOADEDDATA="loadeddata";}(Zy||(Zy={}));const $y={uninit:100,none:110,init:120,loadeddata:130,canplay:200,playing:210,paused:220,suspend:300,stalled:310,waiting:320,error:330,destroyed:340,abort:350,ended:360,emptied:370};var eA;!function(e){e.OPEN="open",e.MESSAGE="message",e.CLOSE="close",e.CLOSING="closing",e.ERROR="error";}(eA||(eA={}));class tA extends iT{constructor(e,t){super(),nu(this,"_ID",void 0),nu(this,"_rtpTransceiver",void 0),nu(this,"_lowRtpTransceiver",void 0),nu(this,"_hints",[]),nu(this,"_isClosed",!1),nu(this,"_originMediaStreamTrack",void 0),nu(this,"_mediaStreamTrack",void 0),nu(this,"_external",{}),this._ID=t||xT(8,"track-"),this._originMediaStreamTrack=e,this._mediaStreamTrack=e,function(e){Pr(Dy).call(Dy,e)||Dy.push(e);}(this);}toString(){return this._ID}getTrackId(){return this._ID}getMediaStreamTrack(e){if(!e){const e=rv.reportApiInvoke(null,{name:sT.GET_MEDIA_STREAM_TRACK,options:[],tag:oT.TRACER});this._mediaStreamTrack&&"string"==typeof this._mediaStreamTrack.label?e.onSuccess(this._mediaStreamTrack.label):e.onSuccess("");}return this._mediaStreamTrack}getRTCRtpTransceiver(e){return e===My.LOW_STREAM?this._lowRtpTransceiver:this._rtpTransceiver}getMediaStreamTrackSettings(){return this.getMediaStreamTrack(!0).getSettings()}close(){this._isClosed=!0,this._lowRtpTransceiver=void 0,this._rtpTransceiver=void 0,function(e){const t=Dy.indexOf(e);-1!==t&&Dy.splice(t,1);}(this),this.emit(Fy.CLOSED);}_updateRtpTransceiver(e,t){if(t===My.LOW_STREAM){if(this._lowRtpTransceiver===e)return;this._lowRtpTransceiver=e;}else {if(this._rtpTransceiver===e)return;this._rtpTransceiver=e;}this.emit(Vy.TRANSCEIVER_UPDATED,e,t);}}class iA extends tA{get isExternalTrack(){return this._isExternalTrack}get muted(){return this._muted}get enabled(){return this._enabled}get processorContext(){return this._processorContext}set processorContext(e){this._processorContext=e;}constructor(e,t){super(e,t),nu(this,"_enabled",!0),nu(this,"_muted",!1),nu(this,"_isExternalTrack",!1),nu(this,"_isClosed",!1),nu(this,"_enabledMutex",void 0),nu(this,"processor",void 0),nu(this,"_handleTrackEnded",(()=>{this.onTrackEnded();})),this._enabledMutex=new YT("".concat(this.getTrackId())),e.addEventListener("ended",this._handleTrackEnded);}getTrackLabel(){var e,t;return null!==(e=null===(t=this._originMediaStreamTrack)||void 0===t?void 0:t.label)&&void 0!==e?e:""}close(){this._isClosed||(this.stop(),this._originMediaStreamTrack.stop(),this._mediaStreamTrack!==this._originMediaStreamTrack&&(this._mediaStreamTrack.stop(),this._mediaStreamTrack=null),this._originMediaStreamTrack=null,this._enabledMutex=null,KC.debug("[".concat(this.getTrackId(),"] close")),this.emit(Ly.NEED_CLOSE),super.close());}async _updateOriginMediaStreamTrack(e,t){let i=arguments.length>2&&void 0!==arguments[2]&&arguments[2];this._isExternalTrack=i,e!==this._originMediaStreamTrack&&(this._originMediaStreamTrack&&(this._originMediaStreamTrack.removeEventListener("ended",this._handleTrackEnded),t&&this._originMediaStreamTrack.stop()),e.addEventListener("ended",this._handleTrackEnded),this._originMediaStreamTrack=e,this._muted&&(this._originMediaStreamTrack.enabled=!1),this._mediaStreamTrack=this._originMediaStreamTrack,this._updatePlayerSource(),await gT(this,Ly.NEED_REPLACE_TRACK,this),this.processor&&this.processor.updateInput({track:this._originMediaStreamTrack,context:this.processorContext}));}_getDefaultPlayerConfig(){return {}}onTrackEnded(){KC.debug("[".concat(this.getTrackId(),"] track ended")),this.safeEmit(Fy.TRACK_ENDED);}stateCheck(e,t){if(KC.debug("check track state, [muted: ".concat(this._muted,", enabled: ").concat(this._enabled,"] to [").concat(e,": ").concat(t,"]")),Fg(t,e),this._enabled&&this._muted&&"enabled"===e&&!1===t)throw new Vg(xg.TRACK_STATE_UNREACHABLE,"cannot set enabled while the track is muted").print("error",KC);if(!this._enabled&&!this._muted&&"muted"===e&&!0===t)throw new Vg(xg.TRACK_STATE_UNREACHABLE,"cannot set muted while the track is disabled").print("error",KC)}getProcessorStats(){return this.processorContext.gatherStats()}getProcessorUsage(){return this.processorContext.gatherUsage()}}function nA(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n);}return i}const rA=window.AudioContext||window.webkitAudioContext;let sA=null;const oA=new class extends iT{constructor(){super(...arguments),nu(this,"prevState",void 0),nu(this,"curState",void 0),nu(this,"currentTime",void 0),nu(this,"currentTimeStuckAt",void 0),nu(this,"interruptDetectorTrack",void 0),nu(this,"onLocalAudioTrackMute",(()=>{KC.info("ios15-interruption-start"),this.emit(uy.IOS_15_16_INTERRUPTION_START);})),nu(this,"onLocalAudioTrackUnmute",(async()=>{KC.info("ios15-interruption-end"),"running"!==this.curState||this.duringInterruption?KC.info("ios15-interruption-end-canceled"):(sA&&await sA.suspend(),this.emit(uy.IOS_15_16_INTERRUPTION_END));}));}get duringInterruption(){return "running"===this.prevState&&"interrupted"===this.curState}bindInterruptDetectorTrack(e){KC.debug("webaudio bindInterruptDetectorTrack ".concat(e.getTrackId())),this.interruptDetectorTrack||(this.interruptDetectorTrack=e,this.interruptDetectorTrack._mediaStreamTrack.onmute=this.onLocalAudioTrackMute,this.interruptDetectorTrack._mediaStreamTrack.onunmute=this.onLocalAudioTrackUnmute);}unbindInterruptDetectorTrack(e){KC.debug("webaudio unbindInterruptDetectorTrack ".concat(e.getTrackId())),this.interruptDetectorTrack&&this.interruptDetectorTrack===e&&(this.interruptDetectorTrack._mediaStreamTrack&&(this.interruptDetectorTrack._mediaStreamTrack.onmute=null,this.interruptDetectorTrack._mediaStreamTrack.onunmute=null),this.interruptDetectorTrack=void 0);}};function aA(){if(!rA)return void KC.error("your browser is not support web audio");KC.info("create audio context");const e=function(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?nA(Object(i),!0).forEach((function(t){nu(e,t,i[t]);})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):nA(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t));}));}return e}({},kC("WEBAUDIO_INIT_OPTIONS"));KC.debug("audio context init option:",JSON.stringify(e)),sA=new rA(e),oA.curState=sA.state,sA.onstatechange=()=>{oA.prevState=oA.curState,oA.curState=sA?sA.state:void 0;const{prevState:e,curState:t}=oA,i="running"===t,n="interrupted"===t,r="running"===e,s="suspended"===e,o="interrupted"===e,a=pg().osVersion;(Cg()||Dg())&&r&&n&&(KC.info("ios".concat(a,"-interruption-start")),oA.emit(uy.IOS_INTERRUPTION_START)),(Cg()||Dg())&&(s||o)&&i&&(KC.info("ios".concat(a,"-interruption-end")),oA.emit(uy.IOS_INTERRUPTION_END)),e!==t&&(KC.debug("AudioContext State Change","".concat(e,"=>").concat(t)),oA.emit(uy.STATE_CHANGE));},setInterval((()=>{var e;const t=null===(e=sA)||void 0===e?void 0:e.currentTime;if(oA.currentTime!==t)oA.currentTimeStuckAt&&(KC.debug("AudioContext current time resume at ".concat(t)),oA.currentTimeStuckAt=void 0),oA.currentTime=t;else {if(t!==oA.currentTimeStuckAt){rv.reportApiInvoke(null,{name:"WEB_AUDIO_CURRENT_TIME_STUCK",options:{currentTime:t},tag:oT.TRACER}).onSuccess(),KC.warning("AudioContext current time stuck at ".concat(t));}oA.currentTimeStuckAt=t;}}),5e3),async function(e){const t=["click","contextmenu","auxclick","dblclick","mousedown","mouseup","touchend","keydown","keyup"];let i,n=!1,r=!1,s=!1;function o(t){"running"===e.state?a(!1):Cg()||Dg()?"suspended"===e.state&&(a(!0),t&&e.resume().then(d,d)):"closed"!==e.state&&(a(!0),t&&e.resume().then(d,d));}function a(e){if(n!==e){n=e;for(let i=0,n=t;i<n.length;i+=1){const t=n[i];e?window.addEventListener(t,l,{capture:!0,passive:!0}):window.removeEventListener(t,l,{capture:!0,passive:!0});}}}function c(){o(!0);}function d(){o(!1);}function l(){o(!0);}function h(e){if(!s)if(i.paused)if(e){let e;u(!1),s=!0;try{e=i.play(),e?e.then(p,p):(i.addEventListener("playing",p),i.addEventListener("abort",p),i.addEventListener("error",p));}catch(e){p();}}else u(!0);else u(!1);}function u(e){if(r!==e){r=e;for(let i=0,n=t;i<n.length;i++){const t=n[i];e?window.addEventListener(t,_,{capture:!0,passive:!0}):window.removeEventListener(t,_,{capture:!0,passive:!0});}}}function p(){i.removeEventListener("playing",p),i.removeEventListener("abort",p),i.removeEventListener("error",p),s=!1,h(!1);}function _(){h(!0);}if(Cg()){const t=e.createMediaStreamDestination(),n=document.createElement("div");n.innerHTML="<audio x-webkit-airplay='deny'></audio>",i=n.children.item(0),i.controls=!1,i.disableRemotePlayback=!0,i.preload="auto",i.srcObject=t.stream,h(!0);}oA.on(uy.STATE_CHANGE,c),o(!1);}(sA);}function cA(){if(!sA){if(aA(),!sA)throw new Vg(xg.NOT_SUPPORTED,"can not create audio context");return sA}return sA}function dA(){return !!sA}function lA(e){if(function(){if(null!==hA)return hA;const e=cA(),t=e.createBufferSource(),i=e.createGain(),n=e.createGain();t.connect(i),t.connect(n),t.disconnect(i);let r=!1;try{t.disconnect(i);}catch(e){r=!0;}return t.disconnect(),hA=r,r}())return;const t=e.connect,i=e.disconnect;e.connect=(i,n,r)=>{var s;return e._inputNodes||(e._inputNodes=[]),Pr(s=e._inputNodes).call(s,i)||(i instanceof AudioNode?(e._inputNodes.push(i),t.call(e,i,n,r)):t.call(e,i,n)),e},e.disconnect=(n,r,s)=>{i.call(e),n?IT(e._inputNodes,n):e._inputNodes=[];for(const i of e._inputNodes)t.call(e,i);};}let hA=null;function uA(e,t){let i=!1;const n=1/t;if(kC("DISABLE_WEBAUDIO")){const t=window.setInterval((()=>{i?window.clearInterval(t):e(performance.now()/1e3);}),1e3*n);}else {const t=cA();let r=t.createGain();r.gain.value=0,r.connect(t.destination);const s=()=>{if(i)return void(r=null);const o=t.createOscillator();o.onended=s,o.connect(r),o.start(0),o.stop(t.currentTime+n),e(t.currentTime);};s();}return ()=>{i=!0;}}const pA={getDisplayMedia:!1,getStreamFromExtension:!1,supportUnifiedPlan:!1,supportMinBitrate:!1,supportSetRtpSenderParameters:!1,supportDualStream:!0,webAudioMediaStreamDest:!1,supportReplaceTrack:!1,supportWebGL:!1,webAudioWithAEC:!1,supportRequestFrame:!1,supportShareAudio:!1,supportDualStreamEncoding:!1,supportDataChannel:!1,supportPCSetConfiguration:!1,supportWebRTCEncodedTransform:!1,supportWebRTCInsertableStream:!1};function _A(){return pA}class EA{constructor(){nu(this,"context",void 0),nu(this,"analyserNode",void 0),nu(this,"sourceNode",void 0),this.context=cA(),this.analyserNode=this.context.createAnalyser(),this.analyserNode.fftSize=2048,this.analyserNode.smoothingTimeConstant=.4;}updateSource(e){if(e!==this.sourceNode){if(this.sourceNode)try{this.sourceNode.disconnect(this.analyserNode);}catch(e){}this.sourceNode=e,null==e||e.connect(this.analyserNode);}}getVolumeLevel(){if(!this.sourceNode)return 0;if(!this.context||Cg()||Dg()||"running"!==this.context.state&&this.context.resume(),!this.analyserNode)return 0;const e=new Float32Array(this.analyserNode.fftSize);if(this.analyserNode.getFloatTimeDomainData)this.analyserNode.getFloatTimeDomainData(e);else {const t=new Uint8Array(this.analyserNode.fftSize);this.analyserNode.getByteTimeDomainData(t);for(let i=0;i<e.length;++i)e[i]=t[i]/128-1;}const t=cS(e).call(e,((e,t)=>e+t*t),0)/e.length;return Math.max(10*Math.log10(t)+100,0)/100}getAnalyserNode(){return this.analyserNode}rebuildAnalyser(){try{var e,t;null===(e=this.sourceNode)||void 0===e||e.disconnect(this.analyserNode),this.analyserNode=this.context.createAnalyser(),this.analyserNode.fftSize=2048,this.analyserNode.smoothingTimeConstant=.4,null===(t=this.sourceNode)||void 0===t||t.connect(this.analyserNode);}catch(e){KC.warning("rebuild analyser node failed.");}}destroy(){this.updateSource(void 0);}}class mA extends iT{get processSourceNode(){return this.sourceNode}set processedNode(e){var t;if(!this.isDestroyed&&this._processedNode!==e){try{var i;null===(i=this.sourceNode)||void 0===i||i.disconnect(this.outputNode);}catch(e){}null===(t=this._processedNode)||void 0===t||t.disconnect(),this._processedNode=e,this.connect();}}get processedNode(){return this._processedNode}constructor(){super(),nu(this,"outputNode",void 0),nu(this,"outputTrack",void 0),nu(this,"isPlayed",!1),nu(this,"context",void 0),nu(this,"audioBufferNode",void 0),nu(this,"destNode",void 0),nu(this,"audioOutputLevel",0),nu(this,"volumeLevelAnalyser",void 0),nu(this,"_processedNode",void 0),nu(this,"playNode",void 0),nu(this,"isDestroyed",!1),nu(this,"onNoAudioInput",void 0),nu(this,"isNoAudioInput",!1),nu(this,"_noAudioInputCount",0),this.context=cA(),this.playNode=this.context.destination,this.outputNode=this.context.createGain(),lA(this.outputNode),this.volumeLevelAnalyser=new EA;}startGetAudioBuffer(e){this.audioBufferNode||(this.audioBufferNode=this.context.createScriptProcessor(e),this.outputNode.connect(this.audioBufferNode),this.audioBufferNode.connect(this.context.destination),this.audioBufferNode.onaudioprocess=e=>{this.emit(jy.ON_AUDIO_BUFFER,function(e){for(let t=0;t<e.outputBuffer.numberOfChannels;t+=1){const i=e.outputBuffer.getChannelData(t);for(let e=0;e<i.length;e+=1)i[e]=0;}return e.inputBuffer}(e));});}stopGetAudioBuffer(){this.audioBufferNode&&(this.audioBufferNode.onaudioprocess=null,this.outputNode.disconnect(this.audioBufferNode),this.audioBufferNode=void 0);}createOutputTrack(){if(!_A().webAudioMediaStreamDest)throw new Vg(xg.NOT_SUPPORTED,"your browser is not support audio processor");return this.destNode&&this.outputTrack||(this.destNode=this.context.createMediaStreamDestination(),this.outputNode.connect(this.destNode),this.outputTrack=this.destNode.stream.getAudioTracks()[0]),this.outputTrack}play(e){"running"!==this.context.state&&AT((()=>{oA.emit("autoplay-failed");})),this.isPlayed=!0,this.playNode=e||this.context.destination,this.outputNode.connect(this.playNode);}stop(){if(this.isPlayed)try{this.outputNode.disconnect(this.playNode);}catch(e){}this.isPlayed=!1;}getAccurateVolumeLevel(){return this.volumeLevelAnalyser.getVolumeLevel()}async checkHasAudioInput(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;if(e>5)return this.isNoAudioInput=!0,this.onNoAudioInput&&this.onNoAudioInput(),!1;Cg()||Dg()?"suspended"===this.context.state&&this.context.resume():"running"!==this.context.state&&this.context.resume();const t=this.volumeLevelAnalyser.getAnalyserNode();let i;t.getFloatTimeDomainData?(i=new Float32Array(t.fftSize),t.getFloatTimeDomainData(i)):(i=new Uint8Array(t.fftSize),t.getByteTimeDomainData(i));let n=!1;for(let e=0;e<i.length;e++)0!==i[e]&&(n=!0);return n?(this.isNoAudioInput=!1,!0):(await UT(200),await this.checkHasAudioInput(e?e+1:1)&&n)}getAudioVolume(){return this.outputNode.gain.value}setVolume(e){this.outputNode.gain.setValueAtTime(e,this.context.currentTime);}destroy(){this.disconnect(),this.stop(),this.isDestroyed=!0,this.onNoAudioInput=void 0;}disconnect(){var e,t;null===(e=this.processedNode)||void 0===e||e.disconnect(),null===(t=this.sourceNode)||void 0===t||t.disconnect(),this.outputNode&&this.outputNode.disconnect();}connect(){var e;this.processedNode?null===(e=this.processedNode)||void 0===e||e.connect(this.outputNode):this.sourceNode&&this.sourceNode.connect(this.outputNode);this.volumeLevelAnalyser.updateSource(this.outputNode);}}class fA extends mA{get isFreeze(){return !1}constructor(e,t,i){var n;if(super(),nu(this,"sourceNode",void 0),nu(this,"track",void 0),nu(this,"clonedTrack",void 0),nu(this,"audioElement",void 0),nu(this,"isCurrentTrackCloned",!1),nu(this,"isRemoteTrack",!1),nu(this,"originVolumeLevelAnalyser",void 0),nu(this,"rebuildWebAudio",(async()=>{if(KC.debug("ready to rebuild web audio, state:",this.context.state),this.isNoAudioInput&&await this.checkHasAudioInput(),!this.isNoAudioInput||this.isDestroyed)return document.body.removeEventListener("click",this.rebuildWebAudio,!0),void KC.debug("rebuild web audio success, current volume status",this.getAccurateVolumeLevel());this.context.resume().then((()=>KC.info("resume success"))),KC.debug("rebuild web audio because of ios 12 bugs"),this.disconnect();const e=this.track;this.track=this.track.clone(),this.isCurrentTrackCloned?e.stop():this.isCurrentTrackCloned=!0;const t=new MediaStream([this.track]);this.sourceNode=this.context.createMediaStreamSource(t),lA(this.sourceNode),this.volumeLevelAnalyser.rebuildAnalyser();const i=this.outputNode.gain.value;this.outputNode=this.context.createGain(),this.outputNode.gain.setValueAtTime(i,this.context.currentTime),lA(this.outputNode),this.emit(jy.UPDATE_SOURCE),this.connect(),this.audioElement.srcObject=t,this.isPlayed&&this.play(this.playNode),this.checkHasAudioInput();})),"audio"!==e.kind)throw new Vg(xg.UNEXPECTED_ERROR);this.track=e;const r=new MediaStream([this.track]);if(this.isRemoteTrack=!!t,this.sourceNode=this.context.createMediaStreamSource(r),lA(this.sourceNode),i){const e=i.clone();e.enabled=!0,this.clonedTrack=e,KC.debug("create an unmuted track ".concat(e.id," from the original track ").concat(i.id," to get the volume"));const t=this.context.createMediaStreamSource(new MediaStream([e]));lA(t),this.originVolumeLevelAnalyser=new EA,this.originVolumeLevelAnalyser.updateSource(t);}this.connect(),this.audioElement=document.createElement("audio"),this.audioElement.srcObject=r;const s=pg();t&&s.os===ag.IOS&&Number(null===(n=s.osVersion)||void 0===n?void 0:n.split(".")[0])<15&&(oA.on(uy.STATE_CHANGE,(()=>{"suspended"===this.context.state?document.body.addEventListener("click",this.rebuildWebAudio,!0):"running"===this.context.state&&this.rebuildWebAudio();})),this.checkHasAudioInput().then((e=>{e||document.body.addEventListener("click",this.rebuildWebAudio,!0);})));}updateTrack(e){this.sourceNode.disconnect(),this.track=e,this.isCurrentTrackCloned=!1;const t=new MediaStream([e]);this.sourceNode=this.context.createMediaStreamSource(t),lA(this.sourceNode),this.processedNode||this.sourceNode.connect(this.outputNode),this.emit(jy.UPDATE_SOURCE),this.audioElement.srcObject=t;}destroy(){var e;this.audioElement.srcObject=null,this.audioElement.remove(),oA.off("state-change",this.rebuildWebAudio),null===(e=this.originVolumeLevelAnalyser)||void 0===e||e.destroy(),this.clonedTrack=void 0,super.destroy();}createMediaStreamSourceNode(e){return this.context.createMediaStreamSource(new MediaStream([e]))}updateOriginTrack(e){const t=e.clone();t.enabled=!0,this.clonedTrack&&(this.clonedTrack.stop(),this.clonedTrack=t),KC.debug("create an unmuted track ".concat(t.id," from the original track ").concat(e.id," to get the volume"));const i=this.context.createMediaStreamSource(new MediaStream([t]));lA(i),this.originVolumeLevelAnalyser&&this.originVolumeLevelAnalyser.updateSource(i);}getOriginVolumeLevel(){return this.originVolumeLevelAnalyser?this.originVolumeLevelAnalyser.getVolumeLevel():this.getAccurateVolumeLevel()}}async function gA(e,t,i){const n=(e,t)=>e?"number"!=typeof e?e.max||e.exact||e.ideal||e.min||t:e:t,r={audio:!!i&&{mandatory:{chromeMediaSource:"desktop"}},video:{mandatory:{chromeMediaSource:"desktop",chromeMediaSourceId:e,maxHeight:n(t.height,1080),maxWidth:n(t.width,1920)}}};return t.frameRate&&"number"!=typeof t.frameRate?(r.video.mandatory.maxFrameRate=t.frameRate.max,r.video.mandatory.minFrameRate=t.frameRate.min):"number"==typeof t.frameRate&&(r.video.mandatory.maxFrameRate=t.frameRate),await navigator.mediaDevices.getUserMedia(r)}async function TA(e,t){const i=await SA(e.mediaSource),{sourceId:n,audio:r}=await function(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return new tg(((i,n)=>{const r=document.createElement("div");r.innerText="share screen",r.setAttribute("style","text-align: center; height: 25px; line-height: 25px; border-radius: 4px 4px 0 0; background: #D4D2D4; border-bottom:  solid 1px #B9B8B9;");const s=document.createElement("div");s.setAttribute("style","width: 100%; height: 500px; padding: 15px 25px ; box-sizing: border-box;");const o=document.createElement("div");o.innerText="Agora Web Screensharing wants to share the contents of your screen with webdemo.agorabeckon.com. Choose what you'd like to share.",o.setAttribute("style","height: 12%;");const a=document.createElement("div");a.setAttribute("style","width: 100%; height: 80%; background: #FFF; border:  solid 1px #CBCBCB; display: flex; flex-wrap: wrap; justify-content: space-around; overflow-y: scroll; padding: 0 15px; box-sizing: border-box;");const c=document.createElement("div");c.setAttribute("style","display: flex; justify-content: space-between; padding: 16px 0;");const d=document.createElement("button");d.innerHTML="cancel",d.setAttribute("style","width: 85px;"),d.onclick=()=>{document.body.removeChild(u);const e=new Error("NotAllowedError");e.name="NotAllowedError",n(e);};let l=t;const h=document.createElement("div");if(t){const e=document.createElement("input");e.setAttribute("type","checkbox");const t=document.createElement("span");e.setAttribute("style","margin-right: 6px;"),t.innerText="Share audio",e.checked=l,e.onchange=()=>{l=e.checked;},h.appendChild(e),h.appendChild(t);}c.appendChild(h),c.appendChild(d),s.appendChild(o),s.appendChild(a),s.appendChild(c);const u=document.createElement("div");u.setAttribute("style","position: fixed; z-index: 99999999; top: 50%; left: 50%; width: 620px; height: 525px; background: #ECECEC; border-radius: 4px; -webkit-transform: translate(-50%,-50%); transform: translate(-50%,-50%);"),u.appendChild(r),u.appendChild(s),document.body.appendChild(u),e.map((e=>{if(e.id){const t=document.createElement("div");t.setAttribute("style","width: 30%; height: 160px; padding: 20px 0; text-align: center;box-sizing: content-box;");let n=e.thumbnail;try{const{width:e}=n.getSize();e>1920&&(n=n.resize({width:1920}));}catch(e){throw e&&e.message.startsWith("Illegal invocation")&&console.error("Operate thumbnail error, please try to set contextIsolation: false. (https://github.com/electron/electron/issues/34953)"),e}t.innerHTML='<div style="height: 120px; display: table-cell; vertical-align: middle;"><img style="width: 100%; background: #333333; box-shadow: 1px 1px 1px 1px rgba(0, 0, 0, 0.2);" src='+n.toDataURL()+' /></div><span style="\theight: 40px; line-height: 40px; display: inline-block; width: 70%; word-break: keep-all; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">'+e.name.replace(/[\u00A0-\u9999<>\&]/g,(function(e){return "&#"+e.charCodeAt(0)+";"}))+"</span>",t.onclick=()=>{document.body.removeChild(u),i({sourceId:e.id,audio:l});},a.appendChild(t);}}));}))}(i,t);return await gA(n,e,r)}async function SA(e){let t=["window","screen"];"application"!==e&&"window"!==e||(t=["window"]),"screen"===e&&(t=["screen"]);const i=rT();if(!i)throw console.error("failed to fetch electron, please mount it to window"),new Vg(xg.ELECTRON_IS_NULL);let n=null;try{var r;n=(null===(r=i.desktopCapturer)||void 0===r?void 0:r.getSources({types:t}))||i.ipcRenderer.invoke("DESKTOP_CAPTURER_GET_SOURCES",{types:t});}catch(e){n=null;}n&&n.then||(n=new tg(((e,n)=>{i.desktopCapturer.getSources({types:t},((t,i)=>{t?n(t):e(i);}));})));try{return await n}catch(e){throw new Vg(xg.ELECTRON_DESKTOP_CAPTURER_GET_SOURCES_ERROR,e.toString())}}function RA(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n);}return i}const CA=new YT("safari");let vA=!1,IA=!1;async function yA(e,t){let i=0,n=null;for(;i<2;)try{n=await AA(e,t,i>0);break}catch(e){if(e instanceof Vg)throw KC.error("[".concat(t,"] ").concat(e.toString())),e;const n=bA(e.name||e.code||e,e.message);if(n.code===xg.MEDIA_OPTION_INVALID){KC.debug("[".concat(t,"] detect media option invalid, retry")),i+=1,await UT(500);continue}throw KC.error("[".concat(t,"] ").concat(n.toString())),n}if(!n)throw new Vg(xg.UNEXPECTED_ERROR,"can not find stream after getUserMedia");return n}async function AA(e,t,i){if(!navigator.mediaDevices||!navigator.mediaDevices.getUserMedia)throw new Vg(xg.NOT_SUPPORTED,"can not find getUserMedia");i&&(e.video&&(delete e.video.width,delete e.video.height),e.screen&&(delete e.screen.width,delete e.screen.height));const n=_A(),r=new MediaStream;if(e.audioSource&&r.addTrack(e.audioSource),e.videoSource&&r.addTrack(e.videoSource),!e.audio&&!e.video&&!e.screen)return KC.debug("Using Video Source/ Audio Source"),r;if(e.screen)if(rT())if(e.screen.sourceId){wA(r,await gA(e.screen.sourceId,e.screen,e.screenAudio));}else {wA(r,await TA(e.screen,e.screenAudio));}else if(Tg()&&e.screen.extensionId&&e.screen.mandatory){if(!n.getStreamFromExtension)throw new Vg(xg.NOT_SUPPORTED,"This browser does not support screen sharing");KC.debug("[".concat(t,'] Screen access on chrome stable, looking for extension"'));const i=await(o=e.screen.extensionId,a=t,new tg(((e,t)=>{try{chrome.runtime.sendMessage(o,{getStream:!0},(i=>{if(!i||!i.streamId)return KC.error("[".concat(a,"] No response from Chrome Plugin. Plugin not installed properly"),i),void t(new Vg(xg.CHROME_PLUGIN_NO_RESPONSE,"No response from Chrome Plugin. Plugin not installed properly"));e(i.streamId);}));}catch(e){KC.error("[".concat(a,"] AgoraRTC screensharing plugin is not accessible(").concat(o,")"),e.toString()),t(new Vg(xg.CHROME_PLUGIN_NOT_INSTALL));}})));e.screen.mandatory.chromeMediaSourceId=i;wA(r,await navigator.mediaDevices.getUserMedia({video:{mandatory:e.screen.mandatory}}));}else if(n.getDisplayMedia){var s;e.screen.mediaSource&&Py(e.screen.mediaSource);const i={width:e.screen.width,height:e.screen.height,frameRate:e.screen.frameRate,displaySurface:null!==(s=e.screen.displaySurface)&&void 0!==s?s:"screen"===e.screen.mediaSource?"monitor":e.screen.mediaSource},{selfBrowserSurface:n,surfaceSwitching:o,systemAudio:a}=e.screen,c={selfBrowserSurface:n,surfaceSwitching:o,systemAudio:a};!n&&delete c.selfBrowserSurface,!o&&delete c.surfaceSwitching,!a&&delete c.systemAudio,KC.debug("[".concat(t,"] getDisplayMedia:"),JSON.stringify({video:i,audio:!!e.screenAudio,controls:c}));const d=await navigator.mediaDevices.getDisplayMedia(function(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?RA(Object(i),!0).forEach((function(t){nu(e,t,i[t]);})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):RA(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t));}));}return e}({video:i,audio:!!e.screenAudio},c));wA(r,d);}else {if(!Rg())throw KC.error("[".concat(t,"] This browser does not support screenSharing")),new Vg(xg.NOT_SUPPORTED,"This browser does not support screen sharing");{e.screen.mediaSource&&Py(e.screen.mediaSource);const i={video:{mediaSource:e.screen.mediaSource,width:e.screen.width,height:e.screen.height,frameRate:e.screen.frameRate}};KC.debug("[".concat(t,"] getUserMedia: ").concat(JSON.stringify(i)));wA(r,await navigator.mediaDevices.getUserMedia(i));}}var o,a;if(!e.video&&!e.audio)return r;let c={video:e.video,audio:e.audio},d=kC("MEDIA_DEVICE_CONSTRAINTS");if(d)try{"string"==typeof d&&(d=JSON.parse(d)),c=WT(c,d);}catch(e){}KC.debug("[".concat(t,"] GetUserMedia"),JSON.stringify(c)),pg();let l,h=null;(Sg()||Cg()||mg())&&(h=await CA.lock());try{l=await navigator.mediaDevices.getUserMedia(c);}catch(e){throw h&&h(),e}return c.audio&&(vA=!0),c.video&&(IA=!0),wA(r,l),h&&h(),r}function bA(e,t){switch(e){case"Starting video failed":case"OverconstrainedError":case"TrackStartError":return new Vg(xg.MEDIA_OPTION_INVALID,"".concat(e,": ").concat(t));case"NotFoundError":case"DevicesNotFoundError":return new Vg(xg.DEVICE_NOT_FOUND,"".concat(e,": ").concat(t));case"NotSupportedError":return new Vg(xg.NOT_SUPPORTED,"".concat(e,": ").concat(t));case"NotReadableError":return new Vg(xg.NOT_READABLE,"".concat(e,": ").concat(t));case"InvalidStateError":case"NotAllowedError":case"PERMISSION_DENIED":case"PermissionDeniedError":return new Vg(xg.PERMISSION_DENIED,"".concat(e,": ").concat(t));case"ConstraintNotSatisfiedError":return new Vg(xg.CONSTRAINT_NOT_SATISFIED,"".concat(e,": ").concat(t));default:return KC.error("getUserMedia unexpected error",e),new Vg(xg.UNEXPECTED_ERROR,"".concat(e,": ").concat(t))}}function wA(e,t){const i=e.getVideoTracks()[0],n=e.getAudioTracks()[0],r=t.getVideoTracks()[0],s=t.getAudioTracks()[0];s&&(n&&e.removeTrack(n),e.addTrack(s)),r&&(i&&e.removeTrack(i),e.addTrack(r));}const OA=new class extends iT{get state(){return this._state}set state(e){e!==this._state&&(this.emit(Qy.STATE_CHANGE,e),this._state=e);}constructor(){super(),nu(this,"_state",Xy.IDLE),nu(this,"isAccessMicrophonePermission",!1),nu(this,"isAccessCameraPermission",!1),nu(this,"lastAccessMicrophonePermission",!1),nu(this,"lastAccessCameraPermission",!1),nu(this,"checkdeviceMatched",!1),nu(this,"deviceInfoMap",new Map),this.init().then((()=>{navigator.mediaDevices.addEventListener&&navigator.mediaDevices.addEventListener("devicechange",this.updateDevicesInfo.bind(this)),window.setInterval((()=>{(kC("ENUMERATE_DEVICES_INTERVAL")||(Mg()||_g()===ag.HARMONY_OS)&&kg())&&this.updateDevicesInfo();}),kC("ENUMERATE_DEVICES_INTERVAL_TIME"));})).catch((e=>KC.error(e.toString())));}async enumerateDevices(e,t){let i=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(!navigator.mediaDevices||!navigator.mediaDevices.enumerateDevices){return new Vg(xg.NOT_SUPPORTED,"enumerateDevices() not supported.").throw()}const n=await navigator.mediaDevices.enumerateDevices(),r=this.checkMediaDeviceInfoIsOk(n);let s=!this.isAccessMicrophonePermission&&e,o=!this.isAccessCameraPermission&&t;r.audio&&(s=!1),r.video&&(o=!1);let a=null,c=null,d=null;if(!i&&(s||o)){if(CA.isLocked){KC.debug("[device manager] wait GUM lock");(await CA.lock())(),KC.debug("[device manager] GUM unlock");}if(vA&&(s=!1,this.isAccessMicrophonePermission=!0),IA&&(o=!1,this.isAccessCameraPermission=!0),KC.debug("[device manager] check media device permissions",e,t,s,o),s&&o){try{d=await navigator.mediaDevices.getUserMedia({audio:!0,video:!0});}catch(e){const t=bA(e.name||e.code||e,e.message);if(t.code===xg.PERMISSION_DENIED)throw t;KC.warning("getUserMedia failed in getDevices",t);}this.isAccessCameraPermission=!0,this.isAccessMicrophonePermission=!0;}else if(s){try{a=await navigator.mediaDevices.getUserMedia({audio:e});}catch(e){const t=bA(e.name||e.code||e,e.message);if(t.code===xg.PERMISSION_DENIED)throw t;KC.warning("getUserMedia failed in getDevices",t);}this.isAccessMicrophonePermission=!0;}else if(o){try{c=await navigator.mediaDevices.getUserMedia({video:t});}catch(e){const t=bA(e.name||e.code||e,e.message);if(t.code===xg.PERMISSION_DENIED)throw t;KC.warning("getUserMedia failed in getDevices",t);}this.isAccessCameraPermission=!0;}KC.debug("[device manager] mic permission",e,"cam permission",t);}try{const e=await navigator.mediaDevices.enumerateDevices();return a&&a.getTracks().forEach((e=>e.stop())),c&&c.getTracks().forEach((e=>e.stop())),d&&d.getTracks().forEach((e=>e.stop())),a=null,c=null,d=null,e}catch(e){a&&a.getTracks().forEach((e=>e.stop())),c&&c.getTracks().forEach((e=>e.stop())),d&&d.getTracks().forEach((e=>e.stop())),a=null,c=null,d=null;return new Vg(xg.ENUMERATE_DEVICES_FAILED,e.toString()).throw()}}async getRecordingDevices(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];return (await this.enumerateDevices(!0,!1,e)).filter((e=>"audioinput"===e.kind))}async getCamerasDevices(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];return (await this.enumerateDevices(!1,!0,e)).filter((e=>"videoinput"===e.kind))}async getSpeakers(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];return (await this.enumerateDevices(!0,!1,e)).filter((e=>"audiooutput"===e.kind))}searchDeviceIdByName(e){let t=null;return this.deviceInfoMap.forEach((i=>{i.device.label===e&&(t=i.device.deviceId);})),t}async getDeviceById(e){const t=(await this.enumerateDevices(!0,!0,!0)).find((t=>t.deviceId===e));if(!t)throw new Vg(xg.DEVICE_NOT_FOUND,"deviceId: ".concat(e));return t}async init(){this.state=Xy.INITING;try{await this.updateDevicesInfo(),this.state=Xy.INITEND;}catch(e){if(KC.warning("Device Detection functionality cannot start properly.",e.toString()),this.state=Xy.IDLE,!("boolean"==typeof isSecureContext?isSecureContext:"https:"===location.protocol||"file:"===location.protocol||"localhost"===location.hostname||"127.0.0.1"===location.hostname||"::1"===location.hostname)){new Vg(xg.WEB_SECURITY_RESTRICT,"Your context is limited by web security, please try using https protocol or localhost.").throw();}throw e}}async updateDevicesInfo(){const e=await this.enumerateDevices(!0,!0,!0),t=Date.now(),i=[];if(e[0]&&e[0].label&&!1===this.checkdeviceMatched){this.checkdeviceMatched=!0;const t=e.find((e=>"audioinput"===e.kind&&"default"===e.deviceId)),i=e.find((e=>"audiooutput"===e.kind&&"default"===e.deviceId));t&&i?i.groupId===t.groupId?KC.debug("[device-check] default input ".concat(t.label," and output ").concat(i.label," is the same group")):KC.warning("[device-check] default input ".concat(t.label," and output ").concat(i.label," is not the same group")):KC.debug("[device-check] default input or output not found");}const n=this.checkMediaDeviceInfoIsOk(e);if(e.forEach((e=>{if(!e.deviceId)return;const n=this.deviceInfoMap.get("".concat(e.kind,"_").concat(e.deviceId));if("ACTIVE"!==(n?n.state:"INACTIVE")){const n={initAt:t,updateAt:t,device:e,state:"ACTIVE"};this.deviceInfoMap.set("".concat(e.kind,"_").concat(e.deviceId),n),i.push(n);}n&&(n.updateAt=t);})),this.deviceInfoMap.forEach(((e,n)=>{"ACTIVE"===e.state&&e.updateAt!==t&&(e.state="INACTIVE",i.push(e));})),this.state!==Xy.INITEND)return n.audio&&(this.lastAccessMicrophonePermission=!0,this.isAccessMicrophonePermission=!0),void(n.video&&(this.lastAccessCameraPermission=!0,this.isAccessCameraPermission=!0));i.forEach((e=>{switch(e.device.kind){case"audioinput":this.lastAccessMicrophonePermission&&this.isAccessMicrophonePermission&&this.emit(Qy.RECORDING_DEVICE_CHANGED,e);break;case"videoinput":this.lastAccessCameraPermission&&this.isAccessCameraPermission&&this.emit(Qy.CAMERA_DEVICE_CHANGED,e);break;case"audiooutput":this.lastAccessMicrophonePermission&&this.isAccessMicrophonePermission&&this.emit(Qy.PLAYOUT_DEVICE_CHANGED,e);}})),n.audio&&(this.lastAccessMicrophonePermission=!0,this.isAccessMicrophonePermission=!0),n.video&&(this.lastAccessCameraPermission=!0,this.isAccessCameraPermission=!0);}checkMediaDeviceInfoIsOk(e){const t=e.filter((e=>"audioinput"===e.kind)),i=e.filter((e=>"videoinput"===e.kind)),n={audio:!1,video:!1};for(const e of t)if(e.label&&e.deviceId){n.audio=!0;break}for(const e of i)if(e.label&&e.deviceId){n.video=!0;break}return n}};let NA=!1;const DA=new class extends iT{constructor(){super(...arguments),nu(this,"onAutoplayFailed",void 0),nu(this,"onAudioAutoplayFailed",void 0);}};function PA(){if(pg(),!NA){const e=t=>{t.preventDefault(),NA=!1,Ug()?document.body.removeEventListener("click",e,!0):(document.body.removeEventListener("touchstart",e,!0),document.body.removeEventListener("mousedown",e,!0));};NA=!0,Ug()?document.body.addEventListener("click",e,!0):(document.body.addEventListener("touchstart",e,!0),document.body.addEventListener("mousedown",e,!0)),KC.info("detect media autoplay failed, document: https://docs.agora.io/cn/Voice/autoplay_policy_web_ng?platform=Web"),DA.onAutoplayFailed?DA.onAutoplayFailed():DA.onAudioAutoplayFailed?KC.warning("AgoraRTC.onAudioAutoplayFailed has been deprecated in favor of AgoraRTC.onAutoplayFailed.\n\n  Please refer to the Agora document to migrate the newer API, https://docs.agora.io/en/Voice/autoplay_policy_web_ng?platform=Web ."):KC.warning("We have detected a media autoplay failed event, and found out that you haven't implemented AgoraRTC.onAutoplayFailed callback yet.\n\n  It will cause audio/video element not playing automatically on some browsers without user interaction, possibly hurting user experiences.\n\n  Please refer to the Agora document to properly handle autoplay failed event, https://docs.agora.io/en/Voice/autoplay_policy_web_ng?platform=Web ."),DA.emit("autoplay-failed");}}function LA(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n);}return i}function kA(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?LA(Object(i),!0).forEach((function(t){nu(e,t,i[t]);})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):LA(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t));}));}return e}function MA(e,t,i,n){if(!e)return;const r=rv.getBaseInfoBySessionId(e);if(!r)return;const s=r.info,o=Date.now(),a=kA(kA({},s),{},{vid:void 0===s.vid?0:Number(s.vid),lts:o,elapse:o-r.startTime,cbRegistered:DA.onAutoplayFailed||DA.onAudioAutoplayFailed?1:-1,errorMsg:i,mediaType:t,trackId:n,extend:void 0});rv.send({type:QC.AUTOPLAY_FAILED,data:a},!0);}const UA=["play","playing","loadeddata","canplay","pause","stalled","suspend","waiting","abort","emptied","ended","error"],xA=new class{constructor(){nu(this,"onAutoplayFailed",void 0),nu(this,"elementMap",new Map),nu(this,"elementStateMap",new Map),nu(this,"elementsNeedToResume",[]),nu(this,"sinkIdMap",new Map),nu(this,"autoResumeAfterInterruption",(()=>{Array.from(this.elementMap.entries()).forEach((e=>{let[t,i]=e;const n=this.elementStateMap.get(t),r=i.srcObject.getAudioTracks()[0];wg()?r&&"live"===r.readyState&&"running"===oA.curState&&(KC.debug("auto resume after interruption for iOS 15"),i.pause(),i.play()):n&&"paused"===n&&r&&"live"===r.readyState&&"running"===oA.curState&&(KC.debug("auto resume after interruption for iOS"),i.play());}));})),nu(this,"autoResumeAfterInterruptionOnIOS15_16",(()=>{Array.from(this.elementMap.entries()).forEach((e=>{let[t,i]=e;const n=i.srcObject.getAudioTracks()[0];n&&"live"===n.readyState&&(KC.debug("auto resume after interruption inside autoResumeAfterInterruptionOnIOS15"),i.pause(),i.play());}));})),this.autoResumeAudioElement(),oA.on(uy.IOS_INTERRUPTION_END,this.autoResumeAfterInterruption),oA.on(uy.IOS_15_16_INTERRUPTION_END,this.autoResumeAfterInterruptionOnIOS15_16),oA.on(uy.STATE_CHANGE,(()=>{Cg()&&"suspended"===oA.prevState&&"running"===oA.curState&&this.autoResumeAfterInterruption();}));}async setSinkID(e,t){const i=this.elementMap.get(e);if(this.sinkIdMap.set(e,t),i)try{await i.setSinkId(t);}catch(e){throw new Vg(xg.PERMISSION_DENIED,"can not set sink id: "+e.toString())}}play(e,t,i,n){if(this.elementMap.has(t))return;const r=document.createElement("audio");r.autoplay=!0,r.srcObject=new MediaStream([e]),this.bindAudioElementEvents(t,r),this.elementMap.set(t,r),this.elementStateMap.set(t,Zy.INIT),this.setVolume(t,i);const s=this.sinkIdMap.get(t);if(s)try{r.setSinkId(s).catch((e=>{KC.warning("[".concat(t,"] set sink id failed"),e.toString());}));}catch(e){KC.warning("[".concat(t,"] set sink id failed"),e.toString());}const o=r.play();o&&o.then&&o.catch((e=>{n&&MA(n,"audio",e.message,t),KC.warning("audio element play warning",e.toString()),this.elementMap.has(t)&&"NotAllowedError"===e.name&&(KC.warning("detected audio element autoplay failed"),this.elementsNeedToResume.push(r),AT((()=>{this.onAutoplayFailed&&this.onAutoplayFailed(),PA();})));}));}updateTrack(e,t){const i=this.elementMap.get(e);i&&(i.srcObject=new MediaStream([t]));}isPlaying(e){return this.elementMap.has(e)&&"playing"===this.elementStateMap.get(e)}setVolume(e,t){const i=this.elementMap.get(e);i&&(t=Math.max(0,Math.min(100,t)),i.volume=t/100);}stop(e){const t=this.elementMap.get(e);if(this.sinkIdMap.delete(e),!t)return;const i=this.elementsNeedToResume.indexOf(t);this.elementsNeedToResume.splice(i,1),t.srcObject=null,t.remove(),this.elementMap.delete(e),this.elementStateMap.delete(e);}bindAudioElementEvents(e,t){UA.forEach((i=>{t.addEventListener(i,(i=>{const n=this.elementStateMap.get(e),r="pause"===i.type?"paused":i.type;if(KC.debug("[".concat(e,"] audio-element-status change ").concat(n," => ").concat(r)),"error"===i.type){const i=null==t?void 0:t.error;i&&KC.error("[".concat(e,"] media error, code: ").concat(i.code,", message: ").concat(i.message));}this.elementStateMap.set(e,r);}));}));}getPlayerState(e){return this.elementStateMap.get(e)||"uninit"}autoResumeAudioElement(){const e=()=>{this.elementsNeedToResume.forEach((e=>{e.play().then((e=>{KC.debug("Auto resume audio element success");})).catch((e=>{KC.warning("Auto resume audio element failed!",e);}));})),this.elementsNeedToResume=[];};new tg((e=>{document.body?e():window.addEventListener("load",(()=>e()));})).then((()=>{Ug()?document.body.addEventListener("click",e,!0):(document.body.addEventListener("touchstart",e,!0),document.body.addEventListener("mousedown",e,!0));}));}};function VA(){return function(e,t,i){const n=i.value;return "function"==typeof n&&(i.value=function(){this._isClosed&&new Vg(xg.INVALID_OPERATION,"[".concat(this.getTrackId(),"] cannot operate a closed track")).print("warning",KC);for(var e=arguments.length,t=new Array(e),i=0;i<e;i++)t[i]=arguments[i];const r=n.apply(this,t);return r instanceof tg?new tg(((e,t)=>{r.then(e).catch(t);})):r}),i}}function FA(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n);}return i}function BA(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?FA(Object(i),!0).forEach((function(t){nu(e,t,i[t]);})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):FA(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t));}));}return e}class jA extends iT{constructor(e){super(),nu(this,"name","VideoProcessorDestination"),nu(this,"ID","0"),nu(this,"_source",void 0),nu(this,"videoContext",void 0),nu(this,"inputTrack",void 0),this.videoContext=e;}get kind(){return "video"}get enabled(){return !0}pipe(){throw new Vg(xg.NOT_SUPPORTED,"VideoProcessor cannot pipe to any other Processor")}unpipe(){throw new Vg(xg.NOT_SUPPORTED,"VideoProcessor cannot unpipe to any other Processor")}enable(){}disable(){}updateInput(e){if(e.context!==this.videoContext)throw new Error("ProcessorContext passed to VideoTrack.processorDestination doesn't match it's belonging VideoTrack's context.\nProbably you are making pipeline like this:\nvideoTrack1.pipe(processor).pipe(videoTrack2.processorDestination).");e.track&&e.track!==this.inputTrack&&(this.videoContext.chained=!0,this.inputTrack=e.track,this.emit(Jy.ON_TRACK,e.track));}reset(){this.inputTrack=void 0,this.videoContext.chained=!1,this.emit(Jy.ON_TRACK,void 0);}}class GA extends iT{set chained(e){this._chained=e;}get chained(){return this._chained}constructor(e,t){super(),nu(this,"constraintsMap",new Map),nu(this,"statsRegistry",[]),nu(this,"usageRegistry",[]),nu(this,"trackId",void 0),nu(this,"direction",void 0),nu(this,"_chained",!1),this.trackId=e,this.direction=t;}async getConstraints(){return await fT(this,zy.REQUEST_CONSTRAINTS)}async requestApplyConstraints(e,t){var i;return KC.info("processor ".concat(t.name," requestApplyConstraints for ").concat(this.trackId)),e&&this.constraintsMap.set(t,e),gT(this,zy.REQUEST_UPDATE_CONSTRAINTS,Array.from(kv(i=this.constraintsMap).call(i)))}async requestRevertConstraints(e){var t;if(this.constraintsMap.has(e))return KC.info("processor ".concat(e.name," requestRevertConstraints for ").concat(this.trackId)),this.constraintsMap.delete(e),gT(this,zy.REQUEST_UPDATE_CONSTRAINTS,Array.from(kv(t=this.constraintsMap).call(t)))}registerStats(e,t,i){this.statsRegistry.find((i=>i.processorID===e.ID&&i.processorName===e.name&&i.type===t))||this.statsRegistry.push({processorName:e.name,processorID:e.ID,type:t,cb:i});}unregisterStats(e,t){const i=this.statsRegistry.findIndex((i=>i.processorID===e.ID&&i.processorName===e.name&&i.type===t));-1!==i&&this.statsRegistry.splice(i,1);}gatherStats(){const e=[];for(const{processorID:t,processorName:i,type:n,cb:r}of this.statsRegistry)try{const s=r();e.push({processorID:t,processorName:i,type:n,stats:s});}catch(e){KC.error(new Vg(xg.UNEXPECTED_ERROR,e.message));}return e}registerUsage(e,t){this.usageRegistry.find((t=>t.processorID===e.ID&&t.processorName===e.name))||this.usageRegistry.push({processorID:e.ID,processorName:e.name,cb:t});}unregisterUsage(e){const t=this.usageRegistry.findIndex((t=>t.processorID===e.ID&&t.processorName===e.name));-1!==t&&this.usageRegistry.splice(t,1);}async gatherUsage(){const e=[];if(!this.chained)return [];for(const{cb:t}of this.usageRegistry)try{let i=t();i instanceof tg&&(i=await i),e.push(BA(BA({},i),{},{direction:this.direction}));}catch(e){KC.error("gather extension usage error",e);}return e}getDirection(){return this.direction}}class WA extends iT{constructor(e){super(),nu(this,"name","AudioProcessorDestination"),nu(this,"ID","0"),nu(this,"inputTrack",void 0),nu(this,"inputNode",void 0),nu(this,"audioProcessorContext",void 0),nu(this,"_source",void 0),this.audioProcessorContext=e;}get kind(){return "audio"}get enabled(){return !0}pipe(){throw new Vg(xg.NOT_SUPPORTED,"AudioProcessorDestination cannot pipe to any other Processor")}unpipe(){throw new Vg(xg.NOT_SUPPORTED,"AudioProcessor cannot unpipe to any other Processor")}enable(){}disable(){}reset(){this.inputTrack=void 0,this.inputNode=void 0,this.audioProcessorContext.chained=!1,this.emit(Jy.ON_TRACK,void 0),this.emit(Jy.ON_NODE,void 0);}updateInput(e){if(e.context!==this.audioProcessorContext)throw new Error("ProcessorContext passed to AudioTrack.processorDestination doesn't match it's belonging AudioTrack's context.\n        Probably you are making pipeline like this: audioTrack1.pipe(processor).pipe(audioTrack2.processorDestination).");e.track&&this.inputTrack!==e.track&&(this.audioProcessorContext.chained=!0,this.inputTrack=e.track,this.emit(Jy.ON_TRACK,this.inputTrack)),e.node&&this.inputNode!==e.node&&(this.audioProcessorContext.chained=!0,this.inputNode=e.node,this.emit(Jy.ON_NODE,this.inputNode));}}class HA extends iT{set chained(e){this._chained=e;}get chained(){return this._chained}constructor(e,t,i){super(),nu(this,"constraintsMap",new Map),nu(this,"statsRegistry",[]),nu(this,"audioContext",void 0),nu(this,"trackId",void 0),nu(this,"direction",void 0),nu(this,"usageRegistry",[]),nu(this,"_chained",!1),this.audioContext=e,this.trackId=t,this.direction=i;}async getConstraints(){return fT(this,zy.REQUEST_CONSTRAINTS)}getAudioContext(){return this.audioContext}async requestApplyConstraints(e,t){var i;return KC.info("processor ".concat(t.name," requestApplyConstraints for ").concat(this.trackId)),e&&this.constraintsMap.set(t,e),gT(this,zy.REQUEST_UPDATE_CONSTRAINTS,Array.from(kv(i=this.constraintsMap).call(i)))}async requestRevertConstraints(e){var t;if(this.constraintsMap.has(e))return this.constraintsMap.delete(e),gT(this,zy.REQUEST_UPDATE_CONSTRAINTS,Array.from(kv(t=this.constraintsMap).call(t)))}registerStats(e,t,i){this.statsRegistry.find((i=>i.processorID===e.ID&&i.processorName===e.name&&i.type===t))||this.statsRegistry.push({processorName:e.name,processorID:e.ID,type:t,cb:i});}unregisterStats(e,t){const i=this.statsRegistry.findIndex((i=>i.processorID===e.ID&&i.processorName===e.name&&i.type===t));-1!==i&&this.statsRegistry.splice(i,1);}gatherStats(){const e=[];for(const{processorID:t,processorName:i,type:n,cb:r}of this.statsRegistry)try{const s=r();e.push({processorID:t,processorName:i,type:n,stats:s});}catch(e){KC.error(new Vg(xg.UNEXPECTED_ERROR,e.message));}return e}registerUsage(e,t){this.usageRegistry.find((t=>t.processorID===e.ID&&t.processorName===e.name))||this.usageRegistry.push({processorID:e.ID,processorName:e.name,cb:t});}unregisterUsage(e){const t=this.usageRegistry.findIndex((t=>t.processorID===e.ID&&t.processorName===e.name));-1!==t&&this.usageRegistry.splice(t,1);}async gatherUsage(){const e=[];if(!this.chained)return [];for(const{cb:t}of this.usageRegistry)try{let i=t();i instanceof tg&&(i=await i),e.push(BA(BA({},i),{},{direction:this.direction}));}catch(e){KC.error("gather extension usage error",e);}return e}getDirection(){return this.direction}}class KA extends iT{get isPlayed(){return !0}get isFreeze(){return !1}constructor(){super(),nu(this,"context",void 0),nu(this,"processSourceNode",void 0),nu(this,"outputTrack",void 0),nu(this,"processedNode",void 0),nu(this,"clonedTrack",void 0),nu(this,"outputNode",void 0),this.outputNode=new YA;}setVolume(){}createOutputTrack(){throw new Vg(xg.NOT_SUPPORTED,"can not create output MediaStreamTrack when WebAudio disabled")}getOriginVolumeLevel(){return 0}getAccurateVolumeLevel(){return 0}stopGetAudioBuffer(){}startGetAudioBuffer(){}play(){}stop(){}destroy(){}updateTrack(){}updateOriginTrack(){}createMediaStreamSourceNode(){}}class YA{disconnect(){}connect(){}}let qA=null;class JA{constructor(){nu(this,"state","open"),nu(this,"trigger",void 0),nu(this,"tasks",[]),KC.debug("[macro-task-queue] is created."),this.trigger=window.setTimeout((()=>{this.state="closed",KC.debug("[macro-task-queue] will be closed, all remaining tasks will execute. [".concat(this.tasks.map((e=>e.key)),"]")),this.trigger=void 0,this.tasks.forEach((e=>{let{func:t}=e;return t()})),this.tasks.length=0,KC.debug("[macro-task-queue] is closed.");}));}enqueue(e,t){"closed"!==this.state&&(this.tasks.push({key:e,func:t}),KC.debug("[macro-task-queue] is queued, current queue ".concat(this.tasks.length,". ").concat("string"==typeof e?e:"")));}runTask(e){if("closed"===this.state)return;const t=this.tasks.findIndex((t=>t.key===e));if(-1!==t){const i=this.tasks.splice(t,1);KC.debug("[macro-task-queue] is unqueued, current queue ".concat(this.tasks.length,". ").concat("string"==typeof e?e:"")),i[0].func();}}release(){this.trigger&&(this.state="closed",clearTimeout(this.trigger),this.trigger=void 0,this.tasks.length=0,KC.debug("[macro-task-queue] is closed."));}}function zA(e){return function(t,i,n){var r;const s=null!==(r=n.value)&&void 0!==r?r:n.get,o=function(){qA&&"open"===qA.state&&qA.runTask(e);for(var t=arguments.length,i=new Array(t),n=0;n<t;n++)i[n]=arguments[n];return null==s?void 0:s.apply(this,...i)};return n.value?n.value=o:n.get=o,n}}function XA(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n);}return i}function QA(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?XA(Object(i),!0).forEach((function(t){nu(e,t,i[t]);})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):XA(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t));}));}return e}class ZA extends iA{get _source(){return this._trackSource}set _source(e){this._trackSource=e;}get processorContext(){return this._processorContext}set processorContext(e){this._processorContext=e;}get processorDestination(){return this._processorDestination}set processorDestination(e){this._processorDestination=e;}get isPlaying(){return this._useAudioElement?xA.isPlaying(this.getTrackId()):this._source.isPlayed}get __className__(){return "LocalAudioTrack"}constructor(e,t,i,n,r){super(e,i),nu(this,"trackMediaType","audio"),nu(this,"_encoderConfig",void 0),nu(this,"_trackSource",void 0),nu(this,"_enabled",!0),nu(this,"_volume",100),nu(this,"_useAudioElement",!1),nu(this,"_bypassWebAudio",!1),nu(this,"processor",void 0),nu(this,"_processorContext",void 0),nu(this,"_processorDestination",void 0),nu(this,"_getOriginVolumeLevel",void 0),this._encoderConfig=t,this._getOriginVolumeLevel=!!n;const s=()=>{this.processorContext=new HA(this._source.context,this.getTrackId(),"local"),this.processorDestination=new WA(this.processorContext),this.bindProcessorDestinationEvents(),this._source.on(jy.UPDATE_SOURCE,(()=>{this.processor&&this.processor.updateInput({node:this._source.processSourceNode,context:this.processorContext});}));},o=r&&Sg()&&!dA();if(kC("DISABLE_WEBAUDIO")?(this._source=new KA,this._useAudioElement=!0,this._bypassWebAudio=!0):o?this._source=new KA:(this._source=new fA(e,!1,this._getOriginVolumeLevel?e:void 0),kC("LOCAL_AUDIO_TRACK_USES_WEB_AUDIO")||(this._useAudioElement=!0)),s(),!kC("DISABLE_WEBAUDIO")&&o){(qA||(qA=new JA),qA).enqueue("INIT_WEBAUDIO",(()=>{this._source=new fA(e,!1,this._getOriginVolumeLevel?e:void 0),kC("LOCAL_AUDIO_TRACK_USES_WEB_AUDIO")||(this._useAudioElement=!0),s(),this.emit(Gy.UPDATE_TRACK_SOURCE);}));}}setVolume(e){jg(e,"volume",0,1e3),this._volume=e,this._source.setVolume(e/100),this._useAudioElement&&xA.setVolume(this.getTrackId(),e);try{if(this._bypassWebAudio)return void KC.debug("[".concat(this.getTrackId(),"] setVolume returned because no pass through WebAudio."));const e=this._source.createOutputTrack();this._mediaStreamTrack!==e&&(this._mediaStreamTrack=e,gT(this,Ly.NEED_REPLACE_TRACK,this).then((()=>{KC.debug("[".concat(this.getTrackId(),"] replace web audio track success"));})).catch((e=>{KC.warning("[".concat(this.getTrackId(),"] replace web audio track failed"),e);})));}catch(e){}}getVolumeLevel(){return this._muted&&this.enabled&&this._getOriginVolumeLevel?this._source.getOriginVolumeLevel():this._source.getAccurateVolumeLevel()}async setPlaybackDevice(e){if(!this._useAudioElement)throw new Vg(xg.NOT_SUPPORTED,"your browser does not support setting the audio output device");await xA.setSinkID(this.getTrackId(),e);}async setEnabled(e,t,i){return this._setEnabled(e,t,i)}async _setEnabled(e,t,i){if(!i){if(e===this._enabled)return;this.stateCheck("enabled",e);}if(KC.info("[".concat(this.getTrackId(),"] start setEnabled"),e),e){this._originMediaStreamTrack.enabled=!0;try{i||(this._enabled=!0),await gT(this,Ly.NEED_ENABLE_TRACK,this),KC.info("[".concat(this.getTrackId(),"] setEnabled to ").concat(e," success"));}catch(e){throw i||(this._enabled=!1),KC.error("[".concat(this.getTrackId(),"] setEnabled to true error"),e.toString()),e}}else {this._originMediaStreamTrack.enabled=!1,i||(this._enabled=!1);try{await gT(this,Ly.NEED_DISABLE_TRACK,this);}catch(e){throw i||(this._enabled=!0),KC.error("[".concat(this.getTrackId(),"] setEnabled to false error"),e.toString()),e}}}async setMuted(e){e!==this._muted&&(this.stateCheck("muted",e),this._muted=e,this._originMediaStreamTrack.enabled=!e,KC.debug("[".concat(this.getTrackId(),"] start set muted: ").concat(e)),e?await gT(this,Ly.NEED_MUTE_TRACK,this):await gT(this,Ly.NEED_UNMUTE_TRACK,this));}getStats(){NT((()=>{KC.warning("[deprecated] LocalAudioTrack.getStats will be removed in the future, use AgoraRTCClient.getLocalAudioStats instead");}),"localAudioTrackGetStatsWarning");const e=TT(this,Ly.GET_STATS);return e||QA({},Wy)}setAudioFrameCallback(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:4096;if(!e)return this._source.removeAllListeners(jy.ON_AUDIO_BUFFER),void this._source.stopGetAudioBuffer();this._source.startGetAudioBuffer(t),this._source.removeAllListeners(jy.ON_AUDIO_BUFFER),this._source.on(jy.ON_AUDIO_BUFFER,(t=>e(t)));}play(){KC.debug("[".concat(this.getTrackId(),"] start audio playback")),this._useAudioElement?(KC.debug("[".concat(this.getTrackId(),"] start audio playback in element")),xA.play(this._mediaStreamTrack,this.getTrackId(),this._volume)):this._source.play();}stop(){KC.debug("[".concat(this.getTrackId(),"] stop audio playback")),this._useAudioElement?xA.stop(this.getTrackId()):this._source.stop();}close(){super.close(),this.unbindProcessorDestinationEvents(),this.unbindProcessorContextEvents(),this.unpipe(),this.processorDestination._source&&this.processorDestination._source.unpipe(),this._source.destroy();}_updatePlayerSource(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];KC.debug("[".concat(this.getTrackId(),"] update player source track")),e&&this._source.updateTrack(this._mediaStreamTrack),this._useAudioElement&&xA.updateTrack(this.getTrackId(),this._mediaStreamTrack);}async _updateOriginMediaStreamTrack(e,t){this._originMediaStreamTrack!==e&&(this._originMediaStreamTrack&&(this._originMediaStreamTrack.removeEventListener("ended",this._handleTrackEnded),t&&this._originMediaStreamTrack.stop()),e.addEventListener("ended",this._handleTrackEnded),this._originMediaStreamTrack=e,this._muted&&(this._originMediaStreamTrack.enabled=!1),this.processor&&this.processor.updateInput({track:e,context:this.processorContext}),this._mediaStreamTrack!==this._source.outputTrack?(this._mediaStreamTrack=this._originMediaStreamTrack,this._updatePlayerSource(),await gT(this,Ly.NEED_REPLACE_TRACK,this)):this._source.updateTrack(this._originMediaStreamTrack),this._getOriginVolumeLevel&&this._source.updateOriginTrack(e));}renewMediaStreamTrack(e){return tg.resolve(void 0)}pipe(e){if(this._bypassWebAudio)throw new Vg(xg.INVALID_OPERATION,"Can not process AudioTrack when bypassWebAudio set to true.");if(this.processor===e)return e;if(e._source)throw new Vg(xg.INVALID_OPERATION,"Processor ".concat(e.name," already piped, please call unpipe beforehand."));return this.unpipe(),this.processor=e,this.processor._source=this,e.updateInput({track:this._originMediaStreamTrack,node:this._source.processSourceNode,context:this.processorContext}),e}unpipe(){var e;if(!this.processor)return;const t=this.processor;null===(e=this._source.processSourceNode)||void 0===e||e.disconnect(),this.processor._source=!1,this.processor=void 0,t.reset();}bindProcessorDestinationEvents(){this.processorDestination.on(Jy.ON_TRACK,(async e=>{e?e!==this._mediaStreamTrack&&(this._mediaStreamTrack=e,this._updatePlayerSource(!1),this._source.processedNode=this._source.createMediaStreamSourceNode(e),await gT(this,Ly.NEED_REPLACE_TRACK,this)):this._mediaStreamTrack!==this._originMediaStreamTrack&&(this._mediaStreamTrack=this._originMediaStreamTrack,this._updatePlayerSource(),await gT(this,Ly.NEED_REPLACE_TRACK,this));})),this.processorDestination.on(Jy.ON_NODE,(e=>{this._source.processedNode=e;}));}unbindProcessorDestinationEvents(){this.processorDestination.removeAllListeners(Jy.ON_TRACK),this.processorDestination.removeAllListeners(Jy.ON_NODE);}unbindProcessorContextEvents(){this.processorContext.removeAllListeners(zy.REQUEST_UPDATE_CONSTRAINTS),this.processorContext.removeAllListeners(zy.REQUEST_CONSTRAINTS);}}Mv([zA("INIT_WEBAUDIO"),Uv("design:type",Object),Uv("design:paramtypes",[Object])],ZA.prototype,"_source",null),Mv([zA("INIT_WEBAUDIO"),Uv("design:type",HA),Uv("design:paramtypes",[HA])],ZA.prototype,"processorContext",null),Mv([zA("INIT_WEBAUDIO"),Uv("design:type",WA),Uv("design:paramtypes",[WA])],ZA.prototype,"processorDestination",null),Mv([nv({argsMap:(e,t)=>[e.getTrackId(),t],throttleTime:300}),Uv("design:type",Function),Uv("design:paramtypes",[Number]),Uv("design:returntype",void 0)],ZA.prototype,"setVolume",null),Mv([nv({argsMap:(e,t)=>[e.getTrackId(),t]}),VA(),Uv("design:type",Function),Uv("design:paramtypes",[String]),Uv("design:returntype",tg)],ZA.prototype,"setPlaybackDevice",null),Mv([qT("LocalAudioTrack","_enabledMutex"),nv({argsMap:(e,t)=>[e.getTrackId(),t]}),VA(),Uv("design:type",Function),Uv("design:paramtypes",[Boolean,Object,Boolean]),Uv("design:returntype",tg)],ZA.prototype,"setEnabled",null),Mv([qT("LocalAudioTrack","_enabledMutex"),nv({argsMap:(e,t)=>[e.getTrackId(),t]}),VA(),Uv("design:type",Function),Uv("design:paramtypes",[Boolean]),Uv("design:returntype",tg)],ZA.prototype,"setMuted",null),Mv([VA(),Uv("design:type",Function),Uv("design:paramtypes",[]),Uv("design:returntype",Object)],ZA.prototype,"getStats",null),Mv([VA(),Uv("design:type",Function),Uv("design:paramtypes",[Object,Number]),Uv("design:returntype",void 0)],ZA.prototype,"setAudioFrameCallback",null),Mv([nv({argsMap:e=>[e.getTrackId()]}),VA(),Uv("design:type",Function),Uv("design:paramtypes",[]),Uv("design:returntype",void 0)],ZA.prototype,"play",null),Mv([nv({argsMap:e=>[e.getTrackId()]}),VA(),Uv("design:type",Function),Uv("design:paramtypes",[]),Uv("design:returntype",void 0)],ZA.prototype,"stop",null),Mv([nv({argsMap:e=>[e.getTrackId()]}),Uv("design:type",Function),Uv("design:paramtypes",[]),Uv("design:returntype",void 0)],ZA.prototype,"close",null),Mv([nv({argsMap:(e,t)=>[e.getTrackId(),t.name]}),Uv("design:type",Function),Uv("design:paramtypes",[Object]),Uv("design:returntype",Object)],ZA.prototype,"pipe",null),Mv([nv({argsMap:e=>[e.getTrackId()]}),Uv("design:type",Function),Uv("design:paramtypes",[]),Uv("design:returntype",void 0)],ZA.prototype,"unpipe",null);class $A extends ZA{get __className__(){return "MicrophoneAudioTrack"}constructor(e,t,i,n){super(e,t.encoderConfig?Ny(t.encoderConfig):{},n,kC("GET_VOLUME_OF_MUTED_AUDIO_TRACK"),!0),nu(this,"_config",void 0),nu(this,"_deviceName","default"),nu(this,"_constraints",void 0),nu(this,"_originalConstraints",void 0),nu(this,"_enabled",!0),this._config=t,this._constraints=i,this._originalConstraints=i,this._deviceName=e.label,"boolean"==typeof t.bypassWebAudio&&(this._bypassWebAudio=t.bypassWebAudio),(wg()||Og())&&oA.bindInterruptDetectorTrack(this),this.on(Gy.UPDATE_TRACK_SOURCE,(()=>{this.bindProcessorContextEvents();})),dA()&&this.bindProcessorContextEvents();}async setDevice(e){if(KC.info("[".concat(this.getTrackId(),"] start set device to ").concat(e)),this._enabled)try{const t=await OA.getDeviceById(e),i={};i.audio=QA({},this._constraints),i.audio.deviceId={exact:e},this._originMediaStreamTrack.stop();let n=null;try{n=await yA(i,this.getTrackId());}catch(e){throw KC.error("[".concat(this.getTrackId(),"] setDevice failed"),e.toString()),n=await yA({audio:this._constraints},this.getTrackId()),await this._updateOriginMediaStreamTrack(n.getAudioTracks()[0],!1),e}await this._updateOriginMediaStreamTrack(n.getAudioTracks()[0],!1),this._deviceName=t.label,this._config.microphoneId=e,this._constraints.deviceId={exact:e};}catch(e){throw KC.error("[".concat(this.getTrackId(),"] setDevice error"),e.toString()),e}else try{const t=await OA.getDeviceById(e);this._deviceName=t.label,this._config.microphoneId=e,this._constraints.deviceId={exact:e};}catch(e){throw KC.error("[".concat(this.getTrackId(),"] setDevice error"),e.toString()),e}KC.info("[".concat(this.getTrackId(),"] set device to ").concat(e," success"));}async setEnabled(e,t,i){if(t)return KC.debug("[".concat(this.getTrackId(),"] setEnabled false (do not close microphone)")),await super._setEnabled(e);if(!i){if(e===this._enabled)return;this.stateCheck("enabled",e);}if(KC.info("[".concat(this.getTrackId(),"] start setEnabled"),e),!e){var n;this._originMediaStreamTrack.onended=null,this._originMediaStreamTrack.stop(),null===(n=this._source.clonedTrack)||void 0===n||n.stop(),i||(this._enabled=!1);try{await gT(this,Ly.NEED_DISABLE_TRACK,this);}catch(e){throw KC.error("[".concat(this.getTrackId(),"] setEnabled false failed"),e.toString()),e}return}const r=QA({},this._constraints),s=OA.searchDeviceIdByName(this._deviceName);s&&!r.deviceId&&(r.deviceId=s);try{i||(this._enabled=!0);const e=await yA({audio:this._constraints},this.getTrackId());await this._updateOriginMediaStreamTrack(e.getAudioTracks()[0],!1),await gT(this,Ly.NEED_ENABLE_TRACK,this);}catch(e){throw i||(this._enabled=!1),KC.error("[".concat(this.getTrackId(),"] setEnabled true failed"),e.toString()),e}KC.info("[".concat(this.getTrackId(),"] setEnabled success"));}close(){super.close(),(wg()||Og())&&oA.unbindInterruptDetectorTrack(this);}onTrackEnded(){if((Cg()||Dg())&&this._enabled&&!this._isClosed&&oA.duringInterruption){const e=async()=>{oA.off(uy.IOS_INTERRUPTION_END,e),this._enabled&&!this._isClosed&&(KC.debug("[".concat(this.getTrackId(),"] try capture microphone media device for interrupted iOS device.")),await this.setEnabled(!1),await this.setEnabled(!0));};oA.on(uy.IOS_INTERRUPTION_END,e);}else KC.debug("[".concat(this.getTrackId(),"] track ended")),this.safeEmit(Fy.TRACK_ENDED);}async renewMediaStreamTrack(e){const t=e||this._constraints,i=OA.searchDeviceIdByName(this._deviceName);if(i&&!t.deviceId&&(t.deviceId=i),this._constraints=t,this._enabled){this._originMediaStreamTrack.stop();const e=await yA({audio:this._constraints},this.getTrackId());await this._updateOriginMediaStreamTrack(e.getAudioTracks()[0],!0);}}bindProcessorContextEvents(){this.processorContext.on(zy.REQUEST_UPDATE_CONSTRAINTS,(async(e,t,i)=>{try{const i=Object.assign({},this._originalConstraints,...e);await this.renewMediaStreamTrack(i),t();}catch(e){i(e);}})),this.processorContext.on(zy.REQUEST_CONSTRAINTS,(async e=>{e(this._originMediaStreamTrack.getSettings());}));}}Mv([nv({argsMap:(e,t)=>[e.getTrackId(),t]}),VA(),Uv("design:type",Function),Uv("design:paramtypes",[String]),Uv("design:returntype",tg)],$A.prototype,"setDevice",null),Mv([qT("MicrophoneAudioTrack","_enabledMutex"),nv({argsMap:(e,t,i)=>[e.getTrackId(),t,i]}),VA(),Uv("design:type",Function),Uv("design:paramtypes",[Boolean,Boolean,Boolean]),Uv("design:returntype",tg)],$A.prototype,"setEnabled",null),Mv([nv({argsMap:e=>[e.getTrackId()]}),Uv("design:type",Function),Uv("design:paramtypes",[]),Uv("design:returntype",void 0)],$A.prototype,"close",null);class eb extends ZA{get __className__(){return "BufferSourceAudioTrack"}constructor(e,t,i,n){super(t.createOutputTrack(),i,n),nu(this,"source",void 0),nu(this,"_bufferSource",void 0),this.source=e,this._bufferSource=t,this._bufferSource.on(jy.AUDIO_SOURCE_STATE_CHANGE,(e=>{this.safeEmit(Fy.SOURCE_STATE_CHANGE,e);}));try{this._mediaStreamTrack=this._source.createOutputTrack();}catch(e){}}get currentState(){return this._bufferSource.currentState}get duration(){return this._bufferSource.duration}get playbackSpeed(){return this._bufferSource.playbackSpeed}getCurrentTime(){return this._bufferSource.currentTime}startProcessAudioBuffer(e){e&&this._bufferSource.updateOptions(e),this._bufferSource.startProcessAudioBuffer();}pauseProcessAudioBuffer(){this._bufferSource.pauseProcessAudioBuffer();}seekAudioBuffer(e){this._bufferSource.seekAudioBuffer(e);}resumeProcessAudioBuffer(){this._bufferSource.resumeProcessAudioBuffer();}stopProcessAudioBuffer(){this._bufferSource.stopProcessAudioBuffer();}close(){this.source=null,this._bufferSource.destroy(),super.close();}setAudioBufferPlaybackSpeed(e){jg(e,"speed",0),this._bufferSource.setAudioBufferPlaybackSpeed(e);}}Mv([nv({argsMap:(e,t)=>[e.getTrackId(),t,e.duration]}),VA(),Uv("design:type",Function),Uv("design:paramtypes",[Object]),Uv("design:returntype",void 0)],eb.prototype,"startProcessAudioBuffer",null),Mv([nv({argsMap:e=>[e.getTrackId()]}),VA(),Uv("design:type",Function),Uv("design:paramtypes",[]),Uv("design:returntype",void 0)],eb.prototype,"pauseProcessAudioBuffer",null),Mv([nv({argsMap:e=>[e.getTrackId()]}),VA(),Uv("design:type",Function),Uv("design:paramtypes",[Number]),Uv("design:returntype",void 0)],eb.prototype,"seekAudioBuffer",null),Mv([nv({argsMap:e=>[e.getTrackId()]}),VA(),Uv("design:type",Function),Uv("design:paramtypes",[]),Uv("design:returntype",void 0)],eb.prototype,"resumeProcessAudioBuffer",null),Mv([nv({argsMap:e=>[e.getTrackId()]}),VA(),Uv("design:type",Function),Uv("design:paramtypes",[]),Uv("design:returntype",void 0)],eb.prototype,"stopProcessAudioBuffer",null),Mv([nv({argsMap:e=>[e.getTrackId()]}),Uv("design:type",Function),Uv("design:paramtypes",[]),Uv("design:returntype",void 0)],eb.prototype,"close",null),Mv([nv({argsMap:e=>[e.getTrackId()]}),VA(),Uv("design:type",Function),Uv("design:paramtypes",[Number]),Uv("design:returntype",void 0)],eb.prototype,"setAudioBufferPlaybackSpeed",null);class tb extends ZA{get __className__(){return "MixingAudioTrack"}get isActive(){for(const e of this.trackList)if(e._enabled&&!e._isClosed&&!e.muted)return !0;return !1}constructor(){const e=cA().createMediaStreamDestination();super(e.stream.getAudioTracks()[0],void 0,xT(8,"track-mix-")),nu(this,"trackList",void 0),nu(this,"destNode",void 0);try{this._mediaStreamTrack=this._source.createOutputTrack();}catch(e){}this.destNode=e,this.trackList=[];}hasAudioTrack(e){return -1!==this.trackList.indexOf(e)}addAudioTrack(e){-1===this.trackList.indexOf(e)?(KC.debug("add ".concat(e.getTrackId()," to mixing track")),e._source.outputNode.connect(this.destNode),this.trackList.push(e),this.updateEncoderConfig()):KC.debug("track ".concat(e.getTrackId()," is already added"));}removeAudioTrack(e){if(-1!==this.trackList.indexOf(e)){KC.debug("remove ".concat(e.getTrackId()," from mixing track"));try{e._source.outputNode.disconnect(this.destNode);}catch(e){}IT(this.trackList,e),this.updateEncoderConfig();}}updateEncoderConfig(){const e={};this.trackList.forEach((t=>{t._encoderConfig&&((t._encoderConfig.bitrate||0)>(e.bitrate||0)&&(e.bitrate=t._encoderConfig.bitrate),(t._encoderConfig.sampleRate||0)>(e.sampleRate||0)&&(e.sampleRate=t._encoderConfig.sampleRate),(t._encoderConfig.sampleSize||0)>(e.sampleSize||0)&&(e.sampleSize=t._encoderConfig.sampleSize),t._encoderConfig.stereo&&(e.stereo=!0));})),this._encoderConfig=e;}_updateRtpTransceiver(e){this._rtpTransceiver!==e&&(this._rtpTransceiver=e,this.trackList.forEach((t=>{t instanceof tb?t.emit(Vy.TRANSCEIVER_UPDATED,e):t._updateRtpTransceiver(e);})));}}function ib(e){const t={};e.facingMode&&(t.facingMode=e.facingMode),e.cameraId&&(t.deviceId={exact:e.cameraId});const i=Ay(e.encoderConfig);return null!=i.width&&(t.width=i.width),null!=i.height&&(t.height=i.height),!Lg()&&i.frameRate&&(t.frameRate=i.frameRate),pg().name===cg.EDGE&&"object"==typeof t.frameRate&&(t.frameRate.max=60),Rg()&&(t.frameRate={ideal:30,max:30}),t}function nb(e){const t={};if(Lg()||(void 0!==e.AGC&&(t.autoGainControl=e.AGC),void 0!==e.AEC&&(t.echoCancellation=e.AEC),void 0!==e.ANS&&(t.noiseSuppression=e.ANS,Tg()&&e.ANS&&(t.googHighpassFilter=e.ANS))),e.encoderConfig){const i=Ny(e.encoderConfig);t.channelCount=i.stereo?2:1,t.sampleRate=i.sampleRate,t.sampleSize=i.sampleSize;}return e.microphoneId&&(t.deviceId={exact:e.microphoneId}),Mg()&&(t.sampleRate=void 0),t}class rb extends mA{set currentState(e){e!==this._currentState&&(this._currentState=e,this.safeEmit(jy.AUDIO_SOURCE_STATE_CHANGE,this._currentState));}get currentState(){return this._currentState}constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};super(),nu(this,"audioBuffer",void 0),nu(this,"sourceNode",void 0),nu(this,"startPlayTime",0),nu(this,"startPlayOffset",0),nu(this,"pausePlayTime",0),nu(this,"options",void 0),nu(this,"currentLoopCount",0),nu(this,"currentPlaybackSpeed",100),nu(this,"_currentState","stopped"),this.audioBuffer=e,this.options=t,this.startPlayOffset=this.options.startPlayTime||0;}createWebAudioDiagram(){return this.context.createGain()}get duration(){return this.audioBuffer?this.audioBuffer.duration:0}get playbackSpeed(){return this.currentPlaybackSpeed}get currentTime(){return this.audioBuffer?"stopped"===this.currentState?0:"paused"===this.currentState?this.pausePlayTime:((this.context.currentTime-this.startPlayTime)*(this.playbackSpeed/100)+this.startPlayOffset)%this.audioBuffer.duration:0}updateOptions(e){"stopped"===this.currentState?(this.options=e,this.startPlayOffset=this.options.startPlayTime||0):KC.warning("can not set audio source options");}startProcessAudioBuffer(){this.sourceNode&&this.stopProcessAudioBuffer(),this.sourceNode=this.createSourceNode(),this.startSourceNode(),this.currentState="playing";}pauseProcessAudioBuffer(){this.sourceNode&&"playing"===this.currentState&&(this.pausePlayTime=this.currentTime,this.sourceNode.onended=null,this.sourceNode.stop(),this.sourceNode.buffer=null,this.sourceNode=this.createSourceNode(),this.currentState="paused");}seekAudioBuffer(e){this.sourceNode&&(this.sourceNode.onended=null,"playing"===this.currentState&&this.sourceNode.stop(),this.sourceNode=this.createSourceNode(),"playing"===this.currentState?(this.startPlayOffset=e,this.startSourceNode()):"paused"===this.currentState&&(this.pausePlayTime=e));}resumeProcessAudioBuffer(){"paused"===this.currentState&&this.sourceNode&&(this.startPlayOffset=this.pausePlayTime,this.pausePlayTime=0,this.startSourceNode(),this.currentState="playing");}stopProcessAudioBuffer(){if(this.sourceNode){this.sourceNode.onended=null;try{this.sourceNode.stop();}catch(e){}this.reset();}}destroy(){this.audioBuffer=null,super.destroy();}setAudioBufferPlaybackSpeed(e){this.sourceNode&&("playing"===this.currentState&&(this.startPlayOffset=this.currentTime,this.startPlayTime=this.context.currentTime),this.sourceNode.playbackRate.value=e/100),this.currentPlaybackSpeed=e;}startSourceNode(){this.sourceNode&&this.sourceNode.buffer&&(this.sourceNode.start(0,this.startPlayOffset),this.startPlayTime=this.context.currentTime,this.sourceNode.onended=this.handleSourceNodeEnded.bind(this));}createSourceNode(){const e=this.context.createBufferSource();return e.buffer=this.audioBuffer,e.loop=!!this.options.loop,e.connect(this.outputNode),e.playbackRate.value=this.currentPlaybackSpeed/100,e}handleSourceNodeEnded(){if(this.currentLoopCount+=1,this.options.cycle&&this.options.cycle>this.currentLoopCount)return this.startPlayOffset=0,this.sourceNode=void 0,void this.startProcessAudioBuffer();this.reset();}reset(){this.startPlayOffset=this.options.startPlayTime||0,this.currentState="stopped",this.sourceNode&&(this.sourceNode.disconnect(),this.sourceNode=void 0),this.currentLoopCount=0;}}const sb=new Map;async function ob(e,t){let i=null;if("string"==typeof e){const t=sb.get(e);if(t)return KC.debug("use cached audio resource: ",e),t;try{i=(await XT((()=>EC.get(e,{responseType:"arraybuffer"})),void 0,void 0,{maxRetryCount:3})).data;}catch(e){throw new Vg(xg.FETCH_AUDIO_FILE_FAILED,e.toString())}}else {const t=new tg(((t,i)=>{const n=new FileReader;n.onload=e=>{e.target?t(e.target.result):i(new Vg(xg.READ_LOCAL_AUDIO_FILE_ERROR));},n.onerror=()=>{i(new Vg(xg.READ_LOCAL_AUDIO_FILE_ERROR));},n.readAsArrayBuffer(e);}));i=await t;}const n=await function(e){const t=cA();return new tg(((i,n)=>{t.decodeAudioData(e,(e=>{i(e);}),(e=>{n(new Vg(xg.DECODE_AUDIO_FILE_FAILED,e.toString()));}));}))}(i);return "string"==typeof e&&t&&sb.set(e,n),n}const ab=e=>{const t=document.createElement("canvas");return t.width=2,t.height=2,new tg(((i,n)=>{t.toBlob((async e=>{if(t.remove(),e){const n=await cb(e);i({buffer:n,width:t.width,height:t.height});}else n(new Vg(xg.CONVERTING_VIDEO_FRAME_TO_BLOB_FAILED));}),e,1);}))},cb=async e=>{const t=await e.arrayBuffer();return new Uint8Array(t)};const db=new class extends iT{get visibility(){return document.visibilityState}get lastHiddenTime(){return this._lastHiddenTime}get lastVisibleTime(){return this._lastVisibleTime}constructor(){super(),nu(this,"_lastHiddenTime",0),nu(this,"_lastVisibleTime",0),document.addEventListener("visibilitychange",(()=>{"hidden"===document.visibilityState?this._lastHiddenTime=performance.now():this._lastVisibleTime=performance.now(),KC.debug("document visibility went ".concat(document.visibilityState)),this.emit("VISIBILITY_CHANGE",document.visibilityState);}));}};function lb(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n);}return i}function hb(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?lb(Object(i),!0).forEach((function(t){nu(e,t,i[t]);})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):lb(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t));}));}return e}class ub{get videoElementStatus(){return this._videoElementStatus}set videoElementStatus(e){e!==this._videoElementStatus&&(KC.debug("[".concat(this.trackId,"] video-element-status change ").concat(this._videoElementStatus," => ").concat(e)),this._videoElementStatus=e);}constructor(e){nu(this,"trackId",void 0),nu(this,"config",void 0),nu(this,"onFirstVideoFrameDecoded",void 0),nu(this,"freezeTimeCounterList",[]),nu(this,"renderFreezeAccTime",0),nu(this,"isKeepLastFrame",!1),nu(this,"timeUpdatedCount",0),nu(this,"freezeTime",0),nu(this,"playbackTime",0),nu(this,"lastTimeUpdatedTime",0),nu(this,"autoplayFailed",!1),nu(this,"videoTrack",void 0),nu(this,"videoElement",void 0),nu(this,"cacheVideoElement",void 0),nu(this,"videoElementCheckInterval",void 0),nu(this,"_videoElementStatus",Zy.NONE),nu(this,"isGettingVideoDimensions",!1),nu(this,"startGetVideoDimensions",(()=>{const e=()=>{if(this.isGettingVideoDimensions=!0,this.videoElement.videoWidth*this.videoElement.videoHeight>4)return KC.debug("[".concat(this.trackId,"] current video dimensions:"),this.videoElement.videoWidth,this.videoElement.videoHeight),void(this.isGettingVideoDimensions=!1);setTimeout(e,500);};!this.isGettingVideoDimensions&&e();})),nu(this,"autoResumeAfterInterruption",(()=>{this.videoTrack&&"live"===this.videoTrack.readyState&&"running"===oA.curState&&(KC.debug("[track-".concat(this.trackId,"] video element paused, auto resume for ").concat(Eg())),Ng()?(this.videoElement.srcObject=null,this.videoElement.srcObject=new MediaStream([this.videoTrack]),this.videoElement.play()):(this.videoElement.pause(),this.videoElement.play()));})),nu(this,"handleVideoEvents",(e=>{switch(e.type){case"play":case"playing":this.startGetVideoDimensions(),this.videoElementStatus=Zy.PLAYING;break;case"loadeddata":if(this.onFirstVideoFrameDecoded&&this.onFirstVideoFrameDecoded(),this.cacheVideoElement){try{this.cacheVideoElement.srcObject=null,this.cacheVideoElement.remove();}catch(e){}this.cacheVideoElement=void 0;}break;case"canplay":this.videoElementStatus=Zy.CANPLAY;break;case"stalled":this.videoElementStatus=Zy.STALLED;break;case"suspend":this.videoElementStatus=Zy.SUSPEND;break;case"pause":this.videoElementStatus=Zy.PAUSED,Cg()||Dg()||Sg()&&this.autoplayFailed||!this.videoTrack||"live"!==this.videoTrack.readyState||(KC.debug("[track-".concat(this.trackId,"] video element paused, auto resume")),this.videoElement.play());break;case"waiting":this.videoElementStatus=Zy.WAITING;break;case"abort":this.videoElementStatus=Zy.ABORT;break;case"ended":this.videoElementStatus=Zy.ENDED;break;case"emptied":this.videoElementStatus=Zy.EMPTIED;break;case"error":{this.videoElementStatus=Zy.ERROR;const e=this.videoElement.error;e&&KC.error("[".concat(this.trackId,"] media error, code: ").concat(e.code,", message: ").concat(e.message));break}case"timeupdate":{const e=performance.now();if(this.timeUpdatedCount+=1,this.timeUpdatedCount<10)return void(this.lastTimeUpdatedTime=e);const t=e-this.lastTimeUpdatedTime,i=this.lastTimeUpdatedTime;if(this.lastTimeUpdatedTime=e,db.lastVisibleTime<db.lastHiddenTime||i<db.lastHiddenTime||i<db.lastVisibleTime)return;for(t>kC("VIDEO_FREEZE_DURATION")&&(this.freezeTime+=t),this.playbackTime+=t;this.playbackTime>=6e3;){this.playbackTime-=6e3;const e=Math.min(6e3,this.freezeTime);this.freezeTimeCounterList.push(e),this.freezeTime=Math.max(0,this.freezeTime-6e3);}break}}})),nu(this,"autoResumeAfterInterruptionOnIOS15_16",(()=>{this.videoTrack&&"live"===this.videoTrack.readyState&&(KC.debug("[track-".concat(this.trackId,"] video element paused, auto resume for ").concat(Eg())),Ng()?(this.videoElement.srcObject=null,this.videoElement.srcObject=new MediaStream([this.videoTrack]),this.videoElement.play()):(this.videoElement.pause(),this.videoElement.play()));})),this.trackId=e.trackId,this.config=e,e.element instanceof HTMLVideoElement?this.videoElement=e.element:this.videoElement=document.createElement("video"),oA.on(uy.IOS_INTERRUPTION_END,this.autoResumeAfterInterruption),oA.on(uy.IOS_15_16_INTERRUPTION_END,this.autoResumeAfterInterruptionOnIOS15_16);}getVideoElement(){return this.videoElement}getContainerElement(){var e;return null!==(e=this.videoElement.parentElement)&&void 0!==e?e:void 0}updateConfig(e){this.config=e,this.trackId=e.trackId,e.element!==this.videoElement&&(this.destroy(),this.videoElement=e.element),this.videoTrack&&this.initVideoElement();}updateVideoTrack(e){this.videoTrack!==e&&(this.videoTrack=e,this.initVideoElement());}play(e){const t=this.videoElement.play();t&&t.catch&&t.catch((t=>{e&&MA(e,"video",t.message,this.trackId),"NotAllowedError"===t.name?(KC.warning("detected video element autoplay failed",t),this.autoplayFailed=!0,this.handleAutoPlayFailed()):KC.warning("[".concat(this.trackId,"] play warning: "),t);}));const i=pg();if(("Safari"===i.name&&15===Number(i.version)||wg())&&t&&t.then){const e=()=>{this.config.mirror&&(this.videoElement.style.transform="rotateY(180deg)");};t.then(e).catch(e);}}getCurrentFrame(){const e=document.createElement("canvas");e.width=this.videoElement.videoWidth,e.height=this.videoElement.videoHeight;const t=e.getContext("2d");if(!t)return KC.error("create canvas context failed!"),new ImageData(2,2);t.drawImage(this.videoElement,0,0,e.width,e.height);const i=t.getImageData(0,0,e.width,e.height);return e.remove(),i}async getCurrentFrameToUint8Array(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;const i=document.createElement("canvas");i.width=this.videoElement.videoWidth,i.height=this.videoElement.videoHeight;const n=i.getContext("2d");return n?(n.drawImage(this.videoElement,0,0,i.width,i.height),new tg(((n,r)=>{i.toBlob((async e=>{if(i.remove(),e){const t=await cb(e);n({buffer:t,width:i.width,height:i.height});}else r(new Vg(xg.CONVERTING_VIDEO_FRAME_TO_BLOB_FAILED));}),e,t<0?.1:t>1?1:t);}))):await ab(e)}destroy(){oA.off(uy.IOS_INTERRUPTION_END,this.autoResumeAfterInterruption),oA.off(uy.IOS_15_16_INTERRUPTION_END,this.autoResumeAfterInterruptionOnIOS15_16),this.videoElement.srcObject=null,this.resetVideoElement(),this.freezeTimeCounterList=[];}initVideoElement(){if(this.videoElementStatus=Zy.INIT,!this.videoElementCheckInterval&&(pb.forEach((e=>{this.videoElement.addEventListener(e,this.handleVideoEvents);})),this.videoElementCheckInterval=window.setInterval((()=>{(function(e){return e!==document.body&&document.body.contains(e)})(this.videoElement)||(this.videoElementStatus=Zy.DESTROYED);}),1e3),kC("ENABLE_VIDEO_FRAME_CALLBACK"))){var e,t;let i;const n=(e,t)=>{if(this.videoElementStatus===Zy.PLAYING){if(i){const e=t.presentationTime-i.presentationTime;e>kC("VIDEO_FREEZE_DURATION")&&db.lastVisibleTime>=db.lastHiddenTime&&i.timestamp>db.lastVisibleTime&&i.timestamp>db.lastHiddenTime&&(this.renderFreezeAccTime+=e);}i=hb(hb({},t),{},{timestamp:e});}var r,s;kC("ENABLE_VIDEO_FRAME_CALLBACK")&&(null===(r=(s=this.videoElement).requestVideoFrameCallback)||void 0===r||r.call(s,n));};null===(e=(t=this.videoElement).requestVideoFrameCallback)||void 0===e||e.call(t,n);}this.videoElement.controls=!1,this.videoElement.setAttribute("playsinline",""),Mg()&&(this.videoElement.poster="noposter");const i=pg();if("Safari"===i.name&&15===Number(i.version)||wg()||!this.config.mirror||(this.videoElement.style.transform="rotateY(180deg)"),this.config.fit?this.videoElement.style.objectFit=this.config.fit:this.videoElement.style.objectFit="cover",this.videoElement.setAttribute("muted",""),this.videoElement.muted=!0,this.videoElement.srcObject&&this.videoElement.srcObject instanceof MediaStream){this.videoElement.srcObject.getVideoTracks()[0]!==this.videoTrack&&(this.videoElement.srcObject=this.videoTrack?new MediaStream([this.videoTrack]):null,Rg()&&this.videoElement.load());}else this.videoElement.srcObject=this.videoTrack?new MediaStream([this.videoTrack]):null,Rg()&&this.videoElement.load();const n=this.videoElement.play();void 0!==n&&n.catch((e=>{KC.debug("[".concat(this.trackId,"] playback interrupted"),e.toString());}));}resetVideoElement(){pb.forEach((e=>{this.videoElement&&this.videoElement.removeEventListener(e,this.handleVideoEvents);})),this.videoElementCheckInterval&&(window.clearInterval(this.videoElementCheckInterval),this.videoElementCheckInterval=void 0),this.videoElementStatus=Zy.NONE;}handleAutoPlayFailed(){const e=t=>{t.preventDefault(),this.videoElement.play().then((()=>{KC.debug("[".concat(this.trackId,"] Video element for trackId:").concat(this.trackId," autoplay resumed."));})).catch((e=>{KC.error(e);})),this.autoplayFailed=!1,Ug()?document.body.removeEventListener("click",e,!0):(document.body.removeEventListener("touchstart",e,!0),document.body.removeEventListener("mousedown",e,!0));};Ug()?document.body.addEventListener("click",e,!0):(document.body.addEventListener("touchstart",e,!0),document.body.addEventListener("mousedown",e,!0)),PA();}}const pb=["play","playing","loadeddata","canplay","pause","stalled","suspend","waiting","abort","emptied","ended","timeupdate","error"];class _b extends ub{constructor(e){super(e),nu(this,"container",void 0),nu(this,"slot",void 0),this.slot=e.element,this.updateConfig(e);}updateConfig(e){this.config=e,this.trackId=e.trackId;const t=e.element;t!==this.slot&&(this.destroy(),this.slot=t),this.createElements();}updateVideoTrack(e){this.videoTrack!==e&&(this.videoTrack=e,this.createElements());}play(e){var t;null!==(t=this.container)&&void 0!==t&&t.contains(this.videoElement)&&super.play(e);}getCurrentFrame(){var e;return null!==(e=this.container)&&void 0!==e&&e.contains(this.videoElement)?super.getCurrentFrame():new ImageData(2,2)}async getCurrentFrameToUint8Array(e){var t;let i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return null!==(t=this.container)&&void 0!==t&&t.contains(this.videoElement)?await super.getCurrentFrameToUint8Array(e,i):await ab(e)}destroy(){if(super.destroy(),this.videoElement.remove(),this.videoElement=document.createElement("video"),this.container){try{this.container.remove(),this.slot.removeChild(this.container);}catch(e){}this.container=void 0;}}createElements(){this.container||(this.container=document.createElement("div")),this.container.id="agora-video-player-".concat(this.trackId),this.container.style.width="100%",this.container.style.height="100%",this.container.style.position="relative",this.container.style.overflow="hidden",this.videoTrack?(this.container.style.backgroundColor="black",kC("KEEP_LAST_FRAME")&&this.isKeepLastFrame&&this.videoElement.paused&&this.resetVideoElement(),this.mountedVideoElement()):this.unmountedVideoElement(),this.slot.appendChild(this.container);}mountedVideoElement(){var e;!this.container||null!==(e=this.container)&&void 0!==e&&e.contains(this.videoElement)||this.container.appendChild(this.videoElement),super.initVideoElement(),this.videoElement.id="video_".concat(this.trackId),this.videoElement.className="agora_video_player",this.videoElement.style.width="100%",this.videoElement.style.height="100%",this.videoElement.style.position="absolute",this.videoElement.style.left="0",this.videoElement.style.top="0";}unmountedVideoElement(){var e;if(null!==(e=this.container)&&void 0!==e&&e.contains(this.videoElement)){super.resetVideoElement();try{this.container&&this.container.removeChild(this.videoElement);}catch(e){}this.videoElement=document.createElement("video");}}resetVideoElement(){var e;null!==(e=this.container)&&void 0!==e&&e.contains(this.videoElement)&&(super.resetVideoElement(),this.cacheVideoElement=this.videoElement,this.videoElement=document.createElement("video"));}getContainerElement(){return this.container}}function Eb(e){return new tg(((t,i)=>{let n=!1;const r=document.createElement("video");r.setAttribute("autoplay",""),r.setAttribute("muted",""),r.muted=!0,r.autoplay=!0,r.setAttribute("playsinline",""),r.setAttribute("style","position: fixed; top: 0; left: 0; width: 1px; height: 1px"),document.body.appendChild(r);const s=Cg()?"canplay":"playing";r.addEventListener(s,(()=>{const e=r.videoWidth,i=r.videoHeight;!e&&Rg()||(n=!0,r.srcObject=null,r.remove(),t([e,i]));})),r.srcObject=new MediaStream([e]),r.play().catch(FT),setTimeout((()=>{n||(r.srcObject=null,r.remove(),t([r.videoWidth,r.videoHeight]));}),4e3);}))}const mb=async(e,t,i)=>{const n=function(e){const t=[];for(let i=0;i<e.length;i+=2)t.push(parseInt(e.slice(i,i+2),16));return Uint8Array.from(t)}(function(e){const t="0123456789abcdef";function i(e){let i,n="";for(i=0;i<=3;i++)n+=t.charAt(e>>8*i+4&15)+t.charAt(e>>8*i&15);return n}function n(e,t){const i=(65535&e)+(65535&t);return (e>>16)+(t>>16)+(i>>16)<<16|65535&i}function r(e,t,i,r,s,o){return n(function(e,t){return e<<t|e>>>32-t}(n(n(t,e),n(r,o)),s),i)}function s(e,t,i,n,s,o,a){return r(t&i|~t&n,e,t,s,o,a)}function o(e,t,i,n,s,o,a){return r(t&n|i&~n,e,t,s,o,a)}function a(e,t,i,n,s,o,a){return r(t^i^n,e,t,s,o,a)}function c(e,t,i,n,s,o,a){return r(i^(t|~n),e,t,s,o,a)}const d=function(e){let t;const i=1+(e.length+8>>6),n=new Array(16*i);for(t=0;t<16*i;t++)n[t]=0;for(t=0;t<e.length;t++)n[t>>2]|=e.charCodeAt(t)<<t%4*8;return n[t>>2]|=128<<t%4*8,n[16*i-2]=8*e.length,n}(e);let l,h,u,p,_,E=1732584193,m=-271733879,f=-1732584194,g=271733878;for(l=0;l<d.length;l+=16)h=E,u=m,p=f,_=g,E=s(E,m,f,g,d[l+0],7,-680876936),g=s(g,E,m,f,d[l+1],12,-389564586),f=s(f,g,E,m,d[l+2],17,606105819),m=s(m,f,g,E,d[l+3],22,-1044525330),E=s(E,m,f,g,d[l+4],7,-176418897),g=s(g,E,m,f,d[l+5],12,1200080426),f=s(f,g,E,m,d[l+6],17,-1473231341),m=s(m,f,g,E,d[l+7],22,-45705983),E=s(E,m,f,g,d[l+8],7,1770035416),g=s(g,E,m,f,d[l+9],12,-1958414417),f=s(f,g,E,m,d[l+10],17,-42063),m=s(m,f,g,E,d[l+11],22,-1990404162),E=s(E,m,f,g,d[l+12],7,1804603682),g=s(g,E,m,f,d[l+13],12,-40341101),f=s(f,g,E,m,d[l+14],17,-1502002290),m=s(m,f,g,E,d[l+15],22,1236535329),E=o(E,m,f,g,d[l+1],5,-165796510),g=o(g,E,m,f,d[l+6],9,-1069501632),f=o(f,g,E,m,d[l+11],14,643717713),m=o(m,f,g,E,d[l+0],20,-373897302),E=o(E,m,f,g,d[l+5],5,-701558691),g=o(g,E,m,f,d[l+10],9,38016083),f=o(f,g,E,m,d[l+15],14,-660478335),m=o(m,f,g,E,d[l+4],20,-405537848),E=o(E,m,f,g,d[l+9],5,568446438),g=o(g,E,m,f,d[l+14],9,-1019803690),f=o(f,g,E,m,d[l+3],14,-187363961),m=o(m,f,g,E,d[l+8],20,1163531501),E=o(E,m,f,g,d[l+13],5,-1444681467),g=o(g,E,m,f,d[l+2],9,-51403784),f=o(f,g,E,m,d[l+7],14,1735328473),m=o(m,f,g,E,d[l+12],20,-1926607734),E=a(E,m,f,g,d[l+5],4,-378558),g=a(g,E,m,f,d[l+8],11,-2022574463),f=a(f,g,E,m,d[l+11],16,1839030562),m=a(m,f,g,E,d[l+14],23,-35309556),E=a(E,m,f,g,d[l+1],4,-1530992060),g=a(g,E,m,f,d[l+4],11,1272893353),f=a(f,g,E,m,d[l+7],16,-155497632),m=a(m,f,g,E,d[l+10],23,-1094730640),E=a(E,m,f,g,d[l+13],4,681279174),g=a(g,E,m,f,d[l+0],11,-358537222),f=a(f,g,E,m,d[l+3],16,-722521979),m=a(m,f,g,E,d[l+6],23,76029189),E=a(E,m,f,g,d[l+9],4,-640364487),g=a(g,E,m,f,d[l+12],11,-421815835),f=a(f,g,E,m,d[l+15],16,530742520),m=a(m,f,g,E,d[l+2],23,-995338651),E=c(E,m,f,g,d[l+0],6,-198630844),g=c(g,E,m,f,d[l+7],10,1126891415),f=c(f,g,E,m,d[l+14],15,-1416354905),m=c(m,f,g,E,d[l+5],21,-57434055),E=c(E,m,f,g,d[l+12],6,1700485571),g=c(g,E,m,f,d[l+3],10,-1894986606),f=c(f,g,E,m,d[l+10],15,-1051523),m=c(m,f,g,E,d[l+1],21,-2054922799),E=c(E,m,f,g,d[l+8],6,1873313359),g=c(g,E,m,f,d[l+15],10,-30611744),f=c(f,g,E,m,d[l+6],15,-1560198380),m=c(m,f,g,E,d[l+13],21,1309151649),E=c(E,m,f,g,d[l+4],6,-145523070),g=c(g,E,m,f,d[l+11],10,-1120210379),f=c(f,g,E,m,d[l+2],15,718787259),m=c(m,f,g,E,d[l+9],21,-343485551),E=n(E,h),m=n(m,u),f=n(f,p),g=n(g,_);return i(E)+i(m)+i(f)+i(g)}(""+t+i)).slice(0,16),r=n.slice(0,12),s=await window.crypto.subtle.importKey("raw",n,"AES-GCM",!0,["encrypt"]);return new Uint8Array(await window.crypto.subtle.encrypt({name:"AES-GCM",iv:r},s,e))},fb=async(e,t,i)=>await mb(e.buffer,t,i);function gb(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n);}return i}function Tb(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?gb(Object(i),!0).forEach((function(t){nu(e,t,i[t]);})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):gb(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t));}));}return e}class Sb extends iA{get isPlaying(){return !(!this._player||this._player.videoElementStatus!==Zy.PLAYING)}get processorContext(){return this._processorContext}set processorContext(e){this._processorContext=e;}get __className__(){return "LocalVideoTrack"}constructor(e,t,i,n,r,s){if(super(e,r),nu(this,"trackMediaType","video"),nu(this,"_player",void 0),nu(this,"isUseScaleResolutionDownBy",!1),nu(this,"_videoVisibleTimer",null),nu(this,"_statsTimer",null),nu(this,"_previousVideoVisibleStatus",void 0),nu(this,"_clearPreviousVideoVisibleStatus",(()=>this._previousVideoVisibleStatus=void 0)),nu(this,"_encoderConfig",void 0),nu(this,"_scalabilityMode",{numSpatialLayers:1,numTemporalLayers:1}),nu(this,"_optimizationMode",void 0),nu(this,"_videoHeight",void 0),nu(this,"_videoWidth",void 0),nu(this,"_forceBitrateLimit",void 0),nu(this,"_enabled",!0),nu(this,"processorDestination",void 0),nu(this,"_processorContext",void 0),Sg()){const{width:t,height:i}=e.getSettings();this._videoWidth=t,this._videoHeight=i;}else this.updateMediaStreamTrackResolution();if(this._encoderConfig=t,this._scalabilityMode=i,this._optimizationMode=n,this._hints=s||[],-1===this._hints.indexOf(ky.SCREEN_TRACK))this.updateBitrateFromProfile();else if(function(e,t,i){const n=pg();return !(n.name!==e||!n.osVersion)&&(i?Number(n.version)>=t&&Number(n.version)<=i:Number(n.version)===t)}(cg.CHROME,115)&&-1!==_g().indexOf("Windows")){const t=function(e,t){if("VideoFrame"in window&&"TransformStream"in window&&_A().supportWebRTCInsertableStream){const i=new MediaStreamTrackProcessor(e),n=new MediaStreamTrackGenerator({kind:"video"});let r,s,o=Date.now();const a=()=>{c&&(clearInterval(c),c=void 0),r&&(r.close(),r=void 0),e.stop(),s=void 0,n.removeEventListener("ended",a);};let c=window.setInterval((()=>{if(s&&r&&Date.now()-o>(null!=t?t:1e3))try{"live"===n.readyState?s.enqueue(r.clone()):a();}catch(e){a();}}),null!=t?t:1e3);const d=new TransformStream({transform:(e,t)=>{"live"===n.readyState?(s=t,o=Date.now(),void 0===r?(r=e,t.enqueue(e.clone())):(t.enqueue(r),r=e)):e.close();}});return n.addEventListener("ended",a),i.readable.pipeThrough(d).pipeTo(n.writable),n}}(e);t&&(KC.info("local screen video track begin to inject frame"),this._mediaStreamTrack=t);}t&&-1!==this._hints.indexOf(ky.CUSTOM_TRACK)&&this.setEncoderConfiguration(t),this.processorContext=new GA(this.getTrackId(),"local"),this.processorDestination=new jA(this.processorContext),this.bindProcessorDestinationEvents();}play(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if("string"==typeof e){const t=document.getElementById(e);t?e=t:(KC.warning("[".concat(this.getTrackId(),'] can not find "#').concat(e,'" element, use document.body')),e=document.body);}KC.debug("[".concat(this.getTrackId(),"] start video playback in ").concat(e instanceof HTMLVideoElement?"HTMLVideoElement":"HTMLElement"),JSON.stringify(t));const i=Tb(Tb(Tb({},this._getDefaultPlayerConfig()),t),{},{trackId:this.getTrackId(),element:e});this._player?this._player.updateConfig(i):(e instanceof HTMLVideoElement?this._player=new ub(i):this._player=new _b(i),this._player.updateVideoTrack(this._mediaStreamTrack)),this._player.play(),this._videoVisibleTimer&&window.clearInterval(this._videoVisibleTimer),this._clearPreviousVideoVisibleStatus(),this._videoVisibleTimer=window.setInterval((()=>{try{const e=this.getVideoElementVisibleStatus();this.safeEmit(Fy.VIDEO_ELEMENT_VISIBLE_STATUS,e);}catch(e){}}),kC("CHECK_VIDEO_VISIBLE_INTERVAL"));}stop(){this._player&&(this._videoVisibleTimer&&(window.clearInterval(this._videoVisibleTimer),this._videoVisibleTimer=null),this._statsTimer&&(this.isUseScaleResolutionDownBy=!1,window.clearInterval(this._statsTimer),this._statsTimer=null),this._clearPreviousVideoVisibleStatus(),this._player.destroy(),this._player=void 0,KC.debug("[".concat(this.getTrackId(),"] stop video playback")));}async setEnabled(e,t){if(!t){if(e===this._enabled)return;this.stateCheck("enabled",e);}if(KC.info("[".concat(this.getTrackId(),"] start setEnabled"),e),!e){this._originMediaStreamTrack.enabled=!1;try{await gT(this,Ly.NEED_DISABLE_TRACK,this);}catch(e){throw KC.error("[".concat(this.getTrackId(),"] setEnabled to false error"),e.toString()),e}return t||(this._enabled=!1),void KC.info("[".concat(this.getTrackId(),"] setEnabled to false success"))}this._originMediaStreamTrack.enabled=!0;try{await gT(this,Ly.NEED_ENABLE_TRACK,this);}catch(e){throw KC.error("[".concat(this.getTrackId(),"] setEnabled to true error"),e.toString()),e}KC.info("[".concat(this.getTrackId(),"] setEnabled to true success")),t||(this._enabled=!0);}async setMuted(e){e!==this._muted&&(this.stateCheck("muted",e),this._muted=e,this._originMediaStreamTrack.enabled=!e,KC.debug("[".concat(this.getTrackId(),"] start set muted: ").concat(e)),e?await gT(this,Ly.NEED_MUTE_TRACK,this):await gT(this,Ly.NEED_UNMUTE_TRACK,this));}async setEncoderConfiguration(e,t){if(!this._enabled)throw new Vg(xg.TRACK_IS_DISABLED,"can not set encoder configuration when track is disabled");if("720p_auto"===e?this.startMonitorStats():this._statsTimer&&(window.clearInterval(this._statsTimer),this._statsTimer=null),e=Ay(e),this._forceBitrateLimit&&(e.bitrateMax=this._forceBitrateLimit.max_bitrate?this._forceBitrateLimit.max_bitrate:e.bitrateMax,e.bitrateMin=this._forceBitrateLimit.min_bitrate?this._forceBitrateLimit.min_bitrate:e.bitrateMin),e.width||e.height||e.frameRate){const t=ib({encoderConfig:e});(Sg()||Cg()||Dg())&&(t.deviceId=void 0),KC.debug("[".concat(this.getTrackId(),"] setEncoderConfiguration applyConstraints"),JSON.stringify(e),JSON.stringify(t));try{await this._originMediaStreamTrack.applyConstraints(t),this.updateMediaStreamTrackResolution();}catch(e){const t=new Vg(xg.UNEXPECTED_ERROR,e.toString());throw KC.error("[".concat(this.getTrackId(),"] applyConstraints error"),t.toString()),t}}this._encoderConfig=e,-1===this._hints.indexOf(ky.SCREEN_TRACK)&&this.updateBitrateFromProfile();try{await gT(this,Ly.NEED_UPDATE_VIDEO_ENCODER,this);}catch(e){return e.throw(KC)}}getStats(){NT((()=>{KC.warning("[deprecated] LocalVideoTrack.getStats will be removed in the future, use AgoraRTCClient.getLocalVideoStats instead");}),"localVideoTrackGetStatsWarning");const e=TT(this,Ly.GET_STATS);return e||Tb({},Hy)}async setBeautyEffect(e){KC.error("LocalVideoTrack.setBeautyEffect was deprecated, please migrate to agora-extension-beauty-effect");}getCurrentFrameData(){return this._player?this._player.getCurrentFrame():new ImageData(2,2)}async getCurrentFrameImage(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return this._player?this._player.getCurrentFrameToUint8Array(e,t):await ab(e)}async setBitrateLimit(e){if(KC.debug("[".concat(this.getTrackId(),"] set bitrate limit, ").concat(JSON.stringify(e))),e){this._forceBitrateLimit=e,this._encoderConfig&&(this._encoderConfig.bitrateMax?this._encoderConfig.bitrateMax=this._encoderConfig.bitrateMax<e.max_bitrate?this._encoderConfig.bitrateMax:e.max_bitrate:this._encoderConfig.bitrateMax=e.max_bitrate,this._encoderConfig.bitrateMin,this._encoderConfig.bitrateMin=e.min_bitrate);try{await gT(this,Ly.NEED_UPDATE_VIDEO_ENCODER,this);}catch(e){return e.throw(KC)}}}async setOptimizationMode(e){if("motion"!==e&&"detail"!==e&&"balanced"!==e)return void KC.error(xg.INVALID_PARAMS,"optimization mode must be motion, detail or balanced");const t=this._optimizationMode;try{this._optimizationMode=e,await gT(this,Ly.SET_OPTIMIZATION_MODE,this);}catch(e){throw this._optimizationMode=t,KC.error("[".concat(this.getTrackId(),"] set optimization mode failed"),e.toString()),e}KC.info("[".concat(this.getTrackId(),"] set optimization mode success (").concat(e,")"));}setScalabiltyMode(e){if(1===e.numSpatialLayers&&1!==e.numTemporalLayers)return KC.error(xg.INVALID_PARAMS,"scalability mode currently not supported, no SVC."),void(this._scalabilityMode={numSpatialLayers:1,numTemporalLayers:1});this._scalabilityMode=e,KC.info("[".concat(this.getTrackId(),"] set scalability mode success (").concat(e,")"));}updateMediaStreamTrackResolution(){Eb(this._originMediaStreamTrack).then((e=>{let[t,i]=e;this._videoHeight=i,this._videoWidth=t;})).catch(FT);}_updatePlayerSource(){this._player&&this._player.updateVideoTrack(this._mediaStreamTrack);}_getDefaultPlayerConfig(){return {fit:"contain"}}async setSenderConfiguration(e){if(!this._enabled)throw new Vg(xg.TRACK_IS_DISABLED,"can not set encoder configuration when track is disabled");KC.debug("[".concat(this.getTrackId(),"] setSenderConfiguration applyConstraints"),JSON.stringify(e)),e=Ay(e),this._forceBitrateLimit&&(e.bitrateMax=this._forceBitrateLimit.max_bitrate?this._forceBitrateLimit.max_bitrate:e.bitrateMax,e.bitrateMin=this._forceBitrateLimit.min_bitrate?this._forceBitrateLimit.min_bitrate:e.bitrateMin),this._encoderConfig=e,-1===this._hints.indexOf(ky.SCREEN_TRACK)&&this.updateBitrateFromProfile();try{await gT(this,Ly.NEED_UPDATE_VIDEO_ENCODER,this);}catch(e){return e.throw(KC)}}updateBitrateFromProfile(){if(!this._encoderConfig)return;const{width:e,height:t,frameRate:i}=this.getMediaStreamTrackSettings();if(!e||!t||!i)return;const[n,r]=function(e,t,i,n){let r;const s=200*Math.pow(i/15,.6)*Math.pow(e*t/640/360,.75),o=s;if("STANDARD_BITRATE"===n)r=4*s;else {if("COMPATIABLE_BITRATE"!==n)return;r=2*s;}return [Math.floor(r),Math.floor(o)]}(e,t,i,kC("BITRATE_ADAPTER_TYPE"))||[void 0,void 0];this._encoderConfig.bitrateMin||this._encoderConfig.bitrateMax||(this._encoderConfig.bitrateMin=r,this._encoderConfig.bitrateMax=n,KC.debug("[".concat(this.getTrackId(),"] update bitrate from profile, [w: ").concat(e,", h: ").concat(t,", fps: ").concat(i,"] => [brMax: ").concat(n,", brMin: ").concat(r,"]")));}getVideoElementVisibleStatus(){try{var e,t;const i=null==this||null===(e=this._player)||void 0===e?void 0:e.getContainerElement(),n={track:this,element:null==this||null===(t=this._player)||void 0===t?void 0:t.getVideoElement(),slot:null==i?void 0:i.parentElement},{element:r,slot:s}=n;if(this.isPlaying&&r instanceof HTMLVideoElement&&s instanceof HTMLElement){const e=Qg.checkOneElementVisible(r),t=Object.assign({},e);if(t.visible!==this._previousVideoVisibleStatus){this._previousVideoVisibleStatus=t.visible;const e=rv.reportApiInvoke(null,{tag:oT.TRACER,name:sT.LOCAL_VIDEO_TRACK_GET_VIDEO_VISIBLE,options:[this.getTrackId()]});t.visible?e.onSuccess("Video is visible"):e.onSuccess("Invisible because of ".concat(t.reason));}return t}return}catch(e){throw new Vg(xg.GET_VIDEO_ELEMENT_VISIBLE_ERROR,e.message)}}async renewMediaStreamTrack(e){}pipe(e){if(this.processor===e)return e;if(e._source)throw new Vg(xg.INVALID_OPERATION,"Processor ".concat(e.name," already piped, please call unpipe beforehand."));return this.unpipe(),this.processor=e,this.processor._source=this,e.updateInput({track:this._originMediaStreamTrack,context:this.processorContext}),e}unpipe(){if(!this.processor)return;const e=this.processor;this.processor._source=void 0,this.processor=void 0,e.reset();}close(){super.close(),this.unbindProcessorDestinationEvents(),this.unbindProcessorContextEvents(),this.unpipe(),this.processorDestination._source&&this.processorDestination._source.unpipe();}clone(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],i=this._encoderConfig;e&&(i=Tb(Tb({},i),Ay(e))),i=wT(i);const n=xT(8,"track-video-cloned-"),r=new Sb(t?this._mediaStreamTrack.clone():this._mediaStreamTrack,i,wT(this._scalabilityMode),this._optimizationMode,n,wT(this._hints));return e&&i&&r.setEncoderConfiguration(i),KC.debug("clone video track from ".concat(this.getTrackId()," to ").concat(n,", clone ").concat(t)),r}async replaceTrack(e,t){if(!(e instanceof MediaStreamTrack))throw new Vg(xg.INVALID_PARAMS,"track should be an instance of MediaStreamTrack");if("video"!==e.kind)throw new Vg(xg.INVALID_PARAMS,"track should be a video MediaStreamTrack");await this._updateOriginMediaStreamTrack(e,t,!0),this.updateMediaStreamTrackResolution();}startMonitorStats(){if(!Sg()&&!Cg())return;this._statsTimer&&window.clearInterval(this._statsTimer);let e=2,t=vy[e];let i=-1;let n=Date.now();const r=e=>{e>2||e<0||(n=Date.now(),t=vy[e],this.setSenderConfiguration(t));};this.isUseScaleResolutionDownBy=!0,this._statsTimer=window.setInterval((()=>{const s=this.getStats(),o=TT(this,Ly.GET_RTC_STATS);if(s.sendPackets>0&&o){-1===i&&(i=Date.now());const a=Date.now();if(a-i<1e3||a-n<kC("PROFILE_SWITCH_INTERVAL"))return;const c=s.sendFrameRate,d=.6*t.frameRate,l=.9*t.frameRate;"number"==typeof c&&c>0&&c<d?e>0&&(e--,r(e),KC.debug("[".concat(this.getTrackId(),"] step down for fps ").concat(c,", switchProfile to ").concat(e))):o.OutgoingAvailableBandwidth<t.bitrateMin?e>0&&(e--,r(e),KC.debug("[".concat(this.getTrackId(),"] step down for OutgoingAvailableBandwidth ").concat(o.OutgoingAvailableBandwidth,", bitrateMin ").concat(t.bitrateMin,", switchProfile to ").concat(e))):"number"==typeof c&&c>l&&e<vy.length-1&&o.OutgoingAvailableBandwidth>1.2*vy[e+1].bitrateMin&&(e++,r(e),KC.debug("[".concat(this.getTrackId(),"] step up for fps ").concat(c,", OutgoingAvailableBandwidth ").concat(o.OutgoingAvailableBandwidth,", switchProfile to ").concat(e)));}}),kC("CHECK_LOCAL_STATS_INTERVAL"));}bindProcessorDestinationEvents(){this.processorDestination.on(Jy.ON_TRACK,(async e=>{e?e!==this._mediaStreamTrack&&(this._mediaStreamTrack=e,this._updatePlayerSource(),await gT(this,Ly.NEED_REPLACE_TRACK,this)):this._mediaStreamTrack!==this._originMediaStreamTrack&&(this._mediaStreamTrack=this._originMediaStreamTrack,this._updatePlayerSource(),await gT(this,Ly.NEED_REPLACE_TRACK,this));}));}unbindProcessorDestinationEvents(){this.processorDestination.removeAllListeners(Jy.ON_TRACK);}unbindProcessorContextEvents(){this.processorContext.removeAllListeners(zy.REQUEST_UPDATE_CONSTRAINTS),this.processorContext.removeAllListeners(zy.REQUEST_CONSTRAINTS);}}Mv([nv({argsMap:(e,t,i)=>[e.getTrackId(),"string"==typeof t?t:t instanceof HTMLVideoElement?"HTMLVideoElement":"HTMLElement",i]}),VA(),Uv("design:type",Function),Uv("design:paramtypes",[Object,Object]),Uv("design:returntype",void 0)],Sb.prototype,"play",null),Mv([nv({argsMap:e=>[e.getTrackId()]}),Uv("design:type",Function),Uv("design:paramtypes",[]),Uv("design:returntype",void 0)],Sb.prototype,"stop",null),Mv([qT("LocalVideoTrack","_enabledMutex"),nv({argsMap:(e,t)=>[e.getTrackId(),t]}),VA(),Uv("design:type",Function),Uv("design:paramtypes",[Boolean,Boolean]),Uv("design:returntype",tg)],Sb.prototype,"setEnabled",null),Mv([qT("LocalVideoTrack","_enabledMutex"),nv({argsMap:(e,t)=>[e.getTrackId(),t]}),VA(),Uv("design:type",Function),Uv("design:paramtypes",[Boolean]),Uv("design:returntype",tg)],Sb.prototype,"setMuted",null),Mv([nv({argsMap:(e,t)=>[e.getTrackId(),t]}),VA(),Uv("design:type",Function),Uv("design:paramtypes",[Object,Boolean]),Uv("design:returntype",tg)],Sb.prototype,"setEncoderConfiguration",null),Mv([VA(),Uv("design:type",Function),Uv("design:paramtypes",[]),Uv("design:returntype",Object)],Sb.prototype,"getStats",null),Mv([nv({argsMap:(e,t,i)=>[e.getTrackId(),t,i]}),VA(),Uv("design:type",Function),Uv("design:paramtypes",[Boolean,Object]),Uv("design:returntype",tg)],Sb.prototype,"setBeautyEffect",null),Mv([VA(),Uv("design:type",Function),Uv("design:paramtypes",[]),Uv("design:returntype",ImageData)],Sb.prototype,"getCurrentFrameData",null),Mv([VA(),Uv("design:type",Function),Uv("design:paramtypes",[String,Number]),Uv("design:returntype",tg)],Sb.prototype,"getCurrentFrameImage",null),Mv([VA(),Uv("design:type",Function),Uv("design:paramtypes",[Object]),Uv("design:returntype",tg)],Sb.prototype,"setBitrateLimit",null),Mv([VA(),Uv("design:type",Function),Uv("design:paramtypes",[String]),Uv("design:returntype",tg)],Sb.prototype,"setOptimizationMode",null),Mv([VA(),Uv("design:type",Function),Uv("design:paramtypes",[Object]),Uv("design:returntype",void 0)],Sb.prototype,"setScalabiltyMode",null),Mv([VA(),Uv("design:type",Function),Uv("design:paramtypes",[]),Uv("design:returntype",void 0)],Sb.prototype,"updateMediaStreamTrackResolution",null),Mv([nv({argsMap:(e,t)=>[e.getTrackId(),t.name]}),Uv("design:type",Function),Uv("design:paramtypes",[Object]),Uv("design:returntype",Object)],Sb.prototype,"pipe",null),Mv([nv({argsMap:e=>[e.getTrackId()]}),Uv("design:type",Function),Uv("design:paramtypes",[]),Uv("design:returntype",void 0)],Sb.prototype,"unpipe",null),Mv([nv({argsMap:e=>[e.getTrackId()]}),Uv("design:type",Function),Uv("design:paramtypes",[]),Uv("design:returntype",void 0)],Sb.prototype,"close",null),Mv([nv({argsMap:(e,t,i)=>[e.getTrackId(),t.label,i]}),Uv("design:type",Function),Uv("design:paramtypes",[MediaStreamTrack,Boolean]),Uv("design:returntype",tg)],Sb.prototype,"replaceTrack",null),Mv([nv(),Uv("design:type",Function),Uv("design:paramtypes",[]),Uv("design:returntype",void 0)],Sb.prototype,"startMonitorStats",null);class Rb extends Sb{get __className__(){return "CameraVideoTrack"}constructor(e,t,i,n,r,s){super(e,Ay(t.encoderConfig),n,r,s),nu(this,"_config",void 0),nu(this,"_originalConstraints",void 0),nu(this,"_constraints",void 0),nu(this,"_enabled",!0),nu(this,"_deviceName","default"),nu(this,"tryResumeVideoForIOS15_16WeChat",(async()=>{(wg()||Og())&&!function(){const e=pg();if(e.os!==ag.IOS||!e.osVersion)return !1;const t=e.osVersion.split(".");return 15===Number(t[0])&&Number(t[1])>=2}()&&Pg()&&this._enabled&&!this._isClosed&&(KC.debug("[".concat(this.getTrackId(),"] try capture camera media device for interrupted iOS 15 device on WeChat.")),await this.renewMediaStreamTrack());})),this._config=t,this._originalConstraints=i,this._constraints=i,this._deviceName=e.label,this._encoderConfig=Ay(this._config.encoderConfig),oA.on(uy.IOS_15_16_INTERRUPTION_END,this.tryResumeVideoForIOS15_16WeChat),oA.on(uy.IOS_INTERRUPTION_END,this.tryResumeVideoForIOS15_16WeChat),this.bindProcessorContextEvents();}async setDevice(e){return "string"==typeof e?this._setDeviceById(e):e.deviceId?this._setDeviceById(e.deviceId):e.facingMode?this._setDeviceByFacingModel(e.facingMode):void 0}async _setDeviceById(e){if(KC.info("[".concat(this.getTrackId(),"] set device to ").concat(e)),this._enabled)try{const t=await OA.getDeviceById(e),i={};i.video=Tb({},this._constraints),i.video.deviceId={exact:e},i.video.facingMode=void 0,this._originMediaStreamTrack.stop();let n=null;try{n=await yA(i,this.getTrackId());}catch(e){throw KC.error("[".concat(this.getTrackId(),"] setDevice failed"),e.toString()),n=await yA({video:this._constraints},this.getTrackId()),await this._updateOriginMediaStreamTrack(n.getVideoTracks()[0],!1),e}await this._updateOriginMediaStreamTrack(n.getVideoTracks()[0],!1),this.updateMediaStreamTrackResolution(),this._deviceName=t.label,this._config.cameraId=e,this._constraints.deviceId={exact:e};}catch(e){throw KC.error("[".concat(this.getTrackId(),"] setDevice error"),e.toString()),e}else try{const t=await OA.getDeviceById(e);this._deviceName=t.label,this._config.cameraId=e,this._constraints.deviceId={exact:e};}catch(e){throw KC.error("[".concat(this.getTrackId(),"] setDevice error"),e.toString()),e}KC.info("[".concat(this.getTrackId(),"] setDevice success"));}async _setDeviceByFacingModel(e){KC.info("[".concat(this.getTrackId(),"] set facingMode ").concat(e));const t={video:Tb(Tb({},this._constraints),{},{deviceId:void 0,facingMode:{exact:e}})};if(this._enabled){this._originMediaStreamTrack.stop();let e=null;try{e=await yA(t,this.getTrackId());}catch(t){throw KC.error("[".concat(this.getTrackId(),"] setDeviceByFacingModel failed"),t.toString()),e=await yA({video:this._constraints},this.getTrackId()),await this._updateOriginMediaStreamTrack(e.getVideoTracks()[0],!1),t}await this._updateOriginMediaStreamTrack(e.getVideoTracks()[0],!1),this.updateMediaStreamTrackResolution();}this._deviceName="",this._config.facingMode=e,this._config.cameraId=void 0,this._constraints=Tb({},t.video),KC.info("[".concat(this.getTrackId(),"] setDeviceByFacingModel success"));}async setEnabled(e,t){if(!t){if(e===this._enabled)return;this.stateCheck("enabled",e);}if(KC.info("[".concat(this.getTrackId(),"] start setEnabled"),e),e){try{if(this.isExternalTrack)this._originMediaStreamTrack.enabled=!0;else {const e=await yA({video:this._constraints},this.getTrackId());await this._updateOriginMediaStreamTrack(e.getVideoTracks()[0],!1);}await gT(this,Ly.NEED_ENABLE_TRACK,this);}catch(e){throw KC.error("[".concat(this.getTrackId(),"] setEnabled true error"),e.toString()),e}this.updateMediaStreamTrackResolution(),KC.info("[".concat(this.getTrackId(),"] setEnabled to true success")),t||(this._enabled=!0);}else {this.isExternalTrack?this._originMediaStreamTrack.enabled=!1:(this._originMediaStreamTrack.onended=null,this._originMediaStreamTrack.stop()),t||(this._enabled=!1);try{await gT(this,Ly.NEED_DISABLE_TRACK,this);}catch(e){throw KC.error("[".concat(this.getTrackId(),"] setEnabled to false error"),e.toString()),e}KC.info("[".concat(this.getTrackId(),"] setEnabled to false success"));}}async setEncoderConfiguration(e,t){if(!this._enabled)throw new Vg(xg.TRACK_IS_DISABLED,"can not set encoder configuration when track is disabled");"720p_auto"===e?this.startMonitorStats():this._statsTimer&&(window.clearInterval(this._statsTimer),this._statsTimer=null),e=Ay(e),this._forceBitrateLimit&&(e.bitrateMax=this._forceBitrateLimit.max_bitrate?this._forceBitrateLimit.max_bitrate:e.bitrateMax,e.bitrateMin=this._forceBitrateLimit.min_bitrate?this._forceBitrateLimit.min_bitrate:e.bitrateMin);const i=bT(this._config);i.encoderConfig=e;const n=ib(i);(Sg()||Cg()||Dg())&&(n.deviceId=void 0),KC.debug("[".concat(this.getTrackId(),"] setEncoderConfiguration applyConstraints"),JSON.stringify(e),JSON.stringify(n));try{await this._originMediaStreamTrack.applyConstraints(n),this.updateMediaStreamTrackResolution();}catch(e){const t=new Vg(xg.UNEXPECTED_ERROR,e.toString());throw KC.error("[".concat(this.getTrackId(),"] applyConstraints error"),t.toString()),t}this._config=i,this._constraints=n,this._originalConstraints=n,this._encoderConfig=e,-1===this._hints.indexOf(ky.SCREEN_TRACK)&&this.updateBitrateFromProfile();try{await gT(this,Ly.NEED_UPDATE_VIDEO_ENCODER,this);}catch(e){return e.throw(KC)}}_getDefaultPlayerConfig(){return {mirror:!0,fit:"cover"}}onTrackEnded(){if((Cg()||Dg())&&this._enabled&&!this._isClosed&&oA.duringInterruption){const e=async()=>{oA.off(uy.IOS_INTERRUPTION_END,e),this._enabled&&!this._isClosed&&(KC.debug("[".concat(this.getTrackId(),"] try capture camera media device for interrupted iOS device.")),await this.setEnabled(!1),await this.setEnabled(!0));};oA.on(uy.IOS_INTERRUPTION_END,e);}else KC.debug("[".concat(this.getTrackId(),"] track ended")),this.safeEmit(Fy.TRACK_ENDED);}async renewMediaStreamTrack(e){const t=e||this._constraints,i=OA.searchDeviceIdByName(this._deviceName);if(i&&!t.deviceId&&(t.deviceId={exact:i}),this._enabled){const e=await yA({video:t},this.getTrackId());this._constraints=t,await this._updateOriginMediaStreamTrack(e.getVideoTracks()[0],!0),this.updateMediaStreamTrackResolution();}}close(){super.close(),oA.off(uy.IOS_15_16_INTERRUPTION_END,this.tryResumeVideoForIOS15_16WeChat),oA.off(uy.IOS_INTERRUPTION_END,this.tryResumeVideoForIOS15_16WeChat);}clone(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],i=this._encoderConfig;e&&(i=Tb(Tb({},i),Ay(e))),i=wT(i);const n=xT(8,"track-cam-cloned-"),r=new Rb(t?this._mediaStreamTrack.clone():this._mediaStreamTrack,wT(Tb(Tb({},this._config),{},{encoderConfig:i})),wT(this._constraints),wT(this._scalabilityMode),this._optimizationMode,n);return e&&i&&r.setEncoderConfiguration(i),KC.debug("clone track from ".concat(this.getTrackId()," to ").concat(n,", clone ").concat(t)),r}bindProcessorContextEvents(){this.processorContext.on(zy.REQUEST_UPDATE_CONSTRAINTS,(async(e,t,i)=>{try{const i=Object.assign({},this._originalConstraints,...e);await this.renewMediaStreamTrack(i),t();}catch(e){i(e);}})),this.processorContext.on(zy.REQUEST_CONSTRAINTS,(async e=>{e(this._originMediaStreamTrack.getSettings());}));}}function Cb(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n);}return i}function vb(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?Cb(Object(i),!0).forEach((function(t){nu(e,t,i[t]);})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):Cb(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t));}));}return e}function Ib(e,t,i,n){i.optimizationMode&&(n&&n.width&&n.height?(i.encoderConfig=vb(vb({},n),{},{bitrateMin:n.bitrateMin,bitrateMax:n.bitrateMax}),"motion"!==i.optimizationMode&&"detail"!==i.optimizationMode||(t.contentHint=i.optimizationMode,t.contentHint===i.optimizationMode?KC.debug("[".concat(e,"] set content hint to"),i.optimizationMode):KC.debug("[".concat(e,"] set content hint failed")))):KC.warning("[".concat(e,"] can not apply optimization mode bitrate config, no encoderConfig")));}function yb(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n);}return i}function Ab(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?yb(Object(i),!0).forEach((function(t){nu(e,t,i[t]);})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):yb(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t));}));}return e}Mv([nv({argsMap:(e,t)=>[e.getTrackId(),t]}),VA(),Uv("design:type",Function),Uv("design:paramtypes",[Object]),Uv("design:returntype",tg)],Rb.prototype,"setDevice",null),Mv([qT("CameraVideoTrack","_enabledMutex"),nv({argsMap:(e,t)=>[e.getTrackId(),t]}),VA(),Uv("design:type",Function),Uv("design:paramtypes",[Boolean,Boolean]),Uv("design:returntype",tg)],Rb.prototype,"setEnabled",null),Mv([nv({argsMap:(e,t)=>[e.getTrackId(),t]}),VA(),Uv("design:type",Function),Uv("design:paramtypes",[Object,Boolean]),Uv("design:returntype",tg)],Rb.prototype,"setEncoderConfiguration",null),Mv([nv({argsMap:e=>[e.getTrackId()]}),Uv("design:type",Function),Uv("design:paramtypes",[]),Uv("design:returntype",void 0)],Rb.prototype,"close",null);class bb extends tA{getUserId(){return this._userId}constructor(e,t,i,n){super(e,"track-".concat(e.kind,"-").concat(t,"-").concat(n.clientId,"_").concat(xT(5,""))),nu(this,"_userId",void 0),nu(this,"_uintId",void 0),nu(this,"_isDestroyed",!1),nu(this,"store",void 0),nu(this,"processor",void 0),this._userId=t,this._uintId=i,this.store=n;}_updateOriginMediaStreamTrack(e){this._originMediaStreamTrack=e,this._mediaStreamTrack=e,this._updatePlayerSource(),this.processor&&this.processor.updateInput({track:this._originMediaStreamTrack,context:this.processorContext});}_destroy(){this._isDestroyed=!0,KC.info("[".concat(this.getTrackId(),"] is destroyed")),this.stop(),super.close();}getProcessorStats(){return this.processorContext.gatherStats()}getProcessorUsage(){return this.processorContext.gatherUsage()}}class wb extends bb{get isPlaying(){return !(!this._player||this._player.videoElementStatus!==Zy.PLAYING)}get __className__(){return "RemoteVideoTrack"}constructor(e,t,i,n){super(e,t,i,n),nu(this,"_videoVisibleTimer",null),nu(this,"_previousVideoVisibleStatus",void 0),nu(this,"_clearPreviousVideoVisibleStatus",(()=>this._previousVideoVisibleStatus=void 0)),nu(this,"trackMediaType","video"),nu(this,"_videoWidth",void 0),nu(this,"_videoHeight",void 0),nu(this,"_player",void 0),nu(this,"processorDestination",void 0),nu(this,"processorContext",void 0),this.updateMediaStreamTrackResolution(),this.processorContext=new GA(this.getTrackId(),"remote"),this.processorDestination=new jA(this.processorContext),this.bindProcessorDestinationEvents();}getStats(){NT((()=>{KC.warning("[deprecated] RemoteVideoTrack.getStats will be removed in the future, use AgoraRTCClient.getRemoteVideoStats instead");}),"remoteVideoTrackGetStatsWarning");return TT(this,Ly.GET_STATS)||Ab({},qy)}play(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if("string"==typeof e){const t=document.getElementById(e);t?e=t:(KC.warning("[".concat(this.getTrackId(),'] can not find "#').concat(e,'" element, use document.body')),e=document.body);}KC.debug("[".concat(this.getTrackId(),"] start video playback in ").concat(e instanceof HTMLVideoElement?"HTMLVideoElement":"HTMLElement"),JSON.stringify(t));const i=Ab(Ab({fit:"cover"},t),{},{trackId:this.getTrackId(),element:e});this._player?this._player.updateConfig(i):(e instanceof HTMLVideoElement?this._player=new ub(i):this._player=new _b(i),this._player.updateVideoTrack(this._mediaStreamTrack),this._player.onFirstVideoFrameDecoded=()=>{this.store.subscribe(this.getUserId(),"video",void 0,void 0,Date.now()),this.safeEmit(By.FIRST_FRAME_DECODED);}),this._player.play(this.store.sessionId||void 0),this._videoVisibleTimer&&window.clearInterval(this._videoVisibleTimer),this._clearPreviousVideoVisibleStatus(),this._videoVisibleTimer=window.setInterval((()=>{try{const e=this.getVideoElementVisibleStatus();this.safeEmit(By.VIDEO_ELEMENT_VISIBLE_STATUS,e);}catch(e){}}),kC("CHECK_VIDEO_VISIBLE_INTERVAL"));}stop(){this._player&&(this._videoVisibleTimer&&(window.clearInterval(this._videoVisibleTimer),this._videoVisibleTimer=null),this._clearPreviousVideoVisibleStatus(),this._player.destroy(),this._player=void 0,KC.debug("[".concat(this.getTrackId(),"] stop video playback")));}getCurrentFrameData(){return this._player?this._player.getCurrentFrame():new ImageData(2,2)}updateMediaStreamTrackResolution(){Eb(this._originMediaStreamTrack).then((e=>{let[t,i]=e;this._videoHeight=i,this._videoWidth=t;})).catch(FT);}_updatePlayerSource(){KC.debug("[".concat(this.getTrackId(),"] update player source track")),this._player&&this._player.updateVideoTrack(this._mediaStreamTrack);}getVideoElementVisibleStatus(){try{var e,t;const i=null==this||null===(e=this._player)||void 0===e?void 0:e.getContainerElement(),n={track:this,element:null==this||null===(t=this._player)||void 0===t?void 0:t.getVideoElement(),slot:null==i?void 0:i.parentElement},{element:r,slot:s}=n;if(this.isPlaying&&r instanceof HTMLVideoElement&&s instanceof HTMLElement){const e=Qg.checkOneElementVisible(r),t=Object.assign({},e);if(t.visible!==this._previousVideoVisibleStatus){this._previousVideoVisibleStatus=t.visible;const e=rv.reportApiInvoke(null,{tag:oT.TRACER,name:sT.REMOTE_VIDEO_TRACK_GET_VIDEO_VISIBLE,options:[this.getTrackId()]});t.visible?e.onSuccess("Video is visible"):e.onSuccess("Invisible because of ".concat(t.reason));}return t}return}catch(e){throw new Vg(xg.GET_VIDEO_ELEMENT_VISIBLE_ERROR,e.message)}}pipe(e){if(this.processor===e)return e;if(e._source)throw new Vg(xg.INVALID_OPERATION,"Processor ".concat(e.name," already piped, please call unpipe beforehand."));return this.unpipe(),this.processor=e,this.processor._source=this,e.updateInput({track:this._originMediaStreamTrack,context:this.processorContext}),e}unpipe(){if(!this.processor)return;const e=this.processor;this.processor._source=void 0,this.processor=void 0,e.reset();}bindProcessorDestinationEvents(){this.processorDestination.on(Jy.ON_TRACK,(async e=>{e?e!==this._mediaStreamTrack&&(this._mediaStreamTrack=e,this._updatePlayerSource()):this._mediaStreamTrack!==this._originMediaStreamTrack&&(this._mediaStreamTrack=this._originMediaStreamTrack,this._updatePlayerSource());}));}unbindProcessorDestinationEvents(){this.processorDestination.removeAllListeners(Jy.ON_TRACK);}_destroy(){super._destroy(),this.unbindProcessorDestinationEvents();}}Mv([nv({argsMap:(e,t,i)=>[e.getTrackId(),"string"==typeof t?t:t instanceof HTMLVideoElement?"HTMLVideoElement":"HTMLElement",i]}),Uv("design:type",Function),Uv("design:paramtypes",[Object,Object]),Uv("design:returntype",void 0)],wb.prototype,"play",null),Mv([nv({argsMap:e=>[e.getTrackId()]}),Uv("design:type",Function),Uv("design:paramtypes",[]),Uv("design:returntype",void 0)],wb.prototype,"stop",null),Mv([nv({argsMap:(e,t)=>[e.getTrackId(),t.name]}),Uv("design:type",Function),Uv("design:paramtypes",[Object]),Uv("design:returntype",Object)],wb.prototype,"pipe",null),Mv([nv({argsMap:e=>[e.getTrackId()]}),Uv("design:type",Function),Uv("design:paramtypes",[]),Uv("design:returntype",void 0)],wb.prototype,"unpipe",null);class Ob extends bb{get isPlaying(){return this._useAudioElement?xA.isPlaying(this.getTrackId()):this._source.isPlayed}get __className__(){return "RemoteAudioTrack"}constructor(e,t,i,n){super(e,t,i,n),nu(this,"trackMediaType","audio"),nu(this,"_source",void 0),nu(this,"_useAudioElement",!0),nu(this,"_volume",100),nu(this,"processorContext",void 0),nu(this,"processorDestination",void 0),nu(this,"_played",!1),nu(this,"_bypassWebAudio",!1),kC("DISABLE_WEBAUDIO")?(this._source=new KA,this._bypassWebAudio=!0,this._useAudioElement=!0):(this._source=new fA(e,!0),kC("REMOTE_AUDIO_TRACK_USES_WEB_AUDIO")&&(this._useAudioElement=!1)),this._source.once(jy.RECEIVE_TRACK_BUFFER,(()=>{this.safeEmit(By.FIRST_FRAME_DECODED);})),this.processorContext=new HA(this._source.context,this.getTrackId(),"remote"),this.processorDestination=new WA(this.processorContext),this.bindProcessorDestinationEvents(),this._source.on(jy.UPDATE_SOURCE,(()=>{this.processor&&this.processor.updateInput({node:this._source.processSourceNode,context:this.processorContext});}));}setAudioFrameCallback(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:4096;if(!e)return this._source.removeAllListeners(jy.ON_AUDIO_BUFFER),void this._source.stopGetAudioBuffer();this._source.startGetAudioBuffer(t),this._source.removeAllListeners(jy.ON_AUDIO_BUFFER),this._source.on(jy.ON_AUDIO_BUFFER,(t=>e(t)));}setVolume(e){this._volume=e,this._useAudioElement?xA.setVolume(this.getTrackId(),e):this._source.setVolume(e/100);}async setPlaybackDevice(e){if(!this._useAudioElement)throw new Vg(xg.NOT_SUPPORTED,"your browser does not support setting the audio output device");await xA.setSinkID(this.getTrackId(),e);}getVolumeLevel(){return this._source.getAccurateVolumeLevel()}getStats(){NT((()=>{KC.warning("[deprecated] RemoteAudioTrack.getStats will be removed in the future, use AgoraRTCClient.getRemoteAudioStats instead");}),"remoteAudioTrackGetStatsWarning");return TT(this,Ly.GET_STATS)||Ab({},Ky)}play(){KC.debug("[".concat(this.getTrackId(),"] start audio playback")),this._played=!0,this._useAudioElement?(KC.debug("[".concat(this.getTrackId(),"] use audio element to play")),xA.play(this._mediaStreamTrack,this.getTrackId(),this._volume,this.store.sessionId||void 0)):this._source.play();}stop(){KC.debug("[".concat(this.getTrackId(),"] stop audio playback")),this._played=!1,this._useAudioElement?xA.stop(this.getTrackId()):this._source.stop();}_destroy(){super._destroy(),this._played=!1,this.unbindProcessorDestinationEvents(),this._source.destroy();}_isFreeze(){return this._source.isFreeze}_updatePlayerSource(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];KC.debug("[".concat(this.getTrackId(),"] update player source track")),e&&this._source.updateTrack(this._mediaStreamTrack),this._useAudioElement&&xA.updateTrack(this.getTrackId(),this._mediaStreamTrack);}pipe(e){if(this._bypassWebAudio)throw new Vg(xg.NOT_SUPPORTED,"can not pipe extension when WebAudio disabled");if(this.processor===e)return e;if(e._source)throw new Vg(xg.INVALID_OPERATION,"Processor ".concat(e.name," already piped, please call unpipe beforehand."));return this.unpipe(),this.processor=e,this.processor._source=this,e.updateInput({track:this._originMediaStreamTrack,node:this._source.processSourceNode,context:this.processorContext}),e}unpipe(){var e;if(this._bypassWebAudio)throw new Vg(xg.NOT_SUPPORTED,"can not unpipe extension when WebAudio disabled");if(!this.processor)return;const t=this.processor;null===(e=this._source.processSourceNode)||void 0===e||e.disconnect(),this.processor._source=!1,this.processor=void 0,t.reset();}bindProcessorDestinationEvents(){this.processorDestination.on(Jy.ON_TRACK,(async e=>{e?e!==this._mediaStreamTrack&&(this._mediaStreamTrack=e,this._updatePlayerSource(!1),this._source.processedNode=this._source.createMediaStreamSourceNode(e)):this._mediaStreamTrack!==this._originMediaStreamTrack&&(this._mediaStreamTrack=this._originMediaStreamTrack,this._updatePlayerSource());})),this.processorDestination.on(Jy.ON_NODE,(e=>{this._source.processedNode=e;const t=!e;this._useAudioElement!==t&&(this._played?(this.stop(),this._useAudioElement=t,this.play()):this._useAudioElement=t);}));}unbindProcessorDestinationEvents(){this.processorDestination.removeAllListeners(Jy.ON_TRACK),this.processorDestination.removeAllListeners(Jy.ON_NODE);}}Mv([nv({argsMap:(e,t)=>[e.getTrackId(),t],throttleTime:300}),Uv("design:type",Function),Uv("design:paramtypes",[Number]),Uv("design:returntype",void 0)],Ob.prototype,"setVolume",null),Mv([nv({argsMap:(e,t)=>[e.getTrackId(),t]}),Uv("design:type",Function),Uv("design:paramtypes",[String]),Uv("design:returntype",tg)],Ob.prototype,"setPlaybackDevice",null),Mv([nv({argsMap:e=>[e.getTrackId()]}),Uv("design:type",Function),Uv("design:paramtypes",[]),Uv("design:returntype",void 0)],Ob.prototype,"play",null),Mv([nv({argsMap:e=>[e.getTrackId()]}),Uv("design:type",Function),Uv("design:paramtypes",[]),Uv("design:returntype",void 0)],Ob.prototype,"stop",null),Mv([nv({argsMap:(e,t)=>[e.getTrackId(),t.name]}),Uv("design:type",Function),Uv("design:paramtypes",[Object]),Uv("design:returntype",Object)],Ob.prototype,"pipe",null),Mv([nv({argsMap:e=>[e.getTrackId()]}),Uv("design:type",Function),Uv("design:paramtypes",[]),Uv("design:returntype",void 0)],Ob.prototype,"unpipe",null);function Nb(e){let t=e.length;for(;--t>=0;)e[t]=0;}const Db=256,Pb=286,Lb=30,kb=15,Mb=new Uint8Array([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0]),Ub=new Uint8Array([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13]),xb=new Uint8Array([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7]),Vb=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),Fb=new Array(576);Nb(Fb);const Bb=new Array(60);Nb(Bb);const jb=new Array(512);Nb(jb);const Gb=new Array(256);Nb(Gb);const Wb=new Array(29);Nb(Wb);const Hb=new Array(Lb);function Kb(e,t,i,n,r){this.static_tree=e,this.extra_bits=t,this.extra_base=i,this.elems=n,this.max_length=r,this.has_stree=e&&e.length;}let Yb,qb,Jb;function zb(e,t){this.dyn_tree=e,this.max_code=0,this.stat_desc=t;}Nb(Hb);const Xb=e=>e<256?jb[e]:jb[256+(e>>>7)],Qb=(e,t)=>{e.pending_buf[e.pending++]=255&t,e.pending_buf[e.pending++]=t>>>8&255;},Zb=(e,t,i)=>{e.bi_valid>16-i?(e.bi_buf|=t<<e.bi_valid&65535,Qb(e,e.bi_buf),e.bi_buf=t>>16-e.bi_valid,e.bi_valid+=i-16):(e.bi_buf|=t<<e.bi_valid&65535,e.bi_valid+=i);},$b=(e,t,i)=>{Zb(e,i[2*t],i[2*t+1]);},ew=(e,t)=>{let i=0;do{i|=1&e,e>>>=1,i<<=1;}while(--t>0);return i>>>1},tw=(e,t,i)=>{const n=new Array(16);let r,s,o=0;for(r=1;r<=kb;r++)o=o+i[r-1]<<1,n[r]=o;for(s=0;s<=t;s++){let t=e[2*s+1];0!==t&&(e[2*s]=ew(n[t]++,t));}},iw=e=>{let t;for(t=0;t<Pb;t++)e.dyn_ltree[2*t]=0;for(t=0;t<Lb;t++)e.dyn_dtree[2*t]=0;for(t=0;t<19;t++)e.bl_tree[2*t]=0;e.dyn_ltree[512]=1,e.opt_len=e.static_len=0,e.sym_next=e.matches=0;},nw=e=>{e.bi_valid>8?Qb(e,e.bi_buf):e.bi_valid>0&&(e.pending_buf[e.pending++]=e.bi_buf),e.bi_buf=0,e.bi_valid=0;},rw=(e,t,i,n)=>{const r=2*t,s=2*i;return e[r]<e[s]||e[r]===e[s]&&n[t]<=n[i]},sw=(e,t,i)=>{const n=e.heap[i];let r=i<<1;for(;r<=e.heap_len&&(r<e.heap_len&&rw(t,e.heap[r+1],e.heap[r],e.depth)&&r++,!rw(t,n,e.heap[r],e.depth));)e.heap[i]=e.heap[r],i=r,r<<=1;e.heap[i]=n;},ow=(e,t,i)=>{let n,r,s,o,a=0;if(0!==e.sym_next)do{n=255&e.pending_buf[e.sym_buf+a++],n+=(255&e.pending_buf[e.sym_buf+a++])<<8,r=e.pending_buf[e.sym_buf+a++],0===n?$b(e,r,t):(s=Gb[r],$b(e,s+Db+1,t),o=Mb[s],0!==o&&(r-=Wb[s],Zb(e,r,o)),n--,s=Xb(n),$b(e,s,i),o=Ub[s],0!==o&&(n-=Hb[s],Zb(e,n,o)));}while(a<e.sym_next);$b(e,256,t);},aw=(e,t)=>{const i=t.dyn_tree,n=t.stat_desc.static_tree,r=t.stat_desc.has_stree,s=t.stat_desc.elems;let o,a,c,d=-1;for(e.heap_len=0,e.heap_max=573,o=0;o<s;o++)0!==i[2*o]?(e.heap[++e.heap_len]=d=o,e.depth[o]=0):i[2*o+1]=0;for(;e.heap_len<2;)c=e.heap[++e.heap_len]=d<2?++d:0,i[2*c]=1,e.depth[c]=0,e.opt_len--,r&&(e.static_len-=n[2*c+1]);for(t.max_code=d,o=e.heap_len>>1;o>=1;o--)sw(e,i,o);c=s;do{o=e.heap[1],e.heap[1]=e.heap[e.heap_len--],sw(e,i,1),a=e.heap[1],e.heap[--e.heap_max]=o,e.heap[--e.heap_max]=a,i[2*c]=i[2*o]+i[2*a],e.depth[c]=(e.depth[o]>=e.depth[a]?e.depth[o]:e.depth[a])+1,i[2*o+1]=i[2*a+1]=c,e.heap[1]=c++,sw(e,i,1);}while(e.heap_len>=2);e.heap[--e.heap_max]=e.heap[1],((e,t)=>{const i=t.dyn_tree,n=t.max_code,r=t.stat_desc.static_tree,s=t.stat_desc.has_stree,o=t.stat_desc.extra_bits,a=t.stat_desc.extra_base,c=t.stat_desc.max_length;let d,l,h,u,p,_,E=0;for(u=0;u<=kb;u++)e.bl_count[u]=0;for(i[2*e.heap[e.heap_max]+1]=0,d=e.heap_max+1;d<573;d++)l=e.heap[d],u=i[2*i[2*l+1]+1]+1,u>c&&(u=c,E++),i[2*l+1]=u,l>n||(e.bl_count[u]++,p=0,l>=a&&(p=o[l-a]),_=i[2*l],e.opt_len+=_*(u+p),s&&(e.static_len+=_*(r[2*l+1]+p)));if(0!==E){do{for(u=c-1;0===e.bl_count[u];)u--;e.bl_count[u]--,e.bl_count[u+1]+=2,e.bl_count[c]--,E-=2;}while(E>0);for(u=c;0!==u;u--)for(l=e.bl_count[u];0!==l;)h=e.heap[--d],h>n||(i[2*h+1]!==u&&(e.opt_len+=(u-i[2*h+1])*i[2*h],i[2*h+1]=u),l--);}})(e,t),tw(i,d,e.bl_count);},cw=(e,t,i)=>{let n,r,s=-1,o=t[1],a=0,c=7,d=4;for(0===o&&(c=138,d=3),t[2*(i+1)+1]=65535,n=0;n<=i;n++)r=o,o=t[2*(n+1)+1],++a<c&&r===o||(a<d?e.bl_tree[2*r]+=a:0!==r?(r!==s&&e.bl_tree[2*r]++,e.bl_tree[32]++):a<=10?e.bl_tree[34]++:e.bl_tree[36]++,a=0,s=r,0===o?(c=138,d=3):r===o?(c=6,d=3):(c=7,d=4));},dw=(e,t,i)=>{let n,r,s=-1,o=t[1],a=0,c=7,d=4;for(0===o&&(c=138,d=3),n=0;n<=i;n++)if(r=o,o=t[2*(n+1)+1],!(++a<c&&r===o)){if(a<d)do{$b(e,r,e.bl_tree);}while(0!=--a);else 0!==r?(r!==s&&($b(e,r,e.bl_tree),a--),$b(e,16,e.bl_tree),Zb(e,a-3,2)):a<=10?($b(e,17,e.bl_tree),Zb(e,a-3,3)):($b(e,18,e.bl_tree),Zb(e,a-11,7));a=0,s=r,0===o?(c=138,d=3):r===o?(c=6,d=3):(c=7,d=4);}};let lw=!1;const hw=(e,t,i,n)=>{Zb(e,0+(n?1:0),3),nw(e),Qb(e,i),Qb(e,~i),i&&e.pending_buf.set(e.window.subarray(t,t+i),e.pending),e.pending+=i;};var uw=e=>{lw||((()=>{let e,t,i,n,r;const s=new Array(16);for(i=0,n=0;n<28;n++)for(Wb[n]=i,e=0;e<1<<Mb[n];e++)Gb[i++]=n;for(Gb[i-1]=n,r=0,n=0;n<16;n++)for(Hb[n]=r,e=0;e<1<<Ub[n];e++)jb[r++]=n;for(r>>=7;n<Lb;n++)for(Hb[n]=r<<7,e=0;e<1<<Ub[n]-7;e++)jb[256+r++]=n;for(t=0;t<=kb;t++)s[t]=0;for(e=0;e<=143;)Fb[2*e+1]=8,e++,s[8]++;for(;e<=255;)Fb[2*e+1]=9,e++,s[9]++;for(;e<=279;)Fb[2*e+1]=7,e++,s[7]++;for(;e<=287;)Fb[2*e+1]=8,e++,s[8]++;for(tw(Fb,287,s),e=0;e<Lb;e++)Bb[2*e+1]=5,Bb[2*e]=ew(e,5);Yb=new Kb(Fb,Mb,257,Pb,kb),qb=new Kb(Bb,Ub,0,Lb,kb),Jb=new Kb(new Array(0),xb,0,19,7);})(),lw=!0),e.l_desc=new zb(e.dyn_ltree,Yb),e.d_desc=new zb(e.dyn_dtree,qb),e.bl_desc=new zb(e.bl_tree,Jb),e.bi_buf=0,e.bi_valid=0,iw(e);},pw=(e,t,i,n)=>{let r,s,o=0;e.level>0?(2===e.strm.data_type&&(e.strm.data_type=(e=>{let t,i=4093624447;for(t=0;t<=31;t++,i>>>=1)if(1&i&&0!==e.dyn_ltree[2*t])return 0;if(0!==e.dyn_ltree[18]||0!==e.dyn_ltree[20]||0!==e.dyn_ltree[26])return 1;for(t=32;t<Db;t++)if(0!==e.dyn_ltree[2*t])return 1;return 0})(e)),aw(e,e.l_desc),aw(e,e.d_desc),o=(e=>{let t;for(cw(e,e.dyn_ltree,e.l_desc.max_code),cw(e,e.dyn_dtree,e.d_desc.max_code),aw(e,e.bl_desc),t=18;t>=3&&0===e.bl_tree[2*Vb[t]+1];t--);return e.opt_len+=3*(t+1)+5+5+4,t})(e),r=e.opt_len+3+7>>>3,s=e.static_len+3+7>>>3,s<=r&&(r=s)):r=s=i+5,i+4<=r&&-1!==t?hw(e,t,i,n):4===e.strategy||s===r?(Zb(e,2+(n?1:0),3),ow(e,Fb,Bb)):(Zb(e,4+(n?1:0),3),((e,t,i,n)=>{let r;for(Zb(e,t-257,5),Zb(e,i-1,5),Zb(e,n-4,4),r=0;r<n;r++)Zb(e,e.bl_tree[2*Vb[r]+1],3);dw(e,e.dyn_ltree,t-1),dw(e,e.dyn_dtree,i-1);})(e,e.l_desc.max_code+1,e.d_desc.max_code+1,o+1),ow(e,e.dyn_ltree,e.dyn_dtree)),iw(e),n&&nw(e);},_w=(e,t,i)=>(e.pending_buf[e.sym_buf+e.sym_next++]=t,e.pending_buf[e.sym_buf+e.sym_next++]=t>>8,e.pending_buf[e.sym_buf+e.sym_next++]=i,0===t?e.dyn_ltree[2*i]++:(e.matches++,t--,e.dyn_ltree[2*(Gb[i]+Db+1)]++,e.dyn_dtree[2*Xb(t)]++),e.sym_next===e.sym_end),Ew={_tr_init:uw,_tr_stored_block:hw,_tr_flush_block:pw,_tr_tally:_w,_tr_align:e=>{Zb(e,2,3),$b(e,256,Fb),(e=>{16===e.bi_valid?(Qb(e,e.bi_buf),e.bi_buf=0,e.bi_valid=0):e.bi_valid>=8&&(e.pending_buf[e.pending++]=255&e.bi_buf,e.bi_buf>>=8,e.bi_valid-=8);})(e);}};var mw=(e,t,i,n)=>{let r=65535&e|0,s=e>>>16&65535|0,o=0;for(;0!==i;){o=i>2e3?2e3:i,i-=o;do{r=r+t[n++]|0,s=s+r|0;}while(--o);r%=65521,s%=65521;}return r|s<<16|0};const fw=new Uint32Array((()=>{let e,t=[];for(var i=0;i<256;i++){e=i;for(var n=0;n<8;n++)e=1&e?3988292384^e>>>1:e>>>1;t[i]=e;}return t})());var gw=(e,t,i,n)=>{const r=fw,s=n+i;e^=-1;for(let i=n;i<s;i++)e=e>>>8^r[255&(e^t[i])];return -1^e},Tw={2:"need dictionary",1:"stream end",0:"","-1":"file error","-2":"stream error","-3":"data error","-4":"insufficient memory","-5":"buffer error","-6":"incompatible version"},Sw={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_MEM_ERROR:-4,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8};const{_tr_init:Rw,_tr_stored_block:Cw,_tr_flush_block:vw,_tr_tally:Iw,_tr_align:yw}=Ew,{Z_NO_FLUSH:Aw,Z_PARTIAL_FLUSH:bw,Z_FULL_FLUSH:ww,Z_FINISH:Ow,Z_BLOCK:Nw,Z_OK:Dw,Z_STREAM_END:Pw,Z_STREAM_ERROR:Lw,Z_DATA_ERROR:kw,Z_BUF_ERROR:Mw,Z_DEFAULT_COMPRESSION:Uw,Z_FILTERED:xw,Z_HUFFMAN_ONLY:Vw,Z_RLE:Fw,Z_FIXED:Bw,Z_DEFAULT_STRATEGY:jw,Z_UNKNOWN:Gw,Z_DEFLATED:Ww}=Sw,Hw=286,Kw=30,Yw=19,qw=2*Hw+1,Jw=15,zw=258,Xw=262,Qw=42,Zw=113,$w=666,eO=(e,t)=>(e.msg=Tw[t],t),tO=e=>2*e-(e>4?9:0),iO=e=>{let t=e.length;for(;--t>=0;)e[t]=0;},nO=e=>{let t,i,n,r=e.w_size;t=e.hash_size,n=t;do{i=e.head[--n],e.head[n]=i>=r?i-r:0;}while(--t);t=r,n=t;do{i=e.prev[--n],e.prev[n]=i>=r?i-r:0;}while(--t)};let rO=(e,t,i)=>(t<<e.hash_shift^i)&e.hash_mask;const sO=e=>{const t=e.state;let i=t.pending;i>e.avail_out&&(i=e.avail_out),0!==i&&(e.output.set(t.pending_buf.subarray(t.pending_out,t.pending_out+i),e.next_out),e.next_out+=i,t.pending_out+=i,e.total_out+=i,e.avail_out-=i,t.pending-=i,0===t.pending&&(t.pending_out=0));},oO=(e,t)=>{vw(e,e.block_start>=0?e.block_start:-1,e.strstart-e.block_start,t),e.block_start=e.strstart,sO(e.strm);},aO=(e,t)=>{e.pending_buf[e.pending++]=t;},cO=(e,t)=>{e.pending_buf[e.pending++]=t>>>8&255,e.pending_buf[e.pending++]=255&t;},dO=(e,t,i,n)=>{let r=e.avail_in;return r>n&&(r=n),0===r?0:(e.avail_in-=r,t.set(e.input.subarray(e.next_in,e.next_in+r),i),1===e.state.wrap?e.adler=mw(e.adler,t,r,i):2===e.state.wrap&&(e.adler=gw(e.adler,t,r,i)),e.next_in+=r,e.total_in+=r,r)},lO=(e,t)=>{let i,n,r=e.max_chain_length,s=e.strstart,o=e.prev_length,a=e.nice_match;const c=e.strstart>e.w_size-Xw?e.strstart-(e.w_size-Xw):0,d=e.window,l=e.w_mask,h=e.prev,u=e.strstart+zw;let p=d[s+o-1],_=d[s+o];e.prev_length>=e.good_match&&(r>>=2),a>e.lookahead&&(a=e.lookahead);do{if(i=t,d[i+o]===_&&d[i+o-1]===p&&d[i]===d[s]&&d[++i]===d[s+1]){s+=2,i++;do{}while(d[++s]===d[++i]&&d[++s]===d[++i]&&d[++s]===d[++i]&&d[++s]===d[++i]&&d[++s]===d[++i]&&d[++s]===d[++i]&&d[++s]===d[++i]&&d[++s]===d[++i]&&s<u);if(n=zw-(u-s),s=u-zw,n>o){if(e.match_start=t,o=n,n>=a)break;p=d[s+o-1],_=d[s+o];}}}while((t=h[t&l])>c&&0!=--r);return o<=e.lookahead?o:e.lookahead},hO=e=>{const t=e.w_size;let i,n,r;do{if(n=e.window_size-e.lookahead-e.strstart,e.strstart>=t+(t-Xw)&&(e.window.set(e.window.subarray(t,t+t-n),0),e.match_start-=t,e.strstart-=t,e.block_start-=t,e.insert>e.strstart&&(e.insert=e.strstart),nO(e),n+=t),0===e.strm.avail_in)break;if(i=dO(e.strm,e.window,e.strstart+e.lookahead,n),e.lookahead+=i,e.lookahead+e.insert>=3)for(r=e.strstart-e.insert,e.ins_h=e.window[r],e.ins_h=rO(e,e.ins_h,e.window[r+1]);e.insert&&(e.ins_h=rO(e,e.ins_h,e.window[r+3-1]),e.prev[r&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=r,r++,e.insert--,!(e.lookahead+e.insert<3)););}while(e.lookahead<Xw&&0!==e.strm.avail_in)},uO=(e,t)=>{let i,n,r,s=e.pending_buf_size-5>e.w_size?e.w_size:e.pending_buf_size-5,o=0,a=e.strm.avail_in;do{if(i=65535,r=e.bi_valid+42>>3,e.strm.avail_out<r)break;if(r=e.strm.avail_out-r,n=e.strstart-e.block_start,i>n+e.strm.avail_in&&(i=n+e.strm.avail_in),i>r&&(i=r),i<s&&(0===i&&t!==Ow||t===Aw||i!==n+e.strm.avail_in))break;o=t===Ow&&i===n+e.strm.avail_in?1:0,Cw(e,0,0,o),e.pending_buf[e.pending-4]=i,e.pending_buf[e.pending-3]=i>>8,e.pending_buf[e.pending-2]=~i,e.pending_buf[e.pending-1]=~i>>8,sO(e.strm),n&&(n>i&&(n=i),e.strm.output.set(e.window.subarray(e.block_start,e.block_start+n),e.strm.next_out),e.strm.next_out+=n,e.strm.avail_out-=n,e.strm.total_out+=n,e.block_start+=n,i-=n),i&&(dO(e.strm,e.strm.output,e.strm.next_out,i),e.strm.next_out+=i,e.strm.avail_out-=i,e.strm.total_out+=i);}while(0===o);return a-=e.strm.avail_in,a&&(a>=e.w_size?(e.matches=2,e.window.set(e.strm.input.subarray(e.strm.next_in-e.w_size,e.strm.next_in),0),e.strstart=e.w_size,e.insert=e.strstart):(e.window_size-e.strstart<=a&&(e.strstart-=e.w_size,e.window.set(e.window.subarray(e.w_size,e.w_size+e.strstart),0),e.matches<2&&e.matches++,e.insert>e.strstart&&(e.insert=e.strstart)),e.window.set(e.strm.input.subarray(e.strm.next_in-a,e.strm.next_in),e.strstart),e.strstart+=a,e.insert+=a>e.w_size-e.insert?e.w_size-e.insert:a),e.block_start=e.strstart),e.high_water<e.strstart&&(e.high_water=e.strstart),o?4:t!==Aw&&t!==Ow&&0===e.strm.avail_in&&e.strstart===e.block_start?2:(r=e.window_size-e.strstart,e.strm.avail_in>r&&e.block_start>=e.w_size&&(e.block_start-=e.w_size,e.strstart-=e.w_size,e.window.set(e.window.subarray(e.w_size,e.w_size+e.strstart),0),e.matches<2&&e.matches++,r+=e.w_size,e.insert>e.strstart&&(e.insert=e.strstart)),r>e.strm.avail_in&&(r=e.strm.avail_in),r&&(dO(e.strm,e.window,e.strstart,r),e.strstart+=r,e.insert+=r>e.w_size-e.insert?e.w_size-e.insert:r),e.high_water<e.strstart&&(e.high_water=e.strstart),r=e.bi_valid+42>>3,r=e.pending_buf_size-r>65535?65535:e.pending_buf_size-r,s=r>e.w_size?e.w_size:r,n=e.strstart-e.block_start,(n>=s||(n||t===Ow)&&t!==Aw&&0===e.strm.avail_in&&n<=r)&&(i=n>r?r:n,o=t===Ow&&0===e.strm.avail_in&&i===n?1:0,Cw(e,e.block_start,i,o),e.block_start+=i,sO(e.strm)),o?3:1)},pO=(e,t)=>{let i,n;for(;;){if(e.lookahead<Xw){if(hO(e),e.lookahead<Xw&&t===Aw)return 1;if(0===e.lookahead)break}if(i=0,e.lookahead>=3&&(e.ins_h=rO(e,e.ins_h,e.window[e.strstart+3-1]),i=e.prev[e.strstart&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=e.strstart),0!==i&&e.strstart-i<=e.w_size-Xw&&(e.match_length=lO(e,i)),e.match_length>=3)if(n=Iw(e,e.strstart-e.match_start,e.match_length-3),e.lookahead-=e.match_length,e.match_length<=e.max_lazy_match&&e.lookahead>=3){e.match_length--;do{e.strstart++,e.ins_h=rO(e,e.ins_h,e.window[e.strstart+3-1]),i=e.prev[e.strstart&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=e.strstart;}while(0!=--e.match_length);e.strstart++;}else e.strstart+=e.match_length,e.match_length=0,e.ins_h=e.window[e.strstart],e.ins_h=rO(e,e.ins_h,e.window[e.strstart+1]);else n=Iw(e,0,e.window[e.strstart]),e.lookahead--,e.strstart++;if(n&&(oO(e,!1),0===e.strm.avail_out))return 1}return e.insert=e.strstart<2?e.strstart:2,t===Ow?(oO(e,!0),0===e.strm.avail_out?3:4):e.sym_next&&(oO(e,!1),0===e.strm.avail_out)?1:2},_O=(e,t)=>{let i,n,r;for(;;){if(e.lookahead<Xw){if(hO(e),e.lookahead<Xw&&t===Aw)return 1;if(0===e.lookahead)break}if(i=0,e.lookahead>=3&&(e.ins_h=rO(e,e.ins_h,e.window[e.strstart+3-1]),i=e.prev[e.strstart&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=e.strstart),e.prev_length=e.match_length,e.prev_match=e.match_start,e.match_length=2,0!==i&&e.prev_length<e.max_lazy_match&&e.strstart-i<=e.w_size-Xw&&(e.match_length=lO(e,i),e.match_length<=5&&(e.strategy===xw||3===e.match_length&&e.strstart-e.match_start>4096)&&(e.match_length=2)),e.prev_length>=3&&e.match_length<=e.prev_length){r=e.strstart+e.lookahead-3,n=Iw(e,e.strstart-1-e.prev_match,e.prev_length-3),e.lookahead-=e.prev_length-1,e.prev_length-=2;do{++e.strstart<=r&&(e.ins_h=rO(e,e.ins_h,e.window[e.strstart+3-1]),i=e.prev[e.strstart&e.w_mask]=e.head[e.ins_h],e.head[e.ins_h]=e.strstart);}while(0!=--e.prev_length);if(e.match_available=0,e.match_length=2,e.strstart++,n&&(oO(e,!1),0===e.strm.avail_out))return 1}else if(e.match_available){if(n=Iw(e,0,e.window[e.strstart-1]),n&&oO(e,!1),e.strstart++,e.lookahead--,0===e.strm.avail_out)return 1}else e.match_available=1,e.strstart++,e.lookahead--;}return e.match_available&&(n=Iw(e,0,e.window[e.strstart-1]),e.match_available=0),e.insert=e.strstart<2?e.strstart:2,t===Ow?(oO(e,!0),0===e.strm.avail_out?3:4):e.sym_next&&(oO(e,!1),0===e.strm.avail_out)?1:2};function EO(e,t,i,n,r){this.good_length=e,this.max_lazy=t,this.nice_length=i,this.max_chain=n,this.func=r;}const mO=[new EO(0,0,0,0,uO),new EO(4,4,8,4,pO),new EO(4,5,16,8,pO),new EO(4,6,32,32,pO),new EO(4,4,16,16,_O),new EO(8,16,32,32,_O),new EO(8,16,128,128,_O),new EO(8,32,128,256,_O),new EO(32,128,258,1024,_O),new EO(32,258,258,4096,_O)];function fO(){this.strm=null,this.status=0,this.pending_buf=null,this.pending_buf_size=0,this.pending_out=0,this.pending=0,this.wrap=0,this.gzhead=null,this.gzindex=0,this.method=Ww,this.last_flush=-1,this.w_size=0,this.w_bits=0,this.w_mask=0,this.window=null,this.window_size=0,this.prev=null,this.head=null,this.ins_h=0,this.hash_size=0,this.hash_bits=0,this.hash_mask=0,this.hash_shift=0,this.block_start=0,this.match_length=0,this.prev_match=0,this.match_available=0,this.strstart=0,this.match_start=0,this.lookahead=0,this.prev_length=0,this.max_chain_length=0,this.max_lazy_match=0,this.level=0,this.strategy=0,this.good_match=0,this.nice_match=0,this.dyn_ltree=new Uint16Array(2*qw),this.dyn_dtree=new Uint16Array(2*(2*Kw+1)),this.bl_tree=new Uint16Array(2*(2*Yw+1)),iO(this.dyn_ltree),iO(this.dyn_dtree),iO(this.bl_tree),this.l_desc=null,this.d_desc=null,this.bl_desc=null,this.bl_count=new Uint16Array(Jw+1),this.heap=new Uint16Array(2*Hw+1),iO(this.heap),this.heap_len=0,this.heap_max=0,this.depth=new Uint16Array(2*Hw+1),iO(this.depth),this.sym_buf=0,this.lit_bufsize=0,this.sym_next=0,this.sym_end=0,this.opt_len=0,this.static_len=0,this.matches=0,this.insert=0,this.bi_buf=0,this.bi_valid=0;}const gO=e=>{if(!e)return 1;const t=e.state;return !t||t.strm!==e||t.status!==Qw&&57!==t.status&&69!==t.status&&73!==t.status&&91!==t.status&&103!==t.status&&t.status!==Zw&&t.status!==$w?1:0},TO=e=>{if(gO(e))return eO(e,Lw);e.total_in=e.total_out=0,e.data_type=Gw;const t=e.state;return t.pending=0,t.pending_out=0,t.wrap<0&&(t.wrap=-t.wrap),t.status=2===t.wrap?57:t.wrap?Qw:Zw,e.adler=2===t.wrap?0:1,t.last_flush=-2,Rw(t),Dw},SO=e=>{const t=TO(e);var i;return t===Dw&&((i=e.state).window_size=2*i.w_size,iO(i.head),i.max_lazy_match=mO[i.level].max_lazy,i.good_match=mO[i.level].good_length,i.nice_match=mO[i.level].nice_length,i.max_chain_length=mO[i.level].max_chain,i.strstart=0,i.block_start=0,i.lookahead=0,i.insert=0,i.match_length=i.prev_length=2,i.match_available=0,i.ins_h=0),t},RO=(e,t,i,n,r,s)=>{if(!e)return Lw;let o=1;if(t===Uw&&(t=6),n<0?(o=0,n=-n):n>15&&(o=2,n-=16),r<1||r>9||i!==Ww||n<8||n>15||t<0||t>9||s<0||s>Bw||8===n&&1!==o)return eO(e,Lw);8===n&&(n=9);const a=new fO;return e.state=a,a.strm=e,a.status=Qw,a.wrap=o,a.gzhead=null,a.w_bits=n,a.w_size=1<<a.w_bits,a.w_mask=a.w_size-1,a.hash_bits=r+7,a.hash_size=1<<a.hash_bits,a.hash_mask=a.hash_size-1,a.hash_shift=~~((a.hash_bits+3-1)/3),a.window=new Uint8Array(2*a.w_size),a.head=new Uint16Array(a.hash_size),a.prev=new Uint16Array(a.w_size),a.lit_bufsize=1<<r+6,a.pending_buf_size=4*a.lit_bufsize,a.pending_buf=new Uint8Array(a.pending_buf_size),a.sym_buf=a.lit_bufsize,a.sym_end=3*(a.lit_bufsize-1),a.level=t,a.strategy=s,a.method=i,SO(e)};var CO=(e,t)=>{if(gO(e)||t>Nw||t<0)return e?eO(e,Lw):Lw;const i=e.state;if(!e.output||0!==e.avail_in&&!e.input||i.status===$w&&t!==Ow)return eO(e,0===e.avail_out?Mw:Lw);const n=i.last_flush;if(i.last_flush=t,0!==i.pending){if(sO(e),0===e.avail_out)return i.last_flush=-1,Dw}else if(0===e.avail_in&&tO(t)<=tO(n)&&t!==Ow)return eO(e,Mw);if(i.status===$w&&0!==e.avail_in)return eO(e,Mw);if(i.status===Qw&&0===i.wrap&&(i.status=Zw),i.status===Qw){let t=Ww+(i.w_bits-8<<4)<<8,n=-1;if(n=i.strategy>=Vw||i.level<2?0:i.level<6?1:6===i.level?2:3,t|=n<<6,0!==i.strstart&&(t|=32),t+=31-t%31,cO(i,t),0!==i.strstart&&(cO(i,e.adler>>>16),cO(i,65535&e.adler)),e.adler=1,i.status=Zw,sO(e),0!==i.pending)return i.last_flush=-1,Dw}if(57===i.status)if(e.adler=0,aO(i,31),aO(i,139),aO(i,8),i.gzhead)aO(i,(i.gzhead.text?1:0)+(i.gzhead.hcrc?2:0)+(i.gzhead.extra?4:0)+(i.gzhead.name?8:0)+(i.gzhead.comment?16:0)),aO(i,255&i.gzhead.time),aO(i,i.gzhead.time>>8&255),aO(i,i.gzhead.time>>16&255),aO(i,i.gzhead.time>>24&255),aO(i,9===i.level?2:i.strategy>=Vw||i.level<2?4:0),aO(i,255&i.gzhead.os),i.gzhead.extra&&i.gzhead.extra.length&&(aO(i,255&i.gzhead.extra.length),aO(i,i.gzhead.extra.length>>8&255)),i.gzhead.hcrc&&(e.adler=gw(e.adler,i.pending_buf,i.pending,0)),i.gzindex=0,i.status=69;else if(aO(i,0),aO(i,0),aO(i,0),aO(i,0),aO(i,0),aO(i,9===i.level?2:i.strategy>=Vw||i.level<2?4:0),aO(i,3),i.status=Zw,sO(e),0!==i.pending)return i.last_flush=-1,Dw;if(69===i.status){if(i.gzhead.extra){let t=i.pending,n=(65535&i.gzhead.extra.length)-i.gzindex;for(;i.pending+n>i.pending_buf_size;){let r=i.pending_buf_size-i.pending;if(i.pending_buf.set(i.gzhead.extra.subarray(i.gzindex,i.gzindex+r),i.pending),i.pending=i.pending_buf_size,i.gzhead.hcrc&&i.pending>t&&(e.adler=gw(e.adler,i.pending_buf,i.pending-t,t)),i.gzindex+=r,sO(e),0!==i.pending)return i.last_flush=-1,Dw;t=0,n-=r;}let r=new Uint8Array(i.gzhead.extra);i.pending_buf.set(r.subarray(i.gzindex,i.gzindex+n),i.pending),i.pending+=n,i.gzhead.hcrc&&i.pending>t&&(e.adler=gw(e.adler,i.pending_buf,i.pending-t,t)),i.gzindex=0;}i.status=73;}if(73===i.status){if(i.gzhead.name){let t,n=i.pending;do{if(i.pending===i.pending_buf_size){if(i.gzhead.hcrc&&i.pending>n&&(e.adler=gw(e.adler,i.pending_buf,i.pending-n,n)),sO(e),0!==i.pending)return i.last_flush=-1,Dw;n=0;}t=i.gzindex<i.gzhead.name.length?255&i.gzhead.name.charCodeAt(i.gzindex++):0,aO(i,t);}while(0!==t);i.gzhead.hcrc&&i.pending>n&&(e.adler=gw(e.adler,i.pending_buf,i.pending-n,n)),i.gzindex=0;}i.status=91;}if(91===i.status){if(i.gzhead.comment){let t,n=i.pending;do{if(i.pending===i.pending_buf_size){if(i.gzhead.hcrc&&i.pending>n&&(e.adler=gw(e.adler,i.pending_buf,i.pending-n,n)),sO(e),0!==i.pending)return i.last_flush=-1,Dw;n=0;}t=i.gzindex<i.gzhead.comment.length?255&i.gzhead.comment.charCodeAt(i.gzindex++):0,aO(i,t);}while(0!==t);i.gzhead.hcrc&&i.pending>n&&(e.adler=gw(e.adler,i.pending_buf,i.pending-n,n));}i.status=103;}if(103===i.status){if(i.gzhead.hcrc){if(i.pending+2>i.pending_buf_size&&(sO(e),0!==i.pending))return i.last_flush=-1,Dw;aO(i,255&e.adler),aO(i,e.adler>>8&255),e.adler=0;}if(i.status=Zw,sO(e),0!==i.pending)return i.last_flush=-1,Dw}if(0!==e.avail_in||0!==i.lookahead||t!==Aw&&i.status!==$w){let n=0===i.level?uO(i,t):i.strategy===Vw?((e,t)=>{let i;for(;;){if(0===e.lookahead&&(hO(e),0===e.lookahead)){if(t===Aw)return 1;break}if(e.match_length=0,i=Iw(e,0,e.window[e.strstart]),e.lookahead--,e.strstart++,i&&(oO(e,!1),0===e.strm.avail_out))return 1}return e.insert=0,t===Ow?(oO(e,!0),0===e.strm.avail_out?3:4):e.sym_next&&(oO(e,!1),0===e.strm.avail_out)?1:2})(i,t):i.strategy===Fw?((e,t)=>{let i,n,r,s;const o=e.window;for(;;){if(e.lookahead<=zw){if(hO(e),e.lookahead<=zw&&t===Aw)return 1;if(0===e.lookahead)break}if(e.match_length=0,e.lookahead>=3&&e.strstart>0&&(r=e.strstart-1,n=o[r],n===o[++r]&&n===o[++r]&&n===o[++r])){s=e.strstart+zw;do{}while(n===o[++r]&&n===o[++r]&&n===o[++r]&&n===o[++r]&&n===o[++r]&&n===o[++r]&&n===o[++r]&&n===o[++r]&&r<s);e.match_length=zw-(s-r),e.match_length>e.lookahead&&(e.match_length=e.lookahead);}if(e.match_length>=3?(i=Iw(e,1,e.match_length-3),e.lookahead-=e.match_length,e.strstart+=e.match_length,e.match_length=0):(i=Iw(e,0,e.window[e.strstart]),e.lookahead--,e.strstart++),i&&(oO(e,!1),0===e.strm.avail_out))return 1}return e.insert=0,t===Ow?(oO(e,!0),0===e.strm.avail_out?3:4):e.sym_next&&(oO(e,!1),0===e.strm.avail_out)?1:2})(i,t):mO[i.level].func(i,t);if(3!==n&&4!==n||(i.status=$w),1===n||3===n)return 0===e.avail_out&&(i.last_flush=-1),Dw;if(2===n&&(t===bw?yw(i):t!==Nw&&(Cw(i,0,0,!1),t===ww&&(iO(i.head),0===i.lookahead&&(i.strstart=0,i.block_start=0,i.insert=0))),sO(e),0===e.avail_out))return i.last_flush=-1,Dw}return t!==Ow?Dw:i.wrap<=0?Pw:(2===i.wrap?(aO(i,255&e.adler),aO(i,e.adler>>8&255),aO(i,e.adler>>16&255),aO(i,e.adler>>24&255),aO(i,255&e.total_in),aO(i,e.total_in>>8&255),aO(i,e.total_in>>16&255),aO(i,e.total_in>>24&255)):(cO(i,e.adler>>>16),cO(i,65535&e.adler)),sO(e),i.wrap>0&&(i.wrap=-i.wrap),0!==i.pending?Dw:Pw)},vO=(e,t)=>{let i=t.length;if(gO(e))return Lw;const n=e.state,r=n.wrap;if(2===r||1===r&&n.status!==Qw||n.lookahead)return Lw;if(1===r&&(e.adler=mw(e.adler,t,i,0)),n.wrap=0,i>=n.w_size){0===r&&(iO(n.head),n.strstart=0,n.block_start=0,n.insert=0);let e=new Uint8Array(n.w_size);e.set(t.subarray(i-n.w_size,i),0),t=e,i=n.w_size;}const s=e.avail_in,o=e.next_in,a=e.input;for(e.avail_in=i,e.next_in=0,e.input=t,hO(n);n.lookahead>=3;){let e=n.strstart,t=n.lookahead-2;do{n.ins_h=rO(n,n.ins_h,n.window[e+3-1]),n.prev[e&n.w_mask]=n.head[n.ins_h],n.head[n.ins_h]=e,e++;}while(--t);n.strstart=e,n.lookahead=2,hO(n);}return n.strstart+=n.lookahead,n.block_start=n.strstart,n.insert=n.lookahead,n.lookahead=0,n.match_length=n.prev_length=2,n.match_available=0,e.next_in=o,e.input=a,e.avail_in=s,n.wrap=r,Dw},IO={deflateInit:(e,t)=>RO(e,t,Ww,15,8,jw),deflateInit2:RO,deflateReset:SO,deflateResetKeep:TO,deflateSetHeader:(e,t)=>gO(e)||2!==e.state.wrap?Lw:(e.state.gzhead=t,Dw),deflate:CO,deflateEnd:e=>{if(gO(e))return Lw;const t=e.state.status;return e.state=null,t===Zw?eO(e,kw):Dw},deflateSetDictionary:vO,deflateInfo:"pako deflate (from Nodeca project)"};const yO=(e,t)=>Object.prototype.hasOwnProperty.call(e,t);var AO={assign:function(e){const t=Array.prototype.slice.call(arguments,1);for(;t.length;){const i=t.shift();if(i){if("object"!=typeof i)throw new TypeError(i+"must be non-object");for(const t in i)yO(i,t)&&(e[t]=i[t]);}}return e},flattenChunks:e=>{let t=0;for(let i=0,n=e.length;i<n;i++)t+=e[i].length;const i=new Uint8Array(t);for(let t=0,n=0,r=e.length;t<r;t++){let r=e[t];i.set(r,n),n+=r.length;}return i}};let bO=!0;try{String.fromCharCode.apply(null,new Uint8Array(1));}catch(e){bO=!1;}const wO=new Uint8Array(256);for(let e=0;e<256;e++)wO[e]=e>=252?6:e>=248?5:e>=240?4:e>=224?3:e>=192?2:1;wO[254]=wO[254]=1;var OO={string2buf:e=>{if("function"==typeof TextEncoder&&TextEncoder.prototype.encode)return (new TextEncoder).encode(e);let t,i,n,r,s,o=e.length,a=0;for(r=0;r<o;r++)i=e.charCodeAt(r),55296==(64512&i)&&r+1<o&&(n=e.charCodeAt(r+1),56320==(64512&n)&&(i=65536+(i-55296<<10)+(n-56320),r++)),a+=i<128?1:i<2048?2:i<65536?3:4;for(t=new Uint8Array(a),s=0,r=0;s<a;r++)i=e.charCodeAt(r),55296==(64512&i)&&r+1<o&&(n=e.charCodeAt(r+1),56320==(64512&n)&&(i=65536+(i-55296<<10)+(n-56320),r++)),i<128?t[s++]=i:i<2048?(t[s++]=192|i>>>6,t[s++]=128|63&i):i<65536?(t[s++]=224|i>>>12,t[s++]=128|i>>>6&63,t[s++]=128|63&i):(t[s++]=240|i>>>18,t[s++]=128|i>>>12&63,t[s++]=128|i>>>6&63,t[s++]=128|63&i);return t},buf2string:(e,t)=>{const i=t||e.length;if("function"==typeof TextDecoder&&TextDecoder.prototype.decode)return (new TextDecoder).decode(e.subarray(0,t));let n,r;const s=new Array(2*i);for(r=0,n=0;n<i;){let t=e[n++];if(t<128){s[r++]=t;continue}let o=wO[t];if(o>4)s[r++]=65533,n+=o-1;else {for(t&=2===o?31:3===o?15:7;o>1&&n<i;)t=t<<6|63&e[n++],o--;o>1?s[r++]=65533:t<65536?s[r++]=t:(t-=65536,s[r++]=55296|t>>10&1023,s[r++]=56320|1023&t);}}return ((e,t)=>{if(t<65534&&e.subarray&&bO)return String.fromCharCode.apply(null,e.length===t?e:e.subarray(0,t));let i="";for(let n=0;n<t;n++)i+=String.fromCharCode(e[n]);return i})(s,r)},utf8border:(e,t)=>{(t=t||e.length)>e.length&&(t=e.length);let i=t-1;for(;i>=0&&128==(192&e[i]);)i--;return i<0||0===i?t:i+wO[e[i]]>t?i:t}};var NO=function(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg="",this.state=null,this.data_type=2,this.adler=0;};const DO=Object.prototype.toString,{Z_NO_FLUSH:PO,Z_SYNC_FLUSH:LO,Z_FULL_FLUSH:kO,Z_FINISH:MO,Z_OK:UO,Z_STREAM_END:xO,Z_DEFAULT_COMPRESSION:VO,Z_DEFAULT_STRATEGY:FO,Z_DEFLATED:BO}=Sw;function jO(e){this.options=AO.assign({level:VO,method:BO,chunkSize:16384,windowBits:15,memLevel:8,strategy:FO},e||{});let t=this.options;t.raw&&t.windowBits>0?t.windowBits=-t.windowBits:t.gzip&&t.windowBits>0&&t.windowBits<16&&(t.windowBits+=16),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new NO,this.strm.avail_out=0;let i=IO.deflateInit2(this.strm,t.level,t.method,t.windowBits,t.memLevel,t.strategy);if(i!==UO)throw new Error(Tw[i]);if(t.header&&IO.deflateSetHeader(this.strm,t.header),t.dictionary){let e;if(e="string"==typeof t.dictionary?OO.string2buf(t.dictionary):"[object ArrayBuffer]"===DO.call(t.dictionary)?new Uint8Array(t.dictionary):t.dictionary,i=IO.deflateSetDictionary(this.strm,e),i!==UO)throw new Error(Tw[i]);this._dict_set=!0;}}function GO(e,t){const i=new jO(t);if(i.push(e,!0),i.err)throw i.msg||Tw[i.err];return i.result}jO.prototype.push=function(e,t){const i=this.strm,n=this.options.chunkSize;let r,s;if(this.ended)return !1;for(s=t===~~t?t:!0===t?MO:PO,"string"==typeof e?i.input=OO.string2buf(e):"[object ArrayBuffer]"===DO.call(e)?i.input=new Uint8Array(e):i.input=e,i.next_in=0,i.avail_in=i.input.length;;)if(0===i.avail_out&&(i.output=new Uint8Array(n),i.next_out=0,i.avail_out=n),(s===LO||s===kO)&&i.avail_out<=6)this.onData(i.output.subarray(0,i.next_out)),i.avail_out=0;else {if(r=IO.deflate(i,s),r===xO)return i.next_out>0&&this.onData(i.output.subarray(0,i.next_out)),r=IO.deflateEnd(this.strm),this.onEnd(r),this.ended=!0,r===UO;if(0!==i.avail_out){if(s>0&&i.next_out>0)this.onData(i.output.subarray(0,i.next_out)),i.avail_out=0;else if(0===i.avail_in)break}else this.onData(i.output);}return !0},jO.prototype.onData=function(e){this.chunks.push(e);},jO.prototype.onEnd=function(e){e===UO&&(this.result=AO.flattenChunks(this.chunks)),this.chunks=[],this.err=e,this.msg=this.strm.msg;};var WO={Deflate:jO,deflate:GO,deflateRaw:function(e,t){return (t=t||{}).raw=!0,GO(e,t)},gzip:function(e,t){return (t=t||{}).gzip=!0,GO(e,t)},constants:Sw};const HO=16209;var KO=function(e,t){let i,n,r,s,o,a,c,d,l,h,u,p,_,E,m,f,g,T,S,R,C,v,I,y;const A=e.state;i=e.next_in,I=e.input,n=i+(e.avail_in-5),r=e.next_out,y=e.output,s=r-(t-e.avail_out),o=r+(e.avail_out-257),a=A.dmax,c=A.wsize,d=A.whave,l=A.wnext,h=A.window,u=A.hold,p=A.bits,_=A.lencode,E=A.distcode,m=(1<<A.lenbits)-1,f=(1<<A.distbits)-1;e:do{p<15&&(u+=I[i++]<<p,p+=8,u+=I[i++]<<p,p+=8),g=_[u&m];t:for(;;){if(T=g>>>24,u>>>=T,p-=T,T=g>>>16&255,0===T)y[r++]=65535&g;else {if(!(16&T)){if(0==(64&T)){g=_[(65535&g)+(u&(1<<T)-1)];continue t}if(32&T){A.mode=16191;break e}e.msg="invalid literal/length code",A.mode=HO;break e}S=65535&g,T&=15,T&&(p<T&&(u+=I[i++]<<p,p+=8),S+=u&(1<<T)-1,u>>>=T,p-=T),p<15&&(u+=I[i++]<<p,p+=8,u+=I[i++]<<p,p+=8),g=E[u&f];i:for(;;){if(T=g>>>24,u>>>=T,p-=T,T=g>>>16&255,!(16&T)){if(0==(64&T)){g=E[(65535&g)+(u&(1<<T)-1)];continue i}e.msg="invalid distance code",A.mode=HO;break e}if(R=65535&g,T&=15,p<T&&(u+=I[i++]<<p,p+=8,p<T&&(u+=I[i++]<<p,p+=8)),R+=u&(1<<T)-1,R>a){e.msg="invalid distance too far back",A.mode=HO;break e}if(u>>>=T,p-=T,T=r-s,R>T){if(T=R-T,T>d&&A.sane){e.msg="invalid distance too far back",A.mode=HO;break e}if(C=0,v=h,0===l){if(C+=c-T,T<S){S-=T;do{y[r++]=h[C++];}while(--T);C=r-R,v=y;}}else if(l<T){if(C+=c+l-T,T-=l,T<S){S-=T;do{y[r++]=h[C++];}while(--T);if(C=0,l<S){T=l,S-=T;do{y[r++]=h[C++];}while(--T);C=r-R,v=y;}}}else if(C+=l-T,T<S){S-=T;do{y[r++]=h[C++];}while(--T);C=r-R,v=y;}for(;S>2;)y[r++]=v[C++],y[r++]=v[C++],y[r++]=v[C++],S-=3;S&&(y[r++]=v[C++],S>1&&(y[r++]=v[C++]));}else {C=r-R;do{y[r++]=y[C++],y[r++]=y[C++],y[r++]=y[C++],S-=3;}while(S>2);S&&(y[r++]=y[C++],S>1&&(y[r++]=y[C++]));}break}}break}}while(i<n&&r<o);S=p>>3,i-=S,p-=S<<3,u&=(1<<p)-1,e.next_in=i,e.next_out=r,e.avail_in=i<n?n-i+5:5-(i-n),e.avail_out=r<o?o-r+257:257-(r-o),A.hold=u,A.bits=p;};const YO=15,qO=new Uint16Array([3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0]),JO=new Uint8Array([16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78]),zO=new Uint16Array([1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0]),XO=new Uint8Array([16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64]);var QO=(e,t,i,n,r,s,o,a)=>{const c=a.bits;let d,l,h,u,p,_,E=0,m=0,f=0,g=0,T=0,S=0,R=0,C=0,v=0,I=0,y=null;const A=new Uint16Array(16),b=new Uint16Array(16);let w,O,N,D=null;for(E=0;E<=YO;E++)A[E]=0;for(m=0;m<n;m++)A[t[i+m]]++;for(T=c,g=YO;g>=1&&0===A[g];g--);if(T>g&&(T=g),0===g)return r[s++]=20971520,r[s++]=20971520,a.bits=1,0;for(f=1;f<g&&0===A[f];f++);for(T<f&&(T=f),C=1,E=1;E<=YO;E++)if(C<<=1,C-=A[E],C<0)return -1;if(C>0&&(0===e||1!==g))return -1;for(b[1]=0,E=1;E<YO;E++)b[E+1]=b[E]+A[E];for(m=0;m<n;m++)0!==t[i+m]&&(o[b[t[i+m]]++]=m);if(0===e?(y=D=o,_=20):1===e?(y=qO,D=JO,_=257):(y=zO,D=XO,_=0),I=0,m=0,E=f,p=s,S=T,R=0,h=-1,v=1<<T,u=v-1,1===e&&v>852||2===e&&v>592)return 1;for(;;){w=E-R,o[m]+1<_?(O=0,N=o[m]):o[m]>=_?(O=D[o[m]-_],N=y[o[m]-_]):(O=96,N=0),d=1<<E-R,l=1<<S,f=l;do{l-=d,r[p+(I>>R)+l]=w<<24|O<<16|N|0;}while(0!==l);for(d=1<<E-1;I&d;)d>>=1;if(0!==d?(I&=d-1,I+=d):I=0,m++,0==--A[E]){if(E===g)break;E=t[i+o[m]];}if(E>T&&(I&u)!==h){for(0===R&&(R=T),p+=f,S=E-R,C=1<<S;S+R<g&&(C-=A[S+R],!(C<=0));)S++,C<<=1;if(v+=1<<S,1===e&&v>852||2===e&&v>592)return 1;h=I&u,r[h]=T<<24|S<<16|p-s|0;}}return 0!==I&&(r[p+I]=E-R<<24|64<<16|0),a.bits=T,0};const{Z_FINISH:ZO,Z_BLOCK:$O,Z_TREES:eN,Z_OK:tN,Z_STREAM_END:iN,Z_NEED_DICT:nN,Z_STREAM_ERROR:rN,Z_DATA_ERROR:sN,Z_MEM_ERROR:oN,Z_BUF_ERROR:aN,Z_DEFLATED:cN}=Sw,dN=16180,lN=16190,hN=16191,uN=16192,pN=16194,_N=16199,EN=16200,mN=16206,fN=16209,gN=e=>(e>>>24&255)+(e>>>8&65280)+((65280&e)<<8)+((255&e)<<24);function TN(){this.strm=null,this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new Uint16Array(320),this.work=new Uint16Array(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0;}const SN=e=>{if(!e)return 1;const t=e.state;return !t||t.strm!==e||t.mode<dN||t.mode>16211?1:0},RN=e=>{if(SN(e))return rN;const t=e.state;return e.total_in=e.total_out=t.total=0,e.msg="",t.wrap&&(e.adler=1&t.wrap),t.mode=dN,t.last=0,t.havedict=0,t.flags=-1,t.dmax=32768,t.head=null,t.hold=0,t.bits=0,t.lencode=t.lendyn=new Int32Array(852),t.distcode=t.distdyn=new Int32Array(592),t.sane=1,t.back=-1,tN},CN=e=>{if(SN(e))return rN;const t=e.state;return t.wsize=0,t.whave=0,t.wnext=0,RN(e)},vN=(e,t)=>{let i;if(SN(e))return rN;const n=e.state;return t<0?(i=0,t=-t):(i=5+(t>>4),t<48&&(t&=15)),t&&(t<8||t>15)?rN:(null!==n.window&&n.wbits!==t&&(n.window=null),n.wrap=i,n.wbits=t,CN(e))},IN=(e,t)=>{if(!e)return rN;const i=new TN;e.state=i,i.strm=e,i.window=null,i.mode=dN;const n=vN(e,t);return n!==tN&&(e.state=null),n};let yN,AN,bN=!0;const wN=e=>{if(bN){yN=new Int32Array(512),AN=new Int32Array(32);let t=0;for(;t<144;)e.lens[t++]=8;for(;t<256;)e.lens[t++]=9;for(;t<280;)e.lens[t++]=7;for(;t<288;)e.lens[t++]=8;for(QO(1,e.lens,0,288,yN,0,e.work,{bits:9}),t=0;t<32;)e.lens[t++]=5;QO(2,e.lens,0,32,AN,0,e.work,{bits:5}),bN=!1;}e.lencode=yN,e.lenbits=9,e.distcode=AN,e.distbits=5;},ON=(e,t,i,n)=>{let r;const s=e.state;return null===s.window&&(s.wsize=1<<s.wbits,s.wnext=0,s.whave=0,s.window=new Uint8Array(s.wsize)),n>=s.wsize?(s.window.set(t.subarray(i-s.wsize,i),0),s.wnext=0,s.whave=s.wsize):(r=s.wsize-s.wnext,r>n&&(r=n),s.window.set(t.subarray(i-n,i-n+r),s.wnext),(n-=r)?(s.window.set(t.subarray(i-n,i),0),s.wnext=n,s.whave=s.wsize):(s.wnext+=r,s.wnext===s.wsize&&(s.wnext=0),s.whave<s.wsize&&(s.whave+=r))),0};var NN=(e,t)=>{let i,n,r,s,o,a,c,d,l,h,u,p,_,E,m,f,g,T,S,R,C,v,I=0;const y=new Uint8Array(4);let A,b;const w=new Uint8Array([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]);if(SN(e)||!e.output||!e.input&&0!==e.avail_in)return rN;i=e.state,i.mode===hN&&(i.mode=uN),o=e.next_out,r=e.output,c=e.avail_out,s=e.next_in,n=e.input,a=e.avail_in,d=i.hold,l=i.bits,h=a,u=c,v=tN;e:for(;;)switch(i.mode){case dN:if(0===i.wrap){i.mode=uN;break}for(;l<16;){if(0===a)break e;a--,d+=n[s++]<<l,l+=8;}if(2&i.wrap&&35615===d){0===i.wbits&&(i.wbits=15),i.check=0,y[0]=255&d,y[1]=d>>>8&255,i.check=gw(i.check,y,2,0),d=0,l=0,i.mode=16181;break}if(i.head&&(i.head.done=!1),!(1&i.wrap)||(((255&d)<<8)+(d>>8))%31){e.msg="incorrect header check",i.mode=fN;break}if((15&d)!==cN){e.msg="unknown compression method",i.mode=fN;break}if(d>>>=4,l-=4,C=8+(15&d),0===i.wbits&&(i.wbits=C),C>15||C>i.wbits){e.msg="invalid window size",i.mode=fN;break}i.dmax=1<<i.wbits,i.flags=0,e.adler=i.check=1,i.mode=512&d?16189:hN,d=0,l=0;break;case 16181:for(;l<16;){if(0===a)break e;a--,d+=n[s++]<<l,l+=8;}if(i.flags=d,(255&i.flags)!==cN){e.msg="unknown compression method",i.mode=fN;break}if(57344&i.flags){e.msg="unknown header flags set",i.mode=fN;break}i.head&&(i.head.text=d>>8&1),512&i.flags&&4&i.wrap&&(y[0]=255&d,y[1]=d>>>8&255,i.check=gw(i.check,y,2,0)),d=0,l=0,i.mode=16182;case 16182:for(;l<32;){if(0===a)break e;a--,d+=n[s++]<<l,l+=8;}i.head&&(i.head.time=d),512&i.flags&&4&i.wrap&&(y[0]=255&d,y[1]=d>>>8&255,y[2]=d>>>16&255,y[3]=d>>>24&255,i.check=gw(i.check,y,4,0)),d=0,l=0,i.mode=16183;case 16183:for(;l<16;){if(0===a)break e;a--,d+=n[s++]<<l,l+=8;}i.head&&(i.head.xflags=255&d,i.head.os=d>>8),512&i.flags&&4&i.wrap&&(y[0]=255&d,y[1]=d>>>8&255,i.check=gw(i.check,y,2,0)),d=0,l=0,i.mode=16184;case 16184:if(1024&i.flags){for(;l<16;){if(0===a)break e;a--,d+=n[s++]<<l,l+=8;}i.length=d,i.head&&(i.head.extra_len=d),512&i.flags&&4&i.wrap&&(y[0]=255&d,y[1]=d>>>8&255,i.check=gw(i.check,y,2,0)),d=0,l=0;}else i.head&&(i.head.extra=null);i.mode=16185;case 16185:if(1024&i.flags&&(p=i.length,p>a&&(p=a),p&&(i.head&&(C=i.head.extra_len-i.length,i.head.extra||(i.head.extra=new Uint8Array(i.head.extra_len)),i.head.extra.set(n.subarray(s,s+p),C)),512&i.flags&&4&i.wrap&&(i.check=gw(i.check,n,p,s)),a-=p,s+=p,i.length-=p),i.length))break e;i.length=0,i.mode=16186;case 16186:if(2048&i.flags){if(0===a)break e;p=0;do{C=n[s+p++],i.head&&C&&i.length<65536&&(i.head.name+=String.fromCharCode(C));}while(C&&p<a);if(512&i.flags&&4&i.wrap&&(i.check=gw(i.check,n,p,s)),a-=p,s+=p,C)break e}else i.head&&(i.head.name=null);i.length=0,i.mode=16187;case 16187:if(4096&i.flags){if(0===a)break e;p=0;do{C=n[s+p++],i.head&&C&&i.length<65536&&(i.head.comment+=String.fromCharCode(C));}while(C&&p<a);if(512&i.flags&&4&i.wrap&&(i.check=gw(i.check,n,p,s)),a-=p,s+=p,C)break e}else i.head&&(i.head.comment=null);i.mode=16188;case 16188:if(512&i.flags){for(;l<16;){if(0===a)break e;a--,d+=n[s++]<<l,l+=8;}if(4&i.wrap&&d!==(65535&i.check)){e.msg="header crc mismatch",i.mode=fN;break}d=0,l=0;}i.head&&(i.head.hcrc=i.flags>>9&1,i.head.done=!0),e.adler=i.check=0,i.mode=hN;break;case 16189:for(;l<32;){if(0===a)break e;a--,d+=n[s++]<<l,l+=8;}e.adler=i.check=gN(d),d=0,l=0,i.mode=lN;case lN:if(0===i.havedict)return e.next_out=o,e.avail_out=c,e.next_in=s,e.avail_in=a,i.hold=d,i.bits=l,nN;e.adler=i.check=1,i.mode=hN;case hN:if(t===$O||t===eN)break e;case uN:if(i.last){d>>>=7&l,l-=7&l,i.mode=mN;break}for(;l<3;){if(0===a)break e;a--,d+=n[s++]<<l,l+=8;}switch(i.last=1&d,d>>>=1,l-=1,3&d){case 0:i.mode=16193;break;case 1:if(wN(i),i.mode=_N,t===eN){d>>>=2,l-=2;break e}break;case 2:i.mode=16196;break;case 3:e.msg="invalid block type",i.mode=fN;}d>>>=2,l-=2;break;case 16193:for(d>>>=7&l,l-=7&l;l<32;){if(0===a)break e;a--,d+=n[s++]<<l,l+=8;}if((65535&d)!=(d>>>16^65535)){e.msg="invalid stored block lengths",i.mode=fN;break}if(i.length=65535&d,d=0,l=0,i.mode=pN,t===eN)break e;case pN:i.mode=16195;case 16195:if(p=i.length,p){if(p>a&&(p=a),p>c&&(p=c),0===p)break e;r.set(n.subarray(s,s+p),o),a-=p,s+=p,c-=p,o+=p,i.length-=p;break}i.mode=hN;break;case 16196:for(;l<14;){if(0===a)break e;a--,d+=n[s++]<<l,l+=8;}if(i.nlen=257+(31&d),d>>>=5,l-=5,i.ndist=1+(31&d),d>>>=5,l-=5,i.ncode=4+(15&d),d>>>=4,l-=4,i.nlen>286||i.ndist>30){e.msg="too many length or distance symbols",i.mode=fN;break}i.have=0,i.mode=16197;case 16197:for(;i.have<i.ncode;){for(;l<3;){if(0===a)break e;a--,d+=n[s++]<<l,l+=8;}i.lens[w[i.have++]]=7&d,d>>>=3,l-=3;}for(;i.have<19;)i.lens[w[i.have++]]=0;if(i.lencode=i.lendyn,i.lenbits=7,A={bits:i.lenbits},v=QO(0,i.lens,0,19,i.lencode,0,i.work,A),i.lenbits=A.bits,v){e.msg="invalid code lengths set",i.mode=fN;break}i.have=0,i.mode=16198;case 16198:for(;i.have<i.nlen+i.ndist;){for(;I=i.lencode[d&(1<<i.lenbits)-1],m=I>>>24,f=I>>>16&255,g=65535&I,!(m<=l);){if(0===a)break e;a--,d+=n[s++]<<l,l+=8;}if(g<16)d>>>=m,l-=m,i.lens[i.have++]=g;else {if(16===g){for(b=m+2;l<b;){if(0===a)break e;a--,d+=n[s++]<<l,l+=8;}if(d>>>=m,l-=m,0===i.have){e.msg="invalid bit length repeat",i.mode=fN;break}C=i.lens[i.have-1],p=3+(3&d),d>>>=2,l-=2;}else if(17===g){for(b=m+3;l<b;){if(0===a)break e;a--,d+=n[s++]<<l,l+=8;}d>>>=m,l-=m,C=0,p=3+(7&d),d>>>=3,l-=3;}else {for(b=m+7;l<b;){if(0===a)break e;a--,d+=n[s++]<<l,l+=8;}d>>>=m,l-=m,C=0,p=11+(127&d),d>>>=7,l-=7;}if(i.have+p>i.nlen+i.ndist){e.msg="invalid bit length repeat",i.mode=fN;break}for(;p--;)i.lens[i.have++]=C;}}if(i.mode===fN)break;if(0===i.lens[256]){e.msg="invalid code -- missing end-of-block",i.mode=fN;break}if(i.lenbits=9,A={bits:i.lenbits},v=QO(1,i.lens,0,i.nlen,i.lencode,0,i.work,A),i.lenbits=A.bits,v){e.msg="invalid literal/lengths set",i.mode=fN;break}if(i.distbits=6,i.distcode=i.distdyn,A={bits:i.distbits},v=QO(2,i.lens,i.nlen,i.ndist,i.distcode,0,i.work,A),i.distbits=A.bits,v){e.msg="invalid distances set",i.mode=fN;break}if(i.mode=_N,t===eN)break e;case _N:i.mode=EN;case EN:if(a>=6&&c>=258){e.next_out=o,e.avail_out=c,e.next_in=s,e.avail_in=a,i.hold=d,i.bits=l,KO(e,u),o=e.next_out,r=e.output,c=e.avail_out,s=e.next_in,n=e.input,a=e.avail_in,d=i.hold,l=i.bits,i.mode===hN&&(i.back=-1);break}for(i.back=0;I=i.lencode[d&(1<<i.lenbits)-1],m=I>>>24,f=I>>>16&255,g=65535&I,!(m<=l);){if(0===a)break e;a--,d+=n[s++]<<l,l+=8;}if(f&&0==(240&f)){for(T=m,S=f,R=g;I=i.lencode[R+((d&(1<<T+S)-1)>>T)],m=I>>>24,f=I>>>16&255,g=65535&I,!(T+m<=l);){if(0===a)break e;a--,d+=n[s++]<<l,l+=8;}d>>>=T,l-=T,i.back+=T;}if(d>>>=m,l-=m,i.back+=m,i.length=g,0===f){i.mode=16205;break}if(32&f){i.back=-1,i.mode=hN;break}if(64&f){e.msg="invalid literal/length code",i.mode=fN;break}i.extra=15&f,i.mode=16201;case 16201:if(i.extra){for(b=i.extra;l<b;){if(0===a)break e;a--,d+=n[s++]<<l,l+=8;}i.length+=d&(1<<i.extra)-1,d>>>=i.extra,l-=i.extra,i.back+=i.extra;}i.was=i.length,i.mode=16202;case 16202:for(;I=i.distcode[d&(1<<i.distbits)-1],m=I>>>24,f=I>>>16&255,g=65535&I,!(m<=l);){if(0===a)break e;a--,d+=n[s++]<<l,l+=8;}if(0==(240&f)){for(T=m,S=f,R=g;I=i.distcode[R+((d&(1<<T+S)-1)>>T)],m=I>>>24,f=I>>>16&255,g=65535&I,!(T+m<=l);){if(0===a)break e;a--,d+=n[s++]<<l,l+=8;}d>>>=T,l-=T,i.back+=T;}if(d>>>=m,l-=m,i.back+=m,64&f){e.msg="invalid distance code",i.mode=fN;break}i.offset=g,i.extra=15&f,i.mode=16203;case 16203:if(i.extra){for(b=i.extra;l<b;){if(0===a)break e;a--,d+=n[s++]<<l,l+=8;}i.offset+=d&(1<<i.extra)-1,d>>>=i.extra,l-=i.extra,i.back+=i.extra;}if(i.offset>i.dmax){e.msg="invalid distance too far back",i.mode=fN;break}i.mode=16204;case 16204:if(0===c)break e;if(p=u-c,i.offset>p){if(p=i.offset-p,p>i.whave&&i.sane){e.msg="invalid distance too far back",i.mode=fN;break}p>i.wnext?(p-=i.wnext,_=i.wsize-p):_=i.wnext-p,p>i.length&&(p=i.length),E=i.window;}else E=r,_=o-i.offset,p=i.length;p>c&&(p=c),c-=p,i.length-=p;do{r[o++]=E[_++];}while(--p);0===i.length&&(i.mode=EN);break;case 16205:if(0===c)break e;r[o++]=i.length,c--,i.mode=EN;break;case mN:if(i.wrap){for(;l<32;){if(0===a)break e;a--,d|=n[s++]<<l,l+=8;}if(u-=c,e.total_out+=u,i.total+=u,4&i.wrap&&u&&(e.adler=i.check=i.flags?gw(i.check,r,u,o-u):mw(i.check,r,u,o-u)),u=c,4&i.wrap&&(i.flags?d:gN(d))!==i.check){e.msg="incorrect data check",i.mode=fN;break}d=0,l=0;}i.mode=16207;case 16207:if(i.wrap&&i.flags){for(;l<32;){if(0===a)break e;a--,d+=n[s++]<<l,l+=8;}if(4&i.wrap&&d!==(4294967295&i.total)){e.msg="incorrect length check",i.mode=fN;break}d=0,l=0;}i.mode=16208;case 16208:v=iN;break e;case fN:v=sN;break e;case 16210:return oN;default:return rN}return e.next_out=o,e.avail_out=c,e.next_in=s,e.avail_in=a,i.hold=d,i.bits=l,(i.wsize||u!==e.avail_out&&i.mode<fN&&(i.mode<mN||t!==ZO))&&ON(e,e.output,e.next_out,u-e.avail_out),h-=e.avail_in,u-=e.avail_out,e.total_in+=h,e.total_out+=u,i.total+=u,4&i.wrap&&u&&(e.adler=i.check=i.flags?gw(i.check,r,u,e.next_out-u):mw(i.check,r,u,e.next_out-u)),e.data_type=i.bits+(i.last?64:0)+(i.mode===hN?128:0)+(i.mode===_N||i.mode===pN?256:0),(0===h&&0===u||t===ZO)&&v===tN&&(v=aN),v},DN={inflateReset:CN,inflateReset2:vN,inflateResetKeep:RN,inflateInit:e=>IN(e,15),inflateInit2:IN,inflate:NN,inflateEnd:e=>{if(SN(e))return rN;let t=e.state;return t.window&&(t.window=null),e.state=null,tN},inflateGetHeader:(e,t)=>{if(SN(e))return rN;const i=e.state;return 0==(2&i.wrap)?rN:(i.head=t,t.done=!1,tN)},inflateSetDictionary:(e,t)=>{const i=t.length;let n,r,s;return SN(e)?rN:(n=e.state,0!==n.wrap&&n.mode!==lN?rN:n.mode===lN&&(r=1,r=mw(r,t,i,0),r!==n.check)?sN:(s=ON(e,t,i,i),s?(n.mode=16210,oN):(n.havedict=1,tN)))},inflateInfo:"pako inflate (from Nodeca project)"};var PN=function(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name="",this.comment="",this.hcrc=0,this.done=!1;};const LN=Object.prototype.toString,{Z_NO_FLUSH:kN,Z_FINISH:MN,Z_OK:UN,Z_STREAM_END:xN,Z_NEED_DICT:VN,Z_STREAM_ERROR:FN,Z_DATA_ERROR:BN,Z_MEM_ERROR:jN}=Sw;function GN(e){this.options=AO.assign({chunkSize:65536,windowBits:15,to:""},e||{});const t=this.options;t.raw&&t.windowBits>=0&&t.windowBits<16&&(t.windowBits=-t.windowBits,0===t.windowBits&&(t.windowBits=-15)),!(t.windowBits>=0&&t.windowBits<16)||e&&e.windowBits||(t.windowBits+=32),t.windowBits>15&&t.windowBits<48&&0==(15&t.windowBits)&&(t.windowBits|=15),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new NO,this.strm.avail_out=0;let i=DN.inflateInit2(this.strm,t.windowBits);if(i!==UN)throw new Error(Tw[i]);if(this.header=new PN,DN.inflateGetHeader(this.strm,this.header),t.dictionary&&("string"==typeof t.dictionary?t.dictionary=OO.string2buf(t.dictionary):"[object ArrayBuffer]"===LN.call(t.dictionary)&&(t.dictionary=new Uint8Array(t.dictionary)),t.raw&&(i=DN.inflateSetDictionary(this.strm,t.dictionary),i!==UN)))throw new Error(Tw[i])}function WN(e,t){const i=new GN(t);if(i.push(e),i.err)throw i.msg||Tw[i.err];return i.result}GN.prototype.push=function(e,t){const i=this.strm,n=this.options.chunkSize,r=this.options.dictionary;let s,o,a;if(this.ended)return !1;for(o=t===~~t?t:!0===t?MN:kN,"[object ArrayBuffer]"===LN.call(e)?i.input=new Uint8Array(e):i.input=e,i.next_in=0,i.avail_in=i.input.length;;){for(0===i.avail_out&&(i.output=new Uint8Array(n),i.next_out=0,i.avail_out=n),s=DN.inflate(i,o),s===VN&&r&&(s=DN.inflateSetDictionary(i,r),s===UN?s=DN.inflate(i,o):s===BN&&(s=VN));i.avail_in>0&&s===xN&&i.state.wrap>0&&0!==e[i.next_in];)DN.inflateReset(i),s=DN.inflate(i,o);switch(s){case FN:case BN:case VN:case jN:return this.onEnd(s),this.ended=!0,!1}if(a=i.avail_out,i.next_out&&(0===i.avail_out||s===xN))if("string"===this.options.to){let e=OO.utf8border(i.output,i.next_out),t=i.next_out-e,r=OO.buf2string(i.output,e);i.next_out=t,i.avail_out=n-t,t&&i.output.set(i.output.subarray(e,e+t),0),this.onData(r);}else this.onData(i.output.length===i.next_out?i.output:i.output.subarray(0,i.next_out));if(s!==UN||0!==a){if(s===xN)return s=DN.inflateEnd(this.strm),this.onEnd(s),this.ended=!0,!0;if(0===i.avail_in)break}}return !0},GN.prototype.onData=function(e){this.chunks.push(e);},GN.prototype.onEnd=function(e){e===UN&&("string"===this.options.to?this.result=this.chunks.join(""):this.result=AO.flattenChunks(this.chunks)),this.chunks=[],this.err=e,this.msg=this.strm.msg;};var HN={Inflate:GN,inflate:WN,inflateRaw:function(e,t){return (t=t||{}).raw=!0,WN(e,t)},ungzip:WN,constants:Sw};const{Deflate:KN,deflate:YN,deflateRaw:qN,gzip:JN}=WO,{Inflate:zN,inflate:XN,inflateRaw:QN,ungzip:ZN}=HN;var $N,eD=YN,tD=XN;!function(e){e[e.ONE_BYTE=0]="ONE_BYTE",e[e.TWO_BYTE=1]="TWO_BYTE";}($N||($N={}));class iD{constructor(){nu(this,"_sequence",0),nu(this,"_startTime",Date.now()),nu(this,"isUseOneByte",!0);}get startTime(){const e=Date.now()-this._startTime;return e<Math.pow(2,16)?e:(this._startTime+=Math.pow(2,16),this.startTime)}get sequence(){return this._sequence<Math.pow(2,32)?this._sequence++:(this._sequence-=Math.pow(2,32),this.sequence)}serialize(e){const t={commonPacketHeader:{length:0,reserved:0,extension:0,sequence:this.sequence},commonStreamHeader:this.startTime,extension:void 0,payload:e};if(e.byteLength>128){const i=new Uint8Array(4);i.set([1,0,0,0]);const n={id:0,length:4,data:i.buffer},r={profile:this.isUseOneByte?0:1,length:this.isUseOneByte?5:6,datas:[n]};t.commonPacketHeader.extension=1,t.extension=r,t.payload=this.compress(e),t.commonPacketHeader.length=8+(t.extension.length+2)+t.payload.byteLength;}else t.commonPacketHeader.length=8+t.payload.byteLength;const i=new ArrayBuffer(t.commonPacketHeader.length),n=new Uint8Array(i),r=new DataView(i);let s=0;if(r.setUint16(s,t.commonPacketHeader.extension<<15|t.commonPacketHeader.reserved<<14|t.commonPacketHeader.length,!0),s+=2,r.setUint32(s,t.commonPacketHeader.sequence,!0),s+=4,r.setUint16(s,t.commonStreamHeader,!0),s+=2,t.extension){const e=this.serializeExtension(t.extension);n.set(new Uint8Array(e),s),s+=e.byteLength;}if(n.set(new Uint8Array(t.payload),s),s+=t.payload.byteLength,s!==t.commonPacketHeader.length)throw Error("serialize error!");return i}deserialize(e){if(e.byteLength<4)return new ArrayBuffer(0);const t=new DataView(e);let i=0;const n=t.getUint16(i,!0);i+=2;const r=(32768&n)>>15;t.getUint16(i+2,!0),t.getUint16(i,!0);let s,o;if(i+=4,t.getUint16(i,!0),i+=2,r){o=this.deserializeExtension(e.slice(i)),i+=2+o.length,s=e.slice(i);let t=!1;if(o.datas.length>0){const e=o.datas.find((e=>0===e.id));if(e){t=1==(1&new DataView(e.data).getUint32(0,!0));}}s=t?this.decompress(s):s;}else s=e.slice(8);return s}serializeExtension(e){const{profile:t,length:i,datas:n}=e,r=new ArrayBuffer(i+2),s=new Uint8Array(r),o=new DataView(r);let a=0;if(o.setUint8(a++,t),o.setUint8(a++,i),n.forEach((e=>{t?(o.setUint8(a++,e.id),o.setUint8(a++,e.length),s.set(new Uint8Array(e.data),a),a+=e.data.byteLength):(o.setUint8(a++,e.id|e.length<<4),s.set(new Uint8Array(e.data),a),a+=e.data.byteLength);})),a!==i+2)throw Error("serialize extension error, is ".concat(a,"!==").concat(i+2));return r}deserializeExtension(e){const t=new DataView(e);let i=0;const n=t.getUint8(i);i++;const r=t.getUint8(i);i++;const s=n===$N.TWO_BYTE,o=[],a=new DataView(e,2);let c=0;for(;c<r;){let e=0,t=0,i=new ArrayBuffer(0);s?(e=a.getUint8(c),c++,t=a.getUint8(c),c++):(e=15&a.getUint8(c),t=a.getUint8(c)>>4,c++),t>0&&(i=a.buffer.slice(c+2,c+2+t),c+=i.byteLength),o.push({id:e,length:t,data:i});}if(c!==r)throw Error("parse error");return {profile:n,length:r,datas:o}}decompress(e){return tD(new Uint8Array(e))}compress(e){return eD(new Uint8Array(e))}}class nD extends iT{constructor(e,t){super(),nu(this,"_version",1),nu(this,"_type",3),nu(this,"_config",void 0),nu(this,"_originDataChannel",void 0),nu(this,"_dataStreamPacketHeader",new ArrayBuffer(4)),nu(this,"_dataStreamPacketHandler",void 0),nu(this,"_datachannelEventMap",new Map),this._config=e,t&&(this._originDataChannel=t,this._bandDataChannelEvents(t)),this._initPacketHeader(),this._dataStreamPacketHandler=new iD;}get id(){return this._config.id}get ordered(){return this._config.ordered}get maxRetransmits(){return kC("DATASTREAM_MAX_RETRANSMITS")}get metadata(){return this._config.metadata}get readyState(){var e,t;return null!==(e=null===(t=this._originDataChannel)||void 0===t?void 0:t.readyState)&&void 0!==e?e:"connecting"}get _originDataChannelId(){var e,t;return null!==(e=null===(t=this._originDataChannel)||void 0===t?void 0:t.id)&&void 0!==e?e:null}getChannelId(){return this.id}getConfig(){return this._config}_close(){this._originDataChannel&&(this._unbindDataChannelEvents(this._originDataChannel),this._originDataChannel=void 0);}async _waitTillOpen(){return new tg(((e,t)=>{if(this._originDataChannel){"open"===this._originDataChannel.readyState&&e();const i=setTimeout((()=>{var e;t(new Vg(xg.DATACHANNEL_CONNECTION_TIMEOUT,"Cannot create datachannel, id: ".concat(null===(e=this._originDataChannel)||void 0===e?void 0:e.id)));}),1e4);this._originDataChannel.onopen=()=>{clearTimeout(i),this._originDataChannel&&this._bandDataChannelEvents(this._originDataChannel),e();},this._originDataChannel.onerror=()=>{throw clearTimeout(i),new Vg(xg.DATACHANNEL_CONNECTION_TIMEOUT)};}else t(new Vg(xg.DATACHANNEL_CONNECTION_TIMEOUT,"cannot find dataChannel"));}))}_updateOriginDataChannel(e){this._originDataChannel=e,this._bandDataChannelEvents(e);}_initPacketHeader(){const e=new DataView(this._dataStreamPacketHeader);e.setUint16(0,this._version),e.setUint8(2,this._type),e.setUint8(3,this._config.id);}_bandDataChannelEvents(e){this._unbindDataChannelEvents(e),[eA.OPEN,eA.CLOSE,eA.ERROR].forEach((t=>{const i=()=>{this.emit(t);};this._datachannelEventMap.set(t,i),e.addEventListener(t,i);}));}_unbindDataChannelEvents(e){Array.from(this._datachannelEventMap.entries()).forEach((t=>{let[i,n]=t;e.removeEventListener(i,n);})),this._datachannelEventMap.clear();}}class rD extends nD{constructor(e){super(e),nu(this,"_messageListener",void 0),this._messageListener=e=>{if(e.data.byteLength<this._dataStreamPacketHeader.byteLength)throw Error("invalid byteLength: the byte length must exceed "+this._dataStreamPacketHeader.byteLength);const t=e.data.slice(0,this._dataStreamPacketHeader.byteLength);if(new DataView(t).getUint8(3)!==this.id)return;let i=e.data.slice(this._dataStreamPacketHeader.byteLength);i=this._dataStreamPacketHandler.deserialize(i),this.emit(eA.MESSAGE,i);};}_updateOriginDataChannel(e){super._updateOriginDataChannel(e),this._bandRemoteDataChannelEvents();}_close(){this._originDataChannel&&(this._originDataChannel.removeEventListener("message",this._messageListener),super._close());}_bandRemoteDataChannelEvents(){this._originDataChannel&&this._originDataChannel.addEventListener("message",this._messageListener);}}class sD extends nD{send(e){if(this._originDataChannel){let t=e;t=this._dataStreamPacketHandler.serialize(e);const i=new Uint8Array(this._dataStreamPacketHeader.byteLength+t.byteLength);i.set(new Uint8Array(this._dataStreamPacketHeader),0),i.set(new Uint8Array(t),this._dataStreamPacketHeader.byteLength),this._originDataChannel.send(i.buffer);}}}class oD extends iT{constructor(){super(...arguments),nu(this,"resultStorage",new Map);}setLocalAudioStats(e,t,i){this.record("AUDIO_INPUT_LEVEL_TOO_LOW",e,this.checkAudioInputLevel(i,t)),this.record("SEND_AUDIO_BITRATE_TOO_LOW",e,this.checkSendAudioBitrate(i,t));}setLocalVideoStats(e,t,i){this.record("SEND_VIDEO_BITRATE_TOO_LOW",e,this.checkSendVideoBitrate(i,t)),this.record("FRAMERATE_INPUT_TOO_LOW",e,this.checkFramerateInput(i,t)),this.record("FRAMERATE_SENT_TOO_LOW",e,this.checkFramerateSent(i));}setRemoteAudioStats(e,t){const i=e.getUserId();this.record("AUDIO_OUTPUT_LEVEL_TOO_LOW",i,this.checkAudioOutputLevel(t));}setRemoteVideoStats(e,t){const i=e.getUserId();this.record("RECV_VIDEO_DECODE_FAILED",i,this.checkVideoDecode(t));}record(e,t,i){if(kC("STATS_UPDATE_INTERVAL")>500)return;this.resultStorage.has(e)||this.resultStorage.set(e,{result:[],isPrevNormal:!0});const n=this.resultStorage.get(e);if(n&&(n.result.push(i),n.result.length>=5)){var r;const i=Pr(r=n.result).call(r,!0);n.isPrevNormal&&!i&&this.emit("exception",aD[e],e,t),!n.isPrevNormal&&i&&this.emit("exception",aD[e]+2e3,e+"_RECOVER",t),n.isPrevNormal=i,n.result=[];}}checkAudioOutputLevel(e){return !(e.receiveBitrate>0&&0===e.receiveLevel)}checkAudioInputLevel(e,t){return t instanceof tb&&!t.isActive||(!!t.muted||0!==e.sendVolumeLevel)}checkFramerateInput(e,t){let i=null;t._encoderConfig&&t._encoderConfig.frameRate&&(i=mD(t._encoderConfig.frameRate));const n=e.captureFrameRate;return !i||!n||!(i>10&&n<5||i<10&&i>=5&&n<=1)}checkFramerateSent(e){return !(e.captureFrameRate&&e.sendFrameRate&&e.captureFrameRate>5&&e.sendFrameRate<=1)}checkSendVideoBitrate(e,t){return !!t.muted||0!==e.sendBitrate}checkSendAudioBitrate(e,t){return t instanceof tb&&!t.isActive||(!!t.muted||0!==e.sendBitrate)}checkVideoDecode(e){return 0===e.receiveBitrate||0!==e.decodeFrameRate}}const aD={FRAMERATE_INPUT_TOO_LOW:1001,FRAMERATE_SENT_TOO_LOW:1002,SEND_VIDEO_BITRATE_TOO_LOW:1003,RECV_VIDEO_DECODE_FAILED:1005,AUDIO_INPUT_LEVEL_TOO_LOW:2001,AUDIO_OUTPUT_LEVEL_TOO_LOW:2002,SEND_AUDIO_BITRATE_TOO_LOW:2003};const cD=new class{markSubscribeStart(e,t){performance.mark("agora-web-sdk/".concat(e,"/subscribe-").concat(t));}markPublishStart(e,t){performance.mark("agora-web-sdk/".concat(e,"/publish-").concat(t));}measureFromSubscribeStart(e,t){const i=performance.getEntriesByName("agora-web-sdk/".concat(e,"/subscribe-").concat(t));if(i.length>0){const e=i[i.length-1];return Math.round(performance.now()-e.startTime)}return 0}measureFromPublishStart(e,t){const i=performance.getEntriesByName("agora-web-sdk/".concat(e,"/publish-").concat(t));if(i.length>0){const e=i[i.length-1];return Math.round(performance.now()-e.startTime)}return 0}};function dD(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n);}return i}function lD(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?dD(Object(i),!0).forEach((function(t){nu(e,t,i[t]);})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):dD(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t));}));}return e}class hD{constructor(e){nu(this,"store",void 0),nu(this,"onStatsException",void 0),nu(this,"onUploadPublishDuration",void 0),nu(this,"onStatsChanged",void 0),nu(this,"localStats",new Map),nu(this,"remoteStats",new Map),nu(this,"updateStatsInterval",void 0),nu(this,"trafficStats",void 0),nu(this,"trafficStatsPeerList",[]),nu(this,"uplinkStats",void 0),nu(this,"exceptionMonitor",void 0),nu(this,"p2pChannel",void 0),nu(this,"scalabilityMode",lv.L1T1),nu(this,"updateStats",(()=>{this.p2pChannel&&(this.updateRemoteStats(this.p2pChannel),this.updateLocalStats(this.p2pChannel));})),this.store=e,this.updateStatsInterval=window.setInterval(this.updateStats,1e3),this.exceptionMonitor=new oD,this.exceptionMonitor.on("exception",((e,t,i)=>{this.onStatsException&&this.onStatsException(e,t,i);}));}reset(){this.localStats=new Map,this.remoteStats=new Map,this.trafficStats=void 0,this.trafficStatsPeerList=[],this.uplinkStats=void 0;}getLocalAudioTrackStats(){return this.localStats.get(_I.LocalAudioTrack)||lD({},Wy)}getLocalVideoTrackStats(){return this.localStats.get(_I.LocalVideoTrack)||lD({},Hy)}getRemoteAudioTrackStats(e){const t=(e,t)=>{if(!this.trafficStats)return t;const i=this.trafficStats.peer_delay.find((t=>t.peer_uid===e));return i&&(t.publishDuration=i.B_ppad+(Date.now()-this.trafficStats.timestamp)),t},i={};if(e){var n;const r=null===(n=this.remoteStats.get(e))||void 0===n?void 0:n.audioStats;r&&(i[e]=t(e,r));}else Array.from(this.remoteStats.entries()).forEach((e=>{let[n,{audioStats:r}]=e;r&&(i[n]=t(n,r));}));return i}getRemoteNetworkQualityStats(e){const t={};if(e){var i;const n=null===(i=this.remoteStats.get(e))||void 0===i?void 0:i.networkStats;n&&(t[e]=n);}else Array.from(this.remoteStats.entries()).forEach((e=>{let[i,{networkStats:n}]=e;n&&(t[i]=n);}));return t}getRemoteVideoTrackStats(e){const t=(e,t)=>{if(!this.trafficStats)return t;const i=this.trafficStats.peer_delay.find((t=>t.peer_uid===e));return i&&(t.publishDuration=i.B_ppvd+(Date.now()-this.trafficStats.timestamp)),t},i={};if(e){var n;const r=null===(n=this.remoteStats.get(e))||void 0===n?void 0:n.videoStats;r&&(i[e]=t(e,r));}else Array.from(this.remoteStats.entries()).forEach((e=>{let[n,{videoStats:r}]=e;r&&(i[n]=t(n,r));}));return i}getRTCStats(){let e=0,t=0,i=0,n=0;const r=this.localStats.get(_I.LocalAudioTrack);r&&(e+=r.sendBytes,t+=r.sendBitrate);const s=this.localStats.get(_I.LocalVideoTrack);s&&(e+=s.sendBytes,t+=s.sendBitrate);const o=this.localStats.get(_I.LocalVideoLowTrack);o&&(e+=o.sendBytes,t+=o.sendBitrate),this.remoteStats.forEach((e=>{let{audioStats:t,videoStats:r}=e;t&&(i+=t.receiveBytes,n+=t.receiveBitrate),r&&(i+=r.receiveBytes,n+=r.receiveBitrate);}));let a=1;return this.trafficStats&&(a+=this.trafficStats.peer_delay.length),{Duration:0,UserCount:a,SendBitrate:t,SendBytes:e,RecvBytes:i,RecvBitrate:n,OutgoingAvailableBandwidth:this.uplinkStats?this.uplinkStats.B_uab/1e3:0,RTT:this.trafficStats?2*this.trafficStats.B_acd:0}}addLocalStats(e){this.localStats.set(e,void 0);}removeLocalStats(e){e?this.localStats.delete(e):this.localStats.clear();}addRemoteStats(e){this.remoteStats.set(e,{});}removeRemoteStats(e){e?this.remoteStats.delete(e):this.remoteStats.clear();}addP2PChannel(e){this.p2pChannel=e;}updateTrafficStats(e){e.peer_delay=e.peer_delay.filter((e=>void 0!==e.B_ppad||void 0!==e.B_ppvd));e.peer_delay.filter((e=>-1===this.trafficStatsPeerList.indexOf(e.peer_uid))).forEach((e=>{var t;const i=null===(t=this.p2pChannel)||void 0===t?void 0:t.getRemoteMedia(e.peer_uid),n=null!=i&&i.videoSSRC?cD.measureFromSubscribeStart(this.store.clientId,i.videoSSRC):0,r=null!=i&&i.audioSSRC?cD.measureFromSubscribeStart(this.store.clientId,i.audioSSRC):0;void 0!==e.B_ppad&&void 0!==e.B_ppvd&&(this.onUploadPublishDuration&&this.onUploadPublishDuration(e.peer_uid,e.B_ppad,e.B_ppvd,n>r?n:r),this.trafficStatsPeerList.push(e.peer_uid));})),this.trafficStats=e;}updateUplinkStats(e){this.uplinkStats&&this.uplinkStats.B_fir!==e.B_fir&&KC.debug("[".concat(this.store.clientId,"]: Period fir changes to ").concat(e.B_fir)),this.uplinkStats=e;}static isRemoteVideoFreeze(e,t,i){if(!e)return !1;const n=!!i&&t.framesDecodeFreezeTime>i.framesDecodeFreezeTime,r=!i||t.framesDecodeCount>i.framesDecodeCount;return n||!r}static isRemoteAudioFreeze(e){return !!e&&e._isFreeze()}isLocalVideoFreeze(e){return !(!e.inputFrame||!e.sentFrame)&&(e.inputFrame.frameRate>5&&e.sentFrame.frameRate<3)}updateLocalStats(e){Array.from(this.localStats.entries()).forEach((t=>{let[i,n]=t;switch(i){case _I.LocalVideoTrack:case _I.LocalVideoLowTrack:{const t=n,s=lD({},Hy),o=e.getStats(),a=e.getLocalMedia(i);if(o){const i=o.videoSend.find((e=>e.ssrc===(null==a?void 0:a.ssrcs[0].ssrcId)));if(i){const n=e.getLocalVideoSize(),r=e.getEncoderConfig(_I.LocalVideoTrack);"H264"!==i.codec&&"H265"!==i.codec&&"VP8"!==i.codec&&"VP9"!==i.codec&&"AV1X"!==i.codec&&"AV1"!==i.codec||(s.codecType=i.codec),s.sendBytes=i.bytes,s.sendBitrate=t?8*Math.max(0,s.sendBytes-t.sendBytes):0,i.inputFrame?(s.captureFrameRate=i.inputFrame.frameRate,s.captureResolutionHeight=i.inputFrame.height,s.captureResolutionWidth=i.inputFrame.width):n&&(s.captureResolutionWidth=n.width,s.captureResolutionHeight=n.height),i.sentFrame?(s.sendFrameRate=i.sentFrame.frameRate,s.sendResolutionHeight=i.sentFrame.height,s.sendResolutionWidth=i.sentFrame.width):n&&(s.sendResolutionWidth=n.width,s.sendResolutionHeight=n.height),i.avgEncodeMs&&(s.encodeDelay=i.avgEncodeMs),r&&r.bitrateMax&&(s.targetSendBitrate=1e3*r.bitrateMax),s.sendPackets=i.packets,s.sendPacketsLost=i.packetsLost,s.sendJitterMs=i.jitterMs,s.sendRttMs=i.rttMs,s.totalDuration=t?t.totalDuration+1:1,s.totalFreezeTime=t?t.totalFreezeTime:0,this.isLocalVideoFreeze(i)&&(s.totalFreezeTime+=1),i.scalabilityMode&&this.scalabilityMode!==i.scalabilityMode&&(KC.debug("[".concat(this.store.clientId,"]: The scalabilityMode of the video sending stream is ").concat(i.scalabilityMode)),this.scalabilityMode=i.scalabilityMode);}this.trafficStats&&(s.currentPacketLossRate=(this.trafficStats.B_pvlr4||0)/100);}var r;if(this.localStats.set(i,s),(null==t?void 0:t.sendResolutionWidth)!==s.sendResolutionWidth||(null==t?void 0:t.sendResolutionHeight)!==s.sendResolutionHeight)null===(r=this.onStatsChanged)||void 0===r||r.call(this,"resolution",{width:s.sendResolutionWidth,height:s.sendResolutionHeight});s&&a&&this.exceptionMonitor.setLocalVideoStats(this.store.uid,a.track,s);break}case _I.LocalAudioTrack:{const t=n,r=lD({},Wy),s=e.getStats(),o=e.getLocalMedia(i);if(s){const i=s.audioSend.find((e=>e.ssrc===(null==o?void 0:o.ssrcs[0].ssrcId)));if(i){if("opus"!==i.codec&&"aac"!==i.codec&&"PCMU"!==i.codec&&"PCMA"!==i.codec&&"G722"!==i.codec||(r.codecType=i.codec),i.inputLevel)r.sendVolumeLevel=Math.round(32767*i.inputLevel);else {const t=e.getLocalAudioVolume();t&&(r.sendVolumeLevel=Math.round(32767*t));}r.sendBytes=i.bytes,r.sendPackets=i.packets,r.sendPacketsLost=i.packetsLost,r.sendJitterMs=i.jitterMs,r.sendRttMs=i.rttMs,r.sendBitrate=t?8*Math.max(0,r.sendBytes-t.sendBytes):0;}}this.trafficStats&&(r.currentPacketLossRate=(this.trafficStats.B_palr4||0)/100),this.localStats.set(_I.LocalAudioTrack,r),r&&o&&this.exceptionMonitor.setLocalAudioStats(this.store.uid,o.track,r);break}}}));}updateRemoteStats(e){Array.from(this.remoteStats.entries()).forEach((t=>{let[i,{videoStats:n,audioStats:r,videoPcStats:s}]=t;const o=r,a=n,c=s,d=lD({},Ky),l=lD({},qy),h=lD({},Yy),{audioTrack:u,videoTrack:p,audioSSRC:_,videoSSRC:E}=e.getRemoteMedia(i),m=e.getStats(),f=null==m?void 0:m.audioRecv.find((e=>e.ssrc===_)),g=null==m?void 0:m.videoRecv.find((e=>e.ssrc===E)),T=this.trafficStats&&this.trafficStats.peer_delay.find((e=>e.peer_uid===i));if(f&&("opus"!==f.codec&&"aac"!==f.codec&&"PCMU"!==f.codec&&"PCMA"!==f.codec&&"G722"!==f.codec||(d.codecType=f.codec),f.outputLevel?d.receiveLevel=Math.round(32767*f.outputLevel):u&&(d.receiveLevel=Math.round(32767*u.getVolumeLevel())),d.receiveBytes=f.bytes,d.receivePackets=f.packets,d.receivePacketsLost=f.packetsLost,d.packetLossRate=d.receivePacketsLost/(d.receivePackets+d.receivePacketsLost),d.receiveBitrate=o?8*Math.max(0,d.receiveBytes-o.receiveBytes):0,d.totalDuration=o?o.totalDuration+1:1,d.totalFreezeTime=o?o.totalFreezeTime:0,d.freezeRate=d.totalFreezeTime/d.totalDuration,d.receiveDelay=f.jitterBufferMs,d.totalDuration>10&&hD.isRemoteAudioFreeze(u)&&(d.totalFreezeTime+=1)),g){"H264"!==g.codec&&"H265"!==g.codec&&"VP8"!==g.codec&&"VP9"!==g.codec&&"AV1X"!==g.codec&&"AV1"!==g.codec||(l.codecType=g.codec),l.receiveBytes=g.bytes,l.receiveBitrate=a?8*Math.max(0,l.receiveBytes-a.receiveBytes):0,l.decodeFrameRate=g.decodeFrameRate<0?0:g.decodeFrameRate,l.renderFrameRate=g.decodeFrameRate<0?0:g.decodeFrameRate,g.outputFrame&&(l.renderFrameRate=g.outputFrame.frameRate),g.receivedFrame?(l.receiveFrameRate=g.receivedFrame.frameRate,l.receiveResolutionHeight=g.receivedFrame.height,l.receiveResolutionWidth=g.receivedFrame.width):p&&(l.receiveResolutionHeight=p._videoHeight||0,l.receiveResolutionWidth=p._videoWidth||0),void 0!==g.framesRateFirefox&&(l.receiveFrameRate=Math.round(g.framesRateFirefox)),l.receivePackets=g.packets,l.receivePacketsLost=g.packetsLost,l.packetLossRate=l.receivePacketsLost/(l.receivePackets+l.receivePacketsLost),l.totalDuration=a?a.totalDuration+1:1,l.totalFreezeTime=a?a.totalFreezeTime:0,l.receiveDelay=g.jitterBufferMs||0;const t=!!E&&e.getRemoteVideoIsReady(E);p&&t&&hD.isRemoteVideoFreeze(p,g,c)&&(l.totalFreezeTime+=1),l.freezeRate=l.totalFreezeTime/l.totalDuration;}T&&(d.end2EndDelay=T.B_ad,l.end2EndDelay=T.B_vd,d.transportDelay=T.B_ed,l.transportDelay=T.B_ed,d.currentPacketLossRate=T.B_ealr4/100,l.currentPacketLossRate=T.B_evlr4/100,h.uplinkNetworkQuality=T.B_punq?T.B_punq:0,h.downlinkNetworkQuality=T.B_pdnq?T.B_pdnq:0),this.remoteStats.set(i,{audioStats:d,videoStats:l,videoPcStats:g,networkStats:h}),u&&this.exceptionMonitor.setRemoteAudioStats(u,d),p&&this.exceptionMonitor.setRemoteVideoStats(p,l);}));}}function uD(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n);}return i}function pD(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?uD(Object(i),!0).forEach((function(t){nu(e,t,i[t]);})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):uD(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t));}));}return e}function _D(e){return e.match(/^[\.\:\d]+$/)?"".concat(e.replace(/[^\d]/g,"-"),".").concat(kC("TURN_DOMAIN")):(KC.info("Cannot recognized as IP address ".concat(e,". Used As Host instead")),e)}function ED(e,t){var i,n;const r=kC("GATEWAY_DOMAINS");let s=r[1]&&-1!==t.indexOf(r[1])?1:0;e.addresses=e.addresses||[];const o=e.addresses.map((e=>e.domain_prefix?{address:"".concat(e.domain_prefix,".").concat(r[s++%r.length],":").concat(e.port)}:e.ip.match(/^[\.\:\d]+$/)?{ip:e.ip,port:e.port,address:"".concat(e.ip.replace(/[^\d]/g,"-"),".").concat(r[s++%r.length],":").concat(e.port)}:(KC.info("Cannot recognized as IP address ".concat(e.ip,". Used As Host instead")),{ip:e.ip,port:e.port,address:"".concat(e.ip,":").concat(e.port)})));if(null!==(i=e.detail)&&void 0!==i&&i[18]&&"string"==typeof(null===(n=e.detail)||void 0===n?void 0:n[18])){const t=e.detail[18],i=null==t?void 0:t.split(";");for(let e=0;e<i.length;e++){var a;const t=fy(a=i[e]).call(a);o[e]&&t&&(o[e].ip6=t);}}return {gatewayAddrs:o,uid:e.uid,cid:e.cid,cert:e.cert,vid:e.detail&&e.detail[8],uni_lbs_ip:e.detail&&e.detail[1],res:e,csIp:e.detail&&e.detail[502]}}function mD(e){return "number"==typeof e?e:e.exact||e.ideal||e.max||e.min||0}function fD(e){const t=e._encoderConfig;if(!t)return {};const i={resolution:t.width&&t.height?"".concat(mD(t.width),"x").concat(mD(t.height)):void 0,maxVideoBW:t.bitrateMax,minVideoBW:t.bitrateMin};return "number"==typeof t.frameRate?(i.maxFrameRate=t.frameRate,i.minFrameRate=t.frameRate):t.frameRate&&(i.maxFrameRate=t.frameRate.max||t.frameRate.ideal||t.frameRate.exact||t.frameRate.min,i.minFrameRate=t.frameRate.min||t.frameRate.ideal||t.frameRate.exact||t.frameRate.max),i}function gD(e){const t={connectionType:0,googRtt:e.rtt};switch(e.selectedCandidatePair.localCandidate.candidateType){case"relay":{const i=e.selectedCandidatePair.localCandidate.relayProtocol;"udp"===i&&(t.connectionType=1),"tcp"===i&&(t.connectionType=3),"tls"===i&&(t.connectionType=4);break}case"srflx":t.connectionType=2;}return t}function TD(e){return e>=0&&e<.17?1:e>=.17&&e<.36?2:e>=.36&&e<.59?3:e>=.59&&e<=1?4:e>1?5:0}function SD(e,t){let i,n,r;switch(t){case hy.CHOOSE_SERVER:n=4096,r="choose server";break;case hy.CLOUD_PROXY:n=1048576,r="proxy";break;case hy.CLOUD_PROXY_5:n=4194304,r="proxy5";break;case hy.CLOUD_PROXY_FALLBACK:n=4194310,r="proxy fallback";break;default:throw new xv(xg.UNEXPECTED_ERROR,"multi unlibs response transformer get unknown service id",{csIp:e.detail&&e.detail[502],retry:!1})}if(e.response_body.forEach((t=>{t.buffer&&t.buffer.flag===n&&(i={code:t.buffer.code,addresses:(t.buffer.edges_services||[]).map((e=>pD(pD({},e),{},{ticket:t.buffer.cert}))),server_ts:e.enter_ts,uid:t.buffer.uid,cid:t.buffer.cid,cname:t.buffer.cname,detail:pD(pD({},t.buffer.detail),e.detail),flag:t.buffer.flag,opid:e.opid,cert:t.buffer.cert});})),!i)throw new xv(xg.MULTI_UNILBS_RESPONSE_ERROR,"cannot parse response ".concat(r," from multi unilbs response"),{csIp:e.detail&&e.detail[502]});return i}async function RD(e,t){return await tg.all(e.addresses.map((async e=>({address:_D(e.ip),tcpport:e.port,udpport:e.port,username:t&&kC("ENCRYPT_PROXY_USERNAME_AND_PSW")&&window.isSecureContext?t.toString():ov.username,password:t&&kC("ENCRYPT_PROXY_USERNAME_AND_PSW")&&window.isSecureContext?await tT(t.toString()):ov.password}))))}function CD(e,t){const i=t._videoHeight||t.getMediaStreamTrack(!0).getSettings().height;return i?Math.max(i/mD(e.height),1):(KC.warning("can't get ori-track's height, default scale down 4 times for low stream"),4)}function vD(e){let{candidateType:t,relayProtocol:i,type:n,address:r,port:s,protocol:o}=e;return "local-candidate"===n?{candidateType:t,relayProtocol:i,protocol:o}:{candidateType:t,relayProtocol:i,address:r,port:s,protocol:o}}function ID(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n);}return i}class yD extends iT{get url(){return this._url?this._url:null}get reconnectMode(){return this._reconnectMode}set reconnectMode(e){var t;Pr(t=["tryNext","recover"]).call(t,e)&&this.resetReconnectCount(e),this._reconnectMode=e;}get state(){return this._state}set state(e){e!==this._state&&(this._state=e,"reconnecting"===this._state?this.emit(CI.RECONNECTING,this.reconnectReason):"connected"===this._state?this.emit(CI.CONNECTED):"closed"===this._state?this.emit(CI.CLOSED):"failed"===this._state&&this.emit(CI.FAILED));}constructor(e,t,i,n){super(),nu(this,"connectionID",0),nu(this,"currentURLIndex",0),nu(this,"reconnectReason",void 0),nu(this,"_reconnectMode","tryNext"),nu(this,"_name",void 0),nu(this,"_state","closed"),nu(this,"_retryConfig",void 0),nu(this,"_reconnectCount",0),nu(this,"_forceCloseTimeout",5e3),nu(this,"_onlineReconnectListener",void 0),nu(this,"_closeEstablishingTransmitter",(()=>{})),nu(this,"_store",void 0),nu(this,"_joinChannelServiceRecordIndex",void 0),nu(this,"_useCompress",void 0),nu(this,"_inflateLength",0),nu(this,"_deflateLength",0),this._store=n,this._name=e,this._retryConfig=function(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?ID(Object(i),!0).forEach((function(t){nu(e,t,i[t]);})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):ID(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t));}));}return e}({},t),this._useCompress=i;}resetReconnectCount(e){KC.debug("".concat(this._name," reset reconnect count, reason: ").concat(e)),this._reconnectCount=0;}close(e,t){if(this.currentURLIndex=0,this.resetReconnectCount("close"),this._reconnectInterrupter&&this._reconnectInterrupter(),this._transmitter){this._transmitter.onclose=null,this._transmitter.onopen=null,this._transmitter.onmessage=null;const e=this._transmitter;t?setTimeout((()=>e.close()),500):e.close(),this._transmitter=void 0;}this.state=e?"failed":"closed",this._closeEstablishingTransmitter&&this._closeEstablishingTransmitter();}reconnect(e,t){if(!this._transmitter)return void KC.warning("[".concat(this._name,"] can not reconnect, no websocket"));var i;(void 0!==e&&(this.reconnectMode=e),KC.debug("[".concat(this._name,"] reconnect is triggered initiative")),"number"==typeof this._joinChannelServiceRecordIndex)&&(null===(i=this._store)||void 0===i||i.recordJoinChannelService({status:"error",errors:[new Error(t)]},this._joinChannelServiceRecordIndex));const n=this._transmitter.onclose;this._transmitter.onclose=null,this._transmitter.close(),n&&n.bind(this._transmitter)({code:9999,reason:t});}getInflateData(){const e=this._inflateLength,t=this._deflateLength;return this.clearInflateData(),{inflateLength:e,deflateLength:t}}setInflateData(e){this._deflateLength=this._deflateLength+e.originLength,this._inflateLength=this._inflateLength+e.compressedLength;}clearInflateData(){this._inflateLength=0,this._deflateLength=0;}}var AD;!function(e){e[e.Default=0]="Default",e[e.Ack=1]="Ack";}(AD||(AD={}));class bD{constructor(e,t,i){nu(this,"version",1),nu(this,"initialRTO",void 0),nu(this,"maxBatchAckCount",void 0),nu(this,"maxRTO",void 0),nu(this,"initialRTT",void 0),nu(this,"ID",void 0),nu(this,"rtt",void 0),nu(this,"packetNumber",1),nu(this,"rtoRatioMap",new Map),nu(this,"timeoutMap",new Map),nu(this,"unorderedPacketQueue",[]),nu(this,"batchAckPacketQueue",[]),nu(this,"lastOrderedPacketNumber",0),nu(this,"batchAckTimer",void 0),nu(this,"sendImpl",void 0),nu(this,"receiveImpl",void 0),this.sendImpl=e,this.receiveImpl=t,this.ID=xT(7,"transmitter-"),this.initialRTO=void 0!==(null==i?void 0:i.initialRTO)?i.initialRTO:kC("TRANSMITTER_INITIAL_RTO"),this.initialRTT=void 0!==(null==i?void 0:i.initialRTT)?i.initialRTT:kC("TRANSMITTER_INITIAL_RTT"),this.rtt=void 0!==(null==i?void 0:i.initialRTT)?i.initialRTT:kC("TRANSMITTER_INITIAL_RTT"),this.maxBatchAckCount=void 0!==(null==i?void 0:i.maxBatchAckCount)?i.maxBatchAckCount:kC("TRANSMITTER_MAX_BATCH_ACK_COUNT"),this.maxRTO=void 0!==(null==i?void 0:i.maxRTO)?i.maxRTO:kC("TRANSMITTER_MAX_RTO");}packetize(e,t){return {type:AD.Default,version:this.version,packetNumber:t,payload:e}}serialize(e){switch(e.type){case AD.Default:{let t;if("string"==typeof e.payload){t=(new TextEncoder).encode(e.payload);}else t=e.payload;const i=new ArrayBuffer(t.length+15),n=new DataView(i);n.setUint16(0,e.version),n.setUint8(2,e.type),n.setUint32(3,e.packetNumber),Jg(n,7,BigInt(e.sendTs));return new Uint8Array(n.buffer).set(t,15),i}case AD.Ack:{const t=new ArrayBuffer(16),i=new DataView(t);return i.setUint16(0,e.version),i.setUint8(2,e.type),i.setUint32(3,e.maxAckPacketNumber),i.setUint8(7,e.shift),Jg(i,8,BigInt(e.ackSendTs)),t}}}deserialize(e){const t=new DataView(e),i=t.getUint16(0),n=t.getUint8(2);switch(n){case AD.Default:{const r=t.getUint32(3),s=qg(t,7),o=e.slice(15),a=(new TextDecoder).decode(o);return {version:i,type:n,packetNumber:r,sendTs:Number(s),payload:a}}case AD.Ack:{const e=t.getUint32(3),r=t.getUint8(7),s=qg(t,8);return {version:i,type:n,maxAckPacketNumber:e,shift:r,ackSendTs:Number(s)}}default:throw KC.error("[".concat(this.ID,"] Unrecognized packet type ").concat(n)),new Error("Unrecognized packet type ".concat(n))}}sendMessage(e){const t=this.packetize(e,this.packetNumber);this.packetNumber=4294967295===this.packetNumber?1:this.packetNumber+1;const i=this.calculateRTO(t),n=window.setTimeout((()=>{this.resendMessage(t);}),i);this.timeoutMap.set(t.packetNumber,n),this.sendPacket(t);}onData(e){const t=this.deserialize(e);t.type===AD.Default?this.ack(t):t.type===AD.Ack&&(this.updateRTT(t,Math.round(performance.now())),this.clearRTO(t));}close(){this.rtt=this.initialRTT,this.packetNumber=1,Array.from(this.timeoutMap.entries()).forEach((e=>{let[t,i]=e;window.clearTimeout(i);})),this.timeoutMap=new Map,this.rtoRatioMap=new Map,this.unorderedPacketQueue=[],this.batchAckPacketQueue=[],this.lastOrderedPacketNumber=0,void 0!==this.batchAckTimer&&window.clearTimeout(this.batchAckTimer);}resendMessage(e){const t=this.calculateRTO(e),i=window.setTimeout((()=>{this.resendMessage(e);}),t);this.timeoutMap.set(e.packetNumber,i),this.sendPacket(e);}calculateRTO(e){const t=this.rtoRatioMap.get(e.packetNumber);if(void 0===t)return this.rtoRatioMap.set(e.packetNumber,1),this.initialRTO;{const i=9*this.rtt/8*t;return this.rtoRatioMap.set(e.packetNumber,t+1),i>this.maxRTO?this.maxRTO:i}}updateRTT(e,t){const i=e.ackSendTs;this.rtt=this.rtt*(7/8)+(t-i-this.rtt)/8;}ack(e){if(e.packetNumber===this.lastOrderedPacketNumber+1)for(this.batchAckPacketQueue.length>=this.maxBatchAckCount&&this.batchAck(),this.batchAckTimer?this.batchAckPacketQueue.push(e):(this.batchAckPacketQueue.push(e),this.batchAckTimer=window.setTimeout((()=>{this.batchAck();}),this.rtt/8)),this.lastOrderedPacketNumber+=1,this.receiveImpl(e.payload);;){const e=this.unorderedPacketQueue[0];if(!e){this.unorderedPacketQueue.shift();break}this.batchAckTimer&&this.batchAck(),this.receiveImpl(e.payload),this.unorderedPacketQueue.shift(),this.lastOrderedPacketNumber+=1;}else if(e.packetNumber<=this.lastOrderedPacketNumber){const t={ackSendTs:e.sendTs,maxAckPacketNumber:e.packetNumber,shift:0,type:AD.Ack,version:this.version};this.sendPacket(t);}else if(e.packetNumber>this.lastOrderedPacketNumber){this.unorderedPacketQueue[e.packetNumber-this.lastOrderedPacketNumber-2]=e;const t={ackSendTs:e.sendTs,maxAckPacketNumber:e.packetNumber,shift:0,type:AD.Ack,version:this.version};this.sendPacket(t);}}batchAck(){window.clearTimeout(this.batchAckTimer),this.batchAckTimer=void 0;const e={ackSendTs:this.batchAckPacketQueue[this.batchAckPacketQueue.length-1].sendTs,maxAckPacketNumber:this.batchAckPacketQueue[this.batchAckPacketQueue.length-1].packetNumber,shift:this.batchAckPacketQueue.length-1,type:AD.Ack,version:this.version};this.sendPacket(e),this.batchAckPacketQueue=[];}sendPacket(e){e.type===AD.Default&&(e.sendTs=Math.round(performance.now()));const t=this.serialize(e);this.sendImpl(t);}clearRTO(e){for(let t=e.maxAckPacketNumber-e.shift;t<=e.maxAckPacketNumber;t++){const e=this.timeoutMap.get(t);void 0!==e&&window.clearTimeout(e),this.timeoutMap.delete(t),this.rtoRatioMap.delete(t);}}}class wD extends yD{constructor(e,t){super(e,t,arguments.length>2&&void 0!==arguments[2]&&arguments[2],arguments.length>3?arguments[3]:void 0),nu(this,"_initMutex",void 0),nu(this,"_reconnectInterrupter",void 0),nu(this,"_url",void 0),nu(this,"_transmitter",void 0),nu(this,"_addresses",void 0),nu(this,"_reliableTransmission",void 0),this._initMutex=new YT("datachannel");const{timeout:i,timeoutFactor:n}=t,r=Math.max(300,Math.floor(3*i/5)),s=Math.max(1.2,Math.floor(8*n)/10);hT.ONLINE&&(this._retryConfig.timeout=r,this._retryConfig.timeoutFactor=s),RT.on(uT.NETWORK_STATE_CHANGE,((e,t)=>{e!==t&&(this.resetReconnectCount("network state change: ".concat(t," -> ").concat(e)),e===hT.ONLINE?(this._retryConfig.timeout=r,this._retryConfig.timeoutFactor=s):(this._retryConfig.timeout=i,this._retryConfig.timeoutFactor=n));}));}getConnection(){if(this._reliableTransmission)return this._reliableTransmission}async init(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:5e3;this._forceCloseTimeout=t;const i=(t,i)=>{this._addresses=e,this.currentURLIndex=this._addresses.findIndex((e=>e.fingerprint||kC("FINGERPRINT")));const n=this._addresses[this.currentURLIndex];this.state="connecting",this.createTransmitterConnection(n).then(t).catch(i),this.once(CI.CLOSED,(()=>i(new xv(xg.WS_DISCONNECT)))),this.once(CI.CONNECTED,(()=>t()));};return this._initMutex.lock().then((e=>new tg(((e,t)=>{i(e,t);})).then((()=>{e();})).catch((()=>{e();}))))}sendMessage(e){let t=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(!this._transmitter||!this._reliableTransmission)throw new xv(xg.WS_ABORT,"datachannel is not ready");try{t||(e=JSON.stringify(e)),this._reliableTransmission.sendMessage(e);}catch(e){throw new xv(xg.WS_ERR,"send datachannel signal message error"+e.toString())}}unbindDcCloseEventListener(){this._transmitter&&(this._transmitter.onclose=null);}sendMessageWithJSON(e){const t=JSON.stringify(e);return {compressed:t,compressedLength:t.length,origin:e}}sendMessageWithUint8Array(e){return {compressed:e,compressedLength:e.byteLength,origin:e}}createTransmitterConnection(e){return this.connectionID+=1,this._joinChannelServiceRecordIndex=void 0,this._url="dc://".concat(e.ip,":").concat(e.port),new tg(((t,i)=>{var n;const r=()=>{KC.debug("[".concat(this._name,"] datachannel opened:"),this._url),this.reconnectMode="retry",this.state="connected",this.resetReconnectCount("opened"),t();},s=async e=>{var n;if(null===(n=this._closeEstablishingTransmitter)||void 0===n||n.call(this),KC.debug("[".concat(this._name,"] datachannel close ").concat(this._url,", code: ").concat(e.code,", reason: ").concat(e.reason,", current mode: ").concat(this.reconnectMode)),this._reconnectCount<this._retryConfig.maxRetryCount){"connected"===this.state&&(this.reconnectReason=e.reason,this.state="reconnecting");const n=TT(this,CI.WILL_RECONNECT,this.reconnectMode)||this.reconnectMode,r=await this.reconnectWithAction(n);if("closed"===this.state)return void KC.debug("[".concat(this.connectionID,"] dc is closed, no need to reconnect"));if(!r)return i(new xv(xg.WS_DISCONNECT,"datachannel reconnect failed: ".concat(e.code))),void this.close(!0);t();}else i(new xv(xg.WS_DISCONNECT,"datachannel close: ".concat(e.code))),this.close();},o=e=>{var t;null===(t=this._reliableTransmission)||void 0===t||t.onData(e.data);};this._transmitter&&(this._transmitter.onclose=null,this._transmitter.close()),this._reliableTransmission&&(this._reliableTransmission.close(),this._reliableTransmission=void 0),KC.debug("[".concat(this._name,"] start connect, address: ").concat(JSON.stringify(e)));const a=null===(n=this._store)||void 0===n?void 0:n.recordJoinChannelService({startTs:Date.now(),status:"pending",service:"gateway"}),c=Date.now();fT(this,CI.TO_CONNECT_DATACHANNEL,e).then((e=>{var t,i;if(!e)throw new Error("transmissonInfo not exist yet");const{transmitter:n,close:d}=e;this._transmitter=n,null===(t=this._store)||void 0===t||t.signalChannelOpen();const l=Date.now()-c;KC.debug("[choose dc] dc open cost ".concat(l,"ms"));this._reliableTransmission=new bD((e=>{var t;this._transmitter&&"open"===this._transmitter.readyState&&(null===(t=this._transmitter)||void 0===t||t.send(e));}),(e=>{"string"==typeof e&&this.emit(CI.ON_MESSAGE,e);})),this._closeEstablishingTransmitter=()=>{var e;null===(e=this._reliableTransmission)||void 0===e||e.close(),this._reliableTransmission=void 0,d();},r&&r(),n.onclose=s,n.onmessage=o,null===(i=this._store)||void 0===i||i.recordJoinChannelService({endTs:Date.now(),status:"success"},a),this._joinChannelServiceRecordIndex=a;})).catch((e=>{var t;if(null===(t=this._store)||void 0===t||t.recordJoinChannelService({endTs:Date.now(),status:e instanceof xv&&e.code===xg.WS_ABORT?"aborted":"error",errors:[e]},a),"closed"!==this.state){if(e instanceof xv&&e.code===xg.WS_ERR){const t=new xv(xg.WS_ERR,"init datachannel failed! Error: ".concat(e.toString()));return KC.error("[".concat(this._name,"]").concat(t)),void i(t)}s&&s(e);}else i(new xv(xg.WS_DISCONNECT,"datachannel is closed: ".concat(e.toString())));}));}))}async reconnectWithAction(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];if(this._reconnectCount>=this._retryConfig.maxRetryCount)return !1;if(!this._addresses)return !1;if("closed"===this.state)return !1;this._onlineReconnectListener||RT.networkState!==hT.OFFLINE||(this._onlineReconnectListener=RT.onlineWaiter&&RT.onlineWaiter.then((()=>{this._onlineReconnectListener=void 0;})));let i=!0;if(this._reconnectInterrupter=()=>{i=!1;},t){const t=zT(this._reconnectCount,this._retryConfig);KC.debug("[".concat(this._name,"] wait ").concat(t,"ms to reconnect datachannel, mode: ").concat(e)),await tg.race([UT(t),this._onlineReconnectListener||new tg((()=>{}))]);}if("closed"===this.state||!i)return !1;this._reconnectCount+=1;const n=async(e,t)=>{this.emit(CI.RECONNECT_CREATE_CONNECTION,t),await this.createTransmitterConnection(e);};try{if("retry"===e){const t=this._addresses[this.currentURLIndex];this.emit(CI.RECONNECT_WAITTING_FINISH,e),await n(t,e);}else if("tryNext"===e){this.currentURLIndex+=1;for(let e=this.currentURLIndex;e<this._addresses.length;e++){if(this._addresses[e].fingerprint||kC("FINGERPRINT")){this.currentURLIndex=e;break}this.currentURLIndex+=1;}if(this.currentURLIndex>=this._addresses.length)return KC.debug("[".concat(this._name,"] the available addresses are exhausted, change to recover")),await this.reconnectWithAction("recover",!1);KC.debug("[".concat(this._name,"] datachannel url length: ").concat(this._addresses.length," current index: ").concat(this.currentURLIndex));const t=this._addresses[this.currentURLIndex];this.emit(CI.RECONNECT_WAITTING_FINISH,e),await n(t,e);}else "recover"===e&&(KC.debug("[".concat(this._name,"] start to failback to websocket")),this.resetReconnectCount("recover mode"),this.emit(CI.RECONNECT_WAITTING_FINISH,e),this.emit(CI.FAILBACK));return !0}catch(i){var r,s;return KC.error("[".concat(this._name,"] reconnect failed"),i.toString()),null!=i&&null!==(r=i.data)&&void 0!==r&&r.desc&&Array.isArray(i.data.desc)&&i.data.desc.length&&Pr(s=i.data.desc).call(s,"dynamic key expired")?(this.emit(CI.ON_TOKEN_PRIVILEGE_DID_EXPIRE),!1):await this.reconnectWithAction(e,t)}}}class OD extends iT{get connectionState(){return this._connectionState}set connectionState(e){e!==this._connectionState&&(this._connectionState=e,e===fv.CONNECTED?this.emit(gv.WS_CONNECTED):e===fv.RECONNECTING?this.emit(gv.WS_RECONNECTING,this._websocketReconnectReason):e===fv.CLOSED&&this.emit(gv.WS_CLOSED,this._disconnectedReason));}get currentURLIndex(){return this.websocket.currentURLIndex}get url(){return this.websocket?this.websocket.url:null}get rtt(){return this.rttRolling.mean()}constructor(e,t){super(),nu(this,"_disconnectedReason",void 0),nu(this,"_websocketReconnectReason",void 0),nu(this,"_connectionState",fv.CLOSED),nu(this,"reconnectToken",void 0),nu(this,"websocket",void 0),nu(this,"openConnectionTime",void 0),nu(this,"clientId",void 0),nu(this,"lastMsgTime",Date.now()),nu(this,"uploadCache",[]),nu(this,"uploadCacheInterval",void 0),nu(this,"rttRolling",new dS(5)),nu(this,"pingpongTimer",void 0),nu(this,"inflateDataTimer",void 0),nu(this,"pingpongTimeoutCount",0),nu(this,"joinResponse",void 0),nu(this,"multiIpOption",void 0),nu(this,"initError",void 0),nu(this,"spec",void 0),nu(this,"store",void 0),nu(this,"onWebsocketMessage",(e=>{if(e instanceof ArrayBuffer)return void this.emit(gv.ON_BINARY_DATA,e);const t=JSON.parse(e);if(this.lastMsgTime=Date.now(),Object.prototype.hasOwnProperty.call(t,"_id")){const e="res-@".concat(t._id);this.emit(e,t._result,t._message);}else if(Object.prototype.hasOwnProperty.call(t,"_type")&&(this.emit(t._type,t._message),t._type===Rv.ON_NOTIFICATION&&this.handleNotification(t._message),t._type===Rv.ON_USER_BANNED))switch(t._message.error_code){case 14:this.close(cT.UID_BANNED);break;case 15:this.close(cT.IP_BANNED);break;case 16:this.close(cT.CHANNEL_BANNED);}})),this.clientId=e.clientId,this.spec=e,this.store=t,this.websocket=new wD("gateway-".concat(this.clientId),this.spec.retryConfig,!0,t),this.handleWebsocketEvents(),window.addEventListener("offline",(()=>{this.connectionState===fv.CONNECTED&&this.reconnect("retry",RI.OFFLINE);}));}async request(e,t,i,n){const r=xT(6,""),s={_id:r,_type:e,_message:t},o=this.websocket.connectionID,a=()=>new tg(((t,i)=>{if(this.connectionState===fv.CONNECTED)return t();const n=()=>{this.off(gv.WS_CLOSED,r),t();},r=()=>{this.off(gv.WS_CONNECTED,n),i(new xv(xg.WS_ABORT));};this.once(gv.WS_CONNECTED,n),this.once(gv.WS_CLOSED,r),e!==Tv.PUBLISH&&e!==Tv.SUBSCRIBE&&e!==Tv.UNSUBSCRIBE&&e!==Tv.UNPUBLISH&&e!==Tv.CONTROL&&e!==Tv.RESTART_ICE||this.once(gv.DISCONNECT_P2P,(()=>{i(new xv(xg.DISCONNECT_P2P));})),e!==Tv.PUBLISH&&e!==Tv.RESTART_ICE||this.once(gv.ABORT_P2P_EXECUTION,(()=>{i(new xv(xg.DISCONNECT_P2P));}));}));if(this.connectionState!==fv.CONNECTING&&this.connectionState!==fv.RECONNECTING||e===Tv.JOIN||e===Tv.REJOIN||await a(),e===Tv.LEAVE&&(this.websocket.unbindDcCloseEventListener(),n=!0),this.websocket.sendMessage(s,!0,!1),n)return;const c=new tg(((i,n)=>{let s=!1;const a=(n,r)=>{s=!0,i({isSuccess:"success"===n,message:r||{}}),this.off(gv.WS_CLOSED,c),this.off(gv.WS_RECONNECTING,c),this.emit(gv.REQUEST_SUCCESS,e,t);};this.once("res-@".concat(r),a);const c=()=>{n(new xv(xg.WS_ABORT,"type: ".concat(e))),this.off(gv.WS_CLOSED,c),this.off(gv.WS_RECONNECTING,c),this.off("res-@".concat(r),a);};this.once(gv.WS_CLOSED,c),this.once(gv.WS_RECONNECTING,c),UT(kC("SIGNAL_REQUEST_TIMEOUT")).then((()=>{this.websocket.connectionID!==o||s||(KC.warning("dc request timeout, type: ".concat(e)),this.emit(gv.REQUEST_TIMEOUT,e,t));}));}));let d=null;try{d=await c;}catch(n){if(this.connectionState===fv.CLOSED||e===Tv.LEAVE)throw new xv(xg.WS_ABORT);return !this.spec.forceWaitGatewayResponse||i?n.throw():e===Tv.JOIN||e===Tv.REJOIN?null:(await a(),await this.request(e,t))}if(d.isSuccess)return d.message;const l=Number(d.message.error_code||d.message.code),h=UI(l),u=new xv(xg.UNEXPECTED_RESPONSE,"".concat(h.desc,": ").concat(d.message.error_str),{code:l,data:d.message});return "success"===h.action?d.message:(KC.warning("[".concat(this.websocket.connectionID,"] unexpected response from type ").concat(e,", error_code: ").concat(l,", message: ").concat(h.desc,", action: ").concat(h.action)),l===mv.ERR_TOO_MANY_BROADCASTERS?e===Tv.JOIN||e===Tv.REJOIN?(this.initError=u,this.close(),u.throw()):u.throw():"failed"===h.action?u.throw():"quit"===h.action?(this.initError=u,this.close(),u.throw()):(l===mv.ERR_JOIN_BY_MULTI_IP?(this.multiIpOption=d.message.option,KC.warning("[".concat(this.clientId,"] detect multi ip, recover")),this.reconnect("recover",RI.MULTI_IP)):this.reconnect(h.action,RI.SERVER_ERROR),e===Tv.JOIN||e===Tv.REJOIN?null:await this.request(e,t)))}waitMessage(e,t){return new tg((i=>{const n=r=>{(!t||t(r))&&(this.off(e,n),i(r));};this.on(e,n);}))}upload(e,t){const i={_type:e,_message:t};try{this.websocket.sendMessage(i);}catch(e){const t=kC("MAX_UPLOAD_CACHE")||50;this.uploadCache.push(i),this.uploadCache.length>t&&this.uploadCache.splice(0,1),this.uploadCache.length>0&&!this.uploadCacheInterval&&(this.uploadCacheInterval=window.setInterval((()=>{if(this.connectionState!==fv.CONNECTED)return;const e=this.uploadCache.splice(0,1)[0];0===this.uploadCache.length&&(window.clearInterval(this.uploadCacheInterval),this.uploadCacheInterval=void 0),this.upload(e._type,e._message);}),kC("UPLOAD_CACHE_INTERVAL")||2e3));}}send(e,t){const i={_type:e,_message:t};this.websocket.sendMessage(i);}init(e,t){return this.initError=void 0,this.multiIpOption=void 0,this.joinResponse=void 0,this.reconnectToken=void 0,this.openConnectionTime=void 0,new tg(((i,n)=>{this.once(gv.WS_CONNECTED,(()=>i(this.joinResponse))),this.once(gv.WS_CLOSED,(()=>n(this.initError||new xv(xg.WS_ABORT)))),this.connectionState=fv.CONNECTING,this.websocket.init(e).catch(n),this.websocket.once(CI.FAILBACK,(()=>{void 0===this.openConnectionTime&&n(new xv(xg.INIT_DATACHANNEL_TIMEOUT));})),this.inflateDataTimer&&window.clearInterval(this.inflateDataTimer),this.inflateDataTimer=window.setInterval((()=>{this.handleInflateData();}),2e4),setTimeout((()=>{t&&void 0===this.openConnectionTime&&(KC.debug("[".concat(this.clientId,"] init datachannel timeout while join with failback to websocket")),n(new xv(xg.INIT_DATACHANNEL_TIMEOUT)));}),kC("DC_JOIN_WITH_FAILBACK"));}))}close(e){this.pingpongTimer&&(this.pingpongTimeoutCount=0,window.clearInterval(this.pingpongTimer),this.pingpongTimer=void 0),this.inflateDataTimer&&(this.handleInflateData(),window.clearInterval(this.inflateDataTimer),this.inflateDataTimer=void 0),this.reconnectToken=void 0,this.joinResponse=void 0,this._disconnectedReason=e||cT.LEAVE,this.connectionState=fv.CLOSED,KC.debug("[".concat(this.clientId,"] ")+"will close datachannel in signal"),this.websocket.close(),e===cT.FALLBACK&&(this.websocket.removeAllListeners(),this.websocket=new wD("gateway-".concat(this.clientId),this.spec.retryConfig,!0,this.store),this.handleWebsocketEvents());}async join(){if(!this.joinResponse){this.emit(gv.ABORT_P2P_EXECUTION);const e=await fT(this,gv.DATACHANNEL_CONNECTING),t=await this.request(Tv.JOIN,e);if(!t)return this.emit(gv.REPORT_JOIN_GATEWAY,xg.TIMEOUT,this.url||""),!1;this.joinResponse=t,this.emit(gv.JOIN_RESPONSE,this.joinResponse),this.reconnectToken=this.joinResponse.rejoin_token;}return this.connectionState=fv.CONNECTED,this.pingpongTimer&&window.clearInterval(this.pingpongTimer),this.pingpongTimer=window.setInterval(this.handlePingPong.bind(this),3e3),!0}async rejoin(){if(!this.reconnectToken)throw new xv(xg.UNEXPECTED_ERROR,"can not rejoin, no rejoin token");const e=ST(this,gv.REQUEST_REJOIN_INFO);e.token=this.reconnectToken;const t=await this.request(Tv.REJOIN,e);return !!t&&(this.connectionState=fv.CONNECTED,this.pingpongTimer&&window.clearInterval(this.pingpongTimer),this.pingpongTimer=window.setInterval(this.handlePingPong.bind(this),3e3),t.peers&&t.peers.forEach((e=>{this.emit(Rv.ON_USER_ONLINE,{uid:e.uid}),e.audio&&this.emit(Rv.ON_ADD_AUDIO_STREAM,{uid:e.uid,uint_id:e.uint_id,audio:!0,ssrcId:e.audio_ssrc}),e.video&&this.emit(Rv.ON_ADD_VIDEO_STREAM,{uid:e.uid,uint_id:e.uint_id,video:!0,ssrcId:e.video_ssrc}),e.audio_mute?this.emit(Rv.MUTE_AUDIO,{uid:e.uid}):this.emit(Rv.UNMUTE_AUDIO,{uid:e.uid}),e.video_mute?this.emit(Rv.MUTE_VIDEO,{uid:e.uid}):this.emit(Rv.UNMUTE_VIDEO,{uid:e.uid}),e.audio_enable_local?this.emit(Rv.ENABLE_LOCAL_AUDIO,{uid:e.uid}):this.emit(Rv.DISABLE_LOCAL_AUDIO,{uid:e.uid}),e.video_enable_local?this.emit(Rv.ENABLE_LOCAL_VIDEO,{uid:e.uid}):this.emit(Rv.DISABLE_LOCAL_VIDEO,{uid:e.uid}),e.audio||e.video||this.emit(Rv.ON_REMOVE_STREAM,{uid:e.uid,uint_id:e.uint_id});})),!0)}reconnect(e,t){this.pingpongTimer&&(this.pingpongTimeoutCount=0,window.clearInterval(this.pingpongTimer),this.pingpongTimer=void 0),this.websocket.reconnect(e,t);}handleNotification(e){KC.debug("[".concat(this.clientId,"] receive notification: "),e);const t=UI(e.code);if("success"!==t.action){if("failed"!==t.action)return "quit"===t.action?("ERR_REPEAT_JOIN_CHANNEL"===t.desc&&this.close(cT.UID_BANNED),void this.close()):void this.reconnect(t.action,RI.SERVER_ERROR);KC.error("[".concat(this.clientId,"] ignore error: "),t.desc);}}handlePingPong(){if(!this.websocket||"connected"!==this.websocket.state)return;this.pingpongTimeoutCount>0&&this.rttRolling.add(3e3),this.pingpongTimeoutCount+=1;const e=kC("PING_PONG_TIME_OUT"),t=Date.now();this.pingpongTimeoutCount>=e&&(KC.warning("PINGPONG Timeout. Last Socket Message: ".concat(t-this.lastMsgTime,"ms")),t-this.lastMsgTime>kC("WEBSOCKET_TIMEOUT_MIN"))?this.reconnect("retry",RI.TIMEOUT):this.request(Tv.PING,void 0,!0).then((()=>{this.pingpongTimeoutCount=0;const e=Date.now()-t;this.rttRolling.add(e),kC("REPORT_STATS")&&this.send(Tv.PING_BACK,{pingpongElapse:e});})).catch((e=>{}));}handleInflateData(){const{inflateLength:e,deflateLength:t}=this.websocket.getInflateData();0!==e&&0!==t&&this.upload(Sv.WS_INFLATE_DATA_LENGTH,{ws_deflate_length:t,ws_inflate_length:e});}handleWebsocketEvents(){this.websocket.on(CI.RECONNECT_WAITTING_FINISH,(e=>{this.emit(gv.WS_RECONNECT_WAITTING_FINISH,e);})),this.websocket.on(CI.RECONNECT_CREATE_CONNECTION,(e=>{this.emit(gv.WS_RECONNECT_CREATE_CONNECTION,e);})),this.websocket.on(CI.ON_MESSAGE,this.onWebsocketMessage),this.websocket.on(CI.CLOSED,(()=>{this.connectionState=fv.CLOSED;})),this.websocket.on(CI.FAILED,(()=>{this._disconnectedReason=cT.NETWORK_ERROR,this.connectionState=fv.CLOSED;})),this.websocket.on(CI.RECONNECTING,(e=>{this._websocketReconnectReason=e,this.joinResponse=void 0,this.connectionState===fv.CONNECTED?this.connectionState=fv.RECONNECTING:this.connectionState=fv.CONNECTING;})),this.websocket.on(CI.WILL_RECONNECT,((e,t)=>{if(ST(this,gv.IS_P2P_DISCONNECTED)&&"retry"===e)return KC.debug("".concat(this.clientId," reconnect mode is retry, but p2p lost, change to tryNext")),this.reconnectToken=void 0,this.emit(gv.NEED_RENEW_SESSION),this.emit(gv.DISCONNECT_P2P),t("tryNext");"retry"!==e&&(KC.debug("".concat(this.clientId," websockt will_connect event, renewSession reconnectMode is ").concat(e)),this.reconnectToken=void 0,this.emit(gv.NEED_RENEW_SESSION),this.emit(gv.DISCONNECT_P2P)),t(e);})),this.websocket.on(CI.CONNECTED,(()=>{this.openConnectionTime=Date.now(),this.reconnectToken?this.rejoin().catch((e=>{KC.warning("[".concat(this.clientId,"] rejoin failed ").concat(e)),this.reconnect("tryNext",RI.SERVER_ERROR);})):this.join().catch((e=>{if(this.emit(gv.REPORT_JOIN_GATEWAY,e.message||e.code,this.url||""),e instanceof xv&&e.code===xg.UNEXPECTED_RESPONSE&&e.data.code===mv.ERR_NO_AUTHORIZED)return KC.warning("[".concat(this.clientId,"] reconnect no authorized, recover")),void this.reconnect("recover",RI.SERVER_ERROR);KC.error("[".concat(this.clientId,"] join gateway request failed"),e.toString()),this.spec.forceWaitGatewayResponse?this.reconnect("tryNext",RI.SERVER_ERROR):(this.initError=e,this.close());}));})),this.websocket.on(CI.REQUEST_NEW_URLS,((e,t)=>{fT(this,gv.REQUEST_RECOVER,this.multiIpOption).then(e).catch(t);})),this.websocket.on(CI.ON_TOKEN_PRIVILEGE_DID_EXPIRE,(()=>{this.emit(Rv.ON_TOKEN_PRIVILEGE_DID_EXPIRE);})),this.websocket.on(CI.TO_CONNECT_DATACHANNEL,(async(e,t,i)=>fT(this,gv.DATACHANNEL_PRECONNECT,e).then(t).catch(i))),this.websocket.on(CI.FAILBACK,(()=>{void 0!==this.openConnectionTime&&this.emit(gv.DATACHANNEL_FAILBACK);}));}}class ND extends iT{constructor(e){super(),nu(this,"_signal",void 0),nu(this,"_sequence",0),nu(this,"_userMap",new Map),nu(this,"_encoder",new TextEncoder),this._signal=e;}async send(e,t,i,n,r){var s,o,a;"string"!=typeof t&&(t=JSON.stringify(t)),n=null!==(s=n)&&void 0!==s?s:xT(6,""),r=null!==(o=r)&&void 0!==o?o:this._sequence++;const c={_id:n,_type:e,_seq:null!==(a=r)&&void 0!==a?a:this._sequence++,_message:t};if(kC("SHOW_P2P_LOG")&&KC.debug("send message",c),this.sendStreamMessage(JSON.stringify(c)),i)return;const d=new tg(((t,i)=>{const r=window.setTimeout((()=>{this.off("res-@".concat(n),s),KC.warning("[external-signal] request timeout, type: ".concat(e)),0===this._userMap.size?i(new Vg(xg.INVALID_REMOTE_USER)):i(new Vg(xg.TIMEOUT));}),kC("EXTERNAL_SIGNAL_REQUEST_TIMEOUT")),s=(e,n)=>{r&&window.clearTimeout(r),"success"===e?t({isSuccess:!0,message:n}):i(new Vg(xg.UNEXPECTED_ERROR,n));};this.once("res-@".concat(n),s);}));let l;try{l=await d;}catch(i){if(i.code===xg.TIMEOUT)return await this.send(e,t,!1,n,r);throw i}return l.isSuccess?l.message:void 0}sendStreamMessage(e){this._splitMessage(e).forEach((e=>{this._signal.request(Tv.DATA_STREAM,{payload:PT(this._encoder.encode(e))});}));}onMessage(e){const{_uid:t}=e;let i;const n=this._userMap.get(t);if(n?i=n.splitMessageMap:(i=new Map,this._userMap.set(t,{isStart:!1,splitMessageMap:i,nextExpectedSequenceNumber:0,receivedMessagesMap:new Map})),"id"in e&&"total"in e){var r;const{id:n,total:s}=e,o=null!==(r=i.get(n))&&void 0!==r?r:[];if(o.push(e),i.has(n)||i.set(n,o),o.length!==s)return;{const r=Zu(o).call(o,((e,t)=>e.index-t.index)).map((e=>e.payload)).join("");i.delete(n),(e=JSON.parse(r))._uid=t;}}this.handleReceivedMessage(e);}setStart(e){this._userMap.has(e)?this._userMap.get(e).isStart=!0:this._userMap.set(e,{isStart:!0,splitMessageMap:new Map,nextExpectedSequenceNumber:0,receivedMessagesMap:new Map}),this.handleReceivedMessage();}setEnd(e){return this._userMap.delete(e),0===this._userMap.size}ack(e,t,i){this.send(wI.ACK,JSON.stringify({success:!i,message:t}),!0,e);}handleReceivedMessage(e){const t=()=>{this._userMap.forEach((e=>{const{receivedMessagesMap:t,nextExpectedSequenceNumber:i}=e;for(;t.has(i);){const n=t.get(i);t.delete(i),this.receiveMessage(n),e.nextExpectedSequenceNumber++;}}));};if(!e)return void t();const{_uid:i,_seq:n}=e,r=this._userMap.get(i),{receivedMessagesMap:s,isStart:o,nextExpectedSequenceNumber:a}=r;n<a?KC.debug("[external-signal] receive old message, seq: ".concat(n)):(s.set(n,e),o&&n===a&&(this.receiveMessage(e),s.delete(a),r.nextExpectedSequenceNumber++,t()));}receiveMessage(e){const{_id:t,_type:i,_message:n,_uid:r}=e;if(kC("SHOW_P2P_LOG")&&KC.debug("收到消息",e),t)switch(e._type){case wI.PUBLISH:const s=JSON.parse(n);this._signal.emit(i,s,r),this.ack(e._id);break;case wI.CONTROL:case wI.UNPUBLISH:case wI.DO_SUBSCRIBE:case wI.DO_UNSUBSCRIBE:{const t=JSON.parse(n);t.uid=r,fT(this._signal,i,t).then((t=>{this.ack(e._id,t);})).catch((t=>{this.ack(e._id,void 0,!0);}));break}case wI.ACK:{const{success:e,message:i}=JSON.parse(n);this.emit("res-@".concat(t),e?"success":"failed",i);break}case wI.CALL:fT(this,i,n).then((e=>{this.ack(t,e);}));break;case wI.RESTART_ICE:case wI.EXCHANGE_SDP:case wI.SUBSCRIBE:case wI.UNSUBSCRIBE:fT(this._signal,i,n).then((e=>{this.ack(t,e);})).catch((t=>{this.ack(e._id,void 0,!0);}));break;case wI.CANDIDATE:this._signal.emit(i,n),this.ack(t);break;case wI.JOIN:this.emit(i,JSON.parse(n));break;default:this.emit(i,n),this.ack(t);}}_splitMessage(e){if(e.length<ND.MAX_MESSAGE_SIZE)return [e];const t=[],i=xT(6,"");let n=0;const r=Math.ceil(e.length/800);for(;e.length>0;){n++;const s=e.slice(0,800);t.push({id:i,index:n,total:r,payload:s}),e=e.slice(800);}return t.map((e=>JSON.stringify(e)))}clear(){this._sequence=0,this._userMap.clear();}}nu(ND,"MAX_MESSAGE_SIZE",1024);class DD extends iT{get connectionState(){return this._connectionState}set connectionState(e){e!==this._connectionState&&(this._connectionState=e,e===fv.CONNECTED?this.emit(gv.WS_CONNECTED):e===fv.RECONNECTING?this.emit(gv.WS_RECONNECTING,this._websocketReconnectReason):e===fv.CLOSED&&this.emit(gv.WS_CLOSED,this._disconnectedReason));}get currentURLIndex(){return this.websocket.currentURLIndex}get url(){return this.websocket&&this.websocket.url||null}get rtt(){return this.rttRolling.mean()}constructor(e,t){super(),nu(this,"_disconnectedReason",void 0),nu(this,"_websocketReconnectReason",void 0),nu(this,"_connectionState",fv.CLOSED),nu(this,"reconnectToken",void 0),nu(this,"_userInRoom",!1),nu(this,"_userOnlineTime",void 0),nu(this,"websocket",void 0),nu(this,"openConnectionTime",void 0),nu(this,"clientId",void 0),nu(this,"lastMsgTime",Date.now()),nu(this,"uploadCache",[]),nu(this,"uploadCacheInterval",void 0),nu(this,"rttRolling",new dS(5)),nu(this,"pingpongTimer",void 0),nu(this,"wsInflateDataTimer",void 0),nu(this,"pingpongTimeoutCount",0),nu(this,"joinResponse",void 0),nu(this,"multiIpOption",void 0),nu(this,"initError",void 0),nu(this,"spec",void 0),nu(this,"store",void 0),nu(this,"_external_signal",void 0),nu(this,"onWebsocketMessage",(e=>{if(e.data instanceof ArrayBuffer)return void this.emit(gv.ON_BINARY_DATA,e.data);const t=JSON.parse(e.data);if(this.lastMsgTime=Date.now(),Object.prototype.hasOwnProperty.call(t,"_id")){const e="res-@".concat(t._id);this.emit(e,t._result,t._message);}else if(Object.prototype.hasOwnProperty.call(t,"_type")){switch(t._type){case Rv.ON_DATA_STREAM:return void this.handleDataStream(t._message);case Rv.MUTE_AUDIO:case Rv.MUTE_VIDEO:case Rv.ON_P2P_LOST:return;case Rv.ON_USER_ONLINE:this.emit(t._type,t._message);const{uid:e}=t._message;return this._external_signal.setStart(e),void this._external_signal.send(wI.JOIN,{onlineTime:this._userOnlineTime},!0)}if(this.emit(t._type,t._message),t._type===Rv.ON_NOTIFICATION&&this.handleNotification(t._message),t._type===Rv.ON_USER_BANNED)switch(t._message.error_code){case 14:this.close(cT.UID_BANNED);break;case 15:this.close(cT.IP_BANNED);break;case 16:this.close(cT.CHANNEL_BANNED);}if(t._type===Rv.ON_USER_LICENSE_BANNED)switch(t._message.error_code){case mv.ERR_LICENSE_MISSING:this.close(cT.LICENSE_MISSING);break;case mv.ERR_LICENSE_EXPIRED:this.close(cT.LICENSE_EXPIRED);break;case mv.ERR_LICENSE_MINUTES_EXCEEDED:this.close(cT.LICENSE_MINUTES_EXCEEDED);break;case mv.ERR_LICENSE_PERIOD_INVALID:this.close(cT.LICENSE_PERIOD_INVALID);break;case mv.ERR_LICENSE_MULTIPLE_SDK_SERVICE:this.close(cT.LICENSE_MULTIPLE_SDK_SERVICE);break;case mv.ERR_LICENSE_ILLEGAL:this.close(cT.LICENSE_ILLEGAL);break;default:this.close();}}})),this.clientId=e.clientId,this.spec=e,this.store=t,this.websocket=new zI("gateway-".concat(this.clientId),this.spec.retryConfig,!0,kC("JOIN_GATEWAY_USE_DUAL_DOMAIN"),kC("JOIN_GATEWAY_USE_443PORT_ONLY"),t),this.handleWebsocketEvents(),window.addEventListener("offline",(()=>{this.connectionState===fv.CONNECTED&&this.reconnect("retry",lT.OFFLINE);})),this._external_signal=new ND(this),this._handleSignalP2PEvents();}async request(e,t,i,n){const r=xT(6,""),s={_id:r,_type:e,_message:t},o=this.websocket.connectionID,a=()=>new tg(((t,i)=>{if(this.connectionState===fv.CONNECTED)return t();const n=()=>{this.off(gv.WS_CLOSED,r),t();},r=()=>{this.off(gv.WS_CONNECTED,n),i(new Vg(xg.WS_ABORT));};this.once(gv.WS_CONNECTED,n),this.once(gv.WS_CLOSED,r),e!==Tv.PUBLISH&&e!==Tv.SUBSCRIBE&&e!==Tv.UNSUBSCRIBE&&e!==Tv.UNPUBLISH&&e!==Tv.CONTROL&&e!==Tv.RESTART_ICE||this.once(gv.DISCONNECT_P2P,(()=>{i(new Vg(xg.DISCONNECT_P2P));})),e!==Tv.PUBLISH&&e!==Tv.RESTART_ICE||this.once(gv.ABORT_P2P_EXECUTION,(()=>{i(new Vg(xg.DISCONNECT_P2P));}));}));if(this.connectionState!==fv.CONNECTING&&this.connectionState!==fv.RECONNECTING||e===Tv.JOIN||e===Tv.REJOIN||await a(),this.websocket.sendMessage(s,!0),n)return;const c=new tg(((i,n)=>{let s=!1;const a=(n,r)=>{s=!0,i({isSuccess:"success"===n,message:r||{}}),this.off(gv.WS_CLOSED,c),this.off(gv.WS_RECONNECTING,c),this.emit(gv.REQUEST_SUCCESS,e,t);};this.once("res-@".concat(r),a);const c=()=>{n(new Vg(xg.WS_ABORT,"type: ".concat(e))),this.off(gv.WS_CLOSED,c),this.off(gv.WS_RECONNECTING,c),this.off("res-@".concat(r),a);};this.once(gv.WS_CLOSED,c),this.once(gv.WS_RECONNECTING,c),UT(kC("SIGNAL_REQUEST_TIMEOUT")).then((()=>{this.websocket.connectionID!==o||s||(KC.warning("[".concat(this.clientId,"] ws request timeout, type: ").concat(e)),this.emit(gv.REQUEST_TIMEOUT,e,t));}));}));let d=null;try{d=await c;}catch(n){if(this.connectionState===fv.CLOSED||e===Tv.LEAVE)throw new Vg(xg.WS_ABORT);return !this.spec.forceWaitGatewayResponse||i?n.throw():e===Tv.JOIN||e===Tv.REJOIN?null:(await a(),await this.request(e,t))}if(d.isSuccess)return d.message;const l=Number(d.message.error_code||d.message.code),h=UI(l),u=new Vg(xg.UNEXPECTED_RESPONSE,"".concat(h.desc,": ").concat(d.message.error_str),{code:l,data:d.message});return "success"===h.action?d.message:(KC.warning("[".concat(this.clientId,"] [").concat(this.websocket.connectionID,"] unexpected response from type ").concat(e,", error_code: ").concat(l,", message: ").concat(h.desc,", action: ").concat(h.action)),l===mv.ERR_TOO_MANY_BROADCASTERS?e===Tv.JOIN||e===Tv.REJOIN?(this.initError=u,this.close(),u.throw()):u.throw():"failed"===h.action?u.throw():"quit"===h.action?(this.initError=u,this.close(),u.throw()):(l===mv.ERR_JOIN_BY_MULTI_IP?(this.multiIpOption=d.message.option,KC.warning("[".concat(this.clientId,"] detect multi ip, recover")),this.reconnect("recover",lT.MULTI_IP)):this.reconnect(h.action,lT.SERVER_ERROR),e===Tv.JOIN||e===Tv.REJOIN?null:await this.request(e,t)))}waitMessage(e,t){return new tg((i=>{const n=r=>{(!t||t(r))&&(this.off(e,n),i(r));};this.on(e,n);}))}upload(e,t){const i={_type:e,_message:t};try{this.websocket.sendMessage(i);}catch(e){const t=kC("MAX_UPLOAD_CACHE")||50;this.uploadCache.push(i),this.uploadCache.length>t&&this.uploadCache.splice(0,1),this.uploadCache.length>0&&!this.uploadCacheInterval&&(this.uploadCacheInterval=window.setInterval((()=>{if(this.connectionState!==fv.CONNECTED)return;const e=this.uploadCache.splice(0,1)[0];0===this.uploadCache.length&&(window.clearInterval(this.uploadCacheInterval),this.uploadCacheInterval=void 0),this.upload(e._type,e._message);}),kC("UPLOAD_CACHE_INTERVAL")||2e3));}}send(e,t){const i={_type:e,_message:t};this.websocket.sendMessage(i);}async sendExtensionMessage(e,t,i){return await this.waitTillUserOnline(),await this._external_signal.send(e,t,i)}init(e,t){return this.initError=void 0,this.multiIpOption=void 0,this.joinResponse=void 0,this.reconnectToken=void 0,this.openConnectionTime=void 0,new tg(((t,i)=>{this.once(gv.WS_CONNECTED,(()=>t(this.joinResponse))),this.once(gv.WS_CLOSED,(()=>i(this.initError||new Vg(xg.WS_ABORT)))),this.connectionState=fv.CONNECTING,this.websocket.init(e).catch(i),this.wsInflateDataTimer&&window.clearInterval(this.wsInflateDataTimer),this.wsInflateDataTimer=window.setInterval((()=>{this.handleWsInflateData();}),2e4);}))}close(e){this.pingpongTimer&&(this.pingpongTimeoutCount=0,window.clearInterval(this.pingpongTimer),this.pingpongTimer=void 0),this.wsInflateDataTimer&&(this.handleWsInflateData(),window.clearInterval(this.wsInflateDataTimer),this.wsInflateDataTimer=void 0),this.reconnectToken=void 0,this.joinResponse=void 0,this._disconnectedReason=e||cT.LEAVE,this.connectionState=fv.CLOSED,KC.debug("[".concat(this.clientId,"] ")+"will close websocket in signal"),this.websocket.close(),e===cT.FALLBACK&&(this.websocket.removeAllListeners(),this.websocket=new zI("gateway-".concat(this.clientId),this.spec.retryConfig,!0,kC("JOIN_GATEWAY_USE_DUAL_DOMAIN"),kC("JOIN_GATEWAY_USE_443PORT_ONLY"),this.store),this.handleWebsocketEvents());}async join(){if(!this.joinResponse){this.emit(gv.ABORT_P2P_EXECUTION);const e=await fT(this,gv.REQUEST_JOIN_INFO),t=await this.request(Tv.JOIN,e);if(!t)return this.emit(gv.REPORT_JOIN_GATEWAY,xg.TIMEOUT,this.url||""),!1;this.joinResponse=t,this.emit(gv.JOIN_RESPONSE,this.joinResponse),this.reconnectToken=this.joinResponse.rejoin_token;}return this.connectionState=fv.CONNECTED,this.pingpongTimer&&window.clearInterval(this.pingpongTimer),this.pingpongTimer=window.setInterval(this.handlePingPong.bind(this),3e3),this._userOnlineTime=(new Date).getTime(),this._external_signal.clear(),!0}async rejoin(){if(!this.reconnectToken)throw new Vg(xg.UNEXPECTED_ERROR,"can not rejoin, no rejoin token");const e=ST(this,gv.REQUEST_REJOIN_INFO);e.token=this.reconnectToken;return !!await this.request(Tv.REJOIN,e)&&(this.connectionState=fv.CONNECTED,this.pingpongTimer&&window.clearInterval(this.pingpongTimer),this.pingpongTimer=window.setInterval(this.handlePingPong.bind(this),3e3),!0)}reconnect(e,t){this.pingpongTimer&&(this.pingpongTimeoutCount=0,window.clearInterval(this.pingpongTimer),this.pingpongTimer=void 0),this.websocket.reconnect(e,t);}handleDataStream(e){try{var t;const i=DT(e.payload),n=(new TextDecoder).decode(i),r=JSON.parse(n);"total"in r&&"id"in r||Pr(t=Object.values(wI)).call(t,r._type)?(e.seq&&delete e.seq,r._uid=e.uid,this._external_signal.onMessage(r)):this.emit(Rv.ON_DATA_STREAM,e);}catch(e){}}handleNotification(e){KC.debug("[".concat(this.clientId,"] receive notification: "),e);const t=UI(e.code);if("success"!==t.action){if("failed"!==t.action)return "quit"===t.action?("ERR_REPEAT_JOIN_CHANNEL"===t.desc&&this.close(cT.UID_BANNED),void this.close()):void this.reconnect(t.action,lT.SERVER_ERROR);KC.error("[".concat(this.clientId,"] ignore error: "),t.desc);}}handlePingPong(){if(!this.websocket||"connected"!==this.websocket.state)return;this.pingpongTimeoutCount>0&&this.rttRolling.add(3e3),this.pingpongTimeoutCount+=1;const e=kC("PING_PONG_TIME_OUT"),t=Date.now();this.pingpongTimeoutCount>=e&&(KC.warning("[".concat(this.clientId,"] PINGPONG Timeout. Last Socket Message: ").concat(t-this.lastMsgTime,"ms")),t-this.lastMsgTime>kC("WEBSOCKET_TIMEOUT_MIN"))?this.reconnect("retry",lT.TIMEOUT):this.request(Tv.PING,void 0,!0).then((()=>{this.pingpongTimeoutCount=0;const e=Date.now()-t;this.rttRolling.add(e),kC("REPORT_STATS")&&this.send(Tv.PING_BACK,{pingpongElapse:e});})).catch((e=>{}));}handleWsInflateData(){const{wsInflateLength:e,wsDeflateLength:t}=this.websocket.getWsInflateData();0!==e&&0!==t&&this.upload(Sv.WS_INFLATE_DATA_LENGTH,{ws_deflate_length:t,ws_inflate_length:e});}handleWebsocketEvents(){this.websocket.on(Iv.RECONNECT_WAITTING_FINISH,(e=>{this.emit(gv.WS_RECONNECT_WAITTING_FINISH,e);})),this.websocket.on(Iv.RECONNECT_CREATE_CONNECTION,(e=>{this.emit(gv.WS_RECONNECT_CREATE_CONNECTION,e);})),this.websocket.on(Iv.ON_MESSAGE,this.onWebsocketMessage),this.websocket.on(Iv.CLOSED,(()=>{this.connectionState=fv.CLOSED;})),this.websocket.on(Iv.FAILED,(()=>{this._disconnectedReason=cT.NETWORK_ERROR,this.connectionState=fv.CLOSED;})),this.websocket.on(Iv.RECONNECTING,(e=>{this._websocketReconnectReason=e,this.joinResponse=void 0,this.connectionState===fv.CONNECTED?this.connectionState=fv.RECONNECTING:this.connectionState=fv.CONNECTING;})),this.websocket.on(Iv.WILL_RECONNECT,((e,t,i)=>{if(ST(this,gv.IS_P2P_DISCONNECTED)&&"retry"===e)return KC.debug("".concat(this.clientId," reconnect mode is retry, but p2p lost, change to tryNext")),this.reconnectToken=void 0,this.emit(gv.NEED_RENEW_SESSION),this.emit(gv.DISCONNECT_P2P),i("tryNext");"retry"!==e&&(KC.debug("".concat(this.clientId," websocket will_connect event, renewSession reconnectMode is ").concat(e)),this.reconnectToken=void 0,this.emit(gv.NEED_RENEW_SESSION),this.emit(gv.DISCONNECT_P2P)),i(e);})),this.websocket.on(Iv.CONNECTED,(()=>{this.openConnectionTime=Date.now(),this.reconnectToken?this.rejoin().catch((e=>{KC.warning("[".concat(this.clientId,"] rejoin failed ").concat(e)),this.reconnect("tryNext",lT.SERVER_ERROR);})):this.join().catch((e=>{if(this.emit(gv.REPORT_JOIN_GATEWAY,e.message||e.code,this.url||""),e instanceof Vg&&e.code===xg.UNEXPECTED_RESPONSE&&e.data.code===mv.ERR_NO_AUTHORIZED)return KC.warning("[".concat(this.clientId,"] reconnect no authorized, recover")),void this.reconnect("recover",lT.SERVER_ERROR);KC.error("[".concat(this.clientId,"] join gateway request failed"),e.toString()),this.spec.forceWaitGatewayResponse?this.reconnect("tryNext",lT.SERVER_ERROR):(this.initError=e,this.close());}));})),this.websocket.on(Iv.REQUEST_NEW_URLS,((e,t)=>{fT(this,gv.REQUEST_RECOVER,this.multiIpOption).then(e).catch(t);})),this.websocket.on(Iv.ON_TOKEN_PRIVILEGE_DID_EXPIRE,(()=>{this.emit(Rv.ON_TOKEN_PRIVILEGE_DID_EXPIRE);}));}_handleSignalP2PEvents(){this._external_signal.on(wI.JOIN,(async e=>{if(this._userOnlineTime&&this._userOnlineTime<e.onlineTime){const e=await fT(this,gv.P2P_START,void 0),t=await this._external_signal.send(wI.CALL,e);this.emit(gv.P2P_CONNECTION,t,!0);}this._userInRoom=!0,this.emit("user-online");})),this.on(Rv.ON_USER_OFFLINE,(async e=>{this._external_signal.clear(),this._userInRoom=!1;})),this._external_signal.on(wI.CALL,(async(e,t,i)=>{this._userInRoom=!0,this.emit("user-online");try{t(await fT(this,gv.P2P_START,e));}catch(e){i(e);}}));}async waitTillUserOnline(){return new tg((e=>{if(this._userInRoom)e();else {const t=()=>{this.off("user-online",t),e();};this.on("user-online",t);}}))}}function PD(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n);}return i}function LD(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?PD(Object(i),!0).forEach((function(t){nu(e,t,i[t]);})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):PD(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t));}));}return e}const kD=new Map;class MD extends iT{get state(){return this._state}set state(e){if(e===this._state)return;const t=this._state;this._state=e,"DISCONNECTED"===e&&this._disconnectedReason?this.emit(eI.CONNECTION_STATE_CHANGE,e,t,this._disconnectedReason):this.emit(eI.CONNECTION_STATE_CHANGE,e,t);}get joinGatewayStartTime(){return this._joinGatewayStartTime}set joinGatewayStartTime(e){KC.debug("[".concat(this.store.clientId,"] set joinGatewayStartTime at ").concat(e)),this._joinGatewayStartTime=e;}constructor(e,t){super(),nu(this,"store",void 0),nu(this,"joinInfo",void 0),nu(this,"key",void 0),nu(this,"ntpOffset",0),nu(this,"signal",void 0),nu(this,"role",void 0),nu(this,"inChannelInfo",{joinAt:null,duration:0}),nu(this,"spec",void 0),nu(this,"_state","DISCONNECTED"),nu(this,"_statsCollector",void 0),nu(this,"_disconnectedReason",void 0),nu(this,"isSignalRecover",!1),nu(this,"hasChangeBGPAddress",!1),nu(this,"trafficStatsInterval",void 0),nu(this,"networkQualityInterval",void 0),nu(this,"_joinGatewayStartTime",0),nu(this,"_signalTimeout",!1),nu(this,"_clientRoleOptions",void 0),nu(this,"_isProactiveJoin",!1),this.store=e,this.spec=t,this.signal=this.store.useP2P?new DD(LD(LD({},t),{},{retryConfig:t.websocketRetryConfig}),e):this.store.useDataChannel?new OD(LD(LD({},t),{},{retryConfig:t.websocketRetryConfig}),e):new QI(LD(LD({},t),{},{retryConfig:t.websocketRetryConfig}),e),this._statsCollector=t.statsCollector,this.role=t.role||"audience",this._clientRoleOptions=t.clientRoleOptions,this.handleSignalEvents();}async join(e,t,i){if(this.signal instanceof OD){let t=!1;"disabled"!==e.cloudProxyServer?(KC.debug("[".concat(this.store.clientId,"] Dc is not supported, because cloudProxyServer are not supported (").concat(e.cloudProxyServer,")")),t=!0):"".concat(e.apResponse.cid,"_").concat(e.apResponse.cert).length>255||"".concat(e.apResponse.cid,"_").concat(e.apResponse.cert).length<22?(KC.debug("[".concat(this.store.clientId,"] Dc is not supported, because ticket length is incorrect, it has to be between 22 and 255")),t=!0):e.apResponse.addresses.some((e=>e.fingerprint))||kC("FINGERPRINT")||(KC.debug("[".concat(this.store.clientId,"] Dc is not supported, because fingerprint does not exist")),t=!0),t&&this.resetSignal();}this.store.joinGatewayStart(),"disabled"!==e.cloudProxyServer&&(this.hasChangeBGPAddress=!0);const n=Date.now();let r=kD.get(e.cname);if(r||(r=new Map,kD.set(e.cname,r)),this._isProactiveJoin=!0,r.has(e.uid)){const t=new xv(xg.UID_CONFLICT);throw rv.joinGateway(e.sid,{lts:n,succ:!1,ec:t.message,addr:null,uid:e.uid,cid:e.cid,firstSuccess:this._isProactiveJoin,avoidJoinStartTime:this.store.avoidJoinStart,isProxy:!!e.proxyServer,signalChannel:this.signal instanceof OD?"1":"0"}),this._isProactiveJoin=!1,t}r.set(e.uid,!0),this.joinInfo=e,this.key=t;let s=0;this.joinGatewayStartTime=n;const o=e.proxyServer;try{let t;if(KC.debug("[".concat(this.store.clientId,"] use ").concat(this.signal instanceof OD?"datachannel":"websocket"," join uid ").concat(s)),this.signal instanceof OD)t=await this.signal.init(e.apResponse.addresses,i);else {const n=e.gatewayAddrs.map((t=>{let{address:i}=t;const[n,r]=i.split(":"),s={host:n,port:r};return e.proxyServer&&(s.proxy=e.proxyServer),s}));t=await this.signal.init(n,i);}s=t.uid,KC.debug("[".concat(this.store.clientId,"] ").concat(this.signal instanceof OD?"datachannel":"websocket"," join uid ").concat(s," cost ").concat(Date.now()-this.joinGatewayStartTime));}catch(t){if(t&&t.code===xg.INIT_WEBSOCKET_TIMEOUT)throw KC.warning("[".concat(this.store.clientId,"] User join failed"),t.toString()),t;if(t&&t.code===xg.INIT_DATACHANNEL_TIMEOUT)throw KC.warning("[".concat(this.store.clientId,"] User join datachannel failed"),t.toString()),this.resetSignal(),t;throw KC.error("[".concat(this.store.clientId,"] User join failed"),t.toString()),rv.joinGateway(e.sid,{lts:n,succ:!1,ec:t.message,addr:this.signal.url,uid:e.uid,cid:e.cid,firstSuccess:this._isProactiveJoin,avoidJoinStartTime:this.store.avoidJoinStart,isProxy:!!o,signalChannel:this.signal instanceof OD?"1":"0"}),this._isProactiveJoin=!1,r.delete(e.uid),this.signal.close(),t}return this.state="CONNECTED",this.inChannelInfo.joinAt=Date.now(),KC.debug("[".concat(this.store.clientId,"] Connected to gateway server")),this.trafficStatsInterval=window.setInterval((()=>{this.updateTrafficStats().catch((e=>{KC.warning("[".concat(this.store.clientId,"] get traffic stats error"),e.toString());}));}),3e3),this.networkQualityInterval=window.setInterval((()=>{navigator&&void 0!==navigator.onLine&&!navigator.onLine?this.emit(eI.NETWORK_QUALITY,{downlinkNetworkQuality:6,uplinkNetworkQuality:6}):this._signalTimeout?this.emit(eI.NETWORK_QUALITY,{downlinkNetworkQuality:5,uplinkNetworkQuality:5}):"CONNECTED"===this.state&&this._statsCollector.trafficStats?this.emit(eI.NETWORK_QUALITY,{uplinkNetworkQuality:TD(this._statsCollector.trafficStats.B_unq),downlinkNetworkQuality:TD(this._statsCollector.trafficStats.B_dnq)}):this.emit(eI.NETWORK_QUALITY,{uplinkNetworkQuality:0,downlinkNetworkQuality:0});}),2e3),this.store.joinGatewayEnd(),s}async leave(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0],t=arguments.length>1?arguments[1]:void 0;if("DISCONNECTED"!==this.state){t!==cT.FALLBACK&&(this.state="DISCONNECTING");try{e||this.signal.connectionState!==fv.CONNECTED||await function(e,t){return t===1/0?e:tg.race([e,MT(t)])}(this.signal.request(Tv.LEAVE,void 0,!0),3e3);}catch(e){KC.warning("[".concat(this.store.clientId,"] leave request failed, ignore"),e);}this.signal.close(t),t!==cT.FALLBACK&&(this.state="DISCONNECTED"),this.reset();}}async publish(e,t,i){if("CONNECTED"!==this.state&&"RECONNECTING"!==this.state)throw new xv(xg.INVALID_OPERATION,"can not publish when connection state is ".concat(this.state));const n={state:"offer",p2p_id:this.store.p2pId,ortc:t,mode:this.spec.mode,extend:kC("PUB_EXTEND"),twcc:!!kC("PUBLISH_TWCC"),rtx:!!kC("USE_PUB_RTX")};try{return (await this.signal.request(Tv.PUBLISH,n,!0))._message}catch(n){if(i&&n.data&&n.data.code===mv.ERR_PUBLISH_REQUEST_INVALID)return KC.warning("[".concat(this.store.clientId,"] receive publish error code, retry"),n.toString()),await this.tryUnpubBeforeRepub(e,t),this.publish(e,t,!1);throw n}}async publishDataChannel(e,t,i){var n;if("CONNECTED"!==this.state&&"RECONNECTING"!==this.state)throw new xv(xg.INVALID_OPERATION,"can not publish when connection state is ".concat(this.state));const r={stream_id:t.streamId,ordered:t.ordered?1:0,max_retrans_times:null!==(n=t.maxRetransmits)&&void 0!==n?n:10,channel_id:t.channelId,metadata:t.metadata};try{await this.signal.request(Tv.PUBLISH_DATASTREAM,r,!0);}catch(n){if(i&&n.data&&n.data.code===mv.ERR_PUBLISH_REQUEST_INVALID)return KC.warning("[".concat(this.store.clientId,"] receive publish datachannels error code, retry"),n.toString()),await this.tryUnpubDataChannelBeforeRepub(e,t),this.publishDataChannel(e,t,!1);throw n}}async unpublish(e,t){try{if("CONNECTED"!==this.state&&"RECONNECTING"!==this.state)throw new xv(xg.INVALID_OPERATION,"can not publish when connection state is ".concat(this.state));await this.signal.request(Tv.UNPUBLISH,{stream_id:t,ortc:e},!0);}catch(e){KC.warning("[".concat(this.store.clientId,"] unpublish warning: "),e);}}async unpublishDataChannel(e){try{if("CONNECTED"!==this.state&&"RECONNECTING"!==this.state)throw new xv(xg.INVALID_OPERATION,"can not publish when connection state is ".concat(this.state));await tg.all(e.map((e=>this.signal.request(Tv.UNPUBLISH_DATASTREAM,{channel_id:e},!0))));}catch(e){KC.warning("unpublish datachannels warning: ",e);}}async subscribe(e,t,i){if("CONNECTED"!==this.state&&"RECONNECTING"!==this.state)throw new xv(xg.INVALID_OPERATION,"can not subscribe when connection state is ".concat(this.state));const n={stream_id:e,stream_type:t.stream_type,mode:this.spec.mode,codec:this.spec.codec,p2p_id:this.store.p2pId,twcc:!!kC("SUBSCRIBE_TWCC"),rtx:!!kC("USE_SUB_RTX"),extend:kC("SUB_EXTEND"),ssrcId:t.ssrcId,svc:Array.isArray(kC("SVC"))&&0!==kC("SVC").length?kC("SVC"):void 0};try{return (await this.signal.request(Tv.SUBSCRIBE,n,!0))._message}catch(n){if(i&&n.data&&n.data.code===mv.ERR_SUBSCRIBE_REQUEST_INVALID)return KC.warning("[".concat(this.store.clientId,"] receiver subscribe error code, retry"),n.toString()),await this.tryUnsubBeforeResub(e,t),await this.subscribe(e,t,!1);throw n}}async subscribeDataChannel(e,t,i){if("CONNECTED"!==this.state&&"RECONNECTING"!==this.state)throw new xv(xg.INVALID_OPERATION,"can not subscribe datachannel when connection state is ".concat(this.state));const n={uid:e,stream_id:t.id,channel_id:t.datachannelId};try{return void await this.signal.request(Tv.SUBSCRIBE_DATASTREAM,n,!0)}catch(n){if(i&&n.data&&n.data.code===mv.ERR_SUBSCRIBE_REQUEST_INVALID)return KC.warning("[".concat(this.store.clientId,"] receiver subscribe datachannel error code, retry"),n.toString()),await this.tryUnsubDataChannelBeforeResub(e,t),await this.subscribeDataChannel(e,t,!1);throw n}}async subscribeAll(e,t){if("CONNECTED"!==this.state&&"RECONNECTING"!==this.state)throw new xv(xg.INVALID_OPERATION,"can not massSubscribe when connection state is ".concat(this.state));const i={p2p_id:this.store.p2pId,users:e,dtx:!1,rtx:!!kC("USE_SUB_RTX")};try{return await this.signal.request(Tv.SUBSCRIBE_STREAMS,i,!0)}catch(i){if(t&&i.data&&i.data.code===mv.ERR_SUBSCRIBE_REQUEST_INVALID)return KC.warning("[".concat(this.store.clientId,"] receiver massSubscribe error code, retry"),i.toString()),await this.tryMassUnsubBeforeResub(e),await this.subscribeAll(e,!1);throw i}}async setVideoProfile(e){const t=function(e){if(!(e.bitrateMax&&e.bitrateMin&&e.frameRate&&e.height&&e.width))return;let t=e.frameRate,i=e.width,n=e.height,r=!0;return "number"!=typeof t&&(t=t.exact||t.ideal||t.max||t.min||0,t||(r=!1)),"number"!=typeof i&&(i=i.exact||i.ideal||i.max||i.min||0,i||(r=!1)),"number"!=typeof n&&(n=n.exact||n.ideal||n.max||n.min||0,t||(r=!1)),r?{stream_type:0,width:i,height:n,fps:t,start_bps:1e3*e.bitrateMax,min_bps:1e3*e.bitrateMin,target_bps:1e3*e.bitrateMax}:void 0}(e);if(t)return this.signal.request(Tv.SET_VIDEO_PROFILE,t);KC.debug("[".concat(this.store.clientId,"] encoder config is not complete, do not report to gateway"));}async unsubscribe(e,t){try{await this.signal.request(Tv.UNSUBSCRIBE,{p2p_id:this.store.p2pId,ortc:e,stream_id:t},!0);}catch(e){KC.warning("[".concat(this.store.clientId,"] unsubscribe warning: "),e);}}async unsubscribeDataChannel(e,t){try{if("CONNECTED"!==this.state&&"RECONNECTING"!==this.state)throw new xv(xg.INVALID_OPERATION,"can not publish when connection state is ".concat(this.state));await tg.all(e.map((e=>this.signal.request(Tv.UNSUBSCRIBE_DATASTREAM,{stream_id:e,uid:t},!0))));}catch(e){KC.warning("unsubscribeDataChannel warning: ",e);}}async massUnsubscribe(e){try{await this.signal.request(Tv.UNSUBSCRIBE_STREAMS,e,!0);}catch(e){KC.warning("[".concat(this.store.clientId,"] massUnsubscribeAll warning: "),e);}}async reconnectPC(e){const{iceParameters:t,dtlsParameters:i,rtpCapabilities:n}=e;return {gatewayEstablishParams:await this.signal.request(Tv.CONNECT_PC,{p2p_id:this.store.p2pId,stream_id:this.store.uid,ortc:{iceParameters:t,dtlsParameters:i,rtpCapabilities:n}},!0),gatewayAddress:this.getCurrentGatewayAddress()}}getGatewayInfo(){return this.signal.request(Tv.GATEWAY_INFO)}async renewToken(e){await this.signal.request(Tv.RENEW_TOKEN,e),this.key=e.token;}async setClientRole(e,t){if(t&&(this._clientRoleOptions=Object.assign({},t)),"CONNECTED"!==this.state)return void(this.role=e);let i,n=0;"audience"===e?this._clientRoleOptions&&this._clientRoleOptions.delay?(i=this._clientRoleOptions.delay,n=1):n=this._clientRoleOptions&&this._clientRoleOptions.level?this._clientRoleOptions.level:2:n=0,await this.signal.request(Tv.SET_CLIENT_ROLE,{role:e,level:n,delay:i,client_ts:Date.now()}),this.role=e;}async setRemoteVideoStreamType(e,t){await this.signal.request(Tv.SWITCH_VIDEO_STREAM,{stream_id:e,stream_type:t});}async setDefaultRemoteVideoStreamType(e){await this.signal.request(Tv.DEFAULT_VIDEO_STREAM,{stream_type:e});}async setStreamFallbackOption(e,t){await this.signal.request(Tv.SET_FALLBACK_OPTION,{stream_id:e,fallback_type:t});}async pickSVCLayer(e,t){await this.signal.request(Tv.PICK_SVC_LAYER,{stream_id:e,spatial_layer:t.spatialLayer,temporal_layer:t.temporalLayer});}async setRTM2Flag(e){await this.signal.request(Tv.SET_RTM2_FLAG,{rtm2_flag:e});}async sendExtensionMessage(e,t,i){if(this.signal instanceof DD)return this.signal.sendExtensionMessage(e,t,i)}getInChannelInfo(){return this.inChannelInfo.joinAt&&(this.inChannelInfo.duration=Date.now()-this.inChannelInfo.joinAt),LD({},this.inChannelInfo)}async getGatewayVersion(){return (await this.signal.request(Tv.GATEWAY_INFO)).version}reset(){if(this.inChannelInfo.joinAt&&(this.inChannelInfo.duration=Date.now()-this.inChannelInfo.joinAt,this.inChannelInfo.joinAt=null),this.trafficStatsInterval&&(window.clearInterval(this.trafficStatsInterval),this.trafficStatsInterval=void 0),this.joinInfo){const e=kD.get(this.joinInfo.cname);e&&e.delete(this.joinInfo.uid);}this.joinInfo=void 0,this.key=void 0,this.networkQualityInterval&&(window.clearInterval(this.networkQualityInterval),this.networkQualityInterval=void 0);}updateTurnConfigFromSignal(){if(!this.joinInfo)return;const e=function(e){let t;return t=e.startsWith("dc")?e.match(/(dc\:\/\/)?([^:]+):(\d+)/):e.match(/(wss\:\/\/)?([^:]+):(\d+)/),t?{username:ov.username,password:ov.password,turnServerURL:t[2],tcpport:parseInt(t[3])+30,udpport:parseInt(t[3])+30,forceturn:!1}:null}(("disabled"===this.joinInfo.cloudProxyServer?this.signal.url:this.joinInfo.gatewayAddrs[this.signal.currentURLIndex].address)||"");this.joinInfo.turnServer.serversFromGateway=[],e&&"off"!==this.joinInfo.turnServer.mode&&"disabled"===this.joinInfo.cloudProxyServer&&this.joinInfo.turnServer.serversFromGateway.push(LD(LD({},ov),{},{turnServerURL:e.turnServerURL,tcpport:e.tcpport,udpport:e.udpport,username:this.joinInfo.uid.toString(),password:this.joinInfo.token}));}async updateTrafficStats(){if("CONNECTED"!==this.state)return;const e=await this.signal.request(Tv.TRAFFIC_STATS,void 0,!0);e.timestamp=Date.now(),null!=e.ntp_offset&&(this.ntpOffset=e.ntp_offset),e.peer_delay.forEach((e=>{const t=this._statsCollector.trafficStats&&this._statsCollector.trafficStats.peer_delay.find((t=>t.peer_uid===e.peer_uid));t&&t.B_st!==e.B_st&&AT((()=>{this.emit(eI.STREAM_TYPE_CHANGE,e.peer_uid,e.B_st);}));})),this._statsCollector.updateTrafficStats(e);}getJoinMessage(e){if(!this.joinInfo||!this.key)throw new xv(xg.UNEXPECTED_ERROR,"can not generate join message, no join info");const t=Object.assign({},this.joinInfo.apResponse);let i=kC("REPORT_APP_SCENARIO");if("string"!=typeof i)try{i=JSON.stringify(i);}catch(e){i=void 0;}i&&i.length>128&&(i=void 0);const n=LD({license:this.joinInfo.license,p2p_id:this.store.p2pId,session_id:this.joinInfo.sid,app_id:this.joinInfo.appId,channel_key:this.key,channel_name:this.joinInfo.cname,sdk_version:OC,browser:navigator.userAgent,process_id:kC("PROCESS_ID"),mode:this.store.useP2P?"p2p":this.spec.mode,codec:this.spec.codec,role:this.role,has_changed_gateway:this.hasChangeBGPAddress,ap_response:t,extend:kC("JOIN_EXTEND"),details:{6:this.joinInfo.stringUid,cservice_map:"proxy3"===this.joinInfo.cloudProxyServer?"1":"proxy5"===this.joinInfo.cloudProxyServer?"2":void 0},features:{rejoin:!0},optionalInfo:this.joinInfo.optionalInfo,appScenario:i,attributes:{userAttributes:{enablePublishedUserList:kC("ENABLE_PUBLISHED_USER_LIST"),maxSubscription:kC("MAX_SUBSCRIPTION"),subscribeAudioFilterTopN:"number"==typeof kC("SUBSCRIBE_AUDIO_FILTER_TOPN")?kC("SUBSCRIBE_AUDIO_FILTER_TOPN"):void 0,enablePublishAudioFilter:"boolean"==typeof kC("ENABLE_PUBLISH_AUDIO_FILTER")?kC("ENABLE_PUBLISH_AUDIO_FILTER"):void 0,enableUserLicenseCheck:"boolean"==typeof kC("ENABLE_USER_LICENSE_CHECK")?kC("ENABLE_USER_LICENSE_CHECK"):void 0,enableRTX:!0===kC("USE_PUB_RTX")||!0===kC("USE_SUB_RTX")||void 0,disableFEC:kC("DISABLE_FEC"),enableNTPReport:!!kC("ENABLE_NTP_REPORT")||void 0,enableInstantVideo:!!kC("ENABLE_INSTANT_VIDEO")||void 0,enableDataStream2:"boolean"==typeof kC("ENABLE_DATASTREAM_2")?kC("ENABLE_DATASTREAM_2"):void 0,rtm2Flag:"number"==typeof kC("RTM2_FLAG")?kC("RTM2_FLAG"):void 0,enableUserAutoRebalanceCheck:!!kC("ENABLE_USER_AUTO_REBALANCE_CHECK"),enableXR:"boolean"==typeof kC("USE_XR")?kC("USE_XR"):void 0}},join_ts:this.joinGatewayStartTime},e);return this.joinInfo.stringUid&&(n.string_uid=this.joinInfo.stringUid),this.joinInfo.aesmode&&this.joinInfo.aespassword&&(n.aes_mode=this.joinInfo.aesmode,kC("ENCRYPT_AES")?(n.aes_secret=this.joinInfo.aespassword,n.aes_encrypt=!0):n.aes_secret=this.joinInfo.aespassword,this.joinInfo.aessalt&&(n.aes_salt=this.joinInfo.aessalt)),t.addresses[this.signal.websocket.currentURLIndex]&&(n.ap_response.ticket=t.addresses[this.signal.websocket.currentURLIndex].ticket,delete t.addresses),void 0!==this.joinInfo.defaultVideoStream&&(n.default_video_stream=this.joinInfo.defaultVideoStream),n}getRejoinMessage(){if(!this.joinInfo)throw new xv(xg.UNEXPECTED_ERROR,"can not generate rejoin message, no join info");return {session_id:this.joinInfo.sid,channel_name:this.joinInfo.cname,cid:this.joinInfo.cid,uid:this.joinInfo.uid,vid:Number(this.joinInfo.vid)}}handleSignalEvents(){this.signal.on(gv.WS_RECONNECT_WAITTING_FINISH,(e=>{var t;Pr(t=["tryNext","recover"]).call(t,e)&&this.joinInfo&&rv.adjustSessionStartTime(this.joinInfo.sid);})),this.signal.on(gv.WS_RECONNECT_CREATE_CONNECTION,(e=>{this.joinGatewayStartTime=Date.now();})),this.signal.on(gv.WS_RECONNECTING,(e=>{this.joinInfo&&rv.WebSocketQuit(this.joinInfo.sid,{lts:Date.now(),succ:-1,cname:this.joinInfo.cname,uid:this.joinInfo.uid,cid:this.joinInfo.cid,errorCode:e||lT.NETWORK_ERROR}),this.joinInfo&&(this.state="RECONNECTING",rv.sessionInit(this.joinInfo.sid,{lts:(new Date).getTime(),extend:this.isSignalRecover?{recover:!0}:{rejoin:!0},cname:this.joinInfo.cname,appid:this.joinInfo.appId,mode:this.spec.mode}),this.isSignalRecover=!1,this.joinGatewayStartTime=Date.now());})),this.signal.on(gv.WS_CLOSED,(e=>{let t;switch(e){case cT.LEAVE:t=lT.LEAVE;break;case cT.UID_BANNED:case cT.IP_BANNED:case cT.CHANNEL_BANNED:case cT.SERVER_ERROR:t=lT.SERVER_ERROR;break;case cT.FALLBACK:t=lT.FALLBACK;break;case cT.LICENSE_MISSING:case cT.LICENSE_EXPIRED:case cT.LICENSE_MINUTES_EXCEEDED:case cT.LICENSE_PERIOD_INVALID:case cT.LICENSE_MULTIPLE_SDK_SERVICE:case cT.LICENSE_ILLEGAL:case cT.TOKEN_EXPIRE:t=e;break;default:t=lT.NETWORK_ERROR;}KC.debug("[".concat(this.store.clientId,"] [signal] websocket closed, reason: ").concat(t||"undefined -> "+lT.NETWORK_ERROR)),this.joinInfo&&rv.WebSocketQuit(this.joinInfo.sid,{lts:Date.now(),succ:e===cT.LEAVE?1:-1,cname:this.joinInfo.cname,uid:this.joinInfo.uid,cid:this.joinInfo.cid,errorCode:t}),this._disconnectedReason=e,e!==cT.FALLBACK&&(this.state="DISCONNECTED"),this.reset();})),this.signal.on(gv.WS_CONNECTED,(()=>{if(this.updateTurnConfigFromSignal(),this.state="CONNECTED",this.joinInfo&&("audience"===this.role&&this._clientRoleOptions&&(this._clientRoleOptions.level||this._clientRoleOptions.delay)&&(KC.debug("[".concat(this.store.clientId,"] patch to send set client role, role: ").concat(this.role,", mode: ").concat(this.spec.mode,", level: ").concat(this._clientRoleOptions.level,", delay: ").concat(this._clientRoleOptions.delay)),this.setClientRole(this.role,this._clientRoleOptions)),rv.joinGateway(this.joinInfo.sid,{lts:this.joinGatewayStartTime,succ:!0,ec:null,vid:this.joinInfo.vid,addr:this.signal.url,uid:this.joinInfo.uid,cid:this.joinInfo.cid,firstSuccess:this._isProactiveJoin,avoidJoinStartTime:this.store.avoidJoinStart,isProxy:!!this.joinInfo.proxyServer,signalChannel:this.signal instanceof OD?"1":"0"}),this._isProactiveJoin=!1,this.joinInfo.useLocalAccessPoint&&1===this.joinInfo.setLocalAPVersion)){const e=this.signal.url&&this.signal.url.match(/wss\:\/\/([^:]+):(\d+)/);if(!e)return void KC.error("[".concat(this.store.clientId,"] set local access point after joined failed: ").concat(e));LC("EVENT_REPORT_DOMAIN",e[1]),LC("EVENT_REPORT_BACKUP_DOMAIN",e[1]),LC("LOG_UPLOAD_SERVER","".concat(e[1],":6444"));}})),this.signal.on(Rv.ON_UPLINK_STATS,(e=>{this._statsCollector.updateUplinkStats(e);})),this.signal.on(gv.REQUEST_RECOVER,((e,t,i)=>{if(!this.joinInfo)return i(new xv(xg.UNEXPECTED_ERROR,"gateway: can not recover, no join info"));e&&(this.joinInfo.multiIP=e,this.hasChangeBGPAddress=!0),this.isSignalRecover=!0,fT(this,eI.REQUEST_NEW_GATEWAY_LIST).then(t).catch(i);})),this.signal.on(gv.REQUEST_JOIN_INFO,(async e=>{var t;if(this.updateTurnConfigFromSignal(),this.store.useP2P)return void e(this.getJoinMessage({ortc:{}}));const{iceParameters:i,dtlsParameters:n,rtpCapabilities:r}=await fT(this,eI.REQUEST_P2P_CONNECTION_PARAMS,{turnServer:null===(t=this.joinInfo)||void 0===t?void 0:t.turnServer});e(this.getJoinMessage({ortc:{iceParameters:i,dtlsParameters:n,rtpCapabilities:r,version:"2"}}));})),this.signal.on(gv.REQUEST_REJOIN_INFO,(e=>{e(this.getRejoinMessage());})),this.signal.on(gv.REPORT_JOIN_GATEWAY,((e,t)=>{this.joinInfo&&(rv.joinGateway(this.joinInfo.sid,{lts:this.joinGatewayStartTime,succ:!1,ec:e,addr:t,uid:this.joinInfo.uid,cid:this.joinInfo.cid,firstSuccess:this._isProactiveJoin,avoidJoinStartTime:this.store.avoidJoinStart,isProxy:!!this.joinInfo.proxyServer,signalChannel:this.signal instanceof OD?"1":"0"}),this._isProactiveJoin=!1);})),this.signal.on(gv.IS_P2P_DISCONNECTED,(e=>{e(ST(this,eI.IS_P2P_DISCONNECTED));})),this.signal.on(gv.DISCONNECT_P2P,(()=>{this.emit(eI.DISCONNECT_P2P);})),this.signal.on(gv.NEED_RENEW_SESSION,(()=>{this.emit(eI.NEED_RENEW_SESSION);})),this.signal.on(gv.REQUEST_SUCCESS,(()=>{this._signalTimeout=!1;})),this.signal.on(gv.REQUEST_TIMEOUT,(()=>{this._signalTimeout=!0;})),this.signal.on(gv.JOIN_RESPONSE,(e=>{const t=this.getCurrentGatewayAddress();this.emit(eI.JOIN_RESPONSE,e,t);})),this.signal.on(gv.DATACHANNEL_PRECONNECT,(async(e,t,i)=>{this.updateTurnConfigFromSignal();const n=this.getCurrentGatewayAddress();return fT(this,eI.DATACHANNEL_PRECONNECT,e,n).then(t).catch(i)})),this.signal.on(gv.DATACHANNEL_CONNECTING,(async e=>{const{iceParameters:t,dtlsParameters:i,rtpCapabilities:n}=await fT(this,eI.REQUEST_DC_CONNECTION_PARAMS);e(this.getJoinMessage({ortc:{iceParameters:t,dtlsParameters:i,rtpCapabilities:n,version:"2"}}));})),this.signal.on(gv.DATACHANNEL_FAILBACK,(()=>{KC.warning("[".concat(this.store.clientId,"] User join datachannel failed")),this.reset(),this.resetSignal(),this.emit(eI.DATACHANNEL_FAILBACK);}));}async tryUnsubBeforeResub(e,t){try{await this.signal.request(Tv.UNSUBSCRIBE,{p2p_id:this.store.p2pId,stream_id:e,ortc:[t]},!0);}catch(e){throw KC.warning("[".concat(this.store.clientId,"] tryUnsubBeforeResub warning"),e),e}}async tryUnsubDataChannelBeforeResub(e,t){try{await this.signal.request(Tv.UNSUBSCRIBE,{stream_id:t.id},!0);}catch(e){throw KC.warning("unsubscribe datachannel warning",e),e}}async tryUnpubBeforeRepub(e,t){try{await this.signal.request(Tv.UNPUBLISH,{stream_id:e,ortc:t},!0);}catch(e){throw KC.warning("[".concat(this.store.clientId,"] tryUnpubBeforeRepub warning: "),e),e}}async tryUnpubDataChannelBeforeRepub(e,t){try{await this.signal.request(Tv.UNPUBLISH_DATASTREAM,{channnel_id:t.channelId},!0);}catch(e){throw KC.warning("unpublish datastream warning: ",e),e}}async tryMassUnsubBeforeResub(e){const t={users:e.map((e=>({stream_id:e.stream_id,stream_type:e.stream_type})))};try{await this.signal.request(Tv.UNSUBSCRIBE_STREAMS,t,!0);}catch(e){throw KC.warning("[".concat(this.store.clientId,"] tryMassUnsubBeforeResub warning"),e),e}}async muteLocal(e,t){const i={action:e.find((e=>e.stream_type===$v.Audio))?"mute_local_audio":"mute_local_video",p2p_id:this.store.p2pId,ortc:e,stream_id:t};try{await this.signal.request(Tv.CONTROL,i,!0,!0);}catch(e){throw KC.warning("[".concat(this.store.clientId,"] gateway muteLocal warning: "),e),e}}async unmuteLocal(e,t){const i={action:e.find((e=>e.stream_type===$v.Audio))?"unmute_local_audio":"unmute_local_video",p2p_id:this.store.p2pId,ortc:e,stream_id:t};try{await this.signal.request(Tv.CONTROL,i,!0,!0);}catch(e){throw KC.warning("[".concat(this.store.clientId,"] gateway unmuteLocal warning: "),e),e}}async muteRemote(e,t){const i={action:e===hI.AUDIO?"mute_remote_audio":"mute_remote_video",p2p_id:this.store.p2pId,stream_id:t};try{await this.signal.request(Tv.CONTROL,i,!0,!0);}catch(e){throw KC.warning("[".concat(this.store.clientId,"] gateway muteRemote warning: "),e),e}}async unmuteRemote(e,t){const i={action:e===hI.AUDIO?"unmute_remote_audio":"unmute_remote_video",p2p_id:this.store.p2pId,stream_id:t};try{await this.signal.request(Tv.CONTROL,i,!0,!0);}catch(e){throw KC.warning("[".concat(this.store.clientId,"] gateway unmuteRemote warning: "),e),e}}uploadStats(e,t){this.signal.upload(e,t);}getSignalRTT(){return this.signal.rtt}async restartICE(e){const t={p2p_id:this.store.p2pId,stream_id:this.store.uid,ortc:e};try{return await this.signal.request(Tv.RESTART_ICE,t,!0)}catch(e){throw KC.warning("[".concat(this.store.clientId,"] P2PChannel.restartICE warning: "),e),e}}reconnect(){"CONNECTED"===this.state&&this.signal.reconnect(void 0,lT.P2P_FAILED);}getCurrentGatewayAddress(){var e;if(!kC("GATEWAY_WSS_ADDRESS"))return null!==(e=this.joinInfo)&&void 0!==e&&e.gatewayAddrs?this.joinInfo.gatewayAddrs[this.signal.currentURLIndex]:void 0}async setPublishAudioFilterEnabled(e){await this.signal.request(Tv.SET_PARAMETER,{enablePublishAudioFilter:e});}resetSignal(){this.signal&&(this.signal.removeAllListeners(),this.signal.close(cT.FALLBACK)),this.store.useDataChannel=!1,this.signal=new QI(LD(LD({},this.spec),{},{retryConfig:this.spec.websocketRetryConfig}),this.store),this.handleSignalEvents(),this.emit(eI.RESET_SIGNAL,nI.websocket);}}let UD=0,xD=0;function VD(e,t,i,n){return new tg(((r,s)=>{t.timeout=t.timeout||kC("HTTP_CONNECT_TIMEOUT"),t.responseType=t.responseType||"json",t.data&&!i?(t.data=JSON.stringify(t.data),UD+=LT(t.data)):i&&(t.data.size?UD+=t.data.size:t.data instanceof FormData?UD+=kT(t.data):UD+=LT(JSON.stringify(t.data))),t.headers=t.headers||{},t.headers["Content-Type"]=t.headers["Content-Type"]||"application/json",t.method="POST",t.url=e,EC.request(t).then((e=>{"string"==typeof e.data?xD+=LT(e.data):e.data instanceof ArrayBuffer||e.data instanceof Uint8Array?xD+=e.data.byteLength:xD+=LT(JSON.stringify(e.data)),n&&r({data:e.data,headers:e.headers}),r(e.data);})).catch((e=>{EC.isCancel(e)?s(new xv(xg.OPERATION_ABORTED,"cancel token canceled")):"ECONNABORTED"===e.code?s(new xv(xg.NETWORK_TIMEOUT,e.message)):e.response?s(new xv(xg.NETWORK_RESPONSE_ERROR,e.response.status)):s(new xv(xg.NETWORK_ERROR,e.message));}));}))}
/*! formdata-polyfill. MIT License. Jimmy W?rting <https://jimmy.warting.se/opensource> */!function(){var e;function t(e){var t=0;return function(){return t<e.length?{done:!1,value:e[t++]}:{done:!0}}}var i="function"==typeof Object.defineProperties?Object.defineProperty:function(e,t,i){return e==Array.prototype||e==Object.prototype||(e[t]=i.value),e};var n,r=function(e){e=["object"==typeof globalThis&&globalThis,e,"object"==typeof window&&window,"object"==typeof self&&self,"object"==typeof q&&q];for(var t=0;t<e.length;++t){var i=e[t];if(i&&i.Math==Math)return i}throw Error("Cannot find global object")}(this);function s(e,t){if(t)e:{var n=r;e=e.split(".");for(var s=0;s<e.length-1;s++){var o=e[s];if(!(o in n))break e;n=n[o];}(t=t(s=n[e=e[e.length-1]]))!=s&&null!=t&&i(n,e,{configurable:!0,writable:!0,value:t});}}function o(e){return (e={next:e})[Symbol.iterator]=function(){return this},e}function a(e){var i="undefined"!=typeof Symbol&&Symbol.iterator&&e[Symbol.iterator];return i?i.call(e):{next:t(e)}}if(s("Symbol",(function(e){function t(e,t){this.A=e,i(this,"description",{configurable:!0,writable:!0,value:t});}if(e)return e;t.prototype.toString=function(){return this.A};var n="jscomp_symbol_"+(1e9*Math.random()>>>0)+"_",r=0;return function e(i){if(this instanceof e)throw new TypeError("Symbol is not a constructor");return new t(n+(i||"")+"_"+r++,i)}})),s("Symbol.iterator",(function(e){if(e)return e;e=Symbol("Symbol.iterator");for(var n="Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array".split(" "),s=0;s<n.length;s++){var a=r[n[s]];"function"==typeof a&&"function"!=typeof a.prototype[e]&&i(a.prototype,e,{configurable:!0,writable:!0,value:function(){return o(t(this))}});}return e})),"function"==typeof Object.setPrototypeOf)n=Object.setPrototypeOf;else {var c;e:{var d={};try{d.__proto__={a:!0},c=d.a;break e}catch(e){}c=!1;}n=c?function(e,t){if(e.__proto__=t,e.__proto__!==t)throw new TypeError(e+" is not extensible");return e}:null;}var l=n;function h(){this.m=!1,this.j=null,this.v=void 0,this.h=1,this.u=this.C=0,this.l=null;}function u(e){if(e.m)throw new TypeError("Generator is already running");e.m=!0;}function p(e,t){return e.h=3,{value:t}}function _(e){this.g=new h,this.G=e;}function E(e,t,i,n){try{var r=t.call(e.g.j,i);if(!(r instanceof Object))throw new TypeError("Iterator result "+r+" is not an object");if(!r.done)return e.g.m=!1,r;var s=r.value;}catch(t){return e.g.j=null,e.g.s(t),m(e)}return e.g.j=null,n.call(e.g,s),m(e)}function m(e){for(;e.g.h;)try{var t=e.G(e.g);if(t)return e.g.m=!1,{value:t.value,done:!1}}catch(t){e.g.v=void 0,e.g.s(t);}if(e.g.m=!1,e.g.l){if(t=e.g.l,e.g.l=null,t.F)throw t.D;return {value:t.return,done:!0}}return {value:void 0,done:!0}}function f(e){this.next=function(t){return e.o(t)},this.throw=function(t){return e.s(t)},this.return=function(t){return function(e,t){u(e.g);var i=e.g.j;return i?E(e,"return"in i?i.return:function(e){return {value:e,done:!0}},t,e.g.return):(e.g.return(t),m(e))}(e,t)},this[Symbol.iterator]=function(){return this};}function g(e,t){return t=new f(new _(t)),l&&e.prototype&&l(t,e.prototype),t}if(h.prototype.o=function(e){this.v=e;},h.prototype.s=function(e){this.l={D:e,F:!0},this.h=this.C||this.u;},h.prototype.return=function(e){this.l={return:e},this.h=this.u;},_.prototype.o=function(e){return u(this.g),this.g.j?E(this,this.g.j.next,e,this.g.o):(this.g.o(e),m(this))},_.prototype.s=function(e){return u(this.g),this.g.j?E(this,this.g.j.throw,e,this.g.o):(this.g.s(e),m(this))},s("Array.prototype.entries",(function(e){return e||function(){return function(e,t){e instanceof String&&(e+="");var i=0,n=!1,r={next:function(){if(!n&&i<e.length){var r=i++;return {value:t(r,e[r]),done:!1}}return n=!0,{done:!0,value:void 0}}};return r[Symbol.iterator]=function(){return r},r}(this,(function(e,t){return [e,t]}))}})),"undefined"!=typeof Blob&&("undefined"==typeof FormData||!FormData.prototype.keys)){var T=function(e,t){for(var i=0;i<e.length;i++)t(e[i]);},S=function(e){return e.replace(/\r?\n|\r/g,"\r\n")},R=function(e,t,i){return t instanceof Blob?(i=void 0!==i?String(i+""):"string"==typeof t.name?t.name:"blob",t.name===i&&"[object Blob]"!==Object.prototype.toString.call(t)||(t=new File([t],i)),[String(e),t]):[String(e),String(t)]},C=function(e,t){if(e.length<t)throw new TypeError(t+" argument required, but only "+e.length+" present.")},v="object"==typeof globalThis?globalThis:"object"==typeof window?window:"object"==typeof self?self:this,I=v.FormData,y=v.XMLHttpRequest&&v.XMLHttpRequest.prototype.send,A=v.Request&&v.fetch,b=v.navigator&&v.navigator.sendBeacon,w=v.Element&&v.Element.prototype,O=v.Symbol&&Symbol.toStringTag;O&&(Blob.prototype[O]||(Blob.prototype[O]="Blob"),"File"in v&&!File.prototype[O]&&(File.prototype[O]="File"));try{new File([],"");}catch(e){v.File=function(e,t,i){return e=new Blob(e,i||{}),Object.defineProperties(e,{name:{value:t},lastModified:{value:+(i&&void 0!==i.lastModified?new Date(i.lastModified):new Date)},toString:{value:function(){return "[object File]"}}}),O&&Object.defineProperty(e,O,{value:"File"}),e};}var N=function(e){return e.replace(/\n/g,"%0A").replace(/\r/g,"%0D").replace(/"/g,"%22")},D=function(e){this.i=[];var t=this;e&&T(e.elements,(function(e){if(e.name&&!e.disabled&&"submit"!==e.type&&"button"!==e.type&&!e.matches("form fieldset[disabled] *"))if("file"===e.type){var i=e.files&&e.files.length?e.files:[new File([],"",{type:"application/octet-stream"})];T(i,(function(i){t.append(e.name,i);}));}else "select-multiple"===e.type||"select-one"===e.type?T(e.options,(function(i){!i.disabled&&i.selected&&t.append(e.name,i.value);})):"checkbox"===e.type||"radio"===e.type?e.checked&&t.append(e.name,e.value):(i="textarea"===e.type?S(e.value):e.value,t.append(e.name,i));}));};if((e=D.prototype).append=function(e,t,i){C(arguments,2),this.i.push(R(e,t,i));},e.delete=function(e){C(arguments,1);var t=[];e=String(e),T(this.i,(function(i){i[0]!==e&&t.push(i);})),this.i=t;},e.entries=function e(){var t,i=this;return g(e,(function(e){if(1==e.h&&(t=0),3!=e.h)return t<i.i.length?e=p(e,i.i[t]):(e.h=0,e=void 0),e;t++,e.h=2;}))},e.forEach=function(e,t){C(arguments,1);for(var i=a(this),n=i.next();!n.done;n=i.next()){var r=a(n.value);n=r.next().value,r=r.next().value,e.call(t,r,n,this);}},e.get=function(e){C(arguments,1);var t=this.i;e=String(e);for(var i=0;i<t.length;i++)if(t[i][0]===e)return t[i][1];return null},e.getAll=function(e){C(arguments,1);var t=[];return e=String(e),T(this.i,(function(i){i[0]===e&&t.push(i[1]);})),t},e.has=function(e){C(arguments,1),e=String(e);for(var t=0;t<this.i.length;t++)if(this.i[t][0]===e)return !0;return !1},e.keys=function e(){var t,i,n,r,s=this;return g(e,(function(e){if(1==e.h&&(t=a(s),i=t.next()),3!=e.h)return i.done?void(e.h=0):(n=i.value,r=a(n),p(e,r.next().value));i=t.next(),e.h=2;}))},e.set=function(e,t,i){C(arguments,2),e=String(e);var n=[],r=R(e,t,i),s=!0;T(this.i,(function(t){t[0]===e?s&&(s=!n.push(r)):n.push(t);})),s&&n.push(r),this.i=n;},e.values=function e(){var t,i,n,r,s=this;return g(e,(function(e){if(1==e.h&&(t=a(s),i=t.next()),3!=e.h)return i.done?void(e.h=0):(n=i.value,(r=a(n)).next(),p(e,r.next().value));i=t.next(),e.h=2;}))},D.prototype._asNative=function(){for(var e=new I,t=a(this),i=t.next();!i.done;i=t.next()){var n=a(i.value);i=n.next().value,n=n.next().value,e.append(i,n);}return e},D.prototype._blob=function(){var e="----formdata-polyfill-"+Math.random(),t=[],i="--"+e+'\r\nContent-Disposition: form-data; name="';return this.forEach((function(e,n){return "string"==typeof e?t.push(i+N(S(n))+'"\r\n\r\n'+S(e)+"\r\n"):t.push(i+N(S(n))+'"; filename="'+N(e.name)+'"\r\nContent-Type: '+(e.type||"application/octet-stream")+"\r\n\r\n",e,"\r\n")})),t.push("--"+e+"--"),new Blob(t,{type:"multipart/form-data; boundary="+e})},D.prototype[Symbol.iterator]=function(){return this.entries()},D.prototype.toString=function(){return "[object FormData]"},w&&!w.matches&&(w.matches=w.matchesSelector||w.mozMatchesSelector||w.msMatchesSelector||w.oMatchesSelector||w.webkitMatchesSelector||function(e){for(var t=(e=(this.document||this.ownerDocument).querySelectorAll(e)).length;0<=--t&&e.item(t)!==this;);return -1<t}),O&&(D.prototype[O]="FormData"),y){var P=v.XMLHttpRequest.prototype.setRequestHeader;v.XMLHttpRequest.prototype.setRequestHeader=function(e,t){P.call(this,e,t),"content-type"===e.toLowerCase()&&(this.B=!0);},v.XMLHttpRequest.prototype.send=function(e){e instanceof D?(e=e._blob(),this.B||this.setRequestHeader("Content-Type",e.type),y.call(this,e)):y.call(this,e);};}A&&(v.fetch=function(e,t){return t&&t.body&&t.body instanceof D&&(t.body=t.body._blob()),A.call(this,e,t)}),b&&(v.navigator.sendBeacon=function(e,t){return t instanceof D&&(t=t._asNative()),b.call(this,e,t)}),v.FormData=D;}}();const FD=()=>{const e=kC("AREAS");0===e.length&&e.push(rI.GLOBAL);return cS(e).call(e,((e,t,i)=>{const n=BD(t);return n?0===i?n:"".concat(e,",").concat(n):e}),"")},BD=e=>e===rI.OVERSEA?"".concat(aI.ASIA,",").concat(aI.EUROPE,",").concat(aI.AFRICA,",").concat(aI.NORTH_AMERICA,",").concat(aI.SOUTH_AMERICA,",").concat(aI.OCEANIA):aI[e],jD=e=>{const t={CODE:"",WEBCS_DOMAIN:[],WEBCS_DOMAIN_BACKUP_LIST:[],PROXY_CS:[],CDS_AP:[],ACCOUNT_REGISTER:[],UAP_AP:[],EVENT_REPORT_DOMAIN:[],EVENT_REPORT_BACKUP_DOMAIN:[],LOG_UPLOAD_SERVER:[],PROXY_SERVER_TYPE3:[]};return e.map((e=>{const i=cI[e],n=Object.keys(i);n&&n.map((e=>{"CODE"!==e&&(t[e]=t[e].concat(i[e]));}));})),t},GD={GLOBAL:{ASIA:[rI.CHINA,rI.JAPAN,rI.INDIA,rI.KOREA,rI.HKMC],EUROPE:[],NORTH_AMERICA:[rI.US],SOUTH_AMERICA:[],OCEANIA:[],AFRICA:[]}},WD=Object.keys(GD[rI.GLOBAL]),HD=[rI.CHINA,rI.NORTH_AMERICA,rI.EUROPE,rI.ASIA,rI.JAPAN,rI.INDIA,rI.OCEANIA,rI.SOUTH_AMERICA,rI.AFRICA,rI.KOREA,rI.HKMC,rI.US],KD=function(e,t){let i=[];if(Pr(e).call(e,rI.GLOBAL)){const s=[rI.GLOBAL,rI.OVERSEA],o=Object.keys(cI);if(t===rI.GLOBAL)throw new xv(xg.INVALID_PARAMS,"GLOBAL is an invalid excludedArea value");if(t===rI.CHINA)i=[rI.OVERSEA];else if(r=t,Pr(WD).call(WD,r)){const e=(n=t,GD[rI.GLOBAL][n]||[]),r=[...s,t,...e];i=o.filter((e=>!Pr(r).call(r,e)));}else if(function(e){let t=!1;return WD.forEach((i=>{var n;Pr(n=GD[rI.GLOBAL][i]).call(n,e)&&(t=!0);})),t}(t)){const e=function(e){let t;return WD.forEach((i=>{var n;Pr(n=GD[rI.GLOBAL][i]).call(n,e)&&(t=i);})),t}(t),n=[...s,e,t];i=o.filter((e=>!Pr(n).call(n,e)));}else i=e;i=function(e){const t=[];return HD.forEach((i=>{Pr(e).call(e,i)&&t.push(i);})),t.concat(e.filter((e=>!Pr(HD).call(HD,e))))}(i);}else i=e;var n,r;return i};function YD(e){var t,i;if(!e&&Pr(t=kC("AREAS")).call(t,rI.EXTENSIONS))return KC.debug("update area from ap : reset"),void qD(sv,!0);if(!Pr(i=kC("AREAS")).call(i,rI.GLOBAL)||!e)return;let n=cI.EXTENSIONS;n&&(n={CODE:BD(rI.EXTENSIONS),WEBCS_DOMAIN:["ap-web-1-".concat(e,".agora.io")],WEBCS_DOMAIN_BACKUP_LIST:["ap-web-2-".concat(e,".ap.sd-rtn.com")],PROXY_CS:["proxy-ap-web-".concat(e,".agora.io")],CDS_AP:["cds-ap-web-1-".concat(e,".agora.io"),"cds-ap-web-2-".concat(e,".ap.sd-rtn.com")],ACCOUNT_REGISTER:["sua-ap-web-1-".concat(e,".agora.io"),"sua-ap-web-2-".concat(e,".ap.sd-rtn.com")],UAP_AP:["uap-ap-web-1-".concat(e,".agora.io"),"uap-ap-web-2-".concat(e,".ap.sd-rtn.com")],EVENT_REPORT_DOMAIN:["statscollector-1-".concat(e,".agora.io")],EVENT_REPORT_BACKUP_DOMAIN:["statscollector-2-".concat(e,".agora.io")],LOG_UPLOAD_SERVER:["logservice-".concat(e,".agora.io")],PROXY_SERVER_TYPE3:["webrtc-cloud-proxy-".concat(e,".agora.io")]},KC.debug("update area from ap success: ".concat(e,",config is "),n),LC("AREAS",[rI.EXTENSIONS],!0),Object.keys(n).map((e=>{if("LOG_UPLOAD_SERVER"===e||"EVENT_REPORT_DOMAIN"===e||"EVENT_REPORT_BACKUP_DOMAIN"===e||"PROXY_SERVER_TYPE3"===e){LC(e,n[e][0]);}else LC(e,n[e]);})));}function qD(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const i=rv.reportApiInvoke(null,{name:sT.SET_AREA,options:e,tag:oT.TRACER});try{let n=[];if("string"==typeof e&&(n=[e]),Array.isArray(e)&&(e.forEach((e=>{if(!Pr(oI).call(oI,e))throw new xv(xg.INVALID_PARAMS,"invalid area code")})),n=e),"[object Object]"===Object.prototype.toString.call(e)){const{areaCode:t,excludedArea:i}=e;if(!t)throw new xv(xg.INVALID_PARAMS,"area code is needed");let r=t;"string"==typeof t&&(r=[t]),n=i?KD(r,i):r;}if(!t){if(MC.AREAS){const e=new xv(xg.PROHIBITED_OPERATION,"setArea is prohibited because of config-distribute");return i.onError(e),void KC.warning("setArea is prohibited because of config-distribute")}if(Pr(n).call(n,rI.GLOBAL)&&kC("AREAS")===rI.EXTENSIONS){const e=new xv(xg.PROHIBITED_OPERATION,"setArea is prohibited because of ap extensions");return i.onError(e),void KC.warning("setArea is prohibited because of ap extensions")}}LC("AREAS",n,t);const r=jD(n);Object.keys(r).map((e=>{if("LOG_UPLOAD_SERVER"===e||"EVENT_REPORT_DOMAIN"===e||"EVENT_REPORT_BACKUP_DOMAIN"===e||"PROXY_SERVER_TYPE3"===e){LC(e,r[e][0]);}else LC(e,r[e]);})),KC.debug("set area success:",n.join(","));}catch(e){throw i.onError(e),e}i.onSuccess();}function JD(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n);}return i}function zD(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?JD(Object(i),!0).forEach((function(t){nu(e,t,i[t]);})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):JD(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t));}));}return e}let XD=1;function QD(e,t,i,n,r){XD+=1;const s={sid:i.sid,command:"convergeAllocateEdge",uid:"666",appId:i.appId,ts:Math.floor(Date.now()/1e3),seq:XD,requestId:XD,version:OC,cname:i.cname},o={service_name:t,json_body:JSON.stringify(s)};let a,c,d=e[0];return XT((async()=>{a=Date.now();const e=await VD(d,{data:o,cancelToken:n,headers:{"X-Packet-Service-Type":"0","X-Packet-URI":"61"}});if(c=Date.now()-a,0!==e.code){const t=new xv(xg.UNEXPECTED_RESPONSE,"live streaming ap error, code"+e.code,{retry:!0,responseTime:c});throw KC.error(t.toString()),t}const i=JSON.parse(e.json_body);if(200!==i.code){const e=new xv(xg.UNEXPECTED_RESPONSE,"live streaming app center error, code: ".concat(i.code,", reason: ").concat(i.reason),{code:i.code,responseTime:c});throw KC.error(e.toString()),e}if(!i.servers||0===i.servers.length){const e=new xv(xg.UNEXPECTED_RESPONSE,"live streaming app center empty server",{code:i.code,responseTime:c});throw KC.error(e.toString()),e}const r=function(e,t){return {addressList:e.servers.map((e=>"wss://".concat(e.address.replace(/\./g,"-"),".").concat(kC("WORKER_DOMAIN"),":").concat(e.wss,"?serviceName=").concat(encodeURIComponent(t)))),workerToken:e.workerToken,vid:e.vid}}(i,t);return kC("LIVE_STREAMING_ADDRESS")&&(r.addressList=kC("LIVE_STREAMING_ADDRESS")instanceof Array?kC("LIVE_STREAMING_ADDRESS"):[kC("LIVE_STREAMING_ADDRESS")]),zD(zD({},r),{},{responseTime:c})}),((n,r)=>(rv.apworkerEvent(i.sid,{success:!0,sc:200,serviceName:t,responseDetail:JSON.stringify(n.addressList),firstSuccess:0===r,responseTime:c,serverIp:e[r%e.length]}),!1)),((n,r)=>(rv.apworkerEvent(i.sid,{success:!1,sc:n.data&&n.data.code||200,serviceName:t,responseTime:c,serverIp:e[r%e.length]}),!!(n.code!==xg.OPERATION_ABORTED&&n.code!==xg.UNEXPECTED_RESPONSE||n.data&&n.data.retry)&&(d=e[(r+1)%e.length],!0))),r)}let ZD=1;function $D(e,t,i,n){let{url:r,areaCode:s}=e;const o=Date.now();let a;const[c,d]=rP(t,s,[hy.CHOOSE_SERVER]);let l=RT.networkState;return XT((async()=>{l&&RT.networkState===hT.OFFLINE&&RT.onlineWaiter&&await tg.race([RT.onlineWaiter,UT(n&&n.maxRetryTimeout||JT.maxRetryTimeout)]),l=RT.networkState;const{data:e,headers:s}=await VD(r,{data:c,cancelToken:i,headers:{"Content-Type":"multipart/form-data;"}},!0,!0);a="1"===s.http3?1:-1,rv.reportResourceTiming(r,t.sid),tP(e,r,t,o,[hy.CHOOSE_SERVER],a);const d=SD(e,hy.CHOOSE_SERVER);return iP(d),ED(d,r)}),(e=>(e&&rv.joinChooseServer(t.sid,{lts:o,succ:!0,csAddr:r,opid:d,serverList:e.gatewayAddrs.map((e=>e.address)),ec:null,cid:e.cid.toString(),uid:e.uid.toString(),csIp:e.csIp,unilbsServerIds:[hy.CHOOSE_SERVER].toString(),isHttp3:a}),!1)),(e=>e.code!==xg.OPERATION_ABORTED&&(e.code===xg.CAN_NOT_GET_GATEWAY_SERVER?e.data.retry:(rv.joinChooseServer(t.sid,{lts:o,succ:!1,csAddr:r,serverList:null,opid:d,ec:e.code,csIp:e.data&&e.data.csIp,unilbsServerIds:[hy.CHOOSE_SERVER].toString(),extend:JSON.stringify({networkState:l}),isHttp3:a}),KC.warning("[".concat(t.clientId,"] Choose server network error, retry"),e),!0))),n)}function eP(e,t,i,n){let r,{url:s,areaCode:o,serviceIds:a}=e;const c=Date.now(),[d,l]=rP(t,o,a);let h;return XT((async()=>{h&&RT.networkState===hT.OFFLINE&&RT.onlineWaiter&&await tg.race([RT.onlineWaiter,UT(n&&n.maxRetryTimeout||JT.maxRetryTimeout)]),h=RT.networkState;const{data:e,headers:o}=await VD(s,{data:d,cancelToken:i,headers:{"Content-Type":"multipart/form-data;"}},!0,!0);r="1"===o.http3?1:-1,rv.reportResourceTiming(s,t.sid),tP(e,s,t,c,a,r);const l=SD(e,hy.CHOOSE_SERVER),u=SD(e,"proxy5"===t.cloudProxyServer?hy.CLOUD_PROXY_5:"proxy3"===t.cloudProxyServer||"proxy4"===t.cloudProxyServer?hy.CLOUD_PROXY:hy.CLOUD_PROXY_FALLBACK);return iP(l),{gatewayInfo:ED(l,s),proxyInfo:u,url:s}}),(e=>(e.gatewayInfo&&rv.joinChooseServer(t.sid,{lts:c,succ:!0,csAddr:s,serverList:e.gatewayInfo.gatewayAddrs.map((e=>e.address)),ec:null,opid:l,cid:e.gatewayInfo.cid.toString(),uid:e.gatewayInfo.uid.toString(),csIp:e.gatewayInfo.csIp,unilbsServerIds:a.toString(),isHttp3:r}),e.proxyInfo&&rv.joinWebProxyAP(t.sid,{lts:c,sucess:1,apServerAddr:s,turnServerAddrList:e.proxyInfo.addresses.map((e=>e.ip)).join(","),errorCode:null,eventType:t.cloudProxyServer,unilbsServerIds:a.toString()}),!1)),(e=>e.code!==xg.OPERATION_ABORTED&&(e.code===xg.CAN_NOT_GET_GATEWAY_SERVER?e.data.retry:(rv.joinWebProxyAP(t.sid,{lts:c,sucess:0,apServerAddr:s,turnServerAddrList:null,errorCode:e.code,eventType:t.cloudProxyServer,unilbsServerIds:a.toString(),extend:JSON.stringify({networkState:h})}),KC.warning("[".concat(t.clientId,"] multi unilbs network error, retry"),e),!0))),n)}const tP=(e,t,i,n,r,s)=>{const o=[],a=o=>{4096===o.flag?rv.joinChooseServer(i.sid,{lts:n,succ:!1,csAddr:t,opid:e.opid,serverList:null,ec:o.error.message,csIp:o.error.data&&o.error.data.csIp,unilbsServerIds:r.toString(),isHttp3:s}):1048576!==o.flag&&4194304!==o.flag&&4194310!==o.flag||rv.joinWebProxyAP(i.sid,{lts:n,sucess:0,apServerAddr:t,turnServerAddrList:null,errorCode:o.error.code,eventType:i.cloudProxyServer,unilbsServerIds:r.toString()});};if(e.response_body.forEach((t=>{const i=t.buffer.code;if(23===t.uri&&0===i&&!t.buffer.edges_services)if(4194310===t.buffer.flag)KC.warning("no edge services in ap response of proxy fallback, will not set proxy in iceServers"),t.buffer.edges_services=[];else {const i={error:new xv(xg.CAN_NOT_GET_GATEWAY_SERVER,"no edge services in ap response",{retry:!0,csIp:e.detail[502]}),flag:t.buffer.flag};o.push(i),a(i);}if(0!==i){const n=kI(i),r={error:new xv(xg.CAN_NOT_GET_GATEWAY_SERVER,n.desc,{desc:n.desc,retry:n.retry,csIp:e.detail[502]}),flag:t.buffer.flag};4194310===t.buffer.flag?KC.warning(r.error.toString()):o.push(r),a(r);}})),o.length)throw KC.warning("[".concat(i.clientId,"] multi unilbs ").concat(t," failed, ").concat(o.map((e=>"flag: ".concat(e.flag,", message: ").concat(e.error.message,", retry: ").concat(e.error.data.retry))).join(" | "))),new xv(xg.CAN_NOT_GET_GATEWAY_SERVER,o.map((e=>"flag: ".concat(e.flag,", message: ").concat(e.error.message))).join(" | "),{retry:!!o.find((e=>e.error.data.retry)),csIp:e.detail[502],desc:[...new Set(o.map((e=>{var t;return null==e||null===(t=e.error)||void 0===t||null===(t=t.data)||void 0===t?void 0:t.desc})).filter((e=>!!e)))]})},iP=e=>{var t,i,n,r;if(e.addresses&&0===e.addresses.length&&0===e.code)throw new xv(xg.CAN_NOT_GET_GATEWAY_SERVER,"void gateway address",{retry:!0,csIp:e.detail&&e.detail[502]});kC("AP_AREA")&&(null!==(n=e.detail)&&void 0!==n&&n[23]&&"string"==typeof(null===(r=e.detail)||void 0===r?void 0:r[23])?YD(e.detail[23].toLowerCase()):YD());if(null!==(t=e.detail)&&void 0!==t&&t[19]&&"string"==typeof(null===(i=e.detail)||void 0===i?void 0:i[19])){const t=e.detail[19],i=null==t?void 0:t.split(";");for(let t=0;t<i.length;t++){var s;const n=fy(s=i[t]).call(s);e.addresses[t]&&i&&(e.addresses[t].fingerprint=n);}}if(kC("GATEWAY_ADDRESS")&&kC("GATEWAY_ADDRESS").length>0){KC.debug("assign gateway address to",kC("GATEWAY_ADDRESS"));const t=kC("GATEWAY_ADDRESS").map((t=>{var i,n;const r=null!==(i=null===(n=e.addresses.find((e=>e.ip===t.ip&&e.port===t.port)))||void 0===n?void 0:n.fingerprint)&&void 0!==i?i:"";return {ip:t.ip,port:t.port,ticket:e.addresses[0]&&e.addresses[0].ticket,fingerprint:r}}));e.addresses=t;}},nP=(e,t)=>{if(e.response_body&&e.response_body.length){const t=e.response_body[0];if(0!==t.buffer.code){const e=kI(t.buffer.code);throw new xv(xg.UPDATE_TICKET_FAILED,"[".concat(t.buffer.code,"]: ").concat(e.desc),{retry:e.retry})}return t.buffer.ticket}throw KC.debug("update ticket request received ap response without response body:",t),new xv(xg.UPDATE_TICKET_FAILED,"cannot find response body from ap response",{retry:!1})},rP=(e,t,i)=>{const n=Math.floor(Math.random()*10**12),r={appid:e.appId,client_ts:Date.now(),opid:n,sid:e.sid,request_bodies:[{uri:22,buffer:{cname:e.cname,detail:zD({6:e.stringUid,11:t,12:kC("USE_NEW_TOKEN")?"1":void 0,22:t},kC("AP_RTM")?{26:"RTM2"}:{}),key:e.token,service_ids:i,uid:e.uid||0}}]};r.request_bodies.forEach((t=>{e.multiIP&&e.multiIP.gateway_ip&&(t.buffer.detail[5]=JSON.stringify({vocs_ip:[e.multiIP.uni_lbs_ip],vos_ip:[e.multiIP.gateway_ip]}));}));const s=new FormData;return s.append("request",JSON.stringify(r)),[s,n]},sP=(e,t)=>{const i=Math.floor(Math.random()*10**12),n={appid:e.appId,client_ts:Date.now(),opid:i,sid:e.sid,request_bodies:[{uri:28,buffer:{cname:e.cname,detail:{1:"",6:e.stringUid,12:"1"},token:e.token,service_ids:t,uid:e.uid||0,edges_services:e.apResponse.addresses.map((e=>({ip:e.ip,port:e.port})))}}]},r=new FormData;return r.append("request",JSON.stringify(n)),[r,i]};let oP=0;function aP(e){return tg.all(e.map((e=>e.then((e=>{throw e}),(e=>e))))).then((e=>{throw e}),(e=>e))}const cP=async e=>{let{fragementLength:t,referenceList:i,asyncMapHandler:n,allFailedhandler:r,promisesCollector:s}=e,o=0;const a=t;let c,d=0;const l=async()=>{const e=(()=>{const e=o*a,t=e+a;return i.slice(e,t).map(n)})();s&&s.push(...e);try{c=await aP(e);}catch(e){if(d+=a,o++,!(d>=i.length))return void await l();r(e);}e.forEach((e=>e.cancel()));};return await l(),c};async function dP(e,t,i,n){const r=async function(e,t,i,n){let r=null;const s=[],o=async()=>{const r=kC("WEBCS_DOMAIN").slice(0,kC("AJAX_REQUEST_CONCURRENT")).map((t=>({url:e.proxyServer?"https://".concat(e.proxyServer,"/ap/?url=").concat(t+"/api/v2/transpond/webrtc?v=2"):"https://".concat(t,"/api/v2/transpond/webrtc?v=2"),areaCode:FD()}))),o=n.recordJoinChannelService({startTs:Date.now(),status:"pending",service:"chooseServer",urls:r.map((e=>e.url))}),a=await cP({fragementLength:kC("FRAGEMENT_LENGTH"),referenceList:r,asyncMapHandler:n=>(KC.debug("[".concat(e.clientId,"] Connect to choose_server:"),n.url),$D(n,e,t,i)),allFailedhandler:e=>{throw n.recordJoinChannelService({endTs:Date.now(),status:"error",errors:e},o),e[0]},promisesCollector:s});return n.recordJoinChannelService({endTs:Date.now(),status:"success"},o),a},a=async()=>{if(await UT(1e3),null!==r)return r;const o=kC("WEBCS_DOMAIN_BACKUP_LIST").map((t=>({url:e.proxyServer?"https://".concat(e.proxyServer,"/ap/?url=").concat(t+"/api/v2/transpond/webrtc?v=2"):"https://".concat(t,"/api/v2/transpond/webrtc?v=2"),areaCode:FD()}))),a=n.recordJoinChannelService({endTs:void 0,startTs:Date.now(),status:"pending",service:"chooseServer",urls:o.map((e=>e.url))}),c=await cP({fragementLength:kC("FRAGEMENT_LENGTH"),referenceList:o,asyncMapHandler:n=>(KC.debug("[".concat(e.clientId,"] Connect to backup choose_server:"),n.url),$D(n,e,t,i)),allFailedhandler:e=>{throw n.recordJoinChannelService({endTs:Date.now(),status:"error",errors:e},a),e[0]},promisesCollector:s});return n.recordJoinChannelService({endTs:Date.now(),status:"success"},a),c};try{return r=await aP([o(),a()]),s.length&&s.forEach((e=>e.cancel&&"function"==typeof e.cancel&&e.cancel())),r}catch(e){throw e[0]}}(e,t,i,n);return {gatewayInfo:await r}}async function lP(e,t,i,n,r){const s=e.cloudProxyServer;if("disabled"===s){if(!n)return;if(e.useLocalAccessPoint)return await dP(e,t,i,r);if(kC("JOIN_WITH_FALLBACK_MEDIA_PROXY")){const{gatewayInfo:n,proxyInfo:s}=await pP(e,t,i,r);return e.turnServer&&"auto"!==e.turnServer.mode||(e.turnServer={mode:"manual",servers:s.map((e=>({turnServerURL:e.address,tcpport:e.tcpport||ov.tcpport,udpport:e.udpport||ov.udpport,username:e.username||ov.username,password:e.password||ov.password,forceturn:!1,security:!0})))}),{gatewayInfo:n}}return await dP(e,t,i,r)}const{proxyInfo:o,gatewayInfo:a}=await pP(e,t,i,r),c={gatewayInfo:a};return e.turnServer={mode:"manual",servers:o.map((e=>({turnServerURL:e.address,tcpport:"proxy3"===s?void 0:e.tcpport?e.tcpport:ov.tcpport,udpport:"proxy4"===s?void 0:e.udpport?e.udpport:ov.udpport,username:e.username||ov.username,password:e.password||ov.password,forceturn:"proxy4"!==s,security:"proxy5"===s})))},KC.debug("[".concat(e.clientId,"] set proxy server: ").concat(e.proxyServer,", mode: ").concat(s)),c}async function hP(e,t,i,n,r){const s=kC("ACCOUNT_REGISTER").slice(0,kC("AJAX_REQUEST_CONCURRENT"));let o=[];o=t.proxyServer?s.map((e=>"https://".concat(t.proxyServer,"/ap/?url=").concat(e+"/api/v1"))):s.map((e=>"https://".concat(e,"/api/v1")));const a=null==r?void 0:r.recordJoinChannelService({startTs:Date.now(),status:"pending",service:"stringUID",urls:o});try{const s=await async function(e,t,i,n,r){const s=Date.now(),o={sid:i.sid,opid:10,appid:i.appId,string_uid:t};let a=e[0];const c=await XT((()=>VD(a+"".concat(-1===a.indexOf("?")?"?":"&","action=stringuid"),{data:o,cancelToken:n,headers:{"X-Packet-Service-Type":0,"X-Packet-URI":72}})),((i,n)=>{if(0===i.code){if(i.uid<=0||i.uid>=Math.pow(2,32))throw KC.error("Invalid Uint Uid ".concat(t," => ").concat(i.uid),i),rv.reqUserAccount(o.sid,{lts:s,success:!1,serverAddr:a,stringUid:o.string_uid,uid:i.uid,errorCode:xg.INVALID_UINT_UID_FROM_STRING_UID,extend:o}),new xv(xg.INVALID_UINT_UID_FROM_STRING_UID);return rv.reqUserAccount(o.sid,{lts:s,success:!0,serverAddr:a,stringUid:o.string_uid,uid:i.uid,errorCode:null,extend:o}),!1}const r=kI(i.code);return r.retry&&(a=e[(n+1)%e.length]),rv.reqUserAccount(o.sid,{lts:s,success:!1,serverAddr:a,stringUid:o.string_uid,uid:i.uid,errorCode:r.desc,extend:o}),r.retry}),((t,i)=>t.code!==xg.OPERATION_ABORTED&&(rv.reqUserAccount(o.sid,{lts:s,success:!1,serverAddr:a,stringUid:o.string_uid,uid:null,errorCode:t.code,extend:o}),a=e[(i+1)%e.length],!0)),r);if(0!==c.code){const e=kI(c.code);throw new xv(xg.UNEXPECTED_RESPONSE,e.desc)}return c}(o,e,t,i,n);return null==r||r.recordJoinChannelService({status:"success",endTs:Date.now()},a),s.uid}catch(e){throw null==r||r.recordJoinChannelService({status:"error",endTs:Date.now(),errors:[e]},a),e}}async function uP(e,t,i){const n=kC("CDS_AP").slice(0,kC("AJAX_REQUEST_CONCURRENT")).map((t=>e.proxyServer?"https://".concat(e.proxyServer,"/ap/?url=").concat(t+"/api/v1"):"https://".concat(t,"/api/v1?action=config"))).map((n=>function(e,t,i,n){const r=pg(),s={flag:64,cipher_method:0,features:{device:r.name,system:r.os,system_general:navigator.userAgent,vendor:t.appId,version:OC,cname:t.cname,sid:t.sid,session_id:t.sid,detail:"",proxyServer:t.proxyServer}};return XT((()=>VD(e,{data:s,timeout:1e3,cancelToken:i,headers:{"X-Packet-Service-Type":0,"X-Packet-URI":54}})),void 0,(e=>e.code!==xg.OPERATION_ABORTED),n)}(n,e,t,i)));let r=null,s=null,o={};try{r=await aP(n);}catch(e){if(e.code===xg.OPERATION_ABORTED)throw e;s=e;}n.forEach((e=>e.cancel()));if(rv.reportApiInvoke(e.sid,{name:sT.REQUEST_CONFIG_DISTRIBUTE,options:{error:s,res:r}}).onSuccess(),r&&r.test_tags)try{o=function(e){if(!e.test_tags)return {};const t=e.test_tags,i=Object.keys(t),n={};return i.forEach((e=>{var i;const r=fy(i=e.slice(4)).call(i),s=JSON.parse(t[e])[1];n[r]=s;})),n}(r);}catch(e){}return o}async function pP(e,t,i,n){const r=kC("PROXY_SERVER_TYPE3"),s=(e,t,i)=>{let n=i||r;return Array.isArray(n)&&(n=t%2==0?r[1]:r[0]),"https://".concat(n,"/ap/?url=").concat(e)};let o=null;const a=[],c=async()=>{const r=kC("WEBCS_DOMAIN").slice(0,kC("AJAX_REQUEST_CONCURRENT")).map(((t,i)=>{let n;return n="disabled"===e.cloudProxyServer&&e.proxyServer?s("".concat(t,"/api/v2/transpond/webrtc?v=2"),i,e.proxyServer):"disabled"===e.cloudProxyServer||"fallback"===e.cloudProxyServer?"https://".concat(t,"/api/v2/transpond/webrtc?v=2"):s("".concat(t,"/api/v2/transpond/webrtc?v=2"),i),{url:n,areaCode:FD(),serviceIds:[hy.CHOOSE_SERVER,"proxy5"===e.cloudProxyServer?hy.CLOUD_PROXY_5:"proxy3"===e.cloudProxyServer||"proxy4"===e.cloudProxyServer?hy.CLOUD_PROXY:hy.CLOUD_PROXY_FALLBACK]}})),o=n.recordJoinChannelService({startTs:Date.now(),status:"pending",service:"chooseServer",urls:r.map((e=>e.url))}),c=await cP({fragementLength:kC("FRAGEMENT_LENGTH"),referenceList:r,asyncMapHandler:n=>(KC.debug("[".concat(e.clientId,"] Connect to choose_server:"),n.url),eP(n,e,t,i)),allFailedhandler:e=>{throw n.recordJoinChannelService({endTs:Date.now(),status:"error",errors:e},o),e[0]},promisesCollector:a});return n.recordJoinChannelService({endTs:Date.now(),status:"success"},o),c},d=async()=>{if(await UT(1e3),null!==o)return o;const r=kC("WEBCS_DOMAIN_BACKUP_LIST").map(((t,i)=>{let n;return n="disabled"===e.cloudProxyServer&&e.proxyServer?s("".concat(t,"/api/v2/transpond/webrtc?v=2"),i,e.proxyServer):"disabled"===e.cloudProxyServer||"fallback"===e.cloudProxyServer?"https://".concat(t,"/api/v2/transpond/webrtc?v=2"):s("".concat(t,"/api/v2/transpond/webrtc?v=2"),i),{url:n,areaCode:FD(),serviceIds:[hy.CHOOSE_SERVER,"proxy5"===e.cloudProxyServer?hy.CLOUD_PROXY_5:"proxy3"===e.cloudProxyServer||"proxy4"===e.cloudProxyServer?hy.CLOUD_PROXY:hy.CLOUD_PROXY_FALLBACK]}})),c=n.recordJoinChannelService({startTs:Date.now(),status:"pending",service:"chooseServer",urls:r.map((e=>e.url))}),d=await cP({fragementLength:kC("FRAGEMENT_LENGTH"),referenceList:r,asyncMapHandler:n=>(KC.debug("[".concat(e.clientId,"] Connect to backup choose_server:"),n.url),eP(n,e,t,i)),allFailedhandler:e=>{throw n.recordJoinChannelService({endTs:Date.now(),status:"error",errors:e},c),e[0]},promisesCollector:a});return n.recordJoinChannelService({endTs:Date.now(),status:"success"},c),d};let l,h,u;try{({gatewayInfo:l,proxyInfo:h,url:u}=await aP([c(),d()]));}catch(e){throw e[0]}if(a.length&&a.forEach((e=>e.cancel&&"function"==typeof e.cancel&&e.cancel())),!l||!h)throw new xv(xg.UNEXPECTED_ERROR,"missing gateway or proxy response").print();if(e.apUrl=u,"disabled"!==e.cloudProxyServer&&Array.isArray(r)&&u){const t=/^https?:\/\/(.+?)(\/.*)?$/.exec(u)[1];Pr(r).call(r,t)&&(e.proxyServer=t,KC.setProxyServer(t),rv.setProxyServer(t));}return o={gatewayInfo:l,proxyInfo:await RD(h,l.uid)},o}async function _P(e,t,i,n){const r=kC("UAP_AP").slice(0,kC("AJAX_REQUEST_CONCURRENT")).map((e=>t.proxyServer?"https://".concat(t.proxyServer,"/ap/?url=").concat(e+"/api/v1?action=uap"):"https://".concat(e,"/api/v1?action=uap")));return await QD(r,e,t,i,n)}async function EP(e,t,i){const n=kC("UAP_AP").slice(0,kC("AJAX_REQUEST_CONCURRENT")).map((t=>e.proxyServer?"https://".concat(e.proxyServer,"/ap/?url=").concat(t+"/api/v1?action=uap"):"https://".concat(t,"/api/v1?action=uap"))).map((n=>function(e,t,i,n){const r={command:"convergeAllocateEdge",sid:t.sid,appId:t.appId,token:t.token,ts:Date.now(),version:OC,cname:t.cname,uid:t.uid.toString(),requestId:ZD,seq:ZD};ZD+=1;const s={service_name:"tele_channel",json_body:JSON.stringify(r)};return XT((async()=>{const t=await VD(e,{data:s,cancelToken:i,headers:{"X-Packet-Service-Type":0,"X-Packet-URI":61}});if(0!==t.code){const e=new xv(xg.UNEXPECTED_RESPONSE,"cross channel ap error, code"+t.code,{retry:!0});throw KC.error(e.toString()),e}const n=JSON.parse(t.json_body);if(200!==n.code){const e=new xv(xg.UNEXPECTED_RESPONSE,"cross channel app center error, code: ".concat(n.code,", reason: ").concat(n.reason));throw KC.error(e.toString()),e}if(!n.servers||0===n.servers.length){const e=new xv(xg.UNEXPECTED_RESPONSE,"cross channel app center empty server");throw KC.error(e.toString()),e}return {vid:n.vid,workerToken:n.workerToken,addressList:(kC("CHANNEL_MEDIA_RELAY_SERVERS")||n.servers).map((e=>"wss://".concat(e.address.replace(/\./g,"-"),".").concat(kC("WORKER_DOMAIN"),":").concat(e.wss)))}}),void 0,(e=>!!(e.code!==xg.OPERATION_ABORTED&&e.code!==xg.UNEXPECTED_RESPONSE||e.data&&e.data.retry)),n)}(n,e,t,i)));try{const e=await aP(n);return n.forEach((e=>e.cancel())),e}catch(e){throw e[0]}}async function mP(e,t,i){let n=null;const r=[],s=async s=>{const o=kC(s?"WEBCS_DOMAIN_BACKUP_LIST":"WEBCS_DOMAIN").map((t=>e.proxyServer?"https://".concat(e.proxyServer,"/ap/?url=").concat(t+"/api/v2/transpond/webrtc?v=2"):"https://".concat(t,"/api/v2/transpond/webrtc?v=2")));return s&&(await UT(1e3),null!==n)?n:await cP({fragementLength:kC("FRAGEMENT_LENGTH"),referenceList:o,asyncMapHandler:n=>(KC.debug("[".concat(e.clientId,"] update ticket, Connect to ").concat(s?"backup":""," choose_server:"),n),function(e,t,i,n){const[r]=sP(t,[hy.CHOOSE_SERVER]);let s=RT.networkState;return XT((async()=>{s&&RT.networkState===hT.OFFLINE&&RT.onlineWaiter&&await tg.race([RT.onlineWaiter,UT(n&&n.maxRetryTimeout||JT.maxRetryTimeout)]),s=RT.networkState;const t=await VD(e,{data:r,cancelToken:i,headers:{"Content-Type":"multipart/form-data;"}},!0);return nP(t,e)}),(()=>!1),(e=>e.code!==xg.OPERATION_ABORTED&&(e.code===xg.UPDATE_TICKET_FAILED?e.data.retry:(KC.warning("[".concat(t.clientId,"] update ticket network error, retry"),e),!0))),n)}(n,e,t,i)),allFailedhandler:e=>{throw e[0]},promisesCollector:r})};try{return n=await aP([s(!1),s(!0)]),r.length&&r.forEach((e=>e.cancel&&"function"==typeof e.cancel&&e.cancel())),n}catch(e){throw e[0]}}function fP(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n);}return i}function gP(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?fP(Object(i),!0).forEach((function(t){nu(e,t,i[t]);})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):fP(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t));}));}return e}class TP extends iT{constructor(){super(),nu(this,"configs",void 0),nu(this,"joinInfo",void 0),nu(this,"cancelToken",void 0),nu(this,"retryConfig",{timeout:3e3,timeoutFactor:1.5,maxRetryCount:1,maxRetryTimeout:1e4}),nu(this,"interval",void 0),nu(this,"mutex",new YT("config-distribute")),nu(this,"mutableParamsRead",!1);}startGetConfigDistribute(e,t){this.joinInfo=e,this.cancelToken=t,this.interval&&this.stopGetConfigDistribute(),kC("ENABLE_CONFIG_DISTRIBUTE")&&(this.updateConfigDistribute(),this.interval=window.setInterval((()=>{this.updateConfigDistribute();}),kC("CONFIG_DISTRIBUTE_INTERVAL")));}stopGetConfigDistribute(){this.interval&&clearInterval(this.interval),this.interval=void 0,this.joinInfo=void 0,this.cancelToken=void 0;}async awaitConfigDistributeComplete(){if(!this.mutex.isLocked)return;(await this.mutex.lock())();}async updateConfigDistribute(){if(!this.mutableParamsRead){this.mutableParamsRead=!0;rv.reportApiInvoke(null,{options:void 0,name:sT.LOAD_CONFIG_FROM_LOCALSTORAGE,tag:oT.TRACER}).onSuccess(JSON.stringify(MC));}if(!this.joinInfo||!this.cancelToken||!this.retryConfig)return void KC.debug("[config-distribute] get config distribute interrupted have no joininfo");let e;const t=await this.mutex.lock();try{e=await uP(this.joinInfo,this.cancelToken,this.retryConfig),KC.debug("[config-distribute] get config distribute",JSON.stringify(e)),e.limit_bitrate&&this.handleBitrateLimit(e.limit_bitrate),this.cacheGlobalParameterConfig(e),this.configs=e;}catch(e){const t=new xv(xg.NETWORK_RESPONSE_ERROR,e);KC.warning("[config-distribute] ".concat(t.toString()));}finally{t();}}getBitrateLimit(){return this.configs?this.configs.limit_bitrate:void 0}handleBitrateLimit(e){var t;(t=e)&&t.uplink&&t.id&&void 0!==t.uplink.max_bitrate&&void 0!==t.uplink.min_bitrate&&(this.configs&&this.configs.limit_bitrate?this.configs&&this.configs.limit_bitrate&&this.configs.limit_bitrate.id!==e.id&&this.emit(dI.UPDATE_BITRATE_LIMIT,e):this.emit(dI.UPDATE_BITRATE_LIMIT,e));}getLowStreamConfigDistribute(){return this.configs&&this.configs.limit_bitrate&&gP({},this.configs.limit_bitrate.low_stream_uplink)}cacheGlobalParameterConfig(e){var t;const i=Zu(t=Object.keys(e).filter((e=>/^webrtc_ng_global_parameter/.test(e)))).call(t);for(let t=0;t<i.length;t++)for(let n=i.length-1;n>t;n--){const t=i[n];if("number"==typeof e[t].__priority){const r=e[t].__priority,s=i[n-1];if("number"==typeof e[s].__priority){if(!(r>e[s].__priority))continue;{const e=t;i[n]=i[n-1],i[n-1]=e;}}else {const e=t;i[n]=i[n-1],i[n-1]=e;}}}const n={};i.forEach((t=>{const i=e[t],r=i.__expires;Object.keys(i).forEach((e=>{"__priority"===e||"__expires"===e||Object.prototype.hasOwnProperty.call(n,e)||(n[e]=gP({value:i[e]},r&&{expires:r}));}));}));try{!function(e){try{const t=Date.now();Object.keys(e).forEach((i=>{switch(i){case"ENABLE_EVENT_REPORT":case"UPLOAD_LOG":if(Object.prototype.hasOwnProperty.call(PC,i)){const{value:n,expires:r}=e[i];if(r&&r<=t)return;MC[i]=n,PC[i]=n,KC.debug("Update global parameters from config distribute",i,n);}}}));}catch(t){KC.error("Error update config immediately: ".concat(e),t.message);}}(n);const e=JSON.stringify(n),t=window.btoa(e);window.localStorage.setItem("websdk_ng_global_parameter",t),KC.debug("Caching global parameters ".concat(e));}catch(e){KC.error("Error caching global parameters:",e.message);}}}function SP(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n);}return i}function RP(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?SP(Object(i),!0).forEach((function(t){nu(e,t,i[t]);})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):SP(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t));}));}return e}class CP extends iT{constructor(e,t,i,n){super(),nu(this,"spec",void 0),nu(this,"token",void 0),nu(this,"websocket",void 0),nu(this,"pingpongTimer",void 0),nu(this,"reconnectMode","retry"),nu(this,"serviceMode",void 0),nu(this,"reqId",0),nu(this,"commandReqId",0),nu(this,"handleWebSocketOpen",(()=>{this.reconnectMode="retry",this.startPingPong();})),nu(this,"handleWebSocketMessage",(e=>{if(!e.data)return;const t=JSON.parse(e.data);t.requestId?this.emit("@".concat(t.requestId,"-").concat(t.sid),t):this.serviceMode===yv.INJECT?this.emit(Kv.INJECT_STREAM_STATUS,t):(rv.workerEvent(this.spec.sid,{actionType:"status",serverCode:t.code,workerType:this.serviceMode===yv.TRANSCODE?1:2}),this.emit(Kv.PUBLISH_STREAM_STATUS,t));})),this.spec=t,this.token=e,this.serviceMode=n,this.websocket=new XI("live-streaming",i),this.websocket.on(Iv.CONNECTED,this.handleWebSocketOpen),this.websocket.on(Iv.ON_MESSAGE,this.handleWebSocketMessage),this.websocket.on(Iv.REQUEST_NEW_URLS,((e,t)=>{fT(this,Kv.REQUEST_NEW_ADDRESS).then(e).catch(t);})),this.websocket.on(Iv.RECONNECTING,(()=>{this.websocket.reconnectMode=this.reconnectMode;}));}init(e){return this.websocket.init(e)}async request(e,t,i,n){this.reqId+=1,"request"===e&&(this.commandReqId+=1);const r=this.commandReqId,s=this.reqId;if(!s||!this.websocket)throw new xv(xg.UNEXPECTED_ERROR);const o=RP({command:e,sdkVersion:"4.19.3"===OC?"0.0.1":OC,seq:s,requestId:s,allocate:i,cname:this.spec.cname,appId:this.spec.appId,sid:this.spec.sid,uid:this.spec.uid.toString(),ts:Math.floor(Date.now()/1e3)},t);if("closed"===this.websocket.state)throw new xv(xg.WS_DISCONNECT);const a=()=>new tg(((e,t)=>{this.websocket.once(Iv.CLOSED,(()=>t(new xv(xg.WS_ABORT)))),this.websocket.once(Iv.CONNECTED,e);}));"connected"!==this.websocket.state&&await a(),o.clientRequest&&(o.clientRequest.workerToken=this.token);const c=new tg(((e,t)=>{const i=()=>{t(new xv(xg.WS_ABORT));};this.websocket.once(Iv.RECONNECTING,i),this.websocket.once(Iv.CLOSED,i),this.once("@".concat(s,"-").concat(this.spec.sid),(t=>{e(t);}));}));n&&rv.workerEvent(this.spec.sid,RP(RP({},n),{},{requestId:r,actionType:"request",payload:JSON.stringify(t.clientRequest),serverCode:0,code:0}));const d=Date.now();this.websocket.sendMessage(o);let l=null;try{l=await c;}catch(n){if("closed"===this.websocket.state)throw n;return await a(),await this.request(e,t,i)}return n&&rv.workerEvent(this.spec.sid,RP(RP({},n),{},{requestId:r,actionType:"response",payload:JSON.stringify(l.serverResponse),serverCode:l.code,success:200===l.code,responseTime:Date.now()-d})),200!==l.code&&this.handleResponseError(l),l}tryNextAddress(){this.reconnectMode="tryNext",this.websocket.reconnect("tryNext");}close(){const e="4.19.3"===OC?"0.0.1":OC;this.reqId+=1,"connected"===this.websocket.state?(this.websocket.sendMessage({command:"request",appId:this.spec.appId,cname:this.spec.cname,uid:this.spec.uid.toString(),sdkVersion:e,sid:this.spec.sid,seq:this.reqId,ts:Math.floor(Date.now()/1e3),requestId:this.reqId,clientRequest:{command:"DestroyWorker"}}),this.websocket.close(!1,!0)):this.websocket.close(!1),this.pingpongTimer&&(window.clearInterval(this.pingpongTimer),this.pingpongTimer=void 0);}handleResponseError(e){switch(e.code){case qv.LIVE_STREAM_RESPONSE_ALREADY_EXISTS_STREAM:return void KC.warning("live stream response already exists stream");case qv.LIVE_STREAM_RESPONSE_TRANSCODING_PARAMETER_ERROR:case qv.LIVE_STREAM_RESPONSE_BAD_STREAM:case qv.LIVE_STREAM_RESPONSE_WM_PARAMETER_ERROR:return new xv(xg.LIVE_STREAMING_INVALID_ARGUMENT,"",{code:e.code}).throw();case qv.LIVE_STREAM_RESPONSE_WM_WORKER_NOT_EXIST:if("UnpublishStream"===e.serverResponse.command||"UninjectStream"===e.serverResponse.command)return;throw new xv(xg.LIVE_STREAMING_INTERNAL_SERVER_ERROR,"live stream response wm worker not exist",{retry:!0});case qv.LIVE_STREAM_RESPONSE_NOT_AUTHORIZED:return new xv(xg.LIVE_STREAMING_PUBLISH_STREAM_NOT_AUTHORIZED,"",{code:e.code}).throw();case qv.LIVE_STREAM_RESPONSE_FAILED_LOAD_IMAGE:{const t=new xv(xg.LIVE_STREAMING_WARN_FAILED_LOAD_IMAGE);return this.emit(Kv.WARNING,t,e.serverResponse.url)}case qv.LIVE_STREAM_RESPONSE_REQUEST_TOO_OFTEN:{const t=new xv(xg.LIVE_STREAMING_WARN_FREQUENT_REQUEST);return this.emit(Kv.WARNING,t,e.serverResponse.url)}case qv.LIVE_STREAM_RESPONSE_NOT_FOUND_PUBLISH:throw new xv(xg.LIVE_STREAMING_INTERNAL_SERVER_ERROR,"live stream response wm worker not exist",{retry:!0});case qv.LIVE_STREAM_RESPONSE_NOT_SUPPORTED:return new xv(xg.LIVE_STREAMING_TRANSCODING_NOT_SUPPORTED,"",{code:e.code}).throw();case qv.LIVE_STREAM_RESPONSE_MAX_STREAM_NUM:{const t=new xv(xg.LIVE_STREAMING_WARN_STREAM_NUM_REACH_LIMIT);return this.emit(Kv.WARNING,t,e.serverResponse.url)}case qv.LIVE_STREAM_RESPONSE_INTERNAL_SERVER_ERROR:return new xv(xg.LIVE_STREAMING_INTERNAL_SERVER_ERROR,"",{code:e.code}).throw();case qv.LIVE_STREAM_RESPONSE_RESOURCE_LIMIT:throw new xv(xg.LIVE_STREAMING_INTERNAL_SERVER_ERROR,"live stream resource limit",{retry:!0,changeAddress:!0});case qv.LIVE_STREAM_RESPONSE_WORKER_LOST:case qv.LIVE_STREAM_RESPONSE_WORKER_QUIT:if("UnpublishStream"===e.serverResponse.command||"UninjectStream"===e.serverResponse.command)return;throw new xv(xg.LIVE_STREAMING_INTERNAL_SERVER_ERROR,"error fail send message",{retry:!0,changeAddress:!0});case qv.ERROR_FAIL_SEND_MESSAGE:if("UnpublishStream"===e.serverResponse.command||"UninjectStream"===e.serverResponse.command)return;if("UpdateTranscoding"===e.serverResponse.command||"ControlStream"===e.serverResponse.command)return new xv(xg.LIVE_STREAMING_INTERNAL_SERVER_ERROR,"error fail send message",{code:e.code}).throw();throw new xv(xg.LIVE_STREAMING_INTERNAL_SERVER_ERROR,"error fail send message",{retry:!0,changeAddress:!0});case qv.PUBLISH_STREAM_STATUS_ERROR_PUBLISH_BROKEN:case qv.PUBLISH_STREAM_STATUS_ERROR_RTMP_CONNECT:case qv.PUBLISH_STREAM_STATUS_ERROR_RTMP_HANDSHAKE:case qv.PUBLISH_STREAM_STATUS_ERROR_RTMP_PUBLISH:return new xv(xg.LIVE_STREAMING_CDN_ERROR,"",{code:e.code}).throw()}}startPingPong(){this.pingpongTimer&&window.clearInterval(this.pingpongTimer),this.pingpongTimer=window.setInterval((()=>{"connected"===this.websocket.state&&this.request("ping",{}).catch(FT);}),6e3);}}function vP(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n);}return i}function IP(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?vP(Object(i),!0).forEach((function(t){nu(e,t,i[t]);})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):vP(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t));}));}return e}class yP extends iT{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:JT,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:JT;super(),nu(this,"onLiveStreamWarning",void 0),nu(this,"onLiveStreamError",void 0),nu(this,"onInjectStatusChange",void 0),nu(this,"spec",void 0),nu(this,"retryTimeout",1e4),nu(this,"connection",void 0),nu(this,"httpRetryConfig",void 0),nu(this,"wsRetryConfig",void 0),nu(this,"streamingTasks",new Map),nu(this,"isStartingStreamingTask",!1),nu(this,"taskMutex",new YT("live-streaming")),nu(this,"cancelToken",EC.CancelToken.source()),nu(this,"transcodingConfig",void 0),nu(this,"injectConfig",IP({},Hv)),nu(this,"injectLoopTimes",0),nu(this,"uapResponse",void 0),nu(this,"lastTaskId",1),nu(this,"statusError",new Map),this.spec=e,this.httpRetryConfig=i,this.wsRetryConfig=t;}async setTranscodingConfig(e){const t=IP(IP({},Wv),e);66!==t.videoCodecProfile&&77!==t.videoCodecProfile&&100!==t.videoCodecProfile&&(KC.debug("[".concat(this.spec.clientId,"] set transcoding config, fix video codec profile: ").concat(t.videoCodecProfile," -> 100")),t.videoCodecProfile=100),t.transcodingUsers||(t.transcodingUsers=t.userConfigs),t.transcodingUsers&&(t.transcodingUsers=t.transcodingUsers.map((e=>IP(IP(IP({},Bv),e),{},{zOrder:e.zOrder?e.zOrder+1:1})))),function(e){Kg(e.width)||jg(e.width,"config.width",0,1e4),Kg(e.height)||jg(e.height,"config.height",0,1e4),Kg(e.videoBitrate)||jg(e.videoBitrate,"config.videoBitrate",1,1e6),Kg(e.videoFrameRate)||jg(e.videoFrameRate,"config.videoFrameRate"),Kg(e.lowLatency)||Fg(e.lowLatency,"config.lowLatency"),Kg(e.audioSampleRate)||Bg(e.audioSampleRate,"config.audioSampleRate",[32e3,44100,48e3]),Kg(e.audioBitrate)||jg(e.audioBitrate,"config.audioBitrate",1,128),Kg(e.audioChannels)||Bg(e.audioChannels,"config.audioChannels",[1,2,3,4,5]),Kg(e.videoGop)||jg(e.videoGop,"config.videoGop"),Kg(e.videoCodecProfile)||Bg(e.videoCodecProfile,"config.videoCodecProfile",[66,77,100]),Kg(e.userCount)||jg(e.userCount,"config.userCount",0,17),Kg(e.backgroundColor)||jg(e.backgroundColor,"config.backgroundColor",0,16777215),Kg(e.userConfigExtraInfo)||Wg(e.userConfigExtraInfo,"config.userConfigExtraInfo",0,4096,!1),e.transcodingUsers&&!Kg(e.transcodingUsers)&&(Hg(e.transcodingUsers,"config.transcodingUsers"),e.transcodingUsers.forEach(((e,t)=>{Fv(e.uid),Kg(e.x)||jg(e.x,"transcodingUser[".concat(t,"].x"),0,1e4),Kg(e.y)||jg(e.y,"transcodingUser[".concat(t,"].y"),0,1e4),Kg(e.width)||jg(e.width,"transcodingUser[".concat(t,"].width"),0,1e4),Kg(e.height)||jg(e.height,"transcodingUser[".concat(t,"].height"),0,1e4),Kg(e.zOrder)||jg(e.zOrder-1,"transcodingUser[".concat(t,"].zOrder"),0,100),Kg(e.alpha)||jg(e.alpha,"transcodingUser[".concat(t,"].alpha"),0,1,!1);}))),Kg(e.watermark)||Gv(e.watermark,"watermark"),Kg(e.backgroundImage)||Gv(e.backgroundImage,"backgroundImage"),e.images&&!Kg(e.images)&&(Hg(e.images,"config.images"),e.images.forEach(((e,t)=>{Gv(e,"images[".concat(t,"]"));})));}(t);const i=[];t.images&&i.push(...t.images.map((e=>IP(IP(IP({},jv),e),{},{zOrder:255})))),t.backgroundImage&&(i.push(IP(IP(IP({},jv),t.backgroundImage),{},{zOrder:0})),delete t.backgroundImage),t.watermark&&(i.push(IP(IP(IP({},jv),t.watermark),{},{zOrder:255})),delete t.watermark),t.images=i,t.transcodingUsers&&(t.userConfigs=t.transcodingUsers.map((e=>IP({},e))),t.userCount=t.transcodingUsers.length,delete t.transcodingUsers);const n=(t.userConfigs||[]).map((e=>"number"==typeof e.uid?tg.resolve(e.uid):hP(e.uid,this.spec,this.cancelToken.token,this.httpRetryConfig)));if((await tg.all(n)).forEach(((e,i)=>{t.userConfigs&&t.userConfigs[i]&&(t.userConfigs[i].uid=e);})),this.transcodingConfig=t,this.connection)try{var r;const e=await this.connection.request("request",{clientRequest:{command:"UpdateTranscoding",transcodingConfig:this.transcodingConfig}},!1,{command:"UpdateTranscoding",workerType:1,requestByUser:!0,tid:Array.from(kv(r=this.streamingTasks).call(r)).map((e=>e.taskId)).join("#")});KC.debug("[".concat(this.spec.clientId,"] update live transcoding config success, code: ").concat(e.code,", config:"),JSON.stringify(this.transcodingConfig));}catch(e){if(!e.data||!e.data.retry)throw e;e.data.changeAddress&&this.connection.tryNextAddress(),this.streamingTasks.forEach((t=>{KC.warning("[".concat(this.spec.clientId,"] live streaming receive error"),e.toString(),"try to republish",t.url),this.startLiveStreamingTask(t.url,t.mode,e).then((()=>{KC.debug("[".concat(this.spec.clientId,"] live streaming republish ").concat(t.url," success"));})).catch((e=>{KC.error("[".concat(this.spec.clientId,"] live streaming republish failed"),t.url,e.toString()),this.onLiveStreamError&&this.onLiveStreamError(t.url,e);}));}));}}setInjectStreamConfig(e,t){this.injectConfig=Object.assign({},this.injectConfig,e),this.injectLoopTimes=t;}async startLiveStreamingTask(e,t,i){var n;if(Array.from(kv(n=this.streamingTasks).call(n)).find((e=>e.mode===yv.INJECT))&&t===yv.INJECT)return new xv(xg.LIVE_STREAMING_TASK_CONFLICT,"inject stream over limit").throw();if(!this.transcodingConfig&&t===yv.TRANSCODE)throw new xv(xg.INVALID_OPERATION,"[LiveStreaming] no transcoding config found, can not start transcoding streaming task");let r={command:"PublishStream",ts:Date.now(),url:e,uid:this.spec.uid.toString(),autoDestroyTime:100,acceptImageTimeout:!0};KC.debug("[".concat(this.spec.clientId,"] start live streaming ").concat(e,", mode: ").concat(t));const s=await this.taskMutex.lock();if(!this.connection&&i)return void s();if(this.streamingTasks.get(e)&&!i)return s(),new xv(xg.LIVE_STREAMING_TASK_CONFLICT).throw();try{this.connection||(this.connection=await this.connect(t));}catch(e){throw s(),e}switch(t){case yv.TRANSCODE:r.transcodingConfig=IP({},this.transcodingConfig);break;case yv.RAW:break;case yv.INJECT:r={cname:this.spec.cname,command:"InjectStream",sid:this.spec.sid,transcodingConfig:this.injectConfig,ts:Date.now(),url:e,loopTimes:this.injectLoopTimes};}this.uapResponse&&this.uapResponse.vid&&(r.vid=this.uapResponse.vid),this.isStartingStreamingTask=!0;const o=this.lastTaskId++;try{const n=new tg(((t,n)=>{UT(this.retryTimeout).then((()=>{if(i)return n(i);const t=this.statusError.get(e);return t?(this.statusError.delete(e),n(t)):void 0}));})),a=await tg.race([this.connection.request("request",{clientRequest:r},!0,{url:e,command:"PublishStream",workerType:t===yv.TRANSCODE?1:2,requestByUser:!i,tid:o.toString()}),n]);this.isStartingStreamingTask=!1,KC.debug("[".concat(this.spec.clientId,"] live streaming started, code: ").concat(a.code)),this.streamingTasks.set(e,{clientRequest:r,mode:t,url:e,taskId:o}),s();}catch(n){if(s(),this.isStartingStreamingTask=!1,!n.data||!n.data.retry||i)throw n;return n.data.changeAddress?(this.connection.tryNextAddress(),await this.startLiveStreamingTask(e,t,n)):await this.startLiveStreamingTask(e,t,n)}}stopLiveStreamingTask(e){return new tg(((t,i)=>{const n=this.streamingTasks.get(e);if(!n||!this.connection)return new xv(xg.UNEXPECTED_ERROR,"can not find streaming task to stop").throw();const r=n.mode;n.abortTask=()=>{KC.debug("[".concat(this.spec.clientId,"] stop live streaming success(worker exception)")),this.streamingTasks.delete(e),t();},this.connection.request("request",{clientRequest:{command:r===yv.INJECT?"UninjectStream":"UnpublishStream",url:n.url}},!1,{url:e,command:"UnPublishStream",workerType:r===yv.TRANSCODE?1:2,requestByUser:!0,tid:(this.lastTaskId++).toString()}).then((i=>{KC.debug("[".concat(this.spec.clientId,"] stop live streaming success, code: ").concat(i.code)),this.streamingTasks.delete(e),0===this.streamingTasks.size&&r!==yv.INJECT&&(this.connection&&this.connection.close(),this.connection=void 0),t(),r===yv.INJECT&&this.onInjectStatusChange&&this.onInjectStatusChange(Av.INJECT_STREAM_STATUS_STOP_SUCCESS,this.spec.uid,e);})).catch(i);}))}async controlInjectStream(e,t,i,n){const r=this.streamingTasks.get(e);if(!r||!this.connection||r.mode!==yv.INJECT)throw new xv(xg.INVALID_OPERATION,"can not find inject stream task to control");return (await this.connection.request("request",{clientRequest:{command:"ControlStream",url:e,control:t,audioVolume:i,position:n}})).serverResponse}resetAllTask(){var e;const t=Array.from(kv(e=this.streamingTasks).call(e));this.terminate();for(const e of t)this.startLiveStreamingTask(e.url,e.mode).catch((t=>{this.onLiveStreamError&&this.onLiveStreamError(e.url,t);}));}terminate(){this.cancelToken&&this.cancelToken.cancel(),this.streamingTasks=new Map,this.isStartingStreamingTask=!1,this.statusError=new Map,this.cancelToken=EC.CancelToken.source(),this.uapResponse=void 0,this.connection&&this.connection.close(),this.connection=void 0;}async connect(e){if(this.connection)throw new xv(xg.UNEXPECTED_ERROR,"live streaming connection has already connected");const t=await fT(this,Yv.REQUEST_WORKER_MANAGER_LIST,e);return this.uapResponse=t,this.connection=new CP(t.workerToken,this.spec,this.wsRetryConfig,e),this.connection.on(Kv.WARNING,((e,t)=>this.onLiveStreamWarning&&this.onLiveStreamWarning(t,e))),this.connection.on(Kv.PUBLISH_STREAM_STATUS,(e=>this.handlePublishStreamServer(e))),this.connection.on(Kv.INJECT_STREAM_STATUS,(e=>this.handleInjectStreamServerStatus(e))),this.connection.on(Kv.REQUEST_NEW_ADDRESS,((t,i)=>{if(!this.connection)return i(new xv(xg.UNEXPECTED_ERROR,"can not get new live streaming address list"));fT(this,Yv.REQUEST_WORKER_MANAGER_LIST,e).then((e=>{this.uapResponse=e,t(e.addressList);})).catch(i);})),await this.connection.init(t.addressList),this.connection}handlePublishStreamServer(e){const t=e.serverStatus&&e.serverStatus.url||"empty_url",i=this.streamingTasks.get(t),n=e.reason;switch(e.code){case qv.PUBLISH_STREAM_STATUS_ERROR_PUBLISH_BROKEN:case qv.PUBLISH_STREAM_STATUS_ERROR_RTMP_CONNECT:case qv.PUBLISH_STREAM_STATUS_ERROR_RTMP_HANDSHAKE:case qv.PUBLISH_STREAM_STATUS_ERROR_RTMP_PUBLISH:{const n=new xv(xg.LIVE_STREAMING_CDN_ERROR,"",{code:e.code});if(i)return KC.error(n.toString()),this.onLiveStreamError&&this.onLiveStreamError(t,n);if(!this.isStartingStreamingTask)return;this.statusError.set(t,n);}case qv.LIVE_STREAM_RESPONSE_FAILED_LOAD_IMAGE:{const e=new xv(xg.LIVE_STREAMING_WARN_FAILED_LOAD_IMAGE,n);return this.onLiveStreamWarning&&this.onLiveStreamWarning(t,e)}case qv.LIVE_STREAM_RESPONSE_WORKER_LOST:case qv.LIVE_STREAM_RESPONSE_WORKER_QUIT:{var r;if(!this.connection)return;this.connection.tryNextAddress();const t=Array.from(kv(r=this.streamingTasks).call(r));for(const i of t)i.abortTask?i.abortTask():(KC.warning("[".concat(this.spec.clientId,"] publish stream status code"),e.code,"try to republish",i.url),this.startLiveStreamingTask(i.url,i.mode,new xv(xg.LIVE_STREAMING_INTERNAL_SERVER_ERROR,"",{code:e.code})).then((()=>{KC.debug("[".concat(this.spec.clientId,"] republish live stream success"),i.url);})).catch((e=>{KC.error(e.toString()),this.onLiveStreamError&&this.onLiveStreamError(i.url,e);})));return}}}handleInjectStreamServerStatus(e){const t=Number(e.uid),i=e.serverStatus&&e.serverStatus.url;switch(e.code){case 200:return void(this.onInjectStatusChange&&this.onInjectStatusChange(Av.INJECT_STREAM_STATUS_START_SUCCESS,t,i));case 451:return this.onInjectStatusChange&&this.onInjectStatusChange(Av.INJECT_STREAM_STATUS_START_ALREADY_EXISTS,t,i),void this.streamingTasks.delete(i);case 453:return this.onInjectStatusChange&&this.onInjectStatusChange(Av.INJECT_STREAM_STATUS_START_UNAUTHORIZED,t,i),void this.streamingTasks.delete(i);case 470:return this.onInjectStatusChange&&this.onInjectStatusChange(Av.INJECT_STREAM_STATUS_BROKEN,t,i),void this.streamingTasks.delete(i);case 499:return this.onInjectStatusChange&&this.onInjectStatusChange(Av.INJECT_STREAM_STATUS_START_TIMEOUT,t,i),void this.streamingTasks.delete(i);default:return void KC.debug("inject stream server status",e)}}hasUrl(e){return this.streamingTasks.has(e)}}class AP{constructor(){nu(this,"destChannelMediaInfos",new Map),nu(this,"srcChannelMediaInfo",void 0);}setSrcChannelInfo(e){sI(e),this.srcChannelMediaInfo=e;}addDestChannelInfo(e){sI(e),this.destChannelMediaInfos.set(e.channelName,e);}removeDestChannelInfo(e){Vv(e),this.destChannelMediaInfos.delete(e);}getSrcChannelMediaInfo(){return this.srcChannelMediaInfo}getDestChannelMediaInfo(){return this.destChannelMediaInfos}}function bP(e){if(!(e instanceof AP)){return new xv(xg.INVALID_PARAMS,"Config should be instance of [ChannelMediaRelayConfiguration]").throw()}const t=e.getSrcChannelMediaInfo(),i=e.getDestChannelMediaInfo();if(!t){return new xv(xg.INVALID_PARAMS,"srcChannelMediaInfo should not be empty").throw()}if(0===i.size){return new xv(xg.INVALID_PARAMS,"destChannelMediaInfo should not be empty").throw()}}class wP extends iT{constructor(e,t,i){super(),nu(this,"ws",void 0),nu(this,"requestId",1),nu(this,"heartBeatTimer",void 0),nu(this,"joinInfo",void 0),nu(this,"clientId",void 0),nu(this,"onOpen",(()=>{this.emit("open"),this.startHeartBeatCheck();})),nu(this,"onClose",(e=>{this.emit("close"),this.dispose();})),nu(this,"onMessage",(e=>{const t=JSON.parse(e.data);if(!t||"serverResponse"!==t.command||!t.requestId)return t&&"serverStatus"===t.command&&t.serverStatus&&t.serverStatus.command?(this.emit("status",t.serverStatus),void this.emit(t.serverStatus.command,t.serverStatus)):void 0;this.emit("req_".concat(t.requestId),t);})),this.joinInfo=e,this.clientId=t,this.ws=new XI("cross-channel-".concat(this.clientId),i),this.ws.on(Iv.RECONNECTING,(()=>{this.ws.reconnectMode="retry",this.emit("reconnecting");})),this.ws.on(Iv.CONNECTED,this.onOpen),this.ws.on(Iv.ON_MESSAGE,this.onMessage),this.ws.on(Iv.CLOSED,this.onClose);}isConnect(){return "connected"===this.ws.state}sendMessage(e){const t=this.requestId++;return e.requestId=t,e.seq=t,this.ws.sendMessage(e),t}waitStatus(e){return new tg(((t,i)=>{const n=window.setTimeout((()=>{i(new xv(xg.TIMEOUT,"wait status timeout, status: ".concat(e)));}),5e3);this.once(e,(r=>{window.clearTimeout(n),r.state&&0!==r.state?i(new xv(xg.CROSS_CHANNEL_WAIT_STATUS_ERROR,"wait status error, status: ".concat(e))):t(void 0);})),this.once("dispose",(()=>{window.clearTimeout(n),i(new xv(xg.WS_ABORT));}));}))}async request(e){if("closed"===this.ws.state)throw new xv(xg.WS_DISCONNECT);const t=()=>new tg(((e,t)=>{this.ws.once(Iv.CLOSED,(()=>t(new xv(xg.WS_ABORT)))),this.ws.once(Iv.CONNECTED,e);}));"connected"!==this.ws.state&&await t();const i=this.sendMessage(e),n=new tg(((e,t)=>{const n=()=>{t(new xv(xg.WS_ABORT));};this.ws.once(Iv.RECONNECTING,n),this.ws.once(Iv.CLOSED,n),this.once("req_".concat(i),e),UT(3e3).then((()=>{this.removeAllListeners("req_".concat(i)),this.ws.off(Iv.RECONNECTING,n),this.ws.off(Iv.CLOSED,n),t(new xv(xg.TIMEOUT,"cross channel ws request timeout"));}));})),r=await n;if(!r||200!==r.code)throw new xv(xg.CROSS_CHANNEL_SERVER_ERROR_RESPONSE,"response: ".concat(JSON.stringify(r)));return r}async connect(e){this.ws.removeAllListeners(Iv.REQUEST_NEW_URLS),this.ws.on(Iv.REQUEST_NEW_URLS,(t=>{t(e);})),await this.ws.init(e);}dispose(){this.clearHeartBeatCheck(),this.emit("dispose"),this.removeAllListeners(),this.ws.close();}sendPing(e){const t=this.requestId++;return e.requestId=t,this.ws.sendMessage(e),t}startHeartBeatCheck(){this.heartBeatTimer&&window.clearInterval(this.heartBeatTimer),this.heartBeatTimer=window.setInterval((()=>{this.sendPing({command:"ping",appId:this.joinInfo.appId,cname:this.joinInfo.cname,uid:this.joinInfo.uid.toString(),sid:this.joinInfo.sid,ts:+new Date,requestId:0});}),3e3);}clearHeartBeatCheck(){window.clearInterval(this.heartBeatTimer),this.heartBeatTimer=void 0;}}class OP extends iT{set state(e){e!==this._state&&(e!==Qv.RELAY_STATE_FAILURE&&(this.errorCode=Zv.RELAY_OK),this.emit("state",e,this.errorCode),this._state=e);}get state(){return this._state}constructor(e,t,i,n,r){super(),nu(this,"joinInfo",void 0),nu(this,"sid",void 0),nu(this,"clientId",void 0),nu(this,"cancelToken",EC.CancelToken.source()),nu(this,"workerToken",void 0),nu(this,"requestId",0),nu(this,"signal",void 0),nu(this,"prevChannelMediaConfig",void 0),nu(this,"httpRetryConfig",void 0),nu(this,"_resolution",void 0),nu(this,"_state",Qv.RELAY_STATE_IDLE),nu(this,"errorCode",Zv.RELAY_OK),nu(this,"onStatus",(e=>{KC.debug("[".concat(this.clientId,"] ChannelMediaStatus: ").concat(JSON.stringify(e))),e&&e.command&&("onAudioPacketReceived"===e.command&&this.emit("event",Xv.PACKET_RECEIVED_AUDIO_FROM_SRC),"onVideoPacketReceived"===e.command&&this.emit("event",Xv.PACKET_RECEIVED_VIDEO_FROM_SRC),"onSrcTokenPrivilegeDidExpire"===e.command&&(this.errorCode=Zv.SRC_TOKEN_EXPIRED,this.state=Qv.RELAY_STATE_FAILURE),"onDestTokenPrivilegeDidExpire"===e.command&&(this.errorCode=Zv.DEST_TOKEN_EXPIRED,this.state=Qv.RELAY_STATE_FAILURE));})),nu(this,"onReconnect",(async()=>{KC.debug("[".concat(this.clientId,"] ChannelMediaSocket disconnect, reconnecting")),this.emit("event",Xv.NETWORK_DISCONNECTED),this.state=Qv.RELAY_STATE_IDLE,this.prevChannelMediaConfig&&this.sendStartRelayMessage(this.prevChannelMediaConfig).catch((e=>{this.state!==Qv.RELAY_STATE_IDLE&&(KC.error("auto restart channel media relay failed",e.toString()),this.errorCode=Zv.SERVER_CONNECTION_LOST,this.state=Qv.RELAY_STATE_FAILURE);}));})),this.joinInfo=e,this.clientId=t,this.sid=VT(),this.signal=new wP(this.joinInfo,this.clientId,i),this.httpRetryConfig=n,this._resolution=r;}async startChannelMediaRelay(e){if(this.state!==Qv.RELAY_STATE_IDLE)throw new xv(xg.INVALID_OPERATION);this.state=Qv.RELAY_STATE_CONNECTING,await this.connect(),KC.debug("[".concat(this.clientId,"] startChannelMediaRelay: connect success"));try{await this.sendStartRelayMessage(e);}catch(e){if(e.data&&e.data.serverResponse&&"SetSourceChannel"===e.data.serverResponse.command)throw new xv(xg.CROSS_CHANNEL_FAILED_JOIN_SRC);if(e.data&&e.data.serverResponse&&"SetDestChannelStatus"===e.serverResponse.command)throw new xv(xg.CROSS_CHANNEL_FAILED_JOIN_DEST);if(e.data&&e.data.serverResponse&&"StartPacketTransfer"===e.serverResponse.command)throw new xv(xg.CROSS_CHANNEL_FAILED_PACKET_SENT_TO_DEST);throw e}this.prevChannelMediaConfig=e;}async updateChannelMediaRelay(e){if(this.state!==Qv.RELAY_STATE_RUNNING)throw new xv(xg.INVALID_OPERATION);await this.sendUpdateMessage(e),this.prevChannelMediaConfig=e;}async setVideoProfile(e){if(this._resolution=e,this.state!==Qv.RELAY_STATE_RUNNING)throw new xv(xg.INVALID_OPERATION);const t=this.genMessage(zv.SetVideoProfile);await this.signal.request(t),KC.debug("[".concat(this.clientId,"] startChannelMediaRelay: setVideoProfile success"));}async stopChannelMediaRelay(){await this.sendStopRelayMessage(),KC.debug("[".concat(this.clientId,"] stopChannelMediaRelay: send stop message success")),this.state=Qv.RELAY_STATE_IDLE,this.dispose();}dispose(){KC.debug("[".concat(this.clientId,"] disposeChannelMediaRelay")),this.cancelToken.cancel(),this.cancelToken=EC.CancelToken.source(),this.state=Qv.RELAY_STATE_IDLE,this.emit("dispose"),this.signal.dispose(),this.prevChannelMediaConfig=void 0;}async connect(){const e=await EP(this.joinInfo,this.cancelToken.token,this.httpRetryConfig);this.workerToken=e.workerToken,await this.signal.connect(e.addressList),this.emit("event",Xv.NETWORK_CONNECTED),this.signal.on("status",this.onStatus),this.signal.on("reconnecting",this.onReconnect);}async sendStartRelayMessage(e){const t=this.genMessage(zv.StopPacketTransfer);await this.signal.request(t),await this.signal.waitStatus("Normal Quit"),KC.debug("[".concat(this.clientId,"] startChannelMediaRelay: StopPacketTransfer success"));const i=this.genMessage(zv.SetSdkProfile,e);await this.signal.request(i),KC.debug("[".concat(this.clientId,"] startChannelMediaRelay: SetSdkProfile success"));const n=this.genMessage(zv.SetSourceChannel,e);await this.signal.request(n),await this.signal.waitStatus("SetSourceChannelStatus"),this.emit("event",Xv.PACKET_JOINED_SRC_CHANNEL),KC.debug("[".concat(this.clientId,"] startChannelMediaRelay: SetSourceChannel success"));const r=this.genMessage(zv.SetSourceUserId,e);await this.signal.request(r),KC.debug("[".concat(this.clientId,"] startChannelMediaRelay: SetSourceUserId success"));const s=this.genMessage(zv.SetDestChannel,e);await this.signal.request(s),await this.signal.waitStatus("SetDestChannelStatus"),this.emit("event",Xv.PACKET_JOINED_DEST_CHANNEL),KC.debug("[".concat(this.clientId,"] startChannelMediaRelay: SetDestChannel success"));const o=this.genMessage(zv.StartPacketTransfer,e);await this.signal.request(o),this.emit("event",Xv.PACKET_SENT_TO_DEST_CHANNEL),this.state=Qv.RELAY_STATE_RUNNING,KC.debug("[".concat(this.clientId,"] startChannelMediaRelay: StartPacketTransfer success")),this.setVideoProfile(this._resolution);}async sendUpdateMessage(e){const t=this.genMessage(zv.UpdateDestChannel,e);await this.signal.request(t),this.emit("event",Xv.PACKET_UPDATE_DEST_CHANNEL),KC.debug("[".concat(this.clientId,"] sendUpdateMessage: UpdateDestChannel success"));}async sendStopRelayMessage(){const e=this.genMessage(zv.StopPacketTransfer);await this.signal.request(e),KC.debug("[".concat(this.clientId,"] sendStopRelayMessage: StopPacketTransfer success"));}genMessage(e,t){const i=[],n=[],r=[];this.requestId+=1;const s={appId:this.joinInfo.appId,cname:this.joinInfo.cname,uid:this.joinInfo.uid.toString(),sdkVersion:OC,sid:this.sid,ts:Date.now(),requestId:this.requestId,seq:this.requestId,allocate:!0,clientRequest:{}};"4.19.3"===s.sdkVersion&&(s.sdkVersion="0.0.1");let o=null,a=null;switch(e){case zv.SetSdkProfile:return s.clientRequest={command:"SetSdkProfile",type:"multi_channel"},s;case zv.SetSourceChannel:if(a=t&&t.getSrcChannelMediaInfo(),!a)throw new xv(xg.UNEXPECTED_ERROR,"can not find source config");return s.clientRequest={command:"SetSourceChannel",uid:"0",channelName:a.channelName,token:a.token||this.joinInfo.appId},s;case zv.SetSourceUserId:if(a=t&&t.getSrcChannelMediaInfo(),!a)throw new xv(xg.UNEXPECTED_ERROR,"can not find source config");return s.clientRequest={command:"SetSourceUserId",uid:a.uid+""},s;case zv.SetDestChannel:if(o=t&&t.getDestChannelMediaInfo(),!o)throw new xv(xg.UNEXPECTED_ERROR,"can not find dest config");return o.forEach((e=>{i.push(e.channelName),n.push(e.uid+""),r.push(e.token||this.joinInfo.appId);})),s.clientRequest={command:"SetDestChannel",channelName:i,uid:n,token:r},s;case zv.StartPacketTransfer:return s.clientRequest={command:"StartPacketTransfer"},s;case zv.Reconnect:return s.clientRequest={command:"Reconnect"},s;case zv.StopPacketTransfer:return s.clientRequest={command:"StopPacketTransfer"},s;case zv.UpdateDestChannel:if(o=t&&t.getDestChannelMediaInfo(),!o)throw new xv(xg.UNEXPECTED_ERROR,"can not find dest config");return o.forEach((e=>{i.push(e.channelName),n.push(e.uid+""),r.push(e.token||this.joinInfo.appId);})),s.clientRequest={command:"UpdateDestChannel",channelName:i,uid:n,token:r},s;case zv.SetVideoProfile:s.clientRequest={command:"SetVideoProfile",width:this._resolution.width,height:this._resolution.height};}return s}}class NP{get hasVideo(){return this._video_enabled_&&!this._video_muted_&&this._video_added_}get hasAudio(){return this._audio_enabled_&&!this._audio_muted_&&this._audio_added_}get audioTrack(){if(this.hasAudio)return this._audioTrack}get videoTrack(){if(this.hasVideo)return this._videoTrack}get dataChannels(){return this._dataChannels}constructor(e,t){nu(this,"uid",void 0),nu(this,"_uintid",void 0),nu(this,"_trust_in_room_",!0),nu(this,"_trust_audio_enabled_state_",!0),nu(this,"_trust_video_enabled_state_",!0),nu(this,"_trust_audio_mute_state_",!0),nu(this,"_trust_video_mute_state_",!0),nu(this,"_audio_muted_",!1),nu(this,"_video_muted_",!1),nu(this,"_audio_enabled_",!0),nu(this,"_video_enabled_",!0),nu(this,"_audio_added_",!1),nu(this,"_video_added_",!1),nu(this,"_trust_video_stream_added_state_",!0),nu(this,"_trust_audio_stream_added_state_",!0),nu(this,"_audioTrack",void 0),nu(this,"_videoTrack",void 0),nu(this,"_dataChannels",[]),nu(this,"_audioSSRC",void 0),nu(this,"_videoSSRC",void 0),nu(this,"_audioOrtc",void 0),nu(this,"_videoOrtc",void 0),nu(this,"_cname",void 0),nu(this,"_rtxSsrcId",void 0),this.uid=e,this._uintid=t;}}var DP=eg,PP=rm;kn({target:"Promise",stat:!0,forced:!0},{withResolvers:function(){var e=PP.f(this);return {promise:e.promise,resolve:e.resolve,reject:e.reject}}});var LP=rm,kP=FE;kn({target:"Promise",stat:!0,forced:!0},{try:function(e){var t=LP.f(this),i=kP(e);return (i.error?t.reject:t.resolve)(i.value),t.promise}});var MP=J(DP),UP=Fo.f("asyncIterator"),xP=J(UP);function VP(e,t){this.v=e,this.k=t;}function FP(e){var t,i;function n(t,i){try{var s=e[t](i),o=s.value,a=o instanceof VP;MP.resolve(a?o.v:o).then((function(i){if(a){var c="return"===t?"return":"next";if(!o.k||i.done)return n(c,i);i=e[c](i).value;}r(s.done?"return":"normal",i);}),(function(e){n("throw",e);}));}catch(e){r("throw",e);}}function r(e,r){switch(e){case"return":t.resolve({value:r,done:!0});break;case"throw":t.reject(r);break;default:t.resolve({value:r,done:!1});}(t=t.next)?n(t.key,t.arg):i=null;}this._invoke=function(e,r){return new MP((function(s,o){var a={key:e,arg:r,resolve:s,reject:o,next:null};i?i=i.next=a:(t=i=a,n(e,r));}))},"function"!=typeof e.return&&(this.return=void 0);}function BP(e){return function(){return new FP(e.apply(this,arguments))}}function jP(e){return new VP(e,0)}function GP(e){var t={},i=!1;function n(t,n){return i=!0,{done:!1,value:new VP(n=new MP((function(i){i(e[t](n));})),1)}}return t[void 0!==Uh&&$h||"@@iterator"]=function(){return this},t.next=function(e){return i?(i=!1,e):n("next",e)},"function"==typeof e.throw&&(t.throw=function(e){if(i)throw i=!1,e;return n("throw",e)}),"function"==typeof e.return&&(t.return=function(e){return i?(i=!1,e):n("return",e)}),t}FP.prototype["function"==typeof Uh&&xP||"@@asyncIterator"]=function(){return this},FP.prototype.next=function(e){return this._invoke("next",e)},FP.prototype.throw=function(e){return this._invoke("throw",e)},FP.prototype.return=function(e){return this._invoke("return",e)};var WP=J(UP),HP={exports:{}};!function(e,t){e.exports=(()=>{var e={8:(e,t,i)=>{i.r(t),i.d(t,{Parser:()=>C,Printer:()=>b,parse:()=>D,print:()=>P});const n="\n",r="".concat("\r").concat(n),s=" ";let o;function a(e){return e>="0"&&e<="9"}function c(e){return e>="!"&&e<="~"}function d(e){return c(e)||e>=""&&e<="ÿ"}function l(e){return "!"===e||e>="#"&&e<="'"||e>="*"&&e<="+"||e>="-"&&e<="."||e>="0"&&e<="9"||e>="A"&&e<="Z"||e>="^"&&e<="~"}function h(e){return e>="1"&&e<="9"}function u(e){return e>="A"&&e<="Z"||e>="a"&&e<="z"}function p(e){return "d"===e||"h"===e||"m"===e||"s"===e}function _(e){return e>""&&e<"\t"||e>"\v"&&e<"\f"||e>""&&e<"ÿ"}function E(e){return u(e)||a(e)||"+"===e||"/"===e}function m(e){return a(e)||u(e)||"+"===e||"/"===e||"-"===e||"_"===e}function f(e){return u(e)||a(e)||"+"===e||"/"===e}function g(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n);}return i}function T(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?g(Object(i),!0).forEach((function(t){S(e,t,i[t]);})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):g(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t));}));}return e}function S(e,t,i){return t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}!function(e){e.VERSION="v",e.ORIGIN="o",e.SESSION_NAME="s",e.INFORMATION="i",e.URI="u",e.EMAIL="e",e.PHONE="p",e.CONNECTION="c",e.BANDWIDTH="b",e.TIME="t",e.REPEAT="r",e.ZONE_ADJUSTMENTS="z",e.KEY="k",e.ATTRIBUTE="a",e.MEDIA="m";}(o||(o={}));class R{consumeText(e,t){let i=t;for(;i<e.length;){const t=e[i];if("\0"===t||"\r"===t||t===n)break;i+=1;}if(i-t==0)throw new Error("Invalid text, at ".concat(e));return i}consumeUnicastAddress(e,t,i){return this.consumeTill(e,t,s)}consumeOneOrMore(e,t,i){let n=t;for(;i(e[n]);)n++;if(n-t==0)throw new Error("Invalid rule at ".concat(t,"."));return n}consumeSpace(e,t){if(e[t]===s)return t+1;throw new Error("Invalid space at ".concat(t,"."))}consumeIP4Address(e,t){let i=t;for(let t=0;t<4;t++)if(i=this.consumeDecimalUChar(e,i),3!==t){if("."!==e[i])throw new Error("Invalid IP4 address.");i++;}return i}consumeDecimalUChar(e,t){let i=t;for(let t=0;t<3&&a(e[i]);t++,i++);if(i-t==0)throw new Error("Invalid decimal uchar.");const n=parseInt(e.slice(t,i));if(n>=0&&n<=255)return i;throw new Error("Invalid decimal uchar")}consumeIP6Address(e,t){let i=this.consumeHexpart(e,t);return ":"===e[i]?(i+=1,i=this.consumeIP4Address(e,i),i):i}consumeHexpart(e,t){let i=t;if(":"===e[i]&&":"===e[i+1]){i+=2;try{i=this.consumeHexseq(e,i);}catch(e){}return i}if(i=this.consumeHexseq(e,i),":"===e[i]&&":"===e[i+1]){i+=2;try{i=this.consumeHexseq(e,i);}catch(e){}return i}return i}consumeHexseq(e,t){let i=t;for(;i=this.consumeHex4(e,i),":"===e[i]&&":"!==e[i+1];)i+=1;return i}consumeHex4(e,t){let i=0;for(;i<4;i++)if(!((n=e[t+i])>="0"&&n<="9"||n>="a"&&n<="f"||n>="A"&&n<="F")){if(0===i)throw new Error("Invalid hex 4");break}var n;return t+i}consumeFQDN(e,t){let i=t;for(;a(e[i])||u(e[i])||"-"===e[i]||"."===e[i];)i+=1;if(i-t<4)throw new Error("Invalid FQDN");return i}consumeExtnAddr(e,t){return this.consumeOneOrMore(e,t,d)}consumeMulticastAddress(e,t,i){switch(i){case"IP4":case"ip4":return this.consumeIP4MulticastAddress(e,t);case"IP6":case"ip6":return this.consumeIP6MulticastAddress(e,t);default:try{return this.consumeFQDN(e,t)}catch(i){return this.consumeExtnAddr(e,t)}}}consumeIP6MulticastAddress(e,t){const i=this.consumeHexpart(e,t);return "/"===e[i]?this.consumeInteger(e,i+1):i}consumeIP4MulticastAddress(e,t){let i=t+3;const n=e.slice(t,i),r=parseInt(n);if(r<224||r>239)throw new Error("Invalid IP4 multicast address, IPv4 multicast addresses may be in the range 224.0.0.0 to 239.255.255.255.");for(let t=0;t<3;t++){if("."!==e[i])throw new Error("Invalid IP4 multicast address.");i+=1,i=this.consumeDecimalUChar(e,i);}return "/"===e[i]&&(i+=1),i=this.consumeTTL(e,i),"/"===e[i]&&(i=this.consumeInteger(e,i)),i}consumeInteger(e,t){if(!h(e[t]))throw new Error("Invalid integer.");for(t+=1;a(e[t]);)t+=1;return t}consumeTTL(e,t){if("0"===e[t])return t+1;if(!h(e[t]))throw new Error("Invalid TTL.");t+=1;for(let i=0;i<2&&a(e[t]);i++)t+=1;return t}consumeToken(e,t){return this.consumeOneOrMore(e,t,l)}consumeTime(e,t){let i=t;if("0"===e[i])return i+1;for(h(e[i])&&(i+=1);a(e[i]);)i++;if(i-t<10)throw new Error("Invalid time");return i}consumeAddress(e,t){return this.consumeTill(e,t,s)}consumeTypedTime(e,t){let i=t;return i=this.consumeOneOrMore(e,i,a),p(e[i])?i+1:i}consumeRepeatInterval(e,t){if(!h(e[t]))throw new Error("Invalid repeat interval");for(t+=1;a(e[t]);)t+=1;return p(e[t])&&(t+=1),t}consumePort(e,t){return this.consumeOneOrMore(e,t,a)}consume(e,t,i){for(let n=0;n<i.length;n++){if(t+n>=e.length)throw new Error("consume exceeding value length");if(e[t+n]!==i[n])throw new Error("consume ".concat(i," failed at ").concat(n))}return t+i.length}consumeTill(e,t,i){let n=t;for(;n<e.length&&("string"!=typeof i||e[n]!==i)&&("function"!=typeof i||!i(e[n]));)n++;return n}}class C extends R{constructor(){super(),S(this,"records",[]),S(this,"currentLine",0);}parse(e){const t=this.probeEOL(e);this.records=e.split(t).filter((e=>!!e.trim())).map(this.parseLine),this.currentLine=0;const i=this.parseVersion(),n=this.parseOrigin(),r=this.parseSessionName(),s=this.parseInformation(),o=this.parseUri(),a=this.parseEmail(),c=this.parsePhone(),d=this.parseConnection(),l=this.parseBandWidth(),h=this.parseTimeFields(),u=this.parseKey(),p=this.parseSessionAttribute(),_=this.parseMediaDescription();if(this.currentLine!==this.records.length)throw new Error("parsing failed, non exhaustive sdp lines.");return {version:i,origin:n,sessionName:r,information:s,uri:o,emails:a,phones:c,connection:d,bandwidths:l,timeFields:h,key:u,attributes:p,mediaDescriptions:_}}getCurrentRecord(){const e=this.records[this.currentLine];if(!e)throw new Error("Record doesn't exit.");return e}probeEOL(e){for(let t=0;t<e.length;t++)if(e[t]===n)return "\r"===e[t-1]?r:n;throw new Error("Invalid newline character.")}parseLine(e,t){if(e.length<2)throw new Error("Invalid sdp line, sdp line should be of form <type>=<value>.");const i=e[0];if("="!==e[1])throw new Error('Invalid sdp line, <type> should be a single character followed by an "=" sign.');return {type:i,value:e.slice(2),line:t,cur:0}}parseSessionAttribute(){const e=new I;for(;this.currentLine<this.records.length;){const t=this.getCurrentRecord();if(t.type!==o.ATTRIBUTE)break;const i={attField:this.extractOneOrMore(t,(e=>l(e)&&":"!==e)),_cur:0};":"===t.value[t.cur]&&(t.cur+=1,i.attValue=this.extractOneOrMore(t,_)),e.parse(i),this.currentLine++;}return e.digest()}parseMediaAttributes(e){const t=new y(e);for(;this.currentLine<this.records.length;){const e=this.getCurrentRecord();if(e.type!==o.ATTRIBUTE)break;const i={attField:this.extractOneOrMore(e,(e=>l(e)&&":"!==e)),_cur:0};":"===e.value[e.cur]&&(e.cur+=1,i.attValue=this.extractOneOrMore(e,_)),t.parse(i),this.currentLine++;}return t.digest()}parseKey(){const e=this.getCurrentRecord();if(e.type===o.KEY){if("prompt"===e.value||"clear:"===e.value||"base64:"===e.value||"uri:"===e.value)return e.value;throw this.currentLine++,new Error("Invalid key.")}}parseZone(){const e=this.getCurrentRecord();if(e.type===o.ZONE_ADJUSTMENTS){const t=[];for(;;)try{const i=this.extract(e,this.consumeTime);this.consumeSpaceForRecord(e);let n=!1;"-"===e.value[e.cur]&&(n=!0,e.cur+=1);const r=this.extract(e,this.consumeTypedTime);t.push({time:i,typedTime:r,back:n});}catch(e){break}if(0===t.length)throw new Error("Invalid zone adjustments");return this.currentLine++,t}return []}parseRepeat(){const e=[];for(;;){const t=this.getCurrentRecord();if(t.type!==o.REPEAT)break;{const i=this.extract(t,this.consumeRepeatInterval),n=this.parseTypedTime(t);e.push({repeatInterval:i,typedTimes:n}),this.currentLine++;}}return e}parseTypedTime(e){const t=[];for(;;)try{this.consumeSpaceForRecord(e),t.push(this.extract(e,this.consumeTypedTime));}catch(e){break}if(0===t.length)throw new Error("Invalid typed time.");return t}parseTime(){const e=this.getCurrentRecord(),t=this.extract(e,this.consumeTime);this.consumeSpaceForRecord(e);const i=this.extract(e,this.consumeTime);return this.currentLine++,{startTime:t,stopTime:i}}parseBandWidth(){const e=[];for(;this.currentLine<this.records.length;){const t=this.getCurrentRecord();if(t.type!==o.BANDWIDTH)break;{const i=this.extractOneOrMore(t,l);if(":"!==t.value[t.cur])throw new Error("Invalid bandwidth field.");t.cur++;const n=this.extractOneOrMore(t,a);e.push({bwtype:i,bandwidth:n}),this.currentLine++;}}return e}parseVersion(){const e=this.getCurrentRecord();if(e.type!==o.VERSION)throw new Error("first sdp record must be version");const t=e.value.slice(0,this.consumeOneOrMore(e.value,0,a));if(t.length!==e.value.length)throw new Error('invalid proto version, "v='.concat(e.value,'"'));return this.currentLine++,t}parseOrigin(){const e=this.getCurrentRecord();if(e.type!==o.ORIGIN)throw new Error("second line of sdp must be origin");const t=this.extractOneOrMore(e,d);this.consumeSpaceForRecord(e);const i=this.extractOneOrMore(e,a);this.consumeSpaceForRecord(e);const n=this.extractOneOrMore(e,a);this.consumeSpaceForRecord(e);const r=this.extractOneOrMore(e,l);this.consumeSpaceForRecord(e);const s=this.extractOneOrMore(e,l);this.consumeSpaceForRecord(e);const c=this.extract(e,this.consumeUnicastAddress);return this.currentLine++,{username:t,sessId:i,sessVersion:n,nettype:r,addrtype:s,unicastAddress:c}}parseSessionName(){const e=this.getCurrentRecord();if(e.type===o.SESSION_NAME){const t=this.extract(e,this.consumeText);return this.currentLine++,t}}parseInformation(){const e=this.getCurrentRecord();if(e.type!==o.INFORMATION)return;const t=this.extract(e,this.consumeText);return this.currentLine++,t}parseUri(){const e=this.getCurrentRecord();if(e.type===o.URI)return this.currentLine++,e.value}parseEmail(){const e=[];for(;;){const t=this.getCurrentRecord();if(t.type!==o.EMAIL)break;e.push(t.value),this.currentLine++;}return e}parsePhone(){const e=[];for(;;){const t=this.getCurrentRecord();if(t.type!==o.PHONE)break;e.push(t.value),this.currentLine++;}return e}parseConnection(){const e=this.getCurrentRecord();if(e.type===o.CONNECTION){const t=this.extractOneOrMore(e,l);this.consumeSpaceForRecord(e);const i=this.extractOneOrMore(e,l);this.consumeSpaceForRecord(e);const n=this.extract(e,this.consumeAddress);return this.currentLine++,{nettype:t,addrtype:i,address:n}}}parseMedia(){const e=this.getCurrentRecord(),t=this.extract(e,this.consumeToken);this.consumeSpaceForRecord(e);let i=this.extract(e,this.consumePort);"/"===e.value[e.cur]&&(e.cur+=1,i+=this.extract(e,this.consumeInteger)),this.consumeSpaceForRecord(e);const n=[];for(n.push(this.extract(e,this.consumeToken));"/"===e.value[e.cur];)e.cur+=1,n.push(this.extract(e,this.consumeToken));if(0===n.length)throw new Error("Invalid proto");const r=this.parseFmt(e);return this.currentLine++,{mediaType:t,port:i,protos:n,fmts:r}}parseTimeFields(){const e=[];for(;this.getCurrentRecord().type===o.TIME;){const t=this.parseTime(),i=this.parseRepeat(),n=this.parseZone();e.push({time:t,repeats:i,zones:n});}return e}parseMediaDescription(){const e=[];for(;this.currentLine<this.records.length&&this.getCurrentRecord().type===o.MEDIA;){const t=this.parseMedia(),i=this.parseInformation(),n=this.parseConnections(),r=this.parseBandWidth(),s=this.parseKey(),o=this.parseMediaAttributes(t);e.push({media:t,information:i,connections:n,bandwidths:r,key:s,attributes:o});}return e}parseConnections(){const e=[];for(;this.currentLine<this.records.length&&this.getCurrentRecord().type===o.CONNECTION;)e.push(this.parseConnection());return e}parseFmt(e){const t=[];for(;;)try{this.consumeSpaceForRecord(e),t.push(this.extract(e,this.consumeToken));}catch(e){break}if(0===t.length)throw new Error("Invalid fmts");return t}extract(e,t,...i){const n=t.call(this,e.value,e.cur,...i),r=e.value.slice(e.cur,n);return e.cur=n,r}extractOneOrMore(e,t){const i=this.consumeOneOrMore(e.value,e.cur,t),n=e.value.slice(e.cur,i);return e.cur=i,n}consumeSpaceForRecord(e){if(e.value[e.cur]!==s)throw new Error("Invalid space at ".concat(e.cur,"."));e.cur+=1;}}class v extends R{constructor(...e){super(...e),S(this,"attributes",void 0),S(this,"digested",!1);}extractOneOrMore(e,t,i){const n=this.consumeOneOrMore(e.attValue,e._cur,t),r=e.attValue.slice(e._cur,n),[s,o]=i||[];if("number"==typeof s&&r.length<s)throw new Error("error in length, should be more or equal than ".concat(s," characters."));if("number"==typeof o&&r.length>o)throw new Error("error in length, should be less or equal than ".concat(o," characters."));return e._cur=n,r}consumeAttributeSpace(e){if(e.attValue[e._cur]!==s)throw new Error("Invalid space at ".concat(e._cur,"."));e._cur+=1;}extract(e,t,...i){if(!e.attValue)throw new Error("Nothing to extract from attValue.");const n=t.call(this,e.attValue,e._cur,...i),r=e.attValue.slice(e._cur,n);return e._cur=n,r}atEnd(e){if(!e.attValue)throw new Error;return e._cur>=e.attValue.length}peekChar(e){if(!e.attValue)throw new Error;return e.attValue[e._cur]}peek(e,t){if(!e.attValue)throw new Error;for(let i=0;i<t.length;i++)if(t[i]!==e.attValue[e._cur+i])return !1;return !0}parseIceUfrag(e){if(this.attributes.iceUfrag)throw new Error("Invalid ice-ufrag, should be only a single line if 'a=ice-ufrag'");this.attributes.iceUfrag=this.extractOneOrMore(e,E,[4,256]);}parseIcePwd(e){if(this.attributes.icePwd)throw new Error("Invalid ice-pwd, should be only a single line if 'a=ice-pwd'");this.attributes.icePwd=this.extractOneOrMore(e,E,[22,256]);}parseIceOptions(e){if(this.attributes.iceOptions)throw new Error("Invalid ice-options, should be only one 'ice-options' line");const t=[];for(;!this.atEnd(e);){t.push(this.extractOneOrMore(e,E));try{this.consumeAttributeSpace(e);}catch(t){if(this.atEnd(e))break;throw t}}this.attributes.iceOptions=t;}parseFingerprint(e){const t=this.extract(e,this.consumeToken);this.consumeAttributeSpace(e);const i=this.extract(e,this.consumeTill);this.attributes.fingerprints.push({hashFunction:t,fingerprint:i});}parseExtmap(e){const t=this.extractOneOrMore(e,a);let i;"/"===this.peekChar(e)&&(this.extract(e,this.consume,"/"),i=this.extract(e,this.consumeToken)),this.consumeAttributeSpace(e);const n=this.extract(e,this.consumeTill,s),r=T(T({entry:parseInt(t,10)},i&&{direction:i}),{},{extensionName:n});this.peekChar(e)===s&&(this.consumeAttributeSpace(e),r.extensionAttributes=this.extract(e,this.consumeTill)),this.attributes.extmaps.push(r);}parseSetup(e){if(this.attributes.setup)throw new Error("must only be one single 'a=setup' line.");const t=this.extract(e,this.consumeTill);if("active"!==t&&"passive"!==t&&"actpass"!==t&&"holdconn"!==t)throw new Error("role must be one of 'active', 'passive', 'actpass', 'holdconn'.");this.attributes.setup=t;}}class I extends v{constructor(...e){super(...e),S(this,"attributes",{unrecognized:[],groups:[],extmaps:[],fingerprints:[],identities:[]});}parse(e){if(this.digested)throw new Error("already digested");try{switch(e.attField){case"group":this.parseGroup(e);break;case"ice-lite":this.parseIceLite();break;case"ice-ufrag":this.parseIceUfrag(e);break;case"ice-pwd":this.parseIcePwd(e);break;case"ice-options":this.parseIceOptions(e);break;case"fingerprint":this.parseFingerprint(e);break;case"setup":this.parseSetup(e);break;case"tls-id":this.parseTlsId(e);break;case"identity":this.parseIdentity(e);break;case"extmap":this.parseExtmap(e);break;case"msid-semantic":this.parseMsidSemantic(e);break;default:e.ignored=!0,this.attributes.unrecognized.push(e);}}catch(t){throw console.error("parsing session attribute ".concat(e.attField,' error, "a=').concat(e.attField,":").concat(e.attValue,'"')),t}if(!e.ignored&&e.attValue&&!this.atEnd(e))throw new Error("attribute parsing error")}digest(){return this.digested=!0,this.attributes}parseGroup(e){const t=this.extract(e,this.consumeToken),i=[];for(;!this.atEnd(e)&&this.peekChar(e)===s;)this.consumeAttributeSpace(e),i.push(this.extract(e,this.consumeToken));this.attributes.groups.push({semantic:t,identificationTag:i});}parseIceLite(){if(this.attributes.iceLite)throw new Error("Invalid ice-lite, should be only a single line of 'a=ice-lite'");this.attributes.iceLite=!0;}parseTlsId(e){if(this.attributes.tlsId)throw new Error("must be only one tld-id line");this.attributes.tlsId=this.extractOneOrMore(e,m);}parseIdentity(e){const t=this.extractOneOrMore(e,f),i=[];for(;!this.atEnd(e)&&this.peekChar(e)===s;){this.consumeAttributeSpace(e);const t=this.extract(e,this.consumeToken);this.extract(e,this.consume,"=");const n=this.extractOneOrMore(e,(e=>e!==s&&_(e)));i.push({name:t,value:n});}this.attributes.identities.push({assertionValue:t,extensions:i});}parseMsidSemantic(e){this.peekChar(e)===s&&this.consumeAttributeSpace(e);const t={semantic:this.extract(e,this.consumeToken),identifierList:[]};for(;;){try{this.consumeAttributeSpace(e);}catch(e){break}if("*"===this.peekChar(e)){this.extract(e,this.consume,"*"),t.applyForAll=!0;break}{const i=this.extract(e,this.consumeTill,s);t.identifierList.push(i);}}this.attributes.msidSemantic=t;}}class y extends v{constructor(e){super(),S(this,"attributes",void 0),-1!==e.protos.indexOf("RTP")||e.protos.indexOf("rtp"),this.attributes={unrecognized:[],candidates:[],extmaps:[],fingerprints:[],imageattr:[],msids:[],remoteCandidatesList:[],rids:[],ssrcs:[],ssrcGroups:[],rtcpFeedbackWildcards:[],payloads:[]};}parse(e){if(this.digested)throw new Error("already digested");try{switch(e.attField){case"extmap":this.parseExtmap(e);break;case"setup":this.parseSetup(e);break;case"ice-ufrag":this.parseIceUfrag(e);break;case"ice-pwd":this.parseIcePwd(e);break;case"ice-options":this.parseIceOptions(e);break;case"candidate":this.parseCandidate(e);break;case"remote-candidate":this.parseRemoteCandidate(e);break;case"end-of-candidates":this.parseEndOfCandidates();break;case"fingerprint":this.parseFingerprint(e);break;case"rtpmap":this.parseRtpmap(e);break;case"ptime":this.parsePtime(e);break;case"maxptime":this.parseMaxPtime(e);break;case"sendrecv":case"recvonly":case"sendonly":case"inactive":this.parseDirection(e);break;case"ssrc":this.parseSSRC(e);break;case"fmtp":this.parseFmtp(e);break;case"rtcp-fb":this.parseRtcpFb(e);break;case"rtcp-mux":this.parseRTCPMux();break;case"rtcp-mux-only":this.parseRTCPMuxOnly();break;case"rtcp-rsize":this.parseRTCPRsize();break;case"rtcp":this.parseRTCP(e);break;case"mid":this.parseMid(e);break;case"msid":this.parseMsid(e);break;case"imageattr":this.parseImageAttr(e);break;case"rid":this.parseRid(e);break;case"simulcast":this.parseSimulcast(e);break;case"sctp-port":this.parseSctpPort(e);break;case"max-message-size":this.parseMaxMessageSize(e);break;case"ssrc-group":this.parseSSRCGroup(e);break;default:e.ignored=!0,this.attributes.unrecognized.push(e);}}catch(t){throw console.error("parsing media attribute ".concat(e.attField,' error, "a=').concat(e.attField,":").concat(e.attValue,'"')),t}if(!e.ignored&&e.attValue&&!this.atEnd(e))throw new Error("attribute parsing error")}parseCandidate(e){const t=this.extractOneOrMore(e,E,[1,32]);this.consumeAttributeSpace(e);const i=this.extractOneOrMore(e,a,[1,5]);this.consumeAttributeSpace(e);const n=this.extract(e,this.consumeToken);this.consumeAttributeSpace(e);const r=this.extractOneOrMore(e,a,[1,10]);this.consumeAttributeSpace(e);const o=this.extract(e,this.consumeAddress);this.consumeAttributeSpace(e);const d=this.extract(e,this.consumePort);this.consumeAttributeSpace(e),this.extract(e,this.consume,"typ"),this.consumeAttributeSpace(e);const l={foundation:t,componentId:i,transport:n,priority:r,connectionAddress:o,port:d,type:this.extract(e,this.consumeToken),extension:{}};for(this.peek(e," raddr")&&(this.extract(e,this.consume," raddr"),this.consumeAttributeSpace(e),l.relAddr=this.extract(e,this.consumeAddress)),this.peek(e," rport")&&(this.extract(e,this.consume," rport"),this.consumeAttributeSpace(e),l.relPort=this.extract(e,this.consumePort));this.peekChar(e)===s;){this.consumeAttributeSpace(e);const t=this.extract(e,this.consumeToken);this.consumeAttributeSpace(e),l.extension[t]=this.extractOneOrMore(e,c);}this.attributes.candidates.push(l);}parseRemoteCandidate(e){const t=[];for(;;){const i=this.extractOneOrMore(e,a,[1,5]);this.consumeAttributeSpace(e);const n=this.extract(e,this.consumeAddress);this.consumeAttributeSpace(e);const r=this.extract(e,this.consumePort);t.push({componentId:i,connectionAddress:n,port:r});try{this.consumeAttributeSpace(e);}catch(e){break}}this.attributes.remoteCandidatesList.push(t);}parseEndOfCandidates(){if(this.attributes.endOfCandidates)throw new Error("must be only one line of end-of-candidates");this.attributes.endOfCandidates=!0;}parseRtpmap(e){const t=this.extract(e,this.consumeToken);this.consumeAttributeSpace(e);const i=this.extract(e,this.consumeTill,"/");this.extract(e,this.consume,"/");const n={encodingName:i,clockRate:this.extractOneOrMore(e,a)};this.atEnd(e)||"/"!==this.peekChar(e)||(this.extract(e,this.consume,"/"),n.encodingParameters=parseInt(this.extract(e,this.consumeTill),10));const r=this.attributes.payloads.find((e=>e.payloadType===parseInt(t,10)));r?r.rtpMap=n:this.attributes.payloads.push({payloadType:parseInt(t,10),rtpMap:n,rtcpFeedbacks:[]});}parsePtime(e){if(this.attributes.ptime)throw new Error("must be only one line of ptime");this.attributes.ptime=this.extract(e,this.consumeTill);}parseMaxPtime(e){if(this.attributes.maxPtime)throw new Error("must be only one line of ptime");this.attributes.maxPtime=this.extract(e,this.consumeTill);}parseDirection(e){if(this.attributes.direction)throw new Error("must be only one line of direction info");this.attributes.direction=e.attField;}parseSSRC(e){const t=this.extractOneOrMore(e,a);this.consumeAttributeSpace(e);const i=this.extract(e,this.consumeTill,":");let n;":"===this.peekChar(e)&&(this.extract(e,this.consume,":"),n=this.extract(e,this.consumeTill));const r=this.attributes.ssrcs.find((e=>e.ssrcId===parseInt(t,10)));r?r.attributes[i]=n:this.attributes.ssrcs.push({ssrcId:parseInt(t,10),attributes:{[i]:n}});}parseFmtp(e){const t=this.extract(e,this.consumeTill,s);this.consumeAttributeSpace(e);const i=this.extract(e,this.consumeTill),n={};i.split(";").forEach((e=>{let[t,i]=e.split("=");t=t.trim();const r="string"==typeof i?i.trim():null;"string"==typeof t&&t.length>0&&(n[t]=r);}));const r=this.attributes.payloads.find((e=>e.payloadType===parseInt(t,10)));r?r.fmtp={parameters:n}:this.attributes.payloads.push({payloadType:parseInt(t,10),rtcpFeedbacks:[],fmtp:{parameters:n}});}parseFmtParameters(e){const t={},i=this.extract(e,this.consumeTill,"=");e._cur++;const n=this.extract(e,this.consumeTill,";");for(t[i]=n;";"===e.attValue[e._cur];){const i=this.extract(e,this.consumeTill,"=");e._cur++;const n=this.extract(e,this.consumeTill,";");t[i]=n;}return t}parseRtcpFb(e){let t="";t="*"===this.peekChar(e)?this.extract(e,this.consume,"*"):this.extract(e,this.consumeTill,s),this.consumeAttributeSpace(e);const i=this.extract(e,this.consumeTill,s);let n;if("trr-int"===i)n={type:i,interval:this.extract(e,this.consumeTill)};else {const t={type:i};this.peekChar(e)===s&&(this.consumeAttributeSpace(e),t.parameter=this.extract(e,this.consumeToken),this.peekChar(e)===s&&(t.additional=this.extract(e,this.consumeTill))),n=t;}if("*"===t)this.attributes.rtcpFeedbackWildcards.push(n);else {const e=this.attributes.payloads.find((e=>e.payloadType===parseInt(t,10)));e?e.rtcpFeedbacks.push(n):this.attributes.payloads.push({payloadType:parseInt(t,10),rtcpFeedbacks:[n]});}}parseRTCPMux(){if(this.attributes.rtcpMux)throw new Error("must be single line of rtcp-mux");this.attributes.rtcpMux=!0;}parseRTCPMuxOnly(){if(this.attributes.rtcpMuxOnly)throw new Error("must be single line of rtcp-only");this.attributes.rtcpMuxOnly=!0;}parseRTCPRsize(){if(this.attributes.rtcpRsize)throw new Error("must be single line of rtcp-rsize");this.attributes.rtcpRsize=!0;}parseRTCP(e){if(this.attributes.rtcp)throw new Error("must be single line of rtcp");const t={port:this.extract(e,this.consumePort)};this.peekChar(e)===s&&(this.consumeAttributeSpace(e),t.netType=this.extractOneOrMore(e,l),this.consumeAttributeSpace(e),t.addressType=this.extractOneOrMore(e,l),this.consumeAttributeSpace(e),t.address=this.extract(e,this.consumeAddress)),this.attributes.rtcp=t;}parseMsid(e){const t={id:this.extractOneOrMore(e,l,[1,64])};this.peekChar(e)===s&&(this.consumeAttributeSpace(e),t.appdata=this.extractOneOrMore(e,l,[1,64])),this.attributes.msids.push(t);}parseImageAttr(e){this.attributes.imageattr.push(e.attValue);}parseRid(e){const t=this.extractOneOrMore(e,(e=>u(e)||a(e)||"_"===e||"-"===e));this.consumeAttributeSpace(e);const i={id:t,direction:this.extract(e,this.consumeToken),params:[]};if(this.peekChar(e)===s){if(this.consumeAttributeSpace(e),this.peek(e,"pt=")){this.extract(e,this.consume,"pt=");const t=[];for(;;){const i=this.extract(e,this.consumeToken);t.push(i);try{this.extract(e,this.consume,",");}catch(e){break}}i.payloads=t,this.peekChar(e)===s&&this.extract(e,this.consume,s);}for(;;){const t=this.extract(e,this.consumeToken);switch(t){case"depend":{const n={type:t,rids:this.extract(e,this.consume,"=").split(",")};i.params.push(n);break}default:{const n={type:t};"="===this.peekChar(e)&&(this.extract(e,this.consume,"="),n.val=this.extract(e,this.consumeTill,";")),i.params.push(n);}}try{this.extract(e,this.consume,";");}catch(e){break}}}this.attributes.rids.push(i);}parseSimulcast(e){if(this.attributes.simulcast)throw new Error("must be single line of simulcast");this.attributes.simulcast=e.attValue,this.extract(e,this.consumeTill);}parseSctpPort(e){this.attributes.sctpPort=this.extractOneOrMore(e,a,[1,5]);}parseMaxMessageSize(e){this.attributes.maxMessageSize=this.extractOneOrMore(e,a,[1,void 0]);}digest(){return this.digested=!0,this.attributes}parseMid(e){this.attributes.mid=this.extract(e,this.consumeToken);}parseSSRCGroup(e){const t=this.extract(e,this.consumeToken),i=[];for(;;)try{this.consumeAttributeSpace(e);const t=this.extract(e,this.consumeInteger);i.push(parseInt(t,10));}catch(e){break}this.attributes.ssrcGroups.push({semantic:t,ssrcIds:i});}}function A(e,t,i){return t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}class b{constructor(){A(this,"eol",r);}print(e,t){let i="";return t&&(this.eol=t),i+=this.printVersion(e.version),i+=this.printOrigin(e.origin),i+=this.printSessionName(e.sessionName),i+=this.printInformation(e.information),i+=this.printUri(e.uri),i+=this.printEmail(e.emails),i+=this.printPhone(e.phones),i+=this.printConnection(e.connection),i+=this.printBandwidth(e.bandwidths),i+=this.printTimeFields(e.timeFields),i+=this.printKey(e.key),i+=this.printSessionAttributes(e.attributes),i+=this.printMediaDescription(e.mediaDescriptions),i}printVersion(e){return "v=".concat(e).concat(this.eol)}printOrigin(e){return "o=".concat(e.username," ").concat(e.sessId," ").concat(e.sessVersion," ").concat(e.nettype," ").concat(e.addrtype," ").concat(e.unicastAddress).concat(this.eol)}printSessionName(e){return e?"s=".concat(e).concat(this.eol):""}printInformation(e){return e?"i=".concat(e).concat(this.eol):""}printUri(e){return e?"u=".concat(e).concat(this.eol):""}printEmail(e){let t="";for(const i of e)t+="e=".concat(i).concat(this.eol);return t}printPhone(e){let t="";for(const i of e)t+="e=".concat(i).concat(this.eol);return t}printConnection(e){return e?"c=".concat(e.nettype," ").concat(e.addrtype," ").concat(e.address).concat(this.eol):""}printBandwidth(e){let t="";for(const i of e)t+="b=".concat(i.bwtype,":").concat(i.bandwidth).concat(this.eol);return t}printTimeFields(e){let t="";for(const i of e){t+="t=".concat(i.time.startTime," ").concat(i.time.startTime).concat(this.eol);for(const e of i.repeats)t+="r=".concat(e.repeatInterval," ").concat(e.typedTimes.join(" ")).concat(this.eol);i.zoneAdjustments&&(t+="z=",t+="z=".concat(i.zoneAdjustments.map((e=>"".concat(e.time," ").concat(e.back?"-":""," ").concat(e.typedTime))).join(" ")).concat(this.eol),t+=this.eol);}return t}printKey(e){return e?"k=".concat(e).concat(this.eol):""}printAttributes(e){let t="";for(const i of e)t+="a=".concat(i.attField).concat(i.attValue?":".concat(i.attValue):"").concat(this.eol);return t}printMediaDescription(e){let t="";for(const i of e)t+=this.printMedia(i.media),t+=this.printInformation(i.information),t+=this.printConnections(i.connections),t+=this.printBandwidth(i.bandwidths),t+=this.printKey(i.key),t+=this.printMediaAttributes(i);return t}printConnections(e){let t="";for(const i of e)t+=this.printConnection(i);return t}printMedia(e){return "m=".concat(e.mediaType," ").concat(e.port," ").concat(e.protos.join("/")," ").concat(e.fmts.join(" ")).concat(this.eol)}printSessionAttributes(e){return new O(this.eol).print(e)}printMediaAttributes(e){return new N(this.eol).print(e)}}class w{constructor(e){A(this,"eol",void 0),this.eol=e;}printIceUfrag(e){return void 0===e?"":"a=ice-ufrag:".concat(e).concat(this.eol)}printIcePwd(e){return void 0===e?"":"a=ice-pwd:".concat(e).concat(this.eol)}printIceOptions(e){return void 0===e?"":"a=ice-options:".concat(e.join(s)).concat(this.eol)}printFingerprints(e){return e.length>0?e.map((e=>"a=fingerprint:".concat(e.hashFunction).concat(s).concat(e.fingerprint))).join(this.eol)+this.eol:""}printExtmap(e){return e.map((e=>"a=extmap:".concat(e.entry).concat(e.direction?"/".concat(e.direction):"").concat(s).concat(e.extensionName).concat(e.extensionAttributes?"".concat(s).concat(e.extensionAttributes):"").concat(this.eol))).join("")}printSetup(e){return void 0===e?"":"a=setup:".concat(e).concat(this.eol)}printUnrecognized(e){return e.map((e=>"a=".concat(e.attField).concat(e.attValue?":".concat(e.attValue):"").concat(this.eol))).join("")}}class O extends w{print(e){let t="";return t+=this.printGroups(e.groups),t+=this.printMsidSemantic(e.msidSemantic),t+=this.printIceLite(e.iceLite),t+=this.printIceUfrag(e.iceUfrag),t+=this.printIcePwd(e.icePwd),t+=this.printIceOptions(e.iceOptions),t+=this.printFingerprints(e.fingerprints),t+=this.printSetup(e.setup),t+=this.printTlsId(e.tlsId),t+=this.printIdentity(e.identities),t+=this.printExtmap(e.extmaps),t+=this.printUnrecognized(e.unrecognized),t}printGroups(e){let t="";return e.length>0&&(t+=e.map((e=>"a=group:".concat(e.semantic).concat(e.identificationTag.map((e=>"".concat(s).concat(e))).join("")).concat(this.eol))).join("")),t}printIceLite(e){return void 0===e?"":"a=ice-lite"+this.eol}printTlsId(e){return e?"a=tls-id:".concat(e).concat(this.eol):""}printIdentity(e){return 0===e.length?"":e.map((e=>"a=identity:".concat(e.assertionValue).concat(e.extensions.map((e=>"".concat(s).concat(e.name).concat(e.value?"=".concat(e.value):"")))))).join(this.eol)+this.eol}printMsidSemantic(e){if(!e)return "";let t="a=msid-semantic:".concat(e.semantic);return e.applyForAll?t+="".concat(s,"*"):e.identifierList.length>0&&(t+=e.identifierList.map((e=>"".concat(s).concat(e)))),t+this.eol}}class N extends w{print(e){const t=e.attributes;let i="";return i+=this.printRTCP(t.rtcp),i+=this.printIceUfrag(t.iceUfrag),i+=this.printIcePwd(t.icePwd),i+=this.printIceOptions(t.iceOptions),i+=this.printCandidates(t.candidates),i+=this.printRemoteCandidatesList(t.remoteCandidatesList),i+=this.printEndOfCandidates(t.endOfCandidates),i+=this.printFingerprints(t.fingerprints),i+=this.printSetup(t.setup),i+=this.printMid(t.mid),i+=this.printExtmap(t.extmaps),i+=this.printRTPRelated(t),i+=this.printPtime(t.ptime),i+=this.printMaxPtime(t.maxPtime),i+=this.printDirection(t.direction),i+=this.printSSRCGroups(t.ssrcGroups),i+=this.printSSRC(t.ssrcs),i+=this.printRTCPMux(t.rtcpMux),i+=this.printRTCPMuxOnly(t.rtcpMuxOnly),i+=this.printRTCPRsize(t.rtcpRsize),i+=this.printMSId(t.msids),i+=this.printImageattr(t.imageattr),i+=this.printRid(t.rids),i+=this.printSimulcast(t.simulcast),i+=this.printSCTPPort(t.sctpPort),i+=this.printMaxMessageSize(t.maxMessageSize),i+=this.printUnrecognized(t.unrecognized),i}printCandidates(e){return e.map((e=>"a=candidate:".concat(e.foundation).concat(s).concat(e.componentId).concat(s).concat(e.transport).concat(s).concat(e.priority).concat(s).concat(e.connectionAddress).concat(s).concat(e.port).concat(s,"typ").concat(s).concat(e.type).concat(e.relAddr?"".concat(s,"raddr").concat(s).concat(e.relAddr):"").concat(e.relPort?"".concat(s,"rport").concat(s).concat(e.relPort):"").concat(Object.keys(e.extension).map((t=>"".concat(s).concat(t).concat(s).concat(e.extension[t]))).join("")).concat(this.eol))).join("")}printRemoteCandidatesList(e){return e.map((e=>"a=remote-candidates:".concat(e.join(s)).concat(this.eol))).join("")}printEndOfCandidates(e){return void 0===e?"":"a=end-of-candidates"+this.eol}printRTPRelated(e){if(!e.payloads)return "";const t=e.payloads;let i="";i+=e.rtcpFeedbackWildcards.map((e=>this.printRTCPFeedback("*",e))).join("");for(const e of t)i+=this.printRtpMap(e.payloadType,e.rtpMap),i+=this.printFmtp(e.payloadType,e.fmtp),i+=e.rtcpFeedbacks.map((t=>this.printRTCPFeedback(e.payloadType,t))).join("");return i}printFmtp(e,t){if(!t)return "";const i=Object.keys(t.parameters);return 1===i.length&&null===t.parameters[i[0]]?"a=fmtp:".concat(e).concat(s).concat(i[0]).concat(this.eol):"a=fmtp:".concat(e).concat(s).concat(Object.keys(t.parameters).map((e=>"".concat(e,"=").concat(t.parameters[e]))).join(";")).concat(this.eol)}printRtpMap(e,t){return t?"a=rtpmap:".concat(e).concat(s).concat(t.encodingName,"/").concat(t.clockRate).concat(t.encodingParameters?"/".concat(t.encodingParameters):"").concat(this.eol):""}printRTCPFeedback(e,t){let i="a=rtcp-fb:".concat(e).concat(s),n=t;return "trr-int"===n.type?i+="ttr-int".concat(s).concat(n.interval):(i+="".concat(n.type),n.parameter&&(i+="".concat(s).concat(n.parameter),n.additional&&(i+="".concat(s).concat(n.additional)))),i+this.eol}printPtime(e){return void 0===e?"":"a=ptime:".concat(e).concat(this.eol)}printMaxPtime(e){return void 0===e?"":"a=maxptime:".concat(e).concat(this.eol)}printDirection(e){return void 0===e?"":"a=".concat(e).concat(this.eol)}printSSRC(e){return e.map((e=>Object.keys(e.attributes).map((t=>"a=ssrc:".concat(e.ssrcId.toString(10)).concat(s).concat(t).concat(e.attributes[t]?":".concat(e.attributes[t]):"").concat(this.eol))).join(""))).join("")}printRTCPMux(e){return void 0===e?"":"a=rtcp-mux".concat(this.eol)}printRTCPMuxOnly(e){return void 0===e?"":"a=rtcp-mux-only".concat(this.eol)}printRTCPRsize(e){return void 0===e?"":"a=rtcp-rsize".concat(this.eol)}printRTCP(e){if(void 0===e)return "";let t="a=rtcp:".concat(e.port);return e.netType&&(t+="".concat(s).concat(e.netType)),e.addressType&&(t+="".concat(s).concat(e.addressType)),e.address&&(t+="".concat(s).concat(e.address)),t+this.eol}printMSId(e){return e.map((e=>"a=msid:".concat(e.id).concat(e.appdata?"".concat(s).concat(e.appdata):"").concat(this.eol))).join("")}printImageattr(e){return e.map((e=>"a=imageattr:".concat(e).concat(this.eol))).join("")}printRid(e){return e.map((e=>{let t="a=rid:".concat(e.id).concat(s).concat(e.direction);return e.payloads&&(t+="".concat(s,"pt=").concat(e.payloads.join(","))),e.params.length>0&&(t+="".concat(s).concat(e.params.map((e=>"depend"===e.type?"depend=".concat(e.rids.join(",")):"".concat(e.type,"=").concat(e.val))).join(";"))),t+this.eol})).join("")}printSimulcast(e){return void 0===e?"":"a=simulcast:".concat(e).concat(this.eol)}printSCTPPort(e){return void 0===e?"":"a=sctp-port:".concat(e).concat(this.eol)}printMaxMessageSize(e){return void 0===e?"":"a=max-message-size:".concat(e).concat(this.eol)}printMid(e){return void 0===e?"":"a=mid:".concat(e).concat(this.eol)}printSSRCGroups(e){return e.map((e=>"a=ssrc-group:".concat(e.semantic).concat(e.ssrcIds.map((e=>"".concat(s).concat(e.toString(10)))).join("")).concat(this.eol))).join("")}}function D(e){return (new C).parse(e)}function P(e,t){return (new b).print(e,t)}}},t={};function i(n){if(t[n])return t[n].exports;var r=t[n]={exports:{}};return e[n](r,r.exports,i),r.exports}return i.d=(e,t)=>{for(var n in t)i.o(t,n)&&!i.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]});},i.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),i.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0});},i(8)})();}(HP);var KP=HP.exports;function YP(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n);}return i}function qP(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?YP(Object(i),!0).forEach((function(t){nu(e,t,i[t]);})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):YP(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t));}));}return e}function JP(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},n=arguments.length>3?arguments[3]:void 0;const{filterRTX:r,filterVideoFec:s,filterAudioFec:o,filterAudioCodec:a,filterVideoCodec:c}=t,{useXR:d}=i;let l=[],h=[],u=[],p=[],_=!1,E=!1;if(KP.parse(e).mediaDescriptions.forEach((e=>{n&&n!==e.attributes.direction||("video"!==e.media.mediaType||_||(h=e.attributes.payloads,p=e.attributes.extmaps,_=!0),"audio"!==e.media.mediaType||E||(l=e.attributes.payloads,u=e.attributes.extmaps,E=!0));})),!p||0===h.length)throw new Error("Cannot get video capabilities from SDP.");if(!u||0===l.length)throw new Error("Cannot get audio capabilities from SDP.");h.forEach((e=>{var t;null!==(t=e.rtpMap)&&void 0!==t&&t.clockRate&&(e.rtpMap.clockRate=parseInt(e.rtpMap.clockRate)),d&&e.rtcpFeedbacks.push({type:"rrtr"});})),l.forEach((e=>{var t;null!==(t=e.rtpMap)&&void 0!==t&&t.clockRate&&(e.rtpMap.clockRate=parseInt(e.rtpMap.clockRate)),d&&e.rtcpFeedbacks.push({type:"rrtr"});})),r&&(l=l.filter((e=>{var t;return "rtx"!==(null===(t=e.rtpMap)||void 0===t?void 0:t.encodingName.toLowerCase())})),h=h.filter((e=>{var t;return "rtx"!==(null===(t=e.rtpMap)||void 0===t?void 0:t.encodingName.toLowerCase())}))),s&&(h=h.filter((e=>{var t;return !/(red)|(ulpfec)|(flexfec)/i.test((null===(t=e.rtpMap)||void 0===t?void 0:t.encodingName)||"")}))),o&&(l=l.filter((e=>{var t;return !/(red)|(ulpfec)|(flexfec)/i.test((null===(t=e.rtpMap)||void 0===t?void 0:t.encodingName)||"")}))),a&&(null==a?void 0:a.length)>0&&(l=l.filter((e=>{var t;return Pr(a).call(a,(null===(t=e.rtpMap)||void 0===t?void 0:t.encodingName.toLowerCase())||"")}))),c&&(null==c?void 0:c.length)>0&&(h=h.filter((e=>{var t;return Pr(c).call(c,(null===(t=e.rtpMap)||void 0===t?void 0:t.encodingName.toLowerCase())||"")})));const m=kC("UNSUPPORTED_VIDEO_CODEC");return m&&m.length>0&&(h=h.filter((e=>!(e.rtpMap&&Pr(m).call(m,e.rtpMap.encodingName.toLowerCase()))))),{audioCodecs:l,videoCodecs:h,audioExtensions:u,videoExtensions:p}}function zP(e){const t=KP.parse(e);let i,n;for(const e of t.mediaDescriptions){if(!i){const t=e.attributes.iceUfrag,n=e.attributes.icePwd;if(!t||!n)throw new Error("Cannot get iceUfrag or icePwd from SDP.");i={iceUfrag:t,icePwd:n};}if(!n){const t=e.attributes.fingerprints;t.length>0&&(n={fingerprints:t});}}if(!n&&t.attributes.fingerprints.length>0&&(n={fingerprints:t.attributes.fingerprints}),!n||!i)throw new Error("Cannot get iceParameters or dtlsParameters from SDP.");return {iceParameters:i,dtlsParameters:n}}function XP(e,t){const i=[],n=e.attributes.ssrcGroups.filter((e=>"FID"===e.semantic)),r=e.attributes.ssrcGroups.find((e=>"SIM"===e.semantic)),s=e.attributes.ssrcs;if(r)r.ssrcIds.forEach((e=>{var r;const s=null===(r=n.find((t=>t.ssrcIds[0]===e)))||void 0===r?void 0:r.ssrcIds[1];i.push({ssrcId:e,rtx:t?s:void 0});}));else if(n.length>0){const e=n[0].ssrcIds[0],r=n[0].ssrcIds[1];i.push({ssrcId:e,rtx:t?r:void 0});}else {if(0===s.length)throw new Error("No ssrcs found on local media description.");i.push({ssrcId:s[0].ssrcId});}return i}function QP(e,t){const{cname:i}=e;let n;t&&t.ip&&"number"==typeof t.port?(n=[{foundation:"udpcandidate",componentId:"1",transport:"udp",priority:"2103266323",connectionAddress:t.ip,port:t.port.toString(),type:"host",extension:{}}],KC.debug("Using remote candidate from AP ".concat(t.ip,":").concat(t.port)),t.ip6&&(n.push({foundation:"udpcandidate",componentId:"1",transport:"udp",priority:"2103266323",connectionAddress:t.ip6,port:t.port.toString(),type:"host",extension:{}}),KC.debug("Using IPV6 remote candidate from AP ".concat(t.ip6,":").concat(t.port)))):n=e.iceParameters.candidates.map((e=>({foundation:e.foundation,componentId:"1",transport:e.protocol,priority:e.priority.toString(),connectionAddress:e.ip,port:e.port.toString(),type:e.type,extension:{}})));const r={fingerprints:e.dtlsParameters.fingerprints.map((e=>({hashFunction:e.algorithm,fingerprint:e.fingerprint})))},s={iceUfrag:e.iceParameters.iceUfrag,icePwd:e.iceParameters.icePwd};let o;switch(e.dtlsParameters.role){case"server":o="passive";break;case"client":o="active";break;case"auto":o="actpass";}return {dtlsParameters:r,iceParameters:s,candidates:n,rtpCapabilities:aL(e.rtpCapabilities),setup:o,cname:i}}function ZP(e,t,i){const n=[],r=[];return e.forEach((e=>{let{ssrcId:s,rtx:o}=e;const a=xT(8,"track-"),c={ssrcId:s,attributes:qP({label:a,mslabel:i=i||xT(10,""),msid:"".concat(i," ").concat(a)},t&&{cname:t})};if(n.push(c),void 0!==o){const e={ssrcId:o,attributes:qP({label:a,mslabel:i,msid:"".concat(i," ").concat(a)},t&&{cname:t})};n.push(e),r.push({semantic:"FID",ssrcIds:[s,o]});}})),e.length>1&&r.push({semantic:"SIM",ssrcIds:e.map((e=>{let{ssrcId:t}=e;return t}))}),{ssrcs:n,ssrcGroups:r}}function $P(e,t){t instanceof ZA&&e.attributes.payloads.forEach((e=>{var i;const n=null===(i=e.rtpMap)||void 0===i?void 0:i.encodingName.toLowerCase();if(!n||-1===["opus","pcmu","pcma","g722"].indexOf(n))return;e.fmtp||(e.fmtp={parameters:{}}),e.fmtp.parameters.minptime="10",e.fmtp.parameters.useinbandfec="1";const r=t._encoderConfig;r&&"pcmu"!==n&&"pcma"!==n&&"g722"!==n&&(r.bitrate&&!Rg()&&(e.fmtp.parameters.maxaveragebitrate="".concat(Math.floor(1e3*r.bitrate))),r.sampleRate&&(e.fmtp.parameters.maxplaybackrate="".concat(r.sampleRate),e.fmtp.parameters["sprop-maxcapturerate"]="".concat(r.sampleRate)),r.stereo&&(e.fmtp.parameters.stereo="1",e.fmtp.parameters["sprop-stereo"]="1"));}));}function eL(e){const t=e.attributes.unrecognized.findIndex((e=>"x-google-flag"===e.attField&&"conference"===e.attValue));-1!==t&&e.attributes.unrecognized.splice(t,1);}function tL(e,t){var i;if(!(t instanceof Sb&&t._encoderConfig&&-1===t._hints.indexOf(ky.SCREEN_TRACK)))return;const n=t._encoderConfig;_A().supportMinBitrate&&n.bitrateMin&&e.attributes.payloads.forEach((e=>{var t,i;Pr(t=["h264","h265","vp8","vp9","av1"]).call(t,(null===(i=e.rtpMap)||void 0===i?void 0:i.encodingName.toLowerCase())||"")&&(e.fmtp||(e.fmtp={parameters:{}}),e.fmtp.parameters["x-google-min-bitrate"]="".concat(n.bitrateMin));})),_A().supportMinBitrate&&!Pr(i=t._hints).call(i,ky.LOW_STREAM)&&n.bitrateMax&&e.attributes.payloads.forEach((e=>{var t,i;Pr(t=["h264","h265","vp8","vp9","av1"]).call(t,(null===(i=e.rtpMap)||void 0===i?void 0:i.encodingName.toLowerCase())||"")&&(e.fmtp||(e.fmtp={parameters:{}}),e.fmtp.parameters["x-google-start-bitrate"]="".concat(kC("X_GOOGLE_START_BITRATE")||Math.floor(n.bitrateMax)));}));}function iL(e){if("video"!==e.media.mediaType)return;const t=pg();if(t.name!==cg.SAFARI&&t.os!==ag.IOS)return;const i=e.attributes.extmaps.findIndex((e=>/video-orientation/g.test(e.extensionName)));-1!==i&&e.attributes.extmaps.splice(i,1);}function nL(e,t,i){if(!t)return;let n,r;if("video"===e.media.mediaType?(n=i.videoExtensions,r=i.videoCodecs):(n=i.audioExtensions,r=i.audioCodecs),!0===t.twcc){const t=n.find((e=>"http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01"===e.extensionName));if(t){e.attributes.extmaps.find((e=>"http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01"===e.extensionName))||e.attributes.extmaps.push({entry:t.entry,extensionName:"http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01"});const i=function(e,t){return t.filter((t=>!!e.find((e=>e.payloadType===t.payloadType&&!!e.rtcpFeedbacks.find((e=>"transport-cc"===e.type))))))}(r,e.attributes.payloads);i.forEach((e=>{e.rtcpFeedbacks.find((e=>"transport-cc"===e.type))||e.rtcpFeedbacks.push({type:"transport-cc"});}));}}else if(!1===t.twcc){const t=e.attributes.extmaps.findIndex((e=>"http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01"===e.extensionName));-1!==t&&e.attributes.extmaps.splice(t,1),e.attributes.payloads.forEach((e=>{const t=e.rtcpFeedbacks.findIndex((e=>"transport-cc"===e.type));-1!==t&&e.rtcpFeedbacks.splice(t,1);}));}if(!0===t.remb){const t=n.find((e=>"http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time"===e.extensionName));if(t){e.attributes.extmaps.find((e=>"http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time"===e.extensionName))||e.attributes.extmaps.push({entry:t.entry,extensionName:"http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time"});const i=function(e,t){return t.filter((t=>!!e.find((e=>e.payloadType===t.payloadType&&!!e.rtcpFeedbacks.find((e=>"goog-remb"===e.type))))))}(r,e.attributes.payloads);i.forEach((e=>{e.rtcpFeedbacks.find((e=>"goog-remb"===e.type))||e.rtcpFeedbacks.push({type:"goog-remb"});}));}}else if(!1===t.remb){const t=e.attributes.extmaps.findIndex((e=>"http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time"===e.extensionName));-1!==t&&e.attributes.extmaps.splice(t,1),e.attributes.payloads.forEach((e=>{const t=e.rtcpFeedbacks.findIndex((e=>"goog-remb"===e.type));-1!==t&&e.rtcpFeedbacks.splice(t,1);}));}}function rL(e,t,i){if(Rg())return;if("video"!==e.media.mediaType)return;if(!(t instanceof Sb))return;if("vp9"!==i&&"vp8"!==i)return;if("vp8"===i&&!kC("SIMULCAST"))return;if(void 0===t._scalabilityMode||t._scalabilityMode.numSpatialLayers<=1)return;const n="vp8"===i?2:t._scalabilityMode.numSpatialLayers,r=e.attributes.ssrcs[0],s=e.attributes.ssrcGroups.find((e=>"FID"===e.semantic&&e.ssrcIds[0]===r.ssrcId)),o={semantic:"SIM",ssrcIds:[r.ssrcId]};for(let t=1;t<n;t++)e.attributes.ssrcs.push({ssrcId:r.ssrcId+t,attributes:bT(r.attributes)}),o.ssrcIds.push(r.ssrcId+t),s&&(e.attributes.ssrcs.push({ssrcId:s.ssrcIds[1]+t,attributes:bT(r.attributes)}),e.attributes.ssrcGroups.push({semantic:"FID",ssrcIds:[r.ssrcId+t,s.ssrcIds[1]+t]}));e.attributes.ssrcGroups.unshift(o);}async function sL(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const{filterRTX:i,filterVideoFec:n,filterAudioFec:r,filterAudioCodec:s,filterVideoCodec:o}=e,{useXR:a}=t,c=new RTCPeerConnection;c.addTransceiver("video",{direction:"sendonly"}),c.addTransceiver("audio",{direction:"sendonly"}),c.addTransceiver("video",{direction:"recvonly"}),c.addTransceiver("audio",{direction:"recvonly"});const d=(await c.createOffer()).sdp,l=JP(d,{filterRTX:i,filterVideoFec:n,filterAudioFec:r,filterAudioCodec:s,filterVideoCodec:o},{useXR:a},"sendonly"),h=JP(d,{filterRTX:i,filterVideoFec:n,filterAudioFec:r,filterAudioCodec:s,filterVideoCodec:o},{useXR:a},"recvonly"),u={audioCodecs:[],audioExtensions:[],videoCodecs:[],videoExtensions:[]},p={audioCodecs:[],audioExtensions:[],videoCodecs:[],videoExtensions:[]},_={audioCodecs:[],audioExtensions:[],videoCodecs:[],videoExtensions:[]};if(oL(l,h,"videoExtensions",u,p,_),oL(l,h,"videoCodecs",u,p,_),oL(l,h,"audioExtensions",u,p,_),oL(l,h,"audioCodecs",u,p,_),kC("RAISE_H264_BASELINE_PRIORITY")){const e=_.videoCodecs.findIndex((e=>{var t,i;return "h264"===(null===(t=e.rtpMap)||void 0===t?void 0:t.encodingName.toLocaleLowerCase())&&"42001f"===(null===(i=e.fmtp)||void 0===i?void 0:i.parameters["profile-level-id"])}));if(-1!==e){const t=_.videoCodecs.findIndex((e=>{var t;return "h264"===(null===(t=e.rtpMap)||void 0===t?void 0:t.encodingName.toLocaleLowerCase())}));if(t<e){KC.debug("raising H264 baseline profile priority");const i=_.videoCodecs[e];_.videoCodecs.splice(e,1),_.videoCodecs.splice(t,0,i);}-1!==t&&(p.videoCodecs=p.videoCodecs.filter((e=>{var t,i;return !("h264"===(null===(t=e.rtpMap)||void 0===t?void 0:t.encodingName.toLocaleLowerCase())&&"42001f"!==(null===(i=e.fmtp)||void 0===i?void 0:i.parameters["profile-level-id"]))}))),-1!==t&&kC("FILTER_SEND_H264_BASELINE")&&(u.videoCodecs=u.videoCodecs.filter((e=>{var t,i;return !("h264"===(null===(t=e.rtpMap)||void 0===t?void 0:t.encodingName.toLocaleLowerCase())&&"42001f"!==(null===(i=e.fmtp)||void 0===i?void 0:i.parameters["profile-level-id"]))})));}}try{c.close();}catch(e){}return {send:u,recv:p,sendrecv:_}}function oL(e,t,i,n,r,s){if("videoExtensions"===i||"audioExtensions"===i){const o=[];return e[i].forEach((e=>{t[i].some(((t,i)=>{if(e.entry===t.entry&&e.extensionName===t.extensionName)return o.push(i),!0}))?s[i].push(e):n[i].push(e);})),void t[i].forEach(((e,t)=>{-1===o.indexOf(t)&&r[i].push(e);}))}if("videoCodecs"===i||"audioCodecs"===i){const o=[];return e[i].forEach((e=>{t[i].some(((t,i)=>{if(e.payloadType===t.payloadType&&JSON.stringify(e)===JSON.stringify(t))return o.push(i),!0}))?s[i].push(e):n[i].push(e);})),void t[i].forEach(((e,t)=>{-1===o.indexOf(t)&&r[i].push(e);}))}}function aL(e){const{send:t,recv:i,sendrecv:n}=e;if(!n){if(!t||!i)throw new Error("cannot merge rtp capabilities because one of send or recv is empty!");return {send:t,recv:i}}let r,s;return t?(r={audioCodecs:[],audioExtensions:[],videoCodecs:[],videoExtensions:[]},r.audioCodecs=[...t.audioCodecs,...n.audioCodecs],r.videoCodecs=[...t.videoCodecs,...n.videoCodecs],r.audioExtensions=[...t.audioExtensions,...n.audioExtensions],r.videoExtensions=[...t.videoExtensions,...n.videoExtensions]):r=n,i?(s={audioCodecs:[],audioExtensions:[],videoCodecs:[],videoExtensions:[]},s.audioCodecs=[...i.audioCodecs,...n.audioCodecs],s.videoCodecs=[...i.videoCodecs,...n.videoCodecs],s.audioExtensions=[...i.audioExtensions,...n.audioExtensions],s.videoExtensions=[...i.videoExtensions,...n.videoExtensions]):s=n,{send:r,recv:s}}function cL(e){if("audio"!==e.media.mediaType)return;e.attributes.payloads.filter((e=>{var t;return "opus"===(null===(t=e.rtpMap)||void 0===t?void 0:t.encodingName.toLowerCase())})).forEach((e=>{e.fmtp||(e.fmtp={parameters:{}}),e.fmtp.parameters.stereo="1",e.fmtp.parameters["sprop-stereo"]="1";}));}function dL(e){e.mediaDescriptions.forEach((e=>{"video"!==e.media.mediaType&&"audio"!==e.media.mediaType||e.attributes.payloads.forEach((e=>{-1===e.rtcpFeedbacks.findIndex((e=>"rrtr"===e.type))&&e.rtcpFeedbacks.push({type:"rrtr"});}));}));}function lL(e,t,i,n){let r=[];if(e===hI.VIDEO){if(kC("H264_PROFILE_LEVEL_ID")&&"h264"===n&&(r=t.videoCodecs.filter((e=>{var t;return Pr(t=e.rtpMap&&e.rtpMap.encodingName.toLowerCase()||"").call(t,n)&&e&&e.fmtp&&e.fmtp.parameters["profile-level-id"]===kC("H264_PROFILE_LEVEL_ID")}))),!Array.isArray(r)||0===r.length){const e=i.videoCodecs.filter((e=>{var t;return Pr(t=e.rtpMap&&e.rtpMap.encodingName.toLowerCase()||"").call(t,n)}));0!==e.length&&(r=t.videoCodecs.filter((t=>e.some((e=>e.payloadType===t.payloadType)))));}if(kC("USE_PUB_RTX")){const e=r.map((e=>e.payloadType.toString())),i=t.videoCodecs.filter((t=>t.rtpMap&&"rtx"===t.rtpMap.encodingName&&Pr(e).call(e,t.fmtp&&t.fmtp.parameters.apt||"")));r=[...r,...i];}0===r.length&&(KC.warning("codec ".concat(n," not included in rtpCapabilities, fallback to default payloads: ").concat(t.videoCodecs[0].rtpMap&&t.videoCodecs[0].rtpMap.encodingName)),r=t.videoCodecs);}else r=t.audioCodecs.filter((e=>{var t;return Pr(t=e.rtpMap&&e.rtpMap.encodingName.toLowerCase()||"").call(t,n)})),0===r.length&&(KC.warning("codec ".concat(n," not included in rtpCapabilities, fallback to opus")),r=t.audioCodecs.filter((e=>{var t;return Pr(t=e.rtpMap&&e.rtpMap.encodingName.toLowerCase()||"").call(t,"opus")})));return r}function hL(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n);}return i}function uL(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?hL(Object(i),!0).forEach((function(t){nu(e,t,i[t]);})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):hL(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t));}));}return e}function pL(e){if(Array.isArray(e))return e.map((e=>e));if(!_L(e))return e;const t={};for(const i in e){const n=e[i];_L(n)||Array.isArray(n)?t[i]=pL(n):t[i]=n;}return t}function _L(e){return !("object"!=typeof e||Array.isArray(e)||!e)}class EL{constructor(e){nu(this,"input",[]),nu(this,"size",void 0),this.size=e;}add(e){this.input.push(e),this.input.length>this.size&&this.input.splice(0,1);}diffMean(){return 0===this.input.length?0:(this.input[this.input.length-1]-this.input[0])/this.input.length}}const mL={address:"unknown",candidateType:"unknown",id:"unknown",port:0,priority:0,protocol:"unknown",type:"unknown"},fL={timestamp:0,bitrate:{actualEncoded:0,transmit:0},sendPacketLossRate:0,recvPacketLossRate:0,videoRecv:[],videoSend:[],audioRecv:[],audioSend:[],selectedCandidatePair:{id:"unknown",localCandidate:mL,remoteCandidate:mL}},gL={firsCount:0,nacksCount:0,plisCount:0,framesDecodeCount:0,framesDecodeInterval:0,framesDecodeFreezeTime:0,decodeFrameRate:0,bytes:0,packetsLost:0,packetLostRate:0,packets:0,ssrc:0,qpSumPerFrame:0},TL={firsCount:0,nacksCount:0,plisCount:0,frameCount:0,bytes:0,packets:0,packetsLost:0,packetLostRate:0,ssrc:0,rttMs:0,jitterMs:0,qpSumPerFrame:0},SL={bytes:0,packets:0,packetsLost:0,packetLostRate:0,ssrc:0,rttMs:0,jitterMs:0},RL={jitterBufferMs:0,jitterMs:0,bytes:0,packetsLost:0,packetLostRate:0,packets:0,ssrc:0,receivedFrames:0,droppedFrames:0,concealedSamples:0};function CL(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n);}return i}function vL(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?CL(Object(i),!0).forEach((function(t){nu(e,t,i[t]);})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):CL(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t));}));}return e}class IL{constructor(e,t){nu(this,"onFirstVideoReceived",void 0),nu(this,"onFirstVideoDecoded",void 0),nu(this,"onFirstAudioReceived",void 0),nu(this,"onFirstVideoDecodedTimeout",void 0),nu(this,"onFirstAudioDecoded",void 0),nu(this,"onSelectedLocalCandidateChanged",void 0),nu(this,"onSelectedRemoteCandidateChanged",void 0),nu(this,"videoIsReady",!1),nu(this,"videoIsReady2",{}),nu(this,"pc",void 0),nu(this,"options",void 0),nu(this,"intervalTimer",void 0),nu(this,"stats",pL(fL)),nu(this,"isFirstVideoReceived",{}),nu(this,"isFirstVideoDecoded",{}),nu(this,"isFirstAudioReceived",{}),nu(this,"isFirstAudioDecoded",{}),nu(this,"isFirstVideoDecodedTimeout",{}),nu(this,"lossRateWindowStats",[]),this.pc=e,this.options=t,this.intervalTimer=window.setInterval((async()=>{this.updateStats();}),this.options.updateInterval);}getStats(){return this.stats}getSelectedCandidatePair(){return new tg((e=>{e({local:vL({},mL),remote:vL({},mL)});}))}setVideoIsReady(e){this.videoIsReady=e;}setVideoIsReady2(e,t){this.videoIsReady2[e]=t;}getVideoIsReady(e){return this.videoIsReady2[e]||!1}setIsFirstAudioDecoded(e){}destroy(){window.clearInterval(this.intervalTimer),this.pc=void 0;}calcLossRate(e){this.lossRateWindowStats.push(e),this.lossRateWindowStats.length>this.options.lossRateInterval&&this.lossRateWindowStats.splice(0,1);const t=this.lossRateWindowStats.length,i=["videoSend","audioSend","videoRecv","audioRecv"];let n=0,r=0,s=0,o=0;for(const a of i)e[a].forEach(((e,i)=>{if(!this.lossRateWindowStats[t-1][a][i]||!this.lossRateWindowStats[0][a][i])return;const c=this.lossRateWindowStats[t-1][a][i].packets-this.lossRateWindowStats[0][a][i].packets,d=this.lossRateWindowStats[t-1][a][i].packetsLost-this.lossRateWindowStats[0][a][i].packetsLost;"videoSend"===a||"audioSend"===a?(n+=c,s+=d):(r+=c,o+=d),Number.isNaN(c)||Number.isNaN(c)?e.packetLostRate=0:e.packetLostRate=c<=0||d<=0?0:d/(c+d);}));e.sendPacketLossRate=n<=0||s<=0?0:s/(n+s),e.recvPacketLossRate=r<=0||o<=0?0:o/(r+o);}}function yL(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n);}return i}function AL(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?yL(Object(i),!0).forEach((function(t){nu(e,t,i[t]);})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):yL(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t));}));}return e}class bL extends IL{constructor(){super(...arguments),nu(this,"_stats",fL),nu(this,"lastDecodeVideoReceiverStats",new Map);}async updateStats(){const e=await this._getStats(),t=this.statsResponsesToObjects(e);this._stats=pL(fL);const i=t.filter((e=>"ssrc"===e.type));this.processSSRCStats(i);const n=t.find((e=>"VideoBwe"===e.type));n&&this.processBandwidthStats(n),this._stats.timestamp=Date.now(),this.calcLossRate(this._stats),this.stats=this._stats;}processBandwidthStats(e){this._stats.bitrate={actualEncoded:Number(e.googActualEncBitrate),targetEncoded:Number(e.googTargetEncBitrate),retransmit:Number(e.googRetransmitBitrate),transmit:Number(e.googTransmitBitrate)},this._stats.sendBandwidth=Number(e.googAvailableSendBandwidth);}processSSRCStats(e){e.forEach((e=>{var t;const i=Pr(t=e.id).call(t,"send");switch("".concat(e.mediaType,"_").concat(i?"send":"recv")){case"video_send":{const t=pL(TL);t.codec=e.googCodecName,t.adaptionChangeReason="none",e.googCpuLimitedResolution&&(t.adaptionChangeReason="cpu"),e.googBandwidthLimitedResolution&&(t.adaptionChangeReason="bandwidth"),t.avgEncodeMs=Number(e.googAvgEncodeMs),t.inputFrame={width:Number(e.googFrameWidthInput)||Number(e.googFrameWidthSent),height:Number(e.googFrameHeightInput)||Number(e.googFrameHeightSent),frameRate:Number(e.googFrameRateInput)},t.sentFrame={width:Number(e.googFrameWidthSent),height:Number(e.googFrameHeightSent),frameRate:Number(e.googFrameRateInput)},t.firsCount=Number(e.googFirReceived),t.nacksCount=Number(e.googNacksReceived),t.plisCount=Number(e.googPlisReceived),t.frameCount=Number(e.framesEncoded),t.bytes=Number(e.bytesSent),t.packets=Number(e.packetsSent),t.packetsLost=Number(e.packetsLost),t.ssrc=Number(e.ssrc),t.rttMs=Number(e.googRtt||0),this._stats.videoSend.push(t),this._stats.rtt=t.rttMs;break}case"video_recv":{const t=pL(gL),i=this.lastDecodeVideoReceiverStats.get(Number(e.ssrc));if(t.codec=e.googCodecName,t.targetDelayMs=Number(e.googTargetDelayMs),t.renderDelayMs=Number(e.googRenderDelayMs),t.currentDelayMs=Number(e.googCurrentDelayMs),t.minPlayoutDelayMs=Number(e.googMinPlayoutDelayMs),t.decodeMs=Number(e.googDecodeMs),t.maxDecodeMs=Number(e.googMaxDecodeMs),t.receivedFrame={width:Number(e.googFrameWidthReceived),height:Number(e.googFrameHeightReceived),frameRate:Number(e.googFrameRateReceived)},t.decodedFrame={width:Number(e.googFrameWidthReceived),height:Number(e.googFrameHeightReceived),frameRate:Number(e.googFrameRateDecoded)},t.decodeFrameRate=Number(e.googFrameRateDecoded),t.outputFrame={width:Number(e.googFrameWidthReceived),height:Number(e.googFrameHeightReceived),frameRate:Number(e.googFrameRateOutput)},t.jitterBufferMs=Number(e.googJitterBufferMs),t.firsCount=Number(e.googFirsSent),t.nacksCount=Number(e.googNacksSent),t.plisCount=Number(e.googPlisSent),t.framesDecodeCount=Number(e.framesDecoded),t.bytes=Number(e.bytesReceived),t.packets=Number(e.packetsReceived),t.packetsLost=Number(e.packetsLost),t.ssrc=Number(e.ssrc),t.packets>0&&!this.isFirstVideoReceived[t.ssrc]&&(this.onFirstVideoReceived&&this.onFirstVideoReceived(t.ssrc),this.isFirstVideoReceived[t.ssrc]=!0),t.framesDecodeCount>0&&!this.isFirstVideoDecoded[t.ssrc]&&(this.onFirstVideoDecoded&&this.onFirstVideoDecoded(t.ssrc,t.decodedFrame.width,t.decodedFrame.height),this.isFirstVideoDecoded[t.ssrc]=!0),i){const n=i.stats,r=Date.now()-i.lts;t.framesDecodeFreezeTime=n.framesDecodeFreezeTime,t.framesDecodeInterval=n.framesDecodeInterval,t.framesDecodeCount>n.framesDecodeCount&&this.isFirstVideoDecoded[t.ssrc]?(i.lts=Date.now(),t.framesDecodeInterval=r,t.framesDecodeInterval>=this.options.freezeRateLimit&&(this.getVideoIsReady(parseInt(e.ssrc,10))?t.framesDecodeFreezeTime+=t.framesDecodeInterval:this.setVideoIsReady2(parseInt(e.ssrc,10),!0))):t.framesDecodeCount<i.stats.framesDecodeCount&&(t.framesDecodeInterval=0);}this.lastDecodeVideoReceiverStats.set(t.ssrc,{stats:AL({},t),lts:Date.now()}),this._stats.videoRecv.push(t);break}case"audio_recv":{const t=pL(RL);t.codec=e.googCodecName,t.outputLevel=Math.abs(Number(e.audioOutputLevel))/32767,t.decodingCNG=Number(e.googDecodingCNG),t.decodingCTN=Number(e.googDecodingCTN),t.decodingCTSG=Number(e.googDecodingCTSG),t.decodingNormal=Number(e.googDecodingNormal),t.decodingPLC=Number(e.googDecodingPLC),t.decodingPLCCNG=Number(e.googDecodingPLCCNG),t.expandRate=Number(e.googExpandRate),t.accelerateRate=Number(e.googAccelerateRate),t.preemptiveExpandRate=Number(e.googPreemptiveExpandRate),t.secondaryDecodedRate=Number(e.googSecondaryDecodedRate),t.speechExpandRate=Number(e.googSpeechExpandRate),t.preferredJitterBufferMs=Number(e.googPreferredJitterBufferMs),t.jitterBufferMs=Number(e.googJitterBufferMs),t.jitterMs=Number(e.googJitterReceived),t.bytes=Number(e.bytesReceived),t.packets=Number(e.packetsReceived),t.packetsLost=Number(e.packetsLost),t.ssrc=Number(e.ssrc),t.receivedFrames=Number(e.googDecodingCTN)||Number(e.packetsReceived),t.droppedFrames=Number(e.googDecodingPLC)+Number(e.googDecodingPLCCNG)||Number(e.packetsLost),t.receivedFrames>0&&!this.isFirstAudioReceived[t.ssrc]&&(this.onFirstAudioReceived&&this.onFirstAudioReceived(t.ssrc),this.isFirstAudioReceived[t.ssrc]=!0),t.decodingNormal>0&&!this.isFirstAudioDecoded[t.ssrc]&&(this.onFirstAudioDecoded&&this.onFirstAudioDecoded(t.ssrc),this.isFirstAudioDecoded[t.ssrc]=!0),this._stats.audioRecv.push(t);break}case"audio_send":{const t=pL(SL);t.codec=e.googCodecName,t.inputLevel=Math.abs(Number(e.audioInputLevel))/32767,t.aecReturnLoss=Number(e.googEchoCancellationReturnLoss||0),t.aecReturnLossEnhancement=Number(e.googEchoCancellationReturnLossEnhancement||0),t.residualEchoLikelihood=Number(e.googResidualEchoLikelihood||0),t.residualEchoLikelihoodRecentMax=Number(e.googResidualEchoLikelihoodRecentMax||0),t.bytes=Number(e.bytesSent),t.packets=Number(e.packetsSent),t.packetsLost=Number(e.packetsLost),t.ssrc=Number(e.ssrc),t.rttMs=Number(e.googRtt||0),this._stats.rtt=t.rttMs,this._stats.audioSend.push(t);break}}}));}_getStats(){return new tg(((e,t)=>{this.pc.getStats(e,t);}))}statsResponsesToObjects(e){const t=[];return e.result().forEach((e=>{const i={id:e.id,timestamp:e.timestamp.valueOf().toString(),type:e.type};e.names().forEach((t=>{i[t]=e.stat(t);})),t.push(i);})),t}}function wL(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n);}return i}function OL(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?wL(Object(i),!0).forEach((function(t){nu(e,t,i[t]);})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):wL(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t));}));}return e}class NL extends IL{constructor(){super(...arguments),nu(this,"_stats",fL),nu(this,"report",void 0),nu(this,"lastDecodeVideoReceiverStats",new Map),nu(this,"lastVideoFramesRecv",new Map),nu(this,"lastVideoFramesSent",new Map),nu(this,"lastVideoFramesDecode",new Map),nu(this,"lastVideoJBDelay",new Map),nu(this,"lastAudioJBDelay",new Map),nu(this,"mediaBytesSent",new Map),nu(this,"mediaBytesRetransmit",new Map),nu(this,"mediaBytesTargetEncode",new Map),nu(this,"lastEncoderMs",new Map);}async updateStats(){this.report=await this.pc.getStats(),this._stats=pL(fL),this.report.forEach((e=>{switch(e.type){case hv.OUTBOUND:case hv.INBOUND:{const t=e.mediaType||e.kind,i=!t&&"frameWidth"in e,n=!t&&!("frameWidth"in e);e.type===hv.OUTBOUND?"audio"===t||n?this.processAudioOutboundStats(e):("video"===t||i)&&this.processVideoOutboundStats(e):e.type===hv.INBOUND&&("audio"===t||n?this.processAudioInboundStats(e):("video"===t||i)&&this.processVideoInboundStats(e));break}case hv.TRANSPORT:{const t=this.report.get(e.selectedCandidatePairId);t&&this.processCandidatePairStats(t);break}case hv.CANDIDATE_PAIR:e.selected&&this.processCandidatePairStats(e);}})),this.updateSendBitrate(),this._stats.timestamp=Date.now(),this.calcLossRate(this._stats),this.stats=this._stats;}async getSelectedCandidatePair(){const e=await this.pc.getStats(),t={local:OL({},mL),remote:OL({},mL)};return e.forEach((i=>{let n;if(i.type===hv.TRANSPORT&&(n=e.get(i.selectedCandidatePairId)),i.type===hv.CANDIDATE_PAIR&&i.selected&&(n=i),n){const i=(e,t)=>{e.type=t.type,e.id=t.id,t.address&&(e.address=t.address),t.candidateType&&(e.candidateType=t.candidateType),t.port&&(e.port=t.port),t.priority&&(e.priority=t.priority),t.protocol&&(e.protocol=t.protocol),t.relayProtocol&&(e.relayProtocol=t.relayProtocol);};if(n.localCandidateId){const r=e.get(n.localCandidateId);r&&i(t.local,r);}if(n.remoteCandidateId){const r=e.get(n.remoteCandidateId);r&&i(t.remote,r);}}})),t}processCandidatePairStats(e){if(this._stats.sendBandwidth=e.availableOutgoingBitrate||0,e.currentRoundTripTime&&(this._stats.rtt=1e3*e.currentRoundTripTime),this._stats.videoSend.forEach((t=>{e.currentRoundTripTime&&(t.rttMs=1e3*e.currentRoundTripTime);})),this._stats.audioSend.forEach((t=>{e.currentRoundTripTime&&(t.rttMs=1e3*e.currentRoundTripTime);})),this._stats.selectedCandidatePair.id=e.id,e.localCandidateId){const t=this.report.get(e.localCandidateId);t&&this.processCandidateStats(t);}if(e.remoteCandidateId){const t=this.report.get(e.remoteCandidateId);t&&this.processCandidateStats(t);}}processCandidateStats(e){let t;e.type===hv.LOCAL_CANDIDATE&&(t=this._stats.selectedCandidatePair.localCandidate),e.type===hv.REMOTE_CANDIDATE&&(t=this._stats.selectedCandidatePair.remoteCandidate),t&&(t.type=e.type,t.id=e.id,e.address&&(t.address=e.address),e.candidateType&&(t.candidateType=e.candidateType),e.port&&(t.port=e.port),e.priority&&(t.priority=e.priority),e.protocol&&(t.protocol=e.protocol),e.relayProtocol&&(t.relayProtocol=e.relayProtocol),e.type===hv.LOCAL_CANDIDATE&&this.stats.selectedCandidatePair.localCandidate.id!==t.id&&this.onSelectedLocalCandidateChanged&&this.onSelectedLocalCandidateChanged(OL({},t),OL({},this.stats.selectedCandidatePair.localCandidate)),e.type===hv.REMOTE_CANDIDATE&&this.stats.selectedCandidatePair.remoteCandidate.id!==t.id&&this.onSelectedRemoteCandidateChanged&&this.onSelectedRemoteCandidateChanged(OL({},t),OL({},this.stats.selectedCandidatePair.remoteCandidate)));}processAudioInboundStats(e){let t=this._stats.audioRecv.find((t=>t.ssrc===e.ssrc));t||(t=pL(RL),this._stats.audioRecv.push(t)),t.ssrc=e.ssrc,t.packets=e.packetsReceived,t.packetsLost=e.packetsLost,t.bytes=e.bytesReceived,t.jitterMs=1e3*e.jitter,this.processAudioTrackReceiverStats(e,e.trackId,t),e.codecId&&(t.codec=this.getCodecFromCodecStats(e.codecId)),t.receivedFrames||(t.receivedFrames=e.packetsReceived),t.droppedFrames||(t.droppedFrames=e.packetsLost),t.receivedFrames>0&&!this.isFirstAudioReceived[t.ssrc]&&(this.onFirstAudioReceived&&this.onFirstAudioReceived(t.ssrc),this.isFirstAudioReceived[t.ssrc]=!0),t.outputLevel&&t.outputLevel>0&&!this.isFirstAudioDecoded[t.ssrc]&&(this.onFirstAudioDecoded&&this.onFirstAudioDecoded(t.ssrc),this.isFirstAudioDecoded[t.ssrc]=!0),"number"==typeof e.concealedSamples&&(t.concealedSamples=e.concealedSamples);}processVideoInboundStats(e){let t=this._stats.videoRecv.find((t=>t.ssrc===e.ssrc));t||(t=pL(gL),this._stats.videoRecv.push(t)),t.ssrc=e.ssrc,t.packets=e.packetsReceived,t.packetsLost=e.packetsLost,t.bytes=e.bytesReceived,t.firsCount=e.firCount,t.nacksCount=e.nackCount,t.plisCount=e.pliCount,t.framesDecodeCount=e.framesDecoded,t.totalInterFrameDelay=e.totalInterFrameDelay,t.totalSquaredInterFrameDelay=e.totalSquaredInterFrameDelay;const i=this.lastDecodeVideoReceiverStats.get(t.ssrc),n=this.lastVideoFramesDecode.get(t.ssrc),r=Date.now();if(t.framesDecodeCount>0&&!this.isFirstVideoDecoded[t.ssrc]){const e=t.decodedFrame?t.decodedFrame.width:0,i=t.decodedFrame?t.decodedFrame.height:0;this.onFirstVideoDecoded&&this.onFirstVideoDecoded(t.ssrc,e,i),this.isFirstVideoDecoded[t.ssrc]=!0;}if(i){const n=i.stats,s=r-i.lts;t.framesDecodeFreezeTime=n.framesDecodeFreezeTime,t.framesDecodeInterval=n.framesDecodeInterval,!this.isFirstVideoDecoded[t.ssrc]&&s>this.options.firstVideoDecodedTimeout&&!this.isFirstVideoDecodedTimeout[t.ssrc]&&(this.onFirstVideoDecodedTimeout&&this.onFirstVideoDecodedTimeout(t.ssrc),this.isFirstVideoDecodedTimeout[t.ssrc]=!0),t.framesDecodeCount>n.framesDecodeCount&&this.isFirstVideoDecoded[t.ssrc]?(i.lts=Date.now(),t.framesDecodeInterval=s,t.framesDecodeInterval>=this.options.freezeRateLimit&&(this.getVideoIsReady(parseInt(e.ssrc))?t.framesDecodeFreezeTime+=t.framesDecodeInterval:this.setVideoIsReady2(parseInt(e.ssrc,10),!0))):t.framesDecodeCount<n.framesDecodeCount&&(t.framesDecodeInterval=0),e.framesDecoded&&e.qpSum&&(i.stats.framesDecodeCount>e.framesDecoded?t.qpSumPerFrame=e.qpSum/e.framesDecoded:t.qpSumPerFrame=(e.qpSum-i.qpSum)/(e.framesDecoded-i.stats.framesDecodeCount));}n&&r-n.lts>=800?(t.decodeFrameRate=Math.round((t.framesDecodeCount-n.count)/((r-n.lts)/1e3)),this.lastVideoFramesDecode.set(t.ssrc,{count:t.framesDecodeCount,lts:r,rate:t.decodeFrameRate})):n?t.decodeFrameRate=n.rate:this.lastVideoFramesDecode.set(t.ssrc,{count:t.framesDecodeCount,lts:r,rate:0}),e.totalDecodeTime&&(t.decodeMs=1e3*e.totalDecodeTime),this.processVideoTrackReceiverStats(e,e.trackId,t),e.codecId&&(t.codec=this.getCodecFromCodecStats(e.codecId)),e.framerateMean&&(t.framesRateFirefox=e.framerateMean),t.packets>0&&!this.isFirstVideoReceived[t.ssrc]&&(this.onFirstVideoReceived&&this.onFirstVideoReceived(t.ssrc),this.isFirstVideoReceived[t.ssrc]=!0),this.lastDecodeVideoReceiverStats.set(t.ssrc,{stats:OL({},t),lts:i?i.lts:Date.now(),qpSum:e.qpSum});}processVideoOutboundStats(e){let t=this._stats.videoSend.find((t=>t.ssrc===e.ssrc));t||(t=pL(TL),this._stats.videoSend.push(t));const i=this.mediaBytesSent.get(e.ssrc);if(i)i.add(e.bytesSent);else {const t=new EL(10);t.add(e.bytesSent),this.mediaBytesSent.set(e.ssrc,t);}if(void 0!==e.retransmittedBytesSent){const t=this.mediaBytesRetransmit.get(e.ssrc);if(t)t.add(e.retransmittedBytesSent);else {const t=new EL(10);t.add(e.retransmittedBytesSent),this.mediaBytesRetransmit.set(e.ssrc,t);}}if(e.totalEncodedBytesTarget){const t=this.mediaBytesTargetEncode.get(e.ssrc);if(t)t.add(e.totalEncodedBytesTarget);else {const t=new EL(10);t.add(e.totalEncodedBytesTarget),this.mediaBytesTargetEncode.set(e.ssrc,t);}}if(t.ssrc=e.ssrc,t.bytes=e.bytesSent,t.packets=e.packetsSent,t.firsCount=e.firCount,t.nacksCount=e.nackCount,t.plisCount=e.pliCount,t.frameCount=e.framesEncoded,t.adaptionChangeReason=e.qualityLimitationReason,t.scalabilityMode=e.scalabilityMode,e.totalEncodeTime&&e.framesEncoded){const i=this.lastEncoderMs.get(e.ssrc);if(!i||i.lastFrameCount>e.framesEncoded)t.avgEncodeMs=1e3*e.totalEncodeTime/e.framesEncoded;else {const n=e.framesEncoded-i.lastFrameCount,r=e.totalEncodeTime-i.lastEncoderTime;t.avgEncodeMs=1e3*r/n;}}if(e.framesEncoded&&e.qpSum){const i=this.lastEncoderMs.get(e.ssrc);!i||i.lastFrameCount>e.framesEncoded?t.qpSumPerFrame=e.qpSum/e.framesEncoded:t.qpSumPerFrame=(e.qpSum-i.lastQpSum)/(e.framesEncoded-i.lastFrameCount);}if(this.lastEncoderMs.set(e.ssrc,{lastFrameCount:e.framesEncoded,lastEncoderTime:e.totalEncodeTime,lastQpSum:e.qpSum,lts:Date.now()}),e.codecId&&(t.codec=this.getCodecFromCodecStats(e.codecId)),e.mediaSourceId&&this.processVideoMediaSource(e.mediaSourceId,t),this.processVideoTrackSenderStats(e,e.trackId,t),e.remoteId)this.processRemoteInboundStats(e.remoteId,t);else {const i=this.findRemoteStatsId(e.ssrc,hv.REMOTE_INBOUND);i&&this.processRemoteInboundStats(i,t);}}processAudioOutboundStats(e){let t=this._stats.audioSend.find((t=>t.ssrc===e.ssrc));if(t||(t=pL(SL),this._stats.audioSend.push(t)),t.ssrc=e.ssrc,t.packets=e.packetsSent,t.bytes=e.bytesSent,e.mediaSourceId&&this.processAudioMediaSource(e.mediaSourceId,t),e.codecId&&(t.codec=this.getCodecFromCodecStats(e.codecId)),this.processAudioTrackSenderStats(e,e.trackId,t),e.remoteId)this.processRemoteInboundStats(e.remoteId,t);else {const i=this.findRemoteStatsId(e.ssrc,hv.REMOTE_INBOUND);i&&this.processRemoteInboundStats(i,t);}}findRemoteStatsId(e,t){var i;const n=Array.from(kv(i=this.report).call(i)).find((i=>i.type===t&&i.ssrc===e));return n?n.id:null}processVideoMediaSource(e,t){const i=this.report.get(e);i&&i.width&&i.height&&i.framesPerSecond&&(t.inputFrame={width:i.width,height:i.height,frameRate:i.framesPerSecond});}processAudioMediaSource(e,t){const i=this.report.get(e);i&&(t.inputLevel=i.audioLevel);}processVideoTrackSenderStats(e,t,i){var n,r,s,o;const a=t?this.report.get(t):void 0,c=null!==(n=null==a?void 0:a.framesSent)&&void 0!==n?n:e.framesSent;if("number"!=typeof c)return;let d=null!==(r=null==a?void 0:a.frameWidth)&&void 0!==r?r:e.frameWidth,l=null!==(s=null==a?void 0:a.frameHeight)&&void 0!==s?s:e.frameHeight,h=null!==(o=null==a?void 0:a.framesPerSecond)&&void 0!==o?o:e.framesPerSecond;if("number"==typeof d&&"number"==typeof l||(d=0,l=0),null==h){const e=Date.now(),t=this.lastVideoFramesSent.get(i.ssrc);t&&e-t.lts>=800?(h=Math.round((c-t.count)/((e-t.lts)/1e3)),this.lastVideoFramesSent.set(i.ssrc,{count:c,lts:e,rate:h})):t?h=t.rate:this.lastVideoFramesSent.set(i.ssrc,{count:c,lts:e,rate:0});}i.sentFrame={width:d,height:l,frameRate:Math.max(0,h)};}processVideoTrackReceiverStats(e,t,i){var n,r,s,o,a;const c=t?this.report.get(t):void 0,d=null!==(n=null==c?void 0:c.framesReceived)&&void 0!==n?n:e.framesReceived,l=null!==(r=null==c?void 0:c.frameWidth)&&void 0!==r?r:e.frameWidth,h=null!==(s=null==c?void 0:c.frameHeight)&&void 0!==s?s:e.frameHeight,u=null!==(o=null==c?void 0:c.jitterBufferDelay)&&void 0!==o?o:e.jitterBufferDelay,p=null!==(a=null==c?void 0:c.jitterBufferEmittedCount)&&void 0!==a?a:e.jitterBufferEmittedCount;if("number"==typeof d){const e=this.lastVideoFramesRecv.get(i.ssrc),t=Date.now();i.framesReceivedCount=d;let n=0;e&&t-e.lts>=800?(n=Math.round((d-e.count)/((t-e.lts)/1e3)),this.lastVideoFramesRecv.set(i.ssrc,{count:d,lts:t,rate:n})):e?n=e.rate:this.lastVideoFramesRecv.set(i.ssrc,{count:d,lts:t,rate:0}),i.receivedFrame={width:l||0,height:h||0,frameRate:n||0},i.decodedFrame={width:l||0,height:h||0,frameRate:i.decodeFrameRate||0},i.outputFrame={width:l||0,height:h||0,frameRate:i.decodeFrameRate||0};}if(u&&p){const e=this.lastVideoJBDelay.get(i.ssrc)||{jitterBufferDelay:0,jitterBufferEmittedCount:0,jitterBufferMs:0};let t=e.jitterBufferMs;const n=p-e.jitterBufferEmittedCount;n>0&&(t=1e3*(u-e.jitterBufferDelay)/n),i.jitterBufferMs=t,i.currentDelayMs=Math.round(t),this.lastVideoJBDelay.set(i.ssrc,{jitterBufferDelay:u,jitterBufferEmittedCount:p,jitterBufferMs:i.currentDelayMs});}}processAudioTrackSenderStats(e,t,i){var n,r,s,o;const a=t?this.report.get(t):void 0,c=null!==(n=null!==(r=null==a?void 0:a.echoReturnLoss)&&void 0!==r?r:e.echoReturnLoss)&&void 0!==n?n:0,d=null!==(s=null!==(o=null==a?void 0:a.echoReturnLossEnhancement)&&void 0!==o?o:e.echoReturnLossEnhancement)&&void 0!==s?s:0;i.aecReturnLoss=c,i.aecReturnLossEnhancement=d;}processAudioTrackReceiverStats(e,t,i){var n,r,s,o,a,c,d;const l=t?this.report.get(t):void 0,h=null!==(n=null==l?void 0:l.removedSamplesForAcceleration)&&void 0!==n?n:e.removedSamplesForAcceleration,u=null!==(r=null==l?void 0:l.totalSamplesReceived)&&void 0!==r?r:e.totalSamplesReceived,p=null!==(s=null==l?void 0:l.jitterBufferDelay)&&void 0!==s?s:e.jitterBufferDelay,_=null!==(o=null==l?void 0:l.jitterBufferEmittedCount)&&void 0!==o?o:e.jitterBufferEmittedCount,E=null!==(a=null==l?void 0:l.audioLevel)&&void 0!==a?a:null==e?void 0:e.audioLevel,m=null!==(c=null==l?void 0:l.totalSamplesDuration)&&void 0!==c?c:null==e?void 0:e.totalSamplesDuration,f=null!==(d=null==l?void 0:l.concealedSamples)&&void 0!==d?d:e.concealedSamples;if(h&&u&&(i.accelerateRate=h/u),p&&_){const e=this.lastAudioJBDelay.get(i.ssrc)||{jitterBufferDelay:0,jitterBufferEmittedCount:0,jitterBufferMs:0};let t=e.jitterBufferMs;const n=_-e.jitterBufferEmittedCount;n>0&&(t=1e3*(p-e.jitterBufferDelay)/n),i.jitterBufferMs=Math.round(t),this.lastAudioJBDelay.set(i.ssrc,{jitterBufferDelay:p,jitterBufferEmittedCount:_,jitterBufferMs:i.jitterBufferMs});}i.outputLevel=E;let g=1920;m&&u&&(g=u/m/50,i.receivedFrames=Math.round(u/g)),f&&(i.droppedFrames=Math.round(f/g));}processRemoteInboundStats(e,t){const i=this.report.get(e);i&&(t.packetsLost=i.packetsLost,i.roundTripTime&&(t.rttMs=1e3*i.roundTripTime),i.jitter&&(t.jitterMs=1e3*i.jitter),i.timestamp&&(t.timestamp=i.timestamp));}getCodecFromCodecStats(e){const t=this.report.get(e);if(!t)return "";const i=t.mimeType.match(/\/(.*)$/);return i&&i[1]?i[1]:""}updateSendBitrate(){let e=0,t=null,i=null;this.mediaBytesSent.forEach((t=>{e+=t.diffMean();})),this.mediaBytesRetransmit.forEach((e=>{t=null===t?e.diffMean():t+e.diffMean();})),this.mediaBytesTargetEncode.forEach((e=>{i=null===i?e.diffMean():i+e.diffMean();}));const n=null!==t?e-t:e;this._stats.bitrate={actualEncoded:8*n/(this.options.updateInterval/1e3),transmit:8*e/(this.options.updateInterval/1e3)},null!==t&&(this._stats.bitrate.retransmit=8*t/(this.options.updateInterval/1e3)),null!==i&&(this._stats.bitrate.targetEncoded=8*i/(this.options.updateInterval/1e3));}}class DL extends IL{updateStats(){return tg.resolve()}}function PL(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:250,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:8,n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:500,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1e4;const s=function(){const e=navigator.userAgent.toLocaleLowerCase().match(/chrome\/[\d]*/i);return e&&e[0]?Number(e[0].split("/")[1]):null}();return s?s<76?new bL(e,{updateInterval:t,lossRateInterval:i,freezeRateLimit:n,firstVideoDecodedTimeout:r}):new NL(e,{updateInterval:t,lossRateInterval:i,freezeRateLimit:n,firstVideoDecodedTimeout:r}):function(e){return !!window.RTCStatsReport&&e.getStats()instanceof tg}(e)?new NL(e,{updateInterval:t,lossRateInterval:i,freezeRateLimit:n,firstVideoDecodedTimeout:r}):new DL(e,{updateInterval:t,lossRateInterval:i,freezeRateLimit:n,firstVideoDecodedTimeout:r})}function LL(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n);}return i}function kL(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?LL(Object(i),!0).forEach((function(t){nu(e,t,i[t]);})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):LL(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t));}));}return e}class ML extends PI{get peerConnectionState(){return this.peerConnection.connectionState}get iceConnectionState(){return this.peerConnection.iceConnectionState}get currentLocalDescription(){return this.peerConnection.currentLocalDescription}get currentRemoteDescription(){return this.peerConnection.currentRemoteDescription}constructor(e,t){super(e,t),nu(this,"store",void 0),nu(this,"peerConnection",void 0),nu(this,"remoteSDP",void 0),nu(this,"initialOffer",void 0),nu(this,"statsFilter",void 0),nu(this,"useRTX",!1),nu(this,"localCapabilities",void 0),nu(this,"localCandidateCount",0),nu(this,"allCandidatesReceived",!1),nu(this,"establishPromise",void 0),nu(this,"mutex",new YT("P2PConnection-mutex")),this.store=t,this.peerConnection=new RTCPeerConnection(ML.resolvePCConfiguration(e),{optional:[{googDscp:!0}]}),this.statsFilter=PL(this.peerConnection,kC("STATS_UPDATE_INTERVAL"),void 0,Rg()?1200:void 0),this.bindPCEvents(),this.bindStatsEvents(),this.store.p2pId=this.store.p2pId+1,this.establishPromise=this.establish();}async establish(){try{const e=await this.peerConnection.createOffer({offerToReceiveAudio:!0,offerToReceiveVideo:!0});if(!e.sdp)throw new Error("Cannot get initialOffer.sdp when trying to establish PeerConnection.");const t=zP(e.sdp),i=JP(e.sdp,{filterRTX:!this.useRTX,filterVideoFec:kC("FILTER_VIDEO_FEC"),filterAudioFec:kC("FILTER_AUDIO_FEC"),filterAudioCodec:["opus"]});return this.localCapabilities=i,this.initialOffer=e,kL(kL({},t),{},{rtpCapabilities:{send:{audioCodecs:[],audioExtensions:[],videoCodecs:[],videoExtensions:[]},recv:{audioCodecs:[],audioExtensions:[],videoCodecs:[],videoExtensions:[]},sendrecv:i},offerSDP:e.sdp})}catch(e){throw new Vg(xg.GET_LOCAL_CONNECTION_PARAMS_FAILED,e.toString())}}async connect(e,t,i,n,r,s){try{if(!this.initialOffer)throw new Error("Cannot establish P2PConnection without initial offer.");this.remoteSDP=new class{constructor(e){nu(this,"sessionDesc",void 0),nu(this,"localCapabilities",void 0),nu(this,"rtpCapabilities",void 0),nu(this,"candidates",void 0),nu(this,"iceParameters",void 0),nu(this,"dtlsParameters",void 0),nu(this,"setup",void 0),nu(this,"currentMidIndex",void 0),nu(this,"cname",void 0),e=bT(e);const{remoteIceParameters:t,remoteDtlsParameters:i,candidates:n,remoteRTPCapabilities:r,remoteSetup:s,localCapabilities:o,sdkCodec:a,cname:c}=e,d=KP.parse("v=0\no=- 0 0 IN IP4 127.0.0.1\ns=AgoraGateway\nt=0 0\na=group:BUNDLE audio video\na=msid-semantic: WMS\na=ice-lite\nm=audio 9 UDP/TLS/RTP/SAVPF 0\nc=IN IP4 127.0.0.1\na=rtcp:9 IN IP4 0.0.0.0\na=sendrecv\na=rtcp-mux\na=rtcp-rsize\na=mid:audio\nm=video 9 UDP/TLS/RTP/SAVPF 0\nc=IN IP4 127.0.0.1\na=rtcp:9 IN IP4 0.0.0.0\na=sendrecv\na=rtcp-mux\na=rtcp-rsize\na=mid:video\n");this.rtpCapabilities=r,this.candidates=n,this.iceParameters=t,this.dtlsParameters=i,this.setup=s,this.localCapabilities=o,this.cname=c;for(let e=0;e<d.mediaDescriptions.length;e++){const o=d.mediaDescriptions[e];if(o.attributes.iceUfrag=t.iceUfrag,o.attributes.icePwd=t.icePwd,o.attributes.fingerprints=i.fingerprints,o.attributes.candidates=n,o.attributes.setup=s,"video"===o.media.mediaType){o.media.fmts=r.videoCodecs.map((e=>e.payloadType.toString(10)));let e=r.videoCodecs.filter((e=>{var t,i;return null===(t=e.rtpMap)||void 0===t?void 0:Pr(i=t.encodingName.toLowerCase()).call(i,a)}));0===e.length&&(e=r.videoCodecs),o.attributes.payloads=e,o.attributes.extmaps=r.videoExtensions;}"audio"===o.media.mediaType&&(o.media.fmts=r.audioCodecs.map((e=>e.payloadType.toString(10))),o.attributes.payloads=r.audioCodecs,o.attributes.extmaps=r.audioExtensions),d.mediaDescriptions[e]=this.mungMediaDesc(o);}this.sessionDesc=d,this.currentMidIndex=d.mediaDescriptions.length-1;}toString(){return KP.print(this.sessionDesc)}send(e,t,i){const{ssrcs:n,ssrcGroups:r}=ZP(t,this.cname),s=this.sessionDesc.mediaDescriptions.find((t=>e===hI.VIDEO?"video"===t.media.mediaType:"audio"===t.media.mediaType)),o=n[0].attributes.label,a=n[0].attributes.mslabel;return s.attributes.ssrcs=s.attributes.ssrcs.concat(n),s.attributes.ssrcGroups=s.attributes.ssrcGroups.concat(r),{id:o,mslabel:a}}batchSend(e){return e.map((e=>{let{kind:t,ssrcMsg:i}=e;return this.send(t,i,void 0)}))}stopSending(e){this.sessionDesc.mediaDescriptions.forEach((t=>{const i=[],n=[],r=[];t.attributes.ssrcs.forEach((t=>{Pr(e).call(e,t.attributes.label||"")?r.push(t):i.push(t);})),t.attributes.ssrcGroups.forEach((e=>{var t;Pr(t=r.map((e=>e.ssrcId))).call(t,e.ssrcIds[0])||n.push(e);})),t.attributes.ssrcs=i,t.attributes.ssrcGroups=n;}));}mute(e){const t=this.sessionDesc.mediaDescriptions.find((t=>t.attributes.mid===e));if(!t)throw new Error("mediaDescription not found with ".concat(e," in remote SDP when calling RemoteSDP.mute."));t.attributes.direction="inactive";}unmute(e){const t=this.sessionDesc.mediaDescriptions.find((t=>t.attributes.mid===e));if(!t)throw new Error("mediaDescription not found with ".concat(e," in remote SDP when calling RemoteSDP.unmute."));t.attributes.direction="sendonly";}receive(e,t,i){e.forEach(((e,t)=>{const i=e._mediaStreamTrack,n=this.sessionDesc.mediaDescriptions.findIndex((e=>e.attributes.mid===i.kind)),r=this.mungRecvMediaDsec(this.sessionDesc.mediaDescriptions[n],e);this.sessionDesc.mediaDescriptions[n]=r;}));}stopReceiving(e){}updateCandidates(e){e===uI.TCP?this.candidates.forEach((e=>{-1===this.candidates.findIndex((t=>"tcp"===t.transport&&t.connectionAddress===e.connectionAddress&&t.port===e.port))&&this.candidates.push(uL(uL({},e),{},{foundation:"tcpcandidate",priority:Number(e.priority)-1+"",transport:"tcp",port:Number(e.port)+90+""}));})):this.candidates=this.candidates.filter((e=>"tcp"!==e.transport));for(const e of this.sessionDesc.mediaDescriptions)e.attributes.candidates=this.candidates;}restartICE(e){e=bT(e),this.iceParameters=e,this.sessionDesc.mediaDescriptions.forEach((t=>{t.attributes.iceUfrag=e.iceUfrag,t.attributes.icePwd=e.icePwd;}));}predictReceivingMids(e){const t=[];for(let i=0;i<e;i++)t.push((this.currentMidIndex+i+1).toString(10));return t}mungRecvMediaDsec(e,t){const i=bT(e);return $P(i,t),tL(i,t),i}updateRecvMedia(e,t){const i=this.sessionDesc.mediaDescriptions.findIndex((t=>t.attributes.mid===e));if(-1!==i){const e=this.mungRecvMediaDsec(this.sessionDesc.mediaDescriptions[i],t);this.sessionDesc.mediaDescriptions[i]=e;}}bumpMid(e){this.currentMidIndex+=e;}updateTrackLabel(e,t,i){const n=this.sessionDesc.mediaDescriptions.find((t=>e===hI.VIDEO?"video"===t.attributes.mid:"audio"===t.attributes.mid));if(n){const e=n.attributes.ssrcs.find((e=>e.attributes.label===t));var r;e&&(e.attributes.label=i,null===(r=e.attributes.msid)||void 0===r||r.replace(t,i));}}mungMediaDesc(e){const t=bT(e);return eL(t),function(e){const t=e.attributes.extmaps.find((e=>"http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01"===e.extensionName));t&&e.attributes.extmaps.splice(e.attributes.extmaps.indexOf(t),1),e.attributes.payloads.forEach((e=>{const t=e.rtcpFeedbacks.findIndex((e=>"transport-cc"===e.type));-1!==t&&e.rtcpFeedbacks.splice(t,1);}));}(t),t}getSSRC(e){for(const t of this.sessionDesc.mediaDescriptions)for(const i of t.attributes.ssrcs)if(i.attributes.label===e)return [i]}}({remoteIceParameters:e,remoteDtlsParameters:t,candidates:i,remoteRTPCapabilities:n.send,remoteSetup:r,localCapabilities:this.localCapabilities,sdkCodec:this.store.codec,cname:s});const o=this.remoteSDP.toString();await this.peerConnection.setLocalDescription(this.initialOffer),await this.peerConnection.setRemoteDescription({type:"answer",sdp:o});}catch(e){throw new Vg(xg.EXCHANGE_SDP_FAILED,"P2PConnection.connect failed; ".concat(e.toString()))}}async updateRemoteRTPCapabilities(e,t){throw new Vg(xg.NOT_SUPPORTED,"Planb mode does not support createDataChannels.")}send(e,t){var i=this;return BP((function*(){const n=yield jP(i.mutex.lock());try{if(!i.remoteSDP)throw new Error("Cannot call P2PConnection.send before remote SDP created");const r=e.map((e=>i.peerConnection.addTrack(e._mediaStreamTrack))),s=yield jP(i.peerConnection.createOffer()),o=KP.parse(s.sdp),a=e.map((e=>{const t=e._mediaStreamTrack,n=o.mediaDescriptions.find((e=>e.attributes.mid===t.kind));if(!n)throw new Error("Cannot extract ssrc from mediaDescription.");return function(e,t,i){const n=e.attributes.ssrcs.filter((e=>e.attributes.label===t)),r=e.attributes.ssrcGroups;if(0===n.length)throw new Error("Cannot extract ssrc from plan-b SDP.");if(r&&n.length>1){const e=r.find((e=>-1!==e.ssrcIds.indexOf(n[0].ssrcId)));return e?[{ssrcId:e.ssrcIds[0],rtx:i?e.ssrcIds[1]:void 0}]:[{ssrcId:n[0].ssrcId}]}return [{ssrcId:n[0].ssrcId}]}(n,t.id,i.useRTX)}));let c;try{c=yield a;}catch(e){throw r.forEach((e=>{Sg()&&e.replaceTrack(null),i.peerConnection.removeTrack(e);})),e}const d=i.mungSendOfferSDP(s.sdp,e);i.remoteSDP.receive(e,t,c);const l=i.remoteSDP.toString();return yield jP(i.peerConnection.setLocalDescription({type:"offer",sdp:d})),yield jP(i.applySendEncodings(r,e)),yield jP(i.peerConnection.setRemoteDescription({type:"answer",sdp:l})),e.map(((e,t)=>{const i=e._mediaStreamTrack.id;return {localSSRC:a[t],id:i}}))}catch(e){throw new Vg(xg.EXCHANGE_SDP_FAILED,"P2PConnection.send failed; ".concat(e.toString()))}finally{n();}}))()}async stopSending(e){try{if(!this.remoteSDP)throw new Error("Cannot call P2PConnection.stopSending before remote SDP created");const t=this.peerConnection.getSenders().filter((t=>{var i;return -1!==e.indexOf((null===(i=t.track)||void 0===i?void 0:i.id)||"")}));if(t.length!==e.length)throw new Error("Transceivers' length doesn't match mids' length when trying to call P2PConnection.stopSending.");t.map((e=>{Sg()&&e.replaceTrack(null),this.peerConnection.removeTrack(e);}));const i=await this.peerConnection.createOffer();await this.peerConnection.setLocalDescription(i),this.remoteSDP.stopReceiving(e);const n=this.remoteSDP.toString();await this.peerConnection.setRemoteDescription({type:"answer",sdp:n});}catch(e){throw new Vg(xg.EXCHANGE_SDP_FAILED,"P2PConnection.stopSending failed; ".concat(e.toString()))}}async receive(e,t,i,n){try{if(!this.remoteSDP)throw new Error("Cannot call P2PConnection.receive ".concat(e," before remoteSDP created."));const{id:i,mslabel:r}=this.remoteSDP.send(e,t,n),s=new tg(((t,n)=>{const s=setTimeout((()=>{n(new Error("Cannot receive track, id: ".concat(i)));}),1e4),o=n=>{const a=pg();if(("Safari"===a.name&&11===Number(a.version)||Cg())&&n.track.id!==i&&n.streams[0].id===r){var c;const r=n.streams[0].getTracks()[0];return null===(c=this.remoteSDP)||void 0===c||c.updateTrackLabel(e,i,n.track.id),this.peerConnection.removeEventListener("track",o),clearTimeout(s),void t(r)}if(n.track.id===i)return this.peerConnection.removeEventListener("track",o),clearTimeout(s),void t(n.track)};this.peerConnection.addEventListener("track",o);})),o=this.remoteSDP.toString();await this.peerConnection.setRemoteDescription({type:"offer",sdp:o});const a=await this.peerConnection.createAnswer();await this.peerConnection.setLocalDescription(a);return {track:await s,id:i}}catch(e){throw new Vg(xg.EXCHANGE_SDP_FAILED,"P2PConnection.receive failed; ".concat(e.toString()))}}async stopReceiving(e){try{if(!this.remoteSDP)throw new Error("Cannot call P2PConnection.stopReceiving before remote SDP created.");this.remoteSDP.stopSending(e);const t=this.remoteSDP.toString();await this.peerConnection.setRemoteDescription({type:"offer",sdp:t});const i=await this.peerConnection.createAnswer();await this.peerConnection.setLocalDescription(i);}catch(e){throw new Vg(xg.EXCHANGE_SDP_FAILED,"P2PConnection stopReceiving failed; ".concat(e.toString()))}}async muteRemote(e){}async unmuteRemote(e){}async muteLocal(e){try{if(!this.remoteSDP)throw new Error("Cannot call P2PConnection.muteLocal before remote SDP created.");const t=this.peerConnection.getSenders().filter((t=>{var i;return -1!==e.indexOf((null===(i=t.track)||void 0===i?void 0:i.id)||"")}));if(t.length!==e.length)throw new Error("sender' length doesn't match mids' length.");t.map((e=>{if(Sg()&&e.track)e.track.enabled=!1;else {const t=e.getParameters();t.encodings.forEach((e=>e.active=!1)),e.setParameters(t);}}));}catch(e){throw new Vg(xg.EXCHANGE_SDP_FAILED,"P2PConnection.muteLocal failed; ".concat(e.toString()))}}async unmuteLocal(e){try{if(!this.remoteSDP)throw new Error("Cannot call P2PConnection.unmuteLocal before remote SDP created.");const t=this.peerConnection.getSenders().filter((t=>{var i;return -1!==e.indexOf((null===(i=t.track)||void 0===i?void 0:i.id)||"")}));if(t.length!==e.length)throw new Error("Senders' length doesn't match mids' length.");t.map((async e=>{if(Sg()&&e.track)e.track.enabled=!0;else {const t=e.getParameters();t.encodings.forEach((e=>e.active=!0)),await e.setParameters(t);}}));const i=await this.peerConnection.createOffer();await this.peerConnection.setLocalDescription(i);const n=this.remoteSDP.toString();await this.peerConnection.setRemoteDescription({type:"answer",sdp:n});}catch(e){throw new Vg(xg.EXCHANGE_SDP_FAILED,"P2PConnection.unmuteLocal failed; ".concat(e.toString()))}}restartICE(e){var t=this;return BP((function*(){const i=yield jP(t.mutex.lock("From P2PConnection.restartICE"));try{if(!t.remoteSDP)throw new Error("Cannot restartICE before remoteSDP created.");if(_A().supportPCSetConfiguration){const i=t.peerConnection.getConfiguration(),n=e===uI.RELAY?"relay":"all";i.iceTransportPolicy!==n&&(KC.debug("[".concat(t.store.clientId,"] restartICE change iceTransportPolicy from [").concat(i.iceTransportPolicy,"] to [").concat(n,"]")),i.iceTransportPolicy=n,t.peerConnection.setConfiguration(i));}else if(e===uI.RELAY)return;e!==uI.RELAY&&t.remoteSDP.updateCandidates(e);const n=yield jP(t.peerConnection.createOffer({iceRestart:!0}));if(!n.sdp)throw new Error("Cannot restartICE because restart offer SDP does not exist.");const r=zP(n.sdp),{remoteIceParameters:s}=yield r.iceParameters;t.remoteSDP.restartICE(s);const o=t.remoteSDP.toString();yield jP(t.peerConnection.setLocalDescription(n)),yield jP(t.peerConnection.setRemoteDescription({type:"answer",sdp:o}));}catch(e){KC.warning("[".concat(t.store.clientId,"] restart ICE failed, abort operation"),e);}finally{i();}}))()}close(){var e;this.peerConnection.close(),null===(e=this.onConnectionStateChange)||void 0===e||e.call(this,"closed"),this.unbindPCEvents(),this.unbindStatsEvents(),this.removeAllListeners(),this.statsFilter.destroy();}getStats(){return this.statsFilter.getStats()}getRemoteVideoIsReady(e){return this.statsFilter.getVideoIsReady(e)}async updateEncoderConfig(e,t){try{if(!this.remoteSDP)throw new Error("Cannot call P2PConnection.updateEncoderConfig before remote SDP created.");const e=await this.peerConnection.createOffer(),i=this.mungSendOfferSDP(e.sdp,[t]);this.remoteSDP.updateRecvMedia(t._mediaStreamTrack.kind,t);const n=this.remoteSDP.toString();await this.peerConnection.setLocalDescription({type:"offer",sdp:i}),await this.peerConnection.setRemoteDescription({type:"answer",sdp:n});}catch(e){throw new Vg(xg.EXCHANGE_SDP_FAILED,e.toString())}}async updateSendParameters(e,t){const i=this.peerConnection.getSenders().filter((t=>{var i;return (null===(i=t.track)||void 0===i?void 0:i.id)===e}));1===i.length&&await this.applySendEncodings(i,[t]);}setStatsRemoteVideoIsReady(e,t){this.statsFilter.setVideoIsReady2(e,t);}async replaceTrack(e,t){const i=this.peerConnection.getSenders().find((e=>{var i;return (null===(i=e.track)||void 0===i?void 0:i.id)===t}));i&&await i.replaceTrack(e._mediaStreamTrack);}createDataChannels(e,t){throw new Vg(xg.NOT_SUPPORTED,"Planb mode does not support createDataChannels.")}stopDataChannels(e){throw new Vg(xg.NOT_SUPPORTED,"Planb mode does not support stopDataChannels.")}bindPCEvents(){this.peerConnection.oniceconnectionstatechange=()=>{var e;null===(e=this.onICEConnectionStateChange)||void 0===e||e.call(this,this.peerConnection.iceConnectionState);},this.peerConnection.onconnectionstatechange=()=>{var e;null===(e=this.onConnectionStateChange)||void 0===e||e.call(this,this.peerConnection.connectionState);},this.peerConnection.onicecandidate=e=>{e.candidate?this.localCandidateCount+=1:(this.peerConnection.onicecandidate=null,this.allCandidatesReceived=!0,KC.debug("[".concat(this.store.clientId,"] [pc-").concat(this.store.p2pId,"] local candidate count"),this.localCandidateCount));},setTimeout((()=>{this.allCandidatesReceived||(this.allCandidatesReceived=!0,KC.debug("[".concat(this.store.clientId,"] [pc-").concat(this.store.p2pId,"] onicecandidate timeout, local candidate count"),this.localCandidateCount));}),kC("CANDIDATE_TIMEOUT"));}unbindPCEvents(){this.peerConnection.oniceconnectionstatechange=null,this.peerConnection.onconnectionstatechange=null,this.peerConnection.onsignalingstatechange=null,this.peerConnection.onicecandidateerror=null,this.peerConnection.onicecandidate=null,this.peerConnection.ontrack=null;}static resolvePCConfiguration(e){const t={iceServers:[],sdpSemantics:"plan-b"};return e.iceServers?t.iceServers=e.iceServers:e.turnServer&&"off"!==e.turnServer.mode&&(_T(e.turnServer.servers)?t.iceServers=e.turnServer.servers:(t.iceServers&&t.iceServers.push(...ML.turnServerConfigToIceServers(e.turnServer.servers)),kC("USE_TURN_SERVER_OF_GATEWAY")&&t.iceServers&&e.turnServer.serversFromGateway&&t.iceServers.push(...ML.turnServerConfigToIceServers(e.turnServer.serversFromGateway)),e.turnServer.servers.concat(e.turnServer.serversFromGateway||[]).forEach((e=>{e.forceturn&&(t.iceTransportPolicy="relay");})))),t}static turnServerConfigToIceServers(e){const t=[];return e.forEach((e=>{e.security?e.tcpport&&t.push({username:e.username,credential:e.password,credentialType:"password",urls:"turns:".concat(e.turnServerURL,":").concat(e.tcpport,"?transport=tcp")}):(e.udpport&&t.push({username:e.username,credential:e.password,credentialType:"password",urls:"turn:".concat(e.turnServerURL,":").concat(e.udpport,"?transport=udp")}),e.tcpport&&t.push({username:e.username,credential:e.password,credentialType:"password",urls:"turn:".concat(e.turnServerURL,":").concat(e.tcpport,"?transport=tcp")}));})),t}async updateRtpSenderEncodings(e,t){var i;if(!t){t=this.peerConnection.getSenders().find((t=>{var i;return (null===(i=t.track)||void 0===i?void 0:i.id)===e._mediaStreamTrack.id}));}if(!t)return KC.warn("[".concat(e.getTrackId(),"] no rtpSender found}"));if(!_A().supportSetRtpSenderParameters)return KC.warn("Browser not support set rtp-sender parameters");const n={},r={};if(e instanceof Sb)switch(e._optimizationMode){case"motion":n.degradationPreference="maintain-framerate";break;case"detail":n.degradationPreference="maintain-resolution";break;default:n.degradationPreference="balanced";}if(kC("DSCP_TYPE")&&kg()){var s;const e=kC("DSCP_TYPE");Pr(s=["very-low","low","medium","high"]).call(s,e)&&(r.networkPriority=e);}const o=t.getParameters(),a=null===(i=o.encodings)||void 0===i?void 0:i[0];a&&Object.assign(a,r),Object.assign(o,n),KC.debug("[".concat(e.getTrackId(),"] updateRtpSenderEncodings: ").concat(JSON.stringify(o.encodings))),await t.setParameters(o);}async applySendEncodings(e,t){try{if(!_A().supportSetRtpSenderParameters)return;if(e.length!==t.length)return;for(let i=0;i<e.length;i++){const n=e[i],r=t[i];n&&r&&await this.updateRtpSenderEncodings(r,n);}}catch(e){KC.debug("[".concat(this.store.clientId,"] Apply RTPSendEncodings failed."));}}mungSendOfferSDP(e,t){const i=KP.parse(e);return t.forEach(((e,t)=>{const n=e._mediaStreamTrack,r=i.mediaDescriptions.find((e=>e.attributes.mid===n.kind));r&&$P(r,e);})),KP.print(i)}bindStatsEvents(){this.statsFilter.onFirstAudioReceived=e=>{var t;null===(t=this.onFirstAudioReceived)||void 0===t||t.call(this,e);},this.statsFilter.onFirstVideoReceived=e=>{var t;null===(t=this.onFirstVideoReceived)||void 0===t||t.call(this,e);},this.statsFilter.onFirstAudioDecoded=e=>{var t;null===(t=this.onFirstAudioDecoded)||void 0===t||t.call(this,e);},this.statsFilter.onFirstVideoDecoded=(e,t,i)=>{var n;null===(n=this.onFirstVideoDecoded)||void 0===n||n.call(this,e,t,i);},this.statsFilter.onSelectedLocalCandidateChanged=(e,t)=>{var i;null===(i=this.onSelectedLocalCandidateChanged)||void 0===i||i.call(this,e,t);},this.statsFilter.onSelectedRemoteCandidateChanged=(e,t)=>{var i;null===(i=this.onSelectedRemoteCandidateChanged)||void 0===i||i.call(this,e,t);};}unbindStatsEvents(){this.statsFilter.onFirstAudioReceived=void 0,this.statsFilter.onFirstVideoReceived=void 0,this.statsFilter.onFirstAudioDecoded=void 0,this.statsFilter.onFirstVideoDecoded=void 0,this.statsFilter.onSelectedLocalCandidateChanged=void 0,this.statsFilter.onSelectedRemoteCandidateChanged=void 0;}async batchReceive(e){try{if(!this.remoteSDP)throw new Error("Cannot call P2PConnection.batchReceive before remoteSDP created.");const t=this.remoteSDP.batchSend(e).map(((t,i)=>{let{id:n,mslabel:r}=t;const{kind:s}=e[i];return new tg(((e,t)=>{const i=setTimeout((()=>{t(new Error("Cannot receive track, id: ".concat(n)));}),1e4),o=t=>{const a=pg();if("Safari"===a.name&&11===Number(a.version)&&t.track.id!==n&&t.streams[0].id===r){var c;const r=t.streams[0].getTracks()[0];return null===(c=this.remoteSDP)||void 0===c||c.updateTrackLabel(s,n,t.track.id),this.peerConnection.removeEventListener("track",o),clearTimeout(i),void e({track:r,id:n})}if(t.track.id===n)return this.peerConnection.removeEventListener("track",o),clearTimeout(i),void e({track:t.track,id:n})};this.peerConnection.addEventListener("track",o);}))})),i=this.remoteSDP.toString();await this.peerConnection.setRemoteDescription({type:"offer",sdp:i});const n=await this.peerConnection.createAnswer();return await this.peerConnection.setLocalDescription(n),await tg.all(t)}catch(e){throw new Vg(xg.EXCHANGE_SDP_FAILED,"P2PConnection.receive failed; ".concat(e.toString()))}}async getRemoteSSRC(e){if(!this.remoteSDP)return;const t=this.remoteSDP.getSSRC(e);return null==t?void 0:t[0].ssrcId}setConfiguration(e){if(_A().supportPCSetConfiguration){const t=ML.resolvePCConfiguration(e);this.peerConnection.setConfiguration(t);}}}function UL(e,t,i){const n=e[t];if("function"!=typeof n)throw new Error("Cannot use mutex on object property.");return i.value=async function(){const e=this.mutex,i=await e.lock("Locking from P2PConnection.".concat(t));try{for(var r=arguments.length,s=new Array(r),o=0;o<r;o++)s[o]=arguments[o];return await n.apply(this,s)}finally{i();}},i}function xL(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n);}return i}function VL(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?xL(Object(i),!0).forEach((function(t){nu(e,t,i[t]);})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):xL(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t));}));}return e}Mv([UL,Uv("design:type",Function),Uv("design:paramtypes",[Object,Object,Array,Object,String,String]),Uv("design:returntype",tg)],ML.prototype,"connect",null),Mv([UL,Uv("design:type",Function),Uv("design:paramtypes",[Array]),Uv("design:returntype",tg)],ML.prototype,"stopSending",null),Mv([UL,Uv("design:type",Function),Uv("design:paramtypes",[String,Array,String,Object]),Uv("design:returntype",tg)],ML.prototype,"receive",null),Mv([UL,Uv("design:type",Function),Uv("design:paramtypes",[Array]),Uv("design:returntype",tg)],ML.prototype,"stopReceiving",null),Mv([UL,Uv("design:type",Function),Uv("design:paramtypes",[String]),Uv("design:returntype",tg)],ML.prototype,"muteRemote",null),Mv([UL,Uv("design:type",Function),Uv("design:paramtypes",[String]),Uv("design:returntype",tg)],ML.prototype,"unmuteRemote",null),Mv([UL,Uv("design:type",Function),Uv("design:paramtypes",[Array]),Uv("design:returntype",tg)],ML.prototype,"muteLocal",null),Mv([UL,Uv("design:type",Function),Uv("design:paramtypes",[Array]),Uv("design:returntype",tg)],ML.prototype,"unmuteLocal",null),Mv([UL,Uv("design:type",Function),Uv("design:paramtypes",[]),Uv("design:returntype",void 0)],ML.prototype,"close",null),Mv([UL,Uv("design:type",Function),Uv("design:paramtypes",[String,iA]),Uv("design:returntype",tg)],ML.prototype,"updateEncoderConfig",null),Mv([UL,Uv("design:type",Function),Uv("design:paramtypes",[String,iA]),Uv("design:returntype",tg)],ML.prototype,"updateSendParameters",null),Mv([UL,Uv("design:type",Function),Uv("design:paramtypes",[iA,String]),Uv("design:returntype",tg)],ML.prototype,"replaceTrack",null),Mv([UL,Uv("design:type",Function),Uv("design:paramtypes",[String]),Uv("design:returntype",tg)],ML.prototype,"getRemoteSSRC",null);const FL="9",BL=4e4;function jL(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n);}return i}function GL(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?jL(Object(i),!0).forEach((function(t){nu(e,t,i[t]);})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):jL(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t));}));}return e}let WL=class e extends PI{get currentLocalDescription(){return this.peerConnection.currentLocalDescription}get currentRemoteDescription(){return this.peerConnection.currentRemoteDescription}get peerConnectionState(){return this.peerConnection.connectionState}get iceConnectionState(){return this.peerConnection.iceConnectionState}get dtlsTransportState(){var e,t;return null!==(e=null===(t=this.peerConnection.getReceivers()[0])||void 0===t||null===(t=t.transport)||void 0===t?void 0:t.state)&&void 0!==e?e:null}constructor(t,i){super(t,i),nu(this,"store",void 0),nu(this,"peerConnection",void 0),nu(this,"remoteSDP",void 0),nu(this,"initialOffer",void 0),nu(this,"transportEventReceiver",void 0),nu(this,"statsFilter",void 0),nu(this,"useXR",kC("USE_XR")),nu(this,"localCapabilities",void 0),nu(this,"remoteCodecs",void 0),nu(this,"localCandidateCount",0),nu(this,"allCandidatesReceived",!1),nu(this,"dataStreamChannelMap",new Map),nu(this,"establishPromise",void 0),nu(this,"mutex",new YT("P2PConnection-mutex")),this.store=i,this.peerConnection=new RTCPeerConnection(e.resolvePCConfiguration(t),{optional:[{googDscp:!0}]}),this.statsFilter=PL(this.peerConnection,kC("STATS_UPDATE_INTERVAL"),void 0,Rg()?1200:void 0),this.bindPCEvents(),this.bindStatsEvents(),this.store.p2pId=this.store.p2pId+1,this.establishPromise=this.establish();}async updateRemoteRTPCapabilities(e,t){this.remoteCodecs=t;const i=[...new Set(this.localCapabilities&&this.localCapabilities.send.videoCodecs.map((e=>e.rtpMap&&e.rtpMap.encodingName.toLowerCase()||"")).filter((e=>{var t;return Pr(t=Object.keys(UC)).call(t,e)})))];if(rv.updateRemoteRTPCapabilities(this.store.sessionId,{mids:e,localCodecs:i,remoteCodecs:this.remoteCodecs}),!this.remoteSDP)return void KC.debug("[P2PConnection] cannot updateRemoteRTPCapabilities before remote SDP created, local codecs: ".concat(i,", codecs: ").concat(t));if(this.remoteSDP.updateRemoteCodec(e,t,this.store.codec)){const e=await this.peerConnection.createOffer(),t=this.logSDPExchange(e.sdp||"","offer","local","muteLocal");await this.peerConnection.setLocalDescription(e);const i=this.remoteSDP.toString();null==t||t(i),await this.peerConnection.setRemoteDescription({type:"answer",sdp:i});}else KC.debug("[P2PConnection] updateRemoteRTPCapabilities no need to exchange SDP.");}async establish(){try{this.peerConnection.addTransceiver("video",{direction:"recvonly"}),this.peerConnection.addTransceiver("audio",{direction:"recvonly"});const e=await this.peerConnection.createOffer();if(!e.sdp)throw new Error("Cannot get initialOffer.sdp when trying to establish PeerConnection.");const t=zP(e.sdp),i=await sL({filterRTX:!kC("USE_PUB_RTX")&&!kC("USE_SUB_RTX"),filterVideoFec:kC("FILTER_VIDEO_FEC"),filterAudioFec:kC("FILTER_AUDIO_FEC"),filterVideoCodec:kC("FILTER_VIDEO_CODEC")},{useXR:this.useXR});return this.localCapabilities=aL(i),this.initialOffer=e,GL(GL({},t),{},{rtpCapabilities:i,offerSDP:e.sdp})}catch(e){throw new Vg(xg.GET_LOCAL_CONNECTION_PARAMS_FAILED,e.toString())}}async connect(e,t,i,n,r,s){try{if(!this.initialOffer)throw new Error("Cannot establish P2PConnection without initial offer.");this.remoteSDP=new class{get localCapabilities(){return bT(this._localCapabilities)}get rtpCapabilities(){return bT(this._rtpCapabilities)}get candidates(){return bT(this._candidates)}get iceParameters(){return bT(this._iceParameters)}get dtlsParameters(){return bT(this._dtlsParameters)}constructor(e){nu(this,"sessionDesc",void 0),nu(this,"_localCapabilities",void 0),nu(this,"_rtpCapabilities",void 0),nu(this,"_candidates",void 0),nu(this,"_iceParameters",void 0),nu(this,"_dtlsParameters",void 0),nu(this,"setup",void 0),nu(this,"currentMidIndex",void 0),nu(this,"cname",void 0),nu(this,"firefoxSsrcMidMap",new Map),e=bT(e);const{remoteIceParameters:t,remoteDtlsParameters:i,candidates:n,remoteRTPCapabilities:r,remoteSetup:s,localCapabilities:o,cname:a}=e,c=KP.parse("v=0\no=- 0 0 IN IP4 127.0.0.1\ns=AgoraGateway\nt=0 0\na=group:BUNDLE 0 1\na=msid-semantic: WMS\na=ice-lite\nm=video 9 UDP/TLS/RTP/SAVPF 0\nc=IN IP4 127.0.0.1\na=rtcp:9 IN IP4 0.0.0.0\na=sendonly\na=rtcp-mux\na=rtcp-rsize\na=mid:0\nm=audio 9 UDP/TLS/RTP/SAVPF 0\nc=IN IP4 127.0.0.1\na=rtcp:9 IN IP4 0.0.0.0\na=sendonly\na=rtcp-mux\na=rtcp-rsize\na=mid:1\n");this._rtpCapabilities=r,this._candidates=n,this._iceParameters=t,this._dtlsParameters=i,this._localCapabilities=o,this.setup=s,this.cname=a;const d=this.rtpCapabilities.send;for(const e of c.mediaDescriptions){if(e.attributes.iceUfrag=t.iceUfrag,e.attributes.icePwd=t.icePwd,e.attributes.fingerprints=i.fingerprints,e.attributes.candidates=n,e.attributes.setup=s,"video"===e.media.mediaType&&(e.media.fmts=d.videoCodecs.map((e=>e.payloadType.toString(10))),e.attributes.payloads=d.videoCodecs,e.attributes.extmaps=d.videoExtensions,kC("PRELOAD_MEDIA_COUNT")>0)){const{ssrcs:t,ssrcGroups:i}=ZP([{ssrcId:BL,rtx:kC("USE_SUB_RTX")?40001:void 0}],this.cname);e.attributes.ssrcs=t,e.attributes.ssrcGroups=i;}if("audio"===e.media.mediaType&&(e.media.fmts=d.audioCodecs.map((e=>e.payloadType.toString(10))),e.attributes.payloads=d.audioCodecs,e.attributes.extmaps=d.audioExtensions,cL(e),kC("PRELOAD_MEDIA_COUNT")>0)){const{ssrcs:t,ssrcGroups:i}=ZP([{ssrcId:2e4}],this.cname);e.attributes.ssrcs=t,e.attributes.ssrcGroups=i;}}this.sessionDesc=c,this.currentMidIndex=c.mediaDescriptions.length-1;}preloadRemoteMedia(){const e=kC("PRELOAD_MEDIA_COUNT");this.rtpCapabilities;const t=this.candidates,i=this.dtlsParameters,n=this.iceParameters,r=this.rtpCapabilities.send;for(let s=1;s<e;s++){const e=2*s+2e4,o=2*s+BL,{ssrcs:a,ssrcGroups:c}=ZP([{ssrcId:e}],this.cname),{ssrcs:d,ssrcGroups:l}=ZP([{ssrcId:o,rtx:kC("USE_SUB_RTX")?o+1:void 0}],this.cname);this.sessionDesc.mediaDescriptions.push({media:{mediaType:"video",port:FL,protos:["UDP","TLS","RTP","SAVPF"],fmts:r.videoCodecs.map((e=>e.payloadType.toString(10)))},connections:[{nettype:"IN",addrtype:"IP4",address:"127.0.0.1"}],bandwidths:[],attributes:{iceUfrag:n.iceUfrag,icePwd:n.icePwd,unrecognized:[],candidates:t,extmaps:r.videoExtensions,fingerprints:i.fingerprints,imageattr:[],msids:[],remoteCandidatesList:[],rids:[],ssrcs:d,ssrcGroups:l,rtcpFeedbackWildcards:[],payloads:r.videoCodecs,rtcp:{port:"9",netType:"IN",addressType:"IP4",address:"0.0.0.0"},setup:this.setup,direction:"sendonly",rtcpMux:!0,rtcpRsize:!0,mid:"".concat(2*s)}}),this.sessionDesc.mediaDescriptions.push({media:{mediaType:"audio",port:FL,protos:["UDP","TLS","RTP","SAVPF"],fmts:r.audioCodecs.map((e=>e.payloadType.toString(10)))},connections:[{nettype:"IN",addrtype:"IP4",address:"127.0.0.1"}],bandwidths:[],attributes:{iceUfrag:n.iceUfrag,icePwd:n.icePwd,unrecognized:[],candidates:t,extmaps:r.audioExtensions,fingerprints:i.fingerprints,imageattr:[],msids:[],remoteCandidatesList:[],rids:[],ssrcs:a,ssrcGroups:c,rtcpFeedbackWildcards:[],payloads:r.audioCodecs,rtcp:{port:"9",netType:"IN",addressType:"IP4",address:"0.0.0.0"},setup:this.setup,direction:"sendonly",rtcpMux:!0,rtcpRsize:!0,mid:"".concat(2*s+1)}}),this.currentMidIndex+=2;}this.updateBundleMids();}toString(){return KP.print(this.sessionDesc)}send(e,t,i,n){const{ssrcs:r,ssrcGroups:s}=ZP(t,this.cname,kC("SYNC_GROUP")?i:void 0),o=this.findPreloadMediaDesc(r);if(o){if(Rg()&&this.firefoxSsrcMidMap.set(r[0].ssrcId,o.attributes.mid),n&&(n.twcc||n.remb)){const e=this.sessionDesc.mediaDescriptions.indexOf(o);return this.sessionDesc.mediaDescriptions[e]=this.mungSendMediaDesc(o,n),{mid:o.attributes.mid,needExchangeSDP:!0}}return {mid:o.attributes.mid,needExchangeSDP:!1}}{const t=this.findAvailableMediaIndex(e,r);let i;return -1===t||1===t&&(Sg()||Ag())||0===t&&kC("USE_SUB_RTX")||bg()?(i=this.createOrRecycleSendMedia(e,r,s,"sendonly",n),this.updateBundleMids()):(i=bT(this.sessionDesc.mediaDescriptions[t]),i.attributes.direction="sendonly",i.attributes.ssrcs=r,i.attributes.ssrcGroups=s,this.sessionDesc.mediaDescriptions[t]=this.mungSendMediaDesc(i,n)),Rg()&&this.firefoxSsrcMidMap.set(r[0].ssrcId,i.attributes.mid),{mid:i.attributes.mid,needExchangeSDP:!0}}}sendDataChannel(){const{mediaDesc:e,needExchangeSDP:t}=this.createOrRecycleDataChannel();return this.updateBundleMids(),{mid:e.attributes.mid,needExchangeSDP:t}}batchSend(e){const t=e.map((e=>{let{kind:t,ssrcMsg:i,mslabel:n}=e;return this.send(t,i,n)})),i=[];let n=!1;return t.forEach((e=>{let{mid:t,needExchangeSDP:r}=e;r&&(n=!0),i.push(t);})),{mids:i,needExchangeSDP:n}}stopSending(e){const t=this.sessionDesc.mediaDescriptions.filter((t=>t.attributes.mid&&-1!==e.indexOf(t.attributes.mid)));if(t.length!==e.length)throw new Error("mediaDescriptions' length doesn't match mids' length when calling RemoteSDP.stopSending.");t.forEach((e=>{"0"===e.attributes.mid||Rg()||bg()?e.attributes.ssrcs=[]:(e.attributes.ssrcs=[],e.attributes.direction="inactive",e.media.port="0");})),this.updateBundleMids();}mute(e){const t=this.sessionDesc.mediaDescriptions.find((t=>t.attributes.mid===e));if(!t)throw new Error("mediaDescription not found with ".concat(e," in remote SDP when calling RemoteSDP.mute."));t.attributes.direction="inactive";}unmute(e){const t=this.sessionDesc.mediaDescriptions.find((t=>t.attributes.mid===e));if(!t)throw new Error("mediaDescription not found with ".concat(e," in remote SDP when calling RemoteSDP.unmute."));t.attributes.direction="sendonly";}muteRemote(e){const t=this.sessionDesc.mediaDescriptions.filter((t=>Pr(e).call(e,t.attributes.mid||"")));if(t.length!==e.length)throw new Error("mediaDescriptions' length doesn't match mids' length when calling RemoteSDP.muteRemote.");t.forEach((e=>{e.attributes.direction="inactive";}));}unmuteRemote(e){const t=this.sessionDesc.mediaDescriptions.filter((t=>Pr(e).call(e,t.attributes.mid||"")));if(t.length!==e.length)throw new Error("mediaDescriptions' length doesn't match mids' length when calling RemoteSDP.muteRemote.");t.forEach((e=>{e.attributes.direction="recvonly";}));}receive(e,t,i,n){e.forEach(((e,r)=>{this.createOrRecycleRecvMedia(e,[],"recvonly",t,i,n[r]);})),this.updateBundleMids();}stopReceiving(e){const t=this.sessionDesc.mediaDescriptions.filter((t=>-1!==e.indexOf(t.attributes.mid)));if(t.length!==e.length)throw new Error("MediaDescriptions' length doesn't match mids's length when calling RemoteSDP.receive.");t.forEach((e=>{e.media.port="0",e.attributes.direction="inactive";})),this.updateBundleMids();}updateCandidates(e){const t=this._candidates.filter((e=>"udp"===e.transport));if(e===uI.TCP){if(0===t.length)return;if(kC("TCP_CANDIDATE_ONLY")){const e=this._candidates.filter((e=>"tcp"===e.transport));t.forEach((t=>{-1===e.findIndex((e=>e.connectionAddress===t.connectionAddress))&&e.push(VL(VL({},t),{},{foundation:"tcpcandidate",priority:Number(t.priority)-1+"",transport:"tcp",port:Number(t.port)+90+""}));})),this._candidates=e;}else {const e=[];t.forEach((t=>{e.push(VL(VL({},t),{},{foundation:"tcpcandidate",priority:Number(t.priority)-1+"",transport:"tcp",port:Number(t.port)+90+""}));})),this._candidates=[...t,...e];}}else if(e===uI.RELAY){if(0!==t.length)return;{const e=this._candidates.filter((e=>"tcp"===e.transport));e.forEach((e=>{t.push(VL(VL({},e),{},{foundation:"udpcandidate",priority:Number(e.priority)+1+"",transport:"udp",port:Number(e.port)-90+""}));})),this._candidates=[...t,...e];}}else 0===t.length?(this._candidates.filter((e=>"tcp"===e.transport)).forEach((e=>{t.push(VL(VL({},e),{},{foundation:"udpcandidate",priority:Number(e.priority)+1+"",transport:"udp",port:Number(e.port)-90+""}));})),this._candidates=t):this._candidates=this._candidates.filter((e=>"tcp"!==e.transport));for(const e of this.sessionDesc.mediaDescriptions)e.attributes.candidates=this.candidates;}restartICE(e){e=bT(e),this._iceParameters=e,this.sessionDesc.mediaDescriptions.forEach((t=>{t.attributes.iceUfrag=e.iceUfrag,t.attributes.icePwd=e.icePwd;}));}predictReceivingMids(e){const t=[];for(let i=0;i<e;i++)t.push((this.currentMidIndex+i+1).toString(10));return t}findAvailableMediaIndex(e,t){return this.sessionDesc.mediaDescriptions.findIndex((i=>{const n=i.media.mediaType===e&&"0"!==i.media.port&&("sendonly"===i.attributes.direction||"sendrecv"===i.attributes.direction)&&0===i.attributes.ssrcs.length;if(Rg()){if(n){const e=this.firefoxSsrcMidMap.get(t[0].ssrcId);return !(e||"0"!==i.attributes.mid&&"1"!==i.attributes.mid)||!(!e||e!==i.attributes.mid)}return !1}return n}))}createOrRecycleDataChannel(){for(const e of this.sessionDesc.mediaDescriptions)if("application"===e.media.mediaType)return {mediaDesc:e,needExchangeSDP:!1};this.currentMidIndex+=1;const e="".concat(this.currentMidIndex),t={media:{mediaType:"application",port:FL,protos:["UDP","DTLS","SCTP"],fmts:["webrtc-datachannel"]},connections:[{nettype:"IN",addrtype:"IP4",address:"127.0.0.1"}],bandwidths:[],attributes:{iceUfrag:this.iceParameters.iceUfrag,icePwd:this.iceParameters.icePwd,unrecognized:[],candidates:this.candidates,extmaps:[],fingerprints:this.dtlsParameters.fingerprints,imageattr:[],msids:[],remoteCandidatesList:[],rids:[],ssrcs:[],ssrcGroups:[],rtcpFeedbackWildcards:[],payloads:[],rtcp:{port:"9",netType:"IN",addressType:"IP4",address:"0.0.0.0"},setup:this.setup,mid:"".concat(e),sctpPort:"5000"}};return this.sessionDesc.mediaDescriptions.push(t),{mediaDesc:t,needExchangeSDP:!0}}createOrRecycleRecvMedia(e,t,i,n,r,s){const o=e._mediaStreamTrack.kind,a=this.rtpCapabilities.recv,c=lL(o,a,this.localCapabilities.send,o===hI.VIDEO?n:r),d=o===hI.VIDEO?a.videoExtensions:a.audioExtensions;this.currentMidIndex+=1;const l="".concat(this.currentMidIndex);let h={media:{mediaType:o,port:FL,protos:["UDP","TLS","RTP","SAVPF"],fmts:c.map((e=>e.payloadType.toString(10)))},connections:[{nettype:"IN",addrtype:"IP4",address:"127.0.0.1"}],bandwidths:[],attributes:{iceUfrag:this.iceParameters.iceUfrag,icePwd:this.iceParameters.icePwd,unrecognized:[],candidates:this.candidates,extmaps:d,fingerprints:this.dtlsParameters.fingerprints,imageattr:[],msids:[],remoteCandidatesList:[],rids:[],ssrcs:t,ssrcGroups:[],rtcpFeedbackWildcards:[],payloads:c,rtcp:{port:"9",netType:"IN",addressType:"IP4",address:"0.0.0.0"},setup:this.setup,direction:i,rtcpMux:!0,rtcpRsize:!0,mid:"".concat(l)}};h=this.mungRecvMediaDsec(h,e,s);const u=this.findFirstClosedMedia(o);if(u){const e=this.sessionDesc.mediaDescriptions.indexOf(u);this.sessionDesc.mediaDescriptions[e]=h;}else this.sessionDesc.mediaDescriptions.push(h);return h}updateRemoteCodec(e,t,i){const n=[...new Set(this._rtpCapabilities.recv.videoCodecs.map((e=>e.rtpMap&&e.rtpMap.encodingName.toLowerCase()||"")).filter((e=>{var t;return Pr(t=Object.keys(UC)).call(t,e)})))],r=new Set(t);if(n.every((e=>r.has(e))))return KC.debug("codecs has not changed, no need to updateRemoteCodec, codecs: ".concat(t)),!1;const s=this._rtpCapabilities.recv.videoCodecs.filter((e=>t.some((t=>{var i;return Pr(i=e.rtpMap&&e.rtpMap.encodingName.toLowerCase()||"").call(i,t)}))));if(0===s.length)return KC.debug("updateRemoteCodec failed, because cannot find matched codec, remoteCapabilities codecs: ".concat(n," codecs: ").concat(t)),!1;const o=[...new Set(s.map((e=>e.rtpMap&&e.rtpMap.encodingName.toLowerCase()||"")))];let a;if(KC.debug("updateRemoteCodec, from ".concat(n," to ").concat(o)),0===e.length)a=this.sessionDesc.mediaDescriptions.filter((e=>"video"===e.media.mediaType&&"recvonly"===e.attributes.direction));else if(a=this.sessionDesc.mediaDescriptions.filter((t=>t.attributes.mid&&Pr(e).call(e,t.attributes.mid)&&"recvonly"===t.attributes.direction)),a.length!==e.length)return KC.debug("updateRemoteCodec failed, because cannot find mids, mids: ".concat(e,", codecs: ").concat(t)),!1;this._rtpCapabilities.recv.videoCodecs=s;const c=this.localCapabilities.send,d=this.rtpCapabilities.recv,l=lL(hI.VIDEO,d,c,i);return a.forEach((e=>{const t=l.map((e=>e.payloadType.toString(10)));KC.debug("updateRemoteCodec mid: ".concat(e.attributes.mid,", from ").concat(e.attributes.payloads," to ").concat(l)),e.attributes.payloads=l,e.media.fmts=t;})),!0}createOrRecycleSendMedia(e,t,i,n,r){const s=this.rtpCapabilities.send,o=e===hI.VIDEO?s.videoCodecs:s.audioCodecs,a=e===hI.VIDEO?s.videoExtensions:s.audioExtensions;this.currentMidIndex+=1;const c="".concat(this.currentMidIndex);let d={media:{mediaType:e,port:FL,protos:["UDP","TLS","RTP","SAVPF"],fmts:o.map((e=>e.payloadType.toString(10)))},connections:[{nettype:"IN",addrtype:"IP4",address:"127.0.0.1"}],bandwidths:[],attributes:{iceUfrag:this.iceParameters.iceUfrag,icePwd:this.iceParameters.icePwd,unrecognized:[],candidates:this.candidates,extmaps:a,fingerprints:this.dtlsParameters.fingerprints,imageattr:[],msids:[],remoteCandidatesList:[],rids:[],ssrcs:t,ssrcGroups:i,rtcpFeedbackWildcards:[],payloads:o,rtcp:{port:"9",netType:"IN",addressType:"IP4",address:"0.0.0.0"},setup:this.setup,direction:n,rtcpMux:!0,rtcpRsize:!0,mid:"".concat(c)}};d=this.mungSendMediaDesc(d,r);const l=this.findFirstClosedMedia(e);if(l){const e=this.sessionDesc.mediaDescriptions.indexOf(l);this.sessionDesc.mediaDescriptions[e]=d;}else this.sessionDesc.mediaDescriptions.push(d);return d}updateBundleMids(){this.sessionDesc.attributes.groups[0].identificationTag=this.sessionDesc.mediaDescriptions.filter((e=>"0"!==e.media.port)).map((e=>e.attributes.mid));}mungRecvMediaDsec(e,t,i){const n=bT(e);return eL(n),$P(n,t),tL(n,t),iL(n),nL(n,i,this.localCapabilities.send),n}mungSendMediaDesc(e,t){const i=bT(e);return nL(i,t,this.localCapabilities.recv),cL(i),i}updateRecvMedia(e,t){const i=this.sessionDesc.mediaDescriptions.findIndex((t=>t.attributes.mid===e));if(-1!==i){const e=this.mungRecvMediaDsec(this.sessionDesc.mediaDescriptions[i],t);this.sessionDesc.mediaDescriptions[i]=e;}}bumpMid(e){this.currentMidIndex+=e;}findFirstClosedMedia(e){return this.sessionDesc.mediaDescriptions.find((t=>Rg()?"0"===t.media.port&&t.media.mediaType===e:"0"===t.media.port))}findPreloadMediaDesc(e){return this.sessionDesc.mediaDescriptions.find((t=>{var i;return (null===(i=t.attributes)||void 0===i||null===(i=i.ssrcs[0])||void 0===i?void 0:i.ssrcId)===e[0].ssrcId}))}getSSRC(e){var t;return null===(t=this.sessionDesc.mediaDescriptions.find((t=>t.attributes.mid===e)))||void 0===t?void 0:t.attributes.ssrcs}}({remoteIceParameters:e,remoteDtlsParameters:t,candidates:i,remoteRTPCapabilities:n,remoteSetup:r,localCapabilities:this.localCapabilities,cname:s}),Array.isArray(this.remoteCodecs)&&this.remoteCodecs.length>0&&this.remoteSDP.updateRemoteCodec([],this.remoteCodecs,this.store.codec);const o=this.remoteSDP.toString(),a=KP.parse(this.initialOffer.sdp),c=a.mediaDescriptions.find((e=>"audio"===e.media.mediaType));c&&cL(c),this.useXR&&dL(a);const d=KP.print(a),l=this.logSDPExchange(d||"","offer","local","connect");this.store.descriptionStart(),await this.peerConnection.setLocalDescription({type:"offer",sdp:d}),null==l||l(o),await this.peerConnection.setRemoteDescription({type:"answer",sdp:o});const h=this.peerConnection.getTransceivers()[0];if(null!=h&&h.receiver&&this.tryBindTransportEvents(h.receiver),kC("PRELOAD_MEDIA_COUNT")>0){this.remoteSDP.preloadRemoteMedia();const e=this.remoteSDP.toString();await this.peerConnection.setRemoteDescription({type:"offer",sdp:e});const t=await this.peerConnection.createAnswer();await this.peerConnection.setLocalDescription(t);}}catch(e){throw new Vg(xg.EXCHANGE_SDP_FAILED,"P2PConnection.connect failed; ".concat(e.toString()))}}send(e,t,i){var n=this;return BP((function*(){const r=yield jP(n.mutex.lock("From P2PConnection.send"));try{if(!n.remoteSDP)throw new Error("Cannot call P2PConnection.send before remote SDP created");const s=[];e.forEach((e=>{const t=n.peerConnection.addTransceiver(e._mediaStreamTrack,{direction:"sendonly"});s.push(t),e._updateRtpTransceiver(t);})),Rg()&&!0===kC("SIMULCAST")&&(yield jP(n.applySimulcastForFirefox(s,e)));const o=yield jP(n.peerConnection.createOffer()),a=n.remoteSDP.predictReceivingMids(e.length),c=n.mungSendOfferSDP(o.sdp,e,a),d=KP.parse(c),l=a.map((e=>{const t=d.mediaDescriptions.find((t=>t.attributes.mid===e));if(!t)throw new Error("Cannot extract ssrc from mediaDescription.");return XP(t,kC("USE_PUB_RTX"))}));let h;try{h=yield l;}catch(r){h=[],n.remoteSDP.receive(e,t,i,h);const s=n.remoteSDP.toString();throw yield jP(n.peerConnection.setLocalDescription({type:"offer",sdp:c})),yield jP(n.peerConnection.setRemoteDescription({type:"answer",sdp:s})),yield jP(n.stopSending(a,!0)),r}n.remoteSDP.receive(e,t,i,h);const u=n.remoteSDP.toString(),p=n.logSDPExchange(c,"offer","local","send");return yield jP(n.peerConnection.setLocalDescription({type:"offer",sdp:c})),yield jP(n.applySimulcastEncodings(s,e)),yield jP(n.applySendEncodings(s,e)),null==p||p(u),yield jP(n.peerConnection.setRemoteDescription({type:"answer",sdp:u})),s.map(((e,t)=>{const i=a[t];return {localSSRC:l[t],id:i,transceiver:e}}))}catch(e){throw e instanceof Vg?e:new Vg(xg.EXCHANGE_SDP_FAILED,"P2PConnection.send failed; ".concat(e.toString()))}finally{r();}}))()}async createDataChannels(e,t){try{if(!this.remoteSDP)throw new Error("Cannot call P2PConnection.createDataChannels before remote SDP created");let i=this.dataStreamChannelMap.get(e);i&&"open"===i.readyState?KC.debug("[P2PConnection] Channels are already available and can be reused directly."):(i=this.peerConnection.createDataChannel("datastream-channel",{ordered:!1,maxRetransmits:kC("DATASTREAM_MAX_RETRANSMITS")}),i.binaryType="arraybuffer",this.dataStreamChannelMap.set(e,i)),t.forEach((e=>{e._updateOriginDataChannel(i);}));const{needExchangeSDP:n}=this.remoteSDP.sendDataChannel();if(n){const e=this.remoteSDP.toString();await this.peerConnection.setRemoteDescription({type:"offer",sdp:e});const t=await this.peerConnection.createAnswer();await this.peerConnection.setLocalDescription(t),KC.debug("[P2PConnection] createDataChannels by exchanging SDP.");}else KC.debug("[P2PConnection] createDataChannels no need to exchange SDP.");return}catch(e){throw e instanceof Vg?e:new Vg(xg.EXCHANGE_SDP_FAILED,"P2PConnection.createDataChannels failed; ".concat(e.toString()))}}async stopDataChannels(e){try{const t=this.dataStreamChannelMap.get(e);return null==t||t.close(),void this.dataStreamChannelMap.delete(e)}catch(e){throw e instanceof Vg?e:new Vg(xg.DATACHANNEL_FAILED,"P2PConnection.stopDataChannels failed; ".concat(e.toString()))}}async stopSending(e,t){const i=t?void 0:await this.mutex.lock("From P2PConnection.stopSending");try{if(!this.remoteSDP)throw new Error("Cannot call P2PConnection.stopSending before remote SDP created");const t=this.peerConnection.getTransceivers().filter((t=>-1!==e.indexOf(t.mid)));if(t.length!==e.length)throw new Error("Transceivers' length doesn't match mids' length when trying to call P2PConnection.stopSending.");t.map((e=>{var t;e.direction="inactive",null===(t=e.stop)||void 0===t||t.call(e);}));const n=await this.peerConnection.createOffer(),r=this.logSDPExchange(n.sdp||"","offer","local","stopSending");await this.peerConnection.setLocalDescription(n),this.remoteSDP.stopReceiving(e);const s=this.remoteSDP.toString();null==r||r(s),await this.peerConnection.setRemoteDescription({type:"answer",sdp:s});}catch(e){throw new Vg(xg.EXCHANGE_SDP_FAILED,"P2PConnection.stopSending failed; ".concat(e.toString()))}finally{i&&i();}}async receive(e,t,i,n){try{if(!this.remoteSDP)throw new Error("Cannot call P2PConnection.receive ".concat(e," before remoteSDP created."));const{mid:r,needExchangeSDP:s}=this.remoteSDP.send(e,t,i,n);if(s){const t=this.remoteSDP.toString(),i=this.logSDPExchange(t,"offer","remote","receive");await this.peerConnection.setRemoteDescription({type:"offer",sdp:t});const n=await this.peerConnection.createAnswer(),s=this.mungReceiveAnswerSDP(n.sdp,r,e);null==i||i(s||""),await this.peerConnection.setLocalDescription({type:"answer",sdp:s}),KC.debug("[".concat(this.store.clientId,"] [P2PConnection] receive ").concat(e," by exchanging SDP."));}else KC.debug("[".concat(this.store.clientId,"] [P2PConnection] receive ").concat(e," no need to exchange SDP."));const o=this.peerConnection.getTransceivers().find((e=>e.mid===r));if(!o)throw new Error("Cannot get transceiver after setLocalDescription.");return {track:o.receiver.track,id:r,transceiver:o}}catch(e){throw new Vg(xg.EXCHANGE_SDP_FAILED,"P2PConnection.receive failed; ".concat(e.toString()))}}async batchReceive(e){try{if(!this.remoteSDP)throw new Error("Cannot call P2PConnection.batchReceive before remoteSDP created.");const{mids:t,needExchangeSDP:i}=this.remoteSDP.batchSend(e);if(i){const e=this.remoteSDP.toString(),t=this.logSDPExchange(e,"offer","remote","receive");await this.peerConnection.setRemoteDescription({type:"offer",sdp:e});const i=await this.peerConnection.createAnswer();null==t||t(i.sdp||""),await this.peerConnection.setLocalDescription(i),KC.debug("[".concat(this.store.clientId,"] [P2PConnection] batchReceive by exchanging SDP."));}else KC.debug("[".concat(this.store.clientId,"] [P2PConnection] batchReceive no need to exchange SDP."));return t.map((e=>{const t=this.peerConnection.getTransceivers().find((t=>t.mid===e));if(!t)throw new Error("Cannot get transceiver after setLocalDescription.");return {track:t.receiver.track,id:e,transceiver:t}}))}catch(e){throw new Vg(xg.EXCHANGE_SDP_FAILED,"P2PConnection.receive failed; ".concat(e.toString()))}}async stopReceiving(e){try{if(!this.remoteSDP)throw new Error("Cannot call P2PConnection.stopReceiving before remote SDP created.");this.remoteSDP.stopSending(e);const t=this.remoteSDP.toString(),i=this.logSDPExchange(t,"offer","remote","stopReceiving");await this.peerConnection.setRemoteDescription({type:"offer",sdp:t});const n=await this.peerConnection.createAnswer();null==i||i(n.sdp||""),await this.peerConnection.setLocalDescription(n);}catch(e){throw new Vg(xg.EXCHANGE_SDP_FAILED,"P2PConnection stopReceiving failed; ".concat(e.toString()))}}async muteRemote(e){try{if(!this.remoteSDP)throw new Error("Cannot call P2PConnection.muteRemote mid=".concat(e," before remote SDP created."));this.remoteSDP.mute(e);const t=this.remoteSDP.toString(),i=this.logSDPExchange(t,"offer","remote","muteRemote");await this.peerConnection.setRemoteDescription({type:"offer",sdp:t});const n=await this.peerConnection.createAnswer();null==i||i(n.sdp||""),await this.peerConnection.setLocalDescription(n);}catch(e){throw new Vg(xg.EXCHANGE_SDP_FAILED,"P2PConnection.muteRemote failed; ".concat(e.toString()))}}async unmuteRemote(e){try{if(!this.remoteSDP)throw new Error("Cannot call P2PConnection.unmuteRemote mid=".concat(e," before remote SDP created."));this.remoteSDP.unmute(e);const t=this.remoteSDP.toString(),i=this.logSDPExchange(t,"offer","remote","unmuteRemote");await this.peerConnection.setRemoteDescription({type:"offer",sdp:t});const n=await this.peerConnection.createAnswer();null==i||i(n.sdp||""),await this.peerConnection.setLocalDescription(n);}catch(e){throw new Vg(xg.EXCHANGE_SDP_FAILED,"P2PConnection.unmuteRemote failed; ".concat(e.toString()))}}async muteLocal(e){try{if(!this.remoteSDP)throw new Error("Cannot call P2PConnection.muteLocal before remote SDP created.");const t=this.peerConnection.getTransceivers().filter((t=>t.mid&&-1!==e.indexOf(t.mid)));if(t.length!==e.length)throw new Error("Transceivers' length doesn't match mids' length.");t.map((e=>{e.direction="inactive";}));const i=await this.peerConnection.createOffer(),n=this.logSDPExchange(i.sdp||"","offer","local","muteLocal");await this.peerConnection.setLocalDescription(i),this.remoteSDP.muteRemote(e);const r=this.remoteSDP.toString();null==n||n(r),await this.peerConnection.setRemoteDescription({type:"answer",sdp:r});}catch(e){throw new Vg(xg.EXCHANGE_SDP_FAILED,"P2PConnection.muteLocal failed; ".concat(e.toString()))}}async unmuteLocal(e){try{if(!this.remoteSDP)throw new Error("Cannot call P2PConnection.unmuteLocal before remote SDP created.");const t=this.peerConnection.getTransceivers().filter((t=>t.mid&&-1!==e.indexOf(t.mid)));if(t.length!==e.length)throw new Error("Transceivers' length doesn't match mids' length.");t.map((async(e,t)=>{e.direction="sendonly";}));const i=await this.peerConnection.createOffer(),n=this.logSDPExchange(i.sdp||"","offer","local","unmuteLocal");await this.peerConnection.setLocalDescription(i),this.remoteSDP.unmuteRemote(e);const r=this.remoteSDP.toString();null==n||n(r),await this.peerConnection.setRemoteDescription({type:"answer",sdp:r});}catch(e){throw new Vg(xg.EXCHANGE_SDP_FAILED,"P2PConnection.unmuteLocal failed; ".concat(e.toString()))}}restartICE(e){var t=this;return BP((function*(){const i=yield jP(t.mutex.lock("From P2PConnection.restartICE"));try{if(!t.remoteSDP)throw new Error("Cannot restartICE before remoteSDP created.");if(_A().supportPCSetConfiguration){const i=t.peerConnection.getConfiguration(),n=e===uI.RELAY?"relay":"all";i.iceTransportPolicy!==n&&(KC.debug("[".concat(t.store.clientId,"] restartICE change iceTransportPolicy from [").concat(i.iceTransportPolicy,"] to [").concat(n,"]")),i.iceTransportPolicy=n,t.peerConnection.setConfiguration(i));}else if(e===uI.RELAY)return;t.remoteSDP.updateCandidates(e);const n=yield jP(t.peerConnection.createOffer({iceRestart:!0}));if(!n.sdp)throw new Error("Cannot restartICE because restart offer SDP does not exist.");const r=zP(n.sdp),{remoteIceParameters:s}=yield r.iceParameters;t.remoteSDP.restartICE(s);const o=t.remoteSDP.toString(),a=t.logSDPExchange(n.sdp||"","offer","local","restartICE");t.store.descriptionStart(),yield jP(t.peerConnection.setLocalDescription(n)),null==a||a(o),yield jP(t.peerConnection.setRemoteDescription({type:"answer",sdp:o}));}catch(e){KC.warning("[".concat(t.store.clientId,"] restart ICE failed, abort operation"),e);}finally{i();}}))()}close(){var e;this.peerConnection.close(),null===(e=this.onConnectionStateChange)||void 0===e||e.call(this,"closed"),this.tryUnbindTransportEvents(),this.unbindPCEvents(),this.unbindStatsEvents(),this.removeAllListeners(),this.transportEventReceiver=void 0,this.statsFilter.destroy(),this.dataStreamChannelMap.clear();}getStats(){return this.statsFilter.getStats()}getRemoteVideoIsReady(e){return this.statsFilter.getVideoIsReady(e)}async updateEncoderConfig(e,t){try{if(!this.remoteSDP)throw new Error("Cannot call P2PConnection.updateEncoderConfig before remote SDP created.");const i=await this.peerConnection.createOffer(),n=this.mungSendOfferSDP(i.sdp,[t],[e]);this.remoteSDP.updateRecvMedia(e,t);const r=this.remoteSDP.toString(),s=this.logSDPExchange(n,"offer","local","updateEncoderConfig");await this.peerConnection.setLocalDescription({type:"offer",sdp:n}),null==s||s(r),await this.peerConnection.setRemoteDescription({type:"answer",sdp:r});}catch(e){throw new Vg(xg.EXCHANGE_SDP_FAILED,e.toString())}}async updateSendParameters(e,t){const i=this.peerConnection.getTransceivers().filter((t=>t.mid===e));1===i.length&&(this.isVP8Simulcast(t)?Rg()||await this.applySimulcastEncodings(i,[t]):await this.applySendEncodings(i,[t]));}setStatsRemoteVideoIsReady(e,t){this.statsFilter.setVideoIsReady2(e,t);}async replaceTrack(e,t){const i=this.peerConnection.getTransceivers().find((e=>e.mid===t));i&&await i.sender.replaceTrack(e._mediaStreamTrack);}async getSelectedCandidatePair(){const e=this.peerConnection.getReceivers();if(e.length>0&&e[0].transport&&e[0].transport.iceTransport&&e[0].transport.iceTransport.getSelectedCandidatePair&&e[0].transport.iceTransport.getSelectedCandidatePair()){const t=e[0].transport.iceTransport,{local:i,remote:n}=t.getSelectedCandidatePair();return {local:GL(GL({},mL),{},{candidateType:i.type,protocol:i.protocol,address:i.address,port:i.port}),remote:GL(GL({},mL),{},{candidateType:n.type,protocol:n.protocol,address:n.address,port:n.port})}}return this.statsFilter.getSelectedCandidatePair()}bindPCEvents(){this.peerConnection.oniceconnectionstatechange=()=>{var e;null===(e=this.onICEConnectionStateChange)||void 0===e||e.call(this,this.peerConnection.iceConnectionState);},this.peerConnection.onconnectionstatechange=()=>{var e;null===(e=this.onConnectionStateChange)||void 0===e||e.call(this,this.peerConnection.connectionState);},this.peerConnection.onicecandidate=e=>{e.candidate?this.localCandidateCount+=1:(this.peerConnection.onicecandidate=null,this.allCandidatesReceived=!0,KC.debug("[".concat(this.store.clientId,"] [pc-").concat(this.store.p2pId,"] local candidate count"),this.localCandidateCount));},setTimeout((()=>{this.allCandidatesReceived||(this.allCandidatesReceived=!0,KC.debug("[".concat(this.store.clientId,"] [pc-").concat(this.store.p2pId,"] onicecandidate timeout, local candidate count"),this.localCandidateCount));}),kC("CANDIDATE_TIMEOUT"));}unbindPCEvents(){this.peerConnection.oniceconnectionstatechange=null,this.peerConnection.onconnectionstatechange=null,this.peerConnection.onsignalingstatechange=null,this.peerConnection.onicecandidateerror=null,this.peerConnection.onicecandidate=null,this.peerConnection.ontrack=null;}static resolvePCConfiguration(t){const i={iceServers:[]};return t.iceServers?i.iceServers=t.iceServers:t.turnServer&&"off"!==t.turnServer.mode&&(_T(t.turnServer.servers)?i.iceServers=t.turnServer.servers:(i.iceServers&&i.iceServers.push(...e.turnServerConfigToIceServers(t.turnServer.servers)),kC("USE_TURN_SERVER_OF_GATEWAY")&&i.iceServers&&t.turnServer.serversFromGateway&&i.iceServers.push(...e.turnServerConfigToIceServers(t.turnServer.serversFromGateway)),kC("FORCE_TURN_TCP")?i.iceTransportPolicy="relay":t.turnServer.servers.concat(t.turnServer.serversFromGateway||[]).forEach((e=>{e.forceturn&&(i.iceTransportPolicy="relay");})))),kC("ENABLE_ENCODED_TRANSFORM")&&_A().supportWebRTCEncodedTransform&&(i.encodedInsertableStreams=!0),i}static turnServerConfigToIceServers(e){const t=[];return e.forEach((e=>{e.security?e.tcpport&&t.push({username:e.username,credential:e.password,credentialType:"password",urls:"turns:".concat(_D(e.turnServerURL),":").concat(e.tcpport,"?transport=tcp")}):(e.udpport&&!kC("FORCE_TURN_TCP")&&t.push({username:e.username,credential:e.password,credentialType:"password",urls:"turn:".concat(e.turnServerURL,":").concat(e.udpport,"?transport=udp")}),e.tcpport&&t.push({username:e.username,credential:e.password,credentialType:"password",urls:"turn:".concat(e.turnServerURL,":").concat(e.tcpport,"?transport=tcp")}));})),t}tryBindTransportEvents(e){const t=e.transport;if(t){this.transportEventReceiver=e,t.onstatechange=()=>{var e;null!=t&&t.state&&(null===(e=this.onDTLSTransportStateChange)||void 0===e||e.call(this,t.state));},t.onerror=e=>{var t;null===(t=this.onDTLSTransportError)||void 0===t||t.call(this,"error"in e?e.error:e);};const i=t.iceTransport;i&&(i.onstatechange=()=>{const e=null==t?void 0:t.iceTransport.state;var i;e&&(null===(i=this.onICETransportStateChange)||void 0===i||i.call(this,e));},i.getSelectedCandidatePair&&(i.onselectedcandidatepairchange=()=>{if(i.getSelectedCandidatePair()){const{local:e,remote:t}=i.getSelectedCandidatePair();KC.info("[".concat(this.store.clientId,"] [pc-").concat(this.store.p2pId,"] selectedcandidatepairchange: local ").concat(JSON.stringify({candidateType:e.type,protocol:e.protocol}),", remote ").concat(JSON.stringify({candidateType:t.type,protocol:t.protocol,address:t.address,port:t.port})," )"));}}));}}tryUnbindTransportEvents(){this.transportEventReceiver&&this.transportEventReceiver.transport&&(this.transportEventReceiver.transport.onstatechange=null,this.transportEventReceiver.transport.onerror=null,this.transportEventReceiver.transport.iceTransport&&(this.transportEventReceiver.transport.iceTransport.onstatechange=null));}async updateRtpSenderEncodings(e,t){var i;if(!t){t=this.peerConnection.getSenders().find((t=>t.track===e._mediaStreamTrack));}if(!t)return KC.warn("[".concat(e.getTrackId(),"] no rtpSender found}"));if(this.isVP8Simulcast(e))return KC.warn("[updateRtpSenderEncodings] Track is VP8 simulcast, please apply simulcast encodings");if(!_A().supportSetRtpSenderParameters)return KC.warn("[updateRtpSenderEncodings] Browser not support set rtp-sender parameters");const n={},r={};switch(e._optimizationMode){case"motion":n.degradationPreference="maintain-framerate";break;case"detail":n.degradationPreference="maintain-resolution";break;default:n.degradationPreference="balanced";}if(e._encoderConfig){var s;const{bitrateMax:t,frameRate:i,scaleResolutionDownBy:n}=e._encoderConfig;t&&(r.maxBitrate=1e3*t),(Pr(s=e._hints).call(s,ky.LOW_STREAM)||e.isUseScaleResolutionDownBy)&&(i&&(r.maxFramerate=mD(i)),n&&n>=1&&(r.scaleResolutionDownBy=n));}if(kC("DSCP_TYPE")&&kg()){var o;const e=kC("DSCP_TYPE");Pr(o=["very-low","low","medium","high"]).call(o,e)&&(r.networkPriority=e);}const a=t.getParameters(),c=null===(i=a.encodings)||void 0===i?void 0:i[0];Rg()&&!c&&(n.encodings=[r]),c&&Object.assign(c,r),Object.assign(a,n),KC.debug("[".concat(e.getTrackId(),"] updateRtpSenderEncodings: ").concat(JSON.stringify(a.encodings))),await t.setParameters(a);}async applySendEncodings(e,t){try{if(!_A().supportSetRtpSenderParameters)return;if(e.length!==t.length)return;for(let i=0;i<e.length;i++){const n=e[i],r=t[i];r instanceof Sb&&!this.isVP8Simulcast(r)&&await this.updateRtpSenderEncodings(r,n.sender);}}catch(e){KC.debug("[".concat(this.store.clientId,"] Apply RTPSendEncodings failed."));}}mungSendOfferSDP(e,t,i){const n=KP.parse(e);return t.forEach(((e,t)=>{const r=i[t],s=n.mediaDescriptions.find((e=>e.attributes.mid===r));s&&($P(s,e),rL(s,e,this.store.codec));})),KP.print(n)}mungReceiveAnswerSDP(e,t,i){const n=KP.parse(e),r=n.mediaDescriptions.find((e=>e.attributes.mid===t));return r&&(i===hI.AUDIO&&"audio"===r.media.mediaType&&cL(r),this.useXR&&dL(n)),KP.print(n)}bindStatsEvents(){this.statsFilter.onFirstAudioReceived=e=>{var t;null===(t=this.onFirstAudioReceived)||void 0===t||t.call(this,e);},this.statsFilter.onFirstVideoReceived=e=>{var t;null===(t=this.onFirstVideoReceived)||void 0===t||t.call(this,e);},this.statsFilter.onFirstAudioDecoded=e=>{var t;null===(t=this.onFirstAudioDecoded)||void 0===t||t.call(this,e);},this.statsFilter.onFirstVideoDecoded=(e,t,i)=>{var n;null===(n=this.onFirstVideoDecoded)||void 0===n||n.call(this,e,t,i);},this.statsFilter.onSelectedLocalCandidateChanged=(e,t)=>{var i;null===(i=this.onSelectedLocalCandidateChanged)||void 0===i||i.call(this,e,t);},this.statsFilter.onSelectedRemoteCandidateChanged=(e,t)=>{var i;null===(i=this.onSelectedRemoteCandidateChanged)||void 0===i||i.call(this,e,t);},this.statsFilter.onFirstVideoDecodedTimeout=e=>{var t;null===(t=this.onFirstVideoDecodedTimeout)||void 0===t||t.call(this,e);};}unbindStatsEvents(){this.statsFilter.onFirstAudioReceived=void 0,this.statsFilter.onFirstVideoReceived=void 0,this.statsFilter.onFirstAudioDecoded=void 0,this.statsFilter.onFirstVideoDecoded=void 0,this.statsFilter.onSelectedLocalCandidateChanged=void 0,this.statsFilter.onSelectedRemoteCandidateChanged=void 0,this.statsFilter.onFirstVideoDecodedTimeout=void 0;}async applySimulcastForFirefox(e,t){if(e.length===t.length)for(let a=0;a<e.length;a++){var i,n,r,s,o;const c=e[a],d=t[a];if(d instanceof Sb&&!Pr(i=d._hints).call(i,ky.LOW_STREAM)&&null!==(n=d._encoderConfig)&&void 0!==n&&n.bitrateMax&&(null===(r=d._encoderConfig)||void 0===r?void 0:r.bitrateMax)>200&&null!==(s=d._scalabilityMode)&&void 0!==s&&s.numSpatialLayers&&(null===(o=d._scalabilityMode)||void 0===o?void 0:o.numSpatialLayers)>1&&"vp8"===this.store.codec){const e={},t={high:1e3*(d._encoderConfig.bitrateMax-50),medium:5e4};e.encodings=[{rid:"m",active:!0,maxBitrate:t.medium,scaleResolutionDownBy:4},{rid:"h",active:!0,maxBitrate:t.high}];const i=c.sender.getParameters();await c.sender.setParameters(Object.assign(i,e));}}}async applySimulcastEncodings(e,t){if(!Rg()&&e.length===t.length)for(let i=0;i<e.length;i++){const n=t[i];if(n instanceof Sb&&this.isVP8Simulcast(n)){const t=e[i],r={},s={high:1e3*(n._encoderConfig.bitrateMax-50),medium:5e4};r.encodings=[{active:!0,adaptivePtime:!1,networkPriority:"high",priority:"high",maxBitrate:s.high},{active:!0,adaptivePtime:!1,networkPriority:"low",priority:"low",maxBitrate:s.medium,scaleResolutionDownBy:4}];const o=t.sender.getParameters();await t.sender.setParameters(Object.assign(o,r));}}}isVP8Simulcast(e){var t,i,n,r,s;return !!(e instanceof Sb&&kC("SIMULCAST")&&"vp8"===this.store.codec&&!Pr(t=e._hints).call(t,ky.LOW_STREAM)&&null!==(i=e._encoderConfig)&&void 0!==i&&i.bitrateMax&&(null===(n=e._encoderConfig)||void 0===n?void 0:n.bitrateMax)>200&&null!==(r=e._scalabilityMode)&&void 0!==r&&r.numSpatialLayers&&(null===(s=e._scalabilityMode)||void 0===s?void 0:s.numSpatialLayers)>1)}logSDPExchange(e,t,i,n){if(kC("SDP_LOGGING"))return KC.upload("[".concat(this.store.clientId,"] exchanging ").concat(i," ").concat(t," SDP during P2PConnection.").concat(n,"\n"),e),"offer"===t?e=>{this.logSDPExchange(e,"answer","local"===i?"remote":"local",n);}:void 0}async getRemoteSSRC(e){if(!this.remoteSDP)return;const t=this.remoteSDP.getSSRC(e);return null==t?void 0:t[0].ssrcId}setConfiguration(t){if(_A().supportPCSetConfiguration){const i=e.resolvePCConfiguration(t);this.peerConnection.setConfiguration(i);}}};function HL(e,t,i){const n=e[t];if("function"!=typeof n)throw new Error("Cannot use mutex on object property.");return i.value=async function(){const e=this.mutex,i=await e.lock("From P2PConnection.".concat(t));try{for(var r=arguments.length,s=new Array(r),o=0;o<r;o++)s[o]=arguments[o];return await n.apply(this,s)}finally{i();}},i}function KL(e,t){let i=document.createElement("video"),n=document.createElement("canvas");i.setAttribute("style","display:none"),n.setAttribute("style","display:none"),i.setAttribute("muted",""),i.muted=!0,i.setAttribute("autoplay",""),i.autoplay=!0,i.setAttribute("playsinline",""),n.width=mD(t.width),n.height=mD(t.height);const r=mD(t.framerate||15);document.body.append(i),document.body.append(n);let s=e._mediaStreamTrack;i.srcObject=new MediaStream([s]),i.play();const o=n.getContext("2d");if(!o)throw new xv(xg.UNEXPECTED_ERROR,"can not get canvas context");const a=_A(),c=n.captureStream(a.supportRequestFrame?0:r).getVideoTracks()[0];c.canvas||(c.canvas=n),n.startCapture=()=>{if(!i)return n.stopCapture&&n.stopCapture();if(i.paused&&i.play(),i.videoHeight>2&&i.videoWidth>2){const e=i.videoWidth,t=i.videoHeight/e,r=n.width*t;Math.abs(r-n.height)>=2&&(KC.debug("adjust low stream resolution","".concat(n.width,"x").concat(n.height," -> ").concat(n.width,"x").concat(r)),n.height=r);}o.drawImage(i,0,0,n.width,n.height),c.requestFrame&&c.requestFrame(),s!==e._mediaStreamTrack&&(s=e._mediaStreamTrack,i.srcObject=new MediaStream([s]));},n.stopCapture=uA((()=>n.startCapture&&n.startCapture()),r);const d=c.stop;return c.stop=()=>{d.call(c),i&&(i.remove(),i.srcObject=null,i=null),n&&(n.width=0,n.remove(),n.stopCapture&&n.stopCapture(),n.startCapture=void 0,n.stopCapture=void 0,n=null),KC.debug("clean low stream renderer");},c}function YL(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n);}return i}function qL(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?YL(Object(i),!0).forEach((function(t){nu(e,t,i[t]);})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):YL(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t));}));}return e}Mv([HL,Uv("design:type",Function),Uv("design:paramtypes",[Array,Array]),Uv("design:returntype",tg)],WL.prototype,"updateRemoteRTPCapabilities",null),Mv([HL,Uv("design:type",Function),Uv("design:paramtypes",[Object,Object,Array,Object,String,String]),Uv("design:returntype",tg)],WL.prototype,"connect",null),Mv([HL,Uv("design:type",Function),Uv("design:paramtypes",[Object,Array]),Uv("design:returntype",tg)],WL.prototype,"createDataChannels",null),Mv([HL,Uv("design:type",Function),Uv("design:paramtypes",[String,Array,String,Object]),Uv("design:returntype",tg)],WL.prototype,"receive",null),Mv([HL,Uv("design:type",Function),Uv("design:paramtypes",[Array]),Uv("design:returntype",tg)],WL.prototype,"batchReceive",null),Mv([HL,Uv("design:type",Function),Uv("design:paramtypes",[Array]),Uv("design:returntype",tg)],WL.prototype,"stopReceiving",null),Mv([HL,Uv("design:type",Function),Uv("design:paramtypes",[String]),Uv("design:returntype",tg)],WL.prototype,"muteRemote",null),Mv([HL,Uv("design:type",Function),Uv("design:paramtypes",[String]),Uv("design:returntype",tg)],WL.prototype,"unmuteRemote",null),Mv([HL,Uv("design:type",Function),Uv("design:paramtypes",[Array]),Uv("design:returntype",tg)],WL.prototype,"muteLocal",null),Mv([HL,Uv("design:type",Function),Uv("design:paramtypes",[Array]),Uv("design:returntype",tg)],WL.prototype,"unmuteLocal",null),Mv([HL,Uv("design:type",Function),Uv("design:paramtypes",[]),Uv("design:returntype",void 0)],WL.prototype,"close",null),Mv([HL,Uv("design:type",Function),Uv("design:paramtypes",[String,iA]),Uv("design:returntype",tg)],WL.prototype,"updateEncoderConfig",null),Mv([HL,Uv("design:type",Function),Uv("design:paramtypes",[String,iA]),Uv("design:returntype",tg)],WL.prototype,"updateSendParameters",null),Mv([HL,Uv("design:type",Function),Uv("design:paramtypes",[iA,String]),Uv("design:returntype",tg)],WL.prototype,"replaceTrack",null),Mv([HL,Uv("design:type",Function),Uv("design:paramtypes",[String]),Uv("design:returntype",tg)],WL.prototype,"getRemoteSSRC",null);const JL="v=0\no=- 0 0 IN IP4 127.0.0.1\ns=AgoraGateway\nt=0 0\na=group:BUNDLE 0\na=msid-semantic: WMS\na=ice-lite\nm=application 9 UDP/DTLS/SCTP webrtc-datachannel\nc=IN IP4 127.0.0.1\na=mid:0\n",zL="9",XL=2e4,QL=4e4;class ZL{get localCapabilities(){return bT(this._localCapabilities)}get rtpCapabilities(){return bT(this._rtpCapabilities)}get candidates(){return bT(this._candidates)}get iceParameters(){return bT(this._iceParameters)}get dtlsParameters(){return bT(this._dtlsParameters)}constructor(e){nu(this,"sessionDesc",void 0),nu(this,"_localCapabilities",void 0),nu(this,"_rtpCapabilities",void 0),nu(this,"_candidates",void 0),nu(this,"_iceParameters",void 0),nu(this,"_dtlsParameters",void 0),nu(this,"setup",void 0),nu(this,"currentMidIndex",void 0),nu(this,"cname",void 0),nu(this,"firefoxSsrcMidMap",new Map),e=bT(e);const{remoteIceParameters:t,remoteDtlsParameters:i,candidates:n,remoteRTPCapabilities:r,remoteSetup:s,localCapabilities:o,cname:a}=e,c=KP.parse(JL);this._rtpCapabilities=r,this._candidates=n,this._iceParameters=t,this._dtlsParameters=i,this._localCapabilities=o,this.setup=s,this.cname=a;const d=this.rtpCapabilities.send;for(const e of c.mediaDescriptions){if(e.attributes.iceUfrag=t.iceUfrag,e.attributes.icePwd=t.icePwd,e.attributes.fingerprints=i.fingerprints,e.attributes.candidates=n,e.attributes.setup=s,"application"===e.media.mediaType&&(e.attributes.sctpPort="5000"),"video"===e.media.mediaType&&(e.media.fmts=d.videoCodecs.map((e=>e.payloadType.toString(10))),e.attributes.payloads=d.videoCodecs,e.attributes.extmaps=d.videoExtensions,kC("PRELOAD_MEDIA_COUNT")>0)){const{ssrcs:t,ssrcGroups:i}=ZP([{ssrcId:QL,rtx:kC("USE_SUB_RTX")?40001:void 0}],this.cname);e.attributes.ssrcs=t,e.attributes.ssrcGroups=i;}if("audio"===e.media.mediaType&&(e.media.fmts=d.audioCodecs.map((e=>e.payloadType.toString(10))),e.attributes.payloads=d.audioCodecs,e.attributes.extmaps=d.audioExtensions,cL(e),kC("PRELOAD_MEDIA_COUNT")>0)){const{ssrcs:t,ssrcGroups:i}=ZP([{ssrcId:XL}],this.cname);e.attributes.ssrcs=t,e.attributes.ssrcGroups=i;}}this.sessionDesc=c,this.currentMidIndex=c.mediaDescriptions.length-1;}updateRemoteRTPCapabilities(e){const t=KP.parse(JL);this._rtpCapabilities=e;const i=this.rtpCapabilities.send;for(const e of t.mediaDescriptions){if(e.attributes.iceUfrag=this._iceParameters.iceUfrag,e.attributes.icePwd=this._iceParameters.icePwd,e.attributes.fingerprints=this._dtlsParameters.fingerprints,e.attributes.candidates=this._candidates,e.attributes.setup=this.setup,"application"===e.media.mediaType&&(e.attributes.sctpPort="5000"),"video"===e.media.mediaType&&(e.media.fmts=i.videoCodecs.map((e=>e.payloadType.toString(10))),e.attributes.payloads=i.videoCodecs,e.attributes.extmaps=i.videoExtensions,kC("PRELOAD_MEDIA_COUNT")>0)){const{ssrcs:t,ssrcGroups:i}=ZP([{ssrcId:QL,rtx:kC("USE_SUB_RTX")?40001:void 0}],this.cname);e.attributes.ssrcs=t,e.attributes.ssrcGroups=i;}if("audio"===e.media.mediaType&&(e.media.fmts=i.audioCodecs.map((e=>e.payloadType.toString(10))),e.attributes.payloads=i.audioCodecs,e.attributes.extmaps=i.audioExtensions,kC("PRELOAD_MEDIA_COUNT")>0)){const{ssrcs:t,ssrcGroups:i}=ZP([{ssrcId:XL}],this.cname);e.attributes.ssrcs=t,e.attributes.ssrcGroups=i;}}this.sessionDesc=t,this.currentMidIndex=t.mediaDescriptions.length-1;}preloadRemoteMedia(e){this.rtpCapabilities;const t=this.candidates,i=this.dtlsParameters,n=this.iceParameters,r=this.rtpCapabilities.send;for(let s=1;s<e;s++){const e=2*s+XL,o=2*s+QL,{ssrcs:a,ssrcGroups:c}=ZP([{ssrcId:e}],this.cname),{ssrcs:d,ssrcGroups:l}=ZP([{ssrcId:o,rtx:kC("USE_SUB_RTX")?o+1:void 0}],this.cname);this.sessionDesc.mediaDescriptions.push({media:{mediaType:"video",port:zL,protos:["UDP","TLS","RTP","SAVPF"],fmts:r.videoCodecs.map((e=>e.payloadType.toString(10)))},connections:[{nettype:"IN",addrtype:"IP4",address:"127.0.0.1"}],bandwidths:[],attributes:{iceUfrag:n.iceUfrag,icePwd:n.icePwd,unrecognized:[],candidates:t,extmaps:r.videoExtensions,fingerprints:i.fingerprints,imageattr:[],msids:[],remoteCandidatesList:[],rids:[],ssrcs:d,ssrcGroups:l,rtcpFeedbackWildcards:[],payloads:r.videoCodecs,rtcp:{port:"9",netType:"IN",addressType:"IP4",address:"0.0.0.0"},setup:this.setup,direction:"sendonly",rtcpMux:!0,rtcpRsize:!0,mid:"".concat(2*s-1)}}),this.sessionDesc.mediaDescriptions.push({media:{mediaType:"audio",port:zL,protos:["UDP","TLS","RTP","SAVPF"],fmts:r.audioCodecs.map((e=>e.payloadType.toString(10)))},connections:[{nettype:"IN",addrtype:"IP4",address:"127.0.0.1"}],bandwidths:[],attributes:{iceUfrag:n.iceUfrag,icePwd:n.icePwd,unrecognized:[],candidates:t,extmaps:r.audioExtensions,fingerprints:i.fingerprints,imageattr:[],msids:[],remoteCandidatesList:[],rids:[],ssrcs:a,ssrcGroups:c,rtcpFeedbackWildcards:[],payloads:r.audioCodecs,rtcp:{port:"9",netType:"IN",addressType:"IP4",address:"0.0.0.0"},setup:this.setup,direction:"sendonly",rtcpMux:!0,rtcpRsize:!0,mid:"".concat(2*s)}}),this.currentMidIndex+=2;}this.updateBundleMids();}toString(){return KP.print(this.sessionDesc)}send(e,t,i,n){const{ssrcs:r,ssrcGroups:s}=ZP(t,this.cname,kC("SYNC_GROUP")?i:void 0),o=this.findPreloadMediaDesc(r);if(o){if(Rg()&&this.firefoxSsrcMidMap.set(r[0].ssrcId,o.attributes.mid),n&&(n.twcc||n.remb)){const e=this.sessionDesc.mediaDescriptions.indexOf(o);return this.sessionDesc.mediaDescriptions[e]=this.mungSendMediaDesc(o,n),{mid:o.attributes.mid,needExchangeSDP:!0}}return {mid:o.attributes.mid,needExchangeSDP:!1}}{const t=this.findAvailableMediaIndex(e,r);let i;return -1===t||Sg()||Cg()||Ag()||0===t&&kC("USE_SUB_RTX")?(i=this.createOrRecycleSendMedia(e,r,s,"sendonly",n),this.updateBundleMids()):(i=bT(this.sessionDesc.mediaDescriptions[t]),i.attributes.direction="sendonly",i.attributes.ssrcs=r,i.attributes.ssrcGroups=s,this.sessionDesc.mediaDescriptions[t]=this.mungSendMediaDesc(i,n)),Rg()&&this.firefoxSsrcMidMap.set(r[0].ssrcId,i.attributes.mid),{mid:i.attributes.mid,needExchangeSDP:!0}}}batchSend(e){const t=e.map((e=>{let{kind:t,ssrcMsg:i,mslabel:n}=e;return this.send(t,i,n)})),i=[];let n=!1;return t.forEach((e=>{let{mid:t,needExchangeSDP:r}=e;r&&(n=!0),i.push(t);})),{mids:i,needExchangeSDP:n}}stopSending(e){const t=this.sessionDesc.mediaDescriptions.filter((t=>t.attributes.mid&&-1!==e.indexOf(t.attributes.mid)));if(t.length!==e.length)throw new Error("mediaDescriptions' length doesn't match mids' length when calling RemoteSDP.stopSending.");t.forEach((e=>{"0"===e.attributes.mid||Rg()||Sg()||Cg()?e.attributes.ssrcs=[]:(e.attributes.ssrcs=[],e.attributes.direction="inactive",e.media.port="0");})),this.updateBundleMids();}mute(e){const t=this.sessionDesc.mediaDescriptions.find((t=>t.attributes.mid===e));if(!t)throw new Error("mediaDescription not found with ".concat(e," in remote SDP when calling RemoteSDP.mute."));t.attributes.direction="inactive";}unmute(e){const t=this.sessionDesc.mediaDescriptions.find((t=>t.attributes.mid===e));if(!t)throw new Error("mediaDescription not found with ".concat(e," in remote SDP when calling RemoteSDP.unmute."));t.attributes.direction="sendonly";}muteRemote(e){const t=this.sessionDesc.mediaDescriptions.filter((t=>Pr(e).call(e,t.attributes.mid||"")));if(t.length!==e.length)throw new Error("mediaDescriptions' length doesn't match mids' length when calling RemoteSDP.muteRemote.");t.forEach((e=>{e.attributes.direction="inactive";}));}unmuteRemote(e){const t=this.sessionDesc.mediaDescriptions.filter((t=>Pr(e).call(e,t.attributes.mid||"")));if(t.length!==e.length)throw new Error("mediaDescriptions' length doesn't match mids' length when calling RemoteSDP.muteRemote.");t.forEach((e=>{e.attributes.direction="recvonly";}));}receive(e,t,i,n){e.forEach(((e,r)=>{this.createOrRecycleRecvMedia(e,[],"recvonly",t,i,n[r]);})),this.updateBundleMids();}stopReceiving(e){const t=this.sessionDesc.mediaDescriptions.filter((t=>-1!==e.indexOf(t.attributes.mid)));if(t.length!==e.length)throw new Error("MediaDescriptions' length doesn't match mids's length when calling RemoteSDP.receive.");t.forEach((e=>{e.media.port="0",e.attributes.direction="inactive";})),this.updateBundleMids();}updateCandidates(e){e===uI.TCP?this._candidates.forEach((e=>{-1===this._candidates.findIndex((t=>"tcp"===t.transport&&t.connectionAddress===e.connectionAddress&&t.port===e.port))&&this._candidates.push(qL(qL({},e),{},{foundation:"tcpcandidate",priority:Number(e.priority)-1+"",transport:"tcp",port:Number(e.port)+90+""}));})):this._candidates=this._candidates.filter((e=>"tcp"!==e.transport));for(const e of this.sessionDesc.mediaDescriptions)e.attributes.candidates=this.candidates;}restartICE(e){e=bT(e),this._iceParameters=e,this.sessionDesc.mediaDescriptions.forEach((t=>{t.attributes.iceUfrag=e.iceUfrag,t.attributes.icePwd=e.icePwd;}));}predictReceivingMids(e){const t=[];for(let i=0;i<e;i++)t.push((this.currentMidIndex+i+1).toString(10));return t}findAvailableMediaIndex(e,t){return this.sessionDesc.mediaDescriptions.findIndex((i=>{const n=i.media.mediaType===e&&"0"!==i.media.port&&("sendonly"===i.attributes.direction||"sendrecv"===i.attributes.direction)&&0===i.attributes.ssrcs.length;if(Rg()){if(n){const e=this.firefoxSsrcMidMap.get(t[0].ssrcId);return !(e||"0"!==i.attributes.mid&&"1"!==i.attributes.mid)||!(!e||e!==i.attributes.mid)}return !1}return n}))}createOrRecycleRecvMedia(e,t,i,n,r,s){const o=e._mediaStreamTrack.kind,a=this.rtpCapabilities.recv,c=lL(o,a,this.localCapabilities.send,o===hI.VIDEO?n:r),d=o===hI.VIDEO?a.videoExtensions:a.audioExtensions;this.currentMidIndex+=1;const l="".concat(this.currentMidIndex);let h={media:{mediaType:o,port:zL,protos:["UDP","TLS","RTP","SAVPF"],fmts:c.map((e=>e.payloadType.toString(10)))},connections:[{nettype:"IN",addrtype:"IP4",address:"127.0.0.1"}],bandwidths:[],attributes:{iceUfrag:this.iceParameters.iceUfrag,icePwd:this.iceParameters.icePwd,unrecognized:[],candidates:this.candidates,extmaps:d,fingerprints:this.dtlsParameters.fingerprints,imageattr:[],msids:[],remoteCandidatesList:[],rids:[],ssrcs:t,ssrcGroups:[],rtcpFeedbackWildcards:[],payloads:c,rtcp:{port:"9",netType:"IN",addressType:"IP4",address:"0.0.0.0"},setup:this.setup,direction:i,rtcpMux:!0,rtcpRsize:!0,mid:"".concat(l)}};h=this.mungRecvMediaDsec(h,e,s);const u=this.findFirstClosedMedia(o);if(u){const e=this.sessionDesc.mediaDescriptions.indexOf(u);this.sessionDesc.mediaDescriptions[e]=h;}else this.sessionDesc.mediaDescriptions.push(h);return h}updateRemoteCodec(e,t,i){const n=[...new Set(this._rtpCapabilities.recv.videoCodecs.map((e=>e.rtpMap&&e.rtpMap.encodingName.toLowerCase()||"")).filter((e=>{var t;return Pr(t=Object.keys(UC)).call(t,e)})))],r=new Set(t);if(n.every((e=>r.has(e))))return KC.debug("codecs has not changed, no need to updateRemoteCodec, codecs: ".concat(t)),!1;const s=this._rtpCapabilities.recv.videoCodecs.filter((e=>t.some((t=>{var i;return Pr(i=e.rtpMap&&e.rtpMap.encodingName.toLowerCase()||"").call(i,t)}))));if(0===s.length)return KC.debug("updateRemoteCodec failed, because cannot find matched codec, remoteCapabilities codecs: ".concat(n," codecs: ").concat(t)),!1;const o=[...new Set(s.map((e=>e.rtpMap&&e.rtpMap.encodingName.toLowerCase()||"")))];let a;if(KC.debug("updateRemoteCodec, from ".concat(n," to ").concat(o)),0===e.length)a=this.sessionDesc.mediaDescriptions.filter((e=>"video"===e.media.mediaType&&"recvonly"===e.attributes.direction));else if(a=this.sessionDesc.mediaDescriptions.filter((t=>t.attributes.mid&&Pr(e).call(e,t.attributes.mid)&&"recvonly"===t.attributes.direction)),a.length!==e.length)return KC.debug("updateRemoteCodec failed, because cannot find mids, mids: ".concat(e,", codecs: ").concat(t)),!1;this._rtpCapabilities.recv.videoCodecs=s;const c=this.localCapabilities.send,d=this.rtpCapabilities.recv,l=lL(hI.VIDEO,d,c,i);return a.forEach((e=>{const t=l.map((e=>e.payloadType.toString(10)));KC.debug("updateRemoteCodec mid: ".concat(e.attributes.mid,", from ").concat(e.attributes.payloads," to ").concat(l)),e.attributes.payloads=l,e.media.fmts=t;})),!0}createOrRecycleSendMedia(e,t,i,n,r){const s=this.rtpCapabilities.send,o=e===hI.VIDEO?s.videoCodecs:s.audioCodecs,a=e===hI.VIDEO?s.videoExtensions:s.audioExtensions;this.currentMidIndex+=1;const c="".concat(this.currentMidIndex);let d={media:{mediaType:e,port:zL,protos:["UDP","TLS","RTP","SAVPF"],fmts:o.map((e=>e.payloadType.toString(10)))},connections:[{nettype:"IN",addrtype:"IP4",address:"127.0.0.1"}],bandwidths:[],attributes:{iceUfrag:this.iceParameters.iceUfrag,icePwd:this.iceParameters.icePwd,unrecognized:[],candidates:this.candidates,extmaps:a,fingerprints:this.dtlsParameters.fingerprints,imageattr:[],msids:[],remoteCandidatesList:[],rids:[],ssrcs:t,ssrcGroups:i,rtcpFeedbackWildcards:[],payloads:o,rtcp:{port:"9",netType:"IN",addressType:"IP4",address:"0.0.0.0"},setup:this.setup,direction:n,rtcpMux:!0,rtcpRsize:!0,mid:"".concat(c)}};d=this.mungSendMediaDesc(d,r);const l=this.findFirstClosedMedia(e);if(l){const e=this.sessionDesc.mediaDescriptions.indexOf(l);this.sessionDesc.mediaDescriptions[e]=d;}else this.sessionDesc.mediaDescriptions.push(d);return d}updateBundleMids(){this.sessionDesc.attributes.groups[0].identificationTag=this.sessionDesc.mediaDescriptions.filter((e=>"0"!==e.media.port)).map((e=>e.attributes.mid));}mungRecvMediaDsec(e,t,i){const n=bT(e);return eL(n),$P(n,t),tL(n,t),iL(n),nL(n,i,this.localCapabilities.send),n}mungSendMediaDesc(e,t){const i=bT(e);return nL(i,t,this.localCapabilities.recv),cL(i),i}updateRecvMedia(e,t){const i=this.sessionDesc.mediaDescriptions.findIndex((t=>t.attributes.mid===e));if(-1!==i){const e=this.mungRecvMediaDsec(this.sessionDesc.mediaDescriptions[i],t);this.sessionDesc.mediaDescriptions[i]=e;}}bumpMid(e){this.currentMidIndex+=e;}findFirstClosedMedia(e){return this.sessionDesc.mediaDescriptions.find((t=>Rg()?"0"===t.media.port&&t.media.mediaType===e:"0"===t.media.port))}findPreloadMediaDesc(e){return this.sessionDesc.mediaDescriptions.find((t=>{var i;return (null===(i=t.attributes)||void 0===i||null===(i=i.ssrcs[0])||void 0===i?void 0:i.ssrcId)===e[0].ssrcId}))}getSSRC(e){var t;return null===(t=this.sessionDesc.mediaDescriptions.find((t=>t.attributes.mid===e)))||void 0===t?void 0:t.attributes.ssrcs}}function $L(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n);}return i}function ek(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?$L(Object(i),!0).forEach((function(t){nu(e,t,i[t]);})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):$L(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t));}));}return e}class tk extends PI{get currentLocalDescription(){return this.peerConnection.currentLocalDescription}get currentRemoteDescription(){return this.peerConnection.currentRemoteDescription}get peerConnectionState(){return this.peerConnection.connectionState}get iceConnectionState(){return this.peerConnection.iceConnectionState}constructor(e,t,i){super(e,t),nu(this,"store",void 0),nu(this,"peerConnection",void 0),nu(this,"remoteSDP",void 0),nu(this,"initialOffer",void 0),nu(this,"transportEventReceiver",void 0),nu(this,"statsFilter",void 0),nu(this,"useXR",kC("USE_XR")),nu(this,"localCapabilities",void 0),nu(this,"localCandidateCount",0),nu(this,"allCandidatesReceived",!1),nu(this,"remoteCodecs",void 0),nu(this,"dataStreamChannelMap",new Map),nu(this,"establishPromise",void 0),nu(this,"mutex",new YT("NVExtentionsConnection-mutex")),nu(this,"rtcMedia",void 0),this.store=t,this.peerConnection=i,this.statsFilter=PL(this.peerConnection,kC("STATS_UPDATE_INTERVAL"),void 0,Rg()?1200:void 0),this.bindPCEvents(),this.bindStatsEvents(),this.store.p2pId=this.store.p2pId+1,this.establishPromise=this.establish();}async establish(e){try{const e=await this.peerConnection.createOffer();if(!e.sdp)throw new Error("Cannot get initialOffer.sdp when trying to establish PeerConnection.");const t=zP(e.sdp),i=await sL({filterRTX:!kC("USE_PUB_RTX")&&!kC("USE_SUB_RTX"),filterVideoFec:kC("FILTER_VIDEO_FEC"),filterAudioFec:kC("FILTER_AUDIO_FEC"),filterVideoCodec:kC("FILTER_VIDEO_CODEC")},{useXR:this.useXR});return this.localCapabilities=i,this.initialOffer=e,ek(ek({},t),{},{rtpCapabilities:i,offerSDP:e.sdp})}catch(e){throw new xv(xg.GET_LOCAL_CONNECTION_PARAMS_FAILED,e.toString())}}async connect(e,t,i,n,r,s){try{if(!this.initialOffer)throw new Error("Cannot establish NVConnection without initial offer.");this.remoteSDP=new ZL({remoteIceParameters:e,remoteDtlsParameters:t,candidates:i,remoteRTPCapabilities:n,remoteSetup:r,localCapabilities:aL(this.localCapabilities),cname:s});const o=this.remoteSDP.toString(),a=KP.parse(this.initialOffer.sdp),c=a.mediaDescriptions.find((e=>"audio"===e.media.mediaType));c&&cL(c),this.useXR&&dL(a);const d=KP.print(a),l=this.logSDPExchange(d||"","offer","local","connect");await this.peerConnection.setLocalDescription({type:"offer",sdp:d}),null==l||l(o),await this.peerConnection.setRemoteDescription({type:"answer",sdp:o});}catch(e){throw new xv(xg.EXCHANGE_SDP_FAILED,"NV.connect failed; ".concat(e.toString()))}}async updateRemoteRTPCapabilities(e,t){let i;this.remoteCodecs=t,this.localCapabilities&&(i=aL(this.localCapabilities));const n=[...new Set(i&&i.send.videoCodecs.map((e=>e.rtpMap&&e.rtpMap.encodingName.toLowerCase()||"")).filter((e=>{var t;return Pr(t=Object.keys(UC)).call(t,e)})))];if(rv.updateRemoteRTPCapabilities(this.store.sessionId,{mids:e,localCodecs:n,remoteCodecs:this.remoteCodecs}),!this.remoteSDP)return void KC.debug("[P2PConnection] cannot updateRemoteRTPCapabilities before remote SDP created, local codecs: ".concat(n,", codecs: ").concat(t));if(this.remoteSDP.updateRemoteCodec(e,t,this.store.codec)){const e=await this.peerConnection.createOffer(),t=this.logSDPExchange(e.sdp||"","offer","local","muteLocal");await this.peerConnection.setLocalDescription(e);const i=this.remoteSDP.toString();null==t||t(i),await this.peerConnection.setRemoteDescription({type:"answer",sdp:i});}else KC.debug("[P2PConnection] updateRemoteRTPCapabilities no need to exchange SDP.");}async updateRemoteConnect(e){var t,i,n,r;(null===(t=this.remoteSDP)||void 0===t||t.updateRemoteRTPCapabilities(e),Array.isArray(this.remoteCodecs)&&this.remoteCodecs.length>0)&&(null===(r=this.remoteSDP)||void 0===r||r.updateRemoteCodec([],this.remoteCodecs,this.store.codec));null===(i=this.remoteSDP)||void 0===i||i.preloadRemoteMedia(2);const s=null===(n=this.remoteSDP)||void 0===n?void 0:n.toString();await this.peerConnection.setRemoteDescription({type:"offer",sdp:s});const o=await this.peerConnection.createAnswer();await this.peerConnection.setLocalDescription(o),KC.debug("[NVExtentionsConnection] updateRemoteRTPCapabilities by exchanging SDP.");}send(e,t,i){var n=this;return BP((function*(){const r=yield jP(n.mutex.lock("From NVExtentionsConnection.send"));try{if(!n.remoteSDP)throw new Error("Cannot call NVExtentionsConnection.send before remote SDP created");const s=[];e.forEach((e=>{const t=n.peerConnection.addTransceiver(e._mediaStreamTrack,{direction:"sendonly"});s.push(t);})),Rg()&&!0===kC("SIMULCAST")&&(yield jP(n.applySimulcastForFirefox(s,e)));const o=yield jP(n.peerConnection.createOffer()),a=n.remoteSDP.predictReceivingMids(e.length),c=n.mungSendOfferSDP(o.sdp,e,a),d=KP.parse(c),l=a.map((e=>{const t=d.mediaDescriptions.find((t=>t.attributes.mid===e));if(!t)throw new Error("Cannot extract ssrc from mediaDescription.");return XP(t,kC("USE_PUB_RTX"))}));let h;try{h=yield l;}catch(r){h=[],n.remoteSDP.receive(e,t,i,h);const s=n.remoteSDP.toString();throw yield jP(n.peerConnection.setLocalDescription({type:"offer",sdp:c})),yield jP(n.peerConnection.setRemoteDescription({type:"answer",sdp:s})),yield jP(n.stopSending(a,!0)),r}n.remoteSDP.receive(e,t,i,h);const u=n.remoteSDP.toString(),p=n.logSDPExchange(c,"offer","local","send");return yield jP(n.peerConnection.setLocalDescription({type:"offer",sdp:c})),yield jP(n.applySimulcastEncodings(s,e)),yield jP(n.applySendEncodings(s,e)),null==p||p(u),yield jP(n.peerConnection.setRemoteDescription({type:"answer",sdp:u})),s.map(((e,t)=>{const i=a[t];return {localSSRC:l[t],id:i,transceiver:e}}))}catch(e){throw e instanceof xv?e:new xv(xg.EXCHANGE_SDP_FAILED,"NVExtentionsConnection.send failed; ".concat(e.toString()))}finally{r();}}))()}async stopSending(e,t){const i=t?void 0:await this.mutex.lock("From NVExtentionsConnection.stopSending");try{if(!this.remoteSDP)throw new Error("Cannot call NVExtentionsConnection.stopSending before remote SDP created");const t=this.peerConnection.getTransceivers().filter((t=>-1!==e.indexOf(t.mid)));if(t.length!==e.length)throw new Error("Transceivers' length doesn't match mids' length when trying to call NVExtentionsConnection.stopSending.");t.map((e=>{var t;e.direction="inactive",null===(t=e.stop)||void 0===t||t.call(e);}));const n=await this.peerConnection.createOffer(),r=this.logSDPExchange(n.sdp||"","offer","local","stopSending");await this.peerConnection.setLocalDescription(n),this.remoteSDP.stopReceiving(e);const s=this.remoteSDP.toString();null==r||r(s),await this.peerConnection.setRemoteDescription({type:"answer",sdp:s});}catch(e){throw new xv(xg.EXCHANGE_SDP_FAILED,"NVExtentionsConnection.stopSending failed; ".concat(e.toString()))}finally{i&&i();}}async createDataChannels(e,t){try{if(!this.remoteSDP)throw new Error("Cannot call NVExtentionsConnection.createDataChannels before remote SDP created");let i=this.dataStreamChannelMap.get(e);return i&&"open"===i.readyState?KC.debug("[P2PConnection] Channels are already available and can be reused directly."):(i=this.peerConnection.createDataChannel("datastream-channel",{ordered:!1,maxRetransmits:kC("DATASTREAM_MAX_RETRANSMITS")}),i.binaryType="arraybuffer",this.dataStreamChannelMap.set(e,i)),void t.forEach((e=>{e._updateOriginDataChannel(i);}))}catch(e){throw e instanceof xv?e:new xv(xg.DATACHANNEL_FAILED,"NVExtentionsConnection.createDataChannels failed; ".concat(e.toString()))}}async stopDataChannels(e){try{const t=this.dataStreamChannelMap.get(e);return null==t||t.close(),void this.dataStreamChannelMap.delete(e)}catch(e){throw e instanceof xv?e:new xv(xg.DATACHANNEL_FAILED,"NVExtentionsConnection.stopDataChannels failed; ".concat(e.toString()))}}async receive(e,t,i,n){try{if(!this.remoteSDP)throw new Error("Cannot call NVExtentionsConnection.receive ".concat(e," before remoteSDP created."));const{mid:r,needExchangeSDP:s}=this.remoteSDP.send(e,t,i,n);if(s){const t=this.remoteSDP.toString(),i=this.logSDPExchange(t,"offer","remote","receive");await this.peerConnection.setRemoteDescription({type:"offer",sdp:t});const n=await this.peerConnection.createAnswer(),s=this.mungReceiveAnswerSDP(n.sdp,r,e);null==i||i(s||""),await this.peerConnection.setLocalDescription({type:"answer",sdp:s}),KC.debug("[NVExtentionsConnection] receive ".concat(e," by exchanging SDP."));}else KC.debug("[NVExtentionsConnection] receive ".concat(e," no need to exchange SDP."));const o=this.peerConnection.getTransceivers().find((e=>e.mid===r));if(!o)throw new Error("Cannot get transceiver after setLocalDescription.");return {track:o.receiver.track,id:r}}catch(e){throw new xv(xg.EXCHANGE_SDP_FAILED,"NVExtentionsConnection.receive failed; ".concat(e.toString()))}}async batchReceive(e){try{if(!this.remoteSDP)throw new Error("Cannot call NVExtentionsConnection.batchReceive before remoteSDP created.");const{mids:t,needExchangeSDP:i}=this.remoteSDP.batchSend(e);if(i){const e=this.remoteSDP.toString(),t=this.logSDPExchange(e,"offer","remote","receive");await this.peerConnection.setRemoteDescription({type:"offer",sdp:e});const i=await this.peerConnection.createAnswer();null==t||t(i.sdp||""),await this.peerConnection.setLocalDescription(i),KC.debug("[NVExtentionsConnection] batchReceive by exchanging SDP.");}else KC.debug("[NVExtentionsConnection] batchReceive no need to exchange SDP.");return t.map((e=>{const t=this.peerConnection.getTransceivers().find((t=>t.mid===e));if(!t)throw new Error("Cannot get transceiver after setLocalDescription.");return {track:t.receiver.track,id:e}}))}catch(e){throw new xv(xg.EXCHANGE_SDP_FAILED,"NVExtentionsConnection.receive failed; ".concat(e.toString()))}}async stopReceiving(e){try{if(!this.remoteSDP)throw new Error("Cannot call NVExtentionsConnection.stopReceiving before remote SDP created.");this.remoteSDP.stopSending(e);const t=this.remoteSDP.toString(),i=this.logSDPExchange(t,"offer","remote","stopReceiving");await this.peerConnection.setRemoteDescription({type:"offer",sdp:t});const n=await this.peerConnection.createAnswer();null==i||i(n.sdp||""),await this.peerConnection.setLocalDescription(n);}catch(e){throw new xv(xg.EXCHANGE_SDP_FAILED,"NVExtentionsConnection stopReceiving failed; ".concat(e.toString()))}}async muteRemote(e){try{if(!this.remoteSDP)throw new Error("Cannot call NVExtentionsConnection.muteRemote mid=".concat(e," before remote SDP created."));this.remoteSDP.mute(e);const t=this.remoteSDP.toString(),i=this.logSDPExchange(t,"offer","remote","muteRemote");await this.peerConnection.setRemoteDescription({type:"offer",sdp:t});const n=await this.peerConnection.createAnswer();null==i||i(n.sdp||""),await this.peerConnection.setLocalDescription(n);}catch(e){throw new xv(xg.EXCHANGE_SDP_FAILED,"NVExtentionsConnection.muteRemote failed; ".concat(e.toString()))}}async unmuteRemote(e){try{if(!this.remoteSDP)throw new Error("Cannot call NVExtentionsConnection.unmuteRemote mid=".concat(e," before remote SDP created."));this.remoteSDP.unmute(e);const t=this.remoteSDP.toString(),i=this.logSDPExchange(t,"offer","remote","unmuteRemote");await this.peerConnection.setRemoteDescription({type:"offer",sdp:t});const n=await this.peerConnection.createAnswer();null==i||i(n.sdp||""),await this.peerConnection.setLocalDescription(n);}catch(e){throw new xv(xg.EXCHANGE_SDP_FAILED,"NVExtentionsConnection.unmuteRemote failed; ".concat(e.toString()))}}async muteLocal(e){try{if(!this.remoteSDP)throw new Error("Cannot call NVExtentionsConnection.muteLocal before remote SDP created.");const t=this.peerConnection.getTransceivers().filter((t=>t.mid&&-1!==e.indexOf(t.mid)));if(t.length!==e.length)throw new Error("Transceivers' length doesn't match mids' length.");t.map((e=>{e.direction="inactive";}));const i=await this.peerConnection.createOffer(),n=this.logSDPExchange(i.sdp||"","offer","local","muteLocal");await this.peerConnection.setLocalDescription(i),this.remoteSDP.muteRemote(e);const r=this.remoteSDP.toString();null==n||n(r),await this.peerConnection.setRemoteDescription({type:"answer",sdp:r});}catch(e){throw new xv(xg.EXCHANGE_SDP_FAILED,"NVExtentionsConnection.muteLocal failed; ".concat(e.toString()))}}async unmuteLocal(e){try{if(!this.remoteSDP)throw new Error("Cannot call NVExtentionsConnection.unmuteLocal before remote SDP created.");const t=this.peerConnection.getTransceivers().filter((t=>t.mid&&-1!==e.indexOf(t.mid)));if(t.length!==e.length)throw new Error("Transceivers' length doesn't match mids' length.");t.map((async(e,t)=>{e.direction="sendonly";}));const i=await this.peerConnection.createOffer(),n=this.logSDPExchange(i.sdp||"","offer","local","unmuteLocal");await this.peerConnection.setLocalDescription(i),this.remoteSDP.unmuteRemote(e);const r=this.remoteSDP.toString();null==n||n(r),await this.peerConnection.setRemoteDescription({type:"answer",sdp:r});}catch(e){throw new xv(xg.EXCHANGE_SDP_FAILED,"NVExtentionsConnection.unmuteLocal failed; ".concat(e.toString()))}}restartICE(e){var t=this;return BP((function*(){const i=yield jP(t.mutex.lock("From NVExtentionsConnection.restartICE"));try{if(!t.remoteSDP)throw new Error("Cannot restartICE before remoteSDP created.");if(_A().supportPCSetConfiguration){const i=t.peerConnection.getConfiguration(),n=e===uI.RELAY?"relay":"all";i.iceTransportPolicy!==n&&(KC.debug("restartICE change iceTransportPolicy from [".concat(i.iceTransportPolicy,"] to [").concat(n,"]")),i.iceTransportPolicy=n,t.peerConnection.setConfiguration(i));}else if(e===uI.RELAY)return;e!==uI.RELAY&&t.remoteSDP.updateCandidates(e);const n=yield jP(t.peerConnection.createOffer({iceRestart:!0}));if(!n.sdp)throw new Error("Cannot restartICE because restart offer SDP does not exist.");const r=zP(n.sdp),{remoteIceParameters:s}=yield r.iceParameters;t.remoteSDP.restartICE(s);const o=t.remoteSDP.toString(),a=t.logSDPExchange(n.sdp||"","offer","local","restartICE");yield jP(t.peerConnection.setLocalDescription(n)),null==a||a(o),yield jP(t.peerConnection.setRemoteDescription({type:"answer",sdp:o}));}catch(e){KC.warning("restart ICE failed, abort operation",e);}finally{i();}}))()}close(){var e;null===(e=this.onConnectionStateChange)||void 0===e||e.call(this,"closed"),this.unbindPCEvents(),this.unbindStatsEvents(),this.removeAllListeners(),this.transportEventReceiver=void 0,this.statsFilter.destroy(),this.dataStreamChannelMap.clear();}getStats(){return this.statsFilter.getStats()}getRemoteVideoIsReady(e){return this.statsFilter.getVideoIsReady(e)}async updateEncoderConfig(e,t){try{if(!this.remoteSDP)throw new Error("Cannot call NVExtentionsConnection.updateEncoderConfig before remote SDP created.");const i=await this.peerConnection.createOffer(),n=this.mungSendOfferSDP(i.sdp,[t],[e]);this.remoteSDP.updateRecvMedia(e,t);const r=this.remoteSDP.toString(),s=this.logSDPExchange(n,"offer","local","updateEncoderConfig");await this.peerConnection.setLocalDescription({type:"offer",sdp:n}),null==s||s(r),await this.peerConnection.setRemoteDescription({type:"answer",sdp:r});}catch(e){throw new xv(xg.EXCHANGE_SDP_FAILED,e.toString())}}async updateSendParameters(e,t){const i=this.peerConnection.getTransceivers().filter((t=>t.mid===e));1===i.length&&(this.isVP8Simulcast(t)?Rg()||await this.applySimulcastEncodings(i,[t]):await this.applySendEncodings(i,[t]));}setStatsRemoteVideoIsReady(e,t){this.statsFilter.setVideoIsReady2(e,t);}async replaceTrack(e,t){const i=this.peerConnection.getTransceivers().find((e=>e.mid===t));i&&await i.sender.replaceTrack(e._mediaStreamTrack);}getP2PConnectionParams(){var e;if(null===(e=this.peerConnection.currentLocalDescription)||void 0===e||!e.sdp||!this.localCapabilities)throw new Error;return ek(ek({},zP(this.peerConnection.currentLocalDescription.sdp)),{},{rtpCapabilities:this.localCapabilities})}bindPCEvents(){this.peerConnection.oniceconnectionstatechange=()=>{var e;null===(e=this.onICEConnectionStateChange)||void 0===e||e.call(this,this.peerConnection.iceConnectionState);},this.peerConnection.onconnectionstatechange=()=>{var e;null===(e=this.onConnectionStateChange)||void 0===e||e.call(this,this.peerConnection.connectionState);},this.peerConnection.onicecandidate=e=>{e.candidate?this.localCandidateCount+=1:(this.peerConnection.onicecandidate=null,this.allCandidatesReceived=!0,KC.debug("[pc-".concat(this.store.p2pId,"] local candidate count"),this.localCandidateCount));},setTimeout((()=>{this.allCandidatesReceived||(this.allCandidatesReceived=!0,KC.debug("[pc-".concat(this.store.p2pId,"] onicecandidate timeout, local candidate count"),this.localCandidateCount));}),kC("CANDIDATE_TIMEOUT"));}unbindPCEvents(){this.peerConnection.oniceconnectionstatechange=null,this.peerConnection.onconnectionstatechange=null,this.peerConnection.onsignalingstatechange=null,this.peerConnection.onicecandidateerror=null,this.peerConnection.onicecandidate=null,this.peerConnection.ontrack=null;}static resolvePCConfiguration(e){const t={iceServers:[]};return e.iceServers?t.iceServers=e.iceServers:e.turnServer&&"off"!==e.turnServer.mode&&(_T(e.turnServer.servers)?t.iceServers=e.turnServer.servers:(t.iceServers&&t.iceServers.push(...tk.turnServerConfigToIceServers(e.turnServer.servers)),kC("USE_TURN_SERVER_OF_GATEWAY")&&t.iceServers&&e.turnServer.serversFromGateway&&t.iceServers.push(...tk.turnServerConfigToIceServers(e.turnServer.serversFromGateway)),kC("FORCE_TURN_TCP")?t.iceTransportPolicy="relay":e.turnServer.servers.concat(e.turnServer.serversFromGateway||[]).forEach((e=>{e.forceturn&&(t.iceTransportPolicy="relay");})))),t}static turnServerConfigToIceServers(e){const t=[];return e.forEach((e=>{e.security?e.tcpport&&t.push({username:e.username,credential:e.password,credentialType:"password",urls:"turns:".concat(_D(e.turnServerURL),":").concat(e.tcpport,"?transport=tcp")}):(e.udpport&&!kC("FORCE_TURN_TCP")&&t.push({username:e.username,credential:e.password,credentialType:"password",urls:"turn:".concat(e.turnServerURL,":").concat(e.udpport,"?transport=udp")}),e.tcpport&&t.push({username:e.username,credential:e.password,credentialType:"password",urls:"turn:".concat(e.turnServerURL,":").concat(e.tcpport,"?transport=tcp")}));})),t}async applySendEncodings(e,t){try{if(!_A().supportSetRtpSenderParameters)return;if(e.length!==t.length)return;for(let l=0;l<e.length;l++){const h=e[l],u=t[l];if(u&&u instanceof Sb){var i,n,r;if(this.isVP8Simulcast(u))continue;const e={},t={};switch(u._optimizationMode){case"motion":e.degradationPreference="maintain-framerate";break;case"detail":e.degradationPreference="maintain-resolution";break;default:e.degradationPreference="balanced";}var s,o,a,c;if(null!==(i=u._encoderConfig)&&void 0!==i&&i.bitrateMax)t.maxBitrate=1e3*(null===(s=u._encoderConfig)||void 0===s?void 0:s.bitrateMax);if(Pr(n=u._hints).call(n,ky.LOW_STREAM))null!==(o=u._encoderConfig)&&void 0!==o&&o.frameRate&&(t.maxFramerate=mD(u._encoderConfig.frameRate)),null!==(a=u._encoderConfig)&&void 0!==a&&a.scaleResolutionDownBy&&(null===(c=u._encoderConfig)||void 0===c?void 0:c.scaleResolutionDownBy)>1&&(t.scaleResolutionDownBy=u._encoderConfig.scaleResolutionDownBy);if(kC("DSCP_TYPE")&&kg()){var d;const e=kC("DSCP_TYPE");Pr(d=["very-low","low","medium","high"]).call(d,e)&&(t.networkPriority=e);}const l=h.sender.getParameters(),p=null===(r=l.encodings)||void 0===r?void 0:r[0];Rg()&&!p&&(e.encodings=[t]),p&&Object.assign(p,t),Object.assign(l,e),await h.sender.setParameters(l);}}}catch(e){KC.debug("Apply RTPSendEncodings failed.");}}mungSendOfferSDP(e,t,i){const n=KP.parse(e);return t.forEach(((e,t)=>{const r=i[t],s=n.mediaDescriptions.find((e=>e.attributes.mid===r));s&&($P(s,e),rL(s,e,this.store.codec));})),KP.print(n)}mungReceiveAnswerSDP(e,t,i){const n=KP.parse(e),r=n.mediaDescriptions.find((e=>e.attributes.mid===t));return r&&i===hI.AUDIO&&"audio"===r.media.mediaType&&cL(r),this.useXR&&dL(n),KP.print(n)}bindStatsEvents(){this.statsFilter.onFirstAudioReceived=e=>{var t;null===(t=this.onFirstAudioReceived)||void 0===t||t.call(this,e);},this.statsFilter.onFirstVideoReceived=e=>{var t;null===(t=this.onFirstVideoReceived)||void 0===t||t.call(this,e);},this.statsFilter.onFirstAudioDecoded=e=>{var t;null===(t=this.onFirstAudioDecoded)||void 0===t||t.call(this,e);},this.statsFilter.onFirstVideoDecoded=(e,t,i)=>{var n;null===(n=this.onFirstVideoDecoded)||void 0===n||n.call(this,e,t,i);},this.statsFilter.onSelectedLocalCandidateChanged=(e,t)=>{var i;null===(i=this.onSelectedLocalCandidateChanged)||void 0===i||i.call(this,e,t);},this.statsFilter.onSelectedRemoteCandidateChanged=(e,t)=>{var i;null===(i=this.onSelectedRemoteCandidateChanged)||void 0===i||i.call(this,e,t);},this.statsFilter.onFirstVideoDecodedTimeout=e=>{var t;null===(t=this.onFirstVideoDecodedTimeout)||void 0===t||t.call(this,e);};}unbindStatsEvents(){this.statsFilter.onFirstAudioReceived=void 0,this.statsFilter.onFirstVideoReceived=void 0,this.statsFilter.onFirstAudioDecoded=void 0,this.statsFilter.onFirstVideoDecoded=void 0,this.statsFilter.onSelectedLocalCandidateChanged=void 0,this.statsFilter.onSelectedRemoteCandidateChanged=void 0,this.statsFilter.onFirstVideoDecodedTimeout=void 0;}async applySimulcastForFirefox(e,t){if(e.length===t.length)for(let a=0;a<e.length;a++){var i,n,r,s,o;const c=e[a],d=t[a];if(d instanceof Sb&&!Pr(i=d._hints).call(i,ky.LOW_STREAM)&&null!==(n=d._encoderConfig)&&void 0!==n&&n.bitrateMax&&(null===(r=d._encoderConfig)||void 0===r?void 0:r.bitrateMax)>200&&null!==(s=d._scalabilityMode)&&void 0!==s&&s.numSpatialLayers&&(null===(o=d._scalabilityMode)||void 0===o?void 0:o.numSpatialLayers)>1&&"vp8"===this.store.codec){const e={},t={high:1e3*(d._encoderConfig.bitrateMax-50),medium:5e4};e.encodings=[{rid:"m",active:!0,maxBitrate:t.medium,scaleResolutionDownBy:4},{rid:"h",active:!0,maxBitrate:t.high}];const i=c.sender.getParameters();await c.sender.setParameters(Object.assign(i,e));}}}async applySimulcastEncodings(e,t){if(!Rg()&&e.length===t.length)for(let i=0;i<e.length;i++){const n=t[i];if(n instanceof Sb&&this.isVP8Simulcast(n)){const t=e[i],r={},s={high:1e3*(n._encoderConfig.bitrateMax-50),medium:5e4};r.encodings=[{active:!0,adaptivePtime:!1,networkPriority:"high",priority:"high",maxBitrate:s.high},{active:!0,adaptivePtime:!1,networkPriority:"low",priority:"low",maxBitrate:s.medium,scaleResolutionDownBy:4}];const o=t.sender.getParameters();await t.sender.setParameters(Object.assign(o,r));}}}isVP8Simulcast(e){var t,i,n,r,s;return !!(e instanceof Sb&&kC("SIMULCAST")&&"vp8"===this.store.codec&&!Pr(t=e._hints).call(t,ky.LOW_STREAM)&&null!==(i=e._encoderConfig)&&void 0!==i&&i.bitrateMax&&(null===(n=e._encoderConfig)||void 0===n?void 0:n.bitrateMax)>200&&null!==(r=e._scalabilityMode)&&void 0!==r&&r.numSpatialLayers&&(null===(s=e._scalabilityMode)||void 0===s?void 0:s.numSpatialLayers)>1)}logSDPExchange(e,t,i,n){if(kC("SDP_LOGGING"))return KC.upload("exchanging ".concat(i," ").concat(t," SDP during NVExtentionsConnection.").concat(n,"\n"),e),"offer"===t?e=>{this.logSDPExchange(e,"answer","local"===i?"remote":"local",n);}:void 0}async getRemoteSSRC(e){if(!this.remoteSDP)return;const t=this.remoteSDP.getSSRC(e);return null==t?void 0:t[0].ssrcId}setConfiguration(e){if(_A().supportPCSetConfiguration){const t=tk.resolvePCConfiguration(e);this.peerConnection.setConfiguration(t);}}}function ik(e,t,i){const n=e[t];if("function"!=typeof n)throw new Error("Cannot use mutex on object property.");return i.value=async function(){const e=this.mutex,i=await e.lock("From NVExtentionsConnection.".concat(t));try{for(var r=arguments.length,s=new Array(r),o=0;o<r;o++)s[o]=arguments[o];return await n.apply(this,s)}finally{i();}},i}function nk(e){var t,i,n,r=2;for("undefined"!=typeof Symbol&&(i=WP,n=Symbol.iterator);r--;){if(i&&null!=(t=e[i]))return t.call(e);if(n&&null!=(t=e[n]))return new rk(t.call(e));i="@@asyncIterator",n="@@iterator";}throw new TypeError("Object is not async iterable")}function rk(e){function t(e){if(Object(e)!==e)return tg.reject(new TypeError(e+" is not an object."));var t=e.done;return tg.resolve(e.value).then((function(e){return {value:e,done:t}}))}return rk=function(e){this.s=e,this.n=e.next;},rk.prototype={s:null,n:null,next:function(){return t(this.n.apply(this.s,arguments))},return:function(e){var i=this.s.return;return void 0===i?tg.resolve({value:e,done:!0}):t(i.apply(this.s,arguments))},throw:function(e){var i=this.s.return;return void 0===i?tg.reject(e):t(i.apply(this.s,arguments))}},new rk(e)}Mv([ik,Uv("design:type",Function),Uv("design:paramtypes",[Object,Object,Array,Object,String,String]),Uv("design:returntype",tg)],tk.prototype,"connect",null),Mv([ik,Uv("design:type",Function),Uv("design:paramtypes",[Array,Array]),Uv("design:returntype",tg)],tk.prototype,"updateRemoteRTPCapabilities",null),Mv([ik,Uv("design:type",Function),Uv("design:paramtypes",[Object]),Uv("design:returntype",tg)],tk.prototype,"updateRemoteConnect",null),Mv([ik,Uv("design:type",Function),Uv("design:paramtypes",[Object,Array]),Uv("design:returntype",tg)],tk.prototype,"createDataChannels",null),Mv([ik,Uv("design:type",Function),Uv("design:paramtypes",[String,Array,String,Object]),Uv("design:returntype",tg)],tk.prototype,"receive",null),Mv([ik,Uv("design:type",Function),Uv("design:paramtypes",[Array]),Uv("design:returntype",tg)],tk.prototype,"batchReceive",null),Mv([ik,Uv("design:type",Function),Uv("design:paramtypes",[Array]),Uv("design:returntype",tg)],tk.prototype,"stopReceiving",null),Mv([ik,Uv("design:type",Function),Uv("design:paramtypes",[String]),Uv("design:returntype",tg)],tk.prototype,"muteRemote",null),Mv([ik,Uv("design:type",Function),Uv("design:paramtypes",[String]),Uv("design:returntype",tg)],tk.prototype,"unmuteRemote",null),Mv([ik,Uv("design:type",Function),Uv("design:paramtypes",[Array]),Uv("design:returntype",tg)],tk.prototype,"muteLocal",null),Mv([ik,Uv("design:type",Function),Uv("design:paramtypes",[Array]),Uv("design:returntype",tg)],tk.prototype,"unmuteLocal",null),Mv([ik,Uv("design:type",Function),Uv("design:paramtypes",[]),Uv("design:returntype",void 0)],tk.prototype,"close",null),Mv([ik,Uv("design:type",Function),Uv("design:paramtypes",[String,iA]),Uv("design:returntype",tg)],tk.prototype,"updateEncoderConfig",null),Mv([ik,Uv("design:type",Function),Uv("design:paramtypes",[String,iA]),Uv("design:returntype",tg)],tk.prototype,"updateSendParameters",null),Mv([ik,Uv("design:type",Function),Uv("design:paramtypes",[iA,String]),Uv("design:returntype",tg)],tk.prototype,"replaceTrack",null),Mv([ik,Uv("design:type",Function),Uv("design:paramtypes",[String]),Uv("design:returntype",tg)],tk.prototype,"getRemoteSSRC",null);class sk extends PI{get currentLocalDescription(){return this.peerConnection.currentLocalDescription}get currentRemoteDescription(){return this.peerConnection.currentRemoteDescription}get peerConnectionState(){return this.peerConnection.connectionState}get iceConnectionState(){return this.peerConnection.iceConnectionState}constructor(e,t){super(e,t),nu(this,"store",void 0),nu(this,"peerConnection",void 0),nu(this,"cname",void 0),nu(this,"mutex",new YT("DataChannelConnection-mutex")),nu(this,"dataChannel",void 0),nu(this,"_p2pConnection",void 0),nu(this,"establishPromise",void 0),nu(this,"_nvMedia",void 0),this.store=t,this.store.dcId=this.store.dcId+1,this.peerConnection=new RTCPeerConnection(sk.resolvePCConfiguration(e),{optional:[{googDscp:!0}]}),this.dataChannel=this.peerConnection.createDataChannel("agora-signal",{ordered:!1,maxPacketLifeTime:50}),this.dataChannel.binaryType="arraybuffer",this._p2pConnection=new tk(e,t,this.peerConnection),this.bindPCEvents(),this.establishPromise=this._p2pConnection.establishPromise;}async establish(){var e;const t=null===(e=this._nvMedia)||void 0===e?void 0:e.getLocalRtpCapabilities();return await this._p2pConnection.establish(t)}getP2PConnectionParams(){return this._p2pConnection.getP2PConnectionParams()}async connect(e,t,i,n,r,s){return this.cname=s,await this._p2pConnection.connect(e,t,i,n,r,s),await new tg(((e,t)=>{const n=setTimeout((()=>{this.closeSignal(),t(new xv(xg.DATACHANNEL_CONNECTION_TIMEOUT,"Datachannel connection timed out, candidates: ".concat(JSON.stringify(i))));}),2e3);this.dataChannel.onopen=()=>{if("open"===this.dataChannel.readyState)return clearTimeout(n),void e()},this.dataChannel.onerror=e=>{this.closeSignal(),t(e);};})),{transmitter:this.dataChannel,close:this.closeSignal.bind(this)}}async updateRemoteRTPCapabilities(e,t){return this._p2pConnection.updateRemoteRTPCapabilities(e,t)}send(e,t,i){var n=this;return BP((function*(){const r=yield jP(n.mutex.lock("From DataChannelConnection.send"));try{return yield*GP(nk(n._p2pConnection.send(e,t,i)))}finally{r();}}))()}async stopSending(e,t){return this._p2pConnection.stopSending(e,t)}async createDataChannels(e,t){return this._p2pConnection.createDataChannels(e,t)}async stopDataChannels(e){return this._p2pConnection.stopDataChannels(e)}async receive(e,t,i,n){return this._nvMedia?(KC.debug("[DataChannelConnection] receive ".concat(e," by DataChannel.")),await this._nvMedia.reveiveByRTCMedia(e,t,this.cname)):(KC.debug("[DataChannelConnection] receive ".concat(e," by WebRTC.")),await this._p2pConnection.receive(e,t,i,n))}async batchReceive(e){return [...await this._p2pConnection.batchReceive(e)]}async stopReceiving(e){return await this._p2pConnection.stopReceiving(e)}async muteRemote(e){return await this._p2pConnection.muteRemote(e)}async unmuteRemote(e){return await this._p2pConnection.unmuteRemote(e)}async muteLocal(e){return await this._p2pConnection.muteLocal(e)}async unmuteLocal(e){return await this._p2pConnection.unmuteLocal(e)}restartICE(e){var t=this;return BP((function*(){return yield*GP(nk(t._p2pConnection.restartICE(e)))}))()}close(){var e;null===(e=this._nvMedia)||void 0===e||e.close(),this._p2pConnection.close(),this.unbindConnectionEvents(this._p2pConnection);}getStats(){return this._p2pConnection.getStats()}getRemoteVideoIsReady(e){return this._p2pConnection.getRemoteVideoIsReady(e)}updateRemoteConnect(e){var t;null===(t=this._nvMedia)||void 0===t||t.setRemoteRtpCapabilities(e),this._p2pConnection.updateRemoteConnect(e);}async updateEncoderConfig(e,t){return await this._p2pConnection.updateEncoderConfig(e,t)}async updateSendParameters(e,t){return await this._p2pConnection.updateSendParameters(e,t)}setStatsRemoteVideoIsReady(e,t){this._p2pConnection.setStatsRemoteVideoIsReady(e,t);}async replaceTrack(e,t){return await this._p2pConnection.replaceTrack(e,t)}async getRemoteSSRC(e){return this._p2pConnection.getRemoteSSRC(e)}logSDPExchange(e,t,i,n){if(kC("SDP_LOGGING"))return KC.upload("exchanging ".concat(i," ").concat(t," SDP during DataChannelConnection.").concat(n,"\n"),e),"offer"===t?e=>{this.logSDPExchange(e,"answer","local"===i?"remote":"local",n);}:void 0}static resolvePCConfiguration(e){const t={iceServers:[]};return e.iceServers?t.iceServers=e.iceServers:e.turnServer&&"off"!==e.turnServer.mode&&(_T(e.turnServer.servers)?t.iceServers=e.turnServer.servers:(t.iceServers&&t.iceServers.push(...sk.turnServerConfigToIceServers(e.turnServer.servers)),kC("USE_TURN_SERVER_OF_GATEWAY")&&t.iceServers&&e.turnServer.serversFromGateway&&t.iceServers.push(...sk.turnServerConfigToIceServers(e.turnServer.serversFromGateway)),kC("FORCE_TURN_TCP")?t.iceTransportPolicy="relay":e.turnServer.servers.concat(e.turnServer.serversFromGateway||[]).forEach((e=>{e.forceturn&&(t.iceTransportPolicy="relay");})))),t}static turnServerConfigToIceServers(e){const t=[];return e.forEach((e=>{e.security?e.tcpport&&t.push({username:e.username,credential:e.password,credentialType:"password",urls:"turns:".concat(_D(e.turnServerURL),":").concat(e.tcpport,"?transport=tcp")}):(e.udpport&&!kC("FORCE_TURN_TCP")&&t.push({username:e.username,credential:e.password,credentialType:"password",urls:"turn:".concat(e.turnServerURL,":").concat(e.udpport,"?transport=udp")}),e.tcpport&&t.push({username:e.username,credential:e.password,credentialType:"password",urls:"turn:".concat(e.turnServerURL,":").concat(e.tcpport,"?transport=tcp")}));})),t}bindPCEvents(){this._p2pConnection.onICEConnectionStateChange=e=>{var t;return null===(t=this.onICEConnectionStateChange)||void 0===t?void 0:t.call(this,e)},this._p2pConnection.onConnectionStateChange=e=>{var t;return null===(t=this.onConnectionStateChange)||void 0===t?void 0:t.call(this,e)},this._p2pConnection.onDTLSTransportStateChange=e=>{var t;return null===(t=this.onDTLSTransportStateChange)||void 0===t?void 0:t.call(this,e)},this._p2pConnection.onDTLSTransportError=e=>{var t;return null===(t=this.onDTLSTransportError)||void 0===t?void 0:t.call(this,e)},this._p2pConnection.onICETransportStateChange=e=>{var t;return null===(t=this.onICETransportStateChange)||void 0===t?void 0:t.call(this,e)},this._p2pConnection.onFirstAudioReceived=e=>{var t;return null===(t=this.onFirstAudioReceived)||void 0===t?void 0:t.call(this,e)},this._p2pConnection.onFirstVideoReceived=e=>{var t;return null===(t=this.onFirstVideoReceived)||void 0===t?void 0:t.call(this,e)},this._p2pConnection.onFirstAudioDecoded=e=>{var t;return null===(t=this.onFirstAudioDecoded)||void 0===t?void 0:t.call(this,e)},this._p2pConnection.onFirstVideoDecoded=(e,t,i)=>{var n;return null===(n=this.onFirstVideoDecoded)||void 0===n?void 0:n.call(this,e,t,i)},this._p2pConnection.onFirstVideoDecodedTimeout=e=>{var t;return null===(t=this.onFirstVideoDecodedTimeout)||void 0===t?void 0:t.call(this,e)},this._p2pConnection.onSelectedLocalCandidateChanged=(e,t)=>{var i;return null===(i=this.onSelectedLocalCandidateChanged)||void 0===i?void 0:i.call(this,e,t)},this._p2pConnection.onSelectedRemoteCandidateChanged=(e,t)=>{var i;return null===(i=this.onSelectedRemoteCandidateChanged)||void 0===i?void 0:i.call(this,e,t)};}closeSignal(){this.dataChannel.close(),this.peerConnection.close();}unbindConnectionEvents(e){e.onConnectionStateChange=void 0,e.onICEConnectionStateChange=void 0,e.onICETransportStateChange=void 0,e.onDTLSTransportStateChange=void 0,e.onDTLSTransportError=void 0,e.onFirstAudioDecoded=void 0,e.onFirstAudioReceived=void 0,e.onFirstVideoDecoded=void 0,e.onFirstVideoReceived=void 0,e.onSelectedLocalCandidateChanged=void 0,e.onSelectedRemoteCandidateChanged=void 0,e.onFirstVideoDecodedTimeout=void 0;}setConfiguration(e){this._p2pConnection.setConfiguration(e);}}function ok(e,t,i){const n=e[t];if("function"!=typeof n)throw new Error("Cannot use mutex on object property.");return i.value=async function(){const e=this.mutex,i=await e.lock("From DataChannelConnection.".concat(t));try{for(var r=arguments.length,s=new Array(r),o=0;o<r;o++)s[o]=arguments[o];return await n.apply(this,s)}finally{i();}},i}function ak(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n);}return i}function ck(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?ak(Object(i),!0).forEach((function(t){nu(e,t,i[t]);})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):ak(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t));}));}return e}Mv([ok,Uv("design:type",Function),Uv("design:paramtypes",[Object,Object,Array,Object,String,String]),Uv("design:returntype",tg)],sk.prototype,"connect",null),Mv([ok,Uv("design:type",Function),Uv("design:paramtypes",[Array,Array]),Uv("design:returntype",tg)],sk.prototype,"updateRemoteRTPCapabilities",null),Mv([ok,Uv("design:type",Function),Uv("design:paramtypes",[Object,Array]),Uv("design:returntype",tg)],sk.prototype,"createDataChannels",null),Mv([ok,Uv("design:type",Function),Uv("design:paramtypes",[String,Array,String,Object]),Uv("design:returntype",tg)],sk.prototype,"receive",null),Mv([ok,Uv("design:type",Function),Uv("design:paramtypes",[Array]),Uv("design:returntype",tg)],sk.prototype,"stopReceiving",null),Mv([ok,Uv("design:type",Function),Uv("design:paramtypes",[String]),Uv("design:returntype",tg)],sk.prototype,"muteRemote",null),Mv([ok,Uv("design:type",Function),Uv("design:paramtypes",[String]),Uv("design:returntype",tg)],sk.prototype,"unmuteRemote",null),Mv([ok,Uv("design:type",Function),Uv("design:paramtypes",[Array]),Uv("design:returntype",tg)],sk.prototype,"muteLocal",null),Mv([ok,Uv("design:type",Function),Uv("design:paramtypes",[Array]),Uv("design:returntype",tg)],sk.prototype,"unmuteLocal",null),Mv([ok,Uv("design:type",Function),Uv("design:paramtypes",[]),Uv("design:returntype",void 0)],sk.prototype,"close",null),Mv([ok,Uv("design:type",Function),Uv("design:paramtypes",[String,iA]),Uv("design:returntype",tg)],sk.prototype,"updateEncoderConfig",null),Mv([ok,Uv("design:type",Function),Uv("design:paramtypes",[String,iA]),Uv("design:returntype",tg)],sk.prototype,"updateSendParameters",null),Mv([ok,Uv("design:type",Function),Uv("design:paramtypes",[iA,String]),Uv("design:returntype",tg)],sk.prototype,"replaceTrack",null),Mv([ok,Uv("design:type",Function),Uv("design:paramtypes",[String]),Uv("design:returntype",tg)],sk.prototype,"getRemoteSSRC",null);class dk extends iT{constructor(){super(),nu(this,"uplinkStatsUploadInterval",void 0),nu(this,"uplinkRelatedStatsUploadInterval",void 0),nu(this,"uplinkDenoiserStatsUploadInterval",void 0),nu(this,"transportStatsUploadInterval",void 0),nu(this,"uplinkExtensionStatsUploadInterval",void 0),nu(this,"downlinkExtensionStatsUploadInterval",void 0),nu(this,"extensionUsageStatsUploadInterval",void 0),nu(this,"downlinkStatsUploadInterval",void 0),nu(this,"downlinkRelatedStatsUploadInterval",void 0),nu(this,"lastStats",void 0),nu(this,"uploadUnplinkStarted",!1),nu(this,"uploadDownlinkStarted",!1),nu(this,"uploadTransportStarted",!1),nu(this,"uploadExtensionUsageStarted",!1),nu(this,"requestStats",void 0),nu(this,"requestTransportStats",void 0),nu(this,"requestLocalMedia",void 0),nu(this,"requestRemoteMedia",void 0),nu(this,"requestAllTracks",void 0),nu(this,"requestVideoIsReady",void 0),nu(this,"requestUpload",void 0);}startUploadTransportStats(e){this.uploadTransportStarted||(this.uploadTransportStarted=!0,this.transportStatsUploadInterval&&window.clearInterval(this.transportStatsUploadInterval),this.transportStatsUploadInterval=window.setInterval((()=>{var t;const i=null===(t=this.requestStats)||void 0===t?void 0:t.call(this);if(i){const t=gD(i);if(e){var n;const e=null===(n=this.requestStats)||void 0===n?void 0:n.call(this,!0);if(e){const i=gD(e);t.connectionType+=i.connectionType<<3;}t.connectionType+=110;}else t.connectionType+=100;AT((()=>{var e;null===(e=this.requestUpload)||void 0===e||e.call(this,Sv.TRANSPORT_STATS,t);}));}}),1e3));}startUploadExtensionUsageStats(){if(this.uploadExtensionUsageStarted)return;this.uploadExtensionUsageStarted=!0,this.extensionUsageStatsUploadInterval&&window.clearInterval(this.extensionUsageStatsUploadInterval);const e=new Map;this.extensionUsageStatsUploadInterval=window.setInterval((async()=>{var t,i,n;const r=Date.now(),s={connectionInterval:kC("EXTENSION_USAGE_UPLOAD_INTERVAL")/1e3,details:[],lts:r};let o=[];const a=(null===(t=this.requestAllTracks)||void 0===t?void 0:t.call(this))||[];for(const e of a)!e.muted&&e.enabled&&(o=o.concat(await e.getProcessorUsage()));const c=(null===(i=this.requestRemoteMedia)||void 0===i?void 0:i.call(this))||[];for(const[e,t]of c)t.has(hI.VIDEO)&&e.videoTrack&&(o=o.concat(await e.videoTrack.getProcessorUsage())),t.has(hI.AUDIO)&&e.audioTrack&&(o=o.concat(await e.audioTrack.getProcessorUsage()));if(0===o.length)return;s.details=function(e,t){const i={};for(const{id:o,value:a,level:c,direction:d}of e){var n;const e=null!==(n=t.get(o))&&void 0!==n?n:0,l=2===a?e+kC("EXTENSION_USAGE_UPLOAD_INTERVAL")/1e3:e;var r,s;t.set(o,l),i[o]?(2===a&&(i[o].value=a),c>i[o].level&&(i[o].level=c),"remote"===d&&(i[o].remoteUidCount+=1),i[o].totalTs=null!==(r=t.get(o))&&void 0!==r?r:0):i[o]={value:a,level:c,remoteUidCount:"local"===d?0:1,totalTs:null!==(s=t.get(o))&&void 0!==s?s:0};}return Object.keys(i).map((e=>{const{level:t,value:n,totalTs:r}=i[e];return {id:e,level:t,value:n,totalTs:r}}))}(o,e);const d=Date.now(),l=d>r?d:r+1;null===(n=this.requestUpload)||void 0===n||n.call(this,Sv.EXTENSION_USAGE_STATS,{usageStats:s,sendTs:l});}),kC("EXTENSION_USAGE_UPLOAD_INTERVAL"));}startUploadUplinkStats(){this.uploadUnplinkStarted||(this.uploadUnplinkStarted=!0,this.uplinkStatsUploadInterval&&window.clearInterval(this.uplinkStatsUploadInterval),this.uplinkStatsUploadInterval=window.setInterval((()=>{var e;const t=null===(e=this.requestStats)||void 0===e?void 0:e.call(this);t&&(this.uploadUplinkStats(t),this.lastStats=t);}),3e3),this.uplinkRelatedStatsUploadInterval&&window.clearInterval(this.uplinkRelatedStatsUploadInterval),this.uplinkRelatedStatsUploadInterval=window.setInterval((()=>{var e;const t=null===(e=this.requestStats)||void 0===e?void 0:e.call(this);t&&this.uploadRelatedUplinkStats(t,this.lastStats),this.lastStats=t;}),1e3),this.uplinkDenoiserStatsUploadInterval&&window.clearInterval(this.uplinkDenoiserStatsUploadInterval),this.uplinkDenoiserStatsUploadInterval=window.setInterval((()=>{var e;const t=null===(e=this.requestAllTracks)||void 0===e?void 0:e.call(this);t&&this.uploadDenoiserStats(t);}),2e3),this.uplinkExtensionStatsUploadInterval&&window.clearInterval(this.uplinkExtensionStatsUploadInterval),this.uplinkExtensionStatsUploadInterval=window.setInterval((()=>{var e;const t=null===(e=this.requestAllTracks)||void 0===e?void 0:e.call(this);t&&this.uploadExtensionStats(t);}),2e3));}uploadUplinkStats(e){var t;((null===(t=this.requestLocalMedia)||void 0===t?void 0:t.call(this))||[]).forEach((t=>{let[i,{track:n,ssrcs:r}]=t;switch(i){case _I.LocalVideoLowTrack:case _I.LocalVideoTrack:{const t=function(e,t,i){var n;const r=t.videoSend.find((t=>t.ssrc===e));if(!r)return null;const s={id:xT(10,""),timestamp:new Date(t.timestamp).toISOString(),mediaType:"video",type:"ssrc",ssrc:r.ssrc.toString()};switch(s.A_vstd=i._originMediaStreamTrack&&!i._originMediaStreamTrack.enabled||i._mediaStreamTrack&&!i._mediaStreamTrack.enabled?"1":"0",r.sentFrame&&(s.A_fhs=r.sentFrame.height.toString(),s.A_frs=r.sentFrame.frameRate.toString(),s.A_fws=r.sentFrame.width.toString()),r.adaptionChangeReason){case"none":s.A_ac="0";break;case"cpu":s.A_ac="1";break;case"bandwidth":s.A_ac="2";break;case"other":s.A_ac="3";}return s.A_lvps=$y[i._player?i._player.videoElementStatus:"uninit"].toString(),s.A_nr=null===(n=r.nacksCount)||void 0===n?void 0:n.toString(),r.avgEncodeMs&&(s.A_aem=r.avgEncodeMs.toFixed(0).toString()),kC("P2P")&&(r.bytes&&(s.bytesSent=r.bytes.toString()),"number"==typeof r.packetsLost&&(s.packetsLost=r.packetsLost.toString()),r.packets&&(s.packetsSent=r.packets.toString())),s}(r[0].ssrcId,e,n),s=i===_I.LocalVideoTrack?function(e,t,i){var n,r,s,o,a,c,d,l;const h=t.videoSend.find((t=>t.ssrc===e));if(!h)return null;const u={id:xT(10,""),timestamp:new Date(t.timestamp).toISOString(),mediaType:"video",type:"ssrc",ssrc:h.ssrc.toString()},p=null!==(n=null!==(r=null===(s=h.inputFrame)||void 0===s?void 0:s.height)&&void 0!==r?r:null==i?void 0:i._videoHeight)&&void 0!==n?n:0,_=null!==(o=null!==(a=null===(c=h.inputFrame)||void 0===c?void 0:c.width)&&void 0!==a?a:null==i?void 0:i._videoWidth)&&void 0!==o?o:0,E=null!==(d=null===(l=h.inputFrame)||void 0===l?void 0:l.frameRate)&&void 0!==d?d:0;return p&&(u.A_fhi=p+""),_&&(u.A_fwi=_+""),E&&(u.A_fri=E+""),u}(r[0].ssrcId,e,n):null;t&&AT((()=>{var e;return null===(e=this.requestUpload)||void 0===e?void 0:e.call(this,Sv.PUBLISH_STATS,{stream_type:i===_I.LocalVideoLowTrack?"low":"high",stats:ck(ck({},t),s)})}));const o=function(e){const t={id:"bweforvideo",timestamp:new Date(e.timestamp).toISOString(),type:"VideoBwe"};return e.bitrate.retransmit&&(t.A_rb=e.bitrate.retransmit.toString()),e.bitrate.targetEncoded&&(t.A_teb=e.bitrate.targetEncoded.toString()),t.A_aeb=e.bitrate.actualEncoded.toString(),t.A_tb=e.bitrate.transmit.toString(),void 0!==e.sendBandwidth&&(t.A_asb=e.sendBandwidth.toString()),t}(e);o&&setTimeout((()=>{var e;return null===(e=this.requestUpload)||void 0===e?void 0:e.call(this,Sv.PUBLISH_STATS,{stream_type:i===_I.LocalVideoLowTrack?"low":"high",stats:o})}),1e3);break}case _I.LocalAudioTrack:{const t=function(e,t,i){const n=t.audioSend.find((t=>t.ssrc===e));if(!n)return null;const r={id:xT(10,""),timestamp:new Date(t.timestamp).toISOString(),mediaType:"audio",type:"ssrc",ssrc:n.ssrc.toString()};return r.A_astd=i._originMediaStreamTrack&&!i._originMediaStreamTrack.enabled||i._mediaStreamTrack&&!i._mediaStreamTrack.enabled?"1":"0",n.inputLevel?r.A_ail=Math.round(100*n.inputLevel).toString():r.A_ail=Math.round(100*i._source.getAccurateVolumeLevel()).toString(),r.A_apil=Math.round(100*i._source.getAccurateVolumeLevel()).toString(),n.aecReturnLoss&&(r.A_ecrl=Math.round(n.aecReturnLoss).toString()),n.aecReturnLossEnhancement&&(r.A_ecrle=Math.round(n.aecReturnLossEnhancement).toString()),kC("P2P")&&(n.bytes&&(r.bytesSent=n.bytes.toString()),"number"==typeof n.packetsLost&&(r.packetsLost=n.packetsLost.toString()),n.packets&&(r.packetsSent=n.packets.toString())),r}(r[0].ssrcId,e,n);t&&AT((()=>{var e;return null===(e=this.requestUpload)||void 0===e?void 0:e.call(this,Sv.PUBLISH_STATS,{stream_type:"high",stats:t})}));break}}}));}uploadRelatedUplinkStats(e,t){var i;((null===(i=this.requestLocalMedia)||void 0===i?void 0:i.call(this))||[]).filter((e=>{let[t]=e;return t===_I.LocalVideoLowTrack||t===_I.LocalVideoTrack})).forEach((t=>{let[i,{ssrcs:n}]=t;const r=function(e,t){const i=t.videoSend.find((t=>t.ssrc===e));return i?{mediaType:"video",isVideoMute:!1,frameRateInput:i.inputFrame&&i.inputFrame.frameRate.toString(),frameRateSent:i.sentFrame&&i.sentFrame.frameRate.toString(),googRtt:i.rttMs.toString(),qpSumPerFrame:Math.floor(i.qpSumPerFrame).toString()}:null}(n[0].ssrcId,e);r&&AT((()=>{var e;null===(e=this.requestUpload)||void 0===e||e.call(this,Sv.PUBLISH_RELATED_STATS,{stream_type:i===_I.LocalVideoLowTrack?"low":"high",stats:r});}));}));}uploadDenoiserStats(e){for(let r=0;r<e.length;r++){const s=e[r];if(s instanceof $A){var t,i,n;const e=null===(t=(i=s._external).getDenoiserStats)||void 0===t?void 0:t.call(i);return void(e&&(null===(n=this.requestUpload)||void 0===n||n.call(this,Sv.DENOISER_STATS,e)))}}}uploadExtensionStats(e){for(let t=0;t<e.length;t++){e[t].getProcessorStats().forEach((e=>{var t;null===(t=this.requestUpload)||void 0===t||t.call(this,e.type,e.stats);}));}}stopUploadUplinkStats(){this.uploadUnplinkStarted&&(this.uploadUnplinkStarted=!1,this.uplinkStatsUploadInterval&&window.clearInterval(this.uplinkStatsUploadInterval),this.uplinkRelatedStatsUploadInterval&&window.clearInterval(this.uplinkRelatedStatsUploadInterval),this.uplinkDenoiserStatsUploadInterval&&window.clearInterval(this.uplinkDenoiserStatsUploadInterval),this.uplinkStatsUploadInterval=void 0,this.uplinkRelatedStatsUploadInterval=void 0,this.uplinkDenoiserStatsUploadInterval=void 0);}startUploadDownlinkStats(){if(this.uploadDownlinkStarted)return;let e;this.uploadDownlinkStarted=!0,this.downlinkStatsUploadInterval&&window.clearInterval(this.downlinkStatsUploadInterval);let t=!1;this.downlinkStatsUploadInterval=window.setInterval((()=>{var i;const n=null===(i=this.requestStats)||void 0===i?void 0:i.call(this,!0);n&&(this.uploadDownlinkStats(n,t,e),e=n),t=!t;}),3e3),this.downlinkRelatedStatsUploadInterval&&window.clearInterval(this.downlinkRelatedStatsUploadInterval),this.downlinkRelatedStatsUploadInterval=window.setInterval((()=>{var e;const t=null===(e=this.requestStats)||void 0===e?void 0:e.call(this,!0);t&&(this.uploadRelatedDownlinkStats(t,this.lastStats),this.lastStats=t);}),1e3),this.downlinkExtensionStatsUploadInterval&&window.clearInterval(this.downlinkExtensionStatsUploadInterval),this.downlinkExtensionStatsUploadInterval=window.setInterval((()=>{var e;const t=null===(e=this.requestRemoteMedia)||void 0===e?void 0:e.call(this);t&&this.uploadDownlinkExtensionStats(t);}),2e3);}uploadDownlinkStats(e,t,i){var n;((null===(n=this.requestRemoteMedia)||void 0===n?void 0:n.call(this))||[]).forEach((n=>{let[r,s]=n;if(s.has(hI.VIDEO)&&r.videoTrack){const n=r.videoTrack?function(e,t,i,n,r){const s=t.videoRecv.find((t=>t.ssrc===e));if(!s)return null;const o={id:xT(10,""),timestamp:new Date(t.timestamp).toISOString(),mediaType:"video",type:"ssrc",ssrc:s.ssrc.toString()};var a,c;if(o.bytesReceived=s.bytes.toString(),o.packetsLost=s.packetsLost.toString(),o.packetsReceived=s.packets.toString(),s.framesRateFirefox&&(o.A_frr=s.framesRateFirefox.toString()),s.receivedFrame?(o.A_frr=s.receivedFrame.frameRate.toString(),o.A_fhr=s.receivedFrame.height.toString(),o.A_fwr=s.receivedFrame.width.toString()):(o.A_fhr=null===(a=n._videoHeight)||void 0===a?void 0:a.toString(),o.A_fwr=null===(c=n._videoWidth)||void 0===c?void 0:c.toString()),o.A_frd=s.decodeFrameRate.toString(),s.outputFrame&&(o.A_fro=s.outputFrame.frameRate.toString()),void 0!==s.jitterBufferMs&&(o.A_jbm=Math.floor(s.jitterBufferMs).toString()),void 0!==s.currentDelayMs&&(o.A_cdm=Math.floor(s.currentDelayMs).toString()),o.A_fs=s.firsCount.toString(),o.A_ns=s.nacksCount.toString(),o.A_ps=s.plisCount.toString(),n&&(o.A_vrtd=n._originMediaStreamTrack.enabled&&n._mediaStreamTrack.enabled?"0":"1"),n._player&&n._player.freezeTimeCounterList.length>0&&(o.A_vrft=Math.round(n._player.freezeTimeCounterList.splice(0,1)[0]).toString()),r&&n._player&&"visible"===db.visibility){const e=Math.min(6e3,n._player.renderFreezeAccTime);o.A_vrrft=Math.round(e).toString(),n._player.renderFreezeAccTime=Math.max(0,n._player.renderFreezeAccTime-e);}if(o.A_rvps=$y[n._player?n._player.videoElementStatus:"uninit"].toString(),i){const t=i.videoRecv.find((t=>t.ssrc===e));if(t&&void 0!==s.totalInterFrameDelay&&void 0!==s.totalSquaredInterFrameDelay&&void 0!==t.totalInterFrameDelay&&void 0!==t.totalSquaredInterFrameDelay){const e=s.totalInterFrameDelay-t.totalInterFrameDelay,i=s.totalSquaredInterFrameDelay-t.totalSquaredInterFrameDelay,n=s.framesDecodeCount-t.framesDecodeCount,r=e/n*1e3,a=Math.round(1e3*Math.sqrt((i-Math.pow(e,2)/n)/n));!isNaN(a)&&r+a>Math.max(3*r,r+150)&&(o.A_ifdsd=a.toString());}}return o}(r._videoSSRC,e,i,r.videoTrack,t):void 0;n&&AT((()=>{var e;return null===(e=this.requestUpload)||void 0===e?void 0:e.call(this,Sv.SUBSCRIBE_STATS,{stream_id:r.uid,stats:n})}));}if(s.has(hI.AUDIO)&&r.audioTrack){const t=r.audioTrack?function(e,t,i,n){const r=t.audioRecv.find((t=>t.ssrc===e));if(!r)return null;const s={id:xT(10,""),timestamp:new Date(t.timestamp).toISOString(),mediaType:"audio",type:"ssrc",ssrc:r.ssrc.toString()};if(s.bytesReceived=r.bytes.toString(),s.packetsLost=r.packetsLost.toString(),s.packetsReceived=r.packets.toString(),r.outputLevel?s.A_aol=Math.round(100*r.outputLevel).toString():s.A_aol=Math.round(100*n._source.getAccurateVolumeLevel()).toString(),s.A_apol=Math.round(100*n._source.getAccurateVolumeLevel()).toString(),n&&(s.A_artd=n._originMediaStreamTrack.enabled&&n._mediaStreamTrack.enabled?"0":"1"),s.A_jr=r.jitterMs.toString(),s.A_jbm=Math.floor(r.jitterBufferMs).toString(),s.A_cdm=Math.floor(r.jitterBufferMs).toString(),s.A_raps=$y[xA.getPlayerState(n.getTrackId())].toString(),i){const t=i.audioRecv.find((t=>t.ssrc===e));if(t){const e=r.concealedSamples-t.concealedSamples;e>0&&(s.A_cs=Math.round(e).toString());}}return s}(r._audioSSRC,e,i,r.audioTrack):void 0;t&&AT((()=>{var e;return null===(e=this.requestUpload)||void 0===e?void 0:e.call(this,Sv.SUBSCRIBE_STATS,{stream_id:r.uid,stats:t})}));}}));}uploadRelatedDownlinkStats(e,t){var i;((null===(i=this.requestRemoteMedia)||void 0===i?void 0:i.call(this))||[]).forEach((i=>{let[n,r]=i;if(r.has(hI.VIDEO)&&n.videoTrack){var s;const i=!0===(n._videoSSRC&&(null===(s=this.requestVideoIsReady)||void 0===s?void 0:s.call(this,n._videoSSRC))||!1),r=function(e,t,i,n,r,s){const o=i.videoRecv.find((t=>t.ssrc===e)),a=r?r.videoRecv.find((t=>t.ssrc===e)):void 0;if(!o)return null;const c=hD.isRemoteVideoFreeze(s,o,a)&&t,d={mediaType:"video",isVideoMute:!1,peerId:n,frameRateReceived:o.receivedFrame&&o.receivedFrame.frameRate.toString(),frameRateDecoded:o.decodedFrame&&o.decodedFrame.frameRate.toString(),isFreeze:c,bytesReceived:o.bytes.toString(),packetsReceived:o.packets.toString(),packetsLost:o.packetsLost.toString(),qpSumPerFrame:Math.floor(o.qpSumPerFrame).toString()};return o.framesRateFirefox&&(d.frameRateDecoded=o.framesRateFirefox.toString(),d.frameRateReceived=o.framesRateFirefox.toString()),d}(n._videoSSRC,i,e,n.uid,t,n.videoTrack);r&&AT((()=>{var e;null===(e=this.requestUpload)||void 0===e||e.call(this,Sv.SUBSCRIBE_RELATED_STATS,{stream_id:n.uid,stats:r});}));}if(r.has(hI.AUDIO)&&n.audioTrack){const t=function(e,t,i,n){const r=t.audioRecv.find((t=>t.ssrc===e));if(!r)return null;const s=hD.isRemoteAudioFreeze(n);return {mediaType:"audio",isAudioMute:!1,peerId:i,googJitterReceived:r.jitterMs.toString(),isFreeze:s,bytesReceived:r.bytes.toString(),packetsReceived:r.packets.toString(),packetsLost:r.packetsLost.toString(),frameReceived:r.receivedFrames.toString(),frameDropped:r.droppedFrames.toString()}}(n._audioSSRC,e,n.uid,n.audioTrack);t&&AT((()=>{var e;null===(e=this.requestUpload)||void 0===e||e.call(this,Sv.SUBSCRIBE_RELATED_STATS,{stream_id:n.uid,stats:t});}));}}));}stopUploadDownlinkStats(){this.uploadDownlinkStarted&&(this.uploadDownlinkStarted=!1,this.downlinkStatsUploadInterval&&window.clearInterval(this.downlinkStatsUploadInterval),this.downlinkRelatedStatsUploadInterval&&window.clearInterval(this.downlinkRelatedStatsUploadInterval),this.downlinkStatsUploadInterval=void 0,this.downlinkRelatedStatsUploadInterval=void 0);}stopUploadTransportStats(){this.uploadTransportStarted&&(this.uploadTransportStarted=!1,this.transportStatsUploadInterval&&window.clearInterval(this.transportStatsUploadInterval),this.transportStatsUploadInterval=void 0);}stopUploadExtensionUsageStats(){this.uploadExtensionUsageStarted&&(this.uploadExtensionUsageStarted=!1,this.extensionUsageStatsUploadInterval&&window.clearInterval(this.extensionUsageStatsUploadInterval),this.extensionUsageStatsUploadInterval=void 0);}uploadDownlinkExtensionStats(e){e.forEach((e=>{let[t,i]=e;if(i.has(hI.VIDEO)&&t.videoTrack){t.videoTrack.getProcessorStats().forEach((e=>{var t;null===(t=this.requestUpload)||void 0===t||t.call(this,e.type,e.stats);}));}if(i.has(hI.AUDIO)&&t.audioTrack){t.audioTrack.getProcessorStats().forEach((e=>{var t;null===(t=this.requestUpload)||void 0===t||t.call(this,e.type,e.stats);}));}}));}}function lk(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n);}return i}function hk(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?lk(Object(i),!0).forEach((function(t){nu(e,t,i[t]);})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):lk(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t));}));}return e}function uk(e){var t,i,n,r=2;for("undefined"!=typeof Symbol&&(i=WP,n=Symbol.iterator);r--;){if(i&&null!=(t=e[i]))return t.call(e);if(n&&null!=(t=e[n]))return new pk(t.call(e));i="@@asyncIterator",n="@@iterator";}throw new TypeError("Object is not async iterable")}function pk(e){function t(e){if(Object(e)!==e)return tg.reject(new TypeError(e+" is not an object."));var t=e.done;return tg.resolve(e.value).then((function(e){return {value:e,done:t}}))}return pk=function(e){this.s=e,this.n=e.next;},pk.prototype={s:null,n:null,next:function(){return t(this.n.apply(this.s,arguments))},return:function(e){var i=this.s.return;return void 0===i?tg.resolve({value:e,done:!0}):t(i.apply(this.s,arguments))},throw:function(e){var i=this.s.return;return void 0===i?tg.reject(e):t(i.apply(this.s,arguments))}},new pk(e)}class _k extends iT{get state(){return this._state}set state(e){const t=this._state;this._state=e,this.emit(mI.StateChange,t,this._state);}constructor(e,t){super(),nu(this,"store",void 0),nu(this,"statsUploader",void 0),nu(this,"connection",void 0),nu(this,"localTrackMap",new Map),nu(this,"remoteUserMap",new Map),nu(this,"localDataChannels",[]),nu(this,"remoteDataChannelMap",new Map),nu(this,"pendingLocalTracks",[]),nu(this,"pendingRemoteTracks",[]),nu(this,"pendingLocalDataChannels",[]),nu(this,"pendingRemoteDataChannels",[]),nu(this,"statsCollector",void 0),nu(this,"isPlanB",!1),nu(this,"shouldForwardP2PCreation",void 0),nu(this,"iceFailedCount",0),nu(this,"dtlsFailedCount",0),nu(this,"mutex",new YT("P2PChannel-mutex")),nu(this,"_state",EI.Disconnected),nu(this,"_pcStatsUploadType",kC("NEW_ICE_RESTART")?pI.FIRST_CONNECTION:pI.OLD_FIRST_CONNECTION),nu(this,"_isInRestartIce",!1),nu(this,"_isStartRestartIce",!1),nu(this,"_restartStates",["disconnected","failed"]),nu(this,"_restartTimer",void 0),nu(this,"_isFirstConnected",!0),nu(this,"handleMuteLocalTrack",(async(e,t,i)=>{const n=await this.mutex.lock("Locking from P2PChannel.handleMuteLocalTrack");try{if(!this.connection||this.state!==EI.Connected)return void i(new Vg(xg.INVALID_OPERATION,"Cannot call P2PChannel.handleMuteLocalTrack before connection established."));const r=this.filterTobeMutedTracks(e);if(0===r.length)return void t();const s=r.find((e=>"videoLowTrack"===e[0]));if(s){s[1].track._originMediaStreamTrack.stop();}await this.connection.muteLocal(r.map((e=>{let[,{id:t}]=e;return t})));const o=this.createMuteMessage(r);await gT(this,mI.RequestMuteLocal,o),t();}catch(e){i(e);}finally{n();}})),nu(this,"handleUnmuteLocalTrack",(async(e,t,i)=>{const n=await this.mutex.lock("Locking from P2PChannel.handleUnmuteLocalTrack");try{if(!this.connection||this.state!==EI.Connected)return void i(new Vg(xg.INVALID_OPERATION,"Cannot call P2PChannel.handleUnmuteLocalTrack before connection established."));const r=this.filterTobeUnmutedTracks(e);if(0===r.length)return void t();const s=r.find((e=>"videoLowTrack"===e[0]));if(s){const t=s[1];if(t.track._originMediaStreamTrack.stop(),!kC("DISABLE_DUAL_STREAM_USE_ENCODING")&&_A().supportDualStreamEncoding){const i=e._mediaStreamTrack.clone();t.track._mediaStreamTrack=i,t.track._originMediaStreamTrack=i;}else {const i=KL(e,ST(this,mI.RequestLowStreamParameter));t.track._mediaStreamTrack=i,t.track._originMediaStreamTrack=i;}await new tg(((e,i)=>{this.handleReplaceTrack(t.track,e,i,!0);}));}await this.connection.unmuteLocal(r.map((e=>{let[,{id:t}]=e;return t})));const o=this.createUnmuteMessage(r);await gT(this,mI.RequestUnmuteLocal,o),t();}catch(e){i(e);}finally{n();}})),nu(this,"handleUpdateVideoEncoder",(async(e,t,i)=>{const n=await this.mutex.lock("Locking from P2PChannel.handleSetVideoEncoder");try{const i=this.localTrackMap.get(_I.LocalVideoTrack);if(!this.connection||!i||i.track!==e||this.state!==EI.Connected)return void t();const{id:r,track:s}=i;await this.connection.updateSendParameters(r,s),await this.connection.updateEncoderConfig(r,s),this.emit(mI.UpdateVideoEncoder,s),t();}catch(e){i(e);}finally{n();}})),nu(this,"handleSetOptimizationMode",(async(e,t,i)=>{const n=await this.mutex.lock("Locking from P2PChannel.handleSetOptimizationMode");try{const i=this.localTrackMap.get(_I.LocalVideoTrack);if(!this.connection||!i||i.track!==e||this.state!==EI.Connected)return;const{id:r,track:s}=i;await this.connection.updateSendParameters(r,s),t();}catch(e){i(e);}finally{n();}})),nu(this,"handleReplaceTrack",(async(e,t,i,n)=>{let r;KC.debug("[".concat(this.store.clientId,"] P2PChannel handleReplaceTrack for [track-id-").concat(e.getTrackId(),"]")),"boolean"==typeof n&&n||(r=await this.mutex.lock("From P2PChannel.handleReplaceTrack"));try{var s;const i=Array.from(this.localTrackMap.entries()).find((t=>{let[,{track:i}]=t;return e===i}));if(!this.connection||!i||this.state!==EI.Connected)return void t();if(await(null===(s=this.connection)||void 0===s?void 0:s.replaceTrack(e,i[1].id)),this.isPlanB){const t=i[1];t.id=e._mediaStreamTrack.id,this.localTrackMap.set(i[0],t);}if(i[0]===_I.LocalVideoTrack&&!kC("DISABLE_DUAL_STREAM_USE_ENCODING")&&_A().supportDualStreamEncoding){const t=this.localTrackMap.get(_I.LocalVideoLowTrack);if(t){const i=e._mediaStreamTrack.clone();t.track._originMediaStreamTrack.stop(),t.track._mediaStreamTrack=i,t.track._originMediaStreamTrack=i,await new tg(((e,i)=>{this.handleReplaceTrack(t.track,e,i,!0);}));}}t();}catch(e){i(e);}finally{var o;null===(o=r)||void 0===o||o();}})),nu(this,"handleGetRTCStats",(e=>{e(this.statsCollector.getRTCStats());})),nu(this,"handleGetLocalVideoStats",(e=>{e(this.statsCollector.getLocalVideoTrackStats());})),nu(this,"handleGetLocalAudioStats",(e=>{e(this.statsCollector.getLocalAudioTrackStats());})),nu(this,"handleGetRemoteVideoStats",(e=>this.statsCollector.getRemoteVideoTrackStats(e.uid)[e.uid])),nu(this,"handleGetRemoteAudioStats",(e=>this.statsCollector.getRemoteAudioTrackStats(e.uid)[e.uid])),this.store=e,this.statsCollector=t,this.statsCollector.addP2PChannel(this),this.statsUploader=new dk,this.bindStatsUploaderEvents(),this.isPlanB=!_A().supportUnifiedPlan||kC("CHROME_FORCE_PLAN_B")&&kg(),this.shouldForwardP2PCreation=kC("FORWARD_P2P_CREATION")&&_A().supportPCSetConfiguration&&function(){const e=_g();return e===ag.ANDROID||e===ag.IOS||e===ag.HARMONY_OS}(),this.shouldForwardP2PCreation&&(this.connection=this.store.useDataChannel?new sk({},this.store):this.isPlanB?new ML({},this.store):new WL({},this.store),this.bindConnectionEvents(this.connection));}async startP2PConnection(e,t){var i;this.state=EI.New;const n=this.shouldForwardP2PCreation&&"closed"===(null===(i=this.connection)||void 0===i?void 0:i.peerConnectionState);if(this.shouldForwardP2PCreation&&!n||(n&&this.connection&&(KC.warning("[".concat(this.store.clientId,"] P2PChannel.startP2PConnection ForwardP2P closed.")),this.connection.close(),this.unbindConnectionEvents(this.connection)),this.connection=this.store.useDataChannel?new sk(e,this.store):this.isPlanB?new ML(e,this.store):new WL(e,this.store),this.bindConnectionEvents(this.connection)),!this.connection)throw new Vg(xg.UNEXPECTED_ERROR,"Cannot P2PChannel.startConnection before P2PConnection initialization .");return this._pcStatsUploadType=kC("NEW_ICE_RESTART")?pI.FIRST_CONNECTION:pI.OLD_FIRST_CONNECTION,this._isFirstConnected=!0,this._isInRestartIce=!1,this._isStartRestartIce=!1,this.connection.setConfiguration(e),this.connection.establishPromise}async connect(e,t,i,n,r,s){if(!this.connection)throw new Vg(xg.UNEXPECTED_ERROR,"Cannot P2PChannel.connect before P2PChannel.startP2PConnection .");this.connection instanceof sk?this.connection.updateRemoteConnect(n):(this.store.peerConnectionStart(),await this.connection.connect(e,t,i,n,r,s),this.statsUploader.startUploadTransportStats(),this.statsUploader.startUploadExtensionUsageStats(),this.state=EI.Connected);}updateRemoteRTPCapabilities(e){const t=Array.from(this.localTrackMap.entries()).filter((e=>{var t;let[i]=e;return Pr(t=[_I.LocalVideoLowTrack,_I.LocalVideoTrack]).call(t,i)})).map((e=>{let[,{id:t}]=e;return t}));if(this.connection instanceof WL){if(!Pr(e).call(e,this.store.codec)){const t=["vp8","h264"].find((t=>Pr(e).call(e,t)));t&&(this.store.codec=t,KC.debug("[".concat(this.store.clientId,"] [").concat(this.store.p2pId," updateRemoteRTPCapabilities] default codec is not available, hence the fallback to ").concat(t,".")));}this.connection.updateRemoteRTPCapabilities(t,e);}}async preConnect(e,t,i,n,r,s){if(!this.connection)throw new Vg(xg.UNEXPECTED_ERROR,"Cannot P2PChannel.connect before P2PChannel.startP2PConnection .");this.store.peerConnectionStart();const o=await this.connection.connect(e,t,i,n,r,s);return this.statsUploader.startUploadTransportStats(),this.statsUploader.startUploadExtensionUsageStats(),this.state=EI.Connected,o}getEstablishParams(){if(this.connection instanceof sk)return this.connection.getP2PConnectionParams();throw new Error("Only DataChannelConnection needs to obtain establishParams")}async publishDataChannel(e){if(!this.connection){if(this.state===EI.Disconnected)throw new Vg(xg.UNEXPECTED_ERROR,"PeerConnection already disconnected.");const t=e.filter((e=>-1!==this.pendingLocalDataChannels.findIndex((t=>t.id===e.id))));return void(this.pendingLocalDataChannels=this.pendingLocalDataChannels.concat(t))}const t=this.filterTobePublishedDataChannels(e);0!==t.length&&(t.forEach((e=>{const t=Date.now();this.store.publish(e.id.toString(),"datachannel",t);})),await this.connection.createDataChannels(this.store.uid,t),t.forEach((e=>{this.localDataChannels.push(e);const t=Date.now();this.store.publish(e.id+"","datachannel",void 0,t);})));}publish(e,t,i){var n=this;return BP((function*(){const r=yield jP(n.mutex.lock("From P2PChannel.publish"));try{if(!n.connection||n.state!==EI.Connected){if(n.state===EI.Disconnected)throw new Vg(xg.UNEXPECTED_ERROR,"PeerConnection already disconnected.");n.throwIfTrackTypeNotMatch(e);const t=e.filter((e=>-1===n.pendingLocalTracks.indexOf(e)));return void(n.pendingLocalTracks=n.pendingLocalTracks.concat(t))}n.store.pubId=n.store.pubId+1,cD.markPublishStart(n.store.clientId,n.store.pubId);const s=n.filterTobePublishedTracks(e,t,i);if(0===s.length)return void(yield jP(n.tryToUnmuteAudio(e)));yield*GP(uk(n.doPublish(n.connection,s)));}finally{r();}}))()}doPublish(e,t){var i=this;return BP((function*(){t.forEach((e=>{let{track:t,type:n}=e;const r=Date.now();i.store.publish(t.getTrackId(),n===_I.LocalAudioTrack?"audio":"video",r);})),i.bindLocalTrackEvents(t);const n=yield jP(e.send(t.map((e=>{let{track:t}=e;return t})),i.store.codec,i.store.audioCodec)),r=(yield jP(n.next())).value,s=i.createGatewayPublishMessage(t,r);let o;try{o=yield s;}catch(e){throw n.throw(e),(null==e?void 0:e.code)===xg.WS_ABORT&&t.forEach((e=>{let{track:t}=e;-1===i.pendingLocalTracks.indexOf(t)&&i.pendingLocalTracks.push(t);})),i.unbindLocalTrackEvents(t),e}const a=i.mapPubResToRemoteConfig(s,o),c=(yield jP(n.next(a))).value;t.forEach((e=>{let{type:t}=e;i.statsCollector.addLocalStats(t);})),i.assignLocalTracks(t,c),i.statsUploader.startUploadUplinkStats(),t.forEach((e=>{let{track:t,type:n}=e;const r=Date.now();i.store.publish(t.getTrackId(),n===_I.LocalAudioTrack?"audio":"video",void 0,r);}));}))()}async updateVideoStreamParameter(e,t){const i=this.localTrackMap.get(t);if(!i)return;if(!(i.track instanceof Sb))return KC.warn("[updateVideoStreamParameter]: track is not an instance of LocalVideoTrack");if(!(this.connection instanceof WL||this.connection instanceof ML))return KC.warn("[updateVideoStreamParameter]: connection is not P2PConnection or P2PConnectionPlanB");const{track:n}=i,r=function(e,t){const i={};return e.height&&e.width&&(i.scaleResolutionDownBy=CD(e,t)),i.maxFramerate=e.framerate?mD(e.framerate):void 0,i.maxBitrate=e.bitrate?1e3*e.bitrate:void 0,i}(e,n);if(n._encoderConfig||(n._encoderConfig={}),t!==_I.LocalVideoLowTrack||!kC("DISABLE_DUAL_STREAM_USE_ENCODING")&&_A().supportDualStreamEncoding)null!=r.scaleResolutionDownBy&&(n._encoderConfig.scaleResolutionDownBy=r.scaleResolutionDownBy);else {const t=n._originMediaStreamTrack;if(!t.canvas)return KC.warn("[".concat(n.getTrackId(),"] no canvas on track"));!function(e,t){const i=e.canvas;t.width&&(i.width=mD(t.width)),t.height&&(i.height=mD(t.height)),t.framerate&&(i.stopCapture&&i.stopCapture(),i.stopCapture=uA((()=>{!i.startCapture&&i.stopCapture&&i.stopCapture(),i.startCapture&&i.startCapture();}),mD(t.framerate)));}(t,e);}null!=r.maxBitrate&&(n._encoderConfig.bitrateMax=r.maxBitrate/1e3),null!=r.maxFramerate&&(n._encoderConfig.frameRate&&"object"==typeof n._encoderConfig.frameRate?n._encoderConfig.frameRate.max=r.maxFramerate:n._encoderConfig.frameRate={max:r.maxFramerate}),KC.debug("[".concat(n.getTrackId(),"] LowStreamEncoderConfig: , ").concat(JSON.stringify(n._encoderConfig))),await this.connection.updateRtpSenderEncodings(n);}publishLowStream(e){var t=this;return BP((function*(){if(!t.connection||t.state!==EI.Connected)return;const i=yield jP(t.mutex.lock("Locking from P2PChannel.publishLowStream"));try{const r=t.localTrackMap.get(_I.LocalVideoTrack);if(!r)throw new Vg(xg.UNEXPECTED_ERROR,"Could not find high stream");if(t.localTrackMap.has(_I.LocalVideoLowTrack))throw new Vg(xg.UNEXPECTED_ERROR,"[".concat(t.store.clientId,"] Can't publish low stream when stream already publish"));const s=[{track:t.getLowVideoTrack(r.track,e),type:_I.LocalVideoLowTrack}];if(yield*GP(uk(t.doPublish(t.connection,s))),r.track.muted||!r.track.enabled){var n;const e=null===(n=t.localTrackMap.get(_I.LocalVideoLowTrack))||void 0===n?void 0:n.id;void 0!==e&&(yield jP(t.connection.muteLocal([e])));}}finally{i();}}))()}async republish(){this.pendingLocalTracks.length>0&&(KC.debug("[".concat(this.store.clientId,"] Emit P2PChannelEvents.RequestRePublish to republish tracks.")),await fT(this,mI.RequestRePublish,this.pendingLocalTracks),this.emit(mI.MediaReconnectEnd,this.store.uid),this.pendingLocalTracks=[]),this.pendingLocalDataChannels.length>0&&(KC.debug("Emit P2PChannelEvents.RequestRePublishDataChannel to republish datachannels."),await fT(this,mI.RequestRePublishDataChannel,this.pendingLocalDataChannels),this.pendingLocalDataChannels=[]);}async reSubscribe(e){for(let e=this.pendingRemoteTracks.length-1;e>=0;e--){const{user:t,kind:i}=this.pendingRemoteTracks[e];(i!==hI.AUDIO||t._audio_added_&&t._audioSSRC)&&(i!==hI.VIDEO||t._video_added_&&t._videoSSRC)||this.pendingRemoteTracks.splice(e,1);}if(e)await fT(this,mI.RequestReSubscribe,this.pendingRemoteTracks);else for(const{user:e,kind:t}of this.pendingRemoteTracks)await this.subscribe(e,t,t===hI.VIDEO?e._videoSSRC:e._audioSSRC);this.pendingRemoteTracks.forEach((e=>{let{user:t}=e;this.emit(mI.MediaReconnectEnd,t.uid);})),this.pendingRemoteTracks=[];}async unpublish(e){if(!this.connection||this.state!==EI.Connected)return void e.forEach((e=>{const t=this.pendingLocalTracks.indexOf(e);-1!==t&&this.pendingLocalTracks.splice(t,1);}));const t=this.filterTobeUnpublishedTracks(e);if(0===t.length)return;const i=t.find((e=>"videoLowTrack"===e[0]));if(i){i[1].track.close();}return this.doUnpublish(this.connection,t)}async unpublishDataChannel(e){if(!this.connection||this.state!==EI.Connected)return void e.forEach((e=>{const t=this.pendingLocalDataChannels.indexOf(e);-1!==t&&this.pendingLocalDataChannels.splice(t,1);}));const t=this.filterTobeUnpublishedDataChannels(e);return 0!==t.length?(t.forEach((e=>{const t=this.localDataChannels.indexOf(e);-1!==t&&this.localDataChannels.splice(t,1);})),0===this.localDataChannels.length&&await this.connection.stopDataChannels(this.store.uid),t.map((e=>e.id))):void 0}async unpublishLowStream(){if(!this.connection||this.state!==EI.Connected)return;const e=this.localTrackMap.get(_I.LocalVideoLowTrack);if(!e)return;e.track.close();const t=[[_I.LocalVideoLowTrack,e]];return this.doUnpublish(this.connection,t)}async doUnpublish(e,t){const i=this.createGatewayUnpublishMessage(t);return await e.stopSending(t.map((e=>{let[,{id:t}]=e;return t}))),this.withdrawLocalTracks(t),this.unbindLocalTrackEvents(t.map((e=>{let[t,{track:i}]=e;return {type:t,track:i}}))),t.forEach((e=>{let[t]=e;this.statsCollector.removeLocalStats(t);})),0===this.localTrackMap.size&&this.statsUploader.stopUploadUplinkStats(),i}async subscribeDataChannel(e,t){if(!this.connection||this.state!==EI.Connected)throw new Vg(xg.INVALID_OPERATION,"Cannot subscribe remote user when peerConnection disconnected.");const i=t.filter((t=>{var i;return !(null!==(i=this.remoteDataChannelMap.get(e))&&void 0!==i&&i.get(t.id))}));if(0!==i.length)return await this.connection.createDataChannels(e.uid,i),i.forEach((t=>{var i;this.remoteDataChannelMap.has(e)?null===(i=this.remoteDataChannelMap.get(e))||void 0===i||i.set(t.id,t):this.remoteDataChannelMap.set(e,new Map([[t.id,t]]));const n=this.pendingRemoteDataChannels.findIndex((i=>{let{user:n,id:r}=i;return n.uid===e.uid&&r===t.id}));-1!==n&&this.pendingRemoteDataChannels.splice(n,1);})),i.map((e=>e.id))}async subscribe(e,t,i,n,r){var s;if(!this.connection||this.state!==EI.Connected)throw new Vg(xg.INVALID_OPERATION,"Cannot subscribe remote user when peerConnection disconnected.");if(null!==(s=this.remoteUserMap.get(e))&&void 0!==s&&s.has(t))return;let o,a,c;if(r){const i=r.find((e=>{let{stream_type:i}=e;return i===t}));if(!i)throw new Vg(xg.UNEXPECTED_ERROR,"Cannot subscribe to remote ".concat(t," for user: ").concat(e.uid," because subscribe answer from gateway does not contain stream_type: ").concat(t,"."));const n=await this.connection.receive(t,i.ssrcs,String(e._uintid),i.attributes);this.connection instanceof WL&&(c=n.transceiver),o=n.track,a=n.id;}else {const r=await this.connection.receive(t,[{ssrcId:i,rtx:n}],String(e._uintid),void 0);this.connection instanceof WL&&(c=r.transceiver),o=r.track,a=r.id;}t===hI.AUDIO?(e._audioTrack?e._audioTrack._updateOriginMediaStreamTrack(o):(e._audioTrack=new Ob(o,e.uid,e._uintid,this.store),KC.info("[".concat(this.store.clientId,"] [").concat(this.store.p2pId,"] create remote audio track: ").concat(e._audioTrack.getTrackId()))),c&&e._audioTrack._updateRtpTransceiver(c),this.bindRemoteTrackEvents(e,e._audioTrack)):(e._videoTrack?e._videoTrack._updateOriginMediaStreamTrack(o):(e._videoTrack=new wb(o,e.uid,e._uintid,this.store),KC.info("[".concat(this.store.clientId,"] [").concat(this.store.p2pId,"] create remote video track: ").concat(e._videoTrack.getTrackId()))),c&&e._videoTrack._updateRtpTransceiver(c),this.bindRemoteTrackEvents(e,e._videoTrack));const d=this.remoteUserMap.get(e);d?d.set(t,a):this.remoteUserMap.set(e,new Map([[t,a]])),this.statsCollector.addRemoteStats(e.uid),this.statsUploader.startUploadDownlinkStats();const l=this.pendingRemoteTracks.findIndex((i=>{let{user:n,kind:r}=i;return n.uid===e.uid&&t===r}));-1!==l&&(this.pendingRemoteTracks.splice(l,1),this.emit(mI.MediaReconnectEnd,e.uid));}async massSubscribe(e){return this.massSubscribeNoLock(e)}async massSubscribeNoLock(e){if(!this.connection||this.state!==EI.Connected)throw new Vg(xg.INVALID_OPERATION,"Cannot subscribeAll remote users when peerConnection disconnected.");e=e.filter((e=>{var t;let{user:i,mediaType:n}=e;return !(null!==(t=this.remoteUserMap.get(i))&&void 0!==t&&t.has(n))}));const t=await this.connection.batchReceive(e.map((e=>{let{user:t,mediaType:i,ssrcId:n,rtxSsrcId:r}=e;return {kind:i,ssrcMsg:[{ssrcId:n,rtx:r}],mslabel:String(t._uintid)}})));e.forEach(((e,i)=>{let{user:n,mediaType:r}=e;const{track:s,id:o,transceiver:a}=t[i];r===hI.AUDIO?(n._audioTrack?n._audioTrack._updateOriginMediaStreamTrack(s):(n._audioTrack=new Ob(s,n.uid,n._uintid,this.store),KC.info("[".concat(this.store.clientId,"] [").concat(this.store.p2pId,"] create remote audio track: ").concat(n._audioTrack.getTrackId()))),a&&n._audioTrack._updateRtpTransceiver(a),this.bindRemoteTrackEvents(n,n._audioTrack)):(n._videoTrack?n._videoTrack._updateOriginMediaStreamTrack(s):(n._videoTrack=new wb(s,n.uid,n._uintid,this.store),KC.info("[".concat(this.store.clientId,"] [").concat(this.store.p2pId,"] create remote video track: ").concat(n._videoTrack.getTrackId()))),a&&n._videoTrack._updateRtpTransceiver(a),this.bindRemoteTrackEvents(n,n._videoTrack));const c=this.remoteUserMap.get(n);c?c.set(r,o):this.remoteUserMap.set(n,new Map([[r,o]])),this.statsCollector.addRemoteStats(n.uid),this.statsUploader.startUploadDownlinkStats();const d=this.pendingRemoteTracks.findIndex((e=>{let{user:t,kind:i}=e;return t.uid===n.uid&&r===i}));-1!==d&&(this.pendingRemoteTracks.splice(d,1),this.emit(mI.MediaReconnectEnd,n.uid));}));}async unsubscribe(e,t,i){const n=this.pendingRemoteTracks.filter((i=>{let{user:n,kind:r}=i;return void 0!==t?n.uid===e.uid&&t===r:n.uid===e.uid}));if(n.forEach((e=>{const t=this.pendingRemoteTracks.indexOf(e);this.pendingRemoteTracks.splice(t,1);})),this.connection&&this.state===EI.Connected||i||n.forEach((t=>{let{kind:i}=t;var n;if(i===hI.AUDIO)null===(n=e._audioTrack)||void 0===n||n._destroy(),e._audioTrack=void 0;else if(i===hI.VIDEO){var r;null===(r=e._videoTrack)||void 0===r||r._destroy(),e._videoTrack=void 0;}})),!this.connection||this.state!==EI.Connected)return;const r=this.filterTobeUnSubscribedTracks(e,t);if(0===r.length)return;await this.connection.stopReceiving(r.map((e=>{let[,{id:t}]=e;return t})));const s=this.createUnsubscribeMessage(r);return this.withdrawRemoteTracks(r),0===this.remoteUserMap.size&&this.statsUploader.stopUploadDownlinkStats(),r.forEach((e=>{let[t,{kind:n}]=e;var r,s;n===hI.VIDEO&&t._videoSSRC&&(null===(r=this.connection)||void 0===r||r.setStatsRemoteVideoIsReady(t._videoSSRC,!1));if(n===hI.VIDEO)this.unbindRemoteTrackEvents(t._videoTrack),i||(null===(s=t._videoTrack)||void 0===s||s._destroy(),t._videoTrack=void 0);else if(n===hI.AUDIO){var o;if(this.unbindRemoteTrackEvents(t._audioTrack),!i)null===(o=t._audioTrack)||void 0===o||o._destroy(),t._audioTrack=void 0;}})),s}async unsubscribeDataChannel(e,t){if(t.forEach((e=>{const t=this.pendingRemoteDataChannels.findIndex((t=>t.id===e.id));-1!==t&&this.pendingRemoteDataChannels.splice(t,1);})),!this.connection)return;const i=this.filterTobeUnSubscribedDataChannels(e,t);if(0===i.length)return;t.forEach((e=>{e._close();}));const n=this.remoteDataChannelMap.get(e);return i.forEach((e=>{n&&n.delete(e.id);})),n&&0===n.size&&(this.remoteDataChannelMap.delete(e),await this.connection.stopDataChannels(e.uid)),i.map((e=>e.id))}async massUnsubscribe(e){return this.massUnsubscribeNoLock(e)}async massUnsubscribeNoLock(e){let t=[];for(const{user:i,mediaType:n}of e){const e=this.pendingRemoteTracks.filter((e=>{let{user:t,kind:r}=e;return void 0!==n?t.uid===i.uid&&n===r:t.uid===i.uid}));e.forEach((e=>{const t=this.pendingRemoteTracks.indexOf(e);this.pendingRemoteTracks.splice(t,1);})),t=t.concat(e);}if(!this.connection||this.state!==EI.Connected)return void t.forEach((e=>{let{user:t,kind:i}=e;var n;if(i===hI.AUDIO)null===(n=t._audioTrack)||void 0===n||n._destroy(),t._audioTrack=void 0;else if(i===hI.VIDEO){var r;null===(r=t._videoTrack)||void 0===r||r._destroy(),t._videoTrack=void 0;}}));const i=cS(e).call(e,((e,t)=>{let{user:i,mediaType:n}=t;const r=this.filterTobeUnSubscribedTracks(i,n);return e.concat(r)}),[]);if(0===i.length)return;await this.connection.stopReceiving(i.map((e=>{let[,{id:t}]=e;return t})));const n=this.createUnsubscribeAllMessage(i);return this.withdrawRemoteTracks(i),0===this.remoteUserMap.size&&this.statsUploader.stopUploadDownlinkStats(),i.forEach((e=>{let[t,{kind:i}]=e;var n,r;i===hI.VIDEO&&t._videoSSRC&&(null===(n=this.connection)||void 0===n||n.setStatsRemoteVideoIsReady(t._videoSSRC,!1));if(i===hI.VIDEO)this.unbindRemoteTrackEvents(t._videoTrack),null===(r=t._videoTrack)||void 0===r||r._destroy(),t._videoTrack=void 0;else if(i===hI.AUDIO){var s;this.unbindRemoteTrackEvents(t._audioTrack),null===(s=t._audioTrack)||void 0===s||s._destroy(),t._audioTrack=void 0;}})),n}async muteRemote(e,t){if(!this.connection)return;const i=this.remoteUserMap.get(e);if(!i)return void KC.warning("[".concat(this.store.clientId,"] P2PChannel.muteRemote has no remote user ").concat(e.uid,"."));if(!i.get(t))return void KC.warning("[".concat(this.store.clientId,"] P2PChannel.muteRemote has no remote user ").concat(e.uid," media type ").concat(t,"."));const n=t===hI.VIDEO?e._videoSSRC:e._audioSSRC;void 0!==n&&this.connection.setStatsRemoteVideoIsReady(n,!1);}async unmuteRemote(e,t){return this.unmuteRemoteNoLock(e,t)}async unmuteRemoteNoLock(e,t){if(!this.connection)return;const i=this.remoteUserMap.get(e);if(!i)return void KC.warning("[".concat(this.store.clientId,"] P2PChannel.unmuteRemote has no remote user ").concat(e.uid,"."));i.get(t)||KC.warning("[".concat(this.store.clientId,"] P2PChannel.unmuteRemote has no remote user ").concat(e.uid," media type ").concat(t,"."));}getAllTracks(e){const t=this.localTrackMap.get(_I.LocalAudioTrack);if((null==t?void 0:t.track)instanceof tb){const i=t.track;return Array.from(this.localTrackMap.entries()).filter((e=>{let[t]=e;return t!==_I.LocalAudioTrack})).filter((t=>{let[i]=t;return !(e&&i===_I.LocalVideoLowTrack)})).map((e=>{let[,{track:t}]=e;return t})).concat(i.trackList)}return Array.from(this.localTrackMap.entries()).filter((t=>{let[i]=t;return !(e&&i===_I.LocalVideoLowTrack)})).map((e=>{let[,{track:t}]=e;return t}))}getAllDataChannels(){return this.localDataChannels}reportPublishEvent(e,t,i,n,r){if(e){const i=this.localTrackMap.get(_I.LocalAudioTrack),s=n?this.localTrackMap.get(_I.LocalVideoLowTrack):this.localTrackMap.get(_I.LocalVideoTrack);rv.publish(this.store.sessionId,{eventElapse:cD.measureFromPublishStart(this.store.clientId,this.store.pubId),succ:e,ec:t,audioName:null==i?void 0:i.track.getTrackLabel(),videoName:null==s?void 0:s.track.getTrackLabel(),screenshare:-1!==(null==s?void 0:s.track._hints.indexOf(ky.SCREEN_TRACK)),audio:!!i,video:!!s,p2pid:this.store.p2pId,publishRequestid:this.store.pubId,extend:r});}else {var s;i||(i=[]);const o=i.find((e=>e instanceof ZA)),a=n?null===(s=this.localTrackMap.get(_I.LocalVideoTrack))||void 0===s?void 0:s.track:i.find((e=>e instanceof Sb));rv.publish(this.store.sessionId,{eventElapse:cD.measureFromPublishStart(this.store.clientId,this.store.pubId),succ:e,ec:t,audioName:null==o?void 0:o.getTrackLabel(),videoName:null==a?void 0:a.getTrackLabel(),screenshare:-1!==(null==a?void 0:a._hints.indexOf(ky.SCREEN_TRACK)),audio:!!o,video:!!a,p2pid:this.store.p2pId,publishRequestid:this.store.pubId,extend:r});}}reportSubscribeEvent(e,t,i,n){const r=n===hI.VIDEO?i._videoSSRC:i._audioSSRC;r&&rv.subscribe(this.store.sessionId,{succ:e,ec:t,video:n===hI.VIDEO,audio:n===hI.AUDIO,peerid:i.uid,subscribeRequestid:n===hI.VIDEO?i._videoSSRC:i._audioSSRC,p2pid:this.store.p2pId,eventElapse:cD.measureFromSubscribeStart(this.store.clientId,r)});}reset(){KC.debug("[".concat(this.store.clientId,"] P2PChannel.reset")),this.mutex=new YT("P2PChannel-mutex"),this.connection&&(this.connection.close(),this.unbindConnectionEvents(this.connection),this.connection=void 0),this.shouldForwardP2PCreation&&(this.connection=this.store.useDataChannel?new sk({},this.store):this.isPlanB?new ML({},this.store):new WL({},this.store),this.bindConnectionEvents(this.connection)),this.statsUploader.stopUploadUplinkStats(),this.statsUploader.stopUploadDownlinkStats(),this.statsUploader.stopUploadTransportStats(),this.statsUploader.stopUploadExtensionUsageStats(),this.unbindLocalTrackEvents(),this.unbindAllRemoteTrackEvents(),this.unbindRtpTransceiver();const e=this.localTrackMap.get(_I.LocalAudioTrack);if((null==e?void 0:e.track)instanceof tb){if(e.track.trackList.length>0){const t=e.track;e.track.trackList.forEach((e=>{t.removeAudioTrack(e);}));}e.track.close();}this.localTrackMap.clear(),this.remoteUserMap.clear(),this.statsCollector.removeRemoteStats(),this.statsCollector.removeLocalStats(),this.iceFailedCount=0,this.dtlsFailedCount=0,this.pendingLocalTracks=[],this.pendingRemoteTracks=[],this.localDataChannels=[],this.remoteDataChannelMap.clear(),this.pendingLocalDataChannels=[],this.pendingRemoteDataChannels=[],this.state=EI.Disconnected;}getStats(){var e;return null===(e=this.connection)||void 0===e?void 0:e.getStats()}getRemoteVideoIsReady(e){var t;return (null===(t=this.connection)||void 0===t?void 0:t.getRemoteVideoIsReady(e))||!1}getLocalAudioVolume(){const e=this.localTrackMap.get(_I.LocalAudioTrack);if(e)return e.track.getVolumeLevel()}getLocalVideoSize(){const e=this.localTrackMap.get(_I.LocalVideoTrack);if(e)return {width:e.track._videoWidth||0,height:e.track._videoHeight||0}}getEncoderConfig(e){const t=this.localTrackMap.get(e);return t&&t.track instanceof Sb||t&&t.track instanceof ZA?t.track._encoderConfig:void 0}getLocalMedia(e){return this.localTrackMap.get(e)}hasLocalMedia(){return this.localTrackMap.size>0}hasRemoteMedia(e,t){if(!e)return this.remoteUserMap.size>0;const i=this.remoteUserMap.get(e);return !!i&&(!t||i.has(t))}async hasRemoteMediaWithLock(e,t){if(!e)return this.remoteUserMap.size>0;const i=this.remoteUserMap.get(e);return !!i&&(!t||i.has(t))}getRemoteMedia(e){var t;const i=Array.from(hu(t=this.remoteUserMap).call(t)).find((t=>t.uid===e));return i?{audioTrack:i.audioTrack,audioSSRC:i._audioSSRC,videoTrack:i.videoTrack,videoSSRC:i._videoSSRC}:{}}getAudioLevels(){let e=Array.from(this.remoteUserMap.entries()).map((e=>{let[t]=e;return {uid:t.uid,level:t.audioTrack?100*t.audioTrack._source.getAccurateVolumeLevel():0}}));const t=this.localTrackMap.get(_I.LocalAudioTrack);return t&&e.push({level:100*t.track._source.getAccurateVolumeLevel(),uid:this.store.uid}),e=Zu(e).call(e,((e,t)=>e.level-t.level)),e}async disconnectForReconnect(){this.connection&&(KC.debug("[".concat(this.store.clientId,"] P2PChannel.disconnectForReconnect closing P2PConnection")),this.state=EI.Reconnecting,kC("KEEP_LAST_FRAME")&&0!==this.remoteUserMap.size&&Array.from(this.remoteUserMap.entries()).forEach((e=>{let[t]=e;var i;t._videoTrack&&t._videoTrack._player&&(null===(i=t._videoTrack._player.getVideoElement())||void 0===i||i.pause(),t._videoTrack._player.isKeepLastFrame=!0,t._videoTrack._originMediaStreamTrack.stop());})),this.connection.close(),this.unbindConnectionEvents(this.connection),this.connection=void 0,this.shouldForwardP2PCreation&&(this.connection=this.store.useDataChannel?new sk({},this.store):this.isPlanB?new ML({},this.store):new WL({},this.store),this.bindConnectionEvents(this.connection)),0!==this.localTrackMap.size&&(Array.from(this.localTrackMap.entries()).forEach((e=>{var t;let[i,{track:n}]=e;switch(i){case _I.LocalVideoTrack:Pr(t=n._hints).call(t,ky.LOW_STREAM)?n.close():this.pendingLocalTracks.push(n);break;case _I.LocalAudioTrack:n instanceof tb?this.pendingLocalTracks=this.pendingLocalTracks.concat(n.trackList):this.pendingLocalTracks.push(n);case _I.LocalVideoLowTrack:}})),this.emit(mI.MediaReconnectStart,this.store.uid)),this.unbindLocalTrackEvents(),this.localTrackMap.clear(),0!==this.remoteUserMap.size&&Array.from(this.remoteUserMap.entries()).forEach((e=>{let[t,i]=e;Array.from(hu(i).call(i)).forEach((e=>{this.setPendingRemoteMedia(t,e);})),this.emit(mI.MediaReconnectStart,t.uid);})),this.unbindAllRemoteTrackEvents(),this.remoteUserMap.clear(),0!==this.localDataChannels.length&&(this.localDataChannels.forEach((e=>{this.pendingLocalDataChannels.push(e);})),this.localDataChannels.length=0),0!==this.remoteDataChannelMap.size&&(Array.from(this.remoteDataChannelMap.entries()).forEach((e=>{let[t,i]=e;Array.from(hu(i).call(i)).forEach((e=>{this.setPendingRemoteDataChannel(t,e);}));})),this.remoteDataChannelMap.clear()),this.statsUploader.stopUploadUplinkStats(),this.statsUploader.stopUploadDownlinkStats(),this.statsUploader.stopUploadTransportStats(),KC.debug("[".concat(this.store.clientId,"] P2PChannel disconnected, waiting to reconnect.")));}hasPendingRemoteDataChannel(e,t){for(const i of this.pendingRemoteDataChannels){const{user:n,id:r}=i;if((e instanceof NP?e.uid:e)===n.uid&&r===t)return !0}return !1}setPendingRemoteDataChannel(e,t){this.hasPendingRemoteDataChannel(e,t)||this.pendingRemoteDataChannels.push({user:e,id:t});}hasPendingRemoteMedia(e,t){for(const i of this.pendingRemoteTracks){const{user:n,kind:r}=i;if((e instanceof NP?e.uid:e)===n.uid&&t===r)return !0}return !1}setPendingRemoteMedia(e,t){this.hasPendingRemoteMedia(e,t)||this.pendingRemoteTracks.push({user:e,kind:t});}restartICE(e){var t=this;return BP((function*(){if(!t.connection||t.state!==EI.Connected||t.connection instanceof sk)return;const i=yield jP(t.mutex.lock("From P2PChannel.restartICE"));let n;try{n=yield jP(t.connection.restartICE(e));const r=yield jP(n.next());if(r.done)return;const s=r.value,o=yield s;switch(t.reportPCDisconnectedOrFailed(e),e){case uI.TCP:t._pcStatsUploadType=pI.TCP_RESTART;break;case uI.RELAY:t._pcStatsUploadType=pI.RELAY_RESTART;break;default:t._pcStatsUploadType=pI.OLD_RESTART;}t._isInRestartIce=!0,n.next(o);}catch(e){var r;null===(r=n)||void 0===r||r.throw(e);}finally{i();}}))()}getUplinkNetworkQuality(){if(!this.connection)return 0;const e=this.connection.getStats(),t=this.localTrackMap.get(_I.LocalVideoTrack),i=this.localTrackMap.get(_I.LocalAudioTrack),n=e.videoSend.find((e=>e.ssrc===(null==t?void 0:t.ssrcs[0].ssrcId))),r=e.audioSend.find((e=>e.ssrc===(null==i?void 0:i.ssrcs[0].ssrcId)));if(!n||!r)return 1;const s=TT(this,mI.NeedSignalRTT),o=n?n.rttMs:void 0,a=r?r.rttMs:void 0,c=o&&a?(o+a)/2:o||a,d=(c&&s?(c+s)/2:c||s)||0,l=100*e.sendPacketLossRate*.7/50+.3*d/1500,h=l<.17?1:l<.36?2:l<.59?3:l<.1?4:5,u=null==t?void 0:t.track;if(u&&u._encoderConfig&&-1===u._hints.indexOf(ky.SCREEN_TRACK)){const t=u._encoderConfig.bitrateMax,i=e.bitrate.actualEncoded;if(t&&i){const e=(1e3*t-i)/(1e3*t);return av[e<.15?0:e<.3?1:e<.45?2:e<.6?3:4][h]}}return h}getDownlinkNetworkQuality(){if(!this.connection)return 0;const e=this.connection.getStats();let t=0;return Array.from(this.remoteUserMap.entries()).forEach((i=>{let[n]=i;const r=n._audioSSRC,s=n._videoSSRC,o=e.audioRecv.find((e=>e.ssrc===r)),a=e.videoRecv.find((e=>e.ssrc===s));if(!o&&!a)return void(t+=1);const c=TT(this,mI.NeedSignalRTT),d=e.rtt,l=(d&&c?(d+c)/2:d||c)||0,h=o?o.jitterMs:void 0,u=e.recvPacketLossRate;let p=.7*u*100/50+.3*l/1500;h&&(p=.6*u*100/50+.2*l/1500+.2*h/400);t+=p<.1?1:p<.17?2:p<.36?3:p<.59?4:5;})),this.remoteUserMap.size>0?Math.round(t/this.remoteUserMap.size):t}async muteLocalTrack(e){return new tg(((t,i)=>{this.handleMuteLocalTrack(e,t,i);}))}filterTobePublishedTracks(e,t,i){const n=[],r=_A(),s=this.getAllTracks();e=yT(e=e.filter((e=>-1===s.indexOf(e))));let o=!1,a=!1;for(const s of e){if(s instanceof Sb&&(this.localTrackMap.has(_I.LocalVideoTrack)||o?new Vg(xg.CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS).throw():(n.push({track:s,type:_I.LocalVideoTrack}),o=!0),t)){const e=this.getLowVideoTrack(s,i);n.push({track:e,type:_I.LocalVideoLowTrack});}if(s instanceof ZA){const e=this.localTrackMap.get(_I.LocalAudioTrack);if(e){if(!(e.track instanceof tb))throw new Vg(xg.NOT_SUPPORTED,"cannot publish multiple tracks which one of them configured with bypassWebAudio or your browser does not support audio mixing");if(s._bypassWebAudio)throw new Vg(xg.NOT_SUPPORTED,"cannot publish multiple tracks which one of them configured with bypassWebAudio");e.track.addAudioTrack(s),this.bindLocalAudioTrackEvents(s,!0);}else if(a){const e=n.find((e=>{let{type:t}=e;return t===_I.LocalAudioTrack}));if(!(e.track instanceof tb))throw new Vg(xg.NOT_SUPPORTED,"cannot publish multiple tracks which one of them configured with bypassWebAudio or your browser does not support audio mixing");if(s._bypassWebAudio)throw new Vg(xg.NOT_SUPPORTED,"cannot publish multiple tracks which one of them configured with bypassWebAudio");e.track.addAudioTrack(s);}else {if(!r.webAudioMediaStreamDest||s instanceof tb||s._bypassWebAudio)n.push({track:s,type:_I.LocalAudioTrack});else {const e=new tb;e.addAudioTrack(s),n.push({track:e,type:_I.LocalAudioTrack});}a=!0;}}}return n}filterTobeUnpublishedTracks(e){const t=[],i=this.getAllTracks();e=yT(e=e.filter((e=>-1!==i.indexOf(e))));for(const i of e){if(i instanceof ZA){const e=this.localTrackMap.get(_I.LocalAudioTrack);if(!e)continue;e.track instanceof tb?(e.track.removeAudioTrack(i),this.unbindLocalAudioTrackEvents(i),0===e.track.trackList.length&&(t.push([_I.LocalAudioTrack,e]),e.track.close())):t.push([_I.LocalAudioTrack,e]);}if(i instanceof Sb){const e=this.localTrackMap.get(_I.LocalVideoTrack);if(!e)continue;t.push([_I.LocalVideoTrack,e]);const i=this.localTrackMap.get(_I.LocalVideoLowTrack);i&&t.push([_I.LocalVideoLowTrack,i]);}}return t}filterTobePublishedDataChannels(e){return e=(e=yT(e)).filter((e=>-1===this.localDataChannels.findIndex((t=>t.id===e.id))))}filterTobeUnpublishedDataChannels(e){return e=(e=(e=yT(e)).filter((e=>-1!==this.localDataChannels.indexOf(e)))).filter((e=>e._originDataChannel))}bindLocalTrackEvents(e){e.forEach((e=>{let{track:t,type:i}=e;switch(i){case _I.LocalVideoTrack:t.addListener(Ly.GET_STATS,this.handleGetLocalVideoStats),t.addListener(Ly.GET_RTC_STATS,this.handleGetRTCStats),t.addListener(Ly.NEED_DISABLE_TRACK,this.handleMuteLocalTrack),t.addListener(Ly.NEED_ENABLE_TRACK,this.handleUnmuteLocalTrack),t.addListener(Ly.NEED_UPDATE_VIDEO_ENCODER,this.handleUpdateVideoEncoder),t.addListener(Ly.SET_OPTIMIZATION_MODE,this.handleSetOptimizationMode),t.addListener(Ly.NEED_REPLACE_TRACK,this.handleReplaceTrack),t.addListener(Ly.NEED_MUTE_TRACK,this.handleMuteLocalTrack),t.addListener(Ly.NEED_UNMUTE_TRACK,this.handleUnmuteLocalTrack);break;case _I.LocalAudioTrack:this.bindLocalAudioTrackEvents(t);case _I.LocalVideoLowTrack:}}));}bindLocalAudioTrackEvents(e,t){e instanceof tb?e.trackList.forEach((e=>{e.addListener(Ly.NEED_DISABLE_TRACK,this.handleMuteLocalTrack),e.addListener(Ly.NEED_ENABLE_TRACK,this.handleUnmuteLocalTrack),e.addListener(Ly.GET_STATS,this.handleGetLocalAudioStats),e.addListener(Ly.NEED_MUTE_TRACK,this.handleMuteLocalTrack),e.addListener(Ly.NEED_UNMUTE_TRACK,this.handleUnmuteLocalTrack);})):(e.addListener(Ly.GET_STATS,this.handleGetLocalAudioStats),e.addListener(Ly.NEED_DISABLE_TRACK,this.handleMuteLocalTrack),e.addListener(Ly.NEED_ENABLE_TRACK,this.handleUnmuteLocalTrack),e.addListener(Ly.NEED_MUTE_TRACK,this.handleMuteLocalTrack),e.addListener(Ly.NEED_UNMUTE_TRACK,this.handleUnmuteLocalTrack),t||e.addListener(Ly.NEED_REPLACE_TRACK,this.handleReplaceTrack));}unbindLocalTrackEvents(e){e||(e=Array.from(this.localTrackMap.entries()).map((e=>{let[t,{track:i}]=e;return {track:i,type:t}}))),e.forEach((e=>{let{track:t,type:i}=e;switch(i){case _I.LocalVideoTrack:t.off(Ly.GET_STATS,this.handleGetLocalVideoStats),t.off(Ly.GET_RTC_STATS,this.handleGetRTCStats),t.off(Ly.NEED_DISABLE_TRACK,this.handleMuteLocalTrack),t.off(Ly.NEED_ENABLE_TRACK,this.handleUnmuteLocalTrack),t.off(Ly.NEED_UPDATE_VIDEO_ENCODER,this.handleUpdateVideoEncoder),t.off(Ly.SET_OPTIMIZATION_MODE,this.handleSetOptimizationMode),t.off(Ly.NEED_REPLACE_TRACK,this.handleReplaceTrack),t.off(Ly.NEED_MUTE_TRACK,this.handleMuteLocalTrack),t.off(Ly.NEED_UNMUTE_TRACK,this.handleUnmuteLocalTrack);break;case _I.LocalAudioTrack:this.unbindLocalAudioTrackEvents(t);case _I.LocalVideoLowTrack:}}));}unbindLocalAudioTrackEvents(e){e instanceof tb?e.trackList.forEach((e=>{e.off(Ly.NEED_DISABLE_TRACK,this.handleMuteLocalTrack),e.off(Ly.NEED_ENABLE_TRACK,this.handleUnmuteLocalTrack),e.off(Ly.GET_STATS,this.handleGetLocalAudioStats),e.off(Ly.NEED_MUTE_TRACK,this.handleMuteLocalTrack),e.off(Ly.NEED_UNMUTE_TRACK,this.handleUnmuteLocalTrack);})):(e.off(Ly.GET_STATS,this.handleGetLocalAudioStats),e.off(Ly.NEED_DISABLE_TRACK,this.handleMuteLocalTrack),e.off(Ly.NEED_ENABLE_TRACK,this.handleUnmuteLocalTrack),e.off(Ly.NEED_REPLACE_TRACK,this.handleReplaceTrack),e.off(Ly.NEED_MUTE_TRACK,this.handleMuteLocalTrack),e.off(Ly.NEED_UNMUTE_TRACK,this.handleUnmuteLocalTrack));}bindRemoteTrackEvents(e,t){t instanceof wb&&t.addListener(Ly.GET_STATS,(t=>{t(this.handleGetRemoteVideoStats(e));})),t instanceof Ob&&t.addListener(Ly.GET_STATS,(t=>{t(this.handleGetRemoteAudioStats(e));}));}unbindRemoteTrackEvents(e){e&&e.removeAllListeners(Ly.GET_STATS);}unbindAllRemoteTrackEvents(){Array.from(this.remoteUserMap.entries()).forEach((e=>{let[t,i]=e;i.has(hI.AUDIO)&&this.unbindRemoteTrackEvents(t._audioTrack),i.has(hI.VIDEO)&&this.unbindRemoteTrackEvents(t._videoTrack);}));}createGatewayPublishMessage(e,t){return e.map(((e,i)=>{var n;let r,s,{track:o,type:a}=e;switch(a){case _I.LocalAudioTrack:r=$v.Audio,s={dtx:o instanceof $A&&o._config.DTX,hq:!1,lq:!1,stereo:!1,speech:!1};break;case _I.LocalVideoTrack:r=Pr(n=o._hints).call(n,ky.SCREEN_TRACK)?$v.Screen:$v.High,s=hk(hk({},fD(o)),{},{codec:this.store.codec});break;case _I.LocalVideoLowTrack:r=$v.Low,s=hk(hk({},fD(o)),{},{codec:this.store.codec});}return {stream_type:r,attributes:s,ssrcs:t[i]}}))}createGatewayUnpublishMessage(e){return e.map((e=>{var t;let i,[n,{track:r,ssrcs:s,id:o}]=e;switch(n){case _I.LocalVideoTrack:i=Pr(t=r._hints).call(t,ky.SCREEN_TRACK)?$v.Screen:$v.High;break;case _I.LocalAudioTrack:i=$v.Audio;break;case _I.LocalVideoLowTrack:i=$v.Low;}return {stream_type:i,ssrcs:s,mid:o}}))}assignLocalTracks(e,t){e.forEach(((e,i)=>{let{track:n,type:r}=e;this.localTrackMap.set(r,{track:n,id:t[i].id,ssrcs:t[i].localSSRC});}));}withdrawLocalTracks(e){e.forEach((e=>{let[t]=e;this.localTrackMap.delete(t);}));}bindConnectionEvents(e){e.onConnectionStateChange=async t=>{if(KC.info("[".concat(this.store.clientId,"] [p2pId: ").concat(this.store.p2pId,"]: P2PConnection.onConnectionStateChange(").concat(t,")")),this.emit(mI.PeerConnectionStateChange,t),"connected"!==t||this.store.keyMetrics.peerConnectionEnd||this.store.peerConnectionEnd(),"connected"===t&&(this._restartTimer&&(clearTimeout(this._restartTimer),this._restartTimer=void 0),(this._isFirstConnected||this._isInRestartIce)&&this.reportPCStats(Date.now(),!0,this._pcStatsUploadType),this._isInRestartIce=!1,this._isFirstConnected=!1,this._isStartRestartIce=!1),kC("NEW_ICE_RESTART")){var i;if(Pr(i=this._restartStates).call(i,t)){if(this._isStartRestartIce)return;this._isStartRestartIce=!0;const t=t=>{if("disconnected"===e.iceConnectionState||"checking"===e.iceConnectionState||"failed"===e.iceConnectionState){KC.debug("[".concat(this.store.clientId,"] [P2PChannel] start use restartICE, type is ").concat(t));"CONNECTED"===TT(this,mI.QueryClientConnectionState)&&this.emit(mI.RequestRestartICE,t);}},i=()=>{"disconnected"!==e.iceConnectionState&&"checking"!==e.iceConnectionState&&"failed"!==e.iceConnectionState||(this.reportPCStats(Date.now(),!1,this._pcStatsUploadType),KC.debug("[".concat(this.store.clientId,"] P2PConnection disconnected timeout, force reconnect")),setTimeout((()=>this.emit(mI.P2PLost)),0),this.iceFailedCount+=1,this.requestReconnect());},n=kC("ICE_RESTART_INTERVAL");return void(this._restartTimer=window.setTimeout((()=>{if(kC("JOIN_WITH_FALLBACK_MEDIA_PROXY_FORCE")&&_A().supportPCSetConfiguration)t(uI.RELAY),this._restartTimer=window.setTimeout(i,n);else if(Rg())t(uI.UDP),this._restartTimer=window.setTimeout(i,4e3);else {if(t(uI.TCP),_A().supportPCSetConfiguration)return void(this._restartTimer=window.setTimeout((()=>{t(uI.RELAY),this._restartTimer=window.setTimeout(i,n);}),n));this._restartTimer=window.setTimeout(i,n);}}),800))}}else {if("disconnected"===t&&"disconnected"===e.iceConnectionState)return setTimeout((()=>{if("disconnected"===e.iceConnectionState&&kC("ICE_RESTART")){"CONNECTED"===TT(this,mI.QueryClientConnectionState)&&this.emit(mI.RequestRestartICE);}}),800),void setTimeout((()=>{"disconnected"===e.peerConnectionState&&(KC.debug("[".concat(this.store.clientId,"] [p2pId: ").concat(this.store.p2pId,"]: P2PConnection disconnected timeout 4000ms, force reconnect")),this.reportPCStats(Date.now(),!1,this._pcStatsUploadType),this._isInRestartIce=!1,setTimeout((()=>this.emit(mI.P2PLost)),0),this.iceFailedCount+=1,this.requestReconnect());}),4e3);"failed"===t&&(KC.debug("[".concat(this.store.clientId,"] [p2pId: ").concat(this.store.p2pId,"]: P2PConnection state failed, force reconnect")),this.reportPCDisconnectedOrFailed(),setTimeout((()=>this.emit(mI.P2PLost)),0),this.iceFailedCount+=1,await this.requestReconnect());}},e.onICEConnectionStateChange=e=>{"connected"!==e||this.store.keyMetrics.iceConnectionEnd||this.store.iceConnectionEnd(),KC.info("[".concat(this.store.clientId,"] [p2pId: ").concat(this.store.p2pId,"]: P2PConnection.onICEConnectionStateChange(").concat(e,")")),rv.reportApiInvoke(this.store.sessionId,{name:"ICEConnectionStateChange",options:e,tag:oT.TRACER}).onSuccess(),this.emit(mI.IceConnectionStateChange,e);},e.onICETransportStateChange=e=>{KC.info("[".concat(this.store.clientId,"] [p2pId: ").concat(this.store.p2pId,"]: P2PConnection.onICETransportStateChange(").concat(e,")"));},e.onDTLSTransportStateChange=e=>{KC.info("[".concat(this.store.clientId,"] [p2pId: ").concat(this.store.p2pId,"]: P2PConnection.onDTLSTransportStateChange(").concat(e,")"));},e.onDTLSTransportError=e=>{KC.info("[".concat(this.store.clientId,"] [p2pId: ").concat(this.store.p2pId,"]: P2PConnection.onDTLSTransportError(").concat(e,")"));},e.onFirstAudioDecoded=e=>{var t;const i=Array.from(hu(t=this.remoteUserMap).call(t)).find((t=>t._audioSSRC===e));var n;i&&(this.store.subscribe(i.uid,"audio",void 0,void 0,void 0,Date.now()),null===(n=i.audioTrack)||void 0===n||n.emit(By.FIRST_FRAME_DECODED),rv.firstRemoteFrame(this.store.sessionId,XC.FIRST_AUDIO_DECODE,QC.FIRST_AUDIO_DECODE,{peer:i._uintid,subscribeElapse:cD.measureFromSubscribeStart(this.store.clientId,e),subscribeRequestid:e,p2pid:this.store.p2pId}));},e.onFirstAudioReceived=e=>{var t;const i=Array.from(hu(t=this.remoteUserMap).call(t)).find((t=>t._audioSSRC===e));i&&rv.firstRemoteFrame(this.store.sessionId,XC.FIRST_AUDIO_RECEIVED,QC.FIRST_AUDIO_RECEIVED,{peer:i._uintid,subscribeElapse:cD.measureFromSubscribeStart(this.store.clientId,e),subscribeRequestid:e,p2pid:this.store.p2pId});},e.onFirstVideoDecoded=(e,t,i)=>{this.reportVideoFirstFrameDecoded(e,t,i);},e.onFirstVideoReceived=e=>{var t;const i=Array.from(hu(t=this.remoteUserMap).call(t)).find((t=>t._videoSSRC===e));i&&rv.firstRemoteFrame(this.store.sessionId,XC.FIRST_VIDEO_RECEIVED,QC.FIRST_VIDEO_RECEIVED,{peer:i._uintid,subscribeElapse:cD.measureFromSubscribeStart(this.store.clientId,e),subscribeRequestid:e,p2pid:this.store.p2pId});},e.onSelectedLocalCandidateChanged=(e,t)=>{const i="relay"===e.candidateType,n="relay"===t.candidateType;"unknown"!==t.candidateType&&i===n||this.emit(mI.ConnectionTypeChange,i),KC.info("[".concat(this.store.clientId,"] [p2pId: ").concat(this.store.p2pId,"]: P2PConnection.SelectedLocalCandidateChanged(").concat(JSON.stringify(vD(t))," -> ").concat(JSON.stringify(vD(e)),")"));},e.onSelectedRemoteCandidateChanged=(e,t)=>{KC.info("[".concat(this.store.clientId,"] [p2pId: ").concat(this.store.p2pId,"]: P2PConnection.SelectedRemoteCandidateChanged(").concat(JSON.stringify(vD(t))," -> ").concat(JSON.stringify(vD(e)),")"));},e.onFirstVideoDecodedTimeout=e=>{this.reportVideoFirstFrameDecoded(e,void 0,void 0,!0);};}unbindConnectionEvents(e){e.onConnectionStateChange=void 0,e.onICEConnectionStateChange=void 0,e.onICETransportStateChange=void 0,e.onDTLSTransportStateChange=void 0,e.onDTLSTransportError=void 0,e.onFirstAudioDecoded=void 0,e.onFirstAudioReceived=void 0,e.onFirstVideoDecoded=void 0,e.onFirstVideoReceived=void 0,e.onSelectedLocalCandidateChanged=void 0,e.onSelectedRemoteCandidateChanged=void 0,e.onFirstVideoDecodedTimeout=void 0;}filterTobeMutedTracks(e){const t=[];if(-1===this.getAllTracks().indexOf(e))return t;const i=this.localTrackMap.get(_I.LocalAudioTrack);if(e instanceof ZA&&(null==i?void 0:i.track)instanceof tb)return i.track.isActive||t.push([_I.LocalAudioTrack,i]),t;const n=Array.from(this.localTrackMap.entries()).find((t=>{let[,{track:i}]=t;return e===i}));if(n&&(t.push(n),n[0]===_I.LocalVideoTrack)){const e=this.localTrackMap.get(_I.LocalVideoLowTrack);e&&t.push([_I.LocalVideoLowTrack,e]);}return t}filterTobeUnmutedTracks(e){const t=[],i=this.localTrackMap.get(_I.LocalAudioTrack);if(e instanceof ZA&&(null==i?void 0:i.track)instanceof tb)return i.track.isActive&&t.push([_I.LocalAudioTrack,i]),t;const n=Array.from(this.localTrackMap.entries()).find((t=>{let[,{track:i}]=t;return e===i}));if(n)if(n[0]===_I.LocalVideoTrack){t.push(n);const e=this.localTrackMap.get(_I.LocalVideoLowTrack);e&&t.push([_I.LocalVideoLowTrack,e]);}else t.push(n);return t}createMuteMessage(e){return e.map((e=>{var t;let i,[n,{track:r,ssrcs:s,id:o}]=e;switch(n){case _I.LocalAudioTrack:i=$v.Audio;break;case _I.LocalVideoTrack:i=Pr(t=r._hints).call(t,ky.SCREEN_TRACK)?$v.Screen:$v.High;break;case _I.LocalVideoLowTrack:i=$v.Low;}return {stream_type:i,ssrcs:s,mid:o}}))}createUnmuteMessage(e){return e.map((e=>{var t;let i,[n,{track:r,ssrcs:s,id:o}]=e;switch(n){case _I.LocalAudioTrack:i=$v.Audio;break;case _I.LocalVideoTrack:i=Pr(t=r._hints).call(t,ky.SCREEN_TRACK)?$v.Screen:$v.High;break;case _I.LocalVideoLowTrack:i=$v.Low;}return {stream_type:i,ssrcs:s,mid:o}}))}filterTobeUnSubscribedTracks(e,t){const i=[],n=this.remoteUserMap.get(e);if(!n)return i;if(t){const r=n.get(t);if(!r)return i;i.push([e,{kind:t,id:r}]);}else Array.from(n.entries()).forEach((t=>{let[n,r]=t;i.push([e,{kind:n,id:r}]);}));return i}filterTobeUnSubscribedDataChannels(e,t){const i=[];return t.forEach((t=>{var n;null!==(n=this.remoteDataChannelMap.get(e))&&void 0!==n&&n.has(t.id)&&i.push(t);})),i}createUnsubscribeMessage(e){const t=[];return e.forEach((e=>{let[i,{kind:n,id:r}]=e;switch(n){case hI.VIDEO:return void(i._videoSSRC&&t.push({stream_type:hI.VIDEO,ssrcId:i._videoSSRC}));case hI.AUDIO:return void(i._audioSSRC&&t.push({stream_type:hI.AUDIO,ssrcId:i._audioSSRC}))}})),t}createUnsubscribeAllMessage(e){const t=new Map;return e.forEach((e=>{let[i,{kind:n}]=e;if(t.has(i)){let e=t.get(i);n===hI.VIDEO?e|=iI.Video:e|=iI.Audio,t.set(i,e);}else n===hI.VIDEO?t.set(i,iI.Video):t.set(i,iI.Audio);})),{users:Array.from(t.entries()).map((e=>{let[t,i]=e;return {stream_id:t.uid,stream_type:i}}))}}withdrawRemoteTracks(e){e.forEach((e=>{let[t,{kind:i}]=e;const n=this.remoteUserMap.get(t);n&&(n.delete(i),0===Array.from(n.entries()).length&&this.remoteUserMap.delete(t));}));}async updateBitrateLimit(e){const t=this.localTrackMap.get(_I.LocalVideoTrack),i=this.localTrackMap.get(_I.LocalVideoLowTrack);t&&await t.track.setBitrateLimit(e.uplink),i&&e.low_stream_uplink&&await i.track.setBitrateLimit({max_bitrate:e.low_stream_uplink.bitrate,min_bitrate:e.low_stream_uplink.bitrate||0});}isP2PDisconnected(){if(this.connection){return "connected"!==this.connection.peerConnectionState}return !0}mapPubResToRemoteConfig(e,t){return e.map(((e,i)=>{var n;let{stream_type:r}=e;return null===(n=t.find((e=>{let{stream_type:t}=e;return r===t})))||void 0===n?void 0:n.attributes}))}async tryToUnmuteAudio(e){for(let i=0;i<e.length;i++)if(e[i]instanceof ZA){var t;const n=this.filterTobeUnmutedTracks(e[i]);if(0===n.length)continue;await(null===(t=this.connection)||void 0===t?void 0:t.unmuteLocal(n.map((e=>{let[,{id:t}]=e;return t}))));const r=this.createUnmuteMessage(n);return void await gT(this,mI.RequestUnmuteLocal,r)}}bindStatsUploaderEvents(){this.statsUploader.requestStats=()=>this.getStats(),this.statsUploader.requestLocalMedia=()=>Array.from(this.localTrackMap.entries()),this.statsUploader.requestRemoteMedia=()=>Array.from(this.remoteUserMap.entries()),this.statsUploader.requestVideoIsReady=e=>{var t;return !(null===(t=this.connection)||void 0===t||!t.getRemoteVideoIsReady(e))},this.statsUploader.requestUpload=(e,t)=>this.emit(mI.RequestUploadStats,e,t),this.statsUploader.requestAllTracks=()=>this.getAllTracks();}unbindStatsUploaderEvents(){this.statsUploader.requestStats=void 0,this.statsUploader.requestLocalMedia=void 0,this.statsUploader.requestRemoteMedia=void 0,this.statsUploader.requestVideoIsReady=void 0;}async requestReconnect(){this.dtlsFailedCount+=1,await UT(zT(this.dtlsFailedCount,JT)),this.emit(mI.RequestReconnect);}async reconnectP2P(){const e=Array.from(this.localTrackMap.entries()),t=this.createGatewayUnpublishMessage(e);Array.from(this.remoteUserMap.entries()),t.length>0&&await fT(this,mI.RequestUnpublishForReconnectPC,t),this.disconnectForReconnect(),this.emit(mI.RequestReconnectPC);}canPublishLowStream(){return this.localTrackMap.has(_I.LocalVideoTrack)||this.pendingLocalTracks.some((e=>e instanceof Sb))}throwIfTrackTypeNotMatch(e){if(e.filter((e=>e instanceof Sb)).length>1)throw new Vg(xg.CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS);if(e.filter((e=>e instanceof ZA)).length>1&&(e.some((e=>e instanceof ZA&&e._bypassWebAudio))||!_A().webAudioMediaStreamDest))throw new Vg(xg.NOT_SUPPORTED,"cannot publish multiple tracks which one of them configured with bypassWebAudio or your browser doesn't support MediaStreamDestNode");for(const t of e){if(t instanceof Sb&&this.pendingLocalTracks.some((e=>e instanceof Sb)))throw new Vg(xg.CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS);if(t instanceof ZA&&this.pendingLocalTracks.some((e=>e instanceof ZA))&&(!_A().webAudioMediaStreamDest||t._bypassWebAudio||this.pendingLocalTracks.some((e=>e instanceof ZA&&e._bypassWebAudio))))throw new Vg(xg.NOT_SUPPORTED,"cannot publish multiple tracks which one of them configured with bypassWebAudio or your browser doesn't support MediaStreamDestNode")}}getLowVideoTrack(e,t){const i=!kC("DISABLE_DUAL_STREAM_USE_ENCODING")&&_A().supportDualStreamEncoding,n=hk(hk({},{width:160,height:120,framerate:15,bitrate:50}),t);let r;r=i?e._mediaStreamTrack.clone():KL(e,n);const s=xT(8,"track-low-"),o=new Sb(r,hk(hk({},i&&{scaleResolutionDownBy:CD(n,e)}),{},{frameRate:n.framerate,bitrateMax:n.bitrate,bitrateMin:n.bitrate}),void 0,void 0,s);return o.on(Vy.TRANSCEIVER_UPDATED,(t=>{e._updateRtpTransceiver(t,My.LOW_STREAM);})),o._hints.push(ky.LOW_STREAM),e.addListener(Ly.NEED_CLOSE,(()=>{o.close();})),o}async globalLock(){return this.mutex.lock("From P2PChannel.globalLock")}async reportPCStats(e,t,i){let n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;if(this.connection&&this.connection instanceof WL){var r,s,o,a;const c=this.store.keyMetrics.descriptionStart||0,{iceConnectionState:d,dtlsTransportState:l,peerConnectionState:h}=this.connection,{local:u,remote:p}=await this.connection.getSelectedCandidatePair();rv.pcStats(this.store.sessionId,{startTime:c,eventElapse:e-c||0,iceconnectionsate:d,dtlsstate:l,connectionstate:h,intSucc:t?1:2,error:n,selectedLocalCandidateProtocol:null!==(r=null==u?void 0:u.protocol)&&void 0!==r?r:"",selectedLocalCandidateType:null!==(s=u.candidateType)&&void 0!==s?s:"",selectedLocalCandidateAddress:"".concat(u.address,":").concat(u.port),selectedRemoteCandidateProtocol:null!==(o=p.protocol)&&void 0!==o?o:"",selectedRemoteCandidateType:null!==(a=p.candidateType)&&void 0!==a?a:"",selectedRemoteCandidateAddress:"".concat(p.address,":").concat(p.port),restartCnt:i});}}reportVideoFirstFrameDecoded(e,t,i,n){var r;const s=Array.from(hu(r=this.remoteUserMap).call(r)).find((t=>t._videoSSRC===e));if(s){n||this.store.subscribe(s.uid,"video",void 0,void 0,void 0,void 0,Date.now());const r=this.store.keyMetrics,o=r.subscribe.find((e=>e.userId===s.uid&&"video"===e.type));rv.firstRemoteVideoDecode(this.store.sessionId,XC.FIRST_VIDEO_DECODE,QC.FIRST_VIDEO_DECODE,{peer:s._uintid,videowidth:t,videoheight:i,subscribeElapse:cD.measureFromSubscribeStart(this.store.clientId,e),subscribeRequestid:e,p2pid:this.store.p2pId,apEnd:r.requestAPEnd||0,apStart:r.requestAPStart||0,joinGwEnd:r.joinGatewayEnd||0,joinGwStart:r.joinGatewayStart||0,pcEnd:r.peerConnectionEnd||0,pcStart:r.peerConnectionStart||0,subscriberEnd:(null==o?void 0:o.subscribeEnd)||0,subscriberStart:(null==o?void 0:o.subscribeStart)||0,videoAddNotify:(null==o?void 0:o.streamAdded)||0,state:n?1:0});}}async remoteMediaSsrcChanged(e,t,i){if(!this.connection)return !1;const n=this.remoteUserMap.get(e);if(!n)return !1;const r=n.get(t);if(!r)return !1;const s=await this.connection.getRemoteSSRC(r);return void 0!==s&&s!==i}resetConnection(e){KC.debug("[".concat(this.store.clientId,"] [P2PChannel] reset connection to ").concat(e)),this.state===EI.Connected?(KC.debug("[".concat(this.store.clientId,"] [P2PChannel] fallback to websocket but P2PChannel state still connected, disconnect first")),this.disconnectForReconnect()):(this.connection&&(this.connection.close(),this.unbindConnectionEvents(this.connection),this.connection=void 0),this.shouldForwardP2PCreation&&(this.connection=e===nI.datachannel?new sk({},this.store):this.isPlanB?new ML({},this.store):new WL({},this.store),this.bindConnectionEvents(this.connection)));}unbindRtpTransceiver(){0!==this.localTrackMap.size&&Array.from(this.localTrackMap.entries()).forEach((e=>{let[t,{track:i}]=e;t===_I.LocalVideoLowTrack?i._updateRtpTransceiver(void 0,My.LOW_STREAM):i._updateRtpTransceiver(void 0);}));}reportPCDisconnectedOrFailed(e){this.connection&&this.connection instanceof WL&&("disconnected"!==this.connection.iceConnectionState&&"checking"!==this.connection.iceConnectionState&&"failed"!==this.connection.iceConnectionState||(this._isFirstConnected?(this.reportPCStats(Date.now(),!1,this._pcStatsUploadType),this._isFirstConnected=!1):this._pcStatsUploadType===pI.TCP_RESTART&&e===uI.RELAY?this.reportPCStats(Date.now(),!1,this._pcStatsUploadType):this.reportPCStats(Date.now(),!1,pI.DISCONNECTED_OR_FAILED)));}}function Ek(e,t,i){const n=e[t];if("function"!=typeof n)throw new Error("Cannot use mutex on object property.");return i.value=async function(){const e=this.mutex,i=await e.lock("From P2PChannel.".concat(t));try{for(var r=arguments.length,s=new Array(r),o=0;o<r;o++)s[o]=arguments[o];return await n.apply(this,s)}finally{i();}},i}function mk(e){let t=bk();return function(e,t){let i=e.appId;void 0!==i&&(jk(t,10),kk(t,i));let n=e.cid;void 0!==n&&(jk(t,16),jk(t,n));let r=e.cname;void 0!==r&&(jk(t,26),kk(t,r));let s=e.deviceId;void 0!==s&&(jk(t,34),kk(t,s));let o=e.elapse;void 0!==o&&(jk(t,40),Gk(t,o));let a=e.fileSize;void 0!==a&&(jk(t,48),Gk(t,yk(a)));let c=e.height;void 0!==c&&(jk(t,56),Gk(t,yk(c)));let d=e.jpg;void 0!==d&&(jk(t,66),jk(t,d.length),function(e,t){let i=Dk(e,t.length);e.bytes.set(t,i);}(t,d));let l=e.networkType;void 0!==l&&(jk(t,72),Gk(t,yk(l)));let h=e.osType;void 0!==h&&(jk(t,80),Gk(t,yk(h)));let u=e.requestId;void 0!==u&&(jk(t,90),kk(t,u));let p=e.sdkVersion;void 0!==p&&(jk(t,98),kk(t,p));let _=e.sequence;void 0!==_&&(jk(t,104),Gk(t,yk(_)));let E=e.sid;void 0!==E&&(jk(t,114),kk(t,E));let m=e.timestamp;void 0!==m&&(jk(t,120),Gk(t,m));let f=e.uid;void 0!==f&&(jk(t,128),jk(t,f));let g=e.vid;void 0!==g&&(jk(t,136),jk(t,g));let T=e.width;void 0!==T&&(jk(t,144),Gk(t,yk(T)));let S=e.service;void 0!==S&&(jk(t,152),jk(t,S));let R=e.callbackData;void 0!==R&&(jk(t,162),kk(t,R));let C=e.jpgEncryption;void 0!==C&&(jk(t,168),jk(t,C));let v=e.requestType;void 0!==v&&(jk(t,176),jk(t,v));let I=e.scorePorn;void 0!==I&&(jk(t,185),Fk(t,I));let y=e.scoreSexy;void 0!==y&&(jk(t,193),Fk(t,y));let A=e.scoreNeutral;void 0!==A&&(jk(t,201),Fk(t,A));let b=e.scene;void 0!==b&&(jk(t,208),jk(t,b));let w=e.ossFilePrefix;void 0!==w&&(jk(t,218),kk(t,w));let O=e.serviceVendor;if(void 0!==O)for(let e of O){jk(t,226);let i=bk();Tk(e,i),jk(t,i.limit),Mk(t,i),wk(i);}}(e,t),function(e){let t=e.bytes,i=e.limit;return t.length===i?t:t.subarray(0,i)}(t)}function fk(e){return function(e){let t={};e:for(;!Nk(e);){let i=Bk(e);switch(i>>>3){case 0:break e;case 1:t.code=Bk(e);break;case 2:t.msg=Lk(e,Bk(e));break;case 3:{let i=Sk(e);t.data=gk(e),e.limit=i;break}default:Rk(e,7&i);}}return t}({bytes:t=e,offset:0,limit:t.length});var t;}function gk(e){let t={};e:for(;!Nk(e);){let i=Bk(e);switch(i>>>3){case 0:break e;case 1:t.requestId=Lk(e,Bk(e));break;case 2:t.requestType=Bk(e)>>>0;break;case 3:t.scorePorn=Vk(e);break;case 4:t.scoreSexy=Vk(e);break;case 5:t.scoreNeutral=Vk(e);break;case 6:t.requestScene=Bk(e)>>>0;break;case 7:t.scene=Bk(e)>>>0;break;default:Rk(e,7&i);}}return t}function Tk(e,t){let i=e.service;void 0!==i&&(jk(t,8),jk(t,i));let n=e.vendor;void 0!==n&&(jk(t,16),jk(t,n));let r=e.token;void 0!==r&&(jk(t,26),kk(t,r));let s=e.callbackUrl;void 0!==s&&(jk(t,34),kk(t,s));}function Sk(e){let t=Bk(e),i=e.limit;return e.limit=e.offset+t,i}function Rk(e,t){switch(t){case 0:for(;128&Uk(e););break;case 2:Ok(e,Bk(e));break;case 5:Ok(e,4);break;case 1:Ok(e,8);break;default:throw new Error("Unimplemented type: "+t)}}Mv([Ek,Uv("design:type",Function),Uv("design:paramtypes",[Object,Boolean]),Uv("design:returntype",tg)],_k.prototype,"startP2PConnection",null),Mv([Ek,Uv("design:type",Function),Uv("design:paramtypes",[Object,Object,Array,Object,String,String]),Uv("design:returntype",tg)],_k.prototype,"connect",null),Mv([Ek,Uv("design:type",Function),Uv("design:paramtypes",[Array]),Uv("design:returntype",void 0)],_k.prototype,"updateRemoteRTPCapabilities",null),Mv([Ek,Uv("design:type",Function),Uv("design:paramtypes",[Object,Object,Array,Object,String,String]),Uv("design:returntype",tg)],_k.prototype,"preConnect",null),Mv([Ek,Uv("design:type",Function),Uv("design:paramtypes",[Array]),Uv("design:returntype",tg)],_k.prototype,"publishDataChannel",null),Mv([Ek,Uv("design:type",Function),Uv("design:paramtypes",[Array]),Uv("design:returntype",tg)],_k.prototype,"unpublish",null),Mv([Ek,Uv("design:type",Function),Uv("design:paramtypes",[Array]),Uv("design:returntype",tg)],_k.prototype,"unpublishDataChannel",null),Mv([Ek,Uv("design:type",Function),Uv("design:paramtypes",[]),Uv("design:returntype",tg)],_k.prototype,"unpublishLowStream",null),Mv([Ek,Uv("design:type",Function),Uv("design:paramtypes",[NP,Array]),Uv("design:returntype",tg)],_k.prototype,"subscribeDataChannel",null),Mv([Ek,Uv("design:type",Function),Uv("design:paramtypes",[NP,String,Number,Number,Array]),Uv("design:returntype",tg)],_k.prototype,"subscribe",null),Mv([Ek,Uv("design:type",Function),Uv("design:paramtypes",[Array]),Uv("design:returntype",tg)],_k.prototype,"massSubscribe",null),Mv([Ek,Uv("design:type",Function),Uv("design:paramtypes",[NP,String,Boolean]),Uv("design:returntype",tg)],_k.prototype,"unsubscribe",null),Mv([Ek,Uv("design:type",Function),Uv("design:paramtypes",[NP,Array]),Uv("design:returntype",tg)],_k.prototype,"unsubscribeDataChannel",null),Mv([Ek,Uv("design:type",Function),Uv("design:paramtypes",[Array]),Uv("design:returntype",tg)],_k.prototype,"massUnsubscribe",null),Mv([Ek,Uv("design:type",Function),Uv("design:paramtypes",[NP,String]),Uv("design:returntype",tg)],_k.prototype,"muteRemote",null),Mv([Ek,Uv("design:type",Function),Uv("design:paramtypes",[NP,String]),Uv("design:returntype",tg)],_k.prototype,"unmuteRemote",null),Mv([Ek,Uv("design:type",Function),Uv("design:paramtypes",[NP,String]),Uv("design:returntype",tg)],_k.prototype,"hasRemoteMediaWithLock",null),Mv([Ek,Uv("design:type",Function),Uv("design:paramtypes",[]),Uv("design:returntype",tg)],_k.prototype,"disconnectForReconnect",null),Mv([Ek,Uv("design:type",Function),Uv("design:paramtypes",[Object]),Uv("design:returntype",tg)],_k.prototype,"updateBitrateLimit",null),Mv([Ek,Uv("design:type",Function),Uv("design:paramtypes",[NP,String,Number]),Uv("design:returntype",tg)],_k.prototype,"remoteMediaSsrcChanged",null);let Ck=new Float32Array(1);new Uint8Array(Ck.buffer);let vk=new Float64Array(1),Ik=new Uint8Array(vk.buffer);function yk(e){return {low:e|=0,high:e>>31,unsigned:e>=0}}let Ak=[];function bk(){const e=Ak.pop();return e?(e.offset=e.limit=0,e):{bytes:new Uint8Array(64),offset:0,limit:0}}function wk(e){Ak.push(e);}function Ok(e,t){if(e.offset+t>e.limit)throw new Error("Skip past limit");e.offset+=t;}function Nk(e){return e.offset>=e.limit}function Dk(e,t){let i=e.bytes,n=e.offset,r=e.limit,s=n+t;if(s>i.length){let t=new Uint8Array(2*s);t.set(i),e.bytes=t;}return e.offset=s,s>r&&(e.limit=s),n}function Pk(e,t){let i=e.offset;if(i+t>e.limit)throw new Error("Read past limit");return e.offset+=t,i}function Lk(e,t){let i=Pk(e,t),n=String.fromCharCode,r=e.bytes,s="�",o="";for(let e=0;e<t;e++){let a,c,d,l,h=r[e+i];0==(128&h)?o+=n(h):192==(224&h)?e+1>=t?o+=s:(a=r[e+i+1],128!=(192&a)?o+=s:(l=(31&h)<<6|63&a,l<128?o+=s:(o+=n(l),e++))):224==(240&h)?e+2>=t?o+=s:(a=r[e+i+1],c=r[e+i+2],32896!=(49344&(a|c<<8))?o+=s:(l=(15&h)<<12|(63&a)<<6|63&c,l<2048||l>=55296&&l<=57343?o+=s:(o+=n(l),e+=2))):240==(248&h)?e+3>=t?o+=s:(a=r[e+i+1],c=r[e+i+2],d=r[e+i+3],8421504!=(12632256&(a|c<<8|d<<16))?o+=s:(l=(7&h)<<18|(63&a)<<12|(63&c)<<6|63&d,l<65536||l>1114111?o+=s:(l-=65536,o+=n(55296+(l>>10),56320+(1023&l)),e+=3))):o+=s;}return o}function kk(e,t){let i=t.length,n=0;for(let e=0;e<i;e++){let r=t.charCodeAt(e);r>=55296&&r<=56319&&e+1<i&&(r=(r<<10)+t.charCodeAt(++e)-56613888),n+=r<128?1:r<2048?2:r<65536?3:4;}jk(e,n);let r=Dk(e,n),s=e.bytes;for(let e=0;e<i;e++){let n=t.charCodeAt(e);n>=55296&&n<=56319&&e+1<i&&(n=(n<<10)+t.charCodeAt(++e)-56613888),n<128?s[r++]=n:(n<2048?s[r++]=n>>6&31|192:(n<65536?s[r++]=n>>12&15|224:(s[r++]=n>>18&7|240,s[r++]=n>>12&63|128),s[r++]=n>>6&63|128),s[r++]=63&n|128);}}function Mk(e,t){let i=Dk(e,t.limit),n=e.bytes,r=t.bytes;for(let e=0,s=t.limit;e<s;e++)n[e+i]=r[e];}function Uk(e){return e.bytes[Pk(e,1)]}function xk(e,t){let i=Dk(e,1);e.bytes[i]=t;}function Vk(e){let t=Pk(e,8),i=e.bytes;return Ik[0]=i[t++],Ik[1]=i[t++],Ik[2]=i[t++],Ik[3]=i[t++],Ik[4]=i[t++],Ik[5]=i[t++],Ik[6]=i[t++],Ik[7]=i[t++],vk[0]}function Fk(e,t){let i=Dk(e,8),n=e.bytes;vk[0]=t,n[i++]=Ik[0],n[i++]=Ik[1],n[i++]=Ik[2],n[i++]=Ik[3],n[i++]=Ik[4],n[i++]=Ik[5],n[i++]=Ik[6],n[i++]=Ik[7];}function Bk(e){let t,i=0,n=0;do{t=Uk(e),i<32&&(n|=(127&t)<<i),i+=7;}while(128&t);return n}function jk(e,t){for(t>>>=0;t>=128;)xk(e,127&t|128),t>>>=7;xk(e,t);}function Gk(e,t){let i=t.low>>>0,n=(t.low>>>28|t.high<<4)>>>0,r=t.high>>>24,s=0===r?0===n?i<16384?i<128?1:2:i<1<<21?3:4:n<16384?n<128?5:6:n<1<<21?7:8:r<128?9:10,o=Dk(e,s),a=e.bytes;switch(s){case 10:a[o+9]=r>>>7&1;case 9:a[o+8]=9!==s?128|r:127&r;case 8:a[o+7]=8!==s?n>>>21|128:n>>>21&127;case 7:a[o+6]=7!==s?n>>>14|128:n>>>14&127;case 6:a[o+5]=6!==s?n>>>7|128:n>>>7&127;case 5:a[o+4]=5!==s?128|n:127&n;case 4:a[o+3]=4!==s?i>>>21|128:i>>>21&127;case 3:a[o+2]=3!==s?i>>>14|128:i>>>14&127;case 2:a[o+1]=2!==s?i>>>7|128:i>>>7&127;case 1:a[o]=1!==s?128|i:127&i;}}function Wk(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n);}return i}const Hk=new Map([["moderation",1],["supervise",2]]);class Kk extends iT{get connectionState(){return this._connectionState}set connectionState(e){if(this._connectionState===e)return;const t=this._connectionState;this._connectionState=e,this.emit(SI.CONNECTION_STATE_CHANGE,t,e);}get inspectType(){return this._inspectType}set inspectType(e){var t;this._inspectMode=cS(t=e.map((e=>Hk.get(e)||0))).call(t,((e,t)=>e+t)),this._inspectType=e;}get quality(){return this._quality}set quality(e){this._quality=e>1?1:e<.1?.1:e,this.qualityTimer&&(window.clearTimeout(this.qualityTimer),this.qualityTimer=null),this._quality>=1||(this.qualityTimer=window.setTimeout((()=>{this.quality=this._quality/this.qualityRatio;}),6e4));}constructor(e){super(),nu(this,"name","AgoraRTCVideoContentInspect"),nu(this,"_connectionState",gI.CONNECTING),nu(this,"_innerConnectionState",void 0),nu(this,"sequence",0),nu(this,"inspectStartTime",void 0),nu(this,"workerManagerConnection",void 0),nu(this,"workerConnection",void 0),nu(this,"workerMessageLengthLimit",void 0),nu(this,"inspectIntervalMinimum",void 0),nu(this,"qualityRatio",void 0),nu(this,"_connectInfo",void 0),nu(this,"_cancelTokenSource",EC.CancelToken.source()),nu(this,"_retryConfig",void 0),nu(this,"wmSequence",0),nu(this,"inspectInterval",void 0),nu(this,"inspectTimer",null),nu(this,"ossFilePrefix",void 0),nu(this,"extraInfo",void 0),nu(this,"_inspectType",void 0),nu(this,"_inspectMode",void 0),nu(this,"_quality",1),nu(this,"qualityTimer",null),nu(this,"_inspectId",void 0),nu(this,"_needWorkUrlOnly",!1),nu(this,"inspectImage",(()=>{if(this.connectionState!==gI.CONNECTED)throw new xv(xg.OPERATION_ABORTED,"content inspect service connection status is ".concat(this.connectionState));this.inspectTimer&&(window.clearInterval(this.inspectTimer),this.inspectTimer=null),this.inspectTimer=window.setInterval((()=>{this.connectionState===gI.CONNECTED?this.requestToInspectImage():KC.debug("[".concat(this._inspectId,"] Inspect State is not connected , "),this.connectionState);}),this.inspectInterval<this.inspectIntervalMinimum?this.inspectIntervalMinimum:this.inspectInterval),this.requestToInspectImage();})),this._inspectId=xT(5,"inspect-"),this.workerMessageLengthLimit=kC("VIDEO_INSPECT_WORKER_MESSAGE_LENGTH_LIMIT"),this.inspectIntervalMinimum=kC("VIDEO_INSPECT_INTERVAL_MINIMUM"),this.qualityRatio=kC("VIDEO_INSPECT_QUALITY_RATIO"),this.inspectInterval=e.interval,this.ossFilePrefix=e.ossFilePrefix,this.extraInfo=e.extraInfo,this.inspectType=e.inspectType,this.inspectStartTime=Number(Date.now()),this.workerManagerConnection=new XI("worker-manager-"+this._inspectId,JT),this.on(SI.STATE_CHANGE,((e,t)=>{this._innerConnectionState=e,KC.debug("[".concat(this._inspectId,"] Inspect operation :").concat(TI[e]," ").concat(t||""));})),this.handleWorkerManagerEvents(),this.workerConnection=new XI("worker-"+this._inspectId,JT),this.handleWorkerEvents();}async init(e,t){this.emit(SI.STATE_CHANGE,TI.CONNECT_AP),this._connectInfo=e;const i=this._cancelTokenSource.token;return this._retryConfig=t,new tg(((n,r)=>{this.on(SI.CONNECTION_STATE_CHANGE,((e,t)=>{t===gI.CONNECTED&&n();})),this.requestAP(e,i,t).then((e=>{this.connectWorkerManager(e);})).catch((e=>{r(e);}));}))}async requestAP(e,t,i){const n=kC("WEBCS_DOMAIN").map((e=>"https://".concat(e,"/api/v1"))),r=await function(e,t,i,n){let{appId:r,areaCode:s,cname:o,sid:a,token:c,uid:d}=t;oP++;const l="image_moderation_api",h={service_name:l,json_body:JSON.stringify({appId:r,areaCode:s,cname:o,command:"allocateEdge",requestId:oP,seq:oP,sid:a,token:c,ts:Date.now(),uid:d+""})};let u,p,_=e[0];return XT((async()=>{u=Date.now();const e=await VD(_,{data:h,cancelToken:i,headers:{"X-Packet-Service-Type":"0","X-Packet-URI":"61"},params:{action:"wrtc_gateway"}});if(p=Date.now()-u,0!==e.code){const t=new xv(xg.UNEXPECTED_RESPONSE,"image inspect ap error, code"+e.code,{retry:!0,responseTime:p});throw KC.error(t.toString()),t}const t=JSON.parse(e.json_body);if(200!==t.code){const e=new xv(xg.UNEXPECTED_RESPONSE,"image inspect ap error, code: ".concat(t.code,", reason: ").concat(t.reason),{code:t.code,responseTime:p});throw KC.error(e.toString()),e}if(!t.servers||!Array.isArray(t.servers)||0===t.servers.length){const e=new xv(xg.UNEXPECTED_RESPONSE,"image inspect ap empty server",{code:t.code,responseTime:p});throw KC.error(e.toString()),e}const n=kC("VIDEO_INSPECT_WORKER_MANAGER_HOST"),r=kC("VIDEO_INSPECT_WORKER_MANAGER_PORT");return {addressList:t.servers.map((e=>{let{address:t,wss:i}=e;if(t&&i)return "wss://".concat(t.replace(/\./g,"-"),".").concat(n,":").concat(r||i)})).filter((e=>!!e)),workerToken:t.workerToken,vid:t.vid,responseTime:p}}),((t,i)=>(rv.apworkerEvent(a,{success:!0,sc:200,serviceName:l,responseDetail:JSON.stringify(t.addressList),firstSuccess:0===i,responseTime:p,serverIp:e[i%e.length]}),!1)),((t,i)=>(rv.apworkerEvent(a,{success:!1,sc:t.data&&t.data.code||200,serviceName:l,responseTime:p,serverIp:e[i%e.length]}),!!(t.code!==xg.OPERATION_ABORTED&&t.code!==xg.UNEXPECTED_RESPONSE||t.data&&t.data.retry)&&(_=e[(i+1)%e.length],!0))),n)}(n,e,t,i);this.emit(SI.STATE_CHANGE,TI.AP_CONNECTED);const{addressList:s}=r;return this.wmSequence++,s}async connectWorkerManager(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];this._needWorkUrlOnly=t,this.emit(SI.STATE_CHANGE,TI.CONNECT_WORKER_MANAGER),await this.workerManagerConnection.init(e,1e4);}async connectWorker(e){await this.workerConnection.init([e]);}handleWorkerManagerEvents(){this.workerManagerConnection.on(Iv.CONNECTED,(async()=>{this.emit(SI.STATE_CHANGE,TI.WORKER_MANAGER_CONNECTED,this.workerManagerConnection.url),this.workerManagerConnection.sendMessage({appId:this._connectInfo.appId,cname:this._connectInfo.cname,uid:this._connectInfo.uid+"",sdkVersion:"4.19.3",sid:this._connectInfo.sid,seq:this.wmSequence,ts:Number(Date.now()),requestId:Math.floor(1e12*Math.random()),allocate:!0,clientRequest:{command:"join"}},!0);})),this.workerManagerConnection.on(Iv.CLOSED,(()=>{this._innerConnectionState<TI.GET_WORKER_MANAGER_RESPONSE&&KC.debug("[".concat(this._inspectId,"] Inspect worker manager is closed before connecting worker"));})),this.workerManagerConnection.on(Iv.FAILED,(()=>{this._innerConnectionState<TI.GET_WORKER_MANAGER_RESPONSE&&KC.debug("[".concat(this._inspectId,"] Connecting inspect worker manager is failed before connecting worker"));})),this.workerManagerConnection.on(Iv.RECONNECTING,(()=>{this._innerConnectionState<TI.GET_WORKER_MANAGER_RESPONSE&&KC.debug("[".concat(this._inspectId,"] Inspect worker manager is reconnecting before connecting worker"));})),this.workerManagerConnection.on(Iv.ON_MESSAGE,(async e=>{this.emit(SI.STATE_CHANGE,TI.GET_WORKER_MANAGER_RESPONSE);const t=this.workerManagerConnection.url;this.workerManagerConnection.close();const i=JSON.parse(e.data);if(200!==i.code)throw KC.error("[".concat(this._inspectId,"] Unexpected code ").concat(i.code," from worker manager")),new xv(xg.UNEXPECTED_RESPONSE,"response code of worker is unexpected",i);if(!(i.serverResponse&&i.serverResponse.portWss&&t))throw KC.error("[".concat(this._inspectId,"] Unexpected content from worker manager : ").concat(JSON.stringify(i))),new xv(xg.UNEXPECTED_RESPONSE,"response content of worker is unexpected",i);{const e=kC("VIDEO_INSPECT_WORKER_PORT")||i.serverResponse.portWss,n=t.replace(/:\d+\/?$/,":".concat(e));this.emit(SI.STATE_CHANGE,TI.CONNECT_WORKER,n),this._needWorkUrlOnly?this.emit(SI.REQUEST_NEW_WORKER_URL,n):await this.connectWorker(n);}})),this.workerManagerConnection.on(Iv.WILL_RECONNECT,((e,t,i)=>{i(e);})),this.workerManagerConnection.on(Iv.REQUEST_NEW_URLS,((e,t)=>{this.requestAP(this._connectInfo,this._cancelTokenSource.token,this._retryConfig).then(e).catch(t);}));}handleWorkerEvents(){this.workerConnection.on(Iv.CONNECTED,(async()=>{this.emit(SI.STATE_CHANGE,TI.WORKER_CONNECTED,this.workerConnection.url),this.connectionState=gI.CONNECTED;})),this.workerConnection.on(Iv.ON_MESSAGE,(async e=>{if(e.data instanceof ArrayBuffer){const i=fk(new Uint8Array(e.data));if(kC("SHOW_VIDEO_INSPECT_WORKER_MESSAGE")&&KC.debug("[".concat(this._inspectId,"] Response message for worker of inspect content "),JSON.stringify(i)),200===i.code){if(Array.isArray(this.inspectType)&&1===this.inspectType.length&&"supervise"===this.inspectType[0])return void this.emit(SI.INSPECT_RESULT,void 0,void 0);if(i.data&&i.data.scorePorn&&i.data.scoreSexy&&i.data.scoreNeutral){var t;const e={porn:i.data.scorePorn,sexy:i.data.scoreSexy,neutral:i.data.scoreNeutral},n=cS(t=Object.keys(e)).call(t,((t,i)=>e[t]>e[i]?t:i),"porn"),r=Object.keys(e).find((e=>e===n));this.emit(SI.INSPECT_RESULT,r);}else this.emit(SI.INSPECT_RESULT,void 0,new xv(xg.UNEXPECTED_RESPONSE,i.code+"","There is an unexpected data on message"));}else this.emit(SI.INSPECT_RESULT,void 0,new xv(xg.UNEXPECTED_RESPONSE,i.code+"",i.msg));}else KC.error("[".concat(this._inspectId,"] Unexpected message type from worker")),this.emit(SI.INSPECT_RESULT,void 0,new xv(xg.UNEXPECTED_RESPONSE,"invalid worker message type"));})),this.workerConnection.on(Iv.CLOSED,(()=>{this.connectionState=gI.CLOSED;})),this.workerConnection.on(Iv.FAILED,(()=>{this.connectionState=gI.CLOSED;})),this.workerConnection.on(Iv.RECONNECTING,(()=>{this.connectionState=this.connectionState===gI.CONNECTED?gI.RECONNECTING:gI.CONNECTING;})),this.workerConnection.on(Iv.WILL_RECONNECT,((e,t,i)=>{"recover"===e&&i(e),i("tryNext");})),this.workerConnection.on(Iv.REQUEST_NEW_URLS,((e,t)=>{this.workerManagerConnection.close(),this.once(SI.REQUEST_NEW_WORKER_URL,(t=>{e([t]);})),this.requestAP(this._connectInfo,this._cancelTokenSource.token,this._retryConfig).then((e=>{this.connectWorkerManager(e,!0);})).catch((e=>{t(e);}));}));}static intToLong(e){return {low:e|=0,high:e>>31,unsigned:e>=0}}async requestToInspectImage(){this.sequence++;const e=TT(this,SI.CLIENT_LOCAL_VIDEO_TRACK),t={appId:this._connectInfo.appId,cname:this._connectInfo.cname,cid:this._connectInfo.cid,sid:this._connectInfo.sid,uid:this._connectInfo.uid,vid:this._connectInfo.vid};if(e){if(!e.isPlaying)return void this.emit(SI.INSPECT_RESULT,void 0,new xv(xg.INVALID_OPERATION,"Only the track being played can be inspected"));const i=await this.generateRequestData(e,t);this.workerConnection.sendMessage(i,!0,!0);}else this.emit(SI.INSPECT_RESULT,void 0,new xv(xg.INVALID_OPERATION,"Only the track being published can be inspected"));}async generateRequestData(e,t){let{appId:i,cname:n,cid:r,vid:s,sid:o,uid:a}=t;const c=Date.now(),d=await e.getCurrentFrameImage("image/jpeg",this.quality),l=await fb(d,i,n),h=this.sequence+"-"+r+"-"+a+"-"+c+"-"+xT(12,""),u={appId:i,cid:r,cname:n,deviceId:"",elapse:Kk.intToLong(Number(c-this.inspectStartTime)),fileSize:l.byteLength,jpgEncryption:2,height:d.height,width:d.width,jpg:l,networkType:6,osType:7,requestId:h,sdkVersion:"4.19.3",sequence:this.sequence,sid:o,timestamp:Kk.intToLong(c),uid:a,vid:s,service:this._inspectMode,callbackData:this.extraInfo,ossFilePrefix:this.ossFilePrefix};void 0===this.extraInfo&&delete u.callbackData,void 0===this.ossFilePrefix&&delete u.ossFilePrefix;const p=mk(u);if(p.byteLength<this.workerMessageLengthLimit){if(kC("SHOW_VIDEO_INSPECT_WORKER_MESSAGE")){const e=function(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?Wk(Object(i),!0).forEach((function(t){nu(e,t,i[t]);})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):Wk(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t));}));}return e}({},u);delete e.jpg,KC.debug("[".concat(this._inspectId,"] Request message for worker of inspect content "),JSON.stringify(e));}return p}{const t=this.quality*this.qualityRatio;return this.quality=t,await this.generateRequestData(e,{appId:i,cname:n,cid:r,vid:s,sid:o,uid:a})}}close(){this._cancelTokenSource.cancel(),this._cancelTokenSource=EC.CancelToken.source(),this.workerManagerConnection&&this.workerManagerConnection.close(),this.workerConnection&&this.workerConnection.close(),this.inspectTimer&&window.clearInterval(this.inspectTimer),this.inspectTimer=null,this.connectionState=gI.CLOSED,this.emit(SI.STATE_CHANGE,TI.CLOSED);}}function Yk(e){let t=function(){const e=Xk.pop();return e?(e.offset=e.limit=0,e):{bytes:new Uint8Array(64),offset:0,limit:0}}();return function(e,t){let i=e.appId;void 0!==i&&(aM(t,10),nM(t,i));let n=e.cid;void 0!==n&&(aM(t,16),aM(t,n));let r=e.cname;void 0!==r&&(aM(t,26),nM(t,r));let s=e.deviceId;void 0!==s&&(aM(t,34),nM(t,s));let o=e.elapse;void 0!==o&&(aM(t,40),dM(t,o));let a=e.fileSize;void 0!==a&&(aM(t,48),dM(t,zk(a)));let c=e.height;void 0!==c&&(aM(t,56),dM(t,zk(c)));let d=e.jpg;void 0!==d&&(aM(t,66),aM(t,d.length),tM(t,d));let l=e.networkType;void 0!==l&&(aM(t,72),dM(t,zk(l)));let h=e.osType;void 0!==h&&(aM(t,80),dM(t,zk(h)));let u=e.requestId;void 0!==u&&(aM(t,90),nM(t,u));let p=e.sdkVersion;void 0!==p&&(aM(t,98),nM(t,p));let _=e.sequence;void 0!==_&&(aM(t,104),dM(t,zk(_)));let E=e.sid;void 0!==E&&(aM(t,114),nM(t,E));let m=e.timestamp;void 0!==m&&(aM(t,120),dM(t,m));let f=e.uid;void 0!==f&&(aM(t,128),aM(t,f));let g=e.vid;void 0!==g&&(aM(t,136),aM(t,g));let T=e.width;void 0!==T&&(aM(t,144),dM(t,zk(T)));let S=e.service;void 0!==S&&(aM(t,152),aM(t,S));let R=e.callbackData;void 0!==R&&(aM(t,162),aM(t,R.length),tM(t,R));let C=e.ticket;void 0!==C&&(aM(t,170),nM(t,C));}(e,t),function(e){let t=e.bytes,i=e.limit;return t.length===i?t:t.subarray(0,i)}(t)}function qk(e){return function(e){let t={};e:for(;!Zk(e);){let i=oM(e);switch(i>>>3){case 0:break e;case 1:t.code=oM(e);break;case 2:t.msg=iM(e,oM(e));break;case 3:t.requestId=iM(e,oM(e));break;case 4:t.timestamp=cM(e,!1);break;default:Jk(e,7&i);}}return t}({bytes:t=e,offset:0,limit:t.length});var t;}function Jk(e,t){switch(t){case 0:for(;128&rM(e););break;case 2:Qk(e,oM(e));break;case 5:Qk(e,4);break;case 1:Qk(e,8);break;default:throw new Error("Unimplemented type: "+t)}}function zk(e){return {low:e|=0,high:e>>31,unsigned:e>=0}}let Xk=[];function Qk(e,t){if(e.offset+t>e.limit)throw new Error("Skip past limit");e.offset+=t;}function Zk(e){return e.offset>=e.limit}function $k(e,t){let i=e.bytes,n=e.offset,r=e.limit,s=n+t;if(s>i.length){let t=new Uint8Array(2*s);t.set(i),e.bytes=t;}return e.offset=s,s>r&&(e.limit=s),n}function eM(e,t){let i=e.offset;if(i+t>e.limit)throw new Error("Read past limit");return e.offset+=t,i}function tM(e,t){let i=$k(e,t.length);e.bytes.set(t,i);}function iM(e,t){let i=eM(e,t),n=String.fromCharCode,r=e.bytes,s="�",o="";for(let e=0;e<t;e++){let a,c,d,l,h=r[e+i];0==(128&h)?o+=n(h):192==(224&h)?e+1>=t?o+=s:(a=r[e+i+1],128!=(192&a)?o+=s:(l=(31&h)<<6|63&a,l<128?o+=s:(o+=n(l),e++))):224==(240&h)?e+2>=t?o+=s:(a=r[e+i+1],c=r[e+i+2],32896!=(49344&(a|c<<8))?o+=s:(l=(15&h)<<12|(63&a)<<6|63&c,l<2048||l>=55296&&l<=57343?o+=s:(o+=n(l),e+=2))):240==(248&h)?e+3>=t?o+=s:(a=r[e+i+1],c=r[e+i+2],d=r[e+i+3],8421504!=(12632256&(a|c<<8|d<<16))?o+=s:(l=(7&h)<<18|(63&a)<<12|(63&c)<<6|63&d,l<65536||l>1114111?o+=s:(l-=65536,o+=n(55296+(l>>10),56320+(1023&l)),e+=3))):o+=s;}return o}function nM(e,t){let i=t.length,n=0;for(let e=0;e<i;e++){let r=t.charCodeAt(e);r>=55296&&r<=56319&&e+1<i&&(r=(r<<10)+t.charCodeAt(++e)-56613888),n+=r<128?1:r<2048?2:r<65536?3:4;}aM(e,n);let r=$k(e,n),s=e.bytes;for(let e=0;e<i;e++){let n=t.charCodeAt(e);n>=55296&&n<=56319&&e+1<i&&(n=(n<<10)+t.charCodeAt(++e)-56613888),n<128?s[r++]=n:(n<2048?s[r++]=n>>6&31|192:(n<65536?s[r++]=n>>12&15|224:(s[r++]=n>>18&7|240,s[r++]=n>>12&63|128),s[r++]=n>>6&63|128),s[r++]=63&n|128);}}function rM(e){return e.bytes[eM(e,1)]}function sM(e,t){let i=$k(e,1);e.bytes[i]=t;}function oM(e){let t,i=0,n=0;do{t=rM(e),i<32&&(n|=(127&t)<<i),i+=7;}while(128&t);return n}function aM(e,t){for(t>>>=0;t>=128;)sM(e,127&t|128),t>>>=7;sM(e,t);}function cM(e,t){let i,n=0,r=0,s=0;return i=rM(e),n=127&i,128&i&&(i=rM(e),n|=(127&i)<<7,128&i&&(i=rM(e),n|=(127&i)<<14,128&i&&(i=rM(e),n|=(127&i)<<21,128&i&&(i=rM(e),r=127&i,128&i&&(i=rM(e),r|=(127&i)<<7,128&i&&(i=rM(e),r|=(127&i)<<14,128&i&&(i=rM(e),r|=(127&i)<<21,128&i&&(i=rM(e),s=127&i,128&i&&(i=rM(e),s|=(127&i)<<7))))))))),{low:n|r<<28,high:r>>>4|s<<24,unsigned:t}}function dM(e,t){let i=t.low>>>0,n=(t.low>>>28|t.high<<4)>>>0,r=t.high>>>24,s=0===r?0===n?i<16384?i<128?1:2:i<1<<21?3:4:n<16384?n<128?5:6:n<1<<21?7:8:r<128?9:10,o=$k(e,s),a=e.bytes;switch(s){case 10:a[o+9]=r>>>7&1;case 9:a[o+8]=9!==s?128|r:127&r;case 8:a[o+7]=8!==s?n>>>21|128:n>>>21&127;case 7:a[o+6]=7!==s?n>>>14|128:n>>>14&127;case 6:a[o+5]=6!==s?n>>>7|128:n>>>7&127;case 5:a[o+4]=5!==s?128|n:127&n;case 4:a[o+3]=4!==s?i>>>21|128:i>>>21&127;case 3:a[o+2]=3!==s?i>>>14|128:i>>>14&127;case 2:a[o+1]=2!==s?i>>>7|128:i>>>7&127;case 1:a[o]=1!==s?128|i:127&i;}}const lM={},hM={},uM=4294967296,pM=uM*uM,_M=pM/2,EM=SM(0,!0),mM=SM(0),fM=RM(0,-2147483648,!1),gM=RM(-1,2147483647,!1),TM=RM(-1,-1,!0);function SM(e,t){let i,n,r;return t?(r=0<=(e>>>=0)&&e<256)&&(n=hM[e],n)?n:(i=RM(e,0,!0),r&&(hM[e]=i),i):(r=-128<=(e|=0)&&e<128)&&(n=lM[e],n)?n:(i=RM(e,e<0?-1:0,!1),r&&(lM[e]=i),i)}function RM(e,t,i){return {low:0|e,high:0|t,unsigned:!!i}}function CM(e,t){if(isNaN(e))return t?EM:mM;if(t){if(e<0)return EM;if(e>=pM)return TM}else {if(e<=-_M)return fM;if(e+1>=_M)return gM}return e<0?t?EM:mM:RM(e%uM|0,e/uM|0,t)}function vM(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n);}return i}class IM extends iT{get connectionState(){return this._connectionState}set connectionState(e){if(this._connectionState===e)return;const t=this._connectionState;this._connectionState=e,this.emit(AI.CONNECTION_STATE_CHANGE,e,t);}get quality(){return this._quality}set quality(e){this._quality=e>1?1:e<.1?.1:e,this._qualityTimer&&(window.clearTimeout(this._qualityTimer),this._qualityTimer=null),this._quality>=1||(this._qualityTimer=window.setTimeout((()=>{this.quality=this._quality/this._qualityRatio;}),6e4));}constructor(e){var t;super(),nu(this,"name","AgoraRTCImageModeration"),nu(this,"_connectionState",yI.CONNECTING),nu(this,"_sequence",0),nu(this,"_moderationStartTime",void 0),nu(this,"_workerConnection",void 0),nu(this,"_workerMessageLengthLimit",void 0),nu(this,"_qualityRatio",void 0),nu(this,"_connectInfo",void 0),nu(this,"_cancelTokenSource",EC.CancelToken.source()),nu(this,"_retryConfig",void 0),nu(this,"_moderationInterval",void 0),nu(this,"_moderationTimer",null),nu(this,"_moderationMode",1),nu(this,"_quality",1),nu(this,"_qualityTimer",null),nu(this,"_ticket",void 0),nu(this,"_moderationIntervalMinimum",void 0),nu(this,"_uploadFailedNum",0),nu(this,"_uploadNum",0),nu(this,"_uploadTimer",null),nu(this,"_moderationId",void 0),nu(this,"inspectImage",(()=>{if(this.connectionState!==yI.CONNECTED)throw new xv(xg.OPERATION_ABORTED,"image moderation service connection status is ".concat(this.connectionState));this._moderationTimer&&(window.clearInterval(this._moderationTimer),this._moderationTimer=null),this._moderationTimer=window.setInterval((()=>{this.connectionState===yI.CONNECTED?this.requestToInspectImage():KC.debug("[".concat(this._moderationId,"] Moderation State is not connected , "),this.connectionState);}),this._moderationInterval<this._moderationIntervalMinimum?this._moderationIntervalMinimum:this._moderationInterval),this.requestToInspectImage();})),this._moderationId=xT(5,"image-moderation-"),this._workerMessageLengthLimit=kC("IMAGE_MODERATION_WORKER_MESSAGE_LENGTH_LIMIT"),this._moderationIntervalMinimum=kC("IMAGE_MODERATION_INTERVAL_MINIMUM"),this._moderationInterval=null!==(t=e.interval)&&void 0!==t?t:1e3,this._qualityRatio=kC("IMAGE_MODERATION_QUALITY_RATIO"),this._moderationStartTime=Number(Date.now()),this._workerConnection=new XI("worker-"+this._moderationId,JT),this.on(AI.STATE_CHANGE,((e,t)=>{KC.debug("[".concat(this._moderationId,"] Moderation operation :").concat(bI[e]," ").concat(t||""));})),this.handleWorkerEvents();}async init(e,t){this.emit(AI.STATE_CHANGE,bI.CONNECT_AP),this._connectInfo=e;const i=this._cancelTokenSource.token;return this._retryConfig=t,new tg(((n,r)=>{this.on(AI.CONNECTION_STATE_CHANGE,((e,t)=>{e===yI.CONNECTED&&n();})),this.requestAP(e,i,t).then((e=>{this.connectWorker(e);})).catch((e=>{r(e);}));}))}updateConfig(e){var t;this._moderationInterval=null!==(t=e.interval)&&void 0!==t?t:1e3,KC.debug("[".concat(this._moderationId,"] updateConfig: ").concat(JSON.stringify(e))),this.connectionState===yI.CONNECTED&&this.inspectImage();}async requestAP(e,t,i){const n=kC("WEBCS_DOMAIN").map((e=>"https://".concat(e,"/api/v1"))),r=await function(e,t,i,n){let{appId:r,areaCode:s,cname:o,sid:a,token:c,uid:d}=t;oP++;const l="moderation_plugin",h={service_name:l,json_body:JSON.stringify({appId:r,areaCode:s,cname:o,command:"allocateEdge",requestId:oP,seq:oP,sid:a,appToken:c,ts:Date.now(),uid:d+""})};let u,p,_=e[0];return XT((async()=>{u=Date.now();const e=await VD(_,{data:h,cancelToken:i,headers:{"X-Packet-Service-Type":"0","X-Packet-URI":"61"},params:{action:"wrtc_gateway"}});if(p=Date.now()-u,0!==e.code){const t=new xv(xg.UNEXPECTED_RESPONSE,"moderation plugin ap error, code"+e.code,{retry:!0,responseTime:p});throw KC.error(t.toString()),t}const t=JSON.parse(e.json_body);if(200!==t.code){const e=new xv(xg.UNEXPECTED_RESPONSE,"moderation plugin ap error, code: ".concat(t.code,", reason: ").concat(t.reason),{code:t.code,responseTime:p});throw KC.error(e.toString()),e}if(!t.servers||!Array.isArray(t.servers)||0===t.servers.length){const e=new xv(xg.UNEXPECTED_RESPONSE,"moderation plugin ap empty server",{code:t.code,responseTime:p});throw KC.error(e.toString()),e}if(!t.servers.some((e=>!!e.wss))){const e=new xv(xg.UNEXPECTED_RESPONSE,"moderation plugin ap empty port",{code:t.code,responseTime:p});throw KC.error(e.toString()),e}const n=kC("IMAGE_MODERATION_WORKER_HOST");return {addressList:t.servers.map((e=>{let{address:t,wss:i}=e;if(t&&i)return "wss://".concat(t.replace(/\./g,"-"),".").concat(n,":").concat(i,"/moderation")})).filter((e=>!!e)),workerToken:t.workerToken,vid:t.vid,ticket:t.appTicket,responseTime:p}}),((t,i)=>(rv.apworkerEvent(a,{success:!0,sc:200,serviceName:l,responseDetail:JSON.stringify(t.addressList),firstSuccess:0===i,responseTime:p,serverIp:e[i%e.length]}),!1)),((t,i)=>(rv.apworkerEvent(a,{success:!1,sc:t.data&&t.data.code||200,serviceName:l,responseTime:p,serverIp:e[i%e.length]}),!!(t.code!==xg.OPERATION_ABORTED&&t.code!==xg.UNEXPECTED_RESPONSE||t.data&&t.data.retry)&&(_=e[(i+1)%e.length],!0))),n)}(n,e,t,i);this.emit(AI.STATE_CHANGE,bI.AP_CONNECTED);const{addressList:s,ticket:o}=r;return this._ticket=o,s}async connectWorker(e){this.emit(AI.STATE_CHANGE,bI.CONNECT_WORKER),await this._workerConnection.init(e,1e4);}handleWorkerEvents(){this._workerConnection.on(Iv.CONNECTED,(async()=>{this.emit(AI.STATE_CHANGE,bI.WORKER_CONNECTED,this._workerConnection.url),this.connectionState=yI.CONNECTED;})),this._workerConnection.on(Iv.CLOSED,(()=>{this.connectionState=yI.CLOSED;})),this._workerConnection.on(Iv.FAILED,(()=>{this.connectionState=yI.CLOSED;})),this._workerConnection.on(Iv.RECONNECTING,(()=>{this.connectionState=this.connectionState===yI.CONNECTED?yI.RECONNECTING:yI.CONNECTING;})),this._workerConnection.on(Iv.ON_MESSAGE,(async e=>{if(e.data instanceof ArrayBuffer){const t=qk(new Uint8Array(e.data));kC("SHOW_IMAGE_MODERATION_WORKER_MESSAGE")&&KC.debug("[".concat(this._moderationId,"] Response message for worker of image moderation "),JSON.stringify(t)),this._uploadNum++,void 0===t.code||0===t.code||(this._uploadFailedNum++,KC.error("[".concat(this._moderationId,"] Error response from worke, code is ").concat(t.code,", msg is ").concat(t.msg)),this._uploadTimer||(this._uploadTimer=window.setTimeout((()=>{rv.reportApiInvoke(this._connectInfo.sid||null,{name:sT.IMAGE_MODERATION_UPLOAD,options:[this._uploadFailedNum,this._uploadNum,t.code],tag:oT.TRACER}).onError(new xv(xg.IMAGE_MODERATION_UPLOAD_FAILED,t.msg)),this._uploadTimer=null;}),kC("IMAGE_MODERATION_UPLOAD_REPORT_INTERVAL"))));}else KC.error("[".concat(this._moderationId,"] Unexpected message type from worker"));})),this._workerConnection.on(Iv.WILL_RECONNECT,((e,t,i)=>{"recover"===e&&i(e),i("tryNext");})),this._workerConnection.on(Iv.REQUEST_NEW_URLS,((e,t)=>{this.requestAP(this._connectInfo,this._cancelTokenSource.token,this._retryConfig).then(e).catch(t);}));}static intToLong(e){return {low:e|=0,high:e>>31,unsigned:e>=0}}async requestToInspectImage(){const e=TT(this,AI.CLIENT_LOCAL_VIDEO_TRACK),t={appId:this._connectInfo.appId,cname:this._connectInfo.cname,cid:this._connectInfo.cid,sid:this._connectInfo.sid,uid:this._connectInfo.uid,vid:this._connectInfo.vid};if(e){if(!e.isPlaying)return void(kC("SHOW_IMAGE_MODERATION_WORKER_MESSAGE")&&KC.debug("Only the track being played can be inspected"));this._sequence++;const i=await this.generateRequestData(e,t);this._workerConnection.sendMessage(i,!0,!0);}else kC("SHOW_IMAGE_MODERATION_WORKER_MESSAGE")&&KC.debug("Only the track being published can be inspected");}async generateRequestData(e,t){let{appId:i,cname:n,cid:r,vid:s,sid:o,uid:a}=t;const c=Date.now(),d=await e.getCurrentFrameImage("image/jpeg",this.quality),l=await fb(d,i,n),h=this._sequence+"-"+r+"-"+a+"-"+c+"-"+xT(12,""),u={appId:i,cid:r,cname:n,deviceId:"",elapse:IM.intToLong(Number(c-this._moderationStartTime)),fileSize:d.buffer.byteLength,height:d.height,width:d.width,jpg:l,networkType:6,osType:7,requestId:h,sdkVersion:"4.19.3",sequence:this._sequence,sid:o,timestamp:CM(c),uid:a,vid:s,service:this._moderationMode,ticket:this._ticket},p=Yk(u);if(p.byteLength<this._workerMessageLengthLimit){if(kC("SHOW_IMAGE_MODERATION_WORKER_MESSAGE")){const e=function(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?vM(Object(i),!0).forEach((function(t){nu(e,t,i[t]);})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):vM(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t));}));}return e}({},u);delete e.jpg,KC.debug("[".concat(this._moderationId,"] Request message for worker of image moderation service: "),JSON.stringify(e));}return p}{const t=this.quality*this._qualityRatio;return this.quality=t,await this.generateRequestData(e,{appId:i,cname:n,cid:r,vid:s,sid:o,uid:a})}}close(){this._cancelTokenSource.cancel(),this._cancelTokenSource=EC.CancelToken.source(),this._workerConnection&&this._workerConnection.close(),this._moderationTimer&&window.clearInterval(this._moderationTimer),this._moderationTimer=null,this._uploadTimer&&window.clearTimeout(this._uploadTimer),this._uploadTimer=null,this.connectionState=yI.CLOSED,this.emit(AI.STATE_CHANGE,bI.CLOSED);}}function yM(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n);}return i}function AM(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?yM(Object(i),!0).forEach((function(t){nu(e,t,i[t]);})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):yM(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t));}));}return e}class bM extends DI{get currentLocalDescription(){return this.peerConnection.currentLocalDescription}get currentRemoteDescription(){return this.peerConnection.currentRemoteDescription}get peerConnectionState(){return this.peerConnection.connectionState}get iceConnectionState(){return this.peerConnection.iceConnectionState}get dtlsTransportState(){var e,t;return null!==(e=null===(t=this.peerConnection.getReceivers()[0])||void 0===t||null===(t=t.transport)||void 0===t?void 0:t.state)&&void 0!==e?e:null}constructor(e,t,i){super(e,t),nu(this,"direction",void 0),nu(this,"store",void 0),nu(this,"peerConnection",void 0),nu(this,"transportEventReceiver",void 0),nu(this,"statsFilter",void 0),nu(this,"localCandidateCount",0),nu(this,"allCandidatesReceived",!1),nu(this,"mutex",new YT("P2PConnection-mutex")),nu(this,"dataChannel",void 0),nu(this,"onLocalCandidate",void 0),this.store=t,this.peerConnection=new RTCPeerConnection(bM.resolvePCConfiguration(e),{optional:[{googDscp:!0}]}),this.direction=null!=i?i:vv.SEND_ONLY,this.dataChannel=this.peerConnection.createDataChannel("agora-p2p-signal",{ordered:!0}),this.statsFilter=PL(this.peerConnection,kC("STATS_UPDATE_INTERVAL"),void 0,Rg()?1200:void 0),this.bindPCEvents(),this.bindStatsEvents(),this.store.p2pId=this.store.p2pId+1;}async establish(e){try{if(e){await this.peerConnection.setRemoteDescription({type:"offer",sdp:e});const t=await this.peerConnection.createAnswer();if(await this.peerConnection.setLocalDescription(t),!t.sdp)throw new Error("Cannot get answer sdp when trying to establish PeerConnection.");return t.sdp}{const e=await this.peerConnection.createOffer();if(!e.sdp)throw new Error("Cannot get initialOffer.sdp when trying to establish PeerConnection.");return await this.peerConnection.setLocalDescription(e),e.sdp}}catch(e){throw new Vg(xg.GET_LOCAL_CONNECTION_PARAMS_FAILED,e.toString())}}async connect(e){try{await this.peerConnection.setRemoteDescription({type:"answer",sdp:e});}catch(e){throw new Vg(xg.EXCHANGE_SDP_FAILED,"P2PConnection.connect failed; ".concat(e.toString()))}}async addRemoteCandidate(e){try{await this.peerConnection.addIceCandidate(e);}catch(e){throw new Vg(xg.ADD_CANDIDATE_FAILED,"P2PConnection.addRemoteCandidate failed; ".concat(e.toString()))}}async send(e){try{const t=[];e.forEach((e=>{const i=this.peerConnection.addTransceiver(e._mediaStreamTrack,{direction:"sendonly"});t.push(i);})),Rg()&&!0===kC("SIMULCAST")&&await this.applySimulcastForFirefox(t,e),await this.applySimulcastEncodings(t,e),await this.applySendEncodings(t,e);const i=await this.peerConnection.createOffer();if(await this.peerConnection.setLocalDescription(i),!i.sdp)throw new Error("Cannot get offer.sdp when trying to send PeerConnection.");const n=t.map((e=>{const t=this.getLocalSSRC(e.mid,i.sdp);if(!t)throw new Error("Cannot get ssrc when trying to send PeerConnection.");return {mid:e.mid,localSSRC:[{ssrcId:t}]}}));return {sdp:i.sdp,trackMessage:n}}catch(e){throw e instanceof Vg?e:new Vg(xg.EXCHANGE_SDP_FAILED,"P2PConnection.send failed; ".concat(e.toString()))}}async stopSending(e,t){const i=t?void 0:await this.mutex.lock("From P2PConnection.stopSending");try{const t=this.peerConnection.getTransceivers().filter((t=>-1!==e.indexOf(t.mid)));if(t.length!==e.length)throw new Error("Transceivers' length (".concat(t.length,") doesn't match mids' length (").concat(e.length,") when trying to call P2PConnection.stopSending."));t.map((e=>{var t;e.direction="inactive",null===(t=e.stop)||void 0===t||t.call(e),this.peerConnection.removeTrack(e.sender);}));const n=await this.peerConnection.createOffer();if(await this.peerConnection.setLocalDescription(n),!n.sdp)throw new Error("Cannot get offer.sdp when trying to send PeerConnection.");return n.sdp}catch(e){throw new Vg(xg.EXCHANGE_SDP_FAILED,"P2PConnection.stopSending failed; ".concat(e.toString()))}finally{i&&i();}}async receive(e,t,i){try{await this.peerConnection.setRemoteDescription({type:"offer",sdp:t});const n=await this.peerConnection.createAnswer();if(!n.sdp)throw new Error("Cannot get answer sdp when trying to receive track.");await this.peerConnection.setLocalDescription(n),KC.debug("[".concat(this.store.clientId,"] [P2PConnection] receive ").concat(e," by exchanging SDP."));const r=this.getRemoteMid(i,t);if(void 0===r)throw new Error("Cannot get transceiver mid when trying to receive track.");const s=this.peerConnection.getTransceivers().find((e=>e.mid===r));if(!s||null===s.mid)throw new Error("Cannot get transceiver after setLocalDescription.");return {track:s.receiver.track,mid:s.mid,sdp:n.sdp}}catch(e){throw new Vg(xg.EXCHANGE_SDP_FAILED,"P2PConnection.receive failed; ".concat(e.toString()))}}async setDescription(e,t){try{if("remote"===e){await this.peerConnection.setRemoteDescription({type:"offer",sdp:t});const i=await this.peerConnection.createAnswer();if(!i.sdp)throw new Error("Cannot get answer sdp when trying to receive track.");return await this.peerConnection.setLocalDescription(i),KC.debug("[".concat(this.store.clientId,"] [P2PConnection] exchanging SDP, type is ").concat(e)),i.sdp}await this.peerConnection.setRemoteDescription({type:"answer",sdp:t});}catch(e){throw new Vg(xg.EXCHANGE_SDP_FAILED,"P2PConnection.setDescription failed; ".concat(e.toString()))}}async stopReceiving(e,t){try{const i=this.peerConnection.getTransceivers().filter((t=>-1!==e.indexOf(t.mid)));if(i.length!==e.length)throw new Error("Transceivers' length doesn't match mids' length when trying to call P2PConnection.stopSending.");i.map((e=>{var t;e.direction="inactive",null===(t=e.stop)||void 0===t||t.call(e);})),await this.peerConnection.setRemoteDescription({type:"offer",sdp:t});const n=await this.peerConnection.createAnswer();if(await this.peerConnection.setLocalDescription(n),!n.sdp)throw new Error("Cannot get answer sdp when trying to receive track.");return n.sdp}catch(e){throw new Vg(xg.EXCHANGE_SDP_FAILED,"P2PConnection stopReceiving failed; ".concat(e.toString()))}}async restartICE(){try{const e=await this.peerConnection.createOffer({iceRestart:!0});if(!e.sdp)throw new Error("Cannot restartICE because restart offer SDP does not exist.");return this.store.descriptionStart(),await this.peerConnection.setLocalDescription(e),e.sdp}catch(e){throw new Vg(xg.EXCHANGE_SDP_FAILED,"P2PConnection stopReceiving failed; ".concat(e.toString()))}}close(){var e;this.peerConnection.close(),null===(e=this.onConnectionStateChange)||void 0===e||e.call(this,"closed"),this.tryUnbindTransportEvents(),this.unbindPCEvents(),this.unbindStatsEvents(),this.transportEventReceiver=void 0,this.statsFilter.destroy();}getStats(){return this.statsFilter.getStats()}getRemoteVideoIsReady(e){return this.statsFilter.getVideoIsReady(e)}async updateEncoderConfig(e,t){}async updateSendParameters(e,t){const i=this.peerConnection.getTransceivers().filter((t=>t.mid===e));1===i.length&&(this.isVP8Simulcast(t)?Rg()||await this.applySimulcastEncodings(i,[t]):await this.applySendEncodings(i,[t]));}setStatsRemoteVideoIsReady(e,t){this.statsFilter.setVideoIsReady2(e,t);}async replaceTrack(e,t){const i=this.peerConnection.getTransceivers().find((e=>e.mid===t));i&&await i.sender.replaceTrack(e._mediaStreamTrack);}async getSelectedCandidatePair(){const e=this.peerConnection.getReceivers();if(e.length>0&&e[0].transport&&e[0].transport.iceTransport&&e[0].transport.iceTransport.getSelectedCandidatePair&&e[0].transport.iceTransport.getSelectedCandidatePair()){const t=e[0].transport.iceTransport,{local:i,remote:n}=t.getSelectedCandidatePair();return {local:AM(AM({},mL),{},{candidateType:i.type,protocol:i.protocol,address:i.address,port:i.port}),remote:AM(AM({},mL),{},{candidateType:n.type,protocol:n.protocol,address:n.address,port:n.port})}}return this.statsFilter.getSelectedCandidatePair()}bindPCEvents(){this.peerConnection.oniceconnectionstatechange=()=>{var e;null===(e=this.onICEConnectionStateChange)||void 0===e||e.call(this,this.peerConnection.iceConnectionState);},this.peerConnection.onconnectionstatechange=()=>{var e;null===(e=this.onConnectionStateChange)||void 0===e||e.call(this,this.peerConnection.connectionState);},this.peerConnection.onicecandidate=e=>{var t;e.candidate&&(null===(t=this.onLocalCandidate)||void 0===t||t.call(this,e.candidate));e.candidate?this.localCandidateCount+=1:(this.peerConnection.onicecandidate=null,this.allCandidatesReceived=!0,KC.debug("[".concat(this.store.clientId,"] [pc-").concat(this.store.p2pId,"] local candidate count"),this.localCandidateCount));},setTimeout((()=>{this.allCandidatesReceived||(this.allCandidatesReceived=!0,KC.debug("[".concat(this.store.clientId,"] [pc-").concat(this.store.p2pId,"] onicecandidate timeout, local candidate count"),this.localCandidateCount));}),kC("CANDIDATE_TIMEOUT"));}unbindPCEvents(){this.peerConnection.oniceconnectionstatechange=null,this.peerConnection.onconnectionstatechange=null,this.peerConnection.onsignalingstatechange=null,this.peerConnection.onicecandidateerror=null,this.peerConnection.onicecandidate=null,this.peerConnection.ontrack=null;}static resolvePCConfiguration(e){const t={iceServers:[]};return e.iceServers?t.iceServers=e.iceServers:e.turnServer&&"off"!==e.turnServer.mode&&(_T(e.turnServer.servers)?t.iceServers=e.turnServer.servers:(t.iceServers&&t.iceServers.push(...bM.turnServerConfigToIceServers(e.turnServer.servers)),kC("USE_TURN_SERVER_OF_GATEWAY")&&t.iceServers&&e.turnServer.serversFromGateway&&t.iceServers.push(...bM.turnServerConfigToIceServers(e.turnServer.serversFromGateway)),kC("FORCE_TURN_TCP")?t.iceTransportPolicy="relay":e.turnServer.servers.concat(e.turnServer.serversFromGateway||[]).forEach((e=>{e.forceturn&&(t.iceTransportPolicy="relay");})))),kC("ENABLE_ENCODED_TRANSFORM")&&_A().supportWebRTCEncodedTransform&&(t.encodedInsertableStreams=!0),t}static turnServerConfigToIceServers(e){const t=[];return e.forEach((e=>{e.tcpport&&(t.push({username:e.username,credential:e.password,credentialType:"password",urls:"turns:".concat(_D(e.turnServerURL),":").concat(e.tcpport,"?transport=tcp")}),t.push({username:e.username,credential:e.password,credentialType:"password",urls:"turn:".concat(e.turnServerURL,":").concat(e.tcpport,"?transport=udp")}),t.push({username:e.username,credential:e.password,credentialType:"password",urls:"stun:".concat(e.turnServerURL,":").concat(e.tcpport)}));})),t}tryBindTransportEvents(e){const t=e.transport;if(t){this.transportEventReceiver=e,t.onstatechange=()=>{var e;null!=t&&t.state&&(null===(e=this.onDTLSTransportStateChange)||void 0===e||e.call(this,t.state));},t.onerror=e=>{var t;null===(t=this.onDTLSTransportError)||void 0===t||t.call(this,"error"in e?e.error:e);};const i=t.iceTransport;i&&(i.onstatechange=()=>{const e=null==t?void 0:t.iceTransport.state;var i;e&&(null===(i=this.onICETransportStateChange)||void 0===i||i.call(this,e));},i.getSelectedCandidatePair&&(i.onselectedcandidatepairchange=()=>{if(i.getSelectedCandidatePair()){const{local:e,remote:t}=i.getSelectedCandidatePair();KC.info("[".concat(this.store.clientId,"] [pc-").concat(this.store.p2pId,"] selectedcandidatepairchange: local ").concat(JSON.stringify({candidateType:e.type,protocol:e.protocol}),", remote ").concat(JSON.stringify({candidateType:t.type,protocol:t.protocol,address:t.address,port:t.port})," )"));}}));}}tryUnbindTransportEvents(){this.transportEventReceiver&&this.transportEventReceiver.transport&&(this.transportEventReceiver.transport.onstatechange=null,this.transportEventReceiver.transport.onerror=null,this.transportEventReceiver.transport.iceTransport&&(this.transportEventReceiver.transport.iceTransport.onstatechange=null));}async updateRtpSenderEncodings(e,t){var i;if(!t){t=this.peerConnection.getSenders().find((t=>t.track===e._mediaStreamTrack));}if(!t)return KC.warn("[".concat(e.getTrackId(),"] no rtpSender found}"));if(this.isVP8Simulcast(e))return KC.warn("[updateRtpSenderEncodings] Track is VP8 simulcast, please apply simulcast encodings");if(!_A().supportSetRtpSenderParameters)return KC.warn("[updateRtpSenderEncodings] Browser not support set rtp-sender parameters");const n={},r={};switch(e._optimizationMode){case"motion":n.degradationPreference="maintain-framerate";break;case"detail":n.degradationPreference="maintain-resolution";break;default:n.degradationPreference="balanced";}if(e._encoderConfig){var s;const{bitrateMax:t,frameRate:i,scaleResolutionDownBy:n}=e._encoderConfig;t&&(r.maxBitrate=1e3*t),Pr(s=e._hints).call(s,ky.LOW_STREAM)&&(i&&(r.maxFramerate=mD(i)),n&&n>=1&&(r.scaleResolutionDownBy=n));}if(kC("DSCP_TYPE")&&kg()){var o;const e=kC("DSCP_TYPE");Pr(o=["very-low","low","medium","high"]).call(o,e)&&(r.networkPriority=e);}const a=t.getParameters(),c=null===(i=a.encodings)||void 0===i?void 0:i[0];Rg()&&!c&&(n.encodings=[r]),c&&Object.assign(c,r),Object.assign(a,n),KC.debug("[".concat(e.getTrackId(),"] updateRtpSenderEncodings: ").concat(JSON.stringify(a.encodings))),await t.setParameters(a);}async applySendEncodings(e,t){try{if(!_A().supportSetRtpSenderParameters)return;if(e.length!==t.length)return;for(let i=0;i<e.length;i++){const n=e[i],r=t[i];r instanceof Sb&&!this.isVP8Simulcast(r)&&await this.updateRtpSenderEncodings(r,n.sender);}}catch(e){KC.debug("[".concat(this.store.clientId,"] Apply RTPSendEncodings failed."));}}mungSendOfferSDP(e,t,i){const n=KP.parse(e);return t.forEach(((e,t)=>{const r=i[t],s=n.mediaDescriptions.find((e=>e.attributes.mid===r));s&&($P(s,e),rL(s,e,this.store.codec));})),KP.print(n)}bindStatsEvents(){this.statsFilter.onFirstAudioReceived=e=>{var t;null===(t=this.onFirstAudioReceived)||void 0===t||t.call(this,e);},this.statsFilter.onFirstVideoReceived=e=>{var t;null===(t=this.onFirstVideoReceived)||void 0===t||t.call(this,e);},this.statsFilter.onFirstAudioDecoded=e=>{var t;null===(t=this.onFirstAudioDecoded)||void 0===t||t.call(this,e);},this.statsFilter.onFirstVideoDecoded=(e,t,i)=>{var n;null===(n=this.onFirstVideoDecoded)||void 0===n||n.call(this,e,t,i);},this.statsFilter.onSelectedLocalCandidateChanged=(e,t)=>{var i;null===(i=this.onSelectedLocalCandidateChanged)||void 0===i||i.call(this,e,t);},this.statsFilter.onSelectedRemoteCandidateChanged=(e,t)=>{var i;null===(i=this.onSelectedRemoteCandidateChanged)||void 0===i||i.call(this,e,t);},this.statsFilter.onFirstVideoDecodedTimeout=e=>{var t;null===(t=this.onFirstVideoDecodedTimeout)||void 0===t||t.call(this,e);};}unbindStatsEvents(){this.statsFilter.onFirstAudioReceived=void 0,this.statsFilter.onFirstVideoReceived=void 0,this.statsFilter.onFirstAudioDecoded=void 0,this.statsFilter.onFirstVideoDecoded=void 0,this.statsFilter.onSelectedLocalCandidateChanged=void 0,this.statsFilter.onSelectedRemoteCandidateChanged=void 0,this.statsFilter.onFirstVideoDecodedTimeout=void 0;}async applySimulcastForFirefox(e,t){if(e.length===t.length)for(let a=0;a<e.length;a++){var i,n,r,s,o;const c=e[a],d=t[a];if(d instanceof Sb&&!Pr(i=d._hints).call(i,ky.LOW_STREAM)&&null!==(n=d._encoderConfig)&&void 0!==n&&n.bitrateMax&&(null===(r=d._encoderConfig)||void 0===r?void 0:r.bitrateMax)>200&&null!==(s=d._scalabilityMode)&&void 0!==s&&s.numSpatialLayers&&(null===(o=d._scalabilityMode)||void 0===o?void 0:o.numSpatialLayers)>1&&"vp8"===this.store.codec){const e={},t={high:1e3*(d._encoderConfig.bitrateMax-50),medium:5e4};e.encodings=[{rid:"m",active:!0,maxBitrate:t.medium,scaleResolutionDownBy:4},{rid:"h",active:!0,maxBitrate:t.high}];const i=c.sender.getParameters();await c.sender.setParameters(Object.assign(i,e));}}}async applySimulcastEncodings(e,t){if(!Rg()&&e.length===t.length)for(let i=0;i<e.length;i++){const n=t[i];if(n instanceof Sb&&this.isVP8Simulcast(n)){const t=e[i],r={},s={high:1e3*(n._encoderConfig.bitrateMax-50),medium:5e4};r.encodings=[{active:!0,adaptivePtime:!1,networkPriority:"high",priority:"high",maxBitrate:s.high},{active:!0,adaptivePtime:!1,networkPriority:"low",priority:"low",maxBitrate:s.medium,scaleResolutionDownBy:4}];const o=t.sender.getParameters();await t.sender.setParameters(Object.assign(o,r));}}}isVP8Simulcast(e){var t,i,n,r,s;return !!(e instanceof Sb&&kC("SIMULCAST")&&"vp8"===this.store.codec&&!Pr(t=e._hints).call(t,ky.LOW_STREAM)&&null!==(i=e._encoderConfig)&&void 0!==i&&i.bitrateMax&&(null===(n=e._encoderConfig)||void 0===n?void 0:n.bitrateMax)>200&&null!==(r=e._scalabilityMode)&&void 0!==r&&r.numSpatialLayers&&(null===(s=e._scalabilityMode)||void 0===s?void 0:s.numSpatialLayers)>1)}logSDPExchange(e,t,i,n){if(kC("SDP_LOGGING"))return KC.upload("[".concat(this.store.clientId,"] exchanging ").concat(i," ").concat(t," SDP during P2PConnection.").concat(n,"\n"),e),"offer"===t?e=>{this.logSDPExchange(e,"answer","local"===i?"remote":"local",n);}:void 0}getLocalSSRC(e,t){var i,n;if(t=null!==(i=t)&&void 0!==i?i:null===(n=this.currentLocalDescription)||void 0===n?void 0:n.sdp){var r;const i=null===(r=KP.parse(t).mediaDescriptions.find((t=>t.attributes.mid===e)))||void 0===r?void 0:r.attributes.ssrcs;return null==i?void 0:i[0].ssrcId}}getRemoteMid(e,t){var i,n;if(t=null!==(i=t)&&void 0!==i?i:null===(n=this.currentRemoteDescription)||void 0===n?void 0:n.sdp){var r;return null===(r=KP.parse(t).mediaDescriptions.find((t=>t.attributes.ssrcs.some((t=>t.ssrcId===e)))))||void 0===r?void 0:r.attributes.mid}}async getRemoteSSRC(e,t){var i,n;if(t=null!==(i=t)&&void 0!==i?i:null===(n=this.currentRemoteDescription)||void 0===n?void 0:n.sdp){var r;const i=null===(r=KP.parse(t).mediaDescriptions.find((t=>t.attributes.mid===e)))||void 0===r?void 0:r.attributes.ssrcs;return null==i?void 0:i[0].ssrcId}}}function wM(e,t,i){const n=e[t];if("function"!=typeof n)throw new Error("Cannot use mutex on object property.");return i.value=async function(){const e=this.mutex,i=await e.lock("From P2PConnection.".concat(t));try{for(var r=arguments.length,s=new Array(r),o=0;o<r;o++)s[o]=arguments[o];return await n.apply(this,s)}finally{i();}},i}var OM;function NM(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n);}return i}function DM(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?NM(Object(i),!0).forEach((function(t){nu(e,t,i[t]);})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):NM(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t));}));}return e}Mv([wM,Uv("design:type",Function),Uv("design:paramtypes",[String]),Uv("design:returntype",tg)],bM.prototype,"establish",null),Mv([wM,Uv("design:type",Function),Uv("design:paramtypes",[String]),Uv("design:returntype",tg)],bM.prototype,"connect",null),Mv([wM,Uv("design:type",Function),Uv("design:paramtypes",[RTCIceCandidate]),Uv("design:returntype",tg)],bM.prototype,"addRemoteCandidate",null),Mv([wM,Uv("design:type",Function),Uv("design:paramtypes",[Array]),Uv("design:returntype",tg)],bM.prototype,"send",null),Mv([wM,Uv("design:type",Function),Uv("design:paramtypes",[String,String,Number]),Uv("design:returntype",tg)],bM.prototype,"receive",null),Mv([wM,Uv("design:type",Function),Uv("design:paramtypes",[String,String]),Uv("design:returntype",tg)],bM.prototype,"setDescription",null),Mv([wM,Uv("design:type",Function),Uv("design:paramtypes",[Array,String]),Uv("design:returntype",tg)],bM.prototype,"stopReceiving",null),Mv([wM,Uv("design:type",Function),Uv("design:paramtypes",[]),Uv("design:returntype",tg)],bM.prototype,"restartICE",null),Mv([wM,Uv("design:type",Function),Uv("design:paramtypes",[]),Uv("design:returntype",void 0)],bM.prototype,"close",null),Mv([wM,Uv("design:type",Function),Uv("design:paramtypes",[String,iA]),Uv("design:returntype",tg)],bM.prototype,"updateEncoderConfig",null),Mv([wM,Uv("design:type",Function),Uv("design:paramtypes",[String,iA]),Uv("design:returntype",tg)],bM.prototype,"updateSendParameters",null),Mv([wM,Uv("design:type",Function),Uv("design:paramtypes",[iA,String]),Uv("design:returntype",tg)],bM.prototype,"replaceTrack",null),function(e){e.SEND_ONLY="SEND_ONLY",e.RECEIVE_ONLY="RECEIVE_ONLY";}(OM||(OM={}));class PM extends iT{get state(){return this._state}set state(e){const t=this._state;this._state=e,this.emit(mI.StateChange,t,this._state);}constructor(e,t){super(),nu(this,"store",void 0),nu(this,"statsUploader",void 0),nu(this,"sendConnection",void 0),nu(this,"recvConnection",void 0),nu(this,"localTrackMap",new Map),nu(this,"remoteUserMap",new Map),nu(this,"localDataChannels",[]),nu(this,"pendingLocalTracks",[]),nu(this,"pendingRemoteTracks",[]),nu(this,"statsCollector",void 0),nu(this,"dtlsFailedCount",0),nu(this,"sendMutex",new YT("P2PChannel2-send-mutex")),nu(this,"recvMutex",new YT("P2PChannel2-recv-mutex")),nu(this,"_state",EI.Disconnected),nu(this,"_restartStates",["disconnected","failed"]),nu(this,"_restartTimer",void 0),nu(this,"handleMuteLocalTrack",(async(e,t,i)=>{const n=await this.sendMutex.lock("Locking from P2PChannel2.handleMuteLocalTrack");try{if(!this.sendConnection||this.state!==EI.Connected)return void i(new Vg(xg.INVALID_OPERATION,"Cannot call P2PChannel2.handleMuteLocalTrack before sendConnection established."));const o=this.filterTobeMutedTracks(e);if(0===o.length)return void t();const a=o.find((e=>"videoLowTrack"===e[0]));if(a){a[1].track._originMediaStreamTrack.stop();}let c=!1;var r,s;if("video"===e.trackMediaType)c=!(null===(r=this.localTrackMap.get(_I.LocalAudioTrack))||void 0===r||!r.track._muted);else c=void 0===(null===(s=this.localTrackMap.get(_I.LocalVideoTrack))||void 0===s?void 0:s.id);const d=o.filter((e=>{let[t,i]=e;return (t!==_I.LocalAudioTrack||c)&&void 0!==i.id})).map((e=>{let[,t]=e;return t}));let l;d.length>0&&(l=await this.sendConnection.stopSending(d.map((e=>e.id))),d.forEach((e=>{e.id=void 0,e.ssrcs=void 0;})));const h=this.createMuteMessage(o),u="video"===e.trackMediaType?OI.MUTE_LOCAL_VIDEO:OI.MUTE_LOCAL_AUDIO,p=await fT(this,mI.RequestP2PMuteLocal,{action:u,sdp:l,message:h,isMuteAll:c});p&&await this.sendConnection.setDescription("local",p),(l||"audio"===e.trackMediaType)&&await gT(this,mI.RequestMuteLocal,h),t();}catch(e){i(e);}finally{n();}})),nu(this,"handleUnmuteLocalTrack",(async(e,t,i)=>{const n=await this.sendMutex.lock("Locking from P2PChannel2.handleUnmuteLocalTrack");try{if(!this.sendConnection||this.state!==EI.Connected)return void i(new Vg(xg.INVALID_OPERATION,"Cannot call P2PChannel2.handleUnmuteLocalTrack before sendConnection established."));const r=this.filterTobeUnmutedTracks(e);if(0===r.length)return void t();const s=this.createUnmuteMessage(r),o="video"===e.trackMediaType?OI.UNMUTE_LOCAL_VIDEO:OI.UNMUTE_LOCAL_AUDIO;await gT(this,mI.RequestP2PMuteLocal,{action:o,message:s}),t();}catch(e){i(e);}finally{n();}})),nu(this,"handleUpdateVideoEncoder",(async(e,t,i)=>{const n=await this.sendMutex.lock("Locking from P2PChannel2.handleSetVideoEncoder");try{const i=this.localTrackMap.get(_I.LocalVideoTrack);if(!this.sendConnection||!i||i.track!==e||this.state!==EI.Connected)return void t();const{id:r,track:s}=i;r&&(await this.sendConnection.updateSendParameters(r,s),await this.sendConnection.updateEncoderConfig(r,s),this.emit(mI.UpdateVideoEncoder,s)),t();}catch(e){i(e);}finally{n();}})),nu(this,"handleSetOptimizationMode",(async(e,t,i)=>{const n=await this.sendMutex.lock("Locking from P2PChannel2.handleSetOptimizationMode");try{const i=this.localTrackMap.get(_I.LocalVideoTrack);if(!this.sendConnection||!i||i.track!==e||this.state!==EI.Connected)return;const{id:r,track:s}=i;r&&await this.sendConnection.updateSendParameters(r,s),t();}catch(e){i(e);}finally{n();}})),nu(this,"handleReplaceTrack",(async(e,t,i,n)=>{let r;KC.debug("[".concat(this.store.clientId,"] P2PChannel2 handleReplaceTrack for [track-id-").concat(e.getTrackId(),"]")),"boolean"==typeof n&&n||(r=await this.sendMutex.lock("From P2PChannel2.handleReplaceTrack"));try{var s;const i=Array.from(this.localTrackMap.entries()).find((t=>{let[,{track:i}]=t;return e===i}));if(!this.sendConnection||!i||void 0===i[1].id||this.state!==EI.Connected)return void t();if(await(null===(s=this.sendConnection)||void 0===s?void 0:s.replaceTrack(e,i[1].id)),i[0]===_I.LocalVideoTrack&&_A().supportDualStreamEncoding){const t=this.localTrackMap.get(_I.LocalVideoLowTrack);if(t){const i=e._mediaStreamTrack.clone();t.track._originMediaStreamTrack.stop(),t.track._mediaStreamTrack=i,t.track._originMediaStreamTrack=i,await new tg(((e,i)=>{this.handleReplaceTrack(t.track,e,i,!0);}));}}t();}catch(e){i(e);}finally{var o;null===(o=r)||void 0===o||o();}})),nu(this,"handleGetLocalVideoStats",(e=>{e(this.statsCollector.getLocalVideoTrackStats());})),nu(this,"handleGetLocalAudioStats",(e=>{e(this.statsCollector.getLocalAudioTrackStats());})),nu(this,"handleGetRemoteVideoStats",(e=>this.statsCollector.getRemoteVideoTrackStats(e.uid)[e.uid])),nu(this,"handleGetRemoteAudioStats",(e=>this.statsCollector.getRemoteAudioTrackStats(e.uid)[e.uid])),this.store=e,this.statsCollector=t,this.statsCollector.addP2PChannel(this),this.statsUploader=new dk,this.bindStatsUploaderEvents();}async startP2PConnection(e,t){throw new Vg(xg.NOT_SUPPORTED,"p2p mode does not support startP2PConnection.")}async connect(e,t,i,n,r,s){throw new Vg(xg.NOT_SUPPORTED,"p2p mode does not support connect.")}async startP2P(e,t){if(this.state=EI.New,this.sendConnection&&(KC.warning("[".concat(this.store.clientId,"] P2PChannel.startP2P reset P2PConnection.")),this.sendConnection.close(),this.unbindConnectionEvents(this.sendConnection)),this.recvConnection&&(KC.warning("[".concat(this.store.clientId,"] P2PChannel.startP2P reset P2PConnection.")),this.recvConnection.close(),this.unbindConnectionEvents(this.recvConnection)),this.sendConnection=new bM(e,this.store),this.bindConnectionEvents(this.sendConnection),this.recvConnection=new bM(e,this.store,vv.RECEIVE_ONLY),this.bindConnectionEvents(this.recvConnection),t){this.store.peerConnectionStart(),await this.recvConnection.establish(t);const e=await this.sendConnection.establish(t);return this.statsUploader.startUploadTransportStats(!0),this.statsUploader.startUploadExtensionUsageStats(),this.state=EI.Connected,e}return await this.recvConnection.establish(t),this.sendConnection.establish(t)}async p2pConnect(e){if(!this.sendConnection||!this.recvConnection)throw new Vg(xg.UNEXPECTED_ERROR,"Cannot P2PChannel2.connect before P2PChannel2.startP2PConnection .");this.store.peerConnectionStart(),await this.recvConnection.connect(e),await this.sendConnection.connect(e),this.statsUploader.startUploadTransportStats(),this.statsUploader.startUploadExtensionUsageStats(),this.state=EI.Connected;}async addRemoteCandidate(e){if(!this.sendConnection||!this.recvConnection)throw new Vg(xg.UNEXPECTED_ERROR,"Cannot P2PChannel2.connect before P2PChannel2.addRemoteCandidate .");await this.recvConnection.addRemoteCandidate(e),await this.sendConnection.addRemoteCandidate(e);}async publish(e,t,i){if(!this.sendConnection||this.state!==EI.Connected){this.throwIfTrackTypeNotMatch(e);const t=e.filter((e=>-1===this.pendingLocalTracks.indexOf(e)));return void(this.pendingLocalTracks=this.pendingLocalTracks.concat(t))}this.store.pubId=this.store.pubId+1,cD.markPublishStart(this.store.clientId,this.store.pubId);const n=this.filterTobePublishedTracks(e,t,i);if(0===n.length)return void await this.tryToUnmuteAudio(e);n.forEach((e=>{let{track:t,type:i}=e;const n=Date.now();this.store.publish(t.getTrackId(),i===_I.LocalAudioTrack?"audio":"video",n);})),this.bindLocalTrackEvents(n);const r=this.createGatewayPublishMessage(n);return this.assignLocalTracks(n),n.forEach((e=>{let{track:t,type:i}=e;const n=Date.now();this.store.publish(t.getTrackId(),i===_I.LocalAudioTrack?"audio":"video",void 0,n);})),r}async dopublish(e){if(!this.sendConnection||this.state!==EI.Connected)return;const t=this.localTrackMap.get(e);if(t){const{sdp:i,trackMessage:n}=await this.sendConnection.send([t.track]),{mid:r,localSSRC:s}=n[0];t.id=r,t.ssrcs=s,this.statsCollector.addLocalStats(e),this.statsUploader.startUploadUplinkStats();const o=await fT(this,mI.RequestP2PPublish,{kind:e===_I.LocalAudioTrack?hI.AUDIO:hI.VIDEO,sdp:i,ssrcId:s[0].ssrcId});await this.sendConnection.setDescription("local",o);const a=this.createUnmuteMessage([[e,t]]);await gT(this,mI.RequestUnmuteLocal,a);}}async setDescription(e,t){let i,n;"local"===e?(i=await this.sendMutex.lock("From P2PChannel.restartICE"),n=this.sendConnection):(i=await this.recvMutex.lock("From P2PChannel.restartICE"),n=this.recvConnection);try{if(!n||this.state!==EI.Connected)return;return await n.setDescription(e,t)}finally{i();}}publishLowStream(e){return BP((function*(){throw new Vg(xg.NOT_SUPPORTED,"p2p mode does not support publishLowStream.")}))()}async republish(){this.pendingLocalTracks.length>0&&(KC.debug("[".concat(this.store.clientId,"] Emit P2PChannelEvents.RequestRePublish to republish tracks.")),await fT(this,mI.RequestRePublish,this.pendingLocalTracks),this.emit(mI.MediaReconnectEnd,this.store.uid),this.pendingLocalTracks=[]);}async unpublish(e){if(!this.sendConnection||this.state!==EI.Connected)return void(0===e.length?this.pendingLocalTracks.length=0:this.pendingLocalTracks=this.pendingLocalTracks.filter((t=>!Pr(e).call(e,t))));const t=this.filterTobeUnpublishedTracks(e);if(0===t.length)return;this.unbindLocalTrackEvents(t.map((e=>{let[t,{track:i}]=e;return {type:t,track:i}})));const i=t.filter((e=>{let[,{id:t}]=e;return void 0!==t}));if(!this.sendConnection||this.state!==EI.Connected)return void e.forEach((e=>{const t=this.pendingLocalTracks.indexOf(e);-1!==t&&this.pendingLocalTracks.splice(t,1);}));const n=t.find((e=>"videoLowTrack"===e[0]));if(n){n[1].track.close();}let r;const s=this.createGatewayUnpublishMessage(t);i.length>0&&(r=await this.sendConnection.stopSending(i.map((e=>{let[,{id:t}]=e;return t})))),this.withdrawLocalTracks(t),this.unbindLocalTrackEvents(t.map((e=>{let[t,{track:i}]=e;return {type:t,track:i}}))),t.forEach((e=>{let[t]=e;this.statsCollector.removeLocalStats(t);})),0===this.localTrackMap.size&&this.statsUploader.stopUploadUplinkStats();const o=this.createMuteMessage(t);return await tg.all(o.map((async e=>{await gT(this,mI.RequestMuteLocal,[e]);}))),{sdp:r,unpubMsg:s}}async unpublishLowStream(){throw new Vg(xg.NOT_SUPPORTED,"p2p mode does not support unpublishLowStream.")}async doUnpublish(e){if(!this.sendConnection||this.state!==EI.Connected)return;const t=[];if(e!==hI.AUDIO){const e=this.localTrackMap.get(_I.LocalVideoTrack);void 0!==(null==e?void 0:e.id)&&t.push([_I.LocalVideoTrack,e]);const i=this.localTrackMap.get(_I.LocalVideoLowTrack);void 0!==(null==i?void 0:i.id)&&t.push([_I.LocalVideoLowTrack,i]),this.statsCollector.removeLocalStats(_I.LocalVideoTrack),this.statsCollector.removeLocalStats(_I.LocalVideoLowTrack);}if(e!==hI.VIDEO){const e=this.localTrackMap.get(_I.LocalAudioTrack);void 0!==(null==e?void 0:e.id)&&t.push([_I.LocalAudioTrack,e]),this.statsCollector.removeLocalStats(_I.LocalAudioTrack);}if(t.length>0){const i=await this.sendConnection.stopSending(t.map((e=>{let[,t]=e;return t.id})));t.forEach((e=>{let[,t]=e;t.id=void 0,t.ssrcs=void 0;}));const n=await fT(this,mI.RequestP2PUnPublish,{sdp:i,kind:e});await this.sendConnection.setDescription("local",n);const r=this.createMuteMessage(t);await tg.all(r.map((async e=>{await gT(this,mI.RequestMuteLocal,[e]);})));}}async subscribe(e,t,i,n){var r;if(!this.recvConnection||this.state!==EI.Connected)throw new Vg(xg.INVALID_OPERATION,"Cannot subscribe remote user when recvConnection disconnected.");if(null!==(r=this.remoteUserMap.get(e))&&void 0!==r&&r.has(t))return;const{track:s,mid:o,sdp:a}=await this.recvConnection.receive(t,i,n);t===hI.AUDIO?(e._audioSSRC=n,e._audioTrack?e._audioTrack._updateOriginMediaStreamTrack(s):(e._audioTrack=new Ob(s,e.uid,e._uintid,this.store),KC.info("[".concat(this.store.clientId,"] [").concat(this.store.p2pId,"] create remote audio track: ").concat(e._audioTrack.getTrackId()))),this.bindRemoteTrackEvents(e,e._audioTrack)):(e._videoSSRC=n,e._videoTrack?e._videoTrack._updateOriginMediaStreamTrack(s):(e._videoTrack=new wb(s,e.uid,e._uintid,this.store),KC.info("[".concat(this.store.clientId,"] [").concat(this.store.p2pId,"] create remote video track: ").concat(e._videoTrack.getTrackId()))),this.bindRemoteTrackEvents(e,e._videoTrack));const c=this.remoteUserMap.get(e);c?c.set(t,o):this.remoteUserMap.set(e,new Map([[t,o]])),this.statsCollector.addRemoteStats(e.uid),this.statsUploader.startUploadDownlinkStats(),await gT(this,mI.RequestP2PUnmuteRemote,t);const d=this.pendingRemoteTracks.findIndex((i=>{let{user:n,kind:r}=i;return n.uid===e.uid&&t===r}));return -1!==d&&(this.pendingRemoteTracks.splice(d,1),this.emit(mI.MediaReconnectEnd,e.uid)),a}async unsubscribe(e,t,i,n){const r=this.pendingRemoteTracks.filter((t=>{let{user:n,kind:r}=t;return void 0!==i?n.uid===e.uid&&i===r:n.uid===e.uid}));if(r.forEach((e=>{const t=this.pendingRemoteTracks.indexOf(e);this.pendingRemoteTracks.splice(t,1);})),this.recvConnection&&this.state===EI.Connected||n||r.forEach((t=>{let{kind:i}=t;var n;if(i===hI.AUDIO)null===(n=e._audioTrack)||void 0===n||n._destroy(),e._audioTrack=void 0;else if(i===hI.VIDEO){var r;null===(r=e._videoTrack)||void 0===r||r._destroy(),e._videoTrack=void 0;}})),!this.recvConnection||this.state!==EI.Connected)return;const s=this.filterTobeUnSubscribedTracks(e,i);if(0===s.length)return void(i!==hI.VIDEO&&gT(this,mI.RequestP2PMuteRemote,hI.AUDIO));const o=await this.recvConnection.stopReceiving(s.map((e=>{let[,{id:t}]=e;return t})),t);return this.withdrawRemoteTracks(s),0===this.remoteUserMap.size&&this.statsUploader.stopUploadDownlinkStats(),s.forEach((e=>{let[t,{kind:i}]=e;var r,s;i===hI.VIDEO&&t._videoSSRC&&(null===(r=this.recvConnection)||void 0===r||r.setStatsRemoteVideoIsReady(t._videoSSRC,!1));if(i===hI.VIDEO)this.unbindRemoteTrackEvents(t._videoTrack),n||(null===(s=t._videoTrack)||void 0===s||s._destroy(),t._videoTrack=void 0);else if(i===hI.AUDIO){var o;if(this.unbindRemoteTrackEvents(t._audioTrack),!n)null===(o=t._audioTrack)||void 0===o||o._destroy(),t._audioTrack=void 0;}})),s.filter((e=>{let[,{kind:t}]=e;return t!==hI.AUDIO})).forEach((e=>{let[,{kind:t}]=e;gT(this,mI.RequestP2PMuteRemote,t);})),i!==hI.VIDEO&&gT(this,mI.RequestP2PMuteRemote,hI.AUDIO),o}getAllDataChannels(){return this.localDataChannels}async massSubscribe(e){throw new Vg(xg.NOT_SUPPORTED,"p2p mode does not support massSubscribe.")}async massSubscribeNoLock(e){throw new Vg(xg.NOT_SUPPORTED,"p2p mode does not support massSubscribeNoLock.")}async massUnsubscribe(e){throw new Vg(xg.NOT_SUPPORTED,"p2p mode does not support massUnsubscribe.")}async massUnsubscribeNoLock(e){throw new Vg(xg.NOT_SUPPORTED,"p2p mode does not support massUnsubscribeNoLock.")}async muteRemote(e,t){if(!this.recvConnection)return;const i=this.remoteUserMap.get(e);if(!i)return void KC.warning("[".concat(this.store.clientId,"] P2PChannel2.muteRemote has no remote user ").concat(e.uid,"."));if(!i.get(t))return void KC.warning("[".concat(this.store.clientId,"] P2PChannel2.muteRemote has no remote user ").concat(e.uid," media type ").concat(t,"."));const n=t===hI.VIDEO?e._videoSSRC:e._audioSSRC;void 0!==n&&this.recvConnection.setStatsRemoteVideoIsReady(n,!1);}async unmuteRemote(e,t){return this.unmuteRemoteNoLock(e,t)}async unmuteRemoteNoLock(e,t){if(!this.recvConnection)return;const i=this.remoteUserMap.get(e);if(!i)return void KC.warning("[".concat(this.store.clientId,"] P2PChannel2.unmuteRemote has no remote user ").concat(e.uid,"."));i.get(t)||KC.warning("[".concat(this.store.clientId,"] P2PChannel2.unmuteRemote has no remote user ").concat(e.uid," media type ").concat(t,"."));}getAllTracks(e){const t=this.localTrackMap.get(_I.LocalAudioTrack);if((null==t?void 0:t.track)instanceof tb){const i=t.track;return Array.from(this.localTrackMap.entries()).filter((e=>{let[t]=e;return t!==_I.LocalAudioTrack})).filter((t=>{let[i]=t;return !(e&&i===_I.LocalVideoLowTrack)})).map((e=>{let[,{track:t}]=e;return t})).concat(i.trackList)}return Array.from(this.localTrackMap.entries()).filter((t=>{let[i]=t;return !(e&&i===_I.LocalVideoLowTrack)})).map((e=>{let[,{track:t}]=e;return t}))}reportPublishEvent(e,t,i,n,r){if(e){const i=this.localTrackMap.get(_I.LocalAudioTrack),s=n?this.localTrackMap.get(_I.LocalVideoLowTrack):this.localTrackMap.get(_I.LocalVideoTrack);rv.publish(this.store.sessionId,{eventElapse:cD.measureFromPublishStart(this.store.clientId,this.store.pubId),succ:e,ec:t,audioName:null==i?void 0:i.track.getTrackLabel(),videoName:null==s?void 0:s.track.getTrackLabel(),screenshare:-1!==(null==s?void 0:s.track._hints.indexOf(ky.SCREEN_TRACK)),audio:!!i,video:!!s,p2pid:this.store.p2pId,publishRequestid:this.store.pubId,extend:r});}else {var s;i||(i=[]);const o=i.find((e=>e instanceof ZA)),a=n?null===(s=this.localTrackMap.get(_I.LocalVideoTrack))||void 0===s?void 0:s.track:i.find((e=>e instanceof Sb));rv.publish(this.store.sessionId,{eventElapse:cD.measureFromPublishStart(this.store.clientId,this.store.pubId),succ:e,ec:t,audioName:null==o?void 0:o.getTrackLabel(),videoName:null==a?void 0:a.getTrackLabel(),screenshare:-1!==(null==a?void 0:a._hints.indexOf(ky.SCREEN_TRACK)),audio:!!o,video:!!a,p2pid:this.store.p2pId,publishRequestid:this.store.pubId,extend:r});}}reportSubscribeEvent(e,t,i,n){const r=n===hI.VIDEO?i._videoSSRC:i._audioSSRC;r&&rv.subscribe(this.store.sessionId,{succ:e,ec:t,video:n===hI.VIDEO,audio:n===hI.AUDIO,peerid:i.uid,subscribeRequestid:n===hI.VIDEO?i._videoSSRC:i._audioSSRC,p2pid:this.store.p2pId,eventElapse:cD.measureFromSubscribeStart(this.store.clientId,r)});}reset(){KC.debug("[".concat(this.store.clientId,"] P2PChannel2.reset")),this.sendMutex=new YT("P2PChannel2-send-mutex"),this.sendMutex=new YT("P2PChannel2-recv-mutex"),this.sendConnection&&(this.sendConnection.close(),this.unbindConnectionEvents(this.sendConnection),this.sendConnection=void 0),this.recvConnection&&(this.recvConnection.close(),this.unbindConnectionEvents(this.recvConnection),this.recvConnection=void 0),this.statsUploader.stopUploadUplinkStats(),this.statsUploader.stopUploadDownlinkStats(),this.statsUploader.stopUploadTransportStats(),this.statsUploader.stopUploadExtensionUsageStats(),this.unbindLocalTrackEvents(),this.unbindAllRemoteTrackEvents(),this.unbindRtpTransceiver();const e=this.localTrackMap.get(_I.LocalAudioTrack);if((null==e?void 0:e.track)instanceof tb){if(e.track.trackList.length>0){const t=e.track;e.track.trackList.forEach((e=>{t.removeAudioTrack(e);}));}e.track.close();}this.localTrackMap.clear(),this.remoteUserMap.clear(),this.statsCollector.removeRemoteStats(),this.statsCollector.removeLocalStats(),this.dtlsFailedCount=0,this.pendingLocalTracks=[],this.pendingRemoteTracks=[],this.state=EI.Disconnected;}getStats(e){var t,i;return e?null===(i=this.recvConnection)||void 0===i?void 0:i.getStats():null===(t=this.sendConnection)||void 0===t?void 0:t.getStats()}getRemoteVideoIsReady(e){var t;return (null===(t=this.recvConnection)||void 0===t?void 0:t.getRemoteVideoIsReady(e))||!1}getLocalAudioVolume(){const e=this.localTrackMap.get(_I.LocalAudioTrack);if(e)return e.track.getVolumeLevel()}getLocalVideoSize(){const e=this.localTrackMap.get(_I.LocalVideoTrack);if(e)return {width:e.track._videoWidth||0,height:e.track._videoHeight||0}}getEncoderConfig(e){const t=this.localTrackMap.get(e);return t&&t.track instanceof Sb||t&&t.track instanceof ZA?t.track._encoderConfig:void 0}getLocalMedia(e){return this.localTrackMap.get(e)}hasLocalMedia(){return this.localTrackMap.size>0}hasRemoteMedia(e,t){if(!e)return this.remoteUserMap.size>0;const i=this.remoteUserMap.get(e);return !!i&&(!t||i.has(t))}async hasRemoteMediaWithLock(e,t){if(!e)return this.remoteUserMap.size>0;const i=this.remoteUserMap.get(e);return !!i&&(!t||i.has(t))}getRemoteMedia(e){var t;const i=Array.from(hu(t=this.remoteUserMap).call(t)).find((t=>t.uid===e));return i?{audioTrack:i.audioTrack,audioSSRC:i._audioSSRC,videoTrack:i.videoTrack,videoSSRC:i._videoSSRC}:{}}getAudioLevels(){let e=Array.from(this.remoteUserMap.entries()).map((e=>{let[t]=e;return {uid:t.uid,level:t.audioTrack?100*t.audioTrack._source.getAccurateVolumeLevel():0}}));const t=this.localTrackMap.get(_I.LocalAudioTrack);return t&&e.push({level:100*t.track._source.getAccurateVolumeLevel(),uid:this.store.uid}),e=Zu(e).call(e,((e,t)=>e.level-t.level)),e}async disconnectForReconnect(){this.sendConnection&&this.recvConnection&&(KC.debug("[".concat(this.store.clientId,"] P2PChannel2.disconnectForReconnect closing P2PConnection")),this.state=EI.Reconnecting,kC("KEEP_LAST_FRAME")&&0!==this.remoteUserMap.size&&Array.from(this.remoteUserMap.entries()).forEach((e=>{let[t]=e;var i;t._videoTrack&&t._videoTrack._player&&(null===(i=t._videoTrack._player.getVideoElement())||void 0===i||i.pause(),t._videoTrack._player.isKeepLastFrame=!0,t._videoTrack._originMediaStreamTrack.stop());})),this.sendConnection.close(),this.unbindConnectionEvents(this.sendConnection),this.sendConnection=void 0,this.recvConnection.close(),this.unbindConnectionEvents(this.recvConnection),this.recvConnection=void 0,0!==this.localTrackMap.size&&(Array.from(this.localTrackMap.entries()).forEach((e=>{var t;let[i,{track:n}]=e;switch(i){case _I.LocalVideoTrack:Pr(t=n._hints).call(t,ky.LOW_STREAM)?n.close():this.pendingLocalTracks.push(n);break;case _I.LocalAudioTrack:n instanceof tb?this.pendingLocalTracks=this.pendingLocalTracks.concat(n.trackList):this.pendingLocalTracks.push(n);case _I.LocalVideoLowTrack:}})),this.emit(mI.MediaReconnectStart,this.store.uid)),this.unbindLocalTrackEvents(),this.localTrackMap.clear(),0!==this.remoteUserMap.size&&Array.from(this.remoteUserMap.entries()).forEach((e=>{let[t,i]=e;Array.from(hu(i).call(i)).forEach((e=>{this.setPendingRemoteMedia(t,e);})),this.emit(mI.MediaReconnectStart,t.uid);})),this.unbindAllRemoteTrackEvents(),this.remoteUserMap.clear(),this.statsUploader.stopUploadUplinkStats(),this.statsUploader.stopUploadDownlinkStats(),this.statsUploader.stopUploadTransportStats(),KC.debug("[".concat(this.store.clientId,"] P2PChannel2 disconnected, waiting to reconnect.")));}hasPendingRemoteMedia(e,t){for(const i of this.pendingRemoteTracks){const{user:n,kind:r}=i;if((e instanceof NP?e.uid:e)===n.uid&&t===r)return !0}return !1}setPendingRemoteMedia(e,t){this.hasPendingRemoteMedia(e,t)||this.pendingRemoteTracks.push({user:e,kind:t});}async restartICE(e){let t;t=e.direction===vv.SEND_ONLY?await this.sendMutex.lock("From P2PChannel.restartICE"):await this.recvMutex.lock("From P2PChannel.restartICE");try{const i=await e.restartICE(),n=await fT(this,mI.RequestP2PRestartICE,i);e.setDescription("local",n);}finally{t();}}getUplinkNetworkQuality(){if(!this.sendConnection)return 0;const e=this.sendConnection.getStats(),t=this.localTrackMap.get(_I.LocalVideoTrack),i=this.localTrackMap.get(_I.LocalAudioTrack),n=e.videoSend.find((e=>{var i;return e.ssrc===(null==t||null===(i=t.ssrcs)||void 0===i?void 0:i[0].ssrcId)})),r=e.audioSend.find((e=>{var t;return e.ssrc===(null==i||null===(t=i.ssrcs)||void 0===t?void 0:t[0].ssrcId)}));if(!n||!r)return 1;const s=TT(this,mI.NeedSignalRTT),o=n?n.rttMs:void 0,a=r?r.rttMs:void 0,c=o&&a?(o+a)/2:o||a,d=(c&&s?(c+s)/2:c||s)||0,l=100*e.sendPacketLossRate*.7/50+.3*d/1500,h=l<.17?1:l<.36?2:l<.59?3:l<.1?4:5,u=null==t?void 0:t.track;if(u&&u._encoderConfig&&-1===u._hints.indexOf(ky.SCREEN_TRACK)){const t=u._encoderConfig.bitrateMax,i=e.bitrate.actualEncoded;if(t&&i){const e=(1e3*t-i)/(1e3*t);return av[e<.15?0:e<.3?1:e<.45?2:e<.6?3:4][h]}}return h}getDownlinkNetworkQuality(){if(!this.recvConnection)return 0;const e=this.recvConnection.getStats();let t=0;return Array.from(this.remoteUserMap.entries()).forEach((i=>{let[n]=i;const r=n._audioSSRC,s=n._videoSSRC,o=e.audioRecv.find((e=>e.ssrc===r)),a=e.videoRecv.find((e=>e.ssrc===s));if(!o&&!a)return void(t+=1);const c=TT(this,mI.NeedSignalRTT),d=e.rtt,l=(d&&c?(d+c)/2:d||c)||0,h=o?o.jitterMs:void 0,u=e.recvPacketLossRate;let p=.7*u*100/50+.3*l/1500;h&&(p=.6*u*100/50+.2*l/1500+.2*h/400);t+=p<.1?1:p<.17?2:p<.36?3:p<.59?4:5;})),this.remoteUserMap.size>0?Math.round(t/this.remoteUserMap.size):t}async muteLocalTrack(e){return new tg(((t,i)=>{this.handleMuteLocalTrack(e,t,i);}))}filterTobePublishedTracks(e,t,i){const n=[],r=_A(),s=this.getAllTracks();e=yT(e=e.filter((e=>-1===s.indexOf(e))));let o=!1,a=!1;for(const s of e){if(s instanceof Sb&&(this.localTrackMap.has(_I.LocalVideoTrack)||o?new Vg(xg.CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS).throw():(n.push({track:s,type:_I.LocalVideoTrack}),o=!0),t)){const e=this.getLowVideoTrack(s,i);n.push({track:e,type:_I.LocalVideoLowTrack});}if(s instanceof ZA){const e=this.localTrackMap.get(_I.LocalAudioTrack);if(e){if(!(e.track instanceof tb))throw new Vg(xg.NOT_SUPPORTED,"cannot publish multiple tracks which one of them configured with bypassWebAudio or your browser does not support audio mixing");if(s._bypassWebAudio)throw new Vg(xg.NOT_SUPPORTED,"cannot publish multiple tracks which one of them configured with bypassWebAudio");e.track.addAudioTrack(s),this.bindLocalAudioTrackEvents(s,!0);}else if(a){const e=n.find((e=>{let{type:t}=e;return t===_I.LocalAudioTrack}));if(!(e.track instanceof tb))throw new Vg(xg.NOT_SUPPORTED,"cannot publish multiple tracks which one of them configured with bypassWebAudio or your browser does not support audio mixing");if(s._bypassWebAudio)throw new Vg(xg.NOT_SUPPORTED,"cannot publish multiple tracks which one of them configured with bypassWebAudio");e.track.addAudioTrack(s);}else {if(!r.webAudioMediaStreamDest||s instanceof tb||s._bypassWebAudio)n.push({track:s,type:_I.LocalAudioTrack});else {const e=new tb;e.addAudioTrack(s),n.push({track:e,type:_I.LocalAudioTrack});}a=!0;}}}return n}filterTobeUnpublishedTracks(e){const t=[],i=this.getAllTracks();e=yT(e=e.filter((e=>-1!==i.indexOf(e))));for(const i of e){if(i instanceof ZA){const e=this.localTrackMap.get(_I.LocalAudioTrack);if(!e)continue;e.track instanceof tb?(e.track.removeAudioTrack(i),this.unbindLocalAudioTrackEvents(i),0===e.track.trackList.length&&(t.push([_I.LocalAudioTrack,e]),e.track.close())):t.push([_I.LocalAudioTrack,e]);}if(i instanceof Sb){const e=this.localTrackMap.get(_I.LocalVideoTrack);if(!e)continue;t.push([_I.LocalVideoTrack,e]);const i=this.localTrackMap.get(_I.LocalVideoLowTrack);i&&t.push([_I.LocalVideoLowTrack,i]);}}return t}bindLocalTrackEvents(e){e.forEach((e=>{let{track:t,type:i}=e;switch(i){case _I.LocalVideoTrack:t.addListener(Ly.GET_STATS,this.handleGetLocalVideoStats),t.addListener(Ly.NEED_DISABLE_TRACK,this.handleMuteLocalTrack),t.addListener(Ly.NEED_ENABLE_TRACK,this.handleUnmuteLocalTrack),t.addListener(Ly.NEED_UPDATE_VIDEO_ENCODER,this.handleUpdateVideoEncoder),t.addListener(Ly.SET_OPTIMIZATION_MODE,this.handleSetOptimizationMode),t.addListener(Ly.NEED_REPLACE_TRACK,this.handleReplaceTrack),t.addListener(Ly.NEED_MUTE_TRACK,this.handleMuteLocalTrack),t.addListener(Ly.NEED_UNMUTE_TRACK,this.handleUnmuteLocalTrack);break;case _I.LocalAudioTrack:this.bindLocalAudioTrackEvents(t);case _I.LocalVideoLowTrack:}}));}bindLocalAudioTrackEvents(e,t){e instanceof tb?e.trackList.forEach((e=>{e.addListener(Ly.NEED_DISABLE_TRACK,this.handleMuteLocalTrack),e.addListener(Ly.NEED_ENABLE_TRACK,this.handleUnmuteLocalTrack),e.addListener(Ly.GET_STATS,this.handleGetLocalAudioStats),e.addListener(Ly.NEED_MUTE_TRACK,this.handleMuteLocalTrack),e.addListener(Ly.NEED_UNMUTE_TRACK,this.handleUnmuteLocalTrack);})):(e.addListener(Ly.GET_STATS,this.handleGetLocalAudioStats),e.addListener(Ly.NEED_DISABLE_TRACK,this.handleMuteLocalTrack),e.addListener(Ly.NEED_ENABLE_TRACK,this.handleUnmuteLocalTrack),e.addListener(Ly.NEED_MUTE_TRACK,this.handleMuteLocalTrack),e.addListener(Ly.NEED_UNMUTE_TRACK,this.handleUnmuteLocalTrack),t||e.addListener(Ly.NEED_REPLACE_TRACK,this.handleReplaceTrack));}unbindLocalTrackEvents(e){e||(e=Array.from(this.localTrackMap.entries()).map((e=>{let[t,{track:i}]=e;return {track:i,type:t}}))),e.forEach((e=>{let{track:t,type:i}=e;switch(i){case _I.LocalVideoTrack:t.off(Ly.GET_STATS,this.handleGetLocalVideoStats),t.off(Ly.NEED_DISABLE_TRACK,this.handleMuteLocalTrack),t.off(Ly.NEED_ENABLE_TRACK,this.handleUnmuteLocalTrack),t.off(Ly.NEED_UPDATE_VIDEO_ENCODER,this.handleUpdateVideoEncoder),t.off(Ly.SET_OPTIMIZATION_MODE,this.handleSetOptimizationMode),t.off(Ly.NEED_REPLACE_TRACK,this.handleReplaceTrack),t.off(Ly.NEED_MUTE_TRACK,this.handleMuteLocalTrack),t.off(Ly.NEED_UNMUTE_TRACK,this.handleUnmuteLocalTrack);break;case _I.LocalAudioTrack:this.unbindLocalAudioTrackEvents(t);case _I.LocalVideoLowTrack:}}));}unbindLocalAudioTrackEvents(e){e instanceof tb?e.trackList.forEach((e=>{e.off(Ly.NEED_DISABLE_TRACK,this.handleMuteLocalTrack),e.off(Ly.NEED_ENABLE_TRACK,this.handleUnmuteLocalTrack),e.off(Ly.GET_STATS,this.handleGetLocalAudioStats),e.off(Ly.NEED_MUTE_TRACK,this.handleMuteLocalTrack),e.off(Ly.NEED_UNMUTE_TRACK,this.handleUnmuteLocalTrack);})):(e.off(Ly.GET_STATS,this.handleGetLocalAudioStats),e.off(Ly.NEED_DISABLE_TRACK,this.handleMuteLocalTrack),e.off(Ly.NEED_ENABLE_TRACK,this.handleUnmuteLocalTrack),e.off(Ly.NEED_REPLACE_TRACK,this.handleReplaceTrack),e.off(Ly.NEED_MUTE_TRACK,this.handleMuteLocalTrack),e.off(Ly.NEED_UNMUTE_TRACK,this.handleUnmuteLocalTrack));}bindRemoteTrackEvents(e,t){t instanceof wb&&t.addListener(Ly.GET_STATS,(t=>{t(this.handleGetRemoteVideoStats(e));})),t instanceof Ob&&t.addListener(Ly.GET_STATS,(t=>{t(this.handleGetRemoteAudioStats(e));}));}unbindRemoteTrackEvents(e){e&&e.removeAllListeners(Ly.GET_STATS);}unbindAllRemoteTrackEvents(){Array.from(this.remoteUserMap.entries()).forEach((e=>{let[t,i]=e;i.has(hI.AUDIO)&&this.unbindRemoteTrackEvents(t._audioTrack),i.has(hI.VIDEO)&&this.unbindRemoteTrackEvents(t._videoTrack);}));}createGatewayPublishMessage(e){return e.map((e=>{var t;let i,n,{track:r,type:s}=e;switch(s){case _I.LocalAudioTrack:i=$v.Audio,n={dtx:r instanceof $A&&r._config.DTX,hq:!1,lq:!1,stereo:!1,speech:!1};break;case _I.LocalVideoTrack:i=Pr(t=r._hints).call(t,ky.SCREEN_TRACK)?$v.Screen:$v.High,n=DM(DM({},fD(r)),{},{codec:this.store.codec});break;case _I.LocalVideoLowTrack:i=$v.Low,n=DM(DM({},fD(r)),{},{codec:this.store.codec});}return {kind:s===_I.LocalAudioTrack?hI.AUDIO:hI.VIDEO,stream_type:i,attributes:n,isMuted:r.muted||!r.enabled}}))}createGatewayUnpublishMessage(e){return e.map((e=>{var t;let i,[n,{track:r,ssrcs:s,id:o}]=e;switch(n){case _I.LocalVideoTrack:i=Pr(t=r._hints).call(t,ky.SCREEN_TRACK)?$v.Screen:$v.High;break;case _I.LocalAudioTrack:i=$v.Audio;break;case _I.LocalVideoLowTrack:i=$v.Low;}return {stream_type:i,ssrcs:s,mid:o}}))}assignLocalTracks(e){e.forEach((e=>{let{track:t,type:i}=e;this.localTrackMap.set(i,{track:t});}));}withdrawLocalTracks(e){e.forEach((e=>{let[t]=e;this.localTrackMap.delete(t);}));}bindConnectionEvents(e){e.onConnectionStateChange=async t=>{var i;if(KC.info("[".concat(this.store.clientId,"] [p2pId: ").concat(this.store.p2pId,"]: P2PConnection.onConnectionStateChange(").concat(t,")")),this.emit(mI.PeerConnectionStateChange,t),"connected"!==t||this.store.keyMetrics.peerConnectionEnd||this.store.peerConnectionEnd(),Pr(i=this._restartStates).call(i,t)||e.direction===vv.SEND_ONLY){if(this._restartTimer)return;const t=()=>{if("disconnected"===e.iceConnectionState||"checking"===e.iceConnectionState||"failed"===e.iceConnectionState){KC.debug("[".concat(this.store.clientId,"] [P2PChannel] start use restartICE"));"CONNECTED"===TT(this,mI.QueryClientConnectionState)&&this.restartICE(e);}};this._restartTimer=window.setTimeout((()=>{t(),this._restartTimer=void 0;}),800);}},e.onICEConnectionStateChange=e=>{"connected"!==e||this.store.keyMetrics.iceConnectionEnd||this.store.iceConnectionEnd(),KC.info("[".concat(this.store.clientId,"] [p2pId: ").concat(this.store.p2pId,"]: P2PConnection.onICEConnectionStateChange(").concat(e,")")),rv.reportApiInvoke(this.store.sessionId,{name:"ICEConnectionStateChange",options:e,tag:oT.TRACER}).onSuccess(),this.emit(mI.IceConnectionStateChange,e);},e.onICETransportStateChange=e=>{KC.info("[".concat(this.store.clientId,"] [p2pId: ").concat(this.store.p2pId,"]: P2PConnection.onICETransportStateChange(").concat(e,")"));},e.onDTLSTransportStateChange=e=>{KC.info("[".concat(this.store.clientId,"] [p2pId: ").concat(this.store.p2pId,"]: P2PConnection.onDTLSTransportStateChange(").concat(e,")"));},e.onDTLSTransportError=e=>{KC.info("[".concat(this.store.clientId,"] [p2pId: ").concat(this.store.p2pId,"]: P2PConnection.onDTLSTransportError(").concat(e,")"));},e.onFirstAudioDecoded=e=>{var t;const i=Array.from(hu(t=this.remoteUserMap).call(t)).find((t=>t._audioSSRC===e));var n;i&&(this.store.subscribe(i.uid,"audio",void 0,void 0,void 0,Date.now()),null===(n=i.audioTrack)||void 0===n||n.emit(By.FIRST_FRAME_DECODED),rv.firstRemoteFrame(this.store.sessionId,XC.FIRST_AUDIO_DECODE,QC.FIRST_AUDIO_DECODE,{peer:i._uintid,subscribeElapse:cD.measureFromSubscribeStart(this.store.clientId,e),subscribeRequestid:e,p2pid:this.store.p2pId}));},e.onFirstAudioReceived=e=>{var t;const i=Array.from(hu(t=this.remoteUserMap).call(t)).find((t=>t._audioSSRC===e));i&&rv.firstRemoteFrame(this.store.sessionId,XC.FIRST_AUDIO_RECEIVED,QC.FIRST_AUDIO_RECEIVED,{peer:i._uintid,subscribeElapse:cD.measureFromSubscribeStart(this.store.clientId,e),subscribeRequestid:e,p2pid:this.store.p2pId});},e.onFirstVideoDecoded=(e,t,i)=>{this.reportVideoFirstFrameDecoded(e,t,i);},e.onFirstVideoReceived=e=>{var t;const i=Array.from(hu(t=this.remoteUserMap).call(t)).find((t=>t._videoSSRC===e));i&&rv.firstRemoteFrame(this.store.sessionId,XC.FIRST_VIDEO_RECEIVED,QC.FIRST_VIDEO_RECEIVED,{peer:i._uintid,subscribeElapse:cD.measureFromSubscribeStart(this.store.clientId,e),subscribeRequestid:e,p2pid:this.store.p2pId});},e.onSelectedLocalCandidateChanged=(e,t)=>{const i="relay"===e.candidateType,n="relay"===t.candidateType;"unknown"!==t.candidateType&&i===n||this.emit(mI.ConnectionTypeChange,i),KC.info("[".concat(this.store.clientId,"] [p2pId: ").concat(this.store.p2pId,"]: P2PConnection.SelectedLocalCandidateChanged(").concat(JSON.stringify(vD(t))," -> ").concat(JSON.stringify(vD(e)),")"));},e.onSelectedRemoteCandidateChanged=(e,t)=>{KC.info("[".concat(this.store.clientId,"] [p2pId: ").concat(this.store.p2pId,"]: P2PConnection.SelectedRemoteCandidateChanged(").concat(JSON.stringify(vD(t))," -> ").concat(JSON.stringify(vD(e)),")"));},e.onFirstVideoDecodedTimeout=e=>{this.reportVideoFirstFrameDecoded(e,void 0,void 0,!0);},e.onLocalCandidate=e=>{this.emit(mI.LocalCandidate,e);};}unbindConnectionEvents(e){e.onConnectionStateChange=void 0,e.onICEConnectionStateChange=void 0,e.onICETransportStateChange=void 0,e.onDTLSTransportStateChange=void 0,e.onDTLSTransportError=void 0,e.onFirstAudioDecoded=void 0,e.onFirstAudioReceived=void 0,e.onFirstVideoDecoded=void 0,e.onFirstVideoReceived=void 0,e.onSelectedLocalCandidateChanged=void 0,e.onSelectedRemoteCandidateChanged=void 0,e.onFirstVideoDecodedTimeout=void 0,e.onLocalCandidate=void 0;}filterTobeMutedTracks(e){const t=[];if(-1===this.getAllTracks().indexOf(e))return t;const i=this.localTrackMap.get(_I.LocalAudioTrack);if(e instanceof ZA&&(null==i?void 0:i.track)instanceof tb)return i.track.isActive||t.push([_I.LocalAudioTrack,i]),t;const n=Array.from(this.localTrackMap.entries()).find((t=>{let[,{track:i}]=t;return e===i}));if(n&&(t.push(n),n[0]===_I.LocalVideoTrack)){const e=this.localTrackMap.get(_I.LocalVideoLowTrack);e&&t.push([_I.LocalVideoLowTrack,e]);}return t}filterTobeUnmutedTracks(e){const t=[],i=this.localTrackMap.get(_I.LocalAudioTrack);if(e instanceof ZA&&(null==i?void 0:i.track)instanceof tb)return i.track.isActive&&t.push([_I.LocalAudioTrack,i]),t;const n=Array.from(this.localTrackMap.entries()).find((t=>{let[,{track:i}]=t;return e===i}));if(n)if(n[0]===_I.LocalVideoTrack){t.push(n);const e=this.localTrackMap.get(_I.LocalVideoLowTrack);e&&t.push([_I.LocalVideoLowTrack,e]);}else t.push(n);return t}createMuteMessage(e){return e.map((e=>{var t;let i,[n,{track:r,ssrcs:s,id:o}]=e;switch(n){case _I.LocalAudioTrack:i=$v.Audio;break;case _I.LocalVideoTrack:i=Pr(t=r._hints).call(t,ky.SCREEN_TRACK)?$v.Screen:$v.High;break;case _I.LocalVideoLowTrack:i=$v.Low;}return {stream_type:i,ssrcs:s,mid:o}}))}createUnmuteMessage(e){return e.map((e=>{var t;let i,[n,{track:r,ssrcs:s,id:o}]=e;switch(n){case _I.LocalAudioTrack:i=$v.Audio;break;case _I.LocalVideoTrack:i=Pr(t=r._hints).call(t,ky.SCREEN_TRACK)?$v.Screen:$v.High;break;case _I.LocalVideoLowTrack:i=$v.Low;}return {stream_type:i,ssrcs:s,mid:o}}))}filterTobeUnSubscribedTracks(e,t){const i=[],n=this.remoteUserMap.get(e);if(!n)return i;if(t){const r=n.get(t);if(!r)return i;i.push([e,{kind:t,id:r}]);}else Array.from(n.entries()).forEach((t=>{let[n,r]=t;i.push([e,{kind:n,id:r}]);}));return i}createUnsubscribeMessage(e){const t=[];return e.forEach((e=>{let[i,{kind:n,id:r}]=e;switch(n){case hI.VIDEO:return void(i._videoSSRC&&t.push({stream_type:hI.VIDEO,ssrcId:i._videoSSRC}));case hI.AUDIO:return void(i._audioSSRC&&t.push({stream_type:hI.AUDIO,ssrcId:i._audioSSRC}))}})),t}withdrawRemoteTracks(e){e.forEach((e=>{let[t,{kind:i}]=e;const n=this.remoteUserMap.get(t);n&&(n.delete(i),0===Array.from(n.entries()).length&&this.remoteUserMap.delete(t));}));}async updateBitrateLimit(e){const t=this.localTrackMap.get(_I.LocalVideoTrack),i=this.localTrackMap.get(_I.LocalVideoLowTrack);t&&await t.track.setBitrateLimit(e.uplink),i&&e.low_stream_uplink&&await i.track.setBitrateLimit({max_bitrate:e.low_stream_uplink.bitrate,min_bitrate:e.low_stream_uplink.bitrate||0});}isP2PDisconnected(){if(this.sendConnection&&this.recvConnection){const e=this.sendConnection.peerConnectionState,t=this.recvConnection.peerConnectionState;return "connected"!==e&&"connected"!==t}return !0}async tryToUnmuteAudio(e){for(let t=0;t<e.length;t++)if(e[t]instanceof ZA){const i=this.filterTobeUnmutedTracks(e[t]);if(0===i.length)continue;const n=this.createUnmuteMessage(i);return void await gT(this,mI.RequestUnmuteLocal,n)}}bindStatsUploaderEvents(){this.statsUploader.requestStats=e=>this.getStats(e),this.statsUploader.requestLocalMedia=()=>Array.from(this.localTrackMap.entries()).filter((e=>{let[,{ssrcs:t}]=e;return !!t})),this.statsUploader.requestRemoteMedia=()=>Array.from(this.remoteUserMap.entries()),this.statsUploader.requestVideoIsReady=e=>{var t;return !(null===(t=this.recvConnection)||void 0===t||!t.getRemoteVideoIsReady(e))},this.statsUploader.requestUpload=(e,t)=>this.emit(mI.RequestUploadStats,e,t),this.statsUploader.requestAllTracks=()=>this.getAllTracks();}unbindStatsUploaderEvents(){this.statsUploader.requestStats=void 0,this.statsUploader.requestLocalMedia=void 0,this.statsUploader.requestRemoteMedia=void 0,this.statsUploader.requestVideoIsReady=void 0;}async requestReconnect(){this.dtlsFailedCount+=1,await UT(zT(this.dtlsFailedCount,JT)),this.emit(mI.RequestReconnect);}async reconnectP2P(){}canPublishLowStream(){return this.localTrackMap.has(_I.LocalVideoTrack)||this.pendingLocalTracks.some((e=>e instanceof Sb))}throwIfTrackTypeNotMatch(e){if(e.filter((e=>e instanceof Sb)).length>1)throw new Vg(xg.CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS);if(e.filter((e=>e instanceof ZA)).length>1&&(e.some((e=>e instanceof ZA&&e._bypassWebAudio))||!_A().webAudioMediaStreamDest))throw new Vg(xg.NOT_SUPPORTED,"cannot publish multiple tracks which one of them configured with bypassWebAudio or your browser doesn't support MediaStreamDestNode");for(const t of e){if(t instanceof Sb&&this.pendingLocalTracks.some((e=>e instanceof Sb)))throw new Vg(xg.CAN_NOT_PUBLISH_MULTIPLE_VIDEO_TRACKS);if(t instanceof ZA&&this.pendingLocalTracks.some((e=>e instanceof ZA))&&(!_A().webAudioMediaStreamDest||t._bypassWebAudio||this.pendingLocalTracks.some((e=>e instanceof ZA&&e._bypassWebAudio))))throw new Vg(xg.NOT_SUPPORTED,"cannot publish multiple tracks which one of them configured with bypassWebAudio or your browser doesn't support MediaStreamDestNode")}}getLowVideoTrack(e,t){const i=!kC("DISABLE_DUAL_STREAM_USE_ENCODING")&&_A().supportDualStreamEncoding,n=DM(DM({},{width:160,height:120,framerate:15,bitrate:50}),t);let r;r=i?e._mediaStreamTrack.clone():KL(e,n);const s=xT(8,"track-low-"),o=new Sb(r,DM(DM({},i&&{scaleResolutionDownBy:CD(n,e)}),{},{frameRate:n.framerate,bitrateMax:n.bitrate,bitrateMin:n.bitrate}),void 0,void 0,s);return o.on(Vy.TRANSCEIVER_UPDATED,(t=>{e._updateRtpTransceiver(t,My.LOW_STREAM);})),o._hints.push(ky.LOW_STREAM),e.addListener(Ly.NEED_CLOSE,(()=>{o.close();})),o}async globalLock(){return this.recvMutex.lock("From P2PChannel2.globalLock")}reportVideoFirstFrameDecoded(e,t,i,n){var r;const s=Array.from(hu(r=this.remoteUserMap).call(r)).find((t=>t._videoSSRC===e));if(s){n||this.store.subscribe(s.uid,"video",void 0,void 0,void 0,void 0,Date.now());const r=this.store.keyMetrics,o=r.subscribe.find((e=>e.userId===s.uid&&"video"===e.type));rv.firstRemoteVideoDecode(this.store.sessionId,XC.FIRST_VIDEO_DECODE,QC.FIRST_VIDEO_DECODE,{peer:s._uintid,videowidth:t,videoheight:i,subscribeElapse:cD.measureFromSubscribeStart(this.store.clientId,e),subscribeRequestid:e,p2pid:this.store.p2pId,apEnd:r.requestAPEnd||0,apStart:r.requestAPStart||0,joinGwEnd:r.joinGatewayEnd||0,joinGwStart:r.joinGatewayStart||0,pcEnd:r.peerConnectionEnd||0,pcStart:r.peerConnectionStart||0,subscriberEnd:(null==o?void 0:o.subscribeEnd)||0,subscriberStart:(null==o?void 0:o.subscribeStart)||0,videoAddNotify:(null==o?void 0:o.streamAdded)||0,state:n?1:0});}}async remoteMediaSsrcChanged(e,t,i){if(!this.recvConnection)return !1;const n=this.remoteUserMap.get(e);if(!n)return !1;const r=n.get(t);if(!r)return !1;const s=await this.recvConnection.getRemoteSSRC(r);return void 0!==s&&s!==i}resetConnection(e){KC.debug("[".concat(this.store.clientId,"] [P2PChannel2] reset connection to ").concat(e)),this.state===EI.Connected?(KC.debug("[".concat(this.store.clientId,"] [P2PChannel2] fallback to websocket but P2PChannel2 state still connected, disconnect first")),this.disconnectForReconnect()):(this.sendConnection&&(this.sendConnection.close(),this.unbindConnectionEvents(this.sendConnection),this.sendConnection=void 0),this.recvConnection&&(this.recvConnection.close(),this.unbindConnectionEvents(this.recvConnection),this.recvConnection=void 0));}async publishDataChannel(e){throw new Vg(xg.NOT_SUPPORTED)}async unpublishDataChannel(e){throw new Vg(xg.NOT_SUPPORTED)}async subscribeDataChannel(e,t){throw new Vg(xg.NOT_SUPPORTED)}async unsubscribeDataChannel(e,t){throw new Vg(xg.NOT_SUPPORTED)}hasPendingRemoteDataChannel(e,t){throw new Vg(xg.NOT_SUPPORTED)}setPendingRemoteDataChannel(e,t){throw new Vg(xg.NOT_SUPPORTED)}async preConnect(e,t,i,n,r,s){throw new Vg(xg.NOT_SUPPORTED)}getEstablishParams(){throw new Vg(xg.NOT_SUPPORTED)}async reSubscribe(e){throw new Vg(xg.NOT_SUPPORTED)}async updateVideoStreamParameter(e,t){throw new Vg(xg.NOT_SUPPORTED)}unbindRtpTransceiver(){0!==this.localTrackMap.size&&Array.from(this.localTrackMap.entries()).forEach((e=>{let[t,{track:i}]=e;t===_I.LocalVideoLowTrack?i._updateRtpTransceiver(void 0,My.LOW_STREAM):i._updateRtpTransceiver(void 0);}));}}function LM(e){return function(t,i,n){const r=t[i];if("function"!=typeof r)throw new Error("Cannot use mutex on object property.");return n.value=async function(){for(var t=arguments.length,n=new Array(t),s=0;s<t;s++)n[s]=arguments[s];switch(e){case OM.SEND_ONLY:{const e=await this.sendMutex.lock("From P2PChannel2.".concat(i));try{return await r.apply(this,n)}finally{e();}}case OM.RECEIVE_ONLY:{const e=await this.recvMutex.lock("From P2PChannel2.".concat(i));try{return await r.apply(this,n)}finally{e();}}default:{const e=await this.sendMutex.lock("From P2PChannel2.".concat(i)),t=await this.recvMutex.lock("From P2PChannel2.".concat(i));try{return await r.apply(this,n)}finally{e(),t();}}}},n}}function kM(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n);}return i}function MM(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?kM(Object(i),!0).forEach((function(t){nu(e,t,i[t]);})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):kM(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t));}));}return e}Mv([LM(),Uv("design:type",Function),Uv("design:paramtypes",[Object,String]),Uv("design:returntype",tg)],PM.prototype,"startP2P",null),Mv([LM(),Uv("design:type",Function),Uv("design:paramtypes",[String]),Uv("design:returntype",tg)],PM.prototype,"p2pConnect",null),Mv([LM(OM.SEND_ONLY),Uv("design:type",Function),Uv("design:paramtypes",[String]),Uv("design:returntype",tg)],PM.prototype,"dopublish",null),Mv([LM(OM.SEND_ONLY),Uv("design:type",Function),Uv("design:paramtypes",[Array]),Uv("design:returntype",tg)],PM.prototype,"unpublish",null),Mv([LM(),Uv("design:type",Function),Uv("design:paramtypes",[]),Uv("design:returntype",tg)],PM.prototype,"unpublishLowStream",null),Mv([LM(OM.SEND_ONLY),Uv("design:type",Function),Uv("design:paramtypes",[String]),Uv("design:returntype",tg)],PM.prototype,"doUnpublish",null),Mv([LM(OM.RECEIVE_ONLY),Uv("design:type",Function),Uv("design:paramtypes",[NP,String,String,Number]),Uv("design:returntype",tg)],PM.prototype,"subscribe",null),Mv([LM(OM.RECEIVE_ONLY),Uv("design:type",Function),Uv("design:paramtypes",[NP,String,String,Boolean]),Uv("design:returntype",tg)],PM.prototype,"unsubscribe",null),Mv([LM(OM.RECEIVE_ONLY),Uv("design:type",Function),Uv("design:paramtypes",[NP,String]),Uv("design:returntype",tg)],PM.prototype,"muteRemote",null),Mv([LM(OM.RECEIVE_ONLY),Uv("design:type",Function),Uv("design:paramtypes",[NP,String]),Uv("design:returntype",tg)],PM.prototype,"unmuteRemote",null),Mv([LM(OM.RECEIVE_ONLY),Uv("design:type",Function),Uv("design:paramtypes",[NP,String]),Uv("design:returntype",tg)],PM.prototype,"hasRemoteMediaWithLock",null),Mv([LM(),Uv("design:type",Function),Uv("design:paramtypes",[]),Uv("design:returntype",tg)],PM.prototype,"disconnectForReconnect",null),Mv([LM(OM.RECEIVE_ONLY),Uv("design:type",Function),Uv("design:paramtypes",[NP,String,Number]),Uv("design:returntype",tg)],PM.prototype,"remoteMediaSsrcChanged",null);const UM=Date.now(),xM=20,VM=new Map,FM=new Map;async function BM(e){const t=VM.get(e),i=Array.isArray(t)&&t[t.length-1],n=FM.get(e);if(!i)return void(n.isSyncing=!1);const r={uid:i.uid,payload:DT(i.payload)};0===n.firstRecvTs&&(n.firstRecvTs=i.recvTs,n.firstSendTs=i.sendTs);const s=i.sendTs-n.firstSendTs,o=s-(Date.now()-n.firstRecvTs);o>0&&(n.firstRecvTs=Date.now()-s);let a=i.mediaDelay+o;a<=0?(t.pop(),jM(i.context,r),a=0):a=Math.min(a,xM),setTimeout((()=>t.length&&BM(e)),a);}function jM(e,t){e.safeEmit(dT.STREAM_MESSAGE,t.uid,t.payload),e.onStreamMessage&&e.onStreamMessage(t);}function GM(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,i=arguments.length>2?arguments[2]:void 0;if(!e.syncWithAudio)return jM(i,{uid:e.uid,payload:DT(e.payload)});const n="".concat(i.id,"-").concat(e.uid),r=VM.get(n)||[],s=r.findIndex((t=>e.sendTs>=t.sendTs)),o=MM(MM({},e),{},{context:i,mediaDelay:t,recvTs:Date.now()});-1===s?r.push(o):r.splice(s,0,o),VM.set(n,r);let a=!1;var c;FM.has(n)?a=!(null===(c=FM.get(n))||void 0===c||!c.isSyncing):FM.set(n,{isSyncing:a,firstRecvTs:0,firstSendTs:0});a||BM(n);}const WM=pg().name;function HM(){return !function(e,t,i){const n=pg();if(n.os!==ag.IOS||!n.osVersion)return !1;const r=n.osVersion.split(".");return i?t&&Number(r[0])===e&&Number(r[1])<t||Number(r[0])<e:t?Number(r[0])===e&&Number(r[1])<=t||Number(r[0])<e:Number(r[0])<=e}(16,0,!0)&&!function(e,t,i){const n=pg();if(n.name!==cg.SAFARI||!n.osVersion)return !1;const r=n.version.split(".");return i?t&&Number(r[0])===e&&Number(r[1])<t||Number(r[0])<e:t?Number(r[0])===e&&Number(r[1])<=t||Number(r[0])<e:Number(r[0])<=e}(16,0,!0)}function KM(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n);}return i}function YM(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?KM(Object(i),!0).forEach((function(t){nu(e,t,i[t]);})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):KM(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t));}));}return e}YT.setLogger(KC);class qM extends iT{get connectionState(){return this._gateway.state}get remoteUsers(){return this._users}get localTracks(){return this._p2pChannel.getAllTracks(!0)}get uid(){return this._uid}get channelName(){return this._channelName}get localDataChannels(){return this._p2pChannel.getAllDataChannels()}get mode(){return this._config.mode}get role(){var e;return (null===(e=this._config)||void 0===e?void 0:e.role)||"audience"}get codec(){return this._config.codec}get audioCodec(){return this._config.audioCodec||"opus"}get isStringUID(){return !!this._joinInfo&&!!this._joinInfo.stringUid}get __className__(){return "Client"}constructor(e){let t;if(super(),nu(this,"store",void 0),nu(this,"_uid",void 0),nu(this,"_channelName",void 0),nu(this,"_uintUid",void 0),nu(this,"_users",[]),nu(this,"_config",void 0),nu(this,"_clientId",void 0),nu(this,"_appId",void 0),nu(this,"_sessionId",null),nu(this,"_key",void 0),nu(this,"_joinInfo",void 0),nu(this,"_gateway",void 0),nu(this,"_statsCollector",void 0),nu(this,"_configDistribute",void 0),nu(this,"_leaveMutex",new YT("client-leave")),nu(this,"_publishMutex",new YT("client-publish")),nu(this,"_renewTokenMutex",new YT("client-renewtoken")),nu(this,"_subscribeMutex",new YT("client-subscribe")),nu(this,"_encryptionMode","none"),nu(this,"_encryptionSecret",null),nu(this,"_encryptionSalt",null),nu(this,"_proxyServer",void 0),nu(this,"_turnServer",{servers:[],mode:"auto"}),nu(this,"_cloudProxyServerMode","disabled"),nu(this,"_isDualStreamEnabled",!1),nu(this,"_defaultStreamFallbackType",void 0),nu(this,"_lowStreamParameter",void 0),nu(this,"_streamFallbackTypeCacheMap",new Map),nu(this,"_remoteStreamTypeCacheMap",new Map),nu(this,"_axiosCancelSource",EC.CancelToken.source()),nu(this,"_audioVolumeIndicationInterval",void 0),nu(this,"_networkQualityInterval",void 0),nu(this,"_userOfflineTimeout",void 0),nu(this,"_streamRemovedTimeout",void 0),nu(this,"_injectStreamingClient",void 0),nu(this,"_liveTranscodeStreamingClient",void 0),nu(this,"_liveRawStreamingClient",void 0),nu(this,"_channelMediaRelayClient",void 0),nu(this,"_networkQualitySensitivity","normal"),nu(this,"_p2pChannel",void 0),nu(this,"_useLocalAccessPoint",!1),nu(this,"_setLocalAPVersion",void 0),nu(this,"_joinAndNotLeaveYet",!1),nu(this,"_numberOfJoinCount",0),nu(this,"_remoteDefaultVideoStreamType",void 0),nu(this,"_inspect",void 0),nu(this,"_moderation",void 0),nu(this,"_license",void 0),nu(this,"_pendingPublishedUsers",[]),nu(this,"ntpAlignErrorCount",0),nu(this,"remoteInboundOffset",0),nu(this,"_handleLocalTrackEnable",((e,t,i)=>{this.publish(e,!1).then(t).catch(i);})),nu(this,"_handleLocalTrackDisable",((e,t,i)=>{this.unpublish(e).then(t).catch(i);})),nu(this,"_handleUserOnline",(e=>{if(kC("BLOCK_LOCAL_CLIENT")&&dv(e.uid,this.channelName))return void KC.debug("[".concat(e.uid,"] will be ignored in local"));this.isStringUID&&"string"!=typeof e.uid&&KC.error("[".concat(this._clientId,"] StringUID is Mixed with UintUID"));const t=this._users.find((t=>t.uid===e.uid));if(t)t._trust_in_room_=!0;else {const t=new NP(e.uid,e.uint_id||e.uid);this._users.push(t),KC.debug("[".concat(this._clientId,"] user online"),e.uid),this.safeEmit(dT.USER_JOINED,t);}})),nu(this,"_handleUserOffline",(e=>{if(kC("BLOCK_LOCAL_CLIENT")&&dv(e.uid,this.channelName))return;const t=this._users.find((t=>t.uid===e.uid));t&&(this._handleRemoveStream(e),this._handleRemoveDataChannels(e),IT(this._users,t),this._remoteStreamTypeCacheMap.delete(t.uid),this._streamFallbackTypeCacheMap.delete(t.uid),KC.debug("[".concat(this._clientId,"] user offline"),e.uid,"reason:",e.reason),this.safeEmit(dT.USER_LEAVED,t,e.reason));})),nu(this,"_handleAddAudioOrVideoStream",((e,t,i,n,r,s,o)=>{if(kC("BLOCK_LOCAL_CLIENT")&&dv(t,this.channelName))return;const a=this._users.find((e=>e.uid===t));if(!a)return void KC.error("[".concat(this._clientId,"] can not find target user!(on_add_stream)"));KC.debug("[".concat(this._clientId,"] stream added with uid ").concat(t,", type ").concat(e)),this.store.subscribe(a.uid,e,void 0,void 0,void 0,Date.now());const c="audio"===e?a.hasAudio:a.hasVideo;a._uintid||(a._uintid=r||t),"audio"===e?a._trust_audio_stream_added_state_=!0:a._trust_video_stream_added_state_=!0,"audio"===e?(a._audio_added_=!0,void 0!==i&&(a._audioSSRC=i),void 0!==n&&(a._cname=n),s&&(a._audioOrtc=s)):(a._video_added_=!0,void 0!==i&&(a._videoSSRC=i),void 0!==n&&(a._cname=n),void 0!==o&&(a._rtxSsrcId=o),s&&(a._videoOrtc=s)),("audio"===e?a.hasAudio:a.hasVideo)&&!c&&(KC.info("[".concat(this._clientId,"] remote user ").concat(a.uid," published ").concat(e)),this.safeEmit(dT.USER_PUBLISHED,a,e)),"video"===e?rv.onGatewayStream(this._sessionId,XC.ON_ADD_VIDEO_STREAM,QC.ON_ADD_VIDEO_STREAM,{peer:r||t,ssrc:a._videoSSRC}):rv.onGatewayStream(this._sessionId,XC.ON_ADD_AUDIO_STREAM,QC.ON_ADD_AUDIO_STREAM,{peer:r||t,ssrc:a._audioSSRC}),this._p2pChannel.remoteMediaSsrcChanged(a,e,i).then((t=>{if(t&&(KC.debug("[".concat(this._clientId,"] resubscribe ").concat(e," for user ").concat(a.uid," after rejoin because SSRC id changed.")),this._p2pChannel instanceof _k))return this._p2pChannel.unsubscribe(a,e,!0).then((()=>this._subscribe(a,e,!0).catch((e=>{KC.error("[".concat(this._clientId,"] resubscribe error"),e.toString());}))))})),this._p2pChannel.hasPendingRemoteMedia(a,e)&&(KC.debug("[".concat(this._clientId,"] resubscribe ").concat(e," for user ").concat(a.uid," after reconnect.")),this._subscribe(a,e,!0).catch((e=>{KC.error("[".concat(this._clientId,"] resubscribe error"),e.toString());})));})),nu(this,"_handleRemoveStream",((e,t,i)=>{if(kC("BLOCK_LOCAL_CLIENT")&&dv(e.uid,this.channelName))return;const n=this._users.find((t=>t.uid===e.uid));if(!n)return void KC.warning("[".concat(this._clientId,"] can not find target user!(on_remove_stream)"));KC.debug("[".concat(this._clientId,"] stream removed with uid ").concat(e.uid));let r=()=>{};if(n.hasAudio&&n.hasVideo?r=()=>{KC.info("[".concat(this._clientId,"] remote user ").concat(n.uid," unpublished audio track")),this.safeEmit(dT.USER_UNPUBLISHED,n,"audio"),KC.info("[".concat(this._clientId,"] remote user ").concat(n.uid," unpublished video track")),this.safeEmit(dT.USER_UNPUBLISHED,n,"video");}:n.hasVideo?r=()=>{KC.info("[".concat(this._clientId,"] remote user ").concat(n.uid," unpublished video track")),this.safeEmit(dT.USER_UNPUBLISHED,n,"video");}:n.hasAudio&&(r=()=>{KC.info("[".concat(this._clientId,"] remote user ").concat(n.uid," unpublished audio track")),this.safeEmit(dT.USER_UNPUBLISHED,n,"audio");}),n._trust_audio_stream_added_state_=!0,n._trust_video_stream_added_state_=!0,n._audio_added_=!1,n._video_added_=!1,this._p2pChannel instanceof _k)this._p2pChannel.unsubscribe(n).then((e=>{if(e)return this._gateway.unsubscribe(e,n.uid)}));else if(t&&i)if(e.sdp){const{sdp:r}=e;this._p2pChannel.unsubscribe(n,r).then((e=>{e&&t(e);})).catch(i);}else t&&t();n._audioSSRC=void 0,n._videoSSRC=void 0,n._audioOrtc=void 0,n._videoOrtc=void 0,n._rtxSsrcId=void 0,rv.onGatewayStream(this._sessionId,XC.ON_REMOVE_STREAM,QC.ON_REMOVE_STREAM,{peer:e.uint_id||e.uid}),r();})),nu(this,"_handleSetStreamLocalEnable",((e,t,i)=>{if(kC("BLOCK_LOCAL_CLIENT")&&dv(t,this.channelName))return;const n=this._users.find((e=>e.uid===t));if(!n)return void KC.error("[".concat(this._clientId,"] can not find target user!(disable_local)"));KC.debug("[".concat(this._clientId,"] local ").concat(e," ").concat(i?"enabled":"disabled"," with uid ").concat(t));const r="audio"===e?n.hasAudio:n.hasVideo;if("audio"===e){n._trust_audio_enabled_state_=!0;const e=n._audio_enabled_;if(n._audio_enabled_=i,n._audio_enabled_===e)return;{const e=n._audio_enabled_?"enable-local-audio":"disable-local-audio";KC.debug("[".concat(this._clientId,"] user-info-updated, uid: ").concat(t,", msg: ").concat(e)),this.safeEmit(dT.USER_INFO_UPDATED,t,e);}}else {n._trust_video_enabled_state_=!0;const e=n._video_enabled_;if(n._video_enabled_=i,n._video_enabled_===e)return;{const e=n._video_enabled_?"enable-local-video":"disable-local-video";KC.debug("[".concat(this._clientId,"] user-info-update, uid: ").concat(t,", msg: ").concat(e)),this.safeEmit(dT.USER_INFO_UPDATED,t,e);}}const s="audio"===e?n.hasAudio:n.hasVideo;return r!==s?!r&&s?(KC.info("[".concat(this._clientId,"] remote user ").concat(t," published ").concat(e)),void this.safeEmit(dT.USER_PUBLISHED,n,e)):("video"===e&&n._videoTrack&&n._videoTrack._destroy(),"audio"===e&&n._audioTrack,this._p2pChannel.muteRemote(n,e),KC.info("[".concat(this._clientId,"] remote user ").concat(t," unpublished ").concat(e)),void this.safeEmit(dT.USER_UNPUBLISHED,n,e)):void 0})),nu(this,"_handleMuteStream",((e,t,i,n,r,s)=>{if(kC("BLOCK_LOCAL_CLIENT")&&dv(e,this.channelName))return;KC.debug("[".concat(this._clientId,"] receive mute message"),e,t,i);const o=this._users.find((t=>t.uid===e));if(!o)return void KC.warning("[".concat(this._clientId,"] can not find remote user, ignore mute event, uid: ").concat(e));const a="audio"===t?o.hasAudio:o.hasVideo;if("audio"===t){o._trust_audio_mute_state_=!0;const t=o._audio_muted_;if(o._audio_muted_=i,o._audio_muted_===t)return;{const t=o._audio_muted_?"mute-audio":"unmute-audio";KC.debug("[".concat(this._clientId,"] user-info-update, uid: ").concat(e,", msg: ").concat(t)),this.safeEmit(dT.USER_INFO_UPDATED,e,t);}}else {o._trust_video_mute_state_=!0;const t=o._video_muted_;if(o._video_muted_=i,o._video_muted_===t)return;{const t=o._video_muted_?"mute-video":"unmute-video";KC.debug("[".concat(this._clientId,"] user-info-update, uid: ").concat(e,", msg: ").concat(t)),this.safeEmit(dT.USER_INFO_UPDATED,e,t);}}const c="audio"===t?o.hasAudio:o.hasVideo;if(a!==c){if(!a&&c){if(!this.store.useP2P){if(!("audio"===t?o._audioSSRC:o._videoSSRC))return void KC.warning("[".concat(this._clientId,"] remote user ").concat(e," receive ").concat(t," unmute message  before add stream message, ").concat(t," SSRC doesn't exist yet."))}return KC.info("[".concat(this._clientId,"] remote user ").concat(e," published ").concat(t)),void this.safeEmit(dT.USER_PUBLISHED,o,t)}"video"===t&&o._videoTrack&&o._videoTrack._destroy(),"audio"===t&&o._audioTrack,r&&s&&this._p2pChannel instanceof PM&&(n?this._p2pChannel.unsubscribe(o,n,t).then((e=>{r(e);})).catch(s):r()),this._p2pChannel.muteRemote(o,t),KC.info("[".concat(this._clientId,"] remote user ").concat(e," unpublished ").concat(t)),this.safeEmit(dT.USER_UNPUBLISHED,o,t);}})),nu(this,"_handleP2PLost",(async e=>{KC.debug("[".concat(this._clientId,"] receive p2p lost"),e),parseInt(e.p2pid,10)===this.store.p2pId?await this._p2pChannel.requestReconnect():KC.warning("[".concat(this._clientId,"] P2PLost stream not found"),e);})),nu(this,"_handleTokenWillExpire",(()=>{KC.debug("[".concat(this._clientId,"] received message onTokenPrivilegeWillExpire")),this.safeEmit(dT.ON_TOKEN_PRIVILEGE_WILL_EXPIRE);})),nu(this,"_handleBeforeUnload",(e=>{"beforeunload"===e.type&&void 0!==e.returnValue&&""!==e.returnValue||(this.leave(),KC.info("[".concat(this._clientId,"] auto leave onbeforeunload or pagehide")));})),nu(this,"_handleUpdateNetworkQuality",(()=>{if("normal"===this._networkQualitySensitivity)return;if(navigator&&void 0!==navigator.onLine&&!navigator.onLine)return void this.safeEmit(dT.NETWORK_QUALITY,{downlinkNetworkQuality:6,uplinkNetworkQuality:6});const e={downlinkNetworkQuality:0,uplinkNetworkQuality:0};e.uplinkNetworkQuality=this._p2pChannel.getUplinkNetworkQuality(),e.downlinkNetworkQuality=this._p2pChannel.getDownlinkNetworkQuality(),this.safeEmit(dT.NETWORK_QUALITY,e);})),nu(this,"_handleP2PAddAudioOrVideoStream",((e,t)=>{const i=this._users.find((e=>e.uid===t));if(!i)return void KC.error("[".concat(this._clientId,"] can not find target user!(on_add_stream)"));KC.debug("[".concat(this._clientId,"] stream added with uid ").concat(t,", type ").concat(e)),this.store.subscribe(i.uid,e,void 0,void 0,void 0,Date.now());const n="audio"===e?i.hasAudio:i.hasVideo;"audio"===e?i._trust_audio_stream_added_state_=!0:i._trust_video_stream_added_state_=!0,"audio"===e?i._audio_added_=!0:i._video_added_=!0,("audio"===e?i.hasAudio:i.hasVideo)&&!n&&(KC.info("[".concat(this._clientId,"] remote user ").concat(i.uid," published ").concat(e)),this.safeEmit(dT.USER_PUBLISHED,i,e)),this._p2pChannel.hasPendingRemoteMedia(i,e)&&(KC.debug("[".concat(this._clientId,"] resubscribe ").concat(e," for user ").concat(i.uid," after reconnect.")),this._subscribe(i,e,!0).catch((e=>{KC.error("[".concat(this._clientId,"] resubscribe error"),e.toString());})));})),this._config=e,this._clientId=xT(5,"client-"),this.store=new wC(e.codec,e.audioCodec,e.mode,this._clientId),this.store.clientCreated(),e.proxyServer&&this.setProxyServer(e.proxyServer,!0),e.turnServer&&this.setTurnServer(e.turnServer,!0),KC.info("[".concat(this._clientId,"] Initializing AgoraRTC client v").concat(OC," build: ").concat(DC,", mode: ").concat(this.mode,", codec: ").concat(this.codec)),e.clientRoleOptions)try{mT(e.clientRoleOptions),t=Object.assign({},e.clientRoleOptions);}catch(e){KC.warning("[".concat(this._clientId,"] ").concat(e.toString()));}this._statsCollector=new hD(this.store),this._statsCollector.onStatsException=(e,t,i)=>{KC.debug("[".concat(this._clientId,"] receive exception msg, code: ").concat(e,", msg: ").concat(t,", uid: ").concat(i)),this.safeEmit(dT.EXCEPTION,{code:e,msg:t,uid:i});},this._statsCollector.onUploadPublishDuration=(e,t,i,n)=>{const r=this._users.find((t=>t.uid===e));r&&rv.peerPublishStatus(this._sessionId,{subscribeElapse:n,audioPublishDuration:t,videoPublishDuration:i,peer:r._uintid});},this.store.useDataChannel=_A().supportDataChannel&&kC("SIGNAL_CHANNEL"),this.store.useP2P=kC("P2P"),this._gateway=new MD(this.store,{clientId:this._clientId,mode:this.mode,codec:this.codec,websocketRetryConfig:e.websocketRetryConfig||JT,httpRetryConfig:e.httpRetryConfig||JT,forceWaitGatewayResponse:void 0===e.forceWaitGatewayResponse||e.forceWaitGatewayResponse,statsCollector:this._statsCollector,role:e.role,clientRoleOptions:t}),this._configDistribute=new TP,this.store.useP2P?(this._p2pChannel=new PM(this.store,this._statsCollector),this._handleP2PEvents()):this._p2pChannel=new _k(this.store,this._statsCollector),this._handleP2PChannelEvents(),this._handleGatewayEvents(),this._handleGatewaySignalEvents();}async joinMeta(e,t,i,n,r){let s=!(arguments.length>5&&void 0!==arguments[5])||arguments[5],o=arguments.length>6&&void 0!==arguments[6]&&arguments[6];LC("JOIN_GATEWAY_USE_443PORT_ONLY",s),LC("JOIN_GATEWAY_USE_DUAL_DOMAIN",o);const a=this._gateway.signal.websocket;return a instanceof zI&&(a.use443PortOnly=s,a.tryDoubleDomain=o),async function(e,t,i){rg.get(e)||rg.set(e,[]),sg.get(e)||sg.set(e,t),og.get(e)||og.set(e,0);const n=rg.get(e),r=sg.get(e);if(!n||!r)throw new Error("concurrent: deferQueue or maxConcurrency is null");if(og.get(e)===r){const e=ng();n.push(e),await e.promise;}og.set(e,og.get(e)+1);for(var s=arguments.length,o=new Array(s>3?s-3:0),a=3;a<s;a++)o[a-3]=arguments[a];const c=await i(...o);return og.set(e,og.get(e)-1),og.get(e)===r-1&&n.length>0&&(n[0].resolve(),n.shift()),0===og.get(e)&&(rg.set(e,[]),sg.set(e,0),og.set(e,0)),c}("client.join",kC("JOIN_MAX_CONCURRENCY"),this.join.bind(this),e,t,i,n,r)}async join(e,t,i,n,r){const s=++this._numberOfJoinCount;this.store.joinStart(),n&&(this.store.uid=n);const o=vC(),a=IC()?window.isSecureContext:"Browser Not Support";if(!IC()&&!o||!window.isSecureContext){const e="The website must be running in a secure context (About secure context: https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts ), otherwise the media collection will be restricted by the browser";KC.warning(e);}const c=VT();"DISCONNECTED"===this.connectionState&&(this.store.avoidJoinStart=Math.round(Date.now()),KC.debug("[".concat(this._clientId,"] set avoidJoinStart to ").concat(this.store.avoidJoinStart)));const d=rv.reportApiInvoke(c,{name:sT.JOIN,options:[e,t,i,n],states:{isHttps:o,isSecureContext:a},tag:oT.TRACER});rv.setAppId(e);try{if(!i&&null!==i)throw new xv(xg.INVALID_PARAMS,"Invalid token: ".concat(i,". If you don not use token, set it to null"));i&&Wg(i,"token",1,2047),Wg(e,"appid",1,2047),Vv(t),n&&Fv(n),r&&Wg(r,"optionalInfo",1,2047);}catch(e){throw d.onError(e),e}if(KC.info("[".concat(this._clientId,"] start join channel ").concat(t,", join number: ").concat(s)),this._leaveMutex.isLocked){KC.debug("[".concat(this._clientId,"] join: waiting leave operation"));(await this._leaveMutex.lock())(),KC.debug("[".concat(this._clientId,"] join: continue"));}if(this._joinAndNotLeaveYet=!0,"DISCONNECTED"!==this.connectionState){const e=new xv(xg.INVALID_OPERATION,"[".concat(this._clientId,"] Client already in connecting/connected state"));throw d.onError(e),e}this._sessionId||(this._sessionId=c,this.store.sessionId=this._sessionId),this._gateway.state="CONNECTING";const l=YM({clientId:this._clientId,appId:e,sid:this._sessionId,cname:t,uid:"string"!=typeof n?n:null,turnServer:this._turnServer,proxyServer:this._proxyServer,token:i||e,cloudProxyServer:this._cloudProxyServerMode,optionalInfo:r,license:this._license,useLocalAccessPoint:this._useLocalAccessPoint},void 0!==this._remoteDefaultVideoStreamType&&{defaultVideoStream:this._remoteDefaultVideoStreamType});if(this._useLocalAccessPoint&&(l.setLocalAPVersion=this._setLocalAPVersion),"string"==typeof n&&(l.stringUid=n,this._uintUid?(l.uid=this._uintUid,this._uintUid=void 0):l.uid=0),"none"!==this._encryptionMode&&this._encryptionSecret){if(l.aesmode=this._encryptionMode,l.aespassword=await eT(this._encryptionSecret),!this._joinAndNotLeaveYet)throw new xv(xg.INVALID_OPERATION,"[".concat(this._clientId,"] Client already left"));this._encryptionSalt&&(l.aessalt=this._encryptionSalt);}this._startSession(this._sessionId,{channel:t,appId:e});const h=this._sessionId;setTimeout((()=>{"CONNECTING"===this.connectionState&&h===this._sessionId&&rv.joinChannelTimeout(this._sessionId,5);}),5e3);try{var u;let n;const r=l.cloudProxyServer;if(Pr(u=["proxy3","proxy4","proxy5"]).call(u,r)){const e=kC("PROXY_SERVER_TYPE3");Array.isArray(e)?l.proxyServer=e[0]:l.proxyServer=e;}if(rv.setProxyServer(l.proxyServer),KC.setProxyServer(l.proxyServer),this.store.requestAPStart(),l.stringUid&&!l.uid){const e=await hP(l.stringUid,l,this._axiosCancelSource.token,this._config.httpRetryConfig||JT,this.store);KC.debug("[".concat(this._clientId,"] getUserAccount Success ").concat(l.stringUid," => ").concat(e)),l.uid=e,n=await lP(l,this._axiosCancelSource.token,this._config.httpRetryConfig||JT,!0,this.store);}else n=await lP(l,this._axiosCancelSource.token,this._config.httpRetryConfig||JT,!0,this.store);if(!this._joinAndNotLeaveYet)throw new xv(xg.INVALID_OPERATION,"[".concat(this._clientId,"] Client already left"));this.store.requestAPEnd(),setTimeout((()=>{this._configDistribute.startGetConfigDistribute(l,this._axiosCancelSource.token),this._configDistribute.on(dI.UPDATE_BITRATE_LIMIT,(e=>{this._p2pChannel.updateBitrateLimit(e);}));}),0),this._key=i||e;const s=n.gatewayInfo;this._joinInfo=YM(YM({},l),{},{cid:s.cid,uid:l.uid?l.uid:s.uid,vid:s.vid,apResponse:s.res,uni_lbs_ip:s.uni_lbs_ip,gatewayAddrs:s.gatewayAddrs});const o=await this._joinGateway();if(!this._joinAndNotLeaveYet)throw new xv(xg.INVALID_OPERATION,"[".concat(this._clientId,"] Client already left"));d.onSuccess(o),this._appId=e,this._channelName=l.cname,this._uid=o,this.store.uid=o,setTimeout((()=>{this._networkQualityInterval&&window.clearInterval(this._networkQualityInterval),this._networkQualityInterval=window.setInterval(this._handleUpdateNetworkQuality,2e3),window.addEventListener(Sg()?"beforeunload":"pagehide",this._handleBeforeUnload);}),0);const a=l.stringUid?"string uid: ".concat(l.stringUid,",uid: ").concat(l.uid):"uid: ".concat(this._uid);return KC.info("[".concat(this._clientId,"] Joining channel success: channel: ").concat(t,",").concat(a)),setTimeout((()=>{KC.startUpload();}),5e3),this.store.joinEnd(),p=this,Pr(cv).call(cv,p)||cv.push(p),o}catch(e){const t=Array.isArray(e)?e[0]:e;throw t&&t.code===xg.OPERATION_ABORTED?KC.warning("[".concat(this._clientId,"] join number: ").concat(s,", Joining channel failed, rollback"),t):KC.error("[".concat(this._clientId,"] join number: ").concat(s,", Joining channel failed, rollback"),t),t.code!==xg.OPERATION_ABORTED&&this._numberOfJoinCount===s&&(this._gateway.state="DISCONNECTED",this._reset()),d.onError(t),t}var p;}_joinGateway(){if(!this._joinInfo||!this._key)throw new xv(xg.INVALID_OPERATION);return this._gateway.join(this._joinInfo,this._key,!("disabled"!==this._joinInfo.cloudProxyServer||this._joinInfo.proxyServer||!kC("JOIN_WITH_FALLBACK_SIGNAL_PROXY"))).then((e=>e)).catch((e=>{if(e.code===xg.INIT_WEBSOCKET_TIMEOUT)return this._gateway.leave(!0,cT.FALLBACK),e;if(e.code===xg.INIT_DATACHANNEL_TIMEOUT)return this._gateway.leave(!0,cT.FALLBACK),e;throw e})).then((e=>{if(e instanceof xv){if(e.code===xg.INIT_WEBSOCKET_TIMEOUT){if(KC.info("[".concat(this._clientId,"] join timeout, fallback to proxy")),!this._joinInfo||!this._key)throw new xv(xg.INVALID_OPERATION);this._joinInfo.cloudProxyServer="fallback",this._cloudProxyServerMode="fallback",this.store.cloudProxyServerMode="fallback";const e=kC("PROXY_SERVER_TYPE3");if(Array.isArray(e))if(this._joinInfo.apUrl){const t=/^https?:\/\/(.+?)(\/.*)?$/.exec(this._joinInfo.apUrl)[1].split("."),i=t.slice(t.length-2).join(".");e.forEach((e=>{this._joinInfo&&Pr(e).call(e,i)&&(this._joinInfo.proxyServer=e);})),this._joinInfo.proxyServer||(this._joinInfo.proxyServer=e[0]);}else this._joinInfo.proxyServer=e[0];else this._joinInfo.proxyServer=e;const t=kC("LOG_UPLOAD_SERVER").match(/.+:(\d{1,5})$/);t&&t[1]&&"443"!==t[1]&&KC.setProxyServer(this._joinInfo.proxyServer),"443"!==kC("STATS_COLLECTOR_PORT").toString()&&rv.setProxyServer(this._joinInfo.proxyServer);return rv.reportApiInvoke(this._sessionId,{name:sT.JOIN_FALLBACK_TO_PROXY,options:[this._joinInfo.proxyServer],tag:oT.TRACER}).onSuccess(),this.safeEmit(dT.JOIN_FALLBACK_TO_PROXY,this._joinInfo.proxyServer),kC("JOIN_WITH_FALLBACK_MEDIA_PROXY_FORCE")&&this._joinInfo.turnServer.servers.forEach((e=>{"forceturn"in e&&(e.forceturn=!0);})),this._gateway.join(this._joinInfo,this._key)}if(KC.info("[".concat(this._clientId,"] join by datachannel timeout, fallback to websocket")),!this._joinInfo||!this._key)throw new xv(xg.INVALID_OPERATION);return rv.reportApiInvoke(this._sessionId,{name:sT.DATACHANNEL_FAILBACK,options:[this.store.clientId],tag:oT.TRACER}).onSuccess(),this._joinGateway()}return e})).then((e=>e))}async leave(){KC.info("[".concat(this._clientId,"] Leaving channel")),window.removeEventListener(Sg()?"beforeunload":"pagehide",this._handleBeforeUnload),this._reset(),function(e){const t=cv.indexOf(e);-1!==t&&cv.splice(t,1);}(this);const e=await this._leaveMutex.lock();if("DISCONNECTED"===this.connectionState)return KC.info("[".concat(this._clientId,"] Leaving channel repeated, success")),void e();await this._gateway.leave("CONNECTED"!==this.connectionState),KC.info("[".concat(this._clientId,"] Leaving channel success")),this._joinAndNotLeaveYet=!1,this.store.resetJoinChannelServiceRecords(),e();}async publish(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];if(!Array.isArray(e)){if(!(e instanceof iA))return this._publishDataChannel(e);e=[e];}if(0===e.length)throw new xv(xg.INVALID_PARAMS,"param list is empty");const i=e;if("audience"===this._gateway.role)throw new xv(xg.INVALID_OPERATION,"audience can not publish stream");for(const e of i){if(!(e instanceof iA))throw new xv(xg.INVALID_PARAMS,"parameter is not local track");if(!e._enabled&&t)throw new xv(xg.TRACK_IS_DISABLED,"can not publish a disabled track: ".concat(e.getTrackId()))}KC.info("[".concat(this._clientId,"] Publishing tracks, id ").concat(i.map((e=>"".concat(e.getTrackId()," ")))));const n=await this._publishMutex.lock();await this._configDistribute.awaitConfigDistributeComplete(),t&&i.forEach((e=>{const t=this._configDistribute.getBitrateLimit();e instanceof Sb&&t&&e.setBitrateLimit(t.uplink);}));try{await this._publishHighStream(i),KC.info("[".concat(this._clientId,"] Publish success, id ").concat(i.map((e=>"".concat(e.getTrackId()," ")))));}catch(e){throw KC.error("[".concat(this._clientId,"] publish error"),e.toString()),e}finally{n();}}async _publishDataChannel(e){jg(e.id,"id",0,65535,!0),Fg(e.ordered,"ordered"),Wg(e.metadata,"metadata",0,512),KC.info("[".concat(this._clientId,"] Publishing datachannels, id ").concat(e.id));const t=await this._publishMutex.lock();try{if(-1!==this._p2pChannel.getAllDataChannels().findIndex((t=>t.id===e.id)))throw new xv(xg.INVALID_PARAMS,"Invalid id: ".concat(e.id,". If you want to republish the datachannel, unpublish first"));if(!this._joinInfo||void 0===this._uid)throw new xv(xg.INVALID_OPERATION,"Can't publish datachannel, haven't joined yet!");if("CONNECTED"!==this.connectionState&&"RECONNECTING"!==this.connectionState)throw new xv(xg.INVALID_OPERATION,"can not publish datachannel in ".concat(this.connectionState," state"));if("auto"===this._turnServer.mode&&kC("FORCE_TURN")&&!kC("TURN_ENABLE_TCP")&&!kC("TURN_ENABLE_UDP"))throw new xv(xg.UNEXPECTED_ERROR,"force TURN With No TURN Configuration");const i=new sD(e);await this._p2pChannel.publishDataChannel([i]);try{const t={streamId:e.id,ordered:e.ordered,maxRetransmits:kC("DATASTREAM_MAX_RETRANSMITS"),metadata:e.metadata,channelId:i._originDataChannelId};await this._gateway.publishDataChannel(this._uid,t,!0);}catch(e){if(e.code!==xg.DISCONNECT_P2P)throw e}return await i._waitTillOpen(),KC.info("[".concat(this._clientId,"] Publish dataChannels success, id ").concat(i.id)),i}catch(e){throw KC.error("[".concat(this._clientId,"] publish datachannels error"),e.toString()),e}finally{t();}}async unpublish(e){if(!this._joinInfo||void 0===this._uid)throw new xv(xg.INVALID_OPERATION,"Can't unpublish stream, haven't joined yet!");let t=[];if(e)if(Array.isArray(e))t=e;else {if(!(e instanceof iA))return this._unpublishDataChannel([e]);t=[e];}else this.store.useP2P||await this._unpublishDataChannel(),t=this._p2pChannel.getAllTracks(!0);KC.info("[".concat(this._clientId,"] Unpublish tracks, tracks ").concat(t.map((e=>"".concat(e.getTrackId()," ")))," "));const i=await this._publishMutex.lock();try{if(this._p2pChannel instanceof PM){const e=await this._p2pChannel.unpublish(t);if(e){const t=await this._gateway.sendExtensionMessage(wI.UNPUBLISH,e);t&&await this._p2pChannel.setDescription("local",t);}}else {const e=await this._p2pChannel.unpublish(t);e&&await this._gateway.unpublish(e,this._uid),KC.info("[".concat(this._clientId,"] Unpublish success,tracks ").concat(t.map((e=>"".concat(e.getTrackId())))));}}catch(e){throw KC.error("[".concat(this._clientId,"] unpublish error"),e.toString()),e}finally{i&&i();}}async _unpublishDataChannel(e){void 0!==e&&0!==e.length||(e=this._p2pChannel.getAllDataChannels()),KC.info("[".concat(this._clientId,"] Unpublish datachannels, datachannels ").concat(e.map((e=>"".concat(e.id," ")))," "));const t=await this._publishMutex.lock();try{const i=await this._p2pChannel.unpublishDataChannel(e);i&&await this._gateway.unpublishDataChannel(i),KC.info("[".concat(this._clientId,"] Unpublish dataChannel success,dataChannel ").concat(e.map((e=>"".concat(e.id)))));}catch(e){throw KC.error("[".concat(this._clientId,"] unpublish dataChannel error"),e.toString()),e}finally{t&&t();}}async subscribe(e,t,i){return "datachannel"===t?this._subscribeDataChannel(e,i):this._subscribe(e,t)}async _subscribeDataChannel(e,t){var i;if(jg(t,"channelId",0,65535,!0),!this._joinInfo)throw new xv(xg.INVALID_OPERATION,"Can't subscribe datachannel, not joined");if("CONNECTED"!==this.connectionState&&"RECONNECTING"!==this.connectionState)throw new xv(xg.INVALID_OPERATION,"Can't subscribe datachannel in ".concat(this.connectionState," state"));if(!this._users.find((t=>t===e)))throw KC.error("[".concat(this._clientId,"] can not subscribe ").concat(e.uid,", this user is not in the channel")),new xv(xg.INVALID_REMOTE_USER,"user is not in the channel");if(!e.hasAudio&&!e.hasVideo&&0===e._dataChannels.length)throw KC.error("[".concat(this._clientId,"] can not subscribe ").concat(e.uid,", user is not published")),new xv(xg.INVALID_REMOTE_USER,"user is not published");const n=null===(i=e._dataChannels)||void 0===i?void 0:i.find((e=>e.id===t));if(!n)throw KC.error("[".concat(this._clientId,"] can not subscribe ").concat(e.uid," with mediaType datachannel, remote datachannel is not published")),new xv(xg.REMOTE_USER_IS_NOT_PUBLISHED);const r=await this._subscribeMutex.lock();KC.info("[".concat(this._clientId,"] subscribe user ").concat(e.uid,", mediaType: datachannel"));try{const t=await this._p2pChannel.subscribeDataChannel(e,[n]);if(t&&Pr(t).call(t,n.id))try{var s;if(!n._originDataChannelId)throw KC.error("[".concat(this._clientId,"] can not subscribe ").concat(e.uid," with mediaType datachannel, cannot get RTCDatachannel")),new xv(xg.REMOTE_USER_IS_NOT_PUBLISHED);const t={id:n.id,datachannelId:n._originDataChannelId,ordered:n.ordered,maxRetransmits:n.maxRetransmits,metadata:null!==(s=n.metadata)&&void 0!==s?s:""};await this._gateway.subscribeDataChannel(e.uid,t,!0);}catch(t){if((null==t?void 0:t.code)!==xg.WS_ABORT)throw await this._p2pChannel.unsubscribeDataChannel(e,[n]),t;await this._p2pChannel.unsubscribeDataChannel(e,[n]),this._p2pChannel.setPendingRemoteDataChannel(e,n.id);}return await n._waitTillOpen(),KC.info("[".concat(this._clientId,"] subscribe success user ").concat(e.uid,", mediaType: datachannel")),n}finally{r();}}async _p2pSubscribe(e,t,i){if(Bg(t,"mediaType",["audio","video"]),!this._joinInfo)throw new xv(xg.INVALID_OPERATION,"Can't subscribe stream, not joined");if("CONNECTED"!==this.connectionState&&"RECONNECTING"!==this.connectionState)throw new xv(xg.INVALID_OPERATION,"Can't subscribe stream in ".concat(this.connectionState," state"));if(!this._users.find((t=>t===e))){const t=new xv(xg.INVALID_REMOTE_USER,"user is not in the channel");throw KC.error("[".concat(this._clientId,"] can not subscribe ").concat(e.uid,", this user is not in the channel")),t}if(!e.hasAudio&&!e.hasVideo){const t=new xv(xg.INVALID_REMOTE_USER,"user is not published");throw KC.error("[".concat(this._clientId,"] can not subscribe ").concat(e.uid,", user is not published")),t}if(!i&&("audio"===t&&!e.hasAudio||"video"===t&&!e.hasVideo)){const i=new xv(xg.REMOTE_USER_IS_NOT_PUBLISHED);throw KC.error("[".concat(this._clientId,"] can not subscribe ").concat(e.uid," with mediaType ").concat(t,", remote track is not published")),i}const n=await this._subscribeMutex.lock();KC.info("[".concat(this._clientId,"] subscribe user ").concat(e.uid,", mediaType: ").concat(t));const r="audio"===t?_I.LocalAudioTrack:this._joinInfo.defaultVideoStream===Uy.LOW_STREAM?_I.LocalVideoLowTrack:_I.LocalVideoTrack;try{await this._p2pChannel.hasRemoteMediaWithLock(e,t)?await this._p2pChannel.unmuteRemote(e,t):(this.store.subscribe(e.uid,t,Date.now()),this._p2pChannel instanceof PM&&await this._gateway.sendExtensionMessage(wI.SUBSCRIBE,{trackType:r})),KC.info("[".concat(this._clientId,"] subscribe success user ").concat(e.uid,", mediaType: ").concat(t)),this._defaultStreamFallbackType&&this.setStreamFallbackOption(e.uid,this._defaultStreamFallbackType).catch((e=>{KC.warning("[".concat(this._clientId,"] auto set fallback failed"),e);}));const i="audio"===t?e._audioTrack:e._videoTrack;if(!i)throw new xv(xg.UNEXPECTED_ERROR,"can not find remote track in user object");return i}catch(t){throw KC.error("[".concat(this._clientId,"] subscribe user ").concat(e.uid," error"),t),t}finally{n();}}async _subscribe(e,t,i){if(this._p2pChannel instanceof PM)return this._p2pSubscribe(e,t);if(Bg(t,"mediaType",["audio","video"]),!this._joinInfo)throw new xv(xg.INVALID_OPERATION,"Can't subscribe stream, not joined");if("CONNECTED"!==this.connectionState&&"RECONNECTING"!==this.connectionState)throw new xv(xg.INVALID_OPERATION,"Can't subscribe stream in ".concat(this.connectionState," state"));if(!this._users.find((t=>t===e))){const t=new xv(xg.INVALID_REMOTE_USER,"user is not in the channel");throw KC.error("[".concat(this._clientId,"] can not subscribe ").concat(e.uid,", this user is not in the channel")),t}if(!e.hasAudio&&!e.hasVideo){const t=new xv(xg.INVALID_REMOTE_USER,"user is not published");throw KC.error("[".concat(this._clientId,"] can not subscribe ").concat(e.uid,", user is not published")),t}if(!(i||("audio"!==t||e.hasAudio&&void 0!==e._audioSSRC)&&("video"!==t||e.hasVideo&&void 0!==e._videoSSRC))){const i=new xv(xg.REMOTE_USER_IS_NOT_PUBLISHED);throw KC.error("[".concat(this._clientId,"] can not subscribe ").concat(e.uid," with mediaType ").concat(t,", remote track is not published")),i}let n="audio"===t?e._audioSSRC:e._videoSSRC,r="audio"===t?e._audioOrtc:e._videoOrtc,s="video"===t?e._rtxSsrcId:void 0,o={stream_type:"audio"===t?hI.AUDIO:hI.VIDEO,ssrcId:n};const a=await this._subscribeMutex.lock();KC.info("[".concat(this._clientId,"] subscribe user ").concat(e.uid,", mediaType: ").concat(t));try{if(await this._p2pChannel.hasRemoteMediaWithLock(e,t))await this._p2pChannel.unmuteRemote(e,t);else try{const i="audio"===t?e._audioSSRC:e._videoSSRC;void 0!==i&&i!==n&&(n=i,r="audio"===t?e._audioOrtc:e._videoOrtc,s="video"===t?e._rtxSsrcId:void 0,o={stream_type:"audio"===t?hI.AUDIO:hI.VIDEO,ssrcId:n}),cD.markSubscribeStart(this.store.clientId,n),this.store.subscribe(e.uid,t,Date.now()),await this._p2pChannel.subscribe(e,t,n,s,r);try{await this._gateway.subscribe(e.uid,o,!0);}catch(i){if((null==i?void 0:i.code)!==xg.WS_ABORT)throw await this._p2pChannel.unsubscribe(e,t),i;await this._p2pChannel.unsubscribe(e,t,!0),this._p2pChannel.setPendingRemoteMedia(e,t);}this.store.subscribe(e.uid,t,void 0,Date.now()),this._p2pChannel.reportSubscribeEvent(!0,null,e,t);}catch(i){throw this._p2pChannel.reportSubscribeEvent(!1,null==i?void 0:i.code,e,t),i}KC.info("[".concat(this._clientId,"] subscribe success user ").concat(e.uid,", mediaType: ").concat(t)),this._defaultStreamFallbackType&&this.setStreamFallbackOption(e.uid,this._defaultStreamFallbackType).catch((e=>{KC.warning("[".concat(this._clientId,"] auto set fallback failed"),e);}));const i="audio"===t?e._audioTrack:e._videoTrack;if(!i)throw new xv(xg.UNEXPECTED_ERROR,"can not find remote track in user object");return i}catch(t){throw KC.error("[".concat(this._clientId,"] subscribe user ").concat(e.uid," error"),t),t}finally{a();}}async massSubscribe(e){if(Hg(e,"subscribeList"),!this._joinInfo)throw new xv(xg.INVALID_OPERATION,"Can't subscribe stream, not joined");if("CONNECTED"!==this.connectionState&&"RECONNECTING"!==this.connectionState)throw new xv(xg.INVALID_OPERATION,"Can't subscribe stream in ".concat(this.connectionState," state"));const t=Date.now(),i=new Map,n=await this._subscribeMutex.lock();KC.info("[".concat(this._clientId,"]start massSubscribe user ").concat(e.map((e=>{let{user:t,mediaType:i}=e;return "user: ".concat(null==t?void 0:t.uid,", mediaType: ").concat(i)})).join("; ")));const r=(e=[...e]).map((e=>{let{user:t,mediaType:i}=e;return {user:t,mediaType:i}})),s=await this._p2pChannel.globalLock();try{var o;for(let t=e.length-1;t>=0;t--){const n=e[t],{user:s,mediaType:o}=n;if(Bg(o,"mediaType",["audio","video"]),!s){const e=new xv(xg.INVALID_PARAMS,"user property does not exist in subscribeList item");throw KC.error("[".concat(this._clientId,"] user property does not exist in subscribeList item")),e}if(!this._users.find((e=>e===s))){const i=new xv(xg.INVALID_REMOTE_USER,"user is not in the channel");KC.error("[".concat(this._clientId,"] can not massSubscribe ").concat(s.uid,", this user is not in the channel")),r[t].error=i,e.splice(t,1);continue}if("audio"===o&&(!s.hasAudio||void 0===s._audioSSRC)||"video"===o&&(!s.hasVideo||void 0===s._videoSSRC)){const i=new xv(xg.REMOTE_USER_IS_NOT_PUBLISHED);KC.error("[".concat(this._clientId,"] can not subscribe ").concat(s.uid," with mediaType ").concat(o,", remote user is not published")),r[t].error=i,e.splice(t,1);continue}const a=iI.Video|iI.LwoVideo,c=i.get(s);if(c){if("video"===o?c&a:c&iI.Audio){e.splice(t,1),KC.warning("[".concat(this._clientId,"] repeat massSubscribe user:").concat(s.uid,", mediaType:").concat(o," twice"));continue}i.set(s,c|("video"===o?a:iI.Audio));}else i.set(s,"video"===o?a:iI.Audio);}for(let t=e.length-1;t>=0;t--){const n=e[t],{user:r,mediaType:s}=n,o=iI.Video|iI.LwoVideo;if(this._p2pChannel.hasRemoteMedia(r,s)){await this._p2pChannel.unmuteRemoteNoLock(r,s);const n=i.get(r);i.set(r,"video"===s?n^o:n^iI.Audio),e.splice(t,1);}}this.store.massSubscribe(e.map((e=>({userId:e.user.uid,type:e.mediaType}))),t);const a=cS(o=Array.from(i.entries())).call(o,((e,t)=>{let[i,n]=t;if(0===n)return e;const r={stream_id:i.uid,stream_type:n};return n&iI.Audio&&(r.audio_ssrc=i._audioSSRC),n&iI.Video&&(r.video_ssrc=i._videoSSRC),e.push(r),e}),[]);try{e.length>0&&await this._p2pChannel.massSubscribeNoLock(e.map((e=>{let{user:t,mediaType:i}=e;return {user:t,mediaType:i,ssrcId:i===hI.VIDEO?t._videoSSRC:t._audioSSRC,rtxSsrcId:i===hI.VIDEO?t._rtxSsrcId:void 0}})));const i=new Map;if(a.length>0){const e=await this._gateway.subscribeAll(a,!0);((null==e?void 0:e.users)||[]).forEach((e=>{let{stream_id:t,video_error_code:n,audio_error_code:r,error_code:s}=e;(n||r||s)&&i.set(t,{video_error_code:n,audio_error_code:r,error_code:s});}));}if(Array.from(i.entries()).length>0){const e=Array.from(i.entries()).map((e=>{let t,[i,n]=e;n.error_code||n.video_error_code&&n.audio_error_code?t=void 0:n.video_error_code?t=hI.VIDEO:n.audio_error_code&&(t=hI.AUDIO);return {user:this.remoteUsers.find((e=>e.uid===i)),mediaType:t}}));await this._p2pChannel.massUnsubscribeNoLock(e);}for(const e of r){const t=i.get(e.user.uid);if(t){const i=t.error_code||"audio"===e.mediaType&&t.audio_error_code||"video"===e.mediaType&&t.video_error_code;if(i){const t=UI(i);KC.error("user:".concat(e.user.uid," mediaType:").concat(e.mediaType," has massSubscribe error ").concat(t.desc)),e.error=new xv(xg.SUBSCRIBE_FAILED,"code ".concat(i,": ").concat(t.desc));}}e.error||("video"===e.mediaType?e.track=e.user.videoTrack:e.track=e.user.audioTrack);}return this.store.massSubscribe(r.filter((e=>!e.error)).map((e=>({userId:e.user.uid,type:e.mediaType}))),void 0,Date.now()),r.forEach((e=>{var i;rv.subscribe(this.store.sessionId,{succ:!!e.error,ec:(null===(i=e.error)||void 0===i?void 0:i.code)||null,video:e.mediaType===hI.VIDEO,audio:e.mediaType===hI.AUDIO,peerid:e.user.uid,subscribeRequestid:e.mediaType===hI.VIDEO?e.user._videoSSRC:e.user._audioSSRC,p2pid:this.store.p2pId,eventElapse:Math.floor(performance.now()-t)},!0);})),KC.info("[".concat(this._clientId,"] massSubscribe success ").concat(e.map((e=>{let{user:t,mediaType:i}=e;return "user: ".concat(null==t?void 0:t.uid,", mediaType: ").concat(i)})).join("; "))),r}catch(t){throw await this._p2pChannel.massUnsubscribeNoLock(e),t}}finally{s(),n();}}async unsubscribe(e,t,i){if(t||this.store.useP2P){if("datachannel"===t)return this._unsubscribeDataChannel(e,i)}else await this._unsubscribeDataChannel(e,i);if(t&&Bg(t,"mediaType",["audio","video"]),!this._joinInfo)throw new xv(xg.INVALID_OPERATION,"Can't unsubscribe stream, haven't joined yet!");if(!this._users.find((t=>t===e))){const t=new xv(xg.INVALID_REMOTE_USER,"user is not in the channel");throw KC.error("[".concat(this._clientId,"] can not unsubscribe ").concat(e.uid,", user is not in the channel")),t}KC.info("[".concat(this._clientId,"] unsubscribe uid: ").concat(e.uid,", mediaType: ").concat(t));const n=await this._subscribeMutex.lock();try{if(this._p2pChannel instanceof PM)await this._gateway.sendExtensionMessage(wI.UNSUBSCRIBE,{mediaType:t});else {const i=await this._p2pChannel.unsubscribe(e,t);i&&await this._gateway.unsubscribe(i,e.uid),KC.info("[".concat(this._clientId,"] unsubscribe success uid: ").concat(e.uid,", mediaType: ").concat(t));}}catch(t){if(t.code===xg.DISCONNECT_P2P)return void KC.warning("disconnecting p2p, abort unsubscribe request.");throw KC.error("[".concat(this._clientId,"] unsubscribe user ").concat(e.uid," error"),t.toString()),t}finally{n();}}async _unsubscribeDataChannel(e,t){if(t&&jg(t,"id",0,65535,!0),!this._joinInfo)throw new xv(xg.INVALID_OPERATION,"Can't unsubscribe datachannel, haven't joined yet!");if(!this._users.find((t=>t===e))){const t=new xv(xg.INVALID_REMOTE_USER,"user is not in the channel");throw KC.error("[".concat(this._clientId,"] can not unsubscribe ").concat(e.uid,", user is not in the channel")),t}let i;if("number"==typeof t){const n=e._dataChannels.find((e=>e.id===t));n&&(i=[n]);}else i=e._dataChannels;if(void 0===i){const i=new xv(xg.REMOTE_USER_IS_NOT_PUBLISHED);throw KC.error("[".concat(this._clientId,"] can not unsubscribe ").concat(e.uid," with channelId ").concat(t,", remote datachannel is not published")),i}KC.info("[".concat(this._clientId,"] unsubscribe uid: ").concat(e.uid,", mediaType: datachannel, ids: ").concat(i.map((e=>e.id))));try{const t=await this._p2pChannel.unsubscribeDataChannel(e,i);t&&await this._gateway.unsubscribeDataChannel(t,e.uid),KC.info("[".concat(this._clientId,"] unsubscribe datachannel success uid: ").concat(e.uid,", mediaType: datachannel, ids: ").concat(t));}catch(t){if(t.code===xg.DISCONNECT_P2P)return void KC.warning("disconnecting p2p, abort unsubscribe request.");throw KC.error("[".concat(this._clientId,"] unsubscribe user ").concat(e.uid," error"),t.toString()),t}}async massUnsubscribe(e){if(Hg(e,"unsubscribeList"),!this._joinInfo)throw new xv(xg.INVALID_OPERATION,"Can't unsubscribeAll stream, haven't joined yet!");KC.info("[".concat(this._clientId,"] start massUnsubscribe ").concat(e.map((e=>{let{user:t,mediaType:i}=e;return "user: ".concat(null==t?void 0:t.uid,", mediaType: ").concat(i,";")})).join())),e=[...e];const t=new Map;for(let i=e.length-1;i>=0;i--){const{user:n,mediaType:r}=e[i];if(!n){const e=new xv(xg.INVALID_PARAMS,"user property does not exist in unsubscribeList item");throw KC.error("[".concat(this._clientId,"] user property does not exist in unsubscribeList item")),e}Bg(r,"mediaType",["video","audio",void 0]);if(!this._users.find((e=>e===n))){KC.warning("[".concat(this._clientId,"] can not unsubscribe ").concat(n.uid,", user is not in the channel")),e.splice(i,1);continue}const s=iI.Video|iI.LwoVideo;if(t.has(n)){const o=t.get(n);let a;switch(r){case"video":a=o&s;break;case"audio":a=o&iI.Audio;break;default:a=o&(iI.Audio|s);}if(a){KC.warning("[".concat(this._clientId,"] repeat massUnsubscribe user:").concat(n.uid,",mediaType:").concat(r," twice.")),e.splice(i,1);continue}r?"audio"===r?t.set(n,o|iI.Audio):"video"===r&&t.set(n,o|s):t.set(n,o|iI.Audio|s);}else r?"audio"===r?t.set(n,iI.Audio):"video"===r&&t.set(n,s):t.set(n,iI.Audio|s);}try{const t=await this._p2pChannel.massUnsubscribe(e);t&&await this._gateway.massUnsubscribe(t),KC.info("[".concat(this._clientId,"] massUnsubscribe success ").concat(e.map((e=>{let{user:t,mediaType:i}=e;return "user: ".concat(null==t?void 0:t.uid,", mediaType: ").concat(i,";")})).join()));}catch(e){if(e.code===xg.DISCONNECT_P2P)return void KC.warning("[".concat(this._clientId,"] disconnecting p2p, abort unsubscribe request."));throw KC.error("[".concat(this._clientId,"] massUnsubscribe error"),e.toString()),e}}async setLowStreamParameter(e){!function(e){if(!e)throw new Vg(xg.INVALID_PARAMS);Kg(e.width)||Gg(e.width,"streamParameter.width"),Kg(e.height)||Gg(e.height,"streamParameter.height"),Kg(e.framerate)||Gg(e.framerate,"streamParameter.framerate"),Kg(e.bitrate)||jg(e.bitrate,"streamParameter.bitrate");}(e),(!e.width&&e.height||e.width&&!e.height)&&KC.warning("[".concat(this._clientId,"] The width and height parameters take effect only when both are set")),KC.info("[".concat(this._clientId,"] set low stream parameter to"),JSON.stringify(e));const t=this._configDistribute.getLowStreamConfigDistribute();if(t&&t.bitrate&&e.bitrate&&t.bitrate<e.bitrate&&(e.bitrate=t.bitrate),this._lowStreamParameter=e,this._isDualStreamEnabled)return this._p2pChannel.updateVideoStreamParameter(e,_I.LocalVideoLowTrack)}async enableDualStream(){if(!_A().supportDualStream)throw rv.streamSwitch(this._sessionId,{lts:Date.now(),isdual:!0,succ:!1}),new xv(xg.NOT_SUPPORTED,"Your browser is not support dual stream");if(this._isDualStreamEnabled)throw new xv(xg.INVALID_OPERATION,"Dual stream is already enabled");if(this._p2pChannel.canPublishLowStream())try{await this._publishLowStream();}catch(e){throw rv.streamSwitch(this._sessionId,{lts:Date.now(),isdual:!0,succ:!1}),e}this._isDualStreamEnabled=!0,rv.streamSwitch(this._sessionId,{lts:Date.now(),isdual:!0,succ:!0}),KC.info("[".concat(this._clientId,"] enable dual stream"));}async disableDualStream(){if(this._isDualStreamEnabled){if(!this._joinInfo)throw new xv(xg.INVALID_OPERATION,"Can't publish stream, haven't joined yet!");if(this._p2pChannel.getLocalMedia(_I.LocalVideoLowTrack))try{const e=await this._p2pChannel.unpublishLowStream();e&&await this._gateway.unpublish(e,this._joinInfo.stringUid||this._joinInfo.uid);}catch(e){throw rv.streamSwitch(this._sessionId,{lts:Date.now(),isdual:!1,succ:!1}),e}this._isDualStreamEnabled=!1,rv.streamSwitch(this._sessionId,{lts:Date.now(),isdual:!1,succ:!0}),KC.info("[".concat(this._clientId,"] disable dual stream"));}}async setClientRole(e,t){if(function(e){Bg(e,"role",["audience","host"]);}(e),t&&mT(t),"rtc"===this.mode)throw KC.warning("[".concat(this._clientId,"]rtc mode can not use setClientRole")),new xv(xg.INVALID_OPERATION,"rtc mode can not use setClientRole");if(t&&t.level&&"host"===e)throw new xv(xg.INVALID_OPERATION,"host mode can not set audience latency level");if("audience"===e&&this._p2pChannel.hasLocalMedia())throw new xv(xg.INVALID_OPERATION,"can not set client role to audience when publishing stream");await this._gateway.setClientRole(e,t),this._config.role=e,KC.info("[".concat(this._clientId,"] set client role to ").concat(e,", level: ").concat(t&&t.level));}getRemoteInboundOffset(){var e;const t=null===(e=this._p2pChannel.getStats())||void 0===e?void 0:e.audioSend[0];if(!t||!t.timestamp)return 0;const i=t.timestamp-Date.now();return Math.abs(i)>1e3+t.rttMs+100?this.ntpAlignErrorCount+=1:this.ntpAlignErrorCount=0,this.ntpAlignErrorCount>=3?i:0}getNtpWallTimeInMs(){return "visible"===document.visibilityState&&(this.remoteInboundOffset=this.getRemoteInboundOffset()),this.remoteInboundOffset+Date.now()+this._gateway.ntpOffset}setProxyServer(e,t){if(Wg(e,"proxyServer"),!t){if("DISCONNECTED"!==this.connectionState)throw new xv(xg.INVALID_OPERATION,"Set proxy server before join channel");if("disabled"!==this._cloudProxyServerMode||this._useLocalAccessPoint)throw new xv(xg.INVALID_OPERATION,"You have already set the proxy")}this._proxyServer=e,rv.setProxyServer(this._proxyServer),KC.setProxyServer(this._proxyServer),KC.info("[".concat(this._clientId,"] Set proxy server ").concat(t?"by initialize call":""," success."));}setTurnServer(e,t){if(Array.isArray(e)||(e=[e]),!t){if("DISCONNECTED"!==this.connectionState)throw new xv(xg.INVALID_OPERATION,"Set turn server before join channel");if("disabled"!==this._cloudProxyServerMode||this._useLocalAccessPoint)throw new xv(xg.INVALID_OPERATION,"You have already set the proxy")}if(_T(e))return this._turnServer={servers:e,mode:"original-manual"},void KC.info("[".concat(this._clientId,"] Set original turnserver ").concat(t?"by initialize call":""," success: ").concat(e.map((e=>e.urls)).join(","),"."));e.forEach((e=>ET(e))),this._turnServer={servers:e,mode:"manual"},KC.info("[".concat(this._clientId,"] Set turnserver ").concat(t?"by initialize call":""," success."));}setLicense(e){if("DISCONNECTED"!==this.connectionState){throw new xv(xg.INVALID_OPERATION,"you should set license before join channel")}if(Wg(e,"license",32,32),!/^[A-Za-z\d]+$/.test(e))throw new xv(xg.INVALID_PARAMS,"license should only contains characters from A-Z a-z 0-9");this._license=e,KC.info("[".concat(this._clientId,"] set license success"),e);}startProxyServer(e){if("DISCONNECTED"!==this.connectionState)throw new xv(xg.INVALID_OPERATION,"Start proxy server before join channel");if(this._proxyServer||"manual"===this._turnServer.mode||this._useLocalAccessPoint)throw new xv(xg.INVALID_OPERATION,"You have already set the proxy");const t=[3,4,5];let i;switch(void 0===e&&(e=3),e){case 1:case 2:throw new xv(xg.NOT_SUPPORTED,"proxy mode 1/2 has been deprecated and not supported.");case 3:i="proxy3";break;case 4:i="proxy4";break;case 5:i="proxy5";break;default:throw new xv(xg.INVALID_PARAMS,"proxy server mode must be ".concat(t.join("|")))}this._cloudProxyServerMode=i,this.store.cloudProxyServerMode=i,KC.info("[".concat(this._clientId,"] set cloud proxy server mode to"),this._cloudProxyServerMode);}stopProxyServer(){if("DISCONNECTED"!==this.connectionState)throw new xv(xg.INVALID_OPERATION,"Stop proxy server after leave channel");rv.setProxyServer(),KC.setProxyServer(),this._cloudProxyServerMode="disabled",this.store.cloudProxyServerMode="disabled",KC.info("[".concat(this._clientId,"] set cloud proxy server mode to"),this._cloudProxyServerMode),this._proxyServer=void 0,this._turnServer={mode:"auto",servers:[]};}setLocalAccessPointsV2(e){if(!e.accessPoints)throw new xv(xg.INVALID_PARAMS,"accessPoints is required.");Hg(e.accessPoints.serverList,"accessPoints.serverList"),Wg(e.accessPoints.domain,"accessPoints.domain");const t=(e,t)=>{jg(e,t,0,65535,!0);};let i=443;if(e.accessPoints.port&&(t(e.accessPoints.port,"accessPoints.port"),i=e.accessPoints.port),this._proxyServer||"disabled"!==this._cloudProxyServerMode)throw new xv(xg.INVALID_OPERATION,"set local access point failed, You have already set the cloud proxy");kC("CLOSE_AFB_FOR_LOCAL_AP")&&(LC("JOIN_WITH_FALLBACK_SIGNAL_PROXY",!1),LC("JOIN_WITH_FALLBACK_MEDIA_PROXY",!1));const n=/^((\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.){3}(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])$/,r=e.accessPoints.domain,s=e.accessPoints.serverList.map((e=>n.test(e)?"".concat(e.replace(/\./g,"-"),".").concat(r):e)),o=s.map((e=>"".concat(e,":").concat(i)));this._useLocalAccessPoint=!0,this._setLocalAPVersion=2,LC("WEBCS_DOMAIN",o),LC("WEBCS_DOMAIN_BACKUP_LIST",o),LC("GATEWAY_DOMAINS",[r]),e.report&&e.report.hostname&&Array.isArray(e.report.hostname)&&e.report.hostname.length?(Hg(e.report.hostname,"report.hostname"),LC("EVENT_REPORT_DOMAIN",e.report.hostname[0]),LC("EVENT_REPORT_BACKUP_DOMAIN",e.report.hostname[1]||e.report.hostname[0])):(LC("EVENT_REPORT_DOMAIN",s[0]),LC("EVENT_REPORT_BACKUP_DOMAIN",s[1]||s[0]));let a=6443;e.report&&e.report.port&&(t(e.report.port,"report.port"),a=e.report.port),LC("STATS_COLLECTOR_PORT",a),e.report?LC("ENABLE_EVENT_REPORT",!0):LC("ENABLE_EVENT_REPORT",!1);let c="";e.log&&e.log.hostname&&Array.isArray(e.log.hostname)&&e.log.hostname.length?(Hg(e.log.hostname,"log.hostname"),c=e.log.hostname[0]):c=s[0];let d=6444;e.log&&e.log.port&&(t(e.log.port,"log.port"),d=e.log.port),LC("LOG_UPLOAD_SERVER","".concat(c,":").concat(d));let l=[];e.cds&&e.cds.hostname&&Array.isArray(e.cds.hostname)&&e.cds.hostname.length?(Hg(e.cds.hostname,"cds.hostname"),l=e.cds.hostname):l=s;let h=443;e.cds&&e.cds.port&&(t(e.cds.port,"cds.port"),h=e.cds.port),LC("CDS_AP",l.map((e=>"".concat(e,":").concat(h)))),e.cds?LC("ENABLE_CONFIG_DISTRIBUTE",!0):LC("ENABLE_CONFIG_DISTRIBUTE",!1),KC.info("set local access point v2 success");}setLocalAccessPoints(e,t){if(Hg(e,"serverList"),Wg(t,"domain"),this._proxyServer||"disabled"!==this._cloudProxyServerMode)throw new xv(xg.INVALID_OPERATION,"set local access point failed, You have already set the cloud proxy");const i=/^(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])\.(\d{1,2}|1\d\d|2[0-4]\d|25[0-5])$/;e=e.map((e=>i.test(e)?"".concat(e.replace(/\./g,"-"),".").concat(t):e)),this._useLocalAccessPoint=!0,this._setLocalAPVersion=1,LC("WEBCS_DOMAIN",e),LC("WEBCS_DOMAIN_BACKUP_LIST",e),LC("GATEWAY_DOMAINS",[t]),LC("EVENT_REPORT_DOMAIN",e[0]),LC("EVENT_REPORT_BACKUP_DOMAIN",e[1]||e[0]),LC("LOG_UPLOAD_SERVER","".concat(e[0],":6444")),KC.info("[".concat(this._clientId,"] set local access point success"));}async setRemoteDefaultVideoStreamType(e){if(Bg(e,"streamType",[0,1]),this._remoteDefaultVideoStreamType=e,this._joinInfo)try{await this._gateway.setDefaultRemoteVideoStreamType(e),this._joinInfo.defaultVideoStream=this._remoteDefaultVideoStreamType;}catch(e){throw KC.error("[".concat(this._clientId,"] set default remote video stream type error"),e.toString()),e}else KC.debug("[".concat(this._clientId,"] haven't joined yet, cache remoteDefaultVideoStreamType ").concat(e));}async setRemoteVideoStreamType(e,t){Bg(t,"streamType",[0,1]);try{await this._gateway.setRemoteVideoStreamType(e,t),setTimeout((()=>{const t=this._users.find((t=>t.uid===e));t&&t.videoTrack&&t.videoTrack.updateMediaStreamTrackResolution();}),2e3);}catch(e){throw KC.error("[".concat(this._clientId,"] set remote video stream type error"),e.toString()),e}KC.info("[".concat(this._clientId,"] set remote ").concat(e," video stream type to ").concat(t)),this._remoteStreamTypeCacheMap.set(e,t);}async setStreamFallbackOption(e,t){Bg(t,"fallbackType",[0,1,2]);try{await this._gateway.setStreamFallbackOption(e,t);}catch(e){throw KC.error("[".concat(this._clientId,"] set stream fallback option"),e.toString()),e}KC.info("[".concat(this._clientId,"] set remote ").concat(e," stream fallback type to ").concat(t)),this._streamFallbackTypeCacheMap.set(e,t);}setEncryptionConfig(e,t,i){!function(e){Bg(e,"encryptionMode",["aes-128-xts","aes-256-xts","aes-128-ecb","sm4-128-ecb","aes-128-gcm","aes-256-gcm","aes-128-gcm2","aes-256-gcm2","none"]);}(e),Wg(t,"secret");const n=["aes-128-gcm2","aes-256-gcm2"];if(Pr(n).call(n,e)){if(!i||!(i instanceof Uint8Array&&32===i.length))throw new xv(xg.INVALID_PARAMS,"salt must be an Uint8Array and exactly equal to 32 bytes")}else if(i)throw new xv(xg.INVALID_PARAMS,"current encrypt mode does not need salt");new RegExp("^(?=.*[a-z])(?=.*[A-Z])(?=.*[0-9])(?=.*[!@#$%^&*,.<>?/:;'\"|{}\\[\\]])(?=.{8,})").test(t)||KC.warning("The secret is not strong:\n      The secret must contain at least 1 lowercase alphabetical character,\n      The secret must contain at least 1 uppercase alphabetical character,\n      The secret must contain at least 1 numeric character,\n      The secret must contain at least one special character,\n      The secret must be eight characters or longer.\n      "),this._encryptionMode=e,this._encryptionSecret=t,i&&(this._encryptionSalt=PT(i));}async renewToken(e){if(Wg(e,"token",1,2047),!this._key||!this._joinInfo)throw new xv(xg.INVALID_OPERATION,"renewToken should not be called before user join");const t=this._key;this._key=e,this._joinInfo&&(this._joinInfo.token=e);const i=await this._renewTokenMutex.lock();try{if(kC("USE_NEW_TOKEN")){KC.debug("[".concat(this._clientId,"] start renew token with ticket from unilbs"));const t=await mP(this._joinInfo,this._axiosCancelSource.token,this._config.httpRetryConfig||JT);KC.debug("[".concat(this._clientId,"] get ticket from unilbs success")),await this._gateway.renewToken({token:e,ticket:t});}else KC.debug("[".concat(this._clientId,"] start renew token without ticket")),await this._gateway.renewToken({token:e});KC.debug("[".concat(this._clientId,"] renewToken success"));}catch(e){throw this._key=t,this._joinInfo.token=t,KC.error("[".concat(this._clientId,"] renewToken failed"),e.toString()),e}finally{i();}}enableAudioVolumeIndicator(){this._audioVolumeIndicationInterval?KC.warning("you have already enabled audio volume indicator!"):this._audioVolumeIndicationInterval=window.setInterval((()=>{const e=this._p2pChannel.getAudioLevels();this.safeEmit(dT.VOLUME_INDICATOR,e);}),kC("AUDIO_VOLUME_INDICATION_INTERVAL")||2e3);}getRTCStats(){const e=this._statsCollector.getRTCStats(),t=this._gateway.getInChannelInfo();return e.Duration=Math.round(t.duration/1e3),e}async startLiveStreaming(e,t){if(!t){if("h264"!==this.codec)throw new xv(xg.LIVE_STREAMING_INVALID_RAW_STREAM,"raw streaming is only support h264");if(!this._p2pChannel.hasLocalMedia())throw new xv(xg.LIVE_STREAMING_INVALID_RAW_STREAM,"can not find stream to raw streaming")}if(this._liveRawStreamingClient&&this._liveRawStreamingClient.hasUrl(e)||this._liveTranscodeStreamingClient&&this._liveTranscodeStreamingClient.hasUrl(e))throw new xv(xg.LIVE_STREAMING_TASK_CONFLICT);const i=t?yv.TRANSCODE:yv.RAW;return this._createLiveStreamingClient(i).startLiveStreamingTask(e,i)}setLiveTranscoding(e){return this._createLiveStreamingClient(yv.TRANSCODE).setTranscodingConfig(e)}async stopLiveStreaming(e){const t=[this._liveRawStreamingClient,this._liveTranscodeStreamingClient].filter((t=>t&&t.hasUrl(e)));if(!t.length)throw new xv(xg.INVALID_PARAMS,"can not find live streaming url to stop");await tg.all(t.map((t=>t&&t.stopLiveStreamingTask(e))));}async addInjectStreamUrl(e,t){if(!this._joinInfo)throw new xv(xg.INVALID_OPERATION,"can not addInjectStreamUrl, no joininfo");const i=this._createLiveStreamingClient(yv.INJECT);i.setInjectStreamConfig(t,0),await i.startLiveStreamingTask(e,yv.INJECT);}async removeInjectStreamUrl(){var e;const t=this._createLiveStreamingClient(yv.INJECT),i=Array.from(kv(e=t.streamingTasks).call(e)).find((e=>e.mode===yv.INJECT));if(!this._joinInfo||!i)throw new xv(xg.INVALID_OPERATION,"can remove addInjectStreamUrl, no joininfo or inject task");await t.stopLiveStreamingTask(i.url);}async startChannelMediaRelay(e){bP(e);const t=this._createChannelMediaRelayClient();await t.startChannelMediaRelay(e);}async updateChannelMediaRelay(e){bP(e);const t=this._createChannelMediaRelayClient();await t.updateChannelMediaRelay(e);}async stopChannelMediaRelay(){const e=this._createChannelMediaRelayClient();await e.stopChannelMediaRelay(),this._statsCollector.onStatsChanged&&(this._statsCollector.onStatsChanged=void 0);}sendStreamMessage(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];if(!this._joinInfo)throw new xv(xg.INVALID_OPERATION,"can not send data stream, not joined");if(("string"==typeof e||e instanceof Uint8Array)&&(e={payload:e}),"string"==typeof e.payload){const t=new TextEncoder;e.payload=t.encode(e.payload);}if(new Blob([e.payload]).size>1024)throw new xv(xg.INVALID_PARAMS,"stream message out of range.");return this._gateway.signal.request(Tv.DATA_STREAM,{payload:PT(e.payload),syncWithAudio:e.syncWithAudio,sendTs:Date.now()-UM},!t)}sendMetadata(e){if(!this._joinInfo)throw new xv(xg.INVALID_OPERATION,"can not send metadata, not joined");if(new Blob([e]).size>1024)throw new xv(xg.METADATA_OUT_OF_RANGE);return this._gateway.signal.request(Tv.SEND_METADATA,{session_id:this._joinInfo.sid,metadata:PT(e)})}async sendCustomReportMessage(e){if(Array.isArray(e)||(e=[e]),e.forEach(JC),!this._joinInfo)throw new xv(xg.INVALID_OPERATION,"can not send custom report, not joined");await rv.sendCustomReportMessage(this._joinInfo.sid,e);}getLocalAudioStats(){return this._statsCollector.getLocalAudioTrackStats()}getRemoteAudioStats(){return this._statsCollector.getRemoteAudioTrackStats()}getLocalVideoStats(){return this._statsCollector.getLocalVideoTrackStats()}getRemoteVideoStats(){return this._statsCollector.getRemoteVideoTrackStats()}getRemoteNetworkQuality(){return this._statsCollector.getRemoteNetworkQualityStats()}async pickSVCLayer(e,t){Bg(t.spatialLayer,"spatialLayer",[0,1,2,3]),Bg(t.temporalLayer,"temporalLayer",[0,1,2,3]);try{await this._gateway.pickSVCLayer(e,t);}catch(e){throw KC.error("[".concat(this._clientId,"] pick SVC layer failed"),e.toString()),e}}setRTM2Flag(e){if(Bg(e,"flag",[0,1]),!this._joinInfo)throw new xv(xg.INVALID_OPERATION,"Can't setRtm2Flag, not joined");if("CONNECTED"!==this.connectionState&&"RECONNECTING"!==this.connectionState)throw new xv(xg.INVALID_OPERATION,"Can't setRtm2Flag in ".concat(this.connectionState," state"));return this._gateway.setRTM2Flag(e)}_reset(){if(KC.debug("[".concat(this._clientId,"] reset client")),this._axiosCancelSource.cancel(),this._axiosCancelSource=EC.CancelToken.source(),this._streamFallbackTypeCacheMap=new Map,this._remoteStreamTypeCacheMap=new Map,this._configDistribute.stopGetConfigDistribute(),this._joinInfo=void 0,this._proxyServer=void 0,this._defaultStreamFallbackType=void 0,this._sessionId=null,this.store.sessionId=null,this._statsCollector.reset(),this._key=void 0,this._appId=void 0,this._uid=void 0,this.store.uid=void 0,this._channelName=void 0,this._encryptionMode="none",this._encryptionSecret=null,this._encryptionSalt=null,this._pendingPublishedUsers=[],this._users.forEach((e=>{e._audioTrack&&e._audioTrack._destroy(),e._videoTrack&&e._videoTrack._destroy(),e._dataChannels&&(e._dataChannels.forEach((e=>e._close())),e._dataChannels.length=0);})),this._users=[],this._audioVolumeIndicationInterval&&(window.clearInterval(this._audioVolumeIndicationInterval),this._audioVolumeIndicationInterval=void 0),"fallback"===this._cloudProxyServerMode&&(this._cloudProxyServerMode="disabled",this.store.cloudProxyServerMode="disabled"),this._p2pChannel.reset(),this._publishMutex=new YT("client-publish"),this._subscribeMutex=new YT("client-subscribe"),this._networkQualityInterval&&(window.clearInterval(this._networkQualityInterval),this._networkQualityInterval=void 0),this._injectStreamingClient&&(this._injectStreamingClient.terminate(),this._injectStreamingClient.removeAllListeners(),this._injectStreamingClient=void 0),this._liveRawStreamingClient&&(this._liveRawStreamingClient.terminate(),this._liveRawStreamingClient.removeAllListeners(),this._liveRawStreamingClient=void 0),this._liveTranscodeStreamingClient&&(this._liveTranscodeStreamingClient.terminate(),this._liveTranscodeStreamingClient.removeAllListeners(),this._liveTranscodeStreamingClient=void 0),this._channelMediaRelayClient&&(this._channelMediaRelayClient.dispose(),this._channelMediaRelayClient=void 0),this._inspect)try{this._inspect.close(),this._inspect=void 0;}catch(e){}if(this._moderation)try{this.setImageModeration(!1);}catch(e){}}_startSession(e,t){const i=e||VT();e?KC.debug("[".concat(this._clientId,"] new Session ").concat(i)):KC.debug("[".concat(this._clientId,"] renewSession ").concat(this._sessionId," => ").concat(i)),this._sessionId=i,this.store.sessionId=i,t?rv.sessionInit(this._sessionId,{lts:(new Date).getTime(),cname:t.channel,appid:t.appId,mode:this.mode}):this._joinInfo?rv.sessionInit(this._sessionId,{lts:(new Date).getTime(),cname:this._joinInfo.cname,appid:this._joinInfo.appId,mode:this.mode}):this._gateway.joinInfo&&rv.sessionInit(this._sessionId,{lts:(new Date).getTime(),cname:this._gateway.joinInfo.cname,appid:this._gateway.joinInfo.appId,mode:this.mode}),this._joinInfo&&(this._joinInfo.sid=i),this._gateway.joinInfo&&(this._gateway.joinInfo.sid=i);}async _publishHighStream(e){if(!this._joinInfo||void 0===this._uid)throw new xv(xg.INVALID_OPERATION,"Can't publish stream, haven't joined yet!");if("CONNECTED"!==this.connectionState&&"RECONNECTING"!==this.connectionState)throw new xv(xg.INVALID_OPERATION,"can not publish stream in ".concat(this.connectionState," state"));if("auto"===this._turnServer.mode&&kC("FORCE_TURN")&&!kC("TURN_ENABLE_TCP")&&!kC("TURN_ENABLE_UDP"))throw new xv(xg.UNEXPECTED_ERROR,"force TURN With No TURN Configuration");KC.debug("[".concat(this._clientId,"] publish high stream"));try{if(this._p2pChannel instanceof PM){const t=await this._p2pChannel.publish(e,this._isDualStreamEnabled,this._lowStreamParameter);if(t)try{await this._gateway.sendExtensionMessage(wI.PUBLISH,t);}catch(t){throw this._p2pChannel.unpublish(e),t}}else {const i=await this._p2pChannel.publish(e,this._isDualStreamEnabled,this._lowStreamParameter),n=(await i.next()).value;if(n){var t;let e;try{e=await this._gateway.publish(this._uid,n,!0);}catch(e){if(e.code!==xg.DISCONNECT_P2P)throw i.throw(e),e}await i.next((null===(t=e)||void 0===t?void 0:t.ortc)||[]);}this._p2pChannel.reportPublishEvent(!0,null);for(const t of e)t instanceof Sb&&t._encoderConfig&&this._gateway.setVideoProfile(t._encoderConfig),!t.muted&&t.enabled||await this._p2pChannel.muteLocalTrack(t);}}catch(t){if(this._p2pChannel.reportPublishEvent(!1,null==t?void 0:t.code,e),(null==t?void 0:t.code)===xg.WS_ABORT)return;throw t}}async _publishLowStream(){if(!this._joinInfo||void 0===this._uid)throw new xv(xg.INVALID_OPERATION,"Can't publish stream, haven't joined yet!");if("CONNECTED"!==this.connectionState&&"RECONNECTING"!==this.connectionState)throw new xv(xg.INVALID_OPERATION,"can not publish stream in ".concat(this.connectionState," state"));KC.debug("[".concat(this._clientId,"] publish low stream"));const e=this._configDistribute.getLowStreamConfigDistribute();e&&e.bitrate&&(this._lowStreamParameter||(this._lowStreamParameter={width:160,height:120,framerate:15,bitrate:50}),this._lowStreamParameter&&this._lowStreamParameter.bitrate&&e.bitrate<this._lowStreamParameter.bitrate&&(this._lowStreamParameter.bitrate=e.bitrate));try{const e=await this._p2pChannel.publishLowStream(this._lowStreamParameter),i=(await e.next()).value;if(i){var t;let n;try{n=await this._gateway.publish(this._uid,i,!0);}catch(t){if(t.code!==xg.DISCONNECT_P2P)throw e.throw(t),t}e.next((null===(t=n)||void 0===t?void 0:t.ortc)||[]),this._p2pChannel.reportPublishEvent(!0,null,void 0,!0);}}catch(e){if(this._p2pChannel.reportPublishEvent(!1,null==e?void 0:e.code,void 0,!0),(null==e?void 0:e.code)===xg.WS_ABORT)return;throw e}}_createLiveStreamingClient(e){if(!this._joinInfo||!this._appId){return new xv(xg.INVALID_OPERATION,"can not create live streaming client, please join channel first").throw()}const t=()=>new yP(this._joinInfo,this._config.websocketRetryConfig||JT,this._config.httpRetryConfig||JT),i=e=>{e.onLiveStreamError=(e,t)=>{rv.reportApiInvoke(this._sessionId,{name:sT.ON_LIVE_STREAM_ERROR,options:[e,t],tag:oT.TRACER}).onSuccess(),this.safeEmit(dT.LIVE_STREAMING_ERROR,e,t);},e.onLiveStreamWarning=(e,t)=>{rv.reportApiInvoke(this._sessionId,{name:sT.ON_LIVE_STREAM_WARNING,options:[e,t],tag:oT.TRACER}).onSuccess(),this.safeEmit(dT.LIVE_STREAMING_WARNING,e,t);},e.on(Yv.REQUEST_WORKER_MANAGER_LIST,((e,t,i)=>{if(!this._joinInfo)return i(new xv(xg.INVALID_OPERATION,"can not find join info to get worker manager"));_P(e,this._joinInfo,this._axiosCancelSource.token,JT).then(t).catch(i);}));};switch(e){case yv.RAW:return this._liveRawStreamingClient||(this._liveRawStreamingClient=t(),i(this._liveRawStreamingClient)),this._liveRawStreamingClient;case yv.TRANSCODE:return this._liveTranscodeStreamingClient||(this._liveTranscodeStreamingClient=t(),i(this._liveTranscodeStreamingClient)),this._liveTranscodeStreamingClient;case yv.INJECT:return this._injectStreamingClient||(this._injectStreamingClient=t(),this._injectStreamingClient.on(Yv.REQUEST_WORKER_MANAGER_LIST,((e,t,i)=>{if(!this._joinInfo)return i(new xv(xg.INVALID_OPERATION,"can not find join info to get worker manager"));_P(e,this._joinInfo,this._axiosCancelSource.token,JT).then(t).catch(i);})),this._injectStreamingClient.onInjectStatusChange=(e,t,i)=>{this.safeEmit(dT.INJECT_STREAM_STATUS,e,t,i);}),this._injectStreamingClient}}_createChannelMediaRelayClient(){if(!this._joinInfo){return new xv(xg.INVALID_OPERATION,"can not create channel media relay client, please join channel first").throw()}if(!this._channelMediaRelayClient){const{sendResolutionWidth:e,sendResolutionHeight:t}=this.getLocalVideoStats(),i={width:e,height:t};this._channelMediaRelayClient=new OP(this._joinInfo,this._clientId,this._config.websocketRetryConfig||JT,this._config.httpRetryConfig||JT,i),this._channelMediaRelayClient.on("state",(e=>{e===Qv.RELAY_STATE_FAILURE&&this._channelMediaRelayClient&&this._channelMediaRelayClient.dispose(),this.safeEmit(dT.CHANNEL_MEDIA_RELAY_STATE,e);})),this._channelMediaRelayClient.on("event",(e=>{this.safeEmit(dT.CHANNEL_MEDIA_RELAY_EVENT,e);})),this._statsCollector.onStatsChanged=(e,t)=>{var i;"resolution"===e&&(null===(i=this._channelMediaRelayClient)||void 0===i||i.setVideoProfile(t));};}return this._channelMediaRelayClient}_handleUpdateDataChannel(e,t){const{added:i,deleted:n}=e,r=[];Array.isArray(i)&&i.length>0&&i.forEach((e=>{const{uid:i,stream_id:n,ordered:s,max_retrans_times:o,metadata:a}=e,c=this._users.find((e=>e._uintid===i));if(!c)return void KC.error("[".concat(this._clientId,"] can not find target user!(on_add_data_channel)"));KC.debug("[".concat(this._clientId,"] data_channel added with uid ").concat(i)),Pr(r).call(r,c)||r.push(c),c._uintid||(c._uintid=i);if(!(-1!==c._dataChannels.findIndex((t=>t.id===e.stream_id)))){const e={id:n,ordered:!!s,maxRetransmits:o,metadata:a},i=new rD(e);c._dataChannels.push(i),KC.info("[".concat(this._clientId,"] remote user ").concat(c.uid," published datachannel")),t||this.safeEmit(dT.USER_PUBLISHED,c,"datachannel",e);}this._p2pChannel.hasPendingRemoteDataChannel(c,e.stream_id)&&(KC.debug("[".concat(this._clientId,"] resubscribe datachannel for user ").concat(c.uid," after reconnect.")),this._subscribeDataChannel(c,e.stream_id).catch((e=>{KC.error("[".concat(this._clientId,"] resubscribe datachannel error"),e.toString());})));})),t&&(this.safeEmit(dT.PUBLISHED_USER_LIST,this._pendingPublishedUsers),this._pendingPublishedUsers=[]),Array.isArray(n)&&n.length>0&&n.forEach((e=>{const{uid:t,stream_id:i}=e,n=this._users.find((e=>e._uintid===t));if(!n)return void KC.error("[".concat(this._clientId,"] can not find target user!(on_delete_data_channel)"));const r=n._dataChannels.find((t=>t.id===e.stream_id));r&&(KC.debug("[".concat(this._clientId,"] data_stream delete with uid ").concat(t)),this._p2pChannel.unsubscribeDataChannel(n,[r]).then((e=>{if(e)return n._dataChannels=n._dataChannels.filter((e=>e!==r)),this._gateway.unsubscribeDataChannel(e,n.uid)})),KC.info("[".concat(this._clientId,"] remote user ").concat(t," unpublished datachannel ,id:").concat(r.id)),this.safeEmit(dT.USER_UNPUBLISHED,n,"datachannel",r._config));}));}_handleRemoveDataChannels(e){const t=this._users.find((t=>t.uid===e.uid));if(t){if(void 0!==t._dataChannels&&t._dataChannels.length>0){KC.debug("[".concat(this._clientId,"] datachannel removed with uid ").concat(e.uid));const i=()=>{KC.info("[".concat(this._clientId,"] remote user ").concat(t.uid," unpublished datachannel")),t._dataChannels.forEach((e=>{this.safeEmit(dT.USER_UNPUBLISHED,t,"datachannel",e._config);}));};this._p2pChannel.unsubscribeDataChannel(t,t._dataChannels).then((e=>{if(e)return this._gateway.unsubscribeDataChannel(e,t.uid)})),i();}}else KC.warning("[".concat(this._clientId,"] can not find target user!(on_remove_datachannel)"));}_handleGatewayEvents(){this._gateway.on(eI.DISCONNECT_P2P,(async()=>{await this._p2pChannel.disconnectForReconnect();})),this._gateway.on(eI.CONNECTION_STATE_CHANGE,((e,t,i)=>{var n;if(i===cT.FALLBACK)return;const r=()=>{this.safeEmit(dT.CONNECTION_STATE_CHANGE,e,t,i);};if(rv.reportApiInvoke(this._sessionId||(null===(n=this._gateway.joinInfo)||void 0===n?void 0:n.sid)||null,{name:sT.CONNECTION_STATE_CHANGE,options:[e,t,i],tag:oT.TRACER}).onSuccess(JSON.stringify({cur:e,prev:t,reason:i})),KC.info("[".concat(this._clientId,"] connection state change: ").concat(t," -> ").concat(e)),"DISCONNECTED"===e)return this._reset(),void r();if("RECONNECTING"===e)this._users.forEach((e=>{e._trust_in_room_=!1,e._trust_audio_enabled_state_=!1,e._trust_video_enabled_state_=!1,e._trust_audio_mute_state_=!1,e._trust_video_mute_state_=!1,e._trust_audio_stream_added_state_=!1,e._trust_video_stream_added_state_=!1,e._audioSSRC=void 0,e._videoSSRC=void 0,e._videoOrtc=void 0,e._audioOrtc=void 0,e._cname=void 0,e._rtxSsrcId=void 0;})),this._userOfflineTimeout&&window.clearTimeout(this._userOfflineTimeout),this._streamRemovedTimeout&&window.clearTimeout(this._streamRemovedTimeout),this._userOfflineTimeout=void 0,this._streamRemovedTimeout=void 0;else if("CONNECTED"===e){var s;this._streamFallbackTypeCacheMap.forEach(((e,t)=>{this._gateway.setStreamFallbackOption(t,e).catch((e=>{KC.warning("[".concat(this._clientId,"] auto set stream fallback option failed"),e);}));})),this._remoteStreamTypeCacheMap.forEach(((e,t)=>{this._gateway.setRemoteVideoStreamType(t,e).catch((e=>{KC.warning("[".concat(this._clientId,"] auto set remote stream type failed"),e);}));})),void 0!==this._remoteDefaultVideoStreamType&&void 0===(null===(s=this._joinInfo)||void 0===s?void 0:s.defaultVideoStream)&&this.setRemoteDefaultVideoStreamType(this._remoteDefaultVideoStreamType).then((()=>{KC.debug("[".concat(this._clientId,"] setRemoteDefaultVideoStreamType after gateway connected"));})).catch((e=>{KC.error("[".concat(this._clientId,"] setRemoteDefaultVideoStreamType after gateway failed, ").concat(e));})),this.store.useP2P||(this._p2pChannel.republish(),this._userOfflineTimeout=window.setTimeout((()=>{if("CONNECTED"!==this.connectionState)return;this._userOfflineTimeout=void 0;this._users.filter((e=>!e._trust_in_room_)).forEach((e=>{KC.debug("[".concat(this._clientId,"] user offline timeout, emit user offline ").concat(e.uid)),this._handleUserOffline({uid:e.uid});}));}),3e3),this._streamRemovedTimeout=window.setTimeout((()=>{"CONNECTED"===this.connectionState&&(this._streamRemovedTimeout=void 0,this._users.forEach((e=>{e._trust_audio_mute_state_||(KC.debug("[".concat(this._clientId,"] auto dispatch audio unmute event ").concat(e.uid)),this._handleMuteStream(e.uid,hI.AUDIO,!1)),e._trust_video_mute_state_||(KC.debug("[".concat(this._clientId,"] auto dispatch video unmute event ").concat(e.uid)),this._handleMuteStream(e.uid,hI.VIDEO,!1)),e._trust_audio_enabled_state_||(KC.debug("[".concat(this._clientId,"] auto dispatch enable local audio ").concat(e.uid)),this._handleSetStreamLocalEnable("audio",e.uid,!0)),e._trust_video_enabled_state_||(KC.debug("[".concat(this._clientId,"] auto dispatch enable local video ").concat(e.uid)),this._handleSetStreamLocalEnable("video",e.uid,!0)),e._trust_video_stream_added_state_||(KC.debug("[".concat(this._clientId,"] auto dispatch reset video stream added ").concat(e.uid)),this._handleResetAddStream(e,"video")),e._trust_audio_stream_added_state_||(KC.debug("[".concat(this._clientId,"] auto dispatch reset audio stream added ").concat(e.uid)),this._handleResetAddStream(e,"audio")),e._video_added_||e._audio_added_||(KC.debug("[".concat(this._clientId,"] auto dispatch stream remove ").concat(e.uid)),this._handleRemoveStream({uid:e.uid,uint_id:e._uintid}));})));}),1e3));}r();})),this._gateway.on(eI.REQUEST_NEW_GATEWAY_LIST,((e,t)=>{if(!this._joinInfo)return t(new xv(xg.UNEXPECTED_ERROR,"can not recover, no join info"));dP(this._joinInfo,this._axiosCancelSource.token,this._config.httpRetryConfig||JT,this.store).then((t=>{this._joinInfo&&(this._joinInfo.apResponse=t.gatewayInfo.res,this._joinInfo.gatewayAddrs=t.gatewayInfo.gatewayAddrs,this._joinInfo.uni_lbs_ip=t.gatewayInfo.uni_lbs_ip);const i=[];t.gatewayInfo.gatewayAddrs.forEach((e=>{let{address:t}=e;const[n,r]=t.split(":");this._joinInfo&&this._joinInfo.proxyServer?i.push({proxy:this._joinInfo.proxyServer,host:n,port:r}):i.push({host:n,port:r});})),e(i);})).catch(t);})),this._gateway.on(eI.NETWORK_QUALITY,(e=>{"normal"===this._networkQualitySensitivity&&this.safeEmit(dT.NETWORK_QUALITY,e);})),this._gateway.on(eI.STREAM_TYPE_CHANGE,((e,t)=>{this.safeEmit(dT.STREAM_TYPE_CHANGED,e,t);rv.reportApiInvoke(this._sessionId,{name:sT.STREAM_TYPE_CHANGE,options:[e,t],tag:oT.TRACER}).onSuccess(JSON.stringify({uid:e,streamType:t}));})),this._gateway.on(eI.IS_P2P_DISCONNECTED,(e=>{this._p2pChannel.isP2PDisconnected()?e(!0):this._p2pChannel.hasLocalMedia()||this._p2pChannel.hasRemoteMedia()?e(!1):e(!0);})),this._gateway.on(eI.NEED_RENEW_SESSION,(()=>{this._startSession();})),this._gateway.on(eI.REQUEST_P2P_CONNECTION_PARAMS,(async(e,t,i)=>{try{t(await this._p2pChannel.startP2PConnection(e));}catch(e){i(e);}})),this._gateway.on(eI.JOIN_RESPONSE,((e,t)=>{if(this.store.useP2P)return;const{dtlsParameters:i,iceParameters:n,candidates:r,rtpCapabilities:s,setup:o,cname:a}=QP(e.ortc,t);this._p2pChannel.connect(n,i,r,s,o,a);})),this._gateway.on(eI.REQUEST_DC_CONNECTION_PARAMS,(e=>{e(this._p2pChannel.getEstablishParams());})),this._gateway.on(eI.RESET_SIGNAL,(e=>{this._p2pChannel.resetConnection(e),this._handleGatewaySignalEvents();})),this._gateway.on(eI.DATACHANNEL_FAILBACK,(()=>{this._joinGateway();})),this._gateway.on(eI.DATACHANNEL_PRECONNECT,(async(e,t,i,n)=>{var r,s,o,a,c,d;await this._p2pChannel.startP2PConnection({turnServer:null===(r=this._joinInfo)||void 0===r?void 0:r.turnServer},!0);const l=function(e,t){let i;return t&&t.ip&&"number"==typeof t.port?(i=[{foundation:"udpcandidate",componentId:"1",transport:"udp",priority:"2103266323",connectionAddress:t.ip,port:t.port.toString(),type:"host",extension:{}}],KC.debug("Using remote candidate from AP ".concat(t.ip,":").concat(t.port)),t.ip6&&(i.push({foundation:"udpcandidate",componentId:"1",transport:"udp",priority:"2103266323",connectionAddress:t.ip6,port:t.port.toString(),type:"host",extension:{}}),KC.debug("Using IPV6 remote candidate from AP ".concat(t.ip6,":").concat(t.port)))):i=[{foundation:"udpcandidate",componentId:"1",transport:"udp",priority:"2103266323",connectionAddress:e.ip,port:e.port.toString(),type:"host",extension:{}}],i}(e,t);return this._p2pChannel.preConnect({iceUfrag:"".concat(null===(s=this._joinInfo)||void 0===s?void 0:s.apResponse.cid,"_").concat(null===(o=this._joinInfo)||void 0===o?void 0:o.apResponse.cert),icePwd:"".concat(null===(a=this._joinInfo)||void 0===a?void 0:a.apResponse.cid,"_").concat(null===(c=this._joinInfo)||void 0===c?void 0:c.apResponse.cert)},{fingerprints:[{hashFunction:"sha-256",fingerprint:null!==(d=kC("FINGERPRINT"))&&void 0!==d?d:e.fingerprint}]},l,{send:{audioCodecs:[],videoCodecs:[],audioExtensions:[],videoExtensions:[]},recv:{audioCodecs:[],videoCodecs:[],audioExtensions:[],videoExtensions:[]}},"active","o/i14u9pJrxRKAsu").then(i).catch(n)}));}_handleGatewaySignalEvents(){this._gateway.signal.on(Rv.ON_USER_ONLINE,this._handleUserOnline),this._gateway.signal.on(Rv.ON_USER_OFFLINE,this._handleUserOffline),this._gateway.signal.on(Rv.ON_ADD_AUDIO_STREAM,(e=>this._handleAddAudioOrVideoStream("audio",e.uid,e.ssrcId,e.cname,e.uint_id,e.ortc))),this._gateway.signal.on(Rv.ON_ADD_VIDEO_STREAM,(e=>this._handleAddAudioOrVideoStream("video",e.uid,e.ssrcId,e.cname,e.uint_id,e.ortc,e.rtxSsrcId))),this._gateway.signal.on(Rv.ON_REMOTE_DATASTREAM_UPDATE,(e=>{this._handleUpdateDataChannel(e);})),this._gateway.signal.on(Rv.ON_REMOTE_FULL_DATASTREAM_INFO,(e=>{this._handleUpdateDataChannel({added:e.datastreams,deleted:[]},!0);})),this._gateway.signal.on(Rv.ON_REMOVE_STREAM,this._handleRemoveStream),this._gateway.signal.on(Rv.ON_P2P_LOST,this._handleP2PLost),this._gateway.signal.on(Rv.MUTE_AUDIO,(e=>this._handleMuteStream(e.uid,hI.AUDIO,!0))),this._gateway.signal.on(Rv.UNMUTE_AUDIO,(e=>this._handleMuteStream(e.uid,hI.AUDIO,!1))),this._gateway.signal.on(Rv.MUTE_VIDEO,(e=>this._handleMuteStream(e.uid,hI.VIDEO,!0))),this._gateway.signal.on(Rv.UNMUTE_VIDEO,(e=>this._handleMuteStream(e.uid,hI.VIDEO,!1))),this._gateway.signal.on(Rv.RECEIVE_METADATA,(e=>{const t=DT(e.metadata);this.safeEmit(dT.RECEIVE_METADATA,e.uid,t);})),this._gateway.signal.on(Rv.ON_DATA_STREAM,(async e=>{if(!e)return;let t=0;if(e.ordered||e.syncWithAudio){const i=this._p2pChannel.getStats(),n=this.remoteUsers.find((t=>t.uid===e.uid)),r=null==i?void 0:i.audioRecv.find((e=>e.ssrc===(null==n?void 0:n._audioSSRC)));t=null==r?void 0:r.jitterBufferMs;}null==t&&(t=0),GM(e,t,{id:this._clientId,onStreamMessage:"function"==typeof this.onStreamMessage?this.onStreamMessage.bind(this):void 0,safeEmit:this.safeEmit.bind(this)});})),this._gateway.signal.on(Rv.ON_CRYPT_ERROR,(()=>{NT((()=>{KC.warning("[".concat(this._clientId,"] on crypt error")),this.safeEmit(dT.CRYPT_ERROR);}),this._sessionId);})),this._gateway.signal.on(Rv.ON_TOKEN_PRIVILEGE_WILL_EXPIRE,this._handleTokenWillExpire),this._gateway.signal.on(Rv.ON_TOKEN_PRIVILEGE_DID_EXPIRE,(()=>{KC.warning("[".concat(this._clientId,"] received message onTokenPrivilegeDidExpire, please get new token and join again")),this._gateway.leave(!0,cT.TOKEN_EXPIRE),this.safeEmit(dT.ON_TOKEN_PRIVILEGE_DID_EXPIRE),this._reset();})),this._gateway.signal.on(Rv.ON_STREAM_FALLBACK_UPDATE,(e=>{KC.debug("[".concat(this._clientId,"] stream fallback peerId: ").concat(e.stream_id,", attr: ").concat(e.stream_type)),this.safeEmit(dT.STREAM_FALLBACK,e.stream_id,1===e.stream_type?"fallback":"recover");})),this._gateway.signal.on(Rv.ON_PUBLISH_STREAM,(e=>{this.uid===this._uid&&(this._p2pChannel.reportPublishEvent(!0,null,void 0,!1,JSON.stringify({proxy:e.proxy})),KC.info("[".concat(this._clientId,"] on publish stream, ").concat(JSON.stringify(e))));})),this._gateway.signal.on(Rv.ENABLE_LOCAL_VIDEO,(e=>{this._handleSetStreamLocalEnable("video",e.uid,!0);})),this._gateway.signal.on(Rv.DISABLE_LOCAL_VIDEO,(e=>{this._handleSetStreamLocalEnable("video",e.uid,!1);})),this._gateway.signal.on(gv.REQUEST_TIMEOUT,((e,t)=>{if(this._joinInfo)switch(e){case Tv.PUBLISH:{if(!t)return;const e=t.ortc;if(e){var i,n;const r=e.some((e=>{let{stream_type:t}=e;return t===$v.Audio})),s=e.some((e=>{let{stream_type:t}=e;return t!==$v.Audio})),o=e.some((e=>{let{stream_type:t}=e;return t===$v.Screen||t===$v.ScreenLow}));"offer"===t.state&&rv.publish(this._joinInfo.sid,{eventElapse:cD.measureFromPublishStart(this.store.clientId,this.store.pubId),succ:!1,ec:xg.TIMEOUT,audio:r,video:s,p2pid:t.p2p_id,publishRequestid:this.store.pubId,screenshare:o,audioName:r?null===(i=e.find((e=>{let{stream_type:t}=e;return t===$v.Audio})))||void 0===i||null===(i=i.ssrcs[0])||void 0===i?void 0:i.ssrcId.toString():void 0,videoName:s?null===(n=e.find((e=>{let{stream_type:t}=e;return t!==$v.Audio})))||void 0===n||null===(n=n.ssrcs[0])||void 0===n?void 0:n.ssrcId.toString():void 0});}break}case Tv.SUBSCRIBE:t&&rv.subscribe(this._joinInfo.sid,{succ:!1,ec:xg.TIMEOUT,audio:t.stream_type===hI.AUDIO,video:t.stream_type===hI.VIDEO,peerid:t.stream_id,subscribeRequestid:t.ssrcId,p2pid:this.store.p2pId,eventElapse:cD.measureFromSubscribeStart(this.store.clientId,t.ssrcId)});}})),this._gateway.signal.on(Rv.ON_P2P_OK,(e=>{this.uid,this._uid;})),this._gateway.signal.on(Rv.ON_PUBLISHED_USER_LIST,(e=>{if(null==e||!e.users)return;kC("BLOCK_LOCAL_CLIENT")&&(e.users=e.users.filter((e=>!dv(e.string_id||e.stream_id,this.channelName))));const t=[],i=[];for(const n of e.users){let e=this._users.find((e=>e._uintid===n.stream_id));e?e._trust_in_room_=!0:(e=new NP(n.string_id||n.stream_id,n.stream_id),this._users.push(e),0===this.getListeners(dT.PUBLISHED_USER_LIST).length&&(KC.debug("[".concat(this._clientId,"] user online"),n.stream_id),this.safeEmit(dT.USER_JOINED,e)));const r=iI.Audio&n.stream_type,s=(iI.Video|iI.LwoVideo)&n.stream_type,o=0!=(65280&n.stream_type),a=r&&e.hasAudio,c=s&&e.hasVideo;s&&(e._trust_video_stream_added_state_=!0,e._video_added_=!0,e._videoSSRC=n.video_ssrc,e._rtxSsrcId=n.video_rtx),r&&(e._trust_audio_stream_added_state_=!0,e._audio_added_=!0,e._audioSSRC=n.audio_ssrc),r&&!a&&0===this.getListeners(dT.PUBLISHED_USER_LIST).length&&(KC.info("[".concat(this._clientId,"] remote user ").concat(e.uid," published audio")),this.safeEmit(dT.USER_PUBLISHED,e,"audio")),s&&!c&&0===this.getListeners(dT.PUBLISHED_USER_LIST).length&&(KC.info("[".concat(this._clientId,"] remote user ").concat(e.uid," published video")),this.safeEmit(dT.USER_PUBLISHED,e,"video")),(r&&!a||s&&!c||o)&&t.push(e),s&&this._p2pChannel.hasPendingRemoteMedia(e,"video")&&i.push({user:e,mediaType:"video"}),r&&this._p2pChannel.hasPendingRemoteMedia(e,"audio")&&i.push({user:e,mediaType:"audio"});}i.length>0&&(KC.debug("[".concat(this._clientId,"] RE massSubscribe after reconnect ").concat(i.map((e=>"user: ".concat(e.user.uid,", mediaType: ").concat(e.mediaType))).join("; ")," ")),this.massSubscribe(i).catch((e=>{KC.error("[".concat(this._clientId,"] mass resubscribe error"),e.toString());}))),this.getListeners(dT.PUBLISHED_USER_LIST).length>0?kC("ENABLE_DATASTREAM_2")?this._pendingPublishedUsers=t:(KC.info("[".concat(this._clientId,"] client emit user-list event, users: ").concat(t.map((e=>e.uid)).join(", "))),this.safeEmit(dT.PUBLISHED_USER_LIST,t)):KC.info("[".concat(this._clientId,"] client not emit user-list event case there is no user-list listener, users: ").concat(t.map((e=>e.uid)).join(", ")));})),this._gateway.signal.on(Rv.ON_RTP_CAPABILITY_CHANGE,(e=>{const{video_codec:t}=e;this._p2pChannel instanceof _k&&this._p2pChannel.updateRemoteRTPCapabilities(t.map((e=>e.toLowerCase())).filter((e=>{var t;return Pr(t=Object.keys(UC)).call(t,e)})));}));}_handleP2PEvents(){this._gateway.signal.on(Rv.ON_USER_OFFLINE,(()=>{this._p2pChannel.disconnectForReconnect();})),this._gateway.signal.on(wI.PUBLISH,(async(e,t)=>{e.forEach((e=>e.kind===hI.VIDEO?(this._handleP2PAddAudioOrVideoStream("video",t),e.isMuted?this._handleMuteStream(t,hI.VIDEO,!0):this._handleMuteStream(t,hI.VIDEO,!1)):(this._handleP2PAddAudioOrVideoStream("audio",t),e.isMuted?this._handleMuteStream(t,hI.AUDIO,!0):this._handleMuteStream(t,hI.AUDIO,!1))));})),this._gateway.signal.on(gv.P2P_START,(async(e,t)=>{if(this._p2pChannel instanceof PM){var i;t(await this._p2pChannel.startP2P({turnServer:null===(i=this._joinInfo)||void 0===i?void 0:i.turnServer},e));}})),this._gateway.signal.on(gv.P2P_CONNECTION,(async e=>{this._p2pChannel instanceof PM&&await this._p2pChannel.p2pConnect(e);})),this._gateway.signal.on(gv.P2P_REMOTE_CANDIDATE_UPDATE,(e=>{this._p2pChannel instanceof PM&&this._p2pChannel.addRemoteCandidate(JSON.parse(e));})),this._gateway.signal.on(wI.SUBSCRIBE,(async(e,t,i)=>{if(this._p2pChannel instanceof PM){const{trackType:n}=JSON.parse(e);try{await this._p2pChannel.dopublish(n),t();}catch(e){i(e);}}})),this._gateway.signal.on(wI.UNSUBSCRIBE,(async(e,t,i)=>{if(this._p2pChannel instanceof PM){const{mediaType:n}=JSON.parse(e);try{await this._p2pChannel.doUnpublish(n),t();}catch(e){i(e);}}})),this._gateway.signal.on(wI.EXCHANGE_SDP,(async(e,t,i)=>{if(this._p2pChannel instanceof PM){const{type:n,sdp:r}=JSON.parse(e);try{t(await this._p2pChannel.setDescription(n,r));}catch(e){i(e);}}})),this._gateway.signal.on(wI.UNPUBLISH,(async(e,t,i)=>{if(this._p2pChannel instanceof PM){const{unpubMsg:n,uid:r}=e;if(1===n.length){const s=n[0].stream_type===$v.Audio?hI.AUDIO:hI.VIDEO;this._handleMuteStream(r,s,!0);const{sdp:o}=e;if(this._p2pChannel instanceof PM&&o){const e=this._users.find((e=>e.uid===r));if(!e)return KC.warning("[".concat(this._clientId,"] can not find remote user, ignore mute event, uid: ").concat(r)),void t();this._p2pChannel.unsubscribe(e,o,s).then((e=>{e&&t(e);})).catch(i);}else t();}else this._handleRemoveStream(e,t,i);}})),this._gateway.signal.on(wI.CONTROL,(async(e,t,i)=>{const{action:n,sdp:r,isMuteAll:s,uid:o}=e;switch(n){case OI.MUTE_LOCAL_VIDEO:this._handleMuteStream(o,hI.VIDEO,!0,r,t,i);break;case OI.MUTE_LOCAL_AUDIO:t(),this._handleMuteStream(o,hI.AUDIO,!0);break;case OI.UNMUTE_LOCAL_VIDEO:t(),this._handleP2PAddAudioOrVideoStream("video",o),this._handleMuteStream(o,hI.VIDEO,!1);break;case OI.UNMUTE_LOCAL_AUDIO:t(),this._handleP2PAddAudioOrVideoStream("audio",o),this._handleMuteStream(o,hI.AUDIO,!1);}s&&this._handleRemoveStream(e,t,i);})),this._gateway.signal.on(wI.DO_SUBSCRIBE,(async(e,t,i)=>{if(this._p2pChannel instanceof PM){const{kind:n,sdp:r,ssrcId:s,uid:o}=e,a=this._users.find((e=>e.uid===o));if(!a)return KC.error("[".concat(this._clientId,"] can not find target user!(on_add_stream)")),void t();try{t(await this._p2pChannel.subscribe(a,n,r,s));}catch(e){i(e);}}})),this._gateway.signal.on(wI.DO_UNSUBSCRIBE,(async(e,t,i)=>{if(this._p2pChannel instanceof PM){const{uid:n,kind:r,sdp:s}=e,o=this._users.find((e=>e.uid===n));if(!o)return KC.error("[".concat(this._clientId,"] can not find target user!(on_add_stream)")),void t();try{t(await this._p2pChannel.unsubscribe(o,s,r));}catch(e){i(e);}}})),this._gateway.signal.on(wI.RESTART_ICE,(async(e,t,i)=>{if(this._p2pChannel instanceof PM)try{t(await this._p2pChannel.setDescription("remote",e));}catch(e){i(e);}})),this._p2pChannel.on(mI.RequestP2PRestartICE,(async(e,t,i)=>{try{t(await this._gateway.sendExtensionMessage(wI.RESTART_ICE,e));}catch(e){i(e);}})),this._p2pChannel.on(mI.LocalCandidate,(e=>{this._gateway.sendExtensionMessage(wI.CANDIDATE,JSON.stringify(e));})),this._p2pChannel.on(mI.RequestP2PMuteLocal,(async(e,t,i)=>{try{t(await this._gateway.sendExtensionMessage(wI.CONTROL,e));}catch(e){i(e);}})),this._p2pChannel.on(mI.RequestP2PPublish,(async(e,t,i)=>{try{t(await this._gateway.sendExtensionMessage(wI.DO_SUBSCRIBE,e));}catch(e){i(e);}})),this._p2pChannel.on(mI.RequestP2PUnPublish,(async(e,t,i)=>{try{t(await this._gateway.sendExtensionMessage(wI.DO_UNSUBSCRIBE,e));}catch(e){i(e);}})),this._p2pChannel.on(mI.RequestP2PUnmuteRemote,(async(e,t,i)=>{if(this._joinInfo)try{await this._gateway.unmuteRemote(e,this._joinInfo.stringUid||this._joinInfo.uid),t();}catch(e){e.code===xg.DISCONNECT_P2P?t():i(e);}else t();})),this._p2pChannel.on(mI.RequestP2PMuteRemote,(async(e,t,i)=>{if(this._joinInfo)try{await this._gateway.muteRemote(e,this._joinInfo.stringUid||this._joinInfo.uid),t();}catch(e){e.code===xg.DISCONNECT_P2P?t():i(e);}else t();})),this._p2pChannel.on(mI.StateChange,((e,t)=>{t===EI.Connected&&this._p2pChannel.republish();}));}_handleP2PChannelEvents(){this._p2pChannel.on(mI.RequestMuteLocal,(async(e,t,i)=>{if(this._joinInfo)try{await this._gateway.muteLocal(e,this._joinInfo.stringUid||this._joinInfo.uid),t();}catch(e){e.code===xg.DISCONNECT_P2P?t():i(e);}else t();})),this._p2pChannel.on(mI.RequestUnmuteLocal,(async(e,t,i)=>{if(this._joinInfo)try{await this._gateway.unmuteLocal(e,this._joinInfo.stringUid||this._joinInfo.uid),t();}catch(e){e.code===xg.DISCONNECT_P2P?t():i(e);}else t();})),this._p2pChannel.on(mI.RequestRePublish,((e,t,i)=>{this.publish(e,!1).then(t).catch(i);})),this._p2pChannel.on(mI.RequestRePublishDataChannel,((e,t,i)=>{tg.all(e.map((async e=>{await this._p2pChannel.publishDataChannel([e]);const t={streamId:e.id,ordered:e.ordered,maxRetransmits:e.maxRetransmits,metadata:e.metadata,channelId:e._originDataChannelId};try{await this._gateway.publishDataChannel(this._uid,t,!0);}catch(e){if(e.code!==xg.DISCONNECT_P2P)throw e}}))).then(t).catch(i);})),this._p2pChannel.on(mI.RequestReSubscribe,(async(e,t,i)=>{try{for(const{user:t,kind:i}of e)i===hI.VIDEO?await this.subscribe(t,"video"):await this.subscribe(t,"audio");t();}catch(e){i(e);}})),this._p2pChannel.on(mI.RequestUploadStats,((e,t)=>{this._gateway.uploadStats(e,t);})),this._p2pChannel.on(mI.MediaReconnectStart,(e=>{this.safeEmit(dT.MEDIA_RECONNECT_START,e);})),this._p2pChannel.on(mI.MediaReconnectEnd,(e=>{this.safeEmit(dT.MEDIA_RECONNECT_END,e);})),this._p2pChannel.on(mI.NeedSignalRTT,(e=>{e(this._gateway.getSignalRTT());})),this._p2pChannel.on(mI.RequestRestartICE,(async e=>{if(this._p2pChannel instanceof PM)return;const t=await this._p2pChannel.restartICE(e),i=await t.next();if(i.done)return;const n=i.value;let r;try{r=await this._gateway.restartICE({iceParameters:n});}catch(e){return void t.throw(e)}const{iceParameters:s}=function(e){const t=e.iceParameters;return {iceParameters:{iceUfrag:t.iceUfrag,icePwd:t.icePwd}}}(r);await t.next({remoteIceParameters:s});})),this._p2pChannel.on(mI.RequestReconnect,(async()=>{this._gateway.reconnect();})),this._p2pChannel.on(mI.RequestReconnectPC,(async()=>{var e;const{iceParameters:t,dtlsParameters:i,rtpCapabilities:n}=await this._p2pChannel.startP2PConnection({turnServer:null===(e=this._joinInfo)||void 0===e?void 0:e.turnServer}),{gatewayEstablishParams:r,gatewayAddress:s}=await this._gateway.reconnectPC({iceParameters:t,dtlsParameters:i,rtpCapabilities:n}),{dtlsParameters:o,iceParameters:a,candidates:c,rtpCapabilities:d,setup:l,cname:h}=QP(r,s);await this._p2pChannel.connect(a,o,c,d,l,h),await this._p2pChannel.republish(),await this._p2pChannel.reSubscribe();})),this._p2pChannel.on(mI.RequestUnpublishForReconnectPC,(async(e,t,i)=>{this._joinInfo&&void 0!==this._uid?(await this._gateway.unpublish(e,this._uid),t()):i();})),this._p2pChannel.on(mI.P2PLost,(()=>{this.safeEmit(dT.P2P_LOST,this.store.uid);})),this._p2pChannel.on(mI.UpdateVideoEncoder,(e=>{e._encoderConfig&&this._gateway.setVideoProfile(e._encoderConfig);})),this._p2pChannel.on(mI.ConnectionTypeChange,(e=>{this.safeEmit(dT.IS_USING_CLOUD_PROXY,e);})),this._p2pChannel.on(mI.RequestLowStreamParameter,(e=>{e(this._lowStreamParameter||{width:160,height:120,framerate:15,bitrate:50});})),this._p2pChannel.on(mI.QueryClientConnectionState,(e=>{e(this.connectionState);}));}getKeyMetrics(){return this.store.keyMetrics}async enableContentInspect(e){if("CONNECTED"!==this.connectionState||!this._joinInfo)throw new xv(xg.INVALID_OPERATION,"[".concat(this._clientId,"] Client did not join channel"));if(this._inspect)throw new xv(xg.INVALID_OPERATION,"[".concat(this._clientId,"] Inspect content service already in connecting/connected state"));if(!e)throw new xv(xg.INVALID_PARAMS,"[".concat(this._clientId,"] inspectConfig is necessary"));if(!e.inspectType||!Array.isArray(e.inspectType))throw new xv(xg.INVALID_PARAMS,"[".concat(this._clientId,"] inspectConfig.inspectType is necessary and is an instance of Array."));{const t=[...new Set(e.inspectType)];t.forEach((e=>{var t;if(!Pr(t=["supervise","moderation"]).call(t,e))throw new xv(xg.INVALID_PARAMS,"[".concat(this._clientId,"] ").concat(e," is not a valid inspect type."))})),e.inspectType=t;}if(e&&e.extraInfo&&e.extraInfo.length>1024)throw new xv(xg.INVALID_PARAMS,"[".concat(this._clientId,"] inspectConfig.extraInfo length cannot exceed 1024 bytes"));try{const t=new Kk(e);this._inspect=t,this.handleVideoInspectEvents(this._inspect),await t.init({appId:this._joinInfo.appId,areaCode:"",cname:this._joinInfo.cname,sid:this._joinInfo.sid,token:this._joinInfo.token,uid:this._joinInfo.uid,cid:this._joinInfo.cid,vid:this._joinInfo.vid?Number(this._joinInfo.vid):0},JT);}catch(e){throw Array.isArray(e)?e[0]:e}}async disableContentInspect(){if(!this._inspect)throw new xv(xg.INVALID_OPERATION,"[".concat(this._clientId,"] inspectVideoContent not started"));try{this._inspect.close(),this._inspect=void 0;}catch(e){throw Array.isArray(e)?e[0]:e}}async setImageModeration(e,t){if(Fg(e,"enabled"),e){if(!t)throw new xv(xg.INVALID_PARAMS,"[".concat(this._clientId,"] config is necessary"));if(jg(t.interval,"interval",1e3,1/0),"CONNECTED"!==this.connectionState||!this._joinInfo)throw new xv(xg.INVALID_OPERATION,"[".concat(this._clientId,'] can not enable image moderation, not joined"'));try{if(this._moderation)return void this._moderation.updateConfig(t);const e=new IM(t);this._moderation=e,this.handleImageModerationEvents(this._moderation),await e.init({appId:this._joinInfo.appId,areaCode:"",cname:this._joinInfo.cname,sid:this._joinInfo.sid,token:this._joinInfo.token,uid:this._joinInfo.uid,cid:this._joinInfo.cid,vid:this._joinInfo.vid?Number(this._joinInfo.vid):0},JT);}catch(e){throw Array.isArray(e)?e[0]:e}}else {if(!this._moderation)throw new xv(xg.INVALID_OPERATION,"[".concat(this._clientId,"] image moderation not started"));try{this._moderation.close(),this._moderation.removeAllListeners(),this._moderation=void 0;}catch(e){throw Array.isArray(e)?e[0]:e}}}handleImageModerationEvents(e){e.on(AI.CONNECTION_STATE_CHANGE,((t,i)=>{if(this.safeEmit(dT.IMAGE_MODERATION_CONNECTION_STATE_CHANGE,t,i),t===yI.CONNECTED){if("CONNECTED"!==this.connectionState)throw this.setImageModeration(!1),new xv(xg.OPERATION_ABORTED,"Image moderation was cancelled because it left the channel");e.inspectImage();}})),e.on(AI.CLIENT_LOCAL_VIDEO_TRACK,(e=>{e(this.localTracks.filter((e=>"video"===e.trackMediaType))[0]);}));}handleVideoInspectEvents(e){e.on(SI.CONNECTION_STATE_CHANGE,((t,i)=>{if(this.safeEmit(dT.CONTENT_INSPECT_CONNECTION_STATE_CHANGE,t,i),i===gI.CONNECTED){if("CONNECTED"!==this.connectionState)return void this.safeEmit(dT.CONTENT_INSPECT_ERROR,new xv(xg.OPERATION_ABORTED,"Content inspect was cancelled because it left the channel"));e.inspectImage();}})),e.on(SI.INSPECT_RESULT,((e,t)=>{var i;if((null==t?void 0:t.code)===xg.INVALID_OPERATION&&"DISCONNECTED"===this.connectionState)return KC.debug("Stop inspect content because that has left channel"),null==this||null===(i=this._inspect)||void 0===i||i.close(),void(this._inspect=void 0);this.safeEmit(dT.CONTENT_INSPECT_RESULT,e,t);})),e.on(SI.CLIENT_LOCAL_VIDEO_TRACK,(e=>{e(this.localTracks.filter((e=>"video"===e.trackMediaType))[0]);}));}getJoinChannelServiceRecords(){return KC.debug("getJoinChannelServiceRecords"),this.store.joinChannelServiceRecords}async setPublishAudioFilterEnabled(e){Fg(e,"enabled"),LC("ENABLE_PUBLISH_AUDIO_FILTER",e),this._joinInfo&&await this._gateway.setPublishAudioFilterEnabled(e);}_handleResetAddStream(e,t){switch(t){case"audio":e._audio_added_=!1,e._trust_audio_stream_added_state_=!0;break;case"video":e._video_added_=!1,e._trust_video_stream_added_state_=!0;}}}Mv([nv(),Uv("design:type",Function),Uv("design:paramtypes",[]),Uv("design:returntype",tg)],qM.prototype,"leave",null),Mv([nv({argsMap:(e,t)=>{if(!Array.isArray(t)){if(!(t instanceof iA))return [t];t=[t];}return t.map((e=>e?Object(e).toString():"null"))}}),Uv("design:type",Function),Uv("design:paramtypes",[Object,Boolean]),Uv("design:returntype",tg)],qM.prototype,"publish",null),Mv([nv({argsMap:(e,t)=>(t||(t=[]),t instanceof sD?[t.getChannelId()]:(Array.isArray(t)||(t=[t]),t.map((e=>e.getTrackId()))))}),Uv("design:type",Function),Uv("design:paramtypes",[Object]),Uv("design:returntype",tg)],qM.prototype,"unpublish",null),Mv([nv({argsMap:(e,t,i,n)=>[t.uid,i,n]}),Uv("design:type",Function),Uv("design:paramtypes",[NP,String,Number]),Uv("design:returntype",tg)],qM.prototype,"subscribe",null),Mv([nv({argsMap:(e,t)=>t.map((e=>{let{user:t,mediaType:i}=e;return [null==t?void 0:t.uid,i]}))}),Uv("design:type",Function),Uv("design:paramtypes",[Array]),Uv("design:returntype",tg)],qM.prototype,"massSubscribe",null),Mv([nv({argsMap:(e,t,i,n)=>[t.uid,i,n]}),Uv("design:type",Function),Uv("design:paramtypes",[NP,String,Number]),Uv("design:returntype",tg)],qM.prototype,"unsubscribe",null),Mv([nv({argsMap:(e,t)=>t.map((e=>{let{user:t,mediaType:i}=e;return {uid:null==t?void 0:t.uid,mediaType:i}}))}),Uv("design:type",Function),Uv("design:paramtypes",[Array]),Uv("design:returntype",tg)],qM.prototype,"massUnsubscribe",null),Mv([nv(),Uv("design:type",Function),Uv("design:paramtypes",[Object]),Uv("design:returntype",tg)],qM.prototype,"setLowStreamParameter",null),Mv([nv(),Uv("design:type",Function),Uv("design:paramtypes",[]),Uv("design:returntype",tg)],qM.prototype,"enableDualStream",null),Mv([nv(),Uv("design:type",Function),Uv("design:paramtypes",[]),Uv("design:returntype",tg)],qM.prototype,"disableDualStream",null),Mv([nv(),Uv("design:type",Function),Uv("design:paramtypes",[String,Object]),Uv("design:returntype",tg)],qM.prototype,"setClientRole",null),Mv([nv(),Uv("design:type",Function),Uv("design:paramtypes",[String,Boolean]),Uv("design:returntype",void 0)],qM.prototype,"setProxyServer",null),Mv([nv(),Uv("design:type",Function),Uv("design:paramtypes",[Object,Boolean]),Uv("design:returntype",void 0)],qM.prototype,"setTurnServer",null),Mv([nv(),Uv("design:type",Function),Uv("design:paramtypes",[String]),Uv("design:returntype",void 0)],qM.prototype,"setLicense",null),Mv([nv(),Uv("design:type",Function),Uv("design:paramtypes",[Number]),Uv("design:returntype",void 0)],qM.prototype,"startProxyServer",null),Mv([nv(),Uv("design:type",Function),Uv("design:paramtypes",[]),Uv("design:returntype",void 0)],qM.prototype,"stopProxyServer",null),Mv([nv(),Uv("design:type",Function),Uv("design:paramtypes",[Object]),Uv("design:returntype",void 0)],qM.prototype,"setLocalAccessPointsV2",null),Mv([nv(),Uv("design:type",Function),Uv("design:paramtypes",[Array,String]),Uv("design:returntype",void 0)],qM.prototype,"setLocalAccessPoints",null),Mv([nv(),Uv("design:type",Function),Uv("design:paramtypes",[Number]),Uv("design:returntype",tg)],qM.prototype,"setRemoteDefaultVideoStreamType",null),Mv([nv(),Uv("design:type",Function),Uv("design:paramtypes",[Object,Number]),Uv("design:returntype",tg)],qM.prototype,"setRemoteVideoStreamType",null),Mv([nv(),Uv("design:type",Function),Uv("design:paramtypes",[Object,Number]),Uv("design:returntype",tg)],qM.prototype,"setStreamFallbackOption",null),Mv([nv({argsMap:(e,t)=>[t]}),Uv("design:type",Function),Uv("design:paramtypes",[String,String,Uint8Array]),Uv("design:returntype",void 0)],qM.prototype,"setEncryptionConfig",null),Mv([nv(),Uv("design:type",Function),Uv("design:paramtypes",[String]),Uv("design:returntype",tg)],qM.prototype,"renewToken",null),Mv([nv(),Uv("design:type",Function),Uv("design:paramtypes",[]),Uv("design:returntype",void 0)],qM.prototype,"enableAudioVolumeIndicator",null),Mv([nv(),Uv("design:type",Function),Uv("design:paramtypes",[String,Boolean]),Uv("design:returntype",tg)],qM.prototype,"startLiveStreaming",null),Mv([nv(),Uv("design:type",Function),Uv("design:paramtypes",[Object]),Uv("design:returntype",tg)],qM.prototype,"setLiveTranscoding",null),Mv([nv(),Uv("design:type",Function),Uv("design:paramtypes",[String]),Uv("design:returntype",tg)],qM.prototype,"stopLiveStreaming",null),Mv([nv(),Uv("design:type",Function),Uv("design:paramtypes",[String,Object]),Uv("design:returntype",tg)],qM.prototype,"addInjectStreamUrl",null),Mv([nv(),Uv("design:type",Function),Uv("design:paramtypes",[]),Uv("design:returntype",tg)],qM.prototype,"removeInjectStreamUrl",null),Mv([nv(),Uv("design:type",Function),Uv("design:paramtypes",[AP]),Uv("design:returntype",tg)],qM.prototype,"startChannelMediaRelay",null),Mv([nv(),Uv("design:type",Function),Uv("design:paramtypes",[AP]),Uv("design:returntype",tg)],qM.prototype,"updateChannelMediaRelay",null),Mv([nv(),Uv("design:type",Function),Uv("design:paramtypes",[]),Uv("design:returntype",tg)],qM.prototype,"stopChannelMediaRelay",null),Mv([nv({argsMap:(e,t)=>(Array.isArray(t)||(t=[t]),[JSON.stringify(t)])}),Uv("design:type",Function),Uv("design:paramtypes",[Object]),Uv("design:returntype",tg)],qM.prototype,"sendCustomReportMessage",null),Mv([nv(),Uv("design:type",Function),Uv("design:paramtypes",[Object,Object]),Uv("design:returntype",tg)],qM.prototype,"pickSVCLayer",null),Mv([nv(),Uv("design:type",Function),Uv("design:paramtypes",[Number]),Uv("design:returntype",tg)],qM.prototype,"setRTM2Flag",null),Mv([nv(),Uv("design:type",Function),Uv("design:paramtypes",[Object]),Uv("design:returntype",tg)],qM.prototype,"enableContentInspect",null),Mv([nv(),Uv("design:type",Function),Uv("design:paramtypes",[]),Uv("design:returntype",tg)],qM.prototype,"disableContentInspect",null),Mv([nv(),Uv("design:type",Function),Uv("design:paramtypes",[Boolean,Object]),Uv("design:returntype",tg)],qM.prototype,"setImageModeration",null),Mv([nv({reportResult:!0}),Uv("design:type",Function),Uv("design:paramtypes",[]),Uv("design:returntype",Array)],qM.prototype,"getJoinChannelServiceRecords",null),Mv([nv(),Uv("design:type",Function),Uv("design:paramtypes",[Boolean]),Uv("design:returntype",tg)],qM.prototype,"setPublishAudioFilterEnabled",null);class JM{constructor(e,t){nu(this,"id",0),nu(this,"element",void 0),nu(this,"peerPair",void 0),nu(this,"context",void 0),nu(this,"audioPlayerElement",void 0),nu(this,"audioTrack",void 0),JM.count+=1,this.id=JM.count,this.element=e,this.context=t;}initPeers(){this.peerPair=[new RTCPeerConnection,new RTCPeerConnection],this.peerPair[1].ontrack=e=>{const t=document.createElement("audio");t.srcObject=new MediaStream([e.track]),t.play(),this.audioPlayerElement=t;};}async switchSdp(){if(!this.peerPair)return;const e=async(e,t)=>{const i="offer"===t?await e.createOffer():await e.createAnswer();return await e.setLocalDescription(i),"complete"===e.iceGatheringState?e.localDescription:new tg((t=>{e.onicegatheringstatechange=()=>{"complete"===e.iceGatheringState&&t(e.localDescription);};}))},t=async(e,t)=>await e.setRemoteDescription(t);try{const i=await e(this.peerPair[0],"offer");await t(this.peerPair[1],i);const n=await e(this.peerPair[1],"answer");await t(this.peerPair[0],n);}catch(e){throw new xv(xg.LOCAL_AEC_ERROR,e.toString()).print()}}async getTracksFromMediaElement(e){if(this.audioTrack)return this.audioTrack;let t;try{e instanceof HTMLVideoElement&&(e.captureStream?e.captureStream():e.mozCaptureStream()),t=this.context.createMediaStreamDestination();this.context.createMediaElementSource(e).connect(t);}catch(e){throw new xv(xg.LOCAL_AEC_ERROR,e.toString()).print()}if(!t){throw new xv(xg.LOCAL_AEC_ERROR,"no dest node when local aec").print()}const i=t.stream.getAudioTracks()[0];return this.audioTrack=i,i}getElement(){return this.element}async startEchoCancellation(){this.context.resume(),this.peerPair&&this.close(),this.initPeers();const e=this.element,t=await this.getTracksFromMediaElement(e);this.peerPair&&this.peerPair[0].addTrack(t),await this.switchSdp();}close(){KC.debug("close echo cancellation unit, id is",this.id),this.audioPlayerElement&&this.audioPlayerElement.pause(),this.peerPair&&this.peerPair.forEach((e=>{e.close();})),this.peerPair=void 0,this.audioPlayerElement=void 0;}}nu(JM,"count",0);const zM=window.AudioContext||window.webkitAudioContext;class XM{constructor(){nu(this,"units",[]),nu(this,"context",void 0);}processExternalMediaAEC(e){if(!this._doesEnvironmentNeedAEC())return KC.debug("the system does not need to process local aec"),-1;this.context||(this.context=new zM);let t=this.units.find((t=>t&&t.getElement()===e));return t||(t=new JM(e,this.context),this.units.push(t)),t.startEchoCancellation(),KC.debug("start processing local audio echo cancellation, id is",t.id),t.id}_doesEnvironmentNeedAEC(){return pg().name!==cg.SAFARI}}Mv([nv({report:rv}),Uv("design:type",Function),Uv("design:paramtypes",[HTMLAudioElement]),Uv("design:returntype",Number)],XM.prototype,"processExternalMediaAEC",null);const QM=new XM;function ZM(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,n);}return i}function $M(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?ZM(Object(i),!0).forEach((function(t){nu(e,t,i[t]);})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):ZM(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t));}));}return e}const eU=window||document;function tU(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(!eU)return;const i=iU._cspEventHandlerPointer;if(i&&t)return void console.error(i,t);const n=e=>{if(!(e&&e.blockedURI&&(iU.onSecurityPolicyViolation||iU.getListeners(vI.SECURITY_POLICY_VIOLATION).length>0)))return;const t=e.blockedURI;kC("CSP_DETECTED_HOSTNAME_LIST").some((e=>Pr(t).call(t,e)))&&(iU.onSecurityPolicyViolation&&"function"==typeof iU.onSecurityPolicyViolation&&iU.onSecurityPolicyViolation(e),iU.getListeners(vI.SECURITY_POLICY_VIOLATION).length>0&&iU.safeEmit(vI.SECURITY_POLICY_VIOLATION,e));};i&&eU.removeEventListener("securitypolicyviolation",i),(t||e&&"function"==typeof e||iU.getListeners(vI.SECURITY_POLICY_VIOLATION).length>0)&&eU.addEventListener("securitypolicyviolation",n),iU._cspEventHandlerPointer=n;}LC("PROCESS_ID","process-".concat(xT(8,""),"-").concat(xT(4,""),"-").concat(xT(4,""),"-").concat(xT(4,""),"-").concat(xT(12,""))),function(){const e=pg();pA.getDisplayMedia=function(e){if(navigator.mediaDevices&&navigator.mediaDevices.getDisplayMedia)return !0;return !1}(),pA.getStreamFromExtension=e.name===cg.CHROME&&Number(e.version)>34,pA.supportUnifiedPlan=function(){if(!window.RTCRtpTransceiver)return !1;if(!("currentDirection"in RTCRtpTransceiver.prototype))return !1;const e=new RTCPeerConnection;let t=!1;try{e.addTransceiver("audio"),t=!0;}catch(e){}return e.close(),t}(),pA.supportMinBitrate=e.name===cg.CHROME||e.name===cg.EDGE,pA.supportSetRtpSenderParameters=function(){const e=pg();if(!window.RTCRtpSender||!window.RTCRtpSender.prototype.setParameters||!window.RTCRtpSender.prototype.getParameters)return !1;return !!kg()||(!(!Sg()&&!mg())||e.name===cg.FIREFOX&&Number(e.version)>=64)}(),e.name===cg.SAFARI&&(Number(e.version)>=14?pA.supportDualStream=!0:pA.supportDualStream=!1),pA.webAudioMediaStreamDest=function(){const e=pg();if(e.name===cg.SAFARI&&Number(e.version)<12)return !1;return !0}(),pA.supportReplaceTrack=function(){if(!window.RTCRtpSender)return !1;if("function"==typeof RTCRtpSender.prototype.replaceTrack)return !0;return !1}(),pA.supportWebGL="undefined"!=typeof WebGLRenderingContext,pA.supportRequestFrame=!!window.CanvasCaptureMediaStreamTrack,kg()||(pA.webAudioWithAEC=!0),pA.supportShareAudio=function(){const e=pg();if((e.os===ag.WIN_10||e.os===ag.WIN_81||e.os===ag.WIN_7||e.os===ag.LINUX||e.os===ag.MAC_OS)&&e.name===cg.CHROME&&Number(e.version)>=74)return !0;return !1}(),pA.supportDataChannel=function(){if(vg(76)||function(e){const t=pg();return !(t.name!==cg.FIREFOX||!t.osVersion)&&Number(t.version)>=e}(68)||function(e){const t=pg();return !(t.name!==cg.SAFARI||!t.osVersion)&&Number(t.version)>=e}(14))return !0;return !1}(),pA.supportPCSetConfiguration=function(){const e=window.RTCPeerConnection;return !Rg()&&!!e&&e.prototype.setConfiguration instanceof Function}(),pA.supportWebRTCEncodedTransform=function(){const e=pg();return "Chrome"===e.name&&Number(e.version)>=86}(),pA.supportWebRTCInsertableStream=function(){const e=pg();return (e.name===cg.CHROME||e.name===cg.EDGE)&&Number(e.version)>=94&&"MediaStreamTrackGenerator"in window&&"MediaStreamTrackProcessor"in window}(),AT((()=>{pA.supportDualStreamEncoding=function(){const e=pg();if(kC("DISABLE_WEBAUDIO"))return !0;return "Safari"===e.name&&Number(e.version)>=14||!!("Chrome"===e.name&&/Windows/i.test(e.os||"")&&Number(e.version)>=100&&kC("CHROME_DUAL_STREAM_USE_ENCODING"))}(),KC.info("browser compatibility",JSON.stringify(pA),JSON.stringify(e));}));}(),function(){let e;try{e=window.localStorage.getItem("websdk_ng_global_parameter");}catch(e){return void KC.error("Error loading sdk config",e.message)}if(e)try{const t=JSON.parse(window.atob(e)),i=Date.now();KC.debug("Loading global parameters from cache",t),Object.keys(t).forEach((e=>{if(Object.prototype.hasOwnProperty.call(PC,e)){const{value:n,expires:r}=t[e];if(r&&r<=i)return;MC[e]=n,PC[e]=n;}}));}catch(t){KC.error("Error loading mutableParamsCache: ".concat(e),t.message);}}(),Array.isArray(MC.AREAS)&&MC.AREAS.length>0&&qD(MC.AREAS,!0);const iU=function(e){const t=new iT,i=e,n={getListeners:t.getListeners.bind(t),on:(e,i)=>(function(e,t){e===vI.SECURITY_POLICY_VIOLATION&&tU(t,!0);}(e,i),t.on.bind(t)(e,i)),addListener:t.addListener.bind(t),once:t.once.bind(t),off:t.off.bind(t),removeAllListeners:t.removeAllListeners.bind(t),emit:t.emit.bind(t),safeEmit:t.safeEmit.bind(t)};return $M($M({},i),n)}({__TRACK_LIST__:Dy,VERSION:OC,BUILD:DC,ESM_BUNDLER:!1,ESM:!1,UMD:!0,DEV:!1,setParameter:(e,t,i)=>{KC.debug("setParameter key:".concat(e,", value:").concat(JSON.stringify(t))),LC(e,t,i);},getParameter:kC,getSupportedCodec:async function(){let e={audio:[],video:[]};try{let t=new RTCPeerConnection;t.addTransceiver("video",{direction:"recvonly"}),t.addTransceiver("audio",{direction:"recvonly"});const i=(await t.createOffer()).sdp;if(!i)return e;t.close(),t=null,e=function(e){const t={video:[],audio:[]};return e.match(/ VP8/i)&&t.video.push("VP8"),e.match(/ VP9/i)&&t.video.push("VP9"),e.match(/ AV1/i)&&t.video.push("AV1"),e.match(/ H264/i)&&t.video.push("H264"),e.match(/ H265/i)&&t.video.push("H265"),e.match(/ opus/i)&&t.audio.push("OPUS"),e.match(/ PCMU/i)&&t.audio.push("PCMU"),e.match(/ PCMA/i)&&t.audio.push("PCMA"),e.match(/ G722/i)&&t.audio.push("G722"),t}(i);}catch(e){throw new xv(xg.CREATE_OFFER_FAILED,e.toString&&e.toString()).print()}return e},checkSystemRequirements:function(){const e=rv.reportApiInvoke(null,{name:sT.CHECK_SYSTEM_REQUIREMENTS,options:[],tag:oT.TRACER});let t=!1;try{const e=window.RTCPeerConnection,i=navigator.mediaDevices&&navigator.mediaDevices.getUserMedia,n=window.WebSocket;t=!!(e&&i&&n);}catch(e){return KC.error("check system requirement failed: ",e),!1}let i=!1;const n=pg();n.name===cg.CHROME&&Number(n.version)>=58&&(!gg()||fg())&&(i=!0),n.name===cg.FIREFOX&&Number(n.version)>=56&&(i=!0),n.name===cg.OPERA&&Number(n.version)>=45&&(i=!0),n.name===cg.SAFARI&&Number(n.version)>=11&&(i=!0),(Pg()||pg().name===cg.QQ)&&(i=!0),KC.debug("checkSystemRequirements, api:",t,"browser",i);const r=t&&i;return e.onSuccess(r),r},getDevices:function(e){return OA.enumerateDevices(!0,!0,e)},getMicrophones:function(e){return OA.getRecordingDevices(e)},getCameras:function(e){return OA.getCamerasDevices(e)},getElectronScreenSources:SA,getPlaybackDevices:function(e){return OA.getSpeakers(e)},createClient:function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{codec:"vp8",audioCodec:"opus",mode:"rtc"};const t=rv.reportApiInvoke(null,{name:sT.CREATE_CLIENT,options:[e],tag:oT.TRACER});try{!function(e){Bg(e.codec,"config.codec",["vp8","vp9","av1","h264","h265"]),Bg(e.mode,"config.mode",["rtc","live"]),void 0!==e.audioCodec&&Bg(e.audioCodec,"config.audioCodec",["opus","pcmu","pcma","g722"]),void 0!==e.proxyServer&&Wg(e.proxyServer,"config.proxyServer",1,1e4),void 0!==e.turnServer&&ET(e.turnServer),void 0!==e.httpRetryConfig&&pT(e.httpRetryConfig),void 0!==e.websocketRetryConfig&&pT(e.websocketRetryConfig);}(e);}catch(e){throw t.onError(e),e}return HM()||("vp9"===e.codec&&(e.codec="vp8",KC.debug("browser not support vp9, force use vp8")),LC("UNSUPPORTED_VIDEO_CODEC",["vp9"])),void 0===e.audioCodec&&(e.audioCodec="opus"),t.onSuccess(),new qM(YM(YM({forceWaitGatewayResponse:!0},e),{},{role:"rtc"===e.mode?"host":e.role||"audience"}))},createCameraVideoTrack:async function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const t=rv.reportApiInvoke(null,{tag:oT.TRACER,name:sT.CREATE_CAM_VIDEO_TRACK,options:[vb({},e)]}),i=ib(e),n=xT(8,"track-cam-");let r=null;const s="720p_auto"===e.encoderConfig;KC.info("start create camera video track with config",JSON.stringify(e),"trackId",n);try{r=(await yA({video:i},n)).getVideoTracks()[0]||null;}catch(e){throw t.onError(e),e}if(!r){const e=new Vg(xg.UNEXPECTED_ERROR,"can not find track in media stream");return t.onError(e),e.throw(KC)}e.optimizationMode&&Ib(n,r,e,Ay(e.encoderConfig));const o=new Rb(r,e,i,e.scalabiltyMode?wy(e.scalabiltyMode):{numSpatialLayers:1,numTemporalLayers:1},e.optimizationMode,n);return s&&o.startMonitorStats(),t.onSuccess(o.getTrackId()),KC.info("create camera video success, trackId:",n),o},createCustomVideoTrack:function(e){const t=rv.reportApiInvoke(null,{tag:oT.TRACER,name:sT.CREATE_CUSTOM_VIDEO_TRACK,options:[e]}),i=new Sb(e.mediaStreamTrack,{width:e.width,height:e.height,frameRate:e.frameRate,bitrateMax:e.bitrateMax,bitrateMin:e.bitrateMin},e.scalabiltyMode?wy(e.scalabiltyMode):{numSpatialLayers:1,numTemporalLayers:1},e.optimizationMode,xT(8,"track-cus-"),[ky.CUSTOM_TRACK]);return t.onSuccess(i.getTrackId()),KC.info("create custom video track success with config",e,"trackId",i.getTrackId()),i},createScreenVideoTrack:async function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"disable";const i=rv.reportApiInvoke(null,{tag:oT.TRACER,name:sT.CREATE_SCREEN_VIDEO_TRACK,options:[vb({},e),t]}),n="720p_auto"===e.encoderConfig;e.encoderConfig?"string"==typeof e.encoderConfig||e.encoderConfig.width&&e.encoderConfig.height||(e.encoderConfig.width={max:1920},e.encoderConfig.height={max:1080}):e.encoderConfig="1080p_2";const r=function(e){const t={};e.screenSourceType&&(t.mediaSource=e.screenSourceType),e.extensionId&&Tg()&&(t.extensionId=e.extensionId);const{displaySurface:i,selfBrowserSurface:n,surfaceSwitching:r,systemAudio:s}=e;(vg(107)||Ig(107)||yg(93))&&(i&&(Bg(i,"displaySurface",["browser","window","monitor"]),t.displaySurface=i),n?(Bg(n,"selfBrowserSurface",["exclude","include"]),t.selfBrowserSurface=n):t.selfBrowserSurface="include",r&&(Bg(r,"surfaceSwitching",["exclude","include"]),t.surfaceSwitching=r)),(vg(105)||Ig(105)||yg(91))&&s&&(Bg(s,"systemAudio",["exclude","include"]),t.systemAudio=s),e.electronScreenSourceId&&(t.sourceId=e.electronScreenSourceId);const o=e.encoderConfig?by(e.encoderConfig):null;return t.mandatory={chromeMediaSource:"desktop",maxWidth:o?o.width:void 0,maxHeight:o?o.height:void 0},o&&(o.frameRate&&("number"==typeof o.frameRate?(t.mandatory.maxFrameRate=o.frameRate,t.mandatory.minFrameRate=o.frameRate):(t.mandatory.maxFrameRate=o.frameRate.max||o.frameRate.ideal||o.frameRate.exact||void 0,t.mandatory.minFrameRate=o.frameRate.min||o.frameRate.ideal||o.frameRate.exact||void 0),t.frameRate=o.frameRate),o.width&&(t.width=o.width),o.height&&(t.height=o.height)),t}(e),s=xT(8,"track-scr-v-");let o=null,a=null;const c=_A();if(!c.supportShareAudio&&"enable"===t){const e=new Vg(xg.NOT_SUPPORTED,"your browser or platform is not support share-screen with audio");return i.onError(e),e.throw(KC)}KC.info("start create screen video track with config",e,"withAudio",t,"trackId",s);try{const e=await yA({screen:r,screenAudio:"auto"===t?c.supportShareAudio:"enable"===t},s);o=e.getVideoTracks()[0]||null,a=e.getAudioTracks()[0]||null;}catch(e){throw i.onError(e),e}if(!o){const e=new Vg(xg.UNEXPECTED_ERROR,"can not find track in media stream");return i.onError(e),e.throw(KC)}if(!a&&"enable"===t){o&&o.stop();const e=new Vg(xg.SHARE_AUDIO_NOT_ALLOWED);return i.onError(e),e.throw(KC)}if(e.optimizationMode||(e.optimizationMode="detail"),e.optimizationMode){Ib(s,o,e,e.encoderConfig&&by(e.encoderConfig)||void 0),e.encoderConfig&&"string"!=typeof e.encoderConfig&&(e.encoderConfig.bitrateMin=e.encoderConfig.bitrateMax);}const d=new Sb(o,e.encoderConfig?by(e.encoderConfig):{},e.scalabiltyMode?wy(e.scalabiltyMode):{numSpatialLayers:1,numTemporalLayers:1},e.optimizationMode,s,[ky.SCREEN_TRACK]);if(n&&d.startMonitorStats(),!a)return i.onSuccess(d.getTrackId()),KC.info("create screen video track success","video:",d.getTrackId()),d;const l=new ZA(a,void 0,xT(8,"track-scr-a-"),!1,!0);return i.onSuccess([d.getTrackId(),l.getTrackId()]),KC.info("create screen video track success","video:",d.getTrackId(),"audio:",l.getTrackId()),[d,l]},createMicrophoneAndCameraTracks:async function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const i=rv.reportApiInvoke(null,{tag:oT.TRACER,name:sT.CREATE_MIC_AND_CAM_TRACKS,options:[e,t]}),n="720p_auto"===t.encoderConfig,r=ib(t),s=nb(e),o=xT(8,"track-mic-"),a=xT(8,"track-cam-");let c=null,d=null;KC.info("start create camera video track(".concat(a,") and microphone audio track(").concat(o,") with config, audio: ").concat(JSON.stringify(e),", video: ").concat(JSON.stringify(t)));try{const e=await yA({audio:s,video:r},"".concat(o,"-").concat(a));c=e.getAudioTracks()[0],d=e.getVideoTracks()[0];}catch(e){throw i.onError(e),e}if(!c||!d){const e=new Vg(xg.UNEXPECTED_ERROR,"can not find tracks in media stream");return i.onError(e),e.throw(KC)}t.optimizationMode&&Ib(a,d,t,Ay(t.encoderConfig));const l=new $A(c,e,s,o),h=new Rb(d,t,r,t.scalabiltyMode?wy(t.scalabiltyMode):{numSpatialLayers:1,numTemporalLayers:1},t.optimizationMode,a);return n&&h.startMonitorStats(),i.onSuccess([l.getTrackId(),h.getTrackId()]),KC.info("create camera video track(".concat(a,") and microphone audio track(").concat(o,") success")),[l,h]},createMicrophoneAudioTrack:async function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const t=rv.reportApiInvoke(null,{tag:oT.TRACER,name:sT.CREATE_MIC_AUDIO_TRACK,options:[e]}),i=nb(e),n=xT(8,"track-mic-");let r=null;KC.info("start create microphone audio track with config",JSON.stringify(e),"trackId",n);try{r=(await yA({audio:i},n)).getAudioTracks()[0]||null;}catch(e){throw t.onError(e),e}if(!r){const e=new Vg(xg.UNEXPECTED_ERROR,"can not find track in media stream");return t.onError(e),e.throw(KC)}const s=new $A(r,e,i,n);return t.onSuccess(s.getTrackId()),KC.info("create microphone audio track success, trackId:",n),s},createCustomAudioTrack:function(e){const t=rv.reportApiInvoke(null,{tag:oT.TRACER,name:sT.CREATE_CUSTOM_AUDIO_TRACK,options:[e]}),i=new ZA(e.mediaStreamTrack,e.encoderConfig?Ny(e.encoderConfig):{},xT(8,"track-cus-"),!1,!0);return KC.info("create custom audio track success with config",e,"trackId",i.getTrackId()),t.onSuccess(i.getTrackId()),i},createBufferSourceAudioTrack:async function(e){var t;const{cacheOnlineFile:i,encoderConfig:n}=e;let{source:r}=e;const s={source:r instanceof AudioBuffer?"AudioBuffer":r instanceof File?null!==(t=File.name)&&void 0!==t?t:"File":r,cacheOnlineFile:i,encoderConfig:n},o=rv.reportApiInvoke(null,{tag:oT.TRACER,name:sT.CREATE_BUFFER_AUDIO_TRACK,options:[s]});if(kC("DISABLE_WEBAUDIO"))throw new Vg(xg.NOT_SUPPORTED,"can not create BufferSourceAudioTrack when WebAudio disabled");const a=xT(8,"track-buf-");KC.info("start create buffer source audio track with config",JSON.stringify(s),"trackId",a);const c=r;if(!(r instanceof AudioBuffer))try{r=await ob(r,i);}catch(e){return o.onError(e),e.throw(KC)}const d=new rb(r),l=new eb(c,d,n?Ny(n):{},a);return KC.info("create buffer source audio track success, trackId:",a),o.onSuccess(l.getTrackId()),l},setAppType:function(e){if(KC.debug("setAppType: ".concat(e)),!(Number.isInteger(e)&&e>=0))throw KC.debug("Invalid appType"),new xv(xg.INVALID_PARAMS,"invalid app type",e);LC("APP_TYPE",Math.floor(e));},setLogLevel:function(e){KC.setLogLevel(e);},enableLogUpload:function(){kC("USE_NEW_LOG")?LC("UPLOAD_LOG",!0):KC.enableLogUpload();},disableLogUpload:function(){kC("USE_NEW_LOG")?LC("UPLOAD_LOG",!1):KC.disableLogUpload();},createChannelMediaRelayConfiguration:function(){return new AP},checkAudioTrackIsActive:async function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:5e3;const i=rv.reportApiInvoke(null,{tag:oT.TRACER,name:sT.CHECK_AUDIO_TRACK_IS_ACTIVE,options:[t]});if(!(e instanceof ZA||e instanceof Ob)){const e=new xv(xg.INVALID_TRACK,"the parameter is not a audio track");return i.onError(e),e.throw()}t&&t<1e3&&(t=1e3);const n=e instanceof ZA?e.getTrackLabel():"remote_track",r=e.getVolumeLevel();let s=r,o=r;const a=Date.now();return new tg((r=>{const c=setInterval((()=>{const d=e.getVolumeLevel();s=d>s?d:s,o=d<o?d:o;const l=s-o>1e-4,h=Date.now()-a;if(l||h>t){clearInterval(c);const t=l,o={duration:h,deviceLabel:n,maxVolumeLevel:s,result:t};KC.info("[track-".concat(e.getTrackId(),"] check audio track active completed. ").concat(JSON.stringify(o))),i.onSuccess(o),r(t);}}),200);}))},checkVideoTrackIsActive:async function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:5e3;const i=rv.reportApiInvoke(null,{tag:oT.TRACER,name:sT.CHECK_VIDEO_TRACK_IS_ACTIVE,options:[t]});if(!(e instanceof Sb||e instanceof wb)){const e=new xv(xg.INVALID_TRACK,"the parameter is not a video track");return i.onError(e),e.throw()}t&&t<1e3&&(t=1e3);const n=e instanceof Sb?e.getTrackLabel():"remote_track",r=e.getMediaStreamTrack(!0),s=document.createElement("video");s.style.width="1px",s.style.height="1px",s.setAttribute("muted",""),s.muted=!0,s.setAttribute("playsinline",""),s.controls=!1,(Sg()||mg())&&(s.style.opacity="0.01",s.style.position="fixed",s.style.left="0",s.style.top="0",document.body.appendChild(s)),s.srcObject=new MediaStream([r]),s.play();const o=document.createElement("canvas");o.width=160,o.height=120;let a=0,c=0;try{const e=Date.now();a=await function(e,t,i,n){let r,s=0,o=null;return new tg(((a,c)=>{function d(){s>n&&r&&(r(),a(s));const t=i.getContext("2d");if(!t){const e=new xv(xg.UNEXPECTED_ERROR,"can not get canvas 2d context.");return KC.error(e.toString()),void c(e)}t.drawImage(e,0,0,160,120);const d=t.getImageData(0,0,i.width,i.height),l=Math.floor(d.data.length/3);if(o){for(let e=0;e<l;e+=3)if(d.data[e]!==o[e])return s+=1,void(o=d.data);o=d.data;}else o=d.data;}setTimeout((()=>{r&&(r(),a(s));}),t),r=uA((()=>{d();}),30);}))}(s,t,o,4),c=Date.now()-e;}catch(e){throw i.onError(e),e}WM===cg.SAFARI&&(s.pause(),s.remove()),s.srcObject=null;const d=a>4,l={duration:c,changedPicNum:a,deviceLabel:n,result:d};return KC.info("[track-".concat(e.getTrackId(),"] check video track active completed. ").concat(JSON.stringify(l))),i.onSuccess(l),d},setArea:qD,audioElementPlayCenter:xA,processExternalMediaAEC:function(e){QM.processExternalMediaAEC(e);},registerExtensions:function(e){e.forEach((e=>{const t=e;t.__registered__=!0,t.logger.hookLog=KC.extLog,t.reporter.hookApiInvoke=rv.extApiInvoke,t.parameters&&Object.keys(t.parameters).forEach((e=>{t.parameters[e]=kC(e);}));}));},ChannelMediaRelayError:Zv,ChannelMediaRelayEvent:Xv,ChannelMediaRelayState:Qv,RemoteStreamFallbackType:xy,RemoteStreamType:Uy,ConnectionDisconnectedReason:cT,AudienceLatencyLevelType:aT,AREAS:rI});return Object.defineProperties(iU,{onAudioAutoplayFailed:{get:()=>DA.onAudioAutoplayFailed,set:e=>{DA.onAudioAutoplayFailed=e;}},onAutoplayFailed:{get:()=>DA.onAutoplayFailed,set:e=>{DA.onAutoplayFailed=e;}},_onSecurityPolicyViolation:{value:void 0,writable:!0},_cspEventHandlerPointer:{value:void 0,writable:!0},onSecurityPolicyViolation:{get:()=>iU._onSecurityPolicyViolation,set(e){iU._onSecurityPolicyViolation=e,tU(e);}},__CLIENT_LIST__:{get:()=>kC("SHOW_GLOBAL_CLIENT_LIST")?cv:[]}}),OA.on(Qy.CAMERA_DEVICE_CHANGED,(e=>{KC.info("camera device changed",JSON.stringify(e)),iU.onCameraChanged&&iU.onCameraChanged(e),iU.safeEmit(vI.CAMERA_CHANGED,e);})),OA.on(Qy.RECORDING_DEVICE_CHANGED,(e=>{KC.info("microphone device changed",JSON.stringify(e)),iU.onMicrophoneChanged&&iU.onMicrophoneChanged(e),iU.safeEmit(vI.MICROPHONE_CHANGED,e);})),OA.on(Qy.PLAYOUT_DEVICE_CHANGED,(e=>{KC.debug("playout device changed",JSON.stringify(e)),iU.onPlaybackDeviceChanged&&iU.onPlaybackDeviceChanged(e),iU.safeEmit(vI.PLAYBACK_DEVICE_CHANGED,e);})),xA.onAutoplayFailed=()=>{KC.info("detect audio element autoplay failed"),DA.onAudioAutoplayFailed&&DA.onAudioAutoplayFailed();},oA.on("autoplay-failed",(()=>{KC.info("detect webaudio autoplay failed"),DA.onAudioAutoplayFailed&&DA.onAudioAutoplayFailed(),iU.safeEmit(vI.AUTOPLAY_FAILED);})),RT.on(uT.NETWORK_STATE_CHANGE,((e,t)=>{KC.info("[network-indicator] network state changed, ".concat(t," => ").concat(e));})),window&&(window.__ARTC__=iU),iU}));
}(AgoraRTC_NProduction));

var AgoraRTC$1 = /*@__PURE__*/getDefaultExportFromCjs(AgoraRTC_NProduction.exports);const DevicePlatform = {
  Unknown: 'unknown',
  IOS: 'ios',
  Android: 'android',
  WindowsPhone: 'windowsPhone',
  VRHeadset: 'vrHeadset'
};
class DeviceService {
  static get platform() {
    if (!this.platform_) {
      this.platform_ = this.getDevicePlatform();
    }
    return this.platform_;
  }
  static get isIOS() {
    return ['iPad Simulator', 'iPhone Simulator', 'iPod Simulator', 'iPad', 'iPhone', 'iPod'].indexOf(navigator.platform) !== -1
    // iPad on iOS 13 detection
    || navigator.userAgent.indexOf('Mac') !== -1 && 'ontouchend' in document;
  }
  static get isVRHeadset() {
    return navigator.userAgent.indexOf('VR') !== -1 || navigator.userAgent.indexOf('Quest') !== -1 || navigator.userAgent.indexOf('Oculus') !== -1;
  }
  static getDevicePlatform() {
    const userAgent = navigator.userAgent || navigator.vendor || window.opera;
    // Windows Phone must come first because its UA also contains 'Android'
    if (/windows phone/i.test(userAgent)) {
      return DevicePlatform.WindowsPhone;
    }
    if (/android/i.test(userAgent)) {
      return DevicePlatform.Android;
    }
    // iOS detection from: http://stackoverflow.com/a/9039885/177710
    // if (/iPad|iPhone|iPod/.test(userAgent) && !window.MSStream) {
    if (this.isIOS) {
      return DevicePlatform.IOS;
    }
    if (this.isVRHeadset) {
      return DevicePlatform.VRHeadset;
    }
    return DevicePlatform.Unknown;
  }
}class Emittable$1 {
  constructor() {
    this.events = {};
  }
  on(type, callback) {
    const event = this.events[type] = this.events[type] || [];
    event.push(callback);
    return () => {
      this.events[type] = event.filter(x => x !== callback);
    };
  }
  off(type, callback) {
    const event = this.events[type];
    if (event) {
      this.events[type] = event.filter(x => x !== callback);
    }
  }
  once(type, callback) {
    const once = data => {
      callback(data);
      this.off(type, once);
    };
    this.on(type, once);
  }
  emit(type, data) {
    const event = this.events[type];
    if (event) {
      event.forEach(callback => {
        // callback.call(this, data);
        callback(data);
      });
    }
    const broadcast = this.events.broadcast;
    if (broadcast) {
      broadcast.forEach(callback => {
        callback(type, data);
      });
    }
  }
  has(type) {
    const callbacks = this.events[type];
    return callbacks && callbacks.length;
  }
}const LoggerLevel = {
  NONE: 0,
  ERROR: 1,
  WARN: 2,
  INFO: 3,
  LOG: 4,
  ALL: 5
};
class Logger {
  static setLevel(level) {
    this.level_ = level;
  }
  static getLevel() {
    if (environment.flags.production) {
      return LoggerLevel.ERROR;
    } else {
      return this.level_;
    }
  }
  static error() {
    if (this.getLevel() >= LoggerLevel.ERROR) {
      console.error(...arguments);
    }
  }
  static warn() {
    if (this.getLevel() >= LoggerLevel.WARN) {
      console.warn(...arguments);
    }
  }
  static info() {
    if (this.getLevel() >= LoggerLevel.INFO) {
      console.info(...arguments);
    }
  }
  static log() {
    if (this.getLevel() >= LoggerLevel.LOG) {
      console.log(...arguments);
    }
  }
}
Logger.level_ = LoggerLevel.ALL;class SessionStorageService {
  static delete(name) {
    if (this.isSessionStorageSupported()) {
      window.sessionStorage.removeItem(name);
    }
  }
  static exist(name) {
    if (this.isSessionStorageSupported()) {
      return window.sessionStorage[name] !== undefined;
    }
  }
  static get(name) {
    let value = null;
    if (this.isSessionStorageSupported() && window.sessionStorage[name] !== undefined) {
      try {
        value = JSON.parse(window.sessionStorage[name]);
      } catch (e) {
        console.log('SessionStorageService.get.error parsing', name, e);
      }
    }
    return value;
  }
  static set(name, value) {
    if (this.isSessionStorageSupported()) {
      try {
        const cache = [];
        const json = JSON.stringify(value, function (key, value) {
          if (typeof value === 'object' && value !== null) {
            if (cache.indexOf(value) !== -1) {
              // Circular reference found, discard key
              return;
            }
            cache.push(value);
          }
          return value;
        });
        window.sessionStorage.setItem(name, json);
      } catch (e) {
        console.log('SessionStorageService.set.error serializing', name, value, e);
      }
    }
  }
  static isSessionStorageSupported() {
    if (this.supported) {
      return true;
    }
    let supported = false;
    try {
      supported = 'sessionStorage' in window && window.sessionStorage !== null;
      if (supported) {
        window.sessionStorage.setItem('test', '1');
        window.sessionStorage.removeItem('test');
      } else {
        supported = false;
      }
    } catch (e) {
      supported = false;
    }
    this.supported = supported;
    return supported;
  }
}class Stream {
  /**
   *
   * @param {IAgoraRTCRemoteUser} user
   * @param {'audio' | 'video'} mediaType
   * @param {boolean} isLocal
   */
  constructor(user, mediaType, isLocal) {
    if (isLocal === void 0) {
      isLocal = false;
    }
    this.user = user;
    this.mediaType = mediaType;
    this.isLocal = isLocal;
    this.clientInfo = null;
    this.texture = null;
    this.element = null;
    this.parentNode = null;
  }
  get streamId() {
    return this.user?.uid.toString();
  }
  get hasScreen() {
    return this.user?.hasScreen;
  }
  get hasVideo() {
    return this.user?.hasVideo;
  }
  get hasAudio() {
    return this.user?.hasAudio;
  }
  get videoTrack() {
    return this.user?.videoTrack;
  }
  get audioTrack() {
    return this.user?.audioTrack;
  }

  /*
  get screenTrack() {
  	return this.user?.screenTrack;
  }
  */

  get video() {
    return this.videoTrack ? true : false;
  }
  get audio() {
    return this.audioTrack ? true : false;
  }

  /*
  get screen() {
  	return this.screenTrack ? true : false;
  }
  */

  get userMuteVideo() {
    // return this.videoTrack ? !this.videoTrack.enabled : false;
    return this.videoTrack ? this.videoTrack.muted : false;
  }
  get userMuteAudio() {
    // return this.audioTrack ? !this.audioTrack.enabled : false;
    return this.audioTrack ? this.audioTrack.muted : false;
  }
  getTracks() {
    const tracks = [];
    if (this.user.hasVideo) {
      tracks.push(this.videoTrack);
    }
    if (this.user.hasAudio) {
      tracks.push(this.audioTrack);
    }
    /*
    if (this.user.hasScreen) {
    	tracks.push(this.screenTrack);
    }
    */
    return tracks;
  }
  async muteVideo() {
    if (this.videoTrack) {
      // await this.videoTrack.setEnabled(true);
      await this.videoTrack.setMuted(true);
    }
  }
  async unmuteVideo() {
    if (this.videoTrack) {
      // await this.videoTrack.setEnabled(false);
      await this.videoTrack.setMuted(false);
    }
  }
  async muteAudio() {
    if (this.audioTrack) {
      // await this.audioTrack.setEnabled(true);
      await this.audioTrack.setMuted(true);
    }
  }
  async unmuteAudio() {
    if (this.audioTrack) {
      // await this.audioTrack.setEnabled(false);
      await this.audioTrack.setMuted(false);
    }
  }

  /*
  getIsSpeakingUser() {
  	return this.getAudioLevel() > 0.6 ? 1 : 0;
  }
  */

  getAudioLevel() {
    return this.audioTrack ? this.audioTrack.getVolumeLevel() : 0;
  }
  isPlaying() {
    return this.videoTrack?.isPlaying || this.audioTrack?.isPlaying; // || this.screenTrack?.isPlaying;
  }

  play(parentNode, mediaType) {
    if (mediaType === void 0) {
      mediaType = null;
    }
    mediaType = mediaType || this.mediaType;
    while (parentNode.childElementCount > 0) {
      parentNode.removeChild(parentNode.firstElementChild);
    }
    this.parentNode = parentNode;
    if (mediaType === 'video') {
      this.videoTrack.play(parentNode, {
        fit: 'cover',
        mirror: undefined
      });
      this.element = parentNode.firstElementChild;
      Logger.log('Stream.play.videoTrack', parentNode, this.element);
    } else if (this.audioTrack && !this.isLocal) {
      this.audioTrack.play();
    }
    /*
    else if (mediaType === 'screen') {
    	this.screenTrack.play(parentNode, {
    		fit: 'cover',
    		mirror: undefined,
    	});
    	this.element = parentNode.firstElementChild;
    	Logger.log('Stream.play.screenTrack', parentNode, this.element);
    }
    */
  }

  stop() {
    if (this.videoTrack && this.videoTrack.isPlaying) {
      this.videoTrack.stop();
    }
    if (this.audioTrack && this.audioTrack.isPlaying) {
      this.audioTrack.stop();
    }
    /*
    if (this.screenTrack && this.screenTrack.isPlaying) {
    	this.screenTrack.stop();
    }
    */
  }

  close() {
    if (this.videoTrack) {
      this.videoTrack.close();
    }
    if (this.audioTrack) {
      this.audioTrack.close();
    }
    /*
    if (this.screenTrack) {
    	this.screenTrack.close();
    }
    */
  }

  // !!! unused
  update(stream) {
    this.user = stream.user;
    this.mediaType = stream.mediaType;
    /*
    if (this.parentNode) {
    	this.play(this.parentNode);
    }
    */
  }

  resume(parentNode) {
    Logger.log('Stream.resume', parentNode, this.element);
    if (this.element) {
      parentNode.appendChild(this.element);
    }
  }
  published(user, mediaType) {
    this.user = user;
    this.mediaType = mediaType;
    if (this.parentNode) {
      this.play(this.parentNode, mediaType);
    }
  }
  unpublished(user, mediaType) {
    this.user = user;
    switch (mediaType) {
      case 'video':
        user.videoTrack?.stop();
        break;
      case 'audio':
        user.audioTrack?.stop();
        break;
      /*
      case 'screen':
      user.screenTrack?.stop();
      break;
      */
    }
  }
}const StreamServiceMode = {
  Client: 'client',
  Editor: 'editor'
};
class StreamService {
  static set editorStreams(editorStreams) {
    this.editorStreams$.next(editorStreams);
  }
  static get editorStreams() {
    return this.editorStreams$.getValue();
  }
  static set editorScreens(editorScreens) {
    this.editorScreens$.next(editorScreens);
  }
  static get editorScreens() {
    return this.editorScreens$.getValue();
  }

  /** @type {BehaviorSubject<Stream | null>} */

  static set local(local) {
    this.local$.next(local);
  }
  static get local() {
    return this.local$.getValue();
  }

  /** @type {BehaviorSubject<Stream | null>} */

  static set screen(screen) {
    this.screen$.next(screen);
  }
  static get screen() {
    return this.screen$.getValue();
  }

  /** @type {BehaviorSubject<Stream[]>} */

  static set remotes(remotes) {
    this.remotes$.next(remotes);
  }
  static get remotes() {
    return this.remotes$.getValue();
  }

  /** @type {BehaviorSubject<{ uid: string }[]>} */

  static set peers(peers) {
    this.peers$.next(peers);
  }
  static get peers() {
    return this.peers$.getValue();
  }
  static orderedRemotes$() {
    return rxjs.combineLatest([StreamService.remotes$, rxjs.interval(1000)]).pipe(operators.map(datas => {
      const orderedRemotes = [];
      const remotes = datas[0];
      remotes.forEach(remote => {
        let role = null,
          uid = null,
          screenUid = null,
          audioLevel = 0,
          peekAudioLevel = 0,
          order = 0;
        if (remote.clientInfo) {
          audioLevel = remote.clientInfo.audioLevel = remote.getAudioLevel();
          peekAudioLevel = remote.clientInfo.peekAudioLevel = Math.max(remote.clientInfo.audioLevel, 0.2);
          order = remote.clientInfo.order;
          role = remote.clientInfo.role || null;
          uid = remote.clientInfo.uid || null;
          screenUid = remote.clientInfo.screenUid || null;
        }
        orderedRemotes.push({
          role,
          uid,
          screenUid,
          audioLevel,
          peekAudioLevel,
          order,
          remote
        });
      });
      orderedRemotes.sort((a, b) => {
        const av = a.role === RoleType.Publisher ? 2 : a.role === RoleType.Attendee ? 1 : 0;
        const bv = b.role === RoleType.Publisher ? 2 : b.role === RoleType.Attendee ? 1 : 0;
        return bv - av || b.peekAudioLevel - a.peekAudioLevel || (a.order || 0) - (b.order || 0);
      });
      orderedRemotes.forEach((x, i) => {
        if (x.remote.clientInfo) {
          x.remote.clientInfo.order = i;
        }
      });
      return orderedRemotes;
    }), operators.distinctUntilChanged((a, b) => {
      const auid = a.map(x => `${x.uid}-${x.screenUid}`).join('|');
      const buid = b.map(x => `${x.uid}-${x.screenUid}`).join('|');
      // console.log('StreamService.orderedRemotes$', auid, buid);
      return auid === buid;
    }), operators.map(remotes => remotes.map(x => x.remote)));
  }
  static getEditorStreams$() {
    return rxjs.of(null).pipe(operators.switchMap(() => {
      if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia && this.mode === StreamServiceMode.Editor) {
        const body = document.querySelector('body');
        const media = document.createElement('div');
        const video = document.createElement('video');
        media.setAttribute('id', 'stream-editor');
        media.setAttribute('style', 'position:absolute; top: 5000px; line-height: 0;');
        media.appendChild(video);
        body.appendChild(media);
        navigator.mediaDevices.getUserMedia({
          video: {
            width: 800,
            height: 450
          }
        }).then(stream => {
          // console.log(stream);
          if ('srcObject' in video) {
            video.srcObject = stream;
          } else {
            video.src = window.URL.createObjectURL(stream);
          }
          video.oncanplay = () => {
            const fakePublisherStream = {
              streamId: 'editor',
              clientInfo: {
                role: RoleType.Publisher,
                uid: 'editor'
              }
            };
            const fakeAttendeeStream = {
              streamId: 'editor',
              clientInfo: {
                role: RoleType.Attendee,
                uid: 'editor'
              }
            };
            const fakeSmartDeviceStream = {
              streamId: 'editor',
              clientInfo: {
                role: RoleType.SmartDevice,
                uid: 'editor'
              }
            };
            this.editorStreams$.next([fakePublisherStream, fakeAttendeeStream, fakeAttendeeStream, fakeAttendeeStream, fakeAttendeeStream, fakeSmartDeviceStream]);
            // StreamService.editorStreams = [fakePublisherStream, fakeAttendeeStream, fakeAttendeeStream, fakeAttendeeStream, fakeAttendeeStream];
          };

          video.play();
        }).catch(error => {
          console.log('EditorComponent.getUserMedia.error', error.name, error.message);
        });
      }
      return this.editorStreams$;
    }), operators.shareReplay(1));
  }
  static getEditorScreens$() {
    return rxjs.of(null).pipe(operators.switchMap(() => {
      if (navigator.mediaDevices && navigator.mediaDevices.getDisplayMedia && this.mode === StreamServiceMode.Editor) {
        const body = document.querySelector('body');
        const media = document.createElement('div');
        const video = document.createElement('video');
        media.setAttribute('id', 'stream-editor-screen');
        media.setAttribute('style', 'position:absolute; top: 5000px; line-height: 0;');
        media.appendChild(video);
        body.appendChild(media);
        navigator.mediaDevices.getDisplayMedia({
          screen: {
            width: 800,
            height: 450
          }
        }).then(stream => {
          // console.log(stream);
          if ('srcObject' in video) {
            video.srcObject = stream;
          } else {
            video.src = window.URL.createObjectURL(stream);
          }
          video.oncanplay = () => {
            const fakePublisherScreen = {
              streamId: 'editor-screen',
              clientInfo: {
                role: RoleType.Publisher,
                uid: 'editor',
                screenUid: 'editor-screen'
              }
            };
            const fakeAttendeeScreen = {
              streamId: 'editor-screen',
              clientInfo: {
                role: RoleType.Attendee,
                uid: 'editor',
                screenUid: 'editor-screen'
              }
            };
            this.editorScreens$.next([fakePublisherScreen, fakeAttendeeScreen]);
          };
          video.play();
        }).catch(error => {
          console.log('EditorComponent.getUserMedia.error', error.name, error.message);
        });
      }
      return this.editorScreens$;
    }), operators.shareReplay(1));
  }
  static get publisherStreamId() {
    const streams = this.remotes.slice();
    const local = this.local;
    if (local) {
      streams.unshift(local);
    }
    const publisherStream = streams.find(x => x.clientInfo && x.clientInfo.role === RoleType.Publisher && x.clientInfo.uid === x.streamId);
    if (publisherStream) {
      return publisherStream.streamId;
    }
    return null;
  }
  static getPublisherStreamId$() {
    const publisherStreamId = this.publisherStreamId;
    if (publisherStreamId) {
      return rxjs.of(publisherStreamId);
    } else {
      return this.streams$.pipe(operators.map(() => this.publisherStreamId), operators.filter(x => x));
    }
  }
  static get attendeeStreamId() {
    const streams = this.remotes.slice();
    const local = this.local;
    if (local) {
      streams.unshift(local);
    }
    const attendeeStream = streams.find(x => x.clientInfo && x.clientInfo.role === RoleType.Attendee && x.clientInfo.uid === x.streamId);
    if (attendeeStream) {
      return attendeeStream.streamId;
    }
    return null;
  }
  static getAttendeeStreamId$() {
    const attendeeStreamId = this.attendeeStreamId;
    if (attendeeStreamId) {
      return rxjs.of(attendeeStreamId);
    } else {
      return this.streams$.pipe(operators.map(() => this.attendeeStreamId), operators.filter(x => x));
    }
  }
  static getRemoteById(streamId) {
    // console.log('StreamService.getRemoteById', streamId);
    const remotes = StreamService.remotes;
    const remote = remotes.find(x => x.streamId === streamId);
    if (remote) {
      return remote;
    }
  }
  static remoteAdd(stream) {
    const remotes = this.remotes.slice();
    const remote = remotes.find(x => x.streamId === stream.streamId);
    if (!remote) {
      remotes.push(stream);
      this.remotes = remotes;
    }
    /*
    if (remote) {
    	remote.update(stream);
    } else {
    	remotes.push(stream);
    }
    */
  }

  static remoteRemove(streamId) {
    const remotes = this.remotes.slice();
    const remote = remotes.find(x => x.streamId === streamId);
    // console.log('StreamService.remoteRemove', streamId, remote);
    if (remote) {
      remote.stop();
      remotes.splice(remotes.indexOf(remote), 1);
      this.remotes = remotes;
    }
    return remote;
  }
  static remoteSetClientInfo(remoteId, clientInfo) {
    const remotes = this.remotes;
    const remote = remotes.find(x => x.streamId === remoteId);
    if (remote) {
      remote.clientInfo = clientInfo;
    }
    this.remotes = remotes;
  }
}
StreamService.mode = StreamServiceMode.Client;
StreamService.editorStreams$ = new rxjs.BehaviorSubject(null);
StreamService.editorScreens$ = new rxjs.BehaviorSubject(null);
StreamService.local$ = new rxjs.BehaviorSubject(null);
StreamService.screen$ = new rxjs.BehaviorSubject(null);
StreamService.remotes$ = new rxjs.BehaviorSubject([]);
StreamService.peers$ = new rxjs.BehaviorSubject([]);
StreamService.streams$ = rxjs.combineLatest([StreamService.local$, StreamService.screen$, StreamService.remotes$, StreamService.getEditorStreams$(), StreamService.getEditorScreens$()]).pipe(operators.map(data => {
  const local = data[0];
  const screen = data[1];
  const remotes = data[2];
  const editorStreams = data[3];
  const editorScreens = data[4];
  let streams = remotes;
  if (local) {
    // my stream
    streams = streams.slice();
    streams.push(local);
  }
  if (screen) {
    // my screen
    streams = streams.slice();
    streams.push(screen);
  }
  if (editorStreams) {
    // editor streams
    streams.push(...editorStreams);
  }
  if (editorScreens) {
    // editor screens
    streams.push(...editorScreens);
  }
  return streams;
}), operators.shareReplay(1));class AgoraService extends Emittable$1 {
  constructor(defaultDevices) {
    if (AgoraService.AGORA) {
      throw 'AgoraService is a singleton';
    }
    super();
    this.previousMuteAudio_ = false;
    this.channelState = {};
    this.channelSnapshot = {};
    this.onException = this.onException.bind(this);
    this.onUserJoined = this.onUserJoined.bind(this);
    this.onUserLeft = this.onUserLeft.bind(this);
    this.onUserPublished = this.onUserPublished.bind(this);
    this.onUserUnpublished = this.onUserUnpublished.bind(this);
    this.onUserInfoUpdated = this.onUserInfoUpdated.bind(this);
    /*
    this.onStreamAdded = this.onStreamAdded.bind(this);
    this.onStreamRemoved = this.onStreamRemoved.bind(this);
    this.onStreamSubscribed = this.onStreamSubscribed.bind(this);
    this.onMuteVideo = this.onMuteVideo.bind(this);
    this.onUnmuteVideo = this.onUnmuteVideo.bind(this);
    this.onMuteAudio = this.onMuteAudio.bind(this);
    this.onUnmuteAudio = this.onUnmuteAudio.bind(this);
    */
    this.onVolumeIndicator = this.onVolumeIndicator.bind(this);
    this.onConnectionStateChange = this.onConnectionStateChange.bind(this);
    this.onTokenPrivilegeWillExpire = this.onTokenPrivilegeWillExpire.bind(this);
    this.onTokenPrivilegeDidExpire = this.onTokenPrivilegeDidExpire.bind(this);
    this.onMessage = this.onMessage.bind(this);
    const state = StateService.state;
    StateService.patchState({
      devices: state.role !== RoleType.Attendee && defaultDevices ? defaultDevices : {
        videos: [],
        audios: []
      },
      quality: getStreamQuality(state),
      membersCount: 0
    });
  }
  get isHostRole() {
    return StateService.state.role === RoleType.Publisher || StateService.state.role === RoleType.Attendee;
  }
  get isAudienceRole() {
    return StateService.state.role === RoleType.Viewer || StateService.state.role === RoleType.SelfService;
  }
  addStreamDevice(src) {
    this.removeStreamDevice();
    const video = {
      deviceId: 'video-stream',
      label: 'videostream',
      kind: 'videostream',
      src: src
    };
    const audio = {
      deviceId: 'audio-stream',
      label: 'videostream',
      kind: 'videostream',
      src: src
    };
    const devices = StateService.state.devices;
    devices.videos.push(video);
    devices.audios.push(audio);
    StateService.patchState({
      devices: devices
    });
  }
  removeStreamDevice() {
    const devices = StateService.state.devices;
    devices.videos = devices.videos.filter(x => x.kind !== 'videostream');
    devices.audios = devices.audios.filter(x => x.kind !== 'videostream');
    StateService.patchState({
      devices: devices
    });
  }
  devices$() {
    const inputs = StateService.state.devices;
    const defaultVideos = this.defaultVideos = this.defaultVideos || inputs.videos.slice();
    const defaultAudios = this.defaultAudios = this.defaultAudios || inputs.videos.slice();
    inputs.videos = defaultVideos.slice();
    inputs.audios = defaultAudios.slice();
    const devices = async () => {
      const videoTrack = await AgoraRTC$1.createCameraVideoTrack();
      const audioTrack = await AgoraRTC$1.createMicrophoneAudioTrack();
      const devices = await AgoraService.getDevices();
      // Logger.log('AgoraService.devices$.getDevices', devices);
      videoTrack.close();
      audioTrack.close();
      for (let i = 0; i < devices.length; i++) {
        const device = devices[i];
        // Logger.log('AgoraService.devices$', device.deviceId);
        if (device.kind === 'videoinput' && device.deviceId) {
          inputs.videos.push({
            label: device.label || 'camera-' + inputs.videos.length,
            deviceId: device.deviceId,
            kind: device.kind
          });
        }
        if (device.kind === 'audioinput' && device.deviceId) {
          inputs.audios.push({
            label: device.label || 'microphone-' + inputs.audios.length,
            deviceId: device.deviceId,
            kind: device.kind
          });
        }
      }
      if (inputs.videos.length > 0 || inputs.audios.length > 0) {
        return inputs;
      } else {
        throw inputs;
      }
    };
    return rxjs.from(devices());
  }

  // 1. connect
  async connect(preferences) {
    if (!StateService.state.connecting) {
      const devices = StateService.state.devices;
      if (preferences) {
        devices.video = preferences.video;
        devices.audio = preferences.audio;
      }
      // Logger.log('AgoraService.connect', preferences, devices);
      StateService.patchState({
        status: AgoraStatus.Connecting,
        connecting: true,
        devices
      });
      setTimeout(async () => {
        await this.createClient();
        const channelNameLink = this.getChannelNameLink();
        await this.join(channelNameLink);
      }, 250);
    }
    return StateService.state$;
  }
  connect$(preferences) {
    return rxjs.from(this.connect(preferences)).pipe(operators.switchMap(() => StateService.state$));
  }
  membersCount$(channelId) {
    const messageClient = this.messageClient;
    return rxjs.interval(3000).pipe(operators.switchMap(() => rxjs.from(messageClient.getChannelMemberCount([channelId]))), operators.map(counters => counters[channelId]), operators.catchError(error => {
      Logger.error('AgoraService.membersCount$.error', error);
      return rxjs.of(0);
    }), operators.distinctUntilChanged());
  }
  observeMemberCount() {
    this.unobserveMemberCount();
    // !!! perf
    // only host roles collect membersCount to reduce call/sec.
    if (this.isHostRole) {
      this.membersCountSubscription = this.membersCount$(StateService.state.channelNameLink).subscribe(membersCount => {
        StateService.patchState({
          membersCount: membersCount
        });
      });
    }
  }
  unobserveMemberCount() {
    if (this.membersCountSubscription) {
      this.membersCountSubscription.unsubscribe();
      this.membersCountSubscription = null;
      StateService.patchState({
        membersCount: 0
      });
    }
  }

  // 2. rtc client
  async createClient() {
    if (this.client) {
      return this.client;
    }
    try {
      /*
      0: DEBUG. Output all API logs.
      1: INFO. Output logs of the INFO, WARNING and ERROR level.
      2: WARNING. Output logs of the WARNING and ERROR level.
      3: ERROR. Output logs of the ERROR level.
      4: NONE. Do not output any log.
      */
      AgoraRTC$1.setLogLevel(2);
      const client = this.client = AgoraRTC$1.createClient({
        mode: 'live',
        codec: 'h264'
      }); // rtc, vp8
      client.on('exception', this.onException);
      client.on('user-joined', this.onUserJoined);
      client.on('user-left', this.onUserLeft);
      client.on('user-published', this.onUserPublished);
      client.on('user-unpublished', this.onUserUnpublished);
      client.on('user-info-updated', this.onUserInfoUpdated);
      /*
      client.on('stream-added', this.onStreamAdded);
      client.on('stream-removed', this.onStreamRemoved);
      client.on('stream-subscribed', this.onStreamSubscribed);
      client.on('mute-video', this.onMuteVideo);
      client.on('unmute-video', this.onUnmuteVideo);
      client.on('mute-audio', this.onMuteAudio);
      client.on('unmute-audio', this.onUnmuteAudio);
      */
      if (USE_VOLUME_INDICATOR) ;
      // client.on('connection-state-change', this.onConnectionStateChange);
      client.on('onTokenPrivilegeWillExpire', this.onTokenPrivilegeWillExpire);
      client.on('onTokenPrivilegeDidExpire', this.onTokenPrivilegeDidExpire);
      // Logger.log('AgoraService.createClient', 'agora rtm sdk version: ' + AgoraRTM.VERSION + ' compatible');
      /*
      AgoraRTM.LOG_FILTER_OFF
      AgoraRTM.LOG_FILTER_ERROR
      AgoraRTM.LOG_FILTER_INFO (Default)
      AgoraRTM.LOG_FILTER_WARNING
      */
      const messageClient = this.messageClient = AgoraRTM.createInstance(environment.appKey, {
        logFilter: AgoraRTM.LOG_FILTER_OFF
      }); // LOG_FILTER_DEBUG
      messageClient.setParameters({
        logFilter: AgoraRTM.LOG_FILTER_OFF
      });
      Logger.log('AgoraService.createClient', 'client initialized');
      // messageClient.on('ConnectionStateChanged', Logger.warn);
      // messageClient.on('MessageFromPeer', Logger.log);
      await client.setClientRole(this.isAudienceRole ? 'audience' : 'host'); // 'audience' | 'host', AUDIENCE_LEVEL_LOW_LATENCY = 1
      if (environment.flags.useProxy) {
        client.startProxyServer(3);
        /*
        3: The cloud proxy for the UDP protocol, that is, the Force UDP cloud proxy mode. In this mode, the SDK always transmits data over UDP.
        5: The cloud proxy for the TCP (encryption) protocol, that is, the Force TCP cloud proxy mode. In this mode, the SDK always transmits data over TLS 443.
        Note: As of v4.15.0, the default value of mode is 3.
        */
        Logger.log('AgoraService.createClient.startProxyServer');
      }
    } catch (error) {
      Logger.error('AgoraService.createClient.error', error);
      this.client = null;
    }
    return this.client;
  }

  // 3. channelName
  getChannelNameLink() {
    let link = StateService.state.link || '';
    const match = link.match(/(\d{9})-(\d{4})-(\d{13})/);
    if (match) {
      link = `${match[1]}-${match[3]}`;
    }
    const channelName = StateService.state.channelName;
    const channelNameLink = `${channelName}-${link}`;
    // Logger.log('AgoraService.getChannelNameLink', channelNameLink);
    return channelNameLink;
  }

  // 4. join
  async join(channelNameLink) {
    this.channel = null;
    const uid = AgoraService.resolveUserId();
    const rtmToken = await AgoraService.rtmToken$(uid).toPromise();
    // Logger.log('AgoraService.join.rtmToken$', rtmToken);
    try {
      await this.joinRtmChannel(rtmToken.token, channelNameLink, uid);
      const rtcToken = await AgoraService.rtcToken$(channelNameLink).toPromise();
      // Logger.log('AgoraService.rtcToken$', rtcToken);
      await this.joinRtcChannel(rtcToken.token, channelNameLink, uid);
    } catch (error) {
      Logger.error('AgoraService.join.joinRtmChannel.error', error);
    }
  }

  // 5. join rtc
  async joinRtcChannel(token, channelNameLink, uid) {
    try {
      Logger.log('AgoraService.joinRtcChannel', token, channelNameLink, uid);
      await this.client.join(environment.appKey, channelNameLink, token, uid);
      StateService.patchState({
        status: AgoraStatus.Connected,
        channelNameLink,
        connected: true,
        uid: uid
      });
      AgoraService.storeUserId(uid);
      if (!this.isAudienceRole) {
        const devices = await this.autoDetectDevice();
        await this.createMediaStream(uid, devices.video, devices.audio);
      }
      this.observeMemberCount();
    } catch (error) {
      Logger.error('AgoraService.joinRtcChannel.error', error);
      if (error === 'DYNAMIC_KEY_EXPIRED') {
        const rtcToken = await AgoraService.rtcToken$(channelNameLink).toPromise();
        await this.joinRtcChannel(rtcToken.token, channelNameLink, uid);
      }
    }
  }

  // 5. join rtm
  joinRtmChannel(token, channelNameLink, uid) {
    Logger.log('AgoraService.joinRtmChannel', token, channelNameLink, uid);
    let channel;
    return new Promise((resolve, reject) => {
      const messageClient = this.messageClient;
      messageClient.login({
        token,
        uid
      }).then(() => {
        Logger.log('AgoraService.joinRtmChannel.login.success');
        channel = messageClient.createChannel(channelNameLink);
        return channel.join();
      }).then(() => {
        this.channel = channel;
        channel.on('ChannelMessage', this.onMessage);
        this.emit('channel', channel);
        // Logger.log('AgoraService.joinRtmChannel.success');
        resolve(uid);
        Logger.log('AgoraService.joinRtmChannel.join.success');
        channel.getMembers().then(members => {
          members = members.filter(x => x !== uid);
          const message = {
            type: MessageType.ChannelMembers,
            members
          };
          this.broadcastMessage(message);
          Logger.log('AgoraService.joinRtmChannel.members', message);
        });
        Logger.log('AgoraService.joinRtmChannel.success', channelNameLink);
      }).catch(error => {
        Logger.error('AgoraService.joinRtmChannel.error', error);
        reject(error);
      });
    });
  }
  detectDevices(next) {
    AgoraService.getDevices().then(devices => {
      const videos = [];
      const audios = [];
      for (let i = 0; i < devices.length; i++) {
        const device = devices[i];
        if ('videoinput' == device.kind) {
          videos.push({
            label: device.label || 'camera-' + videos.length,
            deviceId: device.deviceId,
            kind: device.kind
          });
        }
        if ('audioinput' == device.kind) {
          audios.push({
            label: device.label || 'microphone-' + videos.length,
            deviceId: device.deviceId,
            kind: device.kind
          });
        }
      }
      next({
        videos: videos,
        audios: audios
      });
    }).catch(error => {
      Logger.error('AgoraService.detectDevices', error);
    });
  }
  getVideoOptions(options, video) {
    return new Promise((resolve, reject) => {
      if (video) {
        if (video.kind === 'videostream') {
          const element = document.querySelector('#' + video.deviceId);
          element.crossOrigin = 'anonymous';
          var hls = new Hls();
          hls.attachMedia(element);
          hls.on(Hls.Events.MEDIA_ATTACHED, () => {
            hls.loadSource(video.src);
            hls.on(Hls.Events.MANIFEST_PARSED, (event, data) => {
              // Logger.log('AgoraService.getVideoOptions.hls', data.levels);
              element.play().then(success => {
                const stream = element.captureStream();
                options.videoSource = stream.getVideoTracks()[0];
                // Logger.log('AgoraService.getVideoOptions', element, stream, stream.getVideoTracks());
                resolve(options);
              }, error => {
                Logger.error('AgoraService.getVideoOptions.error', error);
              });
            });
          });
        } else if (video.kind === 'videoplayer' || video.kind === 'videostream') {
          const element = document.querySelector('#' + video.deviceId);
          element.crossOrigin = 'anonymous';
          // element.oncanplay = () => {
          const stream = element.captureStream();
          options.videoSource = stream.getVideoTracks()[0];
          // Logger.log('getVideoOptions', element, stream, stream.getVideoTracks());
          resolve(options);
          // };
          /*
          element.play().then(success => {
          	const stream = element.captureStream();
          	options.videoSource = stream.getVideoTracks()[0];
          	// Logger.log('getVideoOptions', element, stream, stream.getVideoTracks());
          	resolve(options);
          }, error => {
          	// Logger.error('AgoraService.getVideoOptions.error', error);
          });
          */
        } else {
          options.cameraId = video.deviceId;
          resolve(options);
        }
      } else {
        resolve(options);
      }
    });
  }
  getAudioOptions(options, audio) {
    return new Promise((resolve, reject) => {
      if (audio) {
        if (audio.kind === 'videostream') {
          const element = document.querySelector('#' + audio.deviceId);
          element.crossOrigin = 'anonymous';
          // !!! try hls.service;
          var hls = new Hls();
          hls.attachMedia(element);
          hls.on(Hls.Events.MEDIA_ATTACHED, () => {
            hls.loadSource(audio.src);
            hls.on(Hls.Events.MANIFEST_PARSED, (event, data) => {
              // Logger.log('AgoraService.getAudioOptions.hls', data.levels);
              hls.loadLevel = data.levels.length - 1;
              element.play().then(success => {
                const stream = element.captureStream();
                options.audioSource = stream.getAudioTracks()[0];
                // Logger.log('AgoraService.getAudioOptions', element, stream, stream.getAudioTracks());
                resolve(options);
              }, error => {
                Logger.error('AgoraService.getAudioOptions.error', error);
              });
            });
          });
        } else if (audio.kind === 'videoplayer' || audio.kind === 'videostream') {
          const element = document.querySelector('#' + audio.deviceId);
          element.crossOrigin = 'anonymous';
          // element.oncanplay = () => {
          const stream = element.captureStream();
          options.audioSource = stream.getAudioTracks()[0];
          // Logger.log('AgoraService.getAudioOptions', element, stream, stream.getAudioTracks());
          resolve(options);
          // };
          /*
          element.play().then(success => {
          	const stream = element.captureStream();
          	options.audioSource = stream.getAudioTracks()[0];
          	// Logger.log('AgoraService.getAudioOptions', element, stream, stream.getAudioTracks());
          	resolve(options);
          }, error => {
          	// Logger.error('AgoraService.getAudioOptions.error', error);
          });
          */
        } else {
          options.microphoneId = audio.deviceId;
          resolve(options);
        }
      } else {
        resolve(options);
      }
    });
  }
  async autoDetectDevice() {
    const state = StateService.state;
    if (state.role === RoleType.SmartDevice || USE_AUTODETECT) {
      const inputDevices = await AgoraService.getDevices();
      const devices = {
        videos: [],
        audios: [],
        video: null,
        audio: null
      };
      inputDevices.forEach(x => {
        if (x.kind === 'videoinput') {
          devices.videos.push(x);
        } else if (x.kind === 'audioinput') {
          devices.audios.push(x);
        }
      });
      devices.video = devices.videos[0] || null;
      devices.audio = devices.audios[0] || null;
      StateService.patchState({
        devices
      });
      return devices;
    }
    return state.devices;
  }

  // 6. media stream - 1
  async createMediaStream(uid, video, audio) {
    // this.releaseStream('_mediaVideoStream')
    const options = {
      streamID: uid,
      video: Boolean(video),
      audio: Boolean(audio),
      screen: false
    };
    await this.getVideoOptions(options, video);
    await this.getAudioOptions(options, audio);
    const quality = Object.assign({}, StateService.state.quality);
    await this.createLocalStreamWithOptions(options, quality);
  }

  // 6. media stream - 2
  // If you prefer video smoothness to sharpness, use setVideoProfile
  // to set the video resolution and Agora self-adapts the video bitrate according to the network condition.
  // If you prefer video sharpness to smoothness, use setVideoEncoderConfiguration,
  // and set min in bitrate as 0.4 - 0.5 times the bitrate value in the video profile table.
  async createLocalStreamWithOptions(options, quality) {
    try {
      Logger.log('AgoraService.createLocalStreamWithOptions', options, quality);
      let videoTrack = undefined;
      let audioTrack = undefined;
      if (options.video) {
        videoTrack = await AgoraRTC$1.createCameraVideoTrack({
          cameraId: options.cameraId,
          encoderConfig: quality.profile
        });
      }
      if (options.audio) {
        audioTrack = await AgoraRTC$1.createMicrophoneAudioTrack({
          microphoneId: options.microphoneId
        });
      }
      const user = {
        uid: options.streamID,
        videoTrack,
        audioTrack,
        hasVideo: videoTrack !== undefined,
        hasAudio: audioTrack !== undefined
      };
      const stream = new Stream(user, options.video ? 'video' : 'audio', true);
      StreamService.local = stream;
      setTimeout(async () => {
        await this.publishLocalStream();
      }, 1);
      Logger.log('AgoraService.createLocalStreamWithOptions.success', stream);
    } catch (error) {
      Logger.error('AgoraService.createLocalStreamWithOptions.error', error);
      // throw error;
    }
  }

  // 6. media stream - 3
  async publishLocalStream() {
    try {
      Logger.log('AgoraService.publishLocalStream');
      const clientInfo = await this.setUserState();
      const local = StreamService.local;
      const client = this.client;
      await client.publish(local.getTracks());
      local.clientInfo = clientInfo;
      StreamService.local = local;
    } catch (error) {
      Logger.error('AgoraService.publishLocalStream.error', error);
      throw error;
    }
  }
  async unpublishLocalStream() {
    try {
      Logger.log('AgoraService.unpublishLocalStream');
      const client = this.client;
      const local = StreamService.local;
      if (local) {
        await client.unpublish(local.getTracks());
      }
      await this.clearLocalUserAttributes();
      StreamService.local = null;
    } catch (error) {
      Logger.error('AgoraService.unpublishLocalStream.error', error);
      throw error;
    }
  }
  async closeLocalStream() {
    try {
      const local = StreamService.local;
      if (local) {
        await local.close();
      }
      await this.clearLocalUserAttributes();
      StreamService.local = null;
      Logger.log('AgoraService.closeLocalStream', local);
    } catch (error) {
      Logger.error('AgoraService.closeLocalStream.error', error);
      throw error;
    }
  }
  async leaveChannel() {
    try {
      StateService.patchState({
        connecting: false
      });
      await this.closeLocalStream();
      await this.closeScreenStream();
      StreamService.remotes = [];
      StreamService.peers = [];
      await this.leaveMessageChannel();
      await this.leaveClient();
      await this.leaveScreenClient();
    } catch (error) {
      Logger.error('AgoraService.leaveChannel.error', error);
      throw error;
    }
  }
  leaveClient() {
    return new Promise((resolve, reject) => {
      const client = this.client;
      if (client) {
        client.leave(() => {
          this.client = null;
          // Logger.log('AgoraService.leaveClient', 'Leave channel successfully');
          if (environment.flags.useProxy) {
            client.stopProxyServer();
            Logger.log('AgoraService.leaveClient.stopProxyServer');
          }
          resolve();
        }, error => {
          Logger.error('AgoraService.leaveClient.error', error);
          reject(error);
        });
      } else {
        resolve();
      }
    });
  }
  leaveMessageChannel() {
    return new Promise((resolve, reject) => {
      this.unobserveMemberCount();
      const channel = this.channel;
      if (!channel) {
        return resolve();
      }
      const messageClient = this.messageClient;
      channel.leave().then(() => {
        this.channel = null;
        messageClient.logout().then(() => {
          this.messageClient = null;
          resolve();
        }, reject);
      }, reject);
    });
  }
  async toggleCamera() {
    const local = StreamService.local;
    // Logger.log('AgoraService.toggleCamera', local);
    if (local && local.video) {
      if (local.userMuteVideo) {
        await local.unmuteVideo();
        StateService.patchState({
          cameraMuted: false
        });
        this.broadcastEvent(new AgoraUnmuteVideoEvent({
          streamId: local.streamId
        }));
        this.setUserState();
      } else {
        await local.muteVideo();
        StateService.patchState({
          cameraMuted: true
        });
        this.broadcastEvent(new AgoraMuteVideoEvent({
          streamId: local.streamId
        }));
        this.setUserState();
      }
    }
  }
  async toggleAudio() {
    const local = StreamService.local;
    // Logger.log('AgoraService.toggleAudio', local);
    if (local && local.audio) {
      if (local.userMuteAudio) {
        await local.unmuteAudio();
        StateService.patchState({
          audioMuted: false
        });
        this.broadcastEvent(new AgoraUnmuteAudioEvent({
          streamId: local.streamId
        }));
        this.setUserState();
      } else {
        await local.muteAudio();
        StateService.patchState({
          audioMuted: true
        });
        this.broadcastEvent(new AgoraMuteAudioEvent({
          streamId: local.streamId
        }));
        this.setUserState();
      }
    }
  }
  setAudio(audioMuted) {
    const local = StreamService.local;
    if (local && local.audio) {
      if (audioMuted) {
        this.previousMuteAudio_ = local.userMuteAudio;
        if (!local.userMuteAudio) {
          local.muteAudio();
          StateService.patchState({
            audioMuted: true
          });
          this.broadcastEvent(new AgoraMuteAudioEvent({
            streamId: local.streamId
          }));
          this.setUserState();
        }
      } else {
        if (local.userMuteAudio && !this.previousMuteAudio_) {
          local.unmuteAudio();
          StateService.patchState({
            audioMuted: false
          });
          this.broadcastEvent(new AgoraUnmuteAudioEvent({
            streamId: local.streamId
          }));
          this.setUserState();
        }
      }
    }
  }
  toggleMode() {
    const mode = StateService.state.mode === UIMode.VirtualTour ? UIMode.LiveMeeting : UIMode.VirtualTour;
    StateService.patchState({
      mode
    });
    MessageService.send({
      type: MessageType.Mode,
      mode: mode
    });
    this.setChannelState({
      mode
    });
  }
  toggleNavInfo() {
    const showNavInfo = !StateService.state.showNavInfo;
    StateService.patchState({
      showNavInfo
    });
    MessageService.send({
      type: MessageType.NavInfo,
      showNavInfo: showNavInfo
    });
  }

  /**
   * controllingId is the uid of the controller user.
   */
  requestControl(controllingId) {
    return new Promise((resolve, _) => {
      this.sendRequestControl(controllingId).then(controllingId => {
        StateService.patchState({
          controlling: controllingId,
          spying: false
        });
        resolve(controllingId);
        this.setChannelState({
          controlling: controllingId,
          spying: ''
        });
      });
    });
  }
  requestSpy(spyingId) {
    return new Promise((resolve, _) => {
      this.sendRequestSpy(spyingId).then(spyingId => {
        StateService.patchState({
          spying: spyingId,
          controlling: false
        });
        resolve(spyingId);
        this.setChannelState({
          spying: spyingId,
          controlling: ''
        });
      });
    });
  }

  /**
   * controllingId is the uid of the controller user.
   */
  dismissControl(skipAttributes) {
    if (skipAttributes === void 0) {
      skipAttributes = false;
    }
    return new Promise((resolve, _) => {
      const controllingId = StateService.state.controlling;
      if (controllingId) {
        this.sendRequestControlDismiss(controllingId).then(() => {
          StateService.patchState({
            controlling: false
          });
          resolve(controllingId);
          if (!skipAttributes) {
            this.setChannelState({
              controlling: ''
            });
          }
        });
      } else {
        resolve(false);
      }
    });
  }
  dismissSpy(skipAttributes) {
    if (skipAttributes === void 0) {
      skipAttributes = false;
    }
    return new Promise((resolve, _) => {
      const spyingId = StateService.state.spying;
      if (spyingId) {
        this.sendRequestSpyDismiss(spyingId).then(() => {
          StateService.patchState({
            spying: false
          });
          resolve(spyingId);
          if (!skipAttributes) {
            this.setChannelState({
              spying: ''
            });
          }
        });
      } else {
        resolve(false);
      }
    });
  }

  /**
   * controllingId is the uid of the controller user.
   */
  toggleControl(controllingId) {
    this.dismissSpy(true).then(() => {
      this.dismissControl(true).then(dismissedControllingId => {
        if (dismissedControllingId !== controllingId) {
          this.requestControl(controllingId).then(controllingId => {
            Logger.log('AgoraService.toggleControl', controllingId);
          });
        } else {
          this.setChannelState({
            controlling: ''
          });
        }
      });
    });
  }
  toggleSpy(spyingId) {
    this.dismissControl(true).then(() => {
      this.dismissSpy(true).then(dismissedSpyingId => {
        if (dismissedSpyingId !== spyingId) {
          this.requestSpy(spyingId).then(spyingId => {
            Logger.log('AgoraService.toggleSpy', spyingId);
          });
        } else {
          this.setChannelState({
            spying: ''
          });
        }
      });
    });
  }
  sendRequestControl(controllingId) {
    return new Promise((resolve, _) => {
      this.sendMessage({
        type: MessageType.RequestControl,
        controllingId: controllingId
      }).then(() => {
        resolve(controllingId);
      });
    });
  }
  sendRequestSpy(spyingId) {
    return new Promise((resolve, _) => {
      this.sendMessage({
        type: MessageType.RequestSpy,
        spyingId: spyingId
      }).then(() => {
        resolve(spyingId);
      });
    });
  }
  sendRequestControlDismiss(controllingId) {
    return new Promise((resolve, _) => {
      this.sendMessage({
        type: MessageType.RequestControlDismiss,
        controllingId: controllingId
      }).then(() => {
        resolve(controllingId);
      });
    });
  }
  sendRequestSpyDismiss(spyingId) {
    return new Promise((resolve, _) => {
      this.sendMessage({
        type: MessageType.RequestSpyDismiss,
        spyingId: spyingId
      }).then(() => {
        resolve(spyingId);
      });
    });
  }
  toggleSilence() {
    const silencing = !StateService.state.silencing;
    this.sendMessage({
      type: MessageType.RemoteSilencing,
      silencing: silencing
    });
    StateService.patchState({
      silencing
    });
    // !!! todo silencing
    // this.setChannelState({ silencing });
  }

  newMessageId() {
    return `${StateService.state.uid}-${Date.now().toString()}`;
  }
  navToView(viewId, keepOrientation, useLastOrientation) {
    if (keepOrientation === void 0) {
      keepOrientation = false;
    }
    if (useLastOrientation === void 0) {
      useLastOrientation = false;
    }
    if (StateService.state.controlling === StateService.state.uid || StateService.state.spying === StateService.state.uid) {
      this.sendMessage({
        type: MessageType.NavToView,
        viewId: viewId,
        keepOrientation: keepOrientation,
        useLastOrientation: useLastOrientation
      });
    }
  }
  getSessionStats() {
    const client = this.client;
    client.getSessionStats(stats => {
      Logger.log(`
AgoraService.getSessionStats
	Duration: ${stats.Duration}
	UserCount: ${stats.UserCount}
	SendBytes: ${stats.SendBytes}
	RecvBytes: ${stats.RecvBytes}
	SendBitrate: ${stats.SendBitrate}
	RecvBitrate: ${stats.RecvBitrate}
`);
    });
  }
  getSystemStats() {
    const client = this.client;
    client.getSystemStats(stats => {
      Logger.log(`
AgoraService.getSystemStats
			BatteryLevel: ${stats.BatteryLevel}
`);
    });
  }
  sendMessage(message) {
    return new Promise((resolve, reject) => {
      if (StateService.state.connected) {
        message.clientId = StateService.state.uid;
        // Logger.log('AgoraService.sendMessage');
        switch (message.type) {
          case MessageType.ControlInfo:
          case MessageType.CurrentTimeMedia:
          case MessageType.MenuToggle:
          case MessageType.Mode:
          case MessageType.NavInfo:
          case MessageType.NavLink:
          case MessageType.NavLinkClose:
          case MessageType.NavToGrid:
          case MessageType.NavToView:
          case MessageType.PlayMedia:
          case MessageType.PlayModel:
          case MessageType.SelectItem:
          case MessageType.ShowPanel:
          case MessageType.SlideChange:
          case MessageType.VREnded:
          case MessageType.VRStarted:
          case MessageType.VRState:
          case MessageType.ZoomMedia:
          case MessageType.SetSnapshot:
            // Logger.log('AgoraService.sendMessage', StateService.state.uid, StateService.state.controlling, StateService.state.spying, StateService.state.controlling !== StateService.state.uid && StateService.state.spying !== StateService.state.uid);
            if (StateService.state.controlling !== StateService.state.uid && StateService.state.spying !== StateService.state.uid) {
              return;
            }
            break;
        }
        // message.wrc_version = 'beta';
        // message.uid = StateService.state.uid;
        const onMessageSent = message => {
          resolve(message);
          // rewire inner messages
          switch (message.type) {
            case MessageType.RequestControl:
              // !!! rewire inner message
              this.broadcastMessage(message);
              break;
            case MessageType.SetSnapshot:
              // !!! saving channel snapshot
              this.setChannelSnapshot(message);
              break;
          }
        };
        const send = (message, channel) => {
          Logger.log('AgoraService.sendMessage', message);
          try {
            const text = JSON.stringify(message);
            if (message.messageId) {
              this.once(`message-${message.messageId}`, message => {
                onMessageSent(message);
              });
            }
            // Logger.log('AgoraService.sendMessage.sending', message.type);
            channel.sendMessage({
              text: text
            }).then(() => {
              // Logger.log('AgoraService.sendMessage', text);
              if (!message.messageId) {
                onMessageSent(message);
              }
            }).catch(error => {
              Logger.error('AgoraService.sendMessage.error', error);
            });
          } catch (error) {
            Logger.error('AgoraService.sendMessage.error', error);
            // reject(error);
          }
        };

        const channel = this.channel;
        if (channel) {
          send(message, channel);
        } else {
          try {
            this.once('channel', channel => {
              send(message, channel);
            });
          } catch (error) {
            Logger.error('AgoraService.sendMessage.error', error);
            reject(error);
          }
        }
      } else {
        Logger.error('AgoraService.sendMessage.error', 'not connected');
        // reject();
      }
    });
  }

  /**
   * @description getChannelAttributes
   * @returns Record<string, { lastUpdateTs: number, value: string }>
   */
  getChannelAttributes() {
    Logger.log('AgoraService.getChannelAttributes');
    return new Promise((resolve, reject) => {
      const messageClient = this.messageClient;
      if (messageClient) {
        const promise = messageClient.getChannelAttributes(StateService.state.channelNameLink);
        promise.then(attributes => {
          Logger.log('AgoraService.getChannelAttributes', attributes);
          resolve(attributes);
        }).catch(error => {
          Logger.error('AgoraService.getChannelAttributes.error', error);
          resolve({});
        });
      } else {
        Logger.error('AgoraService.getChannelAttributes.noop');
        resolve({});
      }
    });
  }

  /**
   * @description getChannelAttributesByKeys
   * @params string[]
   * @returns Record<string, string>
   */
  getChannelAttributesByKeys() {
    for (var _len = arguments.length, keys = new Array(_len), _key = 0; _key < _len; _key++) {
      keys[_key] = arguments[_key];
    }
    Logger.log('AgoraService.getChannelAttributesByKeys', keys);
    return new Promise((resolve, reject) => {
      const messageClient = this.messageClient;
      if (messageClient) {
        const promise = messageClient.getChannelAttributes(StateService.state.channelNameLink, keys);
        promise.then(attributes => {
          Logger.log('AgoraService.getChannelAttributesByKeys', attributes);
          const mappedAttributes = {};
          Object.keys(attributes).forEach(key => {
            mappedAttributes[key] = attributes[key].value;
          });
          resolve(mappedAttributes);
        }).catch(error => {
          Logger.error('AgoraService.getChannelAttributesByKeys.error', error);
          resolve({});
        });
      } else {
        Logger.error('AgoraService.getChannelAttributesByKeys.noop', keys);
        resolve({});
      }
    });
  }

  /**
   * @description getChannelMessages
   * @returns { date: number, clientId: string, name: string, message: string }[]
   */
  getChannelMessages() {
    Logger.log('AgoraService.getChannelMessages');
    return rxjs.from(this.getChannelAttributes()).pipe(operators.map(attributes => Object.keys(attributes).filter(key => key.indexOf('message-') === 0).map(key => attributes[key])), operators.map(attributes => {
      attributes.sort((a, b) => {
        return a.lastUpdateTs - b.lastUpdateTs;
      });
      const messages = attributes.map(attribute => {
        const message = JSON.parse(attribute.value);
        return message;
      });
      Logger.log('AgoraService.getChannelMessages', messages);
      return messages;
    }), operators.catchError(error => {
      Logger.error('AgoraService.getChannelMessages.error', error);
      return rxjs.of([]);
    }));
  }

  /**
   * @description addOrUpdateChannelAttributes
   * @params attributes: Record<string, string>
   */
  addOrUpdateChannelAttributes(attributes) {
    Logger.log('AgoraService.addOrUpdateChannelAttributes', attributes);
    return new Promise((resolve, reject) => {
      const messageClient = this.messageClient;
      if (messageClient && Object.keys(attributes).length > 0) {
        const promise = messageClient.addOrUpdateChannelAttributes(StateService.state.channelNameLink, attributes, {
          enableNotificationToChannelMembers: false
        });
        promise.then(() => {
          Logger.log('AgoraService.addOrUpdateChannelAttributes', attributes);
        }).catch(error => {
          Logger.error('AgoraService.addOrUpdateChannelAttributes.error', error);
        }).finally(() => {
          resolve();
        });
      } else {
        Logger.error('AgoraService.addOrUpdateChannelAttributes.noop', attributes);
        resolve();
      }
    });
  }

  /**
   * this method is called after remote stream of the publisher has been added.
   */
  getInitialSession() {
    this.getChannelSession().then(session => {
      StateService.patchState(session.state);
      if (session.state.controlling && session.snapshot) {
        // !!! rewire inner message to update view snapshot
        this.broadcastMessage(session.snapshot);
      }
      // handle window mode changes
      window.dispatchEvent(new Event('resize'));
    });
  }

  /**
   * @description getChannelSession
   * @returns { state: State, snapshot: Snapshot }
   */
  getChannelSession() {
    Logger.log('AgoraService.getChannelSession');
    return new Promise((resolve, reject) => {
      this.getChannelAttributesByKeys('channelState', 'channelSnapshot').then(attributes => {
        const channelSession = {
          state: {},
          snapshot: {}
        };
        if (attributes.channelState) {
          const channelState = JSON.parse(attributes.channelState);
          this.channelState = channelState;
          channelSession.state = channelState;
        }
        if (attributes.channelSnapshot) {
          const channelSnapshot = JSON.parse(attributes.channelSnapshot);
          this.channelSnapshot = channelSnapshot;
          channelSession.snapshot = channelSnapshot;
        }
        Logger.log('AgoraService.getChannelSession', channelSession);
        resolve(channelSession);
      }).catch(error => {
        Logger.error('AgoraService.getChannelSession.error', error);
        resolve({});
      });
    });
  }

  /**
   * @description getChannelState
   * @returns State
   */
  getChannelState() {
    Logger.log('AgoraService.getChannelState');
    return new Promise((resolve, reject) => {
      this.getChannelAttributesByKeys('channelState').then(attributes => {
        if (attributes.channelState) {
          const channelState = JSON.parse(attributes.channelState);
          this.channelState = channelState;
          /*
          const channelState = {
          	role: StateService.state.role,
          	name: StateService.state.name,
          	uid: StateService.state.uid,
          	screenUid: StateService.state.screenUid,
          	controlling: StateService.state.controlling,
          	spying: StateService.state.spying,
          	mode: StateService.state.mode,
          };
          */
          Logger.log('AgoraService.getChannelState', channelState);
          resolve(channelState);
        } else {
          resolve({});
        }
      }).catch(error => {
        Logger.error('AgoraService.getChannelState.error', error);
        resolve({});
      });
    });
  }

  /**
   * @description setChannelState
   * @params partialState: Record<string, string>
   */
  setChannelState(partialState) {
    const channelState = _objectSpread2(_objectSpread2({}, this.channelState || {}), partialState);
    Logger.log('AgoraService.setChannelState', partialState, channelState);
    return this.addOrUpdateChannelAttributes({
      channelState: JSON.stringify(channelState)
    });
  }

  /**
   * @description getChannelSnapshot
   * @returns Snapshot
   */
  getChannelSnapshot() {
    Logger.log('AgoraService.getChannelSnapshot');
    return new Promise((resolve, reject) => {
      this.getChannelAttributesByKeys('channelSnapshot').then(attributes => {
        if (attributes.channelSnapshot) {
          const channelSnapshot = JSON.parse(attributes.channelSnapshot);
          this.channelSnapshot = channelSnapshot;
          Logger.log('AgoraService.getChannelSnapshot', channelSnapshot);
          resolve(channelSnapshot);
        } else {
          resolve({});
        }
      }).catch(error => {
        Logger.error('AgoraService.getChannelSnapshot.error', error);
        resolve({});
      });
    });
  }

  /**
   * @description setChannelSnapshot
   * @params partialSnapshot: Record<string, string>
   */
  setChannelSnapshot(partialSnapshot) {
    const channelSnapshot = _objectSpread2(_objectSpread2({}, this.channelSnapshot || {}), partialSnapshot);
    Logger.log('AgoraService.setChannelSnapshot', partialSnapshot, channelSnapshot);
    return this.addOrUpdateChannelAttributes({
      channelSnapshot: JSON.stringify(channelSnapshot)
    });
  }
  padStart(num, count, char) {
    if (count === void 0) {
      count = 5;
    }
    if (char === void 0) {
      char = '0';
    }
    const s = String(num);
    return s.length >= count ? s : new Array(count - s.length + 1).join(char) + s;
  }

  /**
   * @description addOrUpdateChannelMessages
   * @params messages: { date: number, clientId: string, name: string, message: string }[]
   */
  addOrUpdateChannelMessages(messages) {
    const attributes = {};
    messages.forEach(message => {
      const num = Math.floor(Math.random() * 10000);
      const key = `message-${message.date}-${this.padStart(num)}`;
      attributes[key] = JSON.stringify(message);
    });
    return this.addOrUpdateChannelAttributes(attributes);
  }
  deleteChannelAttributesByKeys(keys) {
    Logger.log('AgoraService.deleteChannelAttributesByKeys', keys);
    return new Promise((resolve, reject) => {
      const messageClient = this.messageClient;
      if (messageClient && keys.length > 0) {
        const promise = messageClient.deleteChannelAttributesByKeys(StateService.state.channelNameLink, keys, {
          enableNotificationToChannelMembers: false
        });
        promise.then(() => {
          Logger.log('AgoraService.deleteChannelAttributesByKeys', keys);
          resolve();
        }).catch(error => {
          Logger.error('AgoraService.deleteChannelAttributesByKeys.error', error);
          reject(error);
        });
      } else {
        Logger.error('AgoraService.deleteChannelAttributesByKeys.noop', keys);
        reject('missing rtm client or keys');
      }
    });
  }
  setUserState() {
    const clientInfo = {
      role: StateService.state.role,
      name: StateService.state.name,
      uid: StateService.state.uid,
      screenUid: StateService.state.screenUid,
      cameraMuted: StateService.state.cameraMuted,
      audioMuted: StateService.state.audioMuted
    };
    Logger.log('AgoraService.setUserState', clientInfo);
    return this.addOrUpdateLocalUserAttributes({
      clientInfo: JSON.stringify(clientInfo)
    }).then(() => {
      return clientInfo;
    });
  }
  getUserState(remoteId) {
    return this.getUserAttributes(remoteId).then(attributes => {
      const clientInfo = JSON.parse(attributes.clientInfo || '');
      Logger.log('AgoraService.getUserState', clientInfo);
      return clientInfo;
    });
  }
  addOrUpdateLocalUserAttributes(attributes) {
    Logger.log('AgoraService.addOrUpdateLocalUserAttributes', attributes);
    return new Promise((resolve, reject) => {
      const messageClient = this.messageClient;
      if (messageClient && Object.keys(attributes).length > 0) {
        const promise = messageClient.addOrUpdateLocalUserAttributes(attributes);
        promise.then(() => {
          Logger.log('AgoraService.addOrUpdateLocalUserAttributes', attributes);
          resolve();
        }).catch(error => {
          Logger.error('AgoraService.addOrUpdateLocalUserAttributes.error', error);
          reject(error);
        });
      } else {
        Logger.error('AgoraService.addOrUpdateLocalUserAttributes.noop', attributes);
        reject('missing rtm client or attributes');
      }
    });
  }
  getUserAttributes(userId) {
    Logger.log('AgoraService.getUserAttributes', userId);
    return new Promise((resolve, reject) => {
      const messageClient = this.messageClient;
      if (messageClient) {
        const promise = messageClient.getUserAttributes(userId);
        promise.then(attributes => {
          Logger.log('AgoraService.getUserAttributes', attributes);
          resolve(attributes);
        }).catch(error => {
          Logger.error('AgoraService.getUserAttributes.error', error);
          reject(error);
        });
      } else {
        Logger.error('AgoraService.getUserAttributes', 'missing rtm client');
        reject('missing rtm client');
      }
    });
  }
  clearLocalUserAttributes() {
    Logger.log('AgoraService.clearLocalUserAttributes');
    return new Promise((resolve, reject) => {
      const messageClient = this.messageClient;
      if (messageClient) {
        const promise = messageClient.clearLocalUserAttributes();
        promise.then(() => {
          Logger.log('AgoraService.clearLocalUserAttributes');
          resolve();
        }).catch(error => {
          Logger.error('AgoraService.clearLocalUserAttributes.error', error);
          resolve();
        });
      } else {
        resolve();
      }
    });
  }
  checkBroadcastMessage(message) {
    // filter for broadcast
    // !!! filter events here
    switch (message.type) {
      case MessageType.RequestControlDismiss:
        StateService.patchState({
          controlling: false
        });
        if (message.controllingId === StateService.state.uid) {
          this.closeScreenStream();
        }
        break;
      case MessageType.RequestSpyDismiss:
        StateService.patchState({
          spying: false
        });
        break;
      case MessageType.SetSnapshot:
        // Logger.log('AgoraService.checkBroadcastMessage.SetSnapshot', message);
        if (StateService.state.role === RoleType.Publisher) {
          this.broadcastMessage(message);
        } else if (StateService.state.controlling && StateService.state.controlling !== StateService.state.uid) {
          this.broadcastMessage(message);
        }
        break;
      case MessageType.RemoteSilencing:
        // only streamers can be silenced
        if (StateService.state.role === RoleType.Streamer) {
          this.broadcastMessage(message);
        }
        break;
      case MessageType.ControlInfo:
      case MessageType.CurrentTimeMedia:
      case MessageType.MenuToggle:
      case MessageType.Mode:
      case MessageType.NavInfo:
      case MessageType.NavLink:
      case MessageType.NavLinkClose:
      case MessageType.NavToGrid:
      case MessageType.NavToView:
      case MessageType.PlayMedia:
      case MessageType.PlayModel:
      case MessageType.SelectItem:
      case MessageType.ShowPanel:
      case MessageType.SlideChange:
      case MessageType.VREnded:
      case MessageType.VRStarted:
      case MessageType.VRState:
      case MessageType.ZoomMedia:
        if (StateService.state.controlling && StateService.state.controlling !== StateService.state.uid || StateService.state.spying && StateService.state.spying !== StateService.state.uid) {
          this.broadcastMessage(message);
        }
        break;
      default:
        this.broadcastMessage(message);
    }
  }
  broadcastMessage(message) {
    MessageService.out(message);
  }
  broadcastEvent(event) {
    MessageService.out({
      type: MessageType.AgoraEvent,
      event
    });
  }
  peerAdd(remoteId) {
    Logger.log('AgoraService.peerAdd', remoteId);
    const peer = {
      uid: remoteId
    };
    const peers = StreamService.peers;
    peers.push(peer);
    StreamService.peers = peers;
    this.broadcastEvent(new AgoraPeerEvent({
      peer
    }));
  }
  peerRemove(remoteId) {
    Logger.log('AgoraService.peerRemove', remoteId);
    const peers = StreamService.peers;
    const peer = peers.find(x => x.uid === remoteId);
    if (peer) {
      peers.splice(peers.indexOf(peer), 1);
      StreamService.peers = peers;
    }
  }
  onMessage(data, uid) {
    // Logger.log('AgoraService.onMessage', data.text, uid, StateService.state.uid);
    // discard message delivered by current state uid;
    if (uid !== StateService.state.uid) {
      Logger.log('AgoraService.onMessage', data.text, uid);
      const message = JSON.parse(data.text);
      if (message.messageId && this.has(`message-${message.messageId}`)) {
        // !!! removed return
        this.emit(`message-${message.messageId}`, message);
      }
      // discard message delivered to specific remoteId when differs from current state uid;
      if (message.remoteId && message.remoteId !== StateService.state.uid && message.remoteId !== StateService.state.screenUid) {
        return;
      }
      // !!! check position !!!
      if (message.type === MessageType.VRStarted) {
        const container = document.createElement('div');
        container.classList.add('player__vr');
        message.container = container;
      }
      /*
      if (message.type === MessageType.VRStarted || message.type === MessageType.VREnded) {
      	// Logger.log('AgoraService.onMessage', message.type, message);
      }
      */
      this.checkBroadcastMessage(message);
    } else {
      Logger.log('AgoraService.onMessage', data.text);
    }
  }
  onException(event) {
    Logger.error('AgoraService.onException', event);
  }
  async onUserJoined(user) {
    Logger.log('AgoraService.onUserJoined', user);
    this.peerAdd(user.uid);
  }
  async onUserLeft(user, reason) {
    Logger.log('AgoraService.onUserLeft', user, reason);
    const remoteId = user.uid.toString();
    if (remoteId !== StateService.state.uid) {
      // Logger.log('AgoraService.onUserLeft', user.uid);
      const remote = this.remoteRemove(remoteId);
      if (remote && remote.clientInfo) {
        // !!! remove screenRemote?
        if (remote.clientInfo.role === RoleType.Publisher) {
          if (StateService.state.role === RoleType.SelfService) {
            StateService.patchState({
              hosted: true,
              controlling: false,
              spying: false,
              silencing: false
            });
          } else {
            StateService.patchState({
              hosted: false,
              controlling: false,
              spying: false,
              silencing: false
            });
          }
        } else {
          if (StateService.state.controlling === remoteId) {
            StateService.patchState({
              controlling: false
            });
          }
          if (StateService.state.spying === remoteId) {
            StateService.patchState({
              spying: false
            });
          }
        }
      }
    }
    this.peerRemove(remoteId);
  }

  /**
   *
   * @param {IAgoraRTCRemoteUser} user
   * @param {'audio' | 'video'} mediaType
   */
  async onUserPublished(user, mediaType) {
    const uid = user.uid.toString();
    Logger.log('AgoraService.onUserPublished', uid, user, mediaType);
    if (uid !== StateService.state.uid && uid !== StateService.state.screenUid) {
      await this.client.subscribe(user, mediaType);
      let remote = StreamService.getRemoteById(user.uid);
      if (remote) {
        remote.published(user, mediaType);
      } else {
        remote = new Stream(user, mediaType);
        await this.remoteAdd(remote);
      }
      /*
      if (mediaType === 'video') {
      	const remote = new Stream(user, mediaType);
      	await this.remoteAdd(remote);
      } else if (mediaType === 'audio') {
      	user.audioTrack?.play();
      }
      */
    } else {
      const clientInfo = {
        role: StateService.state.role,
        name: StateService.state.name,
        uid: StateService.state.uid,
        screenUid: StateService.state.screenUid
      };
      const local = StreamService.local;
      local.clientInfo = clientInfo;
      StreamService.local = local;
    }
  }
  async remoteAdd(stream) {
    Logger.log('AgoraService.remoteAdd', stream);
    StreamService.remoteAdd(stream);
    this.broadcastEvent(new AgoraRemoteEvent({
      stream
    }));
    const remoteId = stream.streamId;
    setTimeout(async () => {
      const clientInfo = await this.getUserState(remoteId);
      Logger.log('AgoraService.remoteAdd.getUserState', clientInfo);
      StreamService.remoteSetClientInfo(remoteId, clientInfo);
      if (clientInfo.cameraMuted) {
        this.broadcastEvent(new AgoraMuteVideoEvent({
          streamId: remoteId
        }));
      }
      if (clientInfo.audioMuted) {
        this.broadcastEvent(new AgoraMuteAudioEvent({
          streamId: remoteId
        }));
      }
      if (clientInfo.role === RoleType.Publisher) {
        const state = {
          hosted: true
        };
        StateService.patchState(state);
        this.getInitialSession();
      }
    }, 100);
  }

  /**
   *
   * @param {IAgoraRTCRemoteUser} user
   * @param {'audio' | 'video'} mediaType
   */
  async onUserUnpublished(user, mediaType) {
    /**
     * !!! now onUserUnpublished happen at mute of track
     */
    const uid = user.uid.toString();
    if (uid !== StateService.state.uid && uid !== StateService.state.screenUid) {
      let remote = StreamService.getRemoteById(user.uid);
      if (remote) {
        remote.unpublished(user, mediaType);
      }
    }
    /*
    Logger.log('AgoraService.onUserUnpublished', uid, user, mediaType);
    if (uid === StateService.state.uid) {
    	StreamService.local = null;
    } else if (uid === StateService.state.screenUid) {
    	StreamService.screen = null;
    } else if (mediaType === 'video') {
    	// !!! this happen on oculus removed timeout
    	this.remoteRemove(uid);
    } else if (mediaType === 'audio') {
    	user.audioTrack?.stop();
    }
    */
  }

  remoteRemove(streamId) {
    // Logger.log('AgoraService.remoteRemove', streamId);
    const remote = StreamService.remoteRemove(streamId);
    if (remote && remote.clientInfo && remote.clientInfo.role === RoleType.Publisher && remote.clientInfo.screenUid !== streamId) {
      StateService.patchState({
        hosted: false
      });
    }
    return remote;
  }
  onUserInfoUpdated(event) {
    Logger.log('AgoraService.onUserInfoUpdated', event);
    switch (event.msg) {
      case 'mute-audio':
        this.broadcastEvent(new AgoraMuteAudioEvent({
          streamId: event.uid
        }));
        break;
      case 'unmute-audio':
        this.broadcastEvent(new AgoraUnmuteAudioEvent({
          streamId: event.uid
        }));
        break;
      case 'mute-video':
        this.broadcastEvent(new AgoraMuteVideoEvent({
          streamId: event.uid
        }));
        break;
      case 'unmute-video':
        this.broadcastEvent(new AgoraUnmuteVideoEvent({
          streamId: event.uid
        }));
        break;
      /*
      case 'disable-local-video':
      this.broadcastEvent(new AgoraDisableVideoEvent({ streamId: event.uid }));
      break;
      case 'enable-local-video':
      this.broadcastEvent(new AgoraEnableVideoEvent({ streamId: event.uid }));
      break;
      */
    }

    this.broadcastEvent(new AgoraUserInfoUpdateEvent({
      streamId: event.uid,
      message: event.msg
    }));
  }

  /*
  onMuteVideo(event) {
  	// Logger.log('AgoraService.onMuteVideo', event);
  	this.broadcastEvent(new AgoraMuteVideoEvent({ streamId: event.uid }));
  }
  
  onUnmuteVideo(event) {
  	// Logger.log('AgoraService.onUnmuteVideo', event);
  	this.broadcastEvent(new AgoraUnmuteVideoEvent({ streamId: event.uid }));
  }
  
  onMuteAudio(event) {
  	// Logger.log('AgoraService.onMuteAudio', event);
  	this.broadcastEvent(new AgoraMuteAudioEvent({ streamId: event.uid }));
  }
  
  onUnmuteAudio(event) {
  	// Logger.log('AgoraService.onUnmuteAudio', event);
  	this.broadcastEvent(new AgoraUnmuteAudioEvent({ streamId: event.uid }));
  }
  */

  onVolumeIndicator(event) {
    // Logger.log('AgoraService.onVolumeIndicator', event);
    const streams = event.attr.map(x => {
      return {
        streamId: x.uid,
        level: x.level
      };
    });
    this.broadcastEvent(new AgoraVolumeLevelsEvent({
      streams: streams
    }));
  }
  onConnectionStateChange(event) {
    Logger.log('AgoraService.onConnectionStateChange', event);
  }
  onTokenPrivilegeWillExpire(event) {
    Logger.log('AgoraService.onTokenPrivilegeWillExpire');
    const client = this.client;
    const channelNameLink = this.getChannelNameLink();
    AgoraService.rtcToken$(channelNameLink).subscribe(async token => {
      if (token.token) {
        await client.renewToken(token.token);
        Logger.log('AgoraService.onTokenPrivilegeWillExpire.renewed');
      }
    });
  }
  onTokenPrivilegeDidExpire(event) {
    Logger.log('AgoraService.onTokenPrivilegeDidExpire');
    const client = this.client;
    const channelNameLink = this.getChannelNameLink();
    AgoraService.rtcToken$(channelNameLink).subscribe(async token => {
      if (token.token) {
        await client.renewToken(token.token);
        Logger.log('AgoraService.onTokenPrivilegeDidExpire.renewed');
      }
    });
  }

  // screen

  toggleScreen() {
    if (this.isAudienceRole) {
      return;
    }
    const screen = StreamService.screen;
    // console.log('AgoraService.toggleScreen', screen);
    if (screen) {
      this.closeScreenStream();
    } else {
      this.openScreenStream();
    }
  }
  async openScreenStream() {
    let screenClient = this.screenClient;
    if (!screenClient) {
      screenClient = await this.createScreenClient();
    }
    if (screenClient) {
      await this.createScreenStream(StateService.state.screenUid);
    }
  }
  async createScreenClient() {
    let screenClient = null;
    try {
      screenClient = AgoraRTC$1.createClient({
        mode: 'live',
        codec: 'h264'
      }); // rtc, vp8
      screenClient.on('exception', this.onScreenException);
      // screenClient.on('user-joined', this.onScreenJoined);
      // screenClient.on('user-left', this.onScreenLeft);
      screenClient.on('user-published', this.onScreenPublished);
      screenClient.on('user-unpublished', this.onScreenUnpublished);
      // screenClient.on('user-info-updated', this.onScreenInfoUpdated);
      // screenClient.on('onTokenPrivilegeWillExpire', this.onTokenPrivilegeWillExpire);
      // screenClient.on('onTokenPrivilegeDidExpire', this.onTokenPrivilegeDidExpire);
      await screenClient.setClientRole('host');
      if (environment.flags.useProxy) {
        screenClient.startProxyServer(3);
        /*
        3: The cloud proxy for the UDP protocol, that is, the Force UDP cloud proxy mode. In this mode, the SDK always transmits data over UDP.
        5: The cloud proxy for the TCP (encryption) protocol, that is, the Force TCP cloud proxy mode. In this mode, the SDK always transmits data over TLS 443.
        Note: As of v4.15.0, the default value of mode is 3.
        */
        Logger.log('AgoraService.openScreenStream.startProxyServer');
      }
      const channelNameLink = this.getChannelNameLink();
      const rtcToken = await AgoraService.rtcToken$(channelNameLink).toPromise();
      Logger.log('AgoraService.toggleScreen.rtcToken$', rtcToken);
      await this.screenJoin(screenClient, rtcToken.token, channelNameLink);
    } catch (error) {
      Logger.error('AgoraService.openScreenStream.error', error);
    }
    this.screenClient = screenClient;
    return screenClient;
  }
  async screenJoin(screenClient, token, channelNameLink) {
    try {
      const screenClientId = AgoraService.getUniqueUserId();
      const screenUid = await screenClient.join(environment.appKey, channelNameLink, token, screenClientId);
      Logger.log('AgoraService.screenJoin', screenUid);
      StateService.patchState({
        screenUid
      });
    } catch (error) {
      Logger.error('AgoraService.screenJoin.error', error);
      if (error === 'DYNAMIC_KEY_EXPIRED') {
        const rtcToken = await AgoraService.rtcToken$(channelNameLink).toPromise();
        await this.screenJoin(screenClient, rtcToken.token, channelNameLink);
      }
    }
  }
  async createScreenStream(screenUid) {
    try {
      const screenQuality = StreamQualities.find(x => x.profile === environment.profiles.screen);
      let screenTrack = await AgoraRTC$1.createScreenVideoTrack({
        displaySurface: 'monitor',
        // pre-selection
        encoderConfig: screenQuality.profile
      }, 'disable');
      const user = {
        uid: screenUid,
        videoTrack: screenTrack,
        hasVideo: screenTrack !== undefined
      };
      const stream = new Stream(user, 'video', true);
      StreamService.screen = stream;
      setTimeout(async () => {
        await this.publishScreenStream();
      }, 1);
      Logger.log('AgoraService.createLocalStreamWithOptions.success', stream);
    } catch (error) {
      Logger.error('AgoraService.createLocalStreamWithOptions.error', error);
      // throw error;
    }
  }

  async publishScreenStream() {
    try {
      Logger.log('AgoraService.publishScreenStream');
      const clientInfo = await this.setUserState();
      const screen = StreamService.screen;
      const screenClient = this.screenClient;
      await screenClient.publish(screen.getTracks());
      screen.clientInfo = clientInfo;
      StreamService.screen = screen;
    } catch (error) {
      Logger.error('AgoraService.publishScreenStream.error', error);
      throw error;
    }
  }
  async unpublishScreenStream() {
    try {
      Logger.log('AgoraService.unpublishScreenStream');
      const screenClient = this.screenClient;
      const screen = StreamService.screen;
      if (screen && screenClient) {
        await screenClient.unpublish(screen.getTracks());
      }
      StreamService.screen = null;
    } catch (error) {
      Logger.error('AgoraService.unpublishScreenStream.error', error);
      throw error;
    }
  }
  async closeScreenStream() {
    try {
      const screen = StreamService.screen;
      if (screen) {
        await screen.close();
      }
      await this.clearLocalUserAttributes();
      StreamService.screen = null;
      Logger.log('AgoraService.closeScreenStream', screen);
    } catch (error) {
      Logger.error('AgoraService.closeScreenStream.error', error);
      throw error;
    }
  }
  leaveScreenClient() {
    return new Promise((resolve, reject) => {
      const screenClient = this.screenClient;
      if (screenClient) {
        screenClient.leave(() => {
          this.screenClient = null;
          // Logger.log(AgoraService.leaveScreenClient');
          if (environment.flags.useProxy) {
            screenClient.stopProxyServer();
            Logger.log('AgoraService.leaveScreenClient.stopProxyServer');
          }
          resolve();
        }, error => {
          Logger.error('AgoraService.leaveScreenClient.error', error);
          reject(error);
        });
      } else {
        resolve();
      }
    });
  }
  onScreenException(error) {
    Logger.error('AgoraService.onScreenException', error);
  }
  onScreenPublished(event) {
    Logger.log('AgoraService.onScreenPublished', event);
    /*
    const screen = StreamService.screen;
    screen.clientInfo = {
    	role: StateService.state.role,
    	name: StateService.state.name,
    	uid: StateService.state.uid,
    	screenUid: StateService.state.screenUid,
    };
    StreamService.screen = screen;
    */
  }

  onScreenUnpublished(event) {
    Logger.log('AgoraService.onScreenUnpublished', event);
    /*
    StreamService.screen = null;
    */
  }

  // static

  static getSingleton(defaultDevices) {
    if (DEBUG) {
      return;
    }
    if (!this.AGORA) {
      this.AGORA = new AgoraService(defaultDevices);
    }
    return this.AGORA;
  }
  static getUniqueUserId() {
    // max safe integer 9007199254740991 length 16
    // max allowed integer 4294967296 2^32
    // const m = 9007199254740991;
    const mult = 10000000000000;
    const a = (1 + Math.floor(Math.random() * 8)) * 100;
    const b = (1 + Math.floor(Math.random() * 8)) * 10;
    const c = (1 + Math.floor(Math.random() * 8)) * 1;
    const combo = a + b + c;
    const date = Date.now();
    const uid = combo * mult + date;
    // Logger.log('AgoraService.getUniqueUserId', combo);
    // Logger.log('AgoraService.getUniqueUserId', date);
    // Logger.log('AgoraService.getUniqueUserId', m);
    // Logger.log('AgoraService.getUniqueUserId', uid);
    /**
     * Agora User Id Spec
     * [String uid] Length of the string: [1,255]. ASCII characters only.
     * [Number uid] The value range is [0,10000]
     * */
    return uid.toString();
    // return uid;
  }

  static resolveUserId() {
    /**
     * Agora User Id Spec
     * [String uid] Length of the string: [1,255]. ASCII characters only.
     * [Number uid] The value range is [0,10000]
     * */
    let clientId = SessionStorageService.get('bHereClientId');
    if (typeof clientId === 'number') {
      return clientId.toString();
    } else if (typeof clientId === 'string') {
      return clientId;
    } else {
      return AgoraService.getUniqueUserId();
    }
  }
  static storeUserId(uid) {
    SessionStorageService.set('bHereClientId', uid);
  }
  static fixLegacy() {
    const prefixes = ['moz', 'webkit'];
    prefixes.forEach(prefix => {
      Logger.log('AgoraService.fixLegacy', `${prefix}RTC`);
      Object.getOwnPropertyNames(window).filter(key => key.indexOf('RTC') === 0).map(key => {
        const legacyKey = `${prefix}${key}`;
        if (typeof window[key] !== 'undefined' && typeof window[legacyKey] === 'undefined') {
          window[legacyKey] = window[key];
        }
      });
    });
  }

  // tokens

  static rtcToken$(channelNameLink) {
    if (environment.flags.useToken) {
      return HttpService.post$('/api/token/rtc', {
        channelName: channelNameLink,
        uid: null
      });
    } else {
      return rxjs.of({
        token: null
      });
    }
  }
  static rtmToken$(uid) {
    if (environment.flags.useToken) {
      return HttpService.post$('/api/token/rtm', {
        uid: uid
      });
    } else {
      return rxjs.of({
        token: null
      });
    }
  }

  // checks

  static checkRtcConnection() {
    return new Promise((resolve, reject) => {
      try {
        const client = AgoraRTC$1.createClient({
          mode: 'live',
          codec: 'h264'
        }); // rtc, vp8
        if (environment.flags.useProxy) {
          client.startProxyServer(3);
        }
        AgoraService.checkRtcTryJoin(client).then(uid => {
          resolve(uid);
        }).catch(error => {
          reject(error);
        }).finally(() => {
          // clear
          client.leave(() => {
            if (environment.flags.useProxy) {
              client.stopProxyServer();
            }
          }, () => {});
        });
      } catch (error) {
        reject(error);
      }
    });
  }
  static checkRtcTryJoin(client) {
    return new Promise((resolve, reject) => {
      const channelName = 'checkRtcConnection';
      AgoraService.rtcToken$(channelName).subscribe(async token => {
        try {
          const uid = await client.join(environment.appKey, channelName, token.token, null);
          resolve(uid);
        } catch (error) {
          if (error === 'DYNAMIC_KEY_EXPIRED') {
            return AgoraService.checkRtcTryJoin(client);
          } else {
            Logger.error('AgoraService.checkRtcConnection.error', error);
            reject(error);
          }
        }
      }, error => reject(error));
    });
  }
  static checkRtmConnection(uid) {
    return new Promise((resolve, reject) => {
      try {
        let client = AgoraRTM.createInstance(environment.appKey, {
          logFilter: AgoraRTM.LOG_FILTER_OFF
        });
        client.setParameters({
          logFilter: AgoraRTM.LOG_FILTER_OFF
        });
        let channel;
        AgoraService.rtmToken$(uid).subscribe(token => {
          // Logger.log('AgoraService.rtmToken$', token);
          const channelName = 'checkRtcConnection';
          client.login({
            token: token.token,
            uid: uid.toString()
          }).then(() => {
            channel = client.createChannel(channelName);
            channel.join().then(() => {
              resolve(uid);
              channel.leave();
            }).catch(error => {
              reject(error);
            }).finally(() => {
              // clear
              channel.leave().then(() => {
                channel = null;
                client.logout().then(() => {
                  client = null;
                }).catch(() => {});
              }).catch(() => {});
            });
          }).catch(error => {
            Logger.error('checkRtmConnection.error', error);
            reject(error);
          }).finally(() => {
            // clear
            if (client) {
              client.logout().then(() => {
                client = null;
              }).catch(() => {});
            }
          });
        }, error => reject(error));
      } catch (error) {
        reject(error);
      }
    });
  }
  static async getDevices() {
    let devices_ = AgoraService.devices_;
    if (devices_) {
      return devices_;
    } else {
      devices_ = AgoraService.devices_ = [];
      const constraints = {
        audio: true,
        video: true
      };
      if (DeviceService.platform === DevicePlatform.IOS) {
        constraints.video = {
          facingMode: 'user'
        };
      }
      if (DeviceService.platform === DevicePlatform.VRHeadset) {
        constraints.video = false;
      }
      if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
        const stream = await navigator.mediaDevices.getUserMedia(constraints);
        const devices = await navigator.mediaDevices.enumerateDevices();
        stream.getTracks().forEach(track => {
          track.stop();
        });
        devices.forEach(device => {
          devices_.push(device);
        });
        return devices_;
      } else {
        throw 'Media device not available';
      }
    }
  }
}const USE_RANDOM_MESSAGE = false;
class ChatMessage {
  constructor(message, clientId, name) {
    this.type = MessageType.ChatMessage;
    this.clientId_ = clientId;
    if (typeof message === 'string') {
      this.date = Date.now();
      this.clientId = clientId;
      this.name = name;
      this.message = message;
    } else if (typeof message === 'object') {
      this.date = message.date;
      this.clientId = message.clientId;
      this.name = message.name;
      this.message = message.message;
    }
    const names = this.name.split(' ');
    this.shortName = names[0].substr(0, 1).toUpperCase() + (names.length > 1 ? names[1] : names[0]).substr(0, 1).toUpperCase();
  }
  get me() {
    return this.clientId === this.clientId_;
  }
  getPayload() {
    return {
      date: this.date,
      clientId: this.clientId,
      name: this.name,
      message: this.message
    };
  }
  getCopy() {
    return new ChatMessage({
      date: this.date,
      clientId: this.clientId,
      name: this.name,
      message: this.message
    }, this.clientId_);
  }
}
class AgoraChatComponent extends rxcomp.Component {
  constructor() {
    super(...arguments);
    this.typings_ = false;
  }
  onInit() {
    this.rows = 1;
    this.showEmoji = false;
    this.demo = window.location.pathname.indexOf('layout') !== -1;
    const form = this.form = new rxcompForm.FormGroup({
      message: null
    });
    this.controls = form.controls;
    form.changes$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(changes => {
      // console.log('AgoraChatComponent.changes$', form.value);
      this.checkTypings(changes);
      this.pushChanges();
    });
    StateService.state$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(state => {
      // console.log('AgoraChatComponent.state', state);
    });
    MessageService.out$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(message => {
      // console.log('AgoraChatComponent.MessageService', message);
      switch (message.type) {
        case MessageType.ChatMessage:
          this.pushMessage(new ChatMessage(message, StateService.state.uid, StateService.state.name));
          break;
        case MessageType.ChatTypingBegin:
          this.typingBegin(message);
          break;
        case MessageType.ChatTypingEnd:
          this.typingEnd(message);
          break;
      }
    });
    this.messages = [];
    this.groupedMessages = [];
    if (this.demo) {
      // !!! only for demo
      const messages = AgoraChatComponent.getFakeList().map(x => new ChatMessage(x, StateService.state.uid, StateService.state.name));
      this.updateMessages(messages.slice(0, 5));
      MessageService.in$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(message => {
        message.clientId = message.clientId || StateService.state.uid;
        // console.log('AgoraChatComponent.MessageService.in$', message);
        switch (message.type) {
          case MessageType.ChatMessage:
            break;
          case MessageType.ChatTypingBegin:
            MessageService.out(message);
            break;
          case MessageType.ChatTypingEnd:
            MessageService.out(message);
            break;
        }
      });
      // !!! only for demo
    } else {
      const agora = this.agora = AgoraService.getSingleton();
      if (agora) {
        agora.getChannelMessages().pipe(operators.first()).subscribe(messages => {
          messages = messages.map(x => new ChatMessage(x, StateService.state.uid, StateService.state.name));
          // console.log('AgoraChatComponent.getChannelAttributes.messages', messages);
          this.updateMessages(messages);
        });
      }
    }
  }
  onView() {
    // this.scrollToBottom();
  }
  onChanges() {
    // this.scrollToBottom();
  }
  onDestroy() {
    if (AgoraChatComponent.to) {
      clearTimeout(AgoraChatComponent.to);
      AgoraChatComponent.to = null;
    }
  }
  onSubmit() {
    const secureMessage = this.secureText(this.form.value.message);
    // console.log('secureMessage', secureMessage);
    const message = this.createMessage(secureMessage);
    this.sendMessage(message);
    this.form.get('message').value = null;
    if (this.demo && USE_RANDOM_MESSAGE) {
      this.randomMessage();
    }
  }
  onKeyDown(event) {
    // console.log('onKeyDown', event);
    if (event.key === 'Enter') {
      if (event.shiftKey) {
        this.rows = Math.min(4, this.rows + 1);
        this.pushChanges();
      } else {
        event.preventDefault();
        this.onSubmit();
        this.rows = 1;
      }
      const {
        node
      } = rxcomp.getContext(this);
      const textareaNode = node.querySelector('textarea');
      textareaNode.setAttribute('rows', this.rows);
    }
  }
  onToggleEmoji() {
    this.showEmoji = !this.showEmoji;
    this.pushChanges();
  }
  onSelectEmoji(emoji) {
    this.showEmoji = false;
    this.form.get('message').value = (this.form.get('message').value || '') + emoji.char;
    // this.pushChanges();
  }

  secureText(unsecureText) {
    let newDocument = new DOMParser().parseFromString(unsecureText, 'text/html');
    return newDocument.body.textContent || '';
  }
  createMessage(text) {
    const message = new ChatMessage(text, StateService.state.uid, StateService.state.name);
    return message;
  }
  sendMessage(message) {
    this.pushMessage(message);
    const agora = this.agora;
    if (agora) {
      agora.addOrUpdateChannelMessages([message.getPayload()]);
    }
    MessageService.send(message);
  }
  onClose(event) {
    this.close.next();
  }
  scrollToBottom() {
    const {
      node
    } = rxcomp.getContext(this);
    const scrollView = node.querySelector('.group--scrollview');
    scrollView.scrollTop = scrollView.scrollHeight;
  }
  pushMessage(message) {
    const messages = this.messages ? this.messages.slice() : [];
    this.removeTyping({
      type: MessageType.ChatTypingBegin,
      clientId: message.clientId
    }, this.messages);
    messages.push(message);
    this.updateMessages(messages);
  }
  typingBegin(message) {
    // console.log('AgoraChatComponent.typingBegin', message);
    const messages = this.messages ? this.messages.slice() : [];
    messages.push(message);
    this.updateMessages(messages);
  }
  typingEnd(message) {
    // console.log('AgoraChatComponent.typingEnd', message);
    const messages = this.messages ? this.messages.slice() : [];
    this.removeTyping({
      type: MessageType.ChatTypingBegin,
      clientId: message.clientId
    }, messages);
    this.updateMessages(messages);
  }
  removeTyping(message, messages, recursive) {
    if (recursive === void 0) {
      recursive = true;
    }
    const index = messages.reduce((p, c, i) => {
      return c.type === message.type && c.clientId === message.clientId ? i : p;
    }, -1);
    if (index !== -1) {
      messages.splice(index, 1);
      if (recursive === true) {
        this.removeTyping(message, messages, true);
      }
    }
    return index;
  }
  checkTypings(changes) {
    const typings = changes.message && changes.message.length > 0 || false;
    // console.log('AgoraChatComponent.checkTypings', typings, this.typings_);
    if (this.typings_ !== typings) {
      this.typings_ = typings;
      if (typings) {
        MessageService.send({
          type: MessageType.ChatTypingBegin
        });
      } else {
        MessageService.send({
          type: MessageType.ChatTypingEnd
        });
      }
    }
  }
  updateMessages(messages) {
    this.messages = messages;
    {
      this.groupedMessages = [];
      this.pushChanges();
    }
    const groupedMessages = [];
    messages.forEach(message => {
      if (message.type === MessageType.ChatMessage) {
        // ChatMessage
        const lastMessage = groupedMessages.length ? groupedMessages[groupedMessages.length - 1] : null;
        if (lastMessage && lastMessage.clientId === message.clientId) {
          lastMessage.message += `<p>${message.message}</p>`;
        } else {
          groupedMessages.push(message.getCopy());
        }
      } else if (message.type === MessageType.ChatTypingBegin) {
        // ChatTypingBegin
        const lastMessage = groupedMessages.reduce((p, c, i) => {
          return c.clientId === message.clientId ? c : p;
        }, null);
        if (lastMessage) {
          lastMessage.typing = true;
        }
        // console.log('MessageType.ChatTypingBegin', lastMessage, message);
      }
    });
    // setTimeout(() => {
    this.groupedMessages = groupedMessages;
    this.pushChanges();
    // console.log('AgoraChatComponent.updateMessages', messages, groupedMessages);
    setTimeout(() => {
      this.scrollToBottom();
    }, 1);
    // }, 1);
  }

  isValid() {
    const isValid = this.form.valid;
    return isValid && this.form.value.message && this.form.value.message.length > 0;
  }

  // demo

  randomMessage() {
    if (AgoraChatComponent.to) {
      clearTimeout(AgoraChatComponent.to);
      AgoraChatComponent.to = null;
    }
    AgoraChatComponent.to = setTimeout(() => {
      const message = AgoraChatComponent.createRandomMessage();
      this.sendMessage(message);
    }, (2 + Math.random() * 6) * 1000);
  }
}
AgoraChatComponent.meta = {
  selector: '[agora-chat]',
  outputs: ['close'],
  template: /* html */`
		<div class="group--scrollview" [class]="'rows--' + rows">
			<div class="group--virtual" *virtual="let item of groupedMessages" [mode]="4" [width]="350" [gutter]="0" [reverse]="true">
				<!-- serve un nodo figlio -->
				<div class="listing__item message" [class]="{ me: item.me, typing: item.typing }">
					<div class="message__avatar" [title]="item.name"><span [innerHTML]="item.shortName"></span></div>
					<div class="message__content">
						<div [innerHTML]="item.message | message"></div>
						<div class="typing-indicator">
							<span></span>
							<span></span>
							<span></span>
						</div>
					</div>
				</div>
			</div>
		</div>
		<div class="group--message" [class]="'rows--' + rows">
			<form class="form" [formGroup]="form" (submit)="isValid() && onSubmit($event)" name="form" role="form" novalidate autocomplete="off">
				<div class="group--form group--form--addon" [class]="{ required: controls.message.validators.length, 'addon': controls.message.valid }">
					<!-- <input type="text" class="control--text" [formControl]="controls.message" [placeholder]="'bhere_write_a_message' | label" /> -->
					<button type="button" class="control--pre" (click)="onToggleEmoji()">
						<svg class="emoji" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#emoji"></use></svg>
					</button>
					<textarea class="control--text" [formControl]="controls.message" [placeholder]="'bhere_write_a_message' | label" rows="1" (keydown)="onKeyDown($event)"></textarea>
					<button type="submit" class="control--addon">
						<svg class="copy" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#send"></use></svg>
					</button>
				</div>
			</form>
		</div>
		<div class="group--close">
			<button type="button" class="btn--close" [title]="'title_close' | label" (click)="onClose($event)">
				<svg class="copy" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#close"></use></svg>
			</button>
		</div>
		<div class="group--emoji" [class]="'rows--' + rows" agora-chat-emoji (emoji)="onSelectEmoji($event)" (close)="onToggleEmoji()" *if="showEmoji">
			<div class="group--virtual" *virtual="let item of items" [mode]="1" [width]="40" [gutter]="10" [reverse]="true">
				<!-- serve un nodo figlio -->
				<div class="listing__item emoji">
					<button type="button" class="btn--emoji" (click)="onSelect(item)"><span [innerHTML]="item.char"></span></button>
				</div>
			</div>
			<div class="group--close">
				<button type="button" class="btn--close" [title]="'title_close' | label" (click)="onClose($event)">
					<svg class="copy" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#close"></use></svg>
				</button>
			</div>
		</div>
	`
};
AgoraChatComponent.getFakeList = () => {
  let messages = [{
    'date': 1614592230000,
    'name': 'Jhon Appleseed',
    'message': 'Function-based web-enabled benchmark',
    'clientId': '7341614597544882'
  }, {
    'date': 1614592240000,
    'name': 'Jhon Appleseed',
    'message': 'Customizable exuding superstructure',
    'clientId': '7341614597544882'
  }, {
    'date': 1614592250000,
    'name': 'Gilles Pitkins',
    'message': 'Synergistic interactive archive',
    'clientId': 'cfe9ff5b-f7da-449d-bf5a-3184b5eba6ea'
  }, {
    'date': 1614592260000,
    'name': 'Jhon Appleseed',
    'message': 'Digitized client-server initiative',
    'clientId': '7341614597544882'
  }, {
    'date': 1614592270000,
    'name': 'Jhon Appleseed',
    'message': 'Quality-focused tertiary open system',
    'clientId': '7341614597544882'
  }, {
    'date': 1614592280000,
    'name': 'Jhon Appleseed',
    'message': 'Exclusive uniform middleware',
    'clientId': '7341614597544882'
  }, {
    'date': 1614592290000,
    'name': 'John Pruckner',
    'message': 'Decentralized disintermediate extranet',
    'clientId': 'ae51e846-d043-41e9-bb5c-3189181e5b43'
  }, {
    'date': 1614592300000,
    'name': 'Lamont Georgievski',
    'message': 'Enhanced static approach',
    'clientId': '1961cd9e-93aa-4bd0-b96a-89fcbd36b257'
  }, {
    'date': 1614592310000,
    'name': 'Jhon Appleseed',
    'message': 'Ergonomic clear-thinking info-mediaries',
    'clientId': '7341614597544882'
  }, {
    'date': 1614592320000,
    'name': 'Jeri Pedroni',
    'message': 'Grass-roots dynamic encryption',
    'clientId': '13d69bba-3656-449b-8fe3-d7a87062b044'
  }, {
    'date': 1614592330000,
    'name': 'Frederik Dechelle',
    'message': 'Compatible disintermediate policy',
    'clientId': '9151ebe0-efa8-40b4-a341-b8fd489e9c88'
  }, {
    'date': 1614592340000,
    'name': 'Jhon Appleseed',
    'message': 'Inverse user-facing adapter',
    'clientId': '7341614597544882'
  }, {
    'date': 1614592350000,
    'name': 'Jhon Appleseed',
    'message': 'Future-proofed even-keeled application',
    'clientId': '7341614597544882'
  }, {
    'date': 1614592360000,
    'name': 'Cassie Jonathon',
    'message': 'Profit-focused content-based budgetary management',
    'clientId': '5b3dc6f3-2a3d-493d-aac5-66ddfce2d709'
  }, {
    'date': 1614592370000,
    'name': 'Jhon Appleseed',
    'message': 'Managed intermediate monitoring',
    'clientId': '7341614597544882'
  }, {
    'date': 1614592380000,
    'name': 'Jhon Appleseed',
    'message': 'Exclusive client-server encoding',
    'clientId': '7341614597544882'
  }, {
    'date': 1614592390000,
    'name': 'Jhon Appleseed',
    'message': 'Cross-group system-worthy matrices',
    'clientId': '7341614597544882'
  }, {
    'date': 1614592400000,
    'name': 'Jhon Appleseed',
    'message': 'Upgradable encompassing benchmark',
    'clientId': '7341614597544882'
  }, {
    'date': 1614592410000,
    'name': 'Emelen Beevors',
    'message': 'Function-based full-range knowledge base',
    'clientId': 'c93aea47-ebd8-4e5e-88fd-52053dd35cd1'
  }, {
    'date': 1614592420000,
    'name': 'Jhon Appleseed',
    'message': 'Synergistic system-worthy capability',
    'clientId': '7341614597544882'
  }];
  while (messages.length < 100) {
    messages = messages.concat(messages);
  }
  return messages;
  // return messages.slice(0, 5);
};

AgoraChatComponent.createRandomMessage = text => {
  const message = new ChatMessage({
    date: Date.now(),
    clientId: '9fe0e1b9-6a6b-418b-b916-4bbff3eeb123',
    name: 'Herman frederick',
    message: 'Lorem ipsum dolor'
  }, StateService.state.uid, StateService.state.name);
  return message;
};
AgoraChatComponent.randomMessage = (instance, messages) => {
  const getRandomMessage = function () {
    const others = messages.filter(x => x.id !== '7341614597544882');
    let message = others[Math.floor(others.length * Math.random())];
    message = new ChatMessage({
      date: Date.now(),
      clientId: '9fe0e1b9-6a6b-418b-b916-4bbff3eeb123',
      name: message.name,
      message: message.message
    }, StateService.state.uid, StateService.state.name);
    return message;
  };
  if (AgoraChatComponent.to) {
    clearTimeout(AgoraChatComponent.to);
    AgoraChatComponent.to = null;
  }
  AgoraChatComponent.to = setTimeout(() => {
    const message = getRandomMessage();
    instance.sendMessage(message);
    AgoraChatComponent.randomMessage(instance, messages);
  }, (2 + Math.random() * 6) * 1000);
};class AgoraCheckComponent extends rxcomp.Component {}
AgoraCheckComponent.meta = {
  selector: '[agora-check]',
  inputs: ['value'],
  template: /* html */`
		<svg *if="value == null" class="checkmark idle" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 52 52">
			<circle class="checkmark__circle" cx="26" cy="26" r="25" fill="none"/>
		</svg>
		<svg *if="value === true" class="checkmark success" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 52 52">
			<circle class="checkmark__circle" cx="26" cy="26" r="25" fill="none"/>
			<path class="checkmark__icon" fill="none" d="M14.1 27.2l7.1 7.2 16.7-16.8" stroke-linecap="round"/>
		</svg>
		<svg *if="value === false" class="checkmark error" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 52 52">
			<circle class="checkmark__circle" cx="26" cy="26" r="25" fill="none"/>
			<path class="checkmark__icon" stroke-linecap="round" fill="none" d="M16 16 36 36 M36 16 16 36"/>
		</svg>
	`
};class ModalEvent {
  constructor(data) {
    this.data = data;
  }
}
class ModalResolveEvent extends ModalEvent {}
class ModalRejectEvent extends ModalEvent {}
class ModalService {
  static get hasModal() {
    return this.hasModal_;
  }
  static set hasModal(hasModal) {
    if (this.hasModal_ !== hasModal) {
      this.hasModal_ = hasModal;
      const body = document.querySelector('body');
      hasModal ? body.classList.add('modal-open') : body.classList.remove('modal-open');
    }
  }
  static open$(modal) {
    this.busy$.next(true);
    return (modal.iframe ? rxjs.of( /* html */`<div class="iframe-modal" iframe-modal src="${modal.iframe}"></div>`) : this.getTemplate$(modal)).pipe(
    // startWith(new ModalLoadEvent(Object.assign({}, modal.data, { $src: modal.src }))),
    operators.map(template => {
      return {
        node: this.getNode(template),
        data: modal.data,
        modal: modal
      };
    }), operators.tap(node => {
      this.modal$.next(node);
      this.hasModal = true;
      this.busy$.next(false);
      // this.events$.next(new ModalLoadedEvent(Object.assign({}, modal.data, { $src: modal.src })));
    }), operators.switchMap(node => this.events$), operators.tap(_ => this.hasModal = false));
  }
  static getTemplate$(modal) {
    if (modal.src) {
      return rxjs.from(fetch(modal.src).then(response => {
        return response.text();
      }));
    } else if (modal.template) {
      return rxjs.of(modal.template);
    } else {
      return rxjs.EMPTY;
    }
  }
  static getNode(template) {
    const div = document.createElement('div');
    div.innerHTML = template;
    const node = div.firstElementChild;
    return node;
  }
  static reject(data) {
    this.modal$.next(null);
    this.events$.next(new ModalRejectEvent(data));
  }
  static resolve(data) {
    this.modal$.next(null);
    this.events$.next(new ModalResolveEvent(data));
  }
}
ModalService.modal$ = new rxjs.Subject();
ModalService.events$ = new rxjs.Subject();
ModalService.busy$ = new rxjs.Subject();class LocalStorageService {
  static delete(name) {
    if (this.isLocalStorageSupported()) {
      window.localStorage.removeItem(name);
    }
  }
  static exist(name) {
    if (this.isLocalStorageSupported()) {
      return window.localStorage[name] !== undefined;
    }
  }
  static get(name) {
    let value = null;
    if (this.isLocalStorageSupported() && window.localStorage[name] !== undefined) {
      try {
        value = JSON.parse(window.localStorage[name]);
      } catch (e) {
        console.log('LocalStorageService.get.error parsing', name, e);
      }
    }
    return value;
  }
  static set(name, value) {
    if (this.isLocalStorageSupported()) {
      try {
        const cache = [];
        const json = JSON.stringify(value, function (key, value) {
          if (typeof value === 'object' && value !== null) {
            if (cache.indexOf(value) !== -1) {
              // Circular reference found, discard key
              return;
            }
            cache.push(value);
          }
          return value;
        });
        window.localStorage.setItem(name, json);
      } catch (e) {
        console.log('LocalStorageService.set.error serializing', name, value, e);
      }
    }
  }
  static isLocalStorageSupported() {
    if (this.supported) {
      return true;
    }
    let supported = false;
    try {
      supported = 'localStorage' in window && window.localStorage !== null;
      if (supported) {
        window.localStorage.setItem('test', '1');
        window.localStorage.removeItem('test');
      } else {
        supported = false;
      }
    } catch (e) {
      supported = false;
    }
    this.supported = supported;
    return supported;
  }
}const TIMEOUT = 100;
class AgoraChecklistService {
  static checklist$() {
    return StateService.state$.pipe(operators.first(), operators.map(state => {
      const event = {
        shouldCheckAudio: true,
        shouldCheckVideo: true,
        key: 'checklist_audio_video',
        uid: null,
        checklist: {
          browser: null,
          https: null,
          video: null,
          audio: null,
          rtc: null,
          rtm: null
        },
        errors: {}
      };
      if (state.role === RoleType.Viewer) {
        event.shouldCheckAudio = false;
        event.shouldCheckVideo = false;
      }
      if (DeviceService.platform === DevicePlatform.VRHeadset) {
        event.shouldCheckAudio = true;
        event.shouldCheckVideo = false;
      }
      event.key = `checklist${event.shouldCheckAudio ? '_audio' : ''}${event.shouldCheckVideo ? '_video' : ''}`;
      return event;
    }), operators.switchMap(event => {
      const checklist = LocalStorageService.get(event.key);
      if (checklist === true) {
        Object.keys(event.checklist).forEach(key => {
          event.checklist[key] = true;
        });
      }
      return rxjs.of(event);
    }));
  }
  static isChecked(event) {
    const isChecked = Object.keys(event.checklist).reduce((p, c, i) => {
      const checked = p && event.checklist[c];
      switch (c) {
        case 'audio':
          return checked || !event.shouldCheckAudio;
        case 'video':
          return checked || !event.shouldCheckVideo;
        default:
          return checked;
      }
    }, true);
    return isChecked;
  }
  static isChecked$() {
    return this.checklist$().pipe(operators.map(event => this.isChecked(event)));
  }
  static checkEvent$() {
    return this.checklist$().pipe(operators.switchMap(event => {
      const checklist = Object.keys(event.checklist).reduce((p, c, i) => {
        return p && event.checklist[c];
      }, true);
      if (checklist === true) {
        return rxjs.of(event);
      } else {
        LocalStorageService.set(event.key, false);
        const event$ = new rxjs.Subject();
        const check$ = rxjs.of(event).pipe(operators.delay(1000), operators.switchMap(event => {
          event$.next(event);
          return this.checkBrowserEvent$(event);
        }), operators.switchMap(event => {
          event$.next(event);
          return this.checkHttpsEvent$(event);
        }), operators.switchMap(event => {
          event$.next(event);
          return this.checkAudioEvent$(event);
        }), operators.switchMap(event => {
          event$.next(event);
          return this.checkVideoEvent$(event);
        }), operators.switchMap(event => {
          event$.next(event);
          return this.checkRtcEvent$(event);
        }), operators.switchMap(event => {
          event$.next(event);
          return this.checkRtmEvent$(event);
        }), operators.tap(event => {
          // console.log('AgoraChecklistService', event);
          LocalStorageService.set(event.key, true);
        }));
        return rxjs.merge(event$, check$);
      }
    }));
  }
  static check$() {
    return this.checklist$().pipe(operators.switchMap(event => {
      const checklist = Object.keys(event.checklist).reduce((p, c, i) => {
        return p && event.checklist[c];
      }, true);
      if (checklist === true) {
        return rxjs.of(event);
      } else {
        LocalStorageService.set(event.key, false);
        return rxjs.of(event).pipe(operators.delay(1000), operators.switchMap(event => this.checkBrowserEvent$(event)), operators.switchMap(event => this.checkHttpsEvent$(event)), operators.switchMap(event => this.checkAudioEvent$(event)), operators.switchMap(event => this.checkVideoEvent$(event)), operators.switchMap(event => this.checkRtcEvent$(event)), operators.switchMap(event => this.checkRtmEvent$(event)), operators.tap(event => {
          // console.log('AgoraChecklistService', event);
          LocalStorageService.set(event.key, true);
        }));
      }
    }));
  }
  static checkBrowser$() {
    const browser = AgoraRTC.checkSystemRequirements();
    return rxjs.of(browser);
  }
  static checkBrowserEvent$(event) {
    return this.checkBrowser$().pipe(operators.switchMap(browser => {
      event.checklist.browser = browser;
      if (browser) {
        return rxjs.of(event).pipe(operators.delay(TIMEOUT));
      } else {
        event.errors.browser = LabelPipe.transform('bhere_browser_error');
        return this.checkHttpsEvent$(event).pipe(operators.switchMap(event => {
          {
            return rxjs.throwError(event);
          }
        }));
      }
    }), operators.catchError(error => {
      console.log('checkBrowserEvent$.error', error);
      event.checklist.browser = false;
      event.errors.browser = LabelPipe.transform('bhere_browser_error');
      return rxjs.throwError(event);
    }));
  }
  static checkHttps$() {
    const https = window.location.protocol === 'https:';
    return rxjs.of(https);
  }
  static checkHttpsEvent$(event) {
    return this.checkHttps$().pipe(operators.switchMap(https => {
      event.checklist.https = https;
      if (https) {
        return rxjs.of(event).pipe(operators.delay(TIMEOUT));
      } else {
        event.errors.https = LabelPipe.transform('bhere_https_error');
        {
          return rxjs.throwError(event);
        }
      }
    }), operators.catchError(error => {
      console.log('checkHttpsEvent$.error', error);
      event.checklist.https = false;
      event.errors.https = LabelPipe.transform('bhere_https_error');
      return rxjs.throwError(event);
    }));
  }
  static checkAudio$() {
    return rxjs.from(AgoraService.getDevices()).pipe(operators.map(devices => {
      const audioinput = devices.find(x => x.kind === 'audioinput' && x.deviceId);
      return audioinput != null;
    }));
  }
  static checkAudioEvent$(event) {
    // console.log('checkAudioEvent$', event);
    if (event.shouldCheckAudio) {
      return this.checkAudio$().pipe(operators.switchMap(audio => {
        event.checklist.audio = audio;
        if (audio) {
          return rxjs.of(event).pipe(operators.delay(TIMEOUT));
        } else {
          event.errors.audio = LabelPipe.transform('bhere_audio_error');
          // console.log('checkAudioEvent$.error', event);
          {
            return rxjs.throwError(event);
          }
        }
      }), operators.catchError(error => {
        console.log('checkAudioEvent$.error', error);
        event.checklist.audio = false;
        event.errors.audio = LabelPipe.transform('bhere_audio_error');
        return rxjs.throwError(event);
      }));
    } else {
      return rxjs.of(event);
    }
  }
  static checkVideo$() {
    return rxjs.from(AgoraService.getDevices()).pipe(operators.map(devices => {
      const videoinput = devices.find(x => x.kind === 'videoinput' && x.deviceId);
      return videoinput != null;
    }));
  }
  static checkVideoEvent$(event) {
    if (event.shouldCheckVideo) {
      return this.checkVideo$().pipe(operators.switchMap(video => {
        event.checklist.video = video;
        if (video) {
          return rxjs.of(event).pipe(operators.delay(TIMEOUT));
        } else {
          event.errors.video = LabelPipe.transform('bhere_video_error');
          {
            return rxjs.throwError(event);
          }
        }
      }), operators.catchError(error => {
        console.log('checkVideoEvent$.error', error);
        event.checklist.video = false;
        event.errors.video = LabelPipe.transform('bhere_video_error');
        return rxjs.throwError(event);
      }));
    } else {
      return rxjs.of(event);
    }
  }
  static checkRtc$() {
    return rxjs.from(AgoraService.checkRtcConnection());
  }
  static checkRtcEvent$(event) {
    return this.checkRtc$().pipe(operators.switchMap(uid => {
      event.uid = uid;
      event.checklist.rtc = uid !== false;
      if (uid) {
        return rxjs.of(event).pipe(operators.delay(TIMEOUT));
      } else {
        event.errors.rtc = LabelPipe.transform('bhere_rtc_error');
        {
          return rxjs.throwError(event);
        }
      }
    }), operators.catchError(error => {
      console.log('checkRtcEvent$.error', error);
      event.checklist.rtc = false;
      event.errors.rtc = LabelPipe.transform('bhere_rtc_error');
      return rxjs.throwError(event);
    }));
  }
  static checkRtm$(uid) {
    return rxjs.from(AgoraService.checkRtmConnection(uid));
  }
  static checkRtmEvent$(event) {
    return this.checkRtm$(event.uid).pipe(operators.switchMap(uid => {
      event.checklist.rtm = uid !== false;
      if (uid) {
        return rxjs.of(event);
      } else {
        event.errors.rtm = LabelPipe.transform('bhere_rtm_error');
        return rxjs.throwError(event);
      }
    }), operators.catchError(error => {
      console.log('checkRtmEvent$.error', error);
      event.checklist.rtm = false;
      event.errors.rtm = LabelPipe.transform('bhere_rtm_error');
      return rxjs.throwError(event);
    }));
  }
}class AgoraConfigureFirewallModalComponent extends rxcomp.Component {
  onClose() {
    ModalService.resolve();
  }
}
AgoraConfigureFirewallModalComponent.meta = {
  selector: '[agora-configure-firewall-modal]',
  template: /* html */`
		<div class="modal__header">
			<button type="button" class="btn--close" (click)="onClose()">
				<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#close"></use></svg>
			</button>
		</div>
		<div class="container">
			<div class="form" [innerHTML]="'bhere_configure_firewall' | label"></div>
			<div class="group--cta">
				<button type="button" class="btn--accept" (click)="onClose()">
					<span>Chiudi</span>
				</button>
			</div>
		</div>
	`
};
AgoraConfigureFirewallModalComponent.chunk = () => /* html */'<div class="configure-firewall-modal" agora-configure-firewall-modal></div>';class AgoraChecklistComponent extends rxcomp.Component {
  onInit() {
    this.platform = DeviceService.platform;
    this.checklist = {};
    this.errors = {};
    this.state = {};
    this.busy = true;
    this.shouldCheckAudio = false;
    this.shouldCheckVideo = false;
    AgoraChecklistService.checkEvent$().pipe(operators.takeUntil(this.unsubscribe$)).subscribe(event => {
      // console.log('AgoraChecklistService', event, event.errors);
      this.shouldCheckAudio = event.shouldCheckAudio;
      this.shouldCheckVideo = event.shouldCheckVideo;
      this.checklist = event.checklist;
      this.errors = event.errors || {};
      // console.log(JSON.stringify(event.errors));
      const success = AgoraChecklistService.isChecked(event);
      if (success) {
        this.checklist.success = success;
        this.busy = false;
        this.pushChanges();
        if (this.state.role === RoleType.SmartDevice) {
          this.onNext();
        }
      } else {
        this.pushChanges();
      }
      // console.log(event);
    }, error => {
      // console.log('AgoraChecklistService.error', error);
      this.errors = error.errors || {};
      this.checklist.error = true;
      this.busy = false;
      this.pushChanges();
    });
  }
  onNext() {
    this.checked.next(this.checklist);
  }
  openHttps() {
    window.location.href = window.location.href.replace('http://', 'https://').replace(':5000', ':6443');
  }
  showFirewallConfiguration() {
    ModalService.open$({
      template: AgoraConfigureFirewallModalComponent.chunk()
    }).pipe(operators.first()).subscribe();
  }
}
AgoraChecklistComponent.meta = {
  selector: '[agora-checklist]',
  outputs: ['checked'],
  template: /* html */`
	<div class="group--info">
		<div class="group--info__content stagger--childs">
			<div class="title" *if="busy" [innerHTML]="'bhere_checklist_busy' | label"></div>
			<div class="title" *if="checklist.success" [innerHTML]="'bhere_checklist_success' | label"></div>
			<div class="title" *if="checklist.error" [innerHTML]="'bhere_checklist_error' | label"></div>
			<ul class="group--checklist stagger--childs">
				<li class="checklist__item check"><span>Browser</span> <span agora-check [value]="checklist.browser"></span></li>
				<li class="checklist__item error" *if="errors.browser"><a class="btn--link" href="https://browsehappy.com/" target="_blank" rel="noopener" [innerHTML]="errors.browser"></a></li>
				<li class="checklist__item check"><span>Https</span> <span agora-check [value]="checklist.https"></span></li>
				<li class="checklist__item error" *if="errors.https"><a class="btn--link" (click)="openHttps()" [innerHTML]="errors.https"></a></li>
				<li class="checklist__item check" *if="shouldCheckAudio"><span>Audio</span> <span agora-check [value]="checklist.audio"></span></li>
				<li class="checklist__item error" *if="errors.audio"><span [innerHTML]="errors.audio"></span></li>
				<li class="checklist__item check" *if="shouldCheckVideo"><span>Video</span> <span agora-check [value]="checklist.video"></span></li>
				<li class="checklist__item error" *if="errors.video"><span [innerHTML]="errors.video"></span></li>
				<li class="checklist__item check"><span>Realtime Communication</span> <span agora-check [value]="checklist.rtc"></span></li>
				<li class="checklist__item error" *if="errors.rtc"><a class="btn--link" (click)="showFirewallConfiguration()" [innerHTML]="errors.rtc"></a></li>
				<li class="checklist__item check"><span>Realtime Messaging</span> <span agora-check [value]="checklist.rtm"></span></li>
				<li class="checklist__item error" *if="errors.rtm"><a class="btn--link" (click)="showFirewallConfiguration()" [innerHTML]="errors.rtm"></a></li>
			</ul>
			<button type="submit" class="btn--next" [class]="{ disabled: !checklist.success, ready: checklist.success }" (click)="onNext()">
				<span [innerHTML]="'bhere_proceed' | label"></span>
			</button>
		</div>
	</div>
	`
};class AudioStreamService {
  static get context() {
    if (!this.context_ && 'AudioContext' in window) {
      this.context_ = new AudioContext();
    }
    return this.context_;
  }

  /*
  static get processorNode() {
  	if (!this.processorNode_) {
  		this.processorNode_ = this.context.createScriptProcessor(BUFF_SIZE, 1, 1);
  	}
  	return this.processorNode_;
  }
  */

  /*
  static get gain() {
  	if (!this.gain_) {
  		this.gain_ = this.context.createGain();
  	}
  	return this.gain_;
  }
  */

  static get analyser() {
    if (!this.analyser_) {
      try {
        this.analyser_ = this.context.createAnalyser();
      } catch (error) {
        console.log('AudioStreamService.analyser', error);
      }
    }
    return this.analyser_;
  }
  static addSource(streamOrElement) {
    const key = streamOrElement instanceof MediaStream ? streamOrElement.id : streamOrElement;
    if (!this.sources_[key]) {
      if (streamOrElement instanceof MediaStream) {
        this.sources_[key] = this.context.createMediaStreamSource(streamOrElement.clone());
      } else {
        this.sources_[key] = this.context.createMediaElementSource(streamOrElement);
      }
      // this.sources_[key] = streamOrElement instanceof MediaStream ? this.context.createMediaStreamSource(streamOrElement) : this.context.createMediaElementSource(streamOrElement);
    }

    return this.sources_[key];
  }
  static removeSource(streamOrElement) {
    const key = streamOrElement instanceof MediaStream ? streamOrElement.id : streamOrElement;
    return this.removeSourceKey(key);
  }
  static removeSourceKey(key) {
    // console.log('AudioStreamService.removeSourceKey', key);
    let source;
    if (this.sources_[key]) {
      source = this.sources_[key];
      /*
      if (source.mediaStream) {
      	source.mediaStream.stop();
      }
      source.stop();
      */
      if (this.analyser) {
        source.disconnect(this.analyser);
      }
      source.disconnect();
      delete this.sources_[key];
    }
    return source;
  }
  static frequency$(streamOrElement, fftSize) {
    if (fftSize === void 0) {
      fftSize = 64;
    }
    if (fftSize % 2 === 1) {
      throw fftSize;
    }
    const state = new Uint8Array(fftSize / 2);
    const context = this.context;
    if (context) {
      const analyser = this.analyser;
      if (analyser) {
        // Connect the output of the analyser to the destination
        // analyser.connect(context.destination); // no audio !
        // console.log(analyser.fftSize); // 2048 by default
        // console.log(analyser.frequencyBinCount); // will give us 1024 data points
        analyser.fftSize = fftSize; // 64
        // console.log(analyser.frequencyBinCount); // fftSize/2 = 32 data points
        const source = this.addSource(streamOrElement);
        // source.connect(context.destination); // no audio!
        // Connect the output of the source to the input of the analyser
        source.connect(analyser);
      }
      const state$ = new rxjs.BehaviorSubject(state);
      return AudioStreamService.frame$.pipe(operators.withLatestFrom(state$), operators.map(_ref => {
        let [deltaTime, state] = _ref;
        if (analyser) {
          // Get the new frequency data
          analyser.getByteFrequencyData(state);
          /*
          const max = state.reduce((p, c, i) => {
          	return Math.max(c, p);
          }, 0);
          if (max > 0) {
          	// console.log(max);
          }
          */
          // Update the visualisation
        }

        return state;
      }), operators.tap(state => state$.next(state)), operators.finalize(() => {
        this.removeSource(streamOrElement);
      }));
    } else {
      return rxjs.of(state);
    }
  }

  // unused
  static volume$(streamOrElement) {
    const state = {
      volume: 0,
      clipped: false
    };
    const context = this.context;
    // console.log('AudioStreamService.volume$', context, state);
    if (context) {
      const source = this.addSource(streamOrElement);
      const meter = AudioStreamService.audioMeterCreate();
      source.connect(meter);
      const state$ = new rxjs.BehaviorSubject(state);
      return AudioStreamService.frame$.pipe(operators.withLatestFrom(state$), operators.map(_ref2 => {
        let [deltaTime, state] = _ref2;
        state.clipped = meter.checkClipping();
        state.volume = meter.volume;
        return state;
      }), operators.tap(state => state$.next(state)), operators.finalize(() => {
        this.removeSource(streamOrElement);
      }));
    } else {
      return rxjs.of(state);
    }
  }

  // unused
  static audioMeterCreate(clipLevel, averaging, clipLag) {
    if (clipLevel === void 0) {
      clipLevel = 0.98;
    }
    if (averaging === void 0) {
      averaging = 0.95;
    }
    if (clipLag === void 0) {
      clipLag = 750;
    }
    const context = this.context;
    if (context) {
      const processor = context.createScriptProcessor(512);
      processor.onaudioprocess = this.audioMeterProcess;
      processor.checkClipping = this.audioMeterClip;
      processor.dispose = this.audioMeterDispose;
      processor.clipping = false;
      processor.lastClip = 0;
      processor.volume = 0;
      processor.clipLevel = clipLevel;
      processor.averaging = averaging;
      processor.clipLag = clipLag;
      // this will have no effect, since we don't copy the input to the output,
      // but works around a current Chrome bug.
      processor.connect(context.destination);
      return processor;
    }
  }
  static audioMeterProcess(event) {
    const buffer = event.inputBuffer.getChannelData(0);
    const bufferLength = buffer.length;
    let sum = 0;
    let x;

    // Do a root-mean-square on the samples: sum up the squares...
    for (let i = 0; i < bufferLength; i++) {
      x = buffer[i];
      if (Math.abs(x) >= this.clipLevel) {
        this.clipping = true;
        this.lastClip = window.performance.now();
      }
      sum += x * x;
    }

    // ... then take the square root of the sum.
    const rms = Math.sqrt(sum / bufferLength);

    // Now smooth this out with the averaging factor applied
    // to the previous sample - take the max here because we
    // want 'fast attack, slow release.'
    this.volume = Math.max(rms, this.volume * this.averaging);
  }
  static audioMeterClip() {
    if (!this.clipping) {
      return false;
    }
    if (this.lastClip + this.clipLag < window.performance.now()) {
      this.clipping = false;
    }
    return this.clipping;
  }
  static audioMeterDispose() {
    this.disconnect();
    this.onaudioprocess = null;
  }
  static step$(previous) {
    /**
     * This function returns an observable that will emit the next frame once the
     * browser has returned an animation frame step. Given the previous frame it calculates
     * the delta time, and we also clamp it to 30FPS in case we get long frames.
     */
    return rxjs.Observable.create(observer => {
      requestAnimationFrame(startTime => {
        // Millis to seconds
        const deltaTime = previous ? (startTime - previous.startTime) / 1000 : 0;
        observer.next({
          startTime,
          deltaTime
        });
      });
    }).pipe(operators.map(frame => {
      if (frame.deltaTime > 1 / 30) {
        frame.deltaTime = 1 / 30;
      }
      return frame;
    }));
  }
  static dispose() {
    Object.keys(this.sources_).forEach(key => {
      this.removeSourceKey(key);
    });
    const analyser = this.analyser;
    if (analyser) {
      analyser.disconnect();
    }
    this.sources_ = {};
    // this.context_.close().then(() => console.log('AudioStreamService.dispose'));
    // this.context_ = null;
  }
}

AudioStreamService.sources_ = {};
AudioStreamService.frame$ = rxjs.of(undefined).pipe(operators.expand(value => AudioStreamService.step$(value)),
// Expand emits the first value provided to it, and in this
//  case we just want to ignore the undefined input frame
operators.filter(frame => frame !== undefined), operators.map(frame => frame.deltaTime), operators.share());class AgoraDevicePreviewComponent extends rxcomp.Component {
  get video() {
    return this.video_;
  }
  set video(video) {
    if (this.video_ !== video) {
      this.video_ = video;
      if (this.change) {
        this.change.next();
        this.init();
        this.initStream();
      }
    }
  }
  get audio() {
    return this.audio_;
  }
  set audio(audio) {
    if (this.audio_ !== audio) {
      this.audio_ = audio;
      if (this.change) {
        this.change.next();
        this.init();
        this.initStream();
      }
    }
  }
  get hasPreview() {
    return this.platform !== DevicePlatform.IOS && this.platform !== DevicePlatform.VRHeadset;
  }
  onInit() {
    this.init();
  }
  init() {
    if (this.initialized_) {
      return;
    }
    this.initialized_ = true;
    this.platform = DeviceService.platform;
    const {
      node
    } = rxcomp.getContext(this);
    this.onLoadedMetadata = this.onLoadedMetadata.bind(this);
    const preview = this.preview = node.querySelector('video');
    preview.addEventListener('loadedmetadata', this.onLoadedMetadata);
    const audio = node.querySelector('.audio');
    if (this.hasPreview) {
      this.bars = new Array(32).fill(0).map(x => {
        const bar = document.createElement('div');
        bar.classList.add('bar');
        audio.appendChild(bar);
        return bar;
      });
    }
  }
  onDestroy() {
    const preview = this.preview;
    preview.removeEventListener('loadedmetadata', this.onLoadedMetadata);
    if (this.hasPreview) {
      AudioStreamService.dispose();
    }
  }
  initStream() {
    const preview = this.preview;
    if (!this.preview) {
      return;
    }
    // console.log(this.video_, this.audio_);
    const {
      node
    } = rxcomp.getContext(this);
    if (this.video_ || this.audio_) {
      node.classList.add('ready');
      if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
        const state = StateService.state;
        const quality = getStreamQuality(state);
        const options = {
          video: this.video_ ? {
            deviceId: this.video_,
            width: {
              ideal: quality.resolution.width
            },
            height: {
              ideal: quality.resolution.height
            },
            frameRate: {
              ideal: quality.frameRate.min,
              max: quality.frameRate.max
            }
          } : false,
          audio: this.audio_ ? {
            deviceId: this.audio_
          } : false
        };
        if (this.platform === DevicePlatform.IOS) {
          options.video.facingMode = 'user';
        }
        // console.log('AgoraDevicePreviewComponent.initStream.getUserMedia', options);
        navigator.mediaDevices.getUserMedia(options).then(stream => {
          if (this.hasPreview) {
            if ('srcObject' in preview) {
              preview.srcObject = stream;
            } else {
              preview.src = window.URL.createObjectURL(stream);
            }
            if (this.audio_) {
              this.analyzeData(stream);
            }
            this.loadingStream_ = stream;
          } else {
            this.stream.next(stream);
          }
        }).catch(error => {
          console.log('AgoraDevicePreviewComponent.initStream.error', error.name, error.message);
          this.stream.next(null);
        });
      }
    } else {
      node.classList.remove('ready');
      if (this.hasPreview) {
        if ('srcObject' in preview) {
          preview.srcObject = null;
        } else {
          preview.src = null;
        }
        this.analyzeData(null);
      }
      this.stream.next(null);
    }
  }
  onLoadedMetadata(event) {
    // console.log('AgoraDevicePreview.onLoadedMetadata', event);
    const {
      node
    } = rxcomp.getContext(this);
    node.classList.add('loaded');
    this.preview.play();
    this.stream.next(this.loadingStream_);
  }
  analyzeData(stream) {
    if (this.frequencySubscription) {
      this.frequencySubscription.unsubscribe();
    }
    // console.log('AgoraDevicePreviewComponent.analyzeData', stream);
    if (stream) {
      this.frequencySubscription = AudioStreamService.frequency$(stream, 64).pipe(operators.takeUntil(this.unsubscribe$)).subscribe(frequency => {
        // 32 data points
        // console.log(frequency);
        const spacing = 100 / 32;
        const bars = this.bars;
        bars.forEach((bar, i) => {
          const pow = Math.min(100, 5 + frequency[i]) / 100;
          bar.style.left = i * spacing + '%';
          bar.style.transform = `scale(1,${pow})`;
          bar.style.opacity = pow;
        });
      });
    }
  }
}
AgoraDevicePreviewComponent.meta = {
  selector: '[agora-device-preview]',
  outputs: ['stream', 'change'],
  inputs: ['video', 'audio']
};class AgoraDeviceComponent extends rxcomp.Component {
  get hasPreview() {
    return this.platform !== DevicePlatform.IOS && this.platform !== DevicePlatform.VRHeadset; // && this.form && this.form.value.video;
  }

  onInit() {
    this.platform = DeviceService.platform;
    this.isHttps = window.location.protocol === 'https:';
    this.state = {};
    this.devices = {
      videos: [],
      audios: []
    };
    this.stream = null;
    this.form = null;
    if (this.isHttps) {
      const agora = this.agora = AgoraService.getSingleton();
      StateService.state$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(state => {
        // console.log('AgoraDeviceComponent.state', state);
        this.state = state;
        this.pushChanges();
      });
      if (agora) {
        agora.devices$().subscribe(devices => {
          // console.log(devices);
          this.devices = devices;
          this.initForm(devices);
          this.pushChanges();
        }, error => {
          console.log('AgoraDeviceComponent.devices$.error', error);
          // alert('AgoraDeviceComponent ' + error); // !!!
        });
      }
    }
  }

  openHttps(event) {
    window.location.href = window.location.href.replace('http://', 'https://').replace(':5000', ':6443');
  }
  initForm(devices) {
    const form = this.form = new rxcompForm.FormGroup({
      video: new rxcompForm.FormControl(null, devices.videos.length ? rxcompForm.Validators.RequiredValidator() : undefined),
      audio: new rxcompForm.FormControl(null, devices.audios.length ? rxcompForm.Validators.RequiredValidator() : undefined)
    });
    const controls = this.controls = form.controls;
    const videoOptions = devices.videos.map(x => {
      return {
        id: x.deviceId,
        name: x.label
      };
    });
    if (videoOptions.length > 0) {
      videoOptions.unshift({
        id: null,
        name: 'bhere_select_video' // LabelPipe.transform('bhere_select_video')
      });
    }

    controls.video.options = videoOptions;
    const audioOptions = devices.audios.map(x => {
      return {
        id: x.deviceId,
        name: x.label
      };
    });
    if (audioOptions.length > 0) {
      audioOptions.unshift({
        id: null,
        name: 'bhere_select_audio' // LabelPipe.transform('bhere_select_audio')
      });
    }

    controls.audio.options = audioOptions;
    form.changes$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(changes => {
      // console.log('AgoraDeviceComponent.changes$', form.value);
      this.pushChanges();
    });
  }
  onStreamDidChange(event) {
    this.stream = null;
    this.pushChanges();
  }
  onStream(stream) {
    this.stream = stream;
    this.pushChanges();
  }
  isValid() {
    const isValid = this.form.valid && (this.stream || !this.hasPreview);
    return isValid;
  }
  onEnter(event) {
    const preferences = this.form.value;
    const devices = this.devices;
    devices.video = devices.videos.find(x => x.deviceId === preferences.video);
    devices.audio = devices.audios.find(x => x.deviceId === preferences.audio);
    this.enter.next(devices);
  }
}
AgoraDeviceComponent.meta = {
  selector: '[agora-device]',
  outputs: ['enter'],
  template: /* html */`
	<div class="group--info" *if="!isHttps">
		<div class="group--info__content stagger--childs">
			<div class="title" [innerHTML]="'bhere_invalid_protocol' | label"></div>
			<div class="info" [innerHTML]="'bhere_reload_in_https' | label"></div>
			<button type="button" class="btn--connect" (click)="openHttps($event)">
				<span [innerHTML]="'bhere_reload' | label"></span>
			</button>
		</div>
	</div>
	<div class="group--info" *if="form">
		<form class="form" [formGroup]="form" (submit)="isValid() && onEnter($event)" name="form" role="form" novalidate autocomplete="off">
			<!-- PREVIEW -->
			<div class="agora-device-preview" agora-device-preview [video]="controls.video.value" [audio]="controls.audio.value" (stream)="onStream($event)" (change)="onStreamDidChange($event)" *if="this.hasPreview">
				<video class="video" muted></video>
				<div class="audio"></div>
			</div>
			<div class="group--info__content stagger--childs">
				<!-- VIDEO -->
				<div control-custom-select [control]="controls.video" label="Video" *if="devices.videos.length"></div>
				<!-- AUDIO -->
				<div control-custom-select [control]="controls.audio" label="Audio" *if="devices.audios.length"></div>
				<div class="info" *if="!isValid()" [innerHTML]="'bhere_select_video_audio' | label"></div>
				<div class="info" *if="isValid()" [innerHTML]="'bhere_video_audio_connected' | label"></div>
				<button type="submit" class="btn--connect" [class]="{ disabled: !isValid() }">
					<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#call"></use></svg>
					<span *if="!state.connecting" [innerHTML]="'bhere_enter' | label"></span>
					<span *if="state.connecting" [innerHTML]="'bhere_connecting' | label"></span>
				</button>
			</div>
		</form>
	</div>
	`
};const ViewType = {
  WaitingRoom: {
    id: 1,
    name: 'waiting-room'
  },
  Panorama: {
    id: 2,
    name: 'panorama'
  },
  PanoramaGrid: {
    id: 3,
    name: 'panorama-grid'
  },
  Room3d: {
    id: 4,
    name: 'room-3d'
  },
  Model: {
    id: 5,
    name: 'model'
  },
  Media: {
    id: 6,
    name: 'media'
  }
};
const ViewItemType = {
  Nav: {
    id: 1,
    name: 'nav'
  },
  Plane: {
    id: 2,
    name: 'plane'
  },
  CurvedPlane: {
    id: 3,
    name: 'curved-plane'
  },
  Model: {
    id: 4,
    name: 'model'
  },
  Texture: {
    id: 5,
    name: 'texture'
  }
};
class View {
  // 'liked'

  constructor(options) {
    if (options) {
      Object.assign(this, options);
      this.updateIndices(options.items);
    }
    this.items = (this.items || []).filter(item => filterViewItem(item)).map(item => mapViewItem(item));
    if (this.tiles) {
      this.tiles = this.tiles.map(tile => mapViewTile(tile));
    }
    this.originalItems = this.items.slice();
    this.lastOrientation = {
      latitude: 0,
      longitude: 0
    };
    this.path = true;
  }
  get payload() {
    const payload = {};
    Object.keys(this).forEach(key => {
      if (View.allowedProps.indexOf(key) !== -1) {
        switch (key) {
          case 'items':
            payload[key] = this[key].map(item => mapViewItem(item).payload);
            break;
          case 'tiles':
            payload[key] = this[key].map(tile => mapViewTile(tile).payload);
            break;
          default:
            payload[key] = this[key];
        }
      }
    });
    return payload;
  }
  get pathItems() {
    return this.items.filter(x => x.path);
  }
  get shortType() {
    return this.type ? this.type.split('-').map(x => x.substring(0, 1).toUpperCase()).join('') : '??';
  }
  updateIndices(items) {
    if (items) {
      let publisherStreamIndex = 0;
      let attendeeStreamIndex = 0;
      let smartDeviceStream = 0;
      let publisherScreenIndex = 0;
      let attendeeScreenIndex = 0;
      items.forEach((item, index) => {
        item.index = index;
        if (item.asset) {
          switch (item.asset.file) {
            case 'publisherStream':
              item.asset.index = publisherStreamIndex++;
              break;
            case 'nextAttendeeStream':
              item.asset.index = attendeeStreamIndex++;
              break;
            case 'smartDeviceStream':
              item.asset.index = smartDeviceStream++;
              break;
            case 'publisherScreen':
              item.asset.index = publisherScreenIndex++;
              break;
            case 'attendeeScreen':
              item.asset.index = attendeeScreenIndex++;
              break;
          }
        }
        /*
        if (item.asset && item.asset.file === 'publisherStream') {
        	item.asset.index = publisherStreamIndex++;
        }
        if (item.asset && item.asset.file === 'nextAttendeeStream') {
        	item.asset.index = attendeeStreamIndex++;
        }
        */
      });
    }
  }
}
View.allowedProps = ['id', 'type', 'name', 'hidden', 'likes', 'asset', 'items', 'orientation', 'zoom', 'ar', 'tiles', 'invertAxes', 'flipAxes'];
class PanoramaView extends View {
  constructor(options) {
    super(options);
  }
}
class PanoramaGridView extends View {
  static mapTiles(tiles, flipAxes, invertAxes, folder) {
    if (tiles === void 0) {
      tiles = [];
    }
    if (flipAxes === void 0) {
      flipAxes = false;
    }
    if (invertAxes === void 0) {
      invertAxes = false;
    }
    if (folder === void 0) {
      folder = '';
    }
    const axes = flipAxes ? -1 : 1;
    return tiles.map((tile, i) => {
      const indices = new THREE.Vector2();
      tile = typeof tile === 'string' ? {
        id: i + 1,
        asset: {
          folder: folder,
          file: tile
        },
        navs: []
      } : tile;
      tile.asset.file.replace(/_x([-|\d]+)_y([-|\d]+)/g, (a, b, c) => {
        if (invertAxes) {
          indices.y = parseInt(b);
          indices.x = parseInt(c) * axes;
        } else {
          indices.x = parseInt(b);
          indices.y = parseInt(c) * axes;
        }
      });
      return {
        id: tile.id,
        type: Object.assign({}, ViewType.PanoramaGrid),
        asset: tile.asset,
        navs: tile.navs || [],
        indices
      };
    });
  }
  set index(index) {
    if (this.index_ !== index) {
      this.index_ = index;
      this.tiles.forEach((tile, i) => tile.selected = i === index);
      this.updateCurrentItems();
      // console.log('PanoramaGridView.index.set', index, this.items);
      this.index$.next(index);
    }
  }
  get index() {
    return this.index_;
  }
  constructor(options) {
    options.tiles = PanoramaGridView.mapTiles(options.tiles, options.flipAxes, options.invertAxes, options.asset ? options.asset.folder : '');
    super(options);
    /*
    if (!this.tiles.length) {
    	throw new Error('PanoramaGridView.constructor tile list is empty!');
    }
    */
    this.index_ = 0;
    this.index$ = new rxjs.Subject();
    this.tiles.forEach((tile, i) => tile.selected = i === 0);
    if (this.tiles.length) {
      this.items = this.originalItems.concat(this.tiles[0].navs);
      this.asset = this.tiles[0].asset;
    }
  }
  updateCurrentItems() {
    this.items = this.originalItems.concat(this.tiles[this.index_].navs);
  }
  getTileIndex(x, y) {
    return this.tiles.reduce((p, c, i) => {
      if (c.indices.x === x && c.indices.y === y) {
        return i;
      } else {
        return p;
      }
    }, -1);
  }
  hasTile(x, y) {
    return this.getTileIndex(x, y) !== -1;
  }
  getTile(x, y) {
    const index = this.getTileIndex(x, y);
    if (index !== -1) {
      this.index = index;
      return this.tiles[index];
    }
  }
}
class Room3DView extends View {
  constructor(options) {
    super(options);
  }
}
class ModelView extends View {
  constructor(options) {
    super(options);
  }
}
class MediaView extends View {
  constructor(options) {
    super(options);
  }
}
class ViewItem {
  constructor(options) {
    if (options) {
      Object.assign(this, options);
    }
    this.path = true;
    const links = this.links || (this.link ? [this.link] : []);
    this.links = links;
  }
  get firstLink() {
    return this.links && this.links.length ? this.links[0] : null;
  }
  get payload() {
    const payload = {};
    Object.keys(this).forEach(key => {
      if (ViewItem.allowedProps.indexOf(key) !== -1) {
        payload[key] = this[key];
      }
    });
    if (payload.link && (!payload.link.title || !payload.link.href)) {
      delete payload.link;
    }
    return payload;
  }
  get hasPanel() {
    return this.type.name === ViewItemType.Nav.name && (this.title && this.title !== '' || this.abstract && this.abstract !== '' || this.asset || this.link);
  }
}
ViewItem.allowedProps = ['id', 'type', 'title', 'abstract', 'asset', 'link', 'links', 'viewId', 'hook', 'hookExtra', 'keepOrientation', 'important', 'transparent', 'position', 'rotation', 'scale', 'radius', 'height', 'arc'];
class NavViewItem extends ViewItem {}
class ViewTile {
  constructor(options) {
    if (options) {
      Object.assign(this, options);
    }
    this.navs = (this.navs || []).map(nav => mapViewItem(nav));
    this.originalItems = this.navs.slice();
  }
  get payload() {
    const payload = {};
    Object.keys(this).forEach(key => {
      if (ViewTile.allowedProps.indexOf(key) !== -1) {
        switch (key) {
          case 'navs':
            payload[key] = this[key].map(nav => mapViewItem(nav).payload);
            break;
          default:
            payload[key] = this[key];
        }
      }
    });
    return payload;
  }
}
ViewTile.allowedProps = ['id', 'asset', 'navs'];
function mapView(view) {
  switch (view.type.name) {
    case ViewType.Panorama.name:
      view = new PanoramaView(view);
      break;
    case ViewType.PanoramaGrid.name:
      view = new PanoramaGridView(view);
      break;
    case ViewType.Room3d.name:
      view = new Room3DView(view);
      break;
    case ViewType.Model.name:
      view = new ModelView(view);
      break;
    case ViewType.Media.name:
      view = new MediaView(view);
      break;
    default:
      view = new View(view);
  }
  return view;
}
function filterViewItem(item) {
  let flag;
  switch (item.type.name) {
    case ViewItemType.Nav.name:
      flag = item.viewId == null || isNavMove(item) || StateService.state.navigable;
      break;
    default:
      flag = true;
  }
  return flag;
}
function mapViewItem(item) {
  switch (item.type.name) {
    case ViewItemType.Nav.name:
      item = new NavViewItem(item);
      break;
    default:
      item = new ViewItem(item);
  }
  return item;
}
function mapViewTile(tile) {
  return new ViewTile(tile);
}
function isNavMove(item) {
  return !isValidText(item.title) && !isValidText(item.abstract);
}
function isValidText(text) {
  return text && text.length > 0;
}class Path {
  constructor(options) {
    if (options) {
      Object.assign(this, options);
    }
    this.items = this.items || [];
    this.originalItems = this.items.slice();
  }
  get payload() {
    const payload = {};
    Object.keys(this).forEach(key => {
      if (View.allowedProps.indexOf(key) !== -1) {
        switch (key) {
          default:
            payload[key] = this[key];
        }
      }
    });
    return payload;
  }
}
Path.allowedProps = ['id', 'name', 'items'];
function mapPath(map) {
  map = new Path(map);
  return map;
}const DEFAULT_PATH = {
  id: null,
  name: 'Principale',
  items: []
};
class PathService {
  static set paths(paths) {
    this.paths$.next(paths);
  }
  static get paths() {
    return this.paths$.getValue();
  }
  static set path(path) {
    this.path$.next(path);
  }
  static get path() {
    return this.path$.getValue();
  }
  static getCurrentPath$(pathId) {
    if (pathId === void 0) {
      pathId = null;
    }
    return this.pathGet$().pipe(operators.switchMap(paths => {
      this.paths = paths;
      let path = DEFAULT_PATH;
      if (pathId) {
        const selectedPath = paths.find(x => x.id === pathId);
        if (selectedPath) {
          path = selectedPath;
        }
      }
      this.path = path;
      return this.path$;
    }));
  }
  static pathGet$() {
    if (environment.flags.usePaths) {
      return HttpService.get$('/api/path').pipe(operators.map(data => {
        data.paths = data.paths.map(path => mapPath(path));
        data.paths.unshift(DEFAULT_PATH);
        return data.paths;
      }));
    } else {
      return rxjs.of([]);
    }
  }
  static addPath(path) {
    const paths = this.paths.slice();
    paths.push(path);
    this.paths = paths;
    this.path = path;
  }
  static editPath(path) {
    // console.log('PathService.editPath', path);
    const paths = this.paths.slice();
    const index = paths.reduce((p, c, i) => {
      return c.id === path.id ? i : p;
    }, -1);
    // console.log('PathService.editPath', paths, index);
    if (index > 0) {
      let currentPath = this.path;
      if (currentPath.id === path.id) {
        currentPath = path;
      }
      // console.log('PathService.editPath', currentPath);
      paths.splice(index, 1, path);
      this.paths = paths;
      this.path = currentPath;
    }
  }
  static deletePath(path) {
    const paths = this.paths.slice();
    const index = paths.indexOf(path);
    if (index > 0) {
      paths.splice(index, 1);
      this.paths = paths;
      let currentPath = this.path;
      if (currentPath.id === path.id) {
        currentPath = paths[0];
      }
      this.path = currentPath;
    }
  }
  static pathCreate$(path) {
    return HttpService.post$('/api/path', path).pipe(operators.map(path => mapPath(path)));
  }
  static pathUpdate$(path) {
    return HttpService.put$(`/api/path/${path.id}`, path).pipe(operators.map(x => mapPath(x)));
  }
  static pathDelete$(path) {
    return HttpService.delete$(`/api/path/${path.id}`);
  }

  /*
  static itemCreate$(path, item) {
  	return HttpService.post$(`/api/path/${path.id}/item`, item).pipe(
  		map(item => mapViewItem(item)),
  	);
  }
  
  static itemUpdate$(path, item) {
  	item = mapViewItem(item); // !!! ??
  	return HttpService.put$(`/api/path/${path.id}/item/${item.id}`, item.payload).pipe(
  		map(item => mapViewItem(item)),
  	);
  }
  
  static itemDelete$(path, item) {
  	return HttpService.delete$(`/api/path/${path.id}/item/${item.id}`);
  }
  */
}
PathService.paths$ = new rxjs.BehaviorSubject([DEFAULT_PATH]);
PathService.path$ = new rxjs.BehaviorSubject(DEFAULT_PATH);class AgoraLinkComponent extends rxcomp.Component {
  get selfServiceTourRoute() {
    const pathId = this.form.get('path').value;
    const route = [RoutePipe.transform(':lang.selfServiceTour')];
    if (pathId) {
      route.push(MeetingUrl.validateParams({
        pathId
      }));
    }
    return route;
  }
  onInit() {
    this.state = {};
    this.paths = [];
    this.pathId = null;
    this.form = null;
    StateService.state$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(state => {
      // console.log('AgoraLinkComponent.state', state);
      this.state = state;
      this.pushChanges();
    });
    if (environment.flags.usePaths) {
      PathService.getCurrentPath$().pipe(operators.first(), operators.tap(), operators.takeUntil(this.unsubscribe$)).subscribe(path => {
        this.paths = PathService.paths;
        this.pathId = path.id || '';
        this.onLoad();
      });
    } else {
      this.onLoad();
    }
  }
  onLoad() {
    const form = this.form = new rxcompForm.FormGroup({
      path: this.pathId,
      id: new rxcompForm.FormControl(null, [rxcompForm.Validators.PatternValidator(MEETING_ID_VALIDATOR), rxcompForm.Validators.RequiredValidator()]),
      idAttendee: null,
      idStreamer: null,
      idViewer: null,
      idSmartDevice: null
      // id: new FormControl(null),
    });

    const controls = this.controls = form.controls;
    const pathOptions = this.paths.map(x => {
      return {
        id: x.id || '',
        name: x.name
      };
    });
    if (pathOptions.length > 0) {
      pathOptions.unshift({
        id: null,
        name: 'bhere_select_path' // LabelPipe.transform('bhere_select_path')
      });
    }

    controls.path.options = pathOptions;
    form.changes$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(changes => {
      // console.log('AgoraLinkComponent.changes$', form.value);
      // console.log(changes.path, changes.id);
      if (this.pathId !== changes.path && changes.id !== null) {
        this.pathId = changes.path;
        this.onGenerateMeetingId();
      }
      this.pushChanges();
    });
  }
  onGenerateMeetingId($event) {
    let pathId = this.pathId ? String(this.pathId) : null;
    pathId = pathId && pathId.length ? pathId : null;
    // console.log('onGenerateMeetingId', this.pathId, pathId);
    const meetingId = new MeetingId({
      pathId
    });
    const meetingIdRoles = meetingId.toRoles();
    this.form.patch(meetingIdRoles);
  }
  onInputDidChange($event) {
    // console.log('onInputDidChange', this.form.get('id').value, this.form.get('id').valid);
    if (this.state.role !== 'publisher') {
      return;
    }
    setTimeout(() => {
      if (this.form.get('id').valid) {
        const value = this.form.get('id').value;
        const meetingId = new MeetingId(value);
        const meetingIdRoles = meetingId.toRoles();
        this.form.patch(meetingIdRoles);
      } else {
        this.form.get('idAttendee').reset();
        this.form.get('idStreamer').reset();
        this.form.get('idViewer').reset();
        this.form.get('idSmartDevice').reset();
      }
    }, 1);
  }
  onCopyToClipBoard(id, asAccessCode) {
    if (asAccessCode === void 0) {
      asAccessCode = false;
    }
    const meetingUrl = new MeetingUrl({
      link: id
    });
    meetingUrl.copyToClipBoard(asAccessCode);
  }
  onNext(event) {
    let meetingId = this.controls.id.value;
    MeetingUrl.replaceWithLink(meetingId);
    this.link.next(meetingId);
  }
  isValid() {
    const isValid = this.form.valid;
    return isValid;
  }
}
AgoraLinkComponent.meta = {
  selector: '[agora-link]',
  outputs: ['link'],
  template: /* html */`
	<div class="group--info" *if="form">
		<form class="form" [formGroup]="form" (submit)="isValid() && onNext($event)" name="form" role="form" novalidate autocomplete="off">
			<div class="group--info__content stagger--childs">
				<div class="stagger--childs" *if="state.role !== 'publisher'">
					<div class="group--form group--form--addon" [class]="{ required: controls.id.validators.length, 'addon': controls.id.valid }">
						<label [innerHTML]="'bhere_insert_meeting_id' | label"></label>
						<input type="text" class="control--text" [formControl]="controls.id" [placeholder]="'bhere_meeting_id' | label" />
						<div class="control--addon" (click)="onCopyToClipBoard(controls.id.value)" *if="controls.id.valid">
							<svg class="copy" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#copy"></use></svg>
						</div>
					</div>
				</div>
				<div class="stagger--childs" *if="state.role === 'publisher'">
					<!-- PATH -->
					<div control-custom-select [control]="controls.path" [label]="'bhere_path' | label" *if="('usePaths' | flag) && paths.length"></div>
					<!--IDS -->
					<div class="group--form group--form--addon" [class]="{ required: controls.id.validators.length, 'addon': controls.id.valid }">
						<label><svg class="lock" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#lock"></use></svg> <span [innerHTML]="'bhere_insert_meeting_id' | label"></span></label>
						<input type="text" class="control--text" [formControl]="controls.id" [placeholder]="'bhere_meeting_id' | label" (change)="onInputDidChange($event)" />
						<div class="control--addon" (click)="onCopyToClipBoard(controls.id.value)" *if="controls.id.valid">
							<svg class="copy" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#copy"></use></svg>
						</div>
					</div>
					<div class="group--form group--form--addon addon" *if="('attendee' | flag) && controls.idAttendee.valid && controls.idAttendee.value !== null">
						<label><svg class="lock" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#lock"></use></svg> <span [innerHTML]="'bhere_attendee_meeting_id' | label"></span></label>
						<input type="text" class="control--text" [formControl]="controls.idAttendee" [placeholder]="'bhere_attendee_meeting_id' | label" readonly />
						<div class="control--addon" (click)="onCopyToClipBoard(controls.idAttendee.value)" *if="controls.idAttendee.valid">
							<svg class="copy" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#copy"></use></svg>
						</div>
					</div>
					<div class="group--form group--form--addon addon" *if="('streamer' | flag) && controls.idStreamer.valid && controls.idStreamer.value !== null">
						<label [innerHTML]="'bhere_streamer_meeting_id' | label"></label>
						<input type="text" class="control--text" [formControl]="controls.idStreamer" [placeholder]="'bhere_streamer_meeting_id' | label" readonly />
						<div class="control--addon" (click)="onCopyToClipBoard(controls.idStreamer.value)" *if="controls.idStreamer.valid">
							<svg class="copy" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#copy"></use></svg>
						</div>
					</div>
					<div class="group--form group--form--addon addon" *if="('viewer' | flag) && controls.idViewer.valid && controls.idViewer.value !== null">
						<label [innerHTML]="'bhere_viewer_meeting_id' | label"></label>
						<input type="text" class="control--text" [formControl]="controls.idViewer" [placeholder]="'bhere_viewer_meeting_id' | label" readonly />
						<div class="control--addon" (click)="onCopyToClipBoard(controls.idViewer.value)" *if="controls.idViewer.valid">
							<svg class="copy" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#copy"></use></svg>
						</div>
					</div>
					<div class="group--form group--form--addon addon" *if="('smartDevice' | flag) && controls.idSmartDevice.valid && controls.idSmartDevice.value !== null">
						<label [innerHTML]="'bhere_smart_device_meeting_id' | label"></label>
						<input type="text" class="control--text" [formControl]="controls.idSmartDevice" [placeholder]="'bhere_smart_device_meeting_id' | label" readonly />
						<div class="control--addon" (click)="onCopyToClipBoard(controls.idSmartDevice.value, true)" *if="controls.idSmartDevice.valid">
							<svg class="copy" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#copy"></use></svg>
						</div>
					</div>
				</div>
				<div class="info" *if="controls.id.errors.required" [innerHTML]="'bhere_insert_meeting_id' | label"></div>
				<div class="info" *if="controls.id.errors.pattern" [innerHTML]="'bhere_invalid_meeting_id' | label"></div>
				<div class="info" *if="isValid()" [innerHTML]="'bhere_take_part_meeting' | label"></div>
				<button type="button" class="btn--generate" *if="state.role == 'publisher'" (click)="onGenerateMeetingId($event)">
					<span [innerHTML]="'bhere_generate_meeting_id' | label"></span>
				</button>
				<button type="submit" class="btn--next" [class]="{ disabled: !isValid() }">
					<span [innerHTML]="'bhere_take_part' | label"></span>
				</button>
				<a [routerLink]="selfServiceTourRoute" class="btn--secondary" *if="state.role === 'publisher'">
					<span [innerHTML]="'bhere_self_service' | label"></span>
				</a>
			</div>
		</form>
	</div>
	`
};class AgoraLoginComponent extends rxcomp.Component {
  onInit() {
    const form = this.form = new rxcompForm.FormGroup({
      username: new rxcompForm.FormControl(null, rxcompForm.Validators.RequiredValidator()),
      password: new rxcompForm.FormControl(null, rxcompForm.Validators.RequiredValidator()),
      checkRequest: window.antiforgery || '',
      checkField: ''
    });
    this.controls = form.controls;
    form.changes$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(changes => {
      this.pushChanges();
    });
    this.error = null;
  }
  test() {
    this.form.patch({
      username: 'publisher',
      password: 'publisher',
      checkRequest: window.antiforgery || '',
      checkField: ''
    });
  }
  reset() {
    this.form.reset();
  }
  onSubmit() {
    if (this.form.valid) {
      const payload = this.form.value;
      this.form.submitted = true;
      this.error = null;
      this.pushChanges();
      UserService.login$(payload).pipe(operators.first()).subscribe(user => {
        if (StateService.state.role === user.type) {
          // this.login.next(user);
          this.onNext(user);
          this.form.reset();
        } else {
          this.error = {
            friendlyMessage: LabelPipe.transform('error_credentials')
          };
          this.pushChanges();
        }
      }, error => {
        console.log('AccessComponent.error', error);
        this.error = error;
        this.pushChanges();
      });
    } else {
      this.form.touched = true;
    }
  }
  isValid() {
    const isValid = this.form.valid;
    return isValid;
  }
  onNext(user) {
    MeetingUrl.replaceWithUser(user);
    this.login.next(user);
  }
}
AgoraLoginComponent.meta = {
  selector: '[agora-login]',
  outputs: ['login'],
  template: /* html */`
	<div class="group--info">
		<form class="form" [formGroup]="form" (submit)="isValid() && onSubmit()" name="form" role="form" novalidate autocomplete="off">
			<div class="group--info__content stagger--childs">
				<div class="title" [innerHTML]="'bhere_login' | label"></div>
				<input name="checkField" [formControl]="controls.checkField" value="" type="text" style="display:none !important;" />
				<div control-text [control]="controls.username" [label]="'bhere_username' | label"></div>
				<div control-password [control]="controls.password" [label]="'bhere_password' | label"></div>
				<div class="group--error" *if="error">
					<span class="status-code" [innerHTML]="error.statusCode"></span>
					<span class="status-message" [innerHTML]="error.statusMessage"></span>
					<span class="friendly-message" [innerHTML]="error.friendlyMessage"></span>
				</div>
				<div class="info" *if="isValid()" [innerHTML]="'bhere_cta' | label"></div>
				<button type="submit" class="btn--next" [class]="{ disabled: !isValid() }">
					<span [innerHTML]="'bhere_cta' | label"></span>
				</button>
				<test-component [form]="form" (test)="test($event)" (reset)="reset($event)"></test-component>
			</div>
		</form>
	</div>
	`
};class AgoraNameComponent extends rxcomp.Component {
  onInit() {
    const meetingUrl = new MeetingUrl();
    this.state = {};
    const fields = this.fields = [];
    if (environment.flags.useExtendedUserInfo) {
      const firstName = meetingUrl.firstName;
      const lastName = meetingUrl.lastName;
      const email = meetingUrl.email;
      fields.push({
        type: 'text',
        name: 'firstName',
        label: 'access_first_name',
        required: true,
        value: firstName,
        test: 'Jhon'
      }, {
        type: 'text',
        name: 'lastName',
        label: 'access_last_name',
        required: true,
        value: lastName,
        test: 'Appleseed'
      }, {
        type: 'email',
        name: 'email',
        label: 'access_email',
        required: true,
        value: email,
        test: 'jhonappleseed@gmail.com'
      });
    } else {
      const name = meetingUrl.name;
      fields.push({
        type: 'text',
        name: 'name',
        label: 'bhere_name_and_surname',
        pattern: /^\w{2,}\s\w{2,}/,
        required: true,
        value: name,
        test: 'Jhon Appleseed'
      });
    }
    fields.push({
      type: 'checkbox',
      name: 'privacy',
      label: 'access_privacy_disclaimer',
      required: true,
      test: true
    }, {
      type: 'hidden',
      name: 'checkField',
      value: '',
      test: ''
    }, {
      type: 'none',
      name: 'checkRequest',
      value: environment.antiforgery || '',
      test: environment.antiforgery || ''
    });
    const form = this.form = fieldsToFormGroup(fields);

    /*
    const form = this.form = new FormGroup({
    	name: new FormControl(name, [Validators.PatternValidator(/^\w{2,}\s\w{2,}/), Validators.RequiredValidator()]),
    });
    */

    this.controls = form.controls;
    form.changes$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(changes => {
      // console.log('AgoraNameComponent.changes$', form.value);
      this.pushChanges();
    });
    StateService.state$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(state => {
      // console.log('AgoraNameComponent.state', state);
      this.state = state;
      this.pushChanges();
    });
  }
  test() {
    patchFields(this.fields, this.form);
  }
  isValid() {
    const isValid = this.form.valid;
    return isValid;
  }
  onNext(event) {
    let name;
    let options;
    if (environment.flags.useExtendedUserInfo) {
      options = {
        firstName: this.controls.firstName.value,
        lastName: this.controls.lastName.value,
        email: this.controls.email.value
      };
      name = `${options.firstName} ${options.lastName}`;
    } else {
      options = {
        name: this.controls.name.value
      };
      name = options.name;
    }
    MeetingUrl.replaceWithOptions(options);
    this.name.next(name);
  }
}
AgoraNameComponent.meta = {
  selector: '[agora-name]',
  outputs: ['name'],
  template: /* html */`
	<div class="group--info" *if="form">
		<form class="form" [formGroup]="form" (submit)="isValid() && onNext($event)" name="form" role="form" novalidate autocomplete="off">
			<div class="group--info__content stagger--childs">
				<!-- controls -->
				<div controls [formGroup]="form" [fields]="fields"></div>
				<!-- NAME -->
				<!--
				<div class="group--form group--form--addon" [class]="{ required: controls.name.validators.length }">
					<label [innerHTML]="'bhere_fill_fullname' | label"></label>
					<input type="text" class="control--text" [formControl]="controls.name" [placeholder]="'bhere_name_and_surname' | label" />
				</div>
				<div class="info" *if="!controls.name.valid" [innerHTML]="'bhere_fill_name_and_surname' | label"></div>
				-->
				<div class="info" *if="!isValid()"><span [innerHTML]="'bhere_fill_name_and_surname' | label"></span></div>
				<div class="info" *if="isValid()"><span [innerHTML]="'bhere_proceed_as' | label"></span> <span [innerHTML]="controls.name.value"></span></div>
				<button type="submit" class="btn--next" [class]="{ disabled: !isValid() }">
					<span [innerHTML]="'bhere_proceed' | label"></span>
				</button>
				<test-component [form]="form" (test)="test($event)" (reset)="reset($event)"></test-component>
			</div>
		</form>
	</div>
	`
};class AgoraStreamComponent extends rxcomp.Component {
  set videoMuted(videoMuted) {
    if (this.videoMuted_ !== videoMuted) {
      this.videoMuted_ = videoMuted;
      const {
        node
      } = rxcomp.getContext(this);
      videoMuted ? node.classList.add('video--muted') : node.classList.remove('video--muted');
    }
  }
  set audioMuted(audioMuted) {
    if (this.audioMuted_ !== audioMuted) {
      this.audioMuted_ = audioMuted;
      const {
        node
      } = rxcomp.getContext(this);
      audioMuted ? node.classList.add('audio--muted') : node.classList.remove('audio--muted');
    }
  }
  get streamId() {
    return this.streamId_;
  }
  set streamId(streamId) {
    this.streamId_ = streamId;
  }

  /** @type {Stream} */
  get stream() {
    return this.stream_;
  }

  /**
   * @param stream {Stream}
   * */
  set stream(stream) {
    try {
      if (this.stream_ !== stream) {
        console.log('AgoraStreamComponent set stream', stream);
        const {
          node
        } = rxcomp.getContext(this);
        const player = this.player = node.querySelector('.agora-stream__player');
        /*
        while (player.childElementCount > 0) {
        	player.removeChild(player.firstElementChild);
        }
        if (this.stream_ && this.stream_.isPlaying() && this.stream_.player.div.parentNode === player) {
        	Logger.log('AgoraStreamComponent', 'stopping stream', this.stream_.streamId);
        	this.stream_.stop();
        }
        */
        this.stream_ = stream;
        if (stream) {
          this.videoMuted = stream.userMuteVideo;
          this.audioMuted = stream.userMuteAudio;
        }
        const streamId = stream ? stream.streamId : null;
        this.streamId = streamId;
        if (streamId) {
          const playerId = `stream-${streamId}`;
          player.setAttribute('id', playerId);
          const self = this;
          // Logger.log('AgoraStreamComponent', streamId);
          if (stream.isPlaying()) {
            stream.resume(player);
          } else {
            this.shouldUseResumeGesture = false;
            try {
              stream.play(player);
            } catch (error) {
              Logger.error('Stream.videoTrack.play.error', error);
              if (error && error.status !== 'aborted') {
                // The playback fails, probably due to browser policy. You can resume the playback by user gesture.
                self.shouldUseResumeGesture = true;
                self.pushChanges();
              }
            }
          }
        } else {
          player.removeAttribute('id');
        }
      }
    } catch (error) {
      Logger.error('AgoraStreamComponent.stream.set.error', error);
    }
  }
  set vrContainer(vrContainer) {
    if (this.vrContainer_ !== vrContainer) {
      this.vrContainer_ = vrContainer;
      if (vrContainer) {
        this.stream_.vrContainer = vrContainer;
        this.player.appendChild(vrContainer);
      } else if (this.stream_.vrContainer && this.stream_.vrContainer.parentNode) {
        this.stream_.vrContainer.parentNode.removeChild(this.stream_.vrContainer);
        this.stream_.vrContainer = null;
      }
    }
  }
  get videoNode() {
    let videoNode = this.videoNode_;
    if (!videoNode) {
      const player = rxcomp.getContext(this).node.querySelector('.agora-stream__player');
      videoNode = document.createElement('video');
      this.onLoadedMetadata = this.onLoadedMetadata.bind(this);
      videoNode.addEventListener('loadedmetadata', this.onLoadedMetadata);
      player.appendChild(videoNode);
      this.videoNode_ = videoNode;
    }
    return videoNode;
  }
  onInit() {
    this.videoMuted = false;
    this.audioMuted = false;
    this.shouldUseResumeGesture = false;
    this.state = {};
    StateService.state$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(state => {
      this.state = state;
      this.pushChanges();
      // console.log('AgoraStreamComponent.StateService.state$', this.streamId, state);
    });

    MessageService.out$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(message => {
      // console.log('AgoraStreamComponent.MessageService.out$', this.streamId, message);
      switch (message.type) {
        case MessageType.AgoraEvent:
          {
            const event = message.event;
            // console.log('AgoraStreamComponent.AgoraEvent', message.event);
            if (this.streamId && event.streamId === this.streamId) {
              if (event instanceof AgoraMuteVideoEvent) {
                this.videoMuted = true;
              }
              if (event instanceof AgoraUnmuteVideoEvent) {
                this.videoMuted = false;
              }
              if (event instanceof AgoraMuteAudioEvent) {
                this.audioMuted = true;
              }
              if (event instanceof AgoraUnmuteAudioEvent) {
                this.audioMuted = false;
              }
            }
            break;
          }
        case MessageType.VRStarted:
          // console.log('AgoraStreamComponent.VRStarted', this.streamId, message.clientId, message.container);
          if (this.streamId === message.clientId) {
            this.vrContainer = message.container;
          }
          break;
        case MessageType.VREnded:
          // console.log('AgoraStreamComponent.VREnded', this.streamId, message.clientId);
          if (this.streamId === message.clientId) {
            this.vrContainer = null;
          }
          break;
      }
    });
  }
  setMediaStream(mediaStream) {
    const videoNode = this.videoNode;
    if ('srcObject' in videoNode) {
      videoNode.srcObject = mediaStream;
    } else {
      videoNode.src = mediaStream ? window.URL.createObjectURL(mediaStream) : null;
    }
  }
  onLoadedMetadata(event) {
    // console.log('AgoraStreamComponent.onLoadedMetadata', event);
    this.videoNode.play().then(success => {
      // console.log('AgoraStreamComponent.play.success', success);
    }, error => {
      console.log('AgoraStreamComponent.play.error', error);
    });
  }
  onToggleControl($event) {
    this.toggleControl.next($event);
  }
  onToggleSpy($event) {
    this.toggleSpy.next($event);
  }
}
AgoraStreamComponent.meta = {
  selector: '[agora-stream]',
  outputs: ['toggleControl', 'toggleSpy'],
  inputs: ['stream']
};class Navmap {
  constructor(options) {
    if (options) {
      Object.assign(this, options);
    }
    this.items = (this.items || []).map(item => mapViewItem(item));
    this.originalItems = this.items.slice();
  }
  get payload() {
    const payload = {};
    Object.keys(this).forEach(key => {
      if (View.allowedProps.indexOf(key) !== -1) {
        switch (key) {
          case 'items':
            payload[key] = this[key].map(item => mapViewItem(item).payload);
            break;
          default:
            payload[key] = this[key];
        }
      }
    });
    return payload;
  }
}
Navmap.allowedProps = ['id', 'name', 'asset', 'items'];
function mapNavmap(map) {
  map = new Navmap(map);
  return map;
}class NavmapService {
  static set active(active) {
    this.active$.next(active);
  }
  static get active() {
    return this.active$.getValue();
  }
  static navmapGet$() {
    return HttpService.get$('/api/navmap').pipe(operators.map(data => {
      data.navmaps.map(navmap => mapNavmap(navmap));
      return data.navmaps;
    }));
  }
  static navmapCreate$(navmap) {
    return HttpService.post$('/api/navmap', navmap).pipe(operators.map(navmap => mapNavmap(navmap)));
  }
  static navmapUpdate$(navmap) {
    return HttpService.put$(`/api/navmap/${navmap.id}`, navmap).pipe(operators.map(x => mapNavmap(x)));
  }
  static navmapDelete$(navmap) {
    return HttpService.delete$(`/api/navmap/${navmap.id}`);
  }
  static itemCreate$(navmap, item) {
    return HttpService.post$(`/api/navmap/${navmap.id}/item`, item).pipe(operators.map(item => mapViewItem(item)));
  }
  static itemUpdate$(navmap, item) {
    item = mapViewItem(item); // !!! ??
    return HttpService.put$(`/api/navmap/${navmap.id}/item/${item.id}`, item.payload).pipe(operators.map(item => mapViewItem(item)));
  }
  static itemDelete$(navmap, item) {
    return HttpService.delete$(`/api/navmap/${navmap.id}/item/${item.id}`);
  }
}
NavmapService.active$ = new rxjs.BehaviorSubject(false);function push_(event) {
  const dataLayer = window.dataLayer || [];
  dataLayer.push(event);
  console.log('GtmService.dataLayer', event);
}
class GtmService {
  static push(event) {
    return push_(event);
  }
}const ToastType = {
  Info: 'info',
  Alert: 'alert',
  Dialog: 'dialog'
};
const ToastPosition = {
  Centered: 'centered',
  TopLeft: 'top-left',
  Top: 'top',
  TopRight: 'top-right',
  Right: 'right',
  BottomRight: 'bottom-right',
  Bottom: 'bottom',
  BottomLeft: 'bottom-left',
  Left: 'left'
};
class ToastEvent {
  constructor(toast) {
    this.toast = toast;
  }
}
class ToastResolveEvent extends ToastEvent {}
class ToastRejectEvent extends ToastEvent {}
class ToastService {
  static open$(toast) {
    toast.id = new Date().getTime();
    toast.type = toast.type || ToastType.Info;
    toast.position = toast.position || ToastPosition.Centered;
    switch (toast.type) {
      case ToastType.Alert:
        toast.acceptMessage = toast.acceptMessage || 'Ok';
        break;
      case ToastType.Dialog:
        toast.acceptMessage = toast.acceptMessage || 'Accept';
        toast.rejectMessage = toast.rejectMessage || 'Reject';
        break;
    }
    this.toast$.next(toast);
    if (toast.type === ToastType.Info) {
      setTimeout(() => {
        this.resolve(toast);
      }, toast.duration || 4000);
    }
    return this.events$;
    /*
    return of(toast).pipe(
    	tap(toast => this.toast$.next(toast)),
    	switchMap(toast => this.events$),
    );
    */
  }

  static resolve(toast) {
    this.toast$.next(null);
    this.events$.next(new ToastResolveEvent(toast));
  }
  static reject(toast) {
    this.toast$.next(null);
    this.events$.next(new ToastRejectEvent(toast));
  }
}
ToastService.toast$ = new rxjs.Subject();
ToastService.events$ = new rxjs.Subject();class ModalOutletComponent extends rxcomp.Component {
  get modal() {
    return this.modal_;
  }
  set modal(modal) {
    // console.log('ModalOutletComponent set modal', modal, this);
    const {
      module
    } = rxcomp.getContext(this);
    if (this.modal_ && this.modal_.node) {
      module.remove(this.modal_.node, this);
      this.modalNode.removeChild(this.modal_.node);
    }
    if (modal && modal.node) {
      this.modal_ = modal;
      this.modalNode.appendChild(modal.node);
      module.compile(modal.node);
    }
    this.modal_ = modal;
    this.pushChanges();
  }
  get busy() {
    return this.busy_;
  }
  set busy(busy) {
    // console.log('ModalOutletComponent set busy', busy, this);
    if (this.busy_ !== busy) {
      this.busy_ = busy;
      this.pushChanges();
    }
  }
  onInit() {
    this.busy_ = false;
    const {
      node
    } = rxcomp.getContext(this);
    this.modalNode = node.querySelector('.modal-outlet__modal');
    ModalService.modal$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(modal => this.modal = modal);
    ModalService.busy$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(busy => this.busy = busy);
  }
  reject(event) {
    ModalService.reject();
  }
}
ModalOutletComponent.meta = {
  selector: '[modal-outlet]',
  template: /* html */`
	<div class="modal-outlet__container" [class]="{ active: modal, busy: busy }">
		<div class="modal-outlet__background" (click)="reject($event)"></div>
		<div class="modal-outlet__modal"></div>
		<!-- spinner -->
		<div class="spinner spinner--contrasted" *if="busy"></div>
	</div>
	`
};class TryInARModalComponent extends rxcomp.Component {
  onInit() {
    super.onInit();
    const {
      parentInstance,
      node
    } = rxcomp.getContext(this);
    if (parentInstance instanceof ModalOutletComponent) {
      const data = this.data = parentInstance.modal.data;
      // console.log('data', data);
      if (data && data.ar) {
        const url = TryInARModalComponent.getUrl(data);
        new QRious({
          element: node.querySelector('.qrcode'),
          value: url,
          size: 256
        });
      }
    }
  }
  onClose() {
    ModalService.reject();
  }
  static getUrl(data) {
    const path = RouterService.buildUrl(RoutePipe.transform(':lang.tryInAr'), {
      viewId: data.id
    });
    const url = window.location.origin + path;
    console.log('TryInARModalComponent.getUrl', url);
    return url;
  }
  static openInAR(data) {
    const url = this.getUrl(data);
    window.open(url, '_blank');
  }
}
TryInARModalComponent.meta = {
  selector: '[try-in-ar-modal]',
  template: /* html */`
		<div class="modal__header">
			<button type="button" class="btn--close" (click)="onClose()">
				<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#close"></use></svg>
			</button>
		</div>
		<div class="container">
			<div class="form">
				<div class="title" [innerHTML]="'bhere_ar' | label"></div>
				<div class="picture">
					<canvas class="qrcode"></canvas>
				</div>
				<div class="group--cta">
					<button type="button" class="btn--accept" (click)="onClose()">
						<span [innerHTML]="'close' | label"></span>
					</button>
				</div>
			</div>
		</div>
	`
};
TryInARModalComponent.chunk = () => /* html */'<div class="try-in-ar-modal" try-in-ar-modal></div>';const EXT_IMAGE = ['jpeg', 'jpg', 'png', 'hdr'];
const EXT_VIDEO = ['mp4', 'webm'];
const EXT_MODEL = ['fbx', 'gltf', 'glb', 'usdz'];
const AssetType = {
  Image: {
    id: 1,
    name: 'image'
  },
  // jpg, png, ...
  Video: {
    id: 2,
    name: 'video'
  },
  // mp4, webm, ...
  Model: {
    id: 3,
    name: 'model'
  },
  // fbx, gltf, glb, usdz ...
  PublisherStream: {
    id: 4,
    name: 'publisher-stream',
    file: 'publisherStream'
  },
  // valore fisso di file a ‘publisherStream’ e folder string.empty
  AttendeeStream: {
    id: 5,
    name: 'next-attendee-stream',
    file: 'nextAttendeeStream'
  },
  // valore fisso di file a ‘nextAttendeeStream’ e folder string.empty
  PublisherScreen: {
    id: 6,
    name: 'publisher-screen',
    file: 'publisherScreen'
  },
  // valore fisso di file a ‘publisherScreen’ e folder string.empty
  AttendeeScreen: {
    id: 7,
    name: 'attendee-screen',
    file: 'attendeeScreen'
  },
  // valore fisso di file a ‘attendeeScreen’ e folder string.empty
  SmartDeviceStream: {
    id: 8,
    name: 'smart-device-stream',
    file: 'smartDeviceStream'
  } // valore fisso di file a smartDeviceStream e folder string.empty
};

const AssetGroupType = {
  ImageOrVideo: {
    id: 1,
    name: 'Image or Video',
    ids: [1, 2]
  },
  // Model: { id: 2, name: 'Model 3D', ids: [3] },
  Publisher: {
    id: 3,
    name: 'Publisher',
    ids: [4]
  },
  Attendee: {
    id: 4,
    name: 'Attendee',
    ids: [5]
  }
  // PublisherScreen: { id: 5, name: 'PublisherScreen', ids: [6] },
  // AttendeeScreen: { id: 6, name: 'AttendeeScreen', ids: [7] },
};

function AssetGroupTypeInit() {
  // console.log('environment.flags.editorAssetScreen', environment.flags.editorAssetScreen, environment);
  if (environment.flags.editorAssetScreen) {
    AssetGroupType.PublisherScreen = {
      id: 5,
      name: 'PublisherScreen',
      ids: [6]
    };
    AssetGroupType.AttendeeScreen = {
      id: 6,
      name: 'AttendeeScreen',
      ids: [7]
    };
  }
  AssetGroupType.SmartDevice = {
    id: 7,
    name: 'Smart Device',
    ids: [8]
  };
}
const STREAM_TYPES = [AssetType.PublisherStream.name, AssetType.AttendeeStream.name, AssetType.PublisherScreen.name, AssetType.AttendeeScreen.name, AssetType.SmartDeviceStream.name];
function assetIsStream(asset) {
  // console.log('assetIsStream', asset.type.name, STREAM_TYPES);
  return asset && STREAM_TYPES.indexOf(asset.type.name) !== -1;
}
function assetTypeById(id) {
  const type = Object.keys(AssetType).reduce((p, key) => {
    const type = AssetType[key];
    return type.id === id ? type : p;
  }, null);
  return type;
  // return Object.keys(AssetType).map(x => AssetType[x]).find(x => x.id === id);
}

function assetGroupTypeById(id) {
  const type = Object.keys(AssetGroupType).reduce((p, key) => {
    const type = AssetGroupType[key];
    return type.id === id ? type : p;
  }, null);
  return type;
  // return Object.keys(AssetGroupType).map(x => AssetGroupType[x]).find(x => x.id === id);
}

function assetGroupTypeFromItem(item) {
  let key;
  if (item && item.asset) {
    key = Object.keys(AssetGroupType).find(key => {
      // console.log(key, AssetGroupType[key].ids, item.asset.type.id);
      return AssetGroupType[key].ids.indexOf(item.asset.type.id) !== -1;
    });
  }
  return AssetGroupType[key || 'ImageOrVideo'];
}
function assetPayloadFromGroupTypeId(groupTypeId) {
  const groupType = assetGroupTypeById(groupTypeId);
  const type = assetTypeById(groupType.ids[0]);
  const file = type.file;
  const asset = {
    type: type,
    folder: '',
    file: file
  };
  // console.log('assetPayloadFromGroupTypeId', asset);
  return new Asset(asset);
}
function assetTypeFromPath(path) {
  const extension = path.split('.').pop().toLowerCase();
  if (EXT_IMAGE.indexOf(extension) !== -1) {
    return AssetType.Image;
  } else if (EXT_VIDEO.indexOf(extension) !== -1) {
    return AssetType.Video;
  } else if (EXT_MODEL.indexOf(extension) !== -1) {
    return AssetType.Model;
  }
}
class Asset {
  constructor(options) {
    if (options) {
      Object.assign(this, options);
    }
  }
  get payload() {
    const payload = {};
    Object.keys(this).forEach(key => {
      if (Asset.allowedProps.indexOf(key) !== -1) {
        payload[key] = this[key];
      }
    });
    return payload;
  }
  static fromUrl(url) {
    const segments = url.split('/');
    const file = segments.pop();
    const folder = segments.join('/') + '/';
    const type = assetTypeFromPath(file);
    return new Asset({
      type: type,
      folder: folder,
      file: file
    });
  }
  static get defaultMediaAsset() {
    const asset = {
      id: -1,
      type: {
        id: AssetType.Image,
        name: 'image'
      },
      folder: '/textures/grid/',
      file: 'grid.jpg'
    };
    return asset;
  }
}
Asset.allowedProps = ['id', 'type', 'folder', 'file', 'linkedPlayId', 'chromaKeyColor', 'autoplay', 'loop'];
function mapAsset(asset) {
  switch (asset.type.name) {
    default:
      asset = new Asset(asset);
  }
  return asset;
}const DEFAULT_WAITING_ROOM = {
  id: 'waiting-room',
  type: {
    id: 1,
    name: 'waiting-room'
  },
  name: 'Waiting Room',
  likes: 0,
  liked: false,
  asset: {
    type: {
      id: 1,
      name: 'image'
    },
    folder: '/textures/waiting-room/',
    file: 'waiting-room.jpg'
  },
  items: [],
  orientation: {
    latitude: 0,
    longitude: 0
  }
};
class ViewService {
  static get dataViews() {
    return this.data ? this.data.views : [];
  }
  static get validViews() {
    return this.data ? this.data.views.filter(x => x.type.name !== ViewType.WaitingRoom.name) : [];
  }
  static get pathViews() {
    const views = this.validViews;
    return views.filter(x => x.path);
  }
  static get validPathViews() {
    const views = this.editor ? this.data.views : this.validViews;
    return views.filter(x => x.path);
  }

  // action: { viewId:number, keepOrientation:boolean, useLastOrientation:boolean };

  static set action(action) {
    this.action$_.next(action);
  }
  static get action() {
    return this.action$_.getValue();
  }

  // static viewId$_ = new BehaviorSubject(null);
  static set viewId(viewId) {
    this.action$_.next({
      viewId,
      keepOrientation: false,
      useLastOrientation: false
    });
  }
  static get viewId() {
    const action = this.action$_.getValue();
    return action ? action.viewId : null;
  }
  static getDataView(viewId) {
    const views = this.dataViews;
    return views.find(x => x.id === viewId) || null;
  }
  static get currentView() {
    const viewId = this.viewId;
    if (viewId !== null) {
      return this.getDataView(viewId);
    }
    return null;
  }
  static getValidPathId(viewId) {
    if (!viewId) {
      return null;
    }
    const views = this.validPathViews;
    if (views.find(x => x.id === viewId) == null) {
      return null;
    }
    return viewId;
  }
  static getFirstPathId() {
    const views = this.editor && this.path.id === null ? this.dataViews : this.pathViews;
    // console.log('ViewService.getFirstPathId', this.editor, this.path, views);
    return views.length ? views[0].id : null;
  }
  static data$() {
    if (!this.data$_) {
      const dataUrl = (environment.flags.production ? '/api/view' : `${environment.assets}api/data.json`) + '?lang=' + LanguageService.lang;
      this.data$_ = HttpService.get$(dataUrl).pipe(operators.map(data => {
        data.views = data.views.map(view => mapView(view));
        this.data = data;
        return data;
      }), operators.shareReplay(1));
    }
    return this.data$_;
  }
  static view$() {
    // const editor = this.editor;
    const meetingUrl = new MeetingUrl();
    // const pathId = meetingUrl.pathId;
    const viewId = this.getValidPathId(meetingUrl.viewId);
    const embedViewId = this.getValidPathId(meetingUrl.embedViewId);
    const initialViewId = embedViewId || viewId || this.getFirstPathId();
    // console.log('ViewService.view$', viewId, embedViewId, initialViewId);
    this.action$_.next({
      viewId: initialViewId
    });
    return this.action$_.pipe(operators.distinctUntilChanged((a, b) => a.viewId === b.viewId), operators.map(action => {
      // const view = data.views.find(view => view.id === action.viewId);
      // console.log('ViewService.view$', 'path', path);
      // filter path
      let view = this.dataViews.find(view => view.id === action.viewId);
      /*
      if (path && !editor) {
      	if (path.items.indexOf(view.id) === -1) {
      		const newView = Object.assign({}, view);
      		newView.items = view.items.filter(x => {
      			if (x.type.name === ViewItemType.Nav.name) {
      				return path.items.indexOf(x.viewId) === -1;
      			} else {
      				return true;
      			}
      		});
      		view = mapView(newView);
      	} else {
      		view = null;
      	}
      }
      // console.log('ViewService.view$', view, path);
      */
      if (view) {
        view.keepOrientation = action.keepOrientation || false;
        view.useLastOrientation = action.useLastOrientation || false;
      }
      // console.log('ViewService.view$', action.viewId, action.keepOrientation, action.useLastOrientation);
      return view || this.getWaitingRoom();
    }));
  }
  static setDataAndPath(data, path) {
    this.data = data;
    data.views.forEach(view => {
      view.path = !path || path.items.indexOf(view.id) === -1;
      view.items.forEach(item => {
        let valid = true;
        if (path) {
          if (item.type.name === ViewItemType.Nav.name) {
            valid = path.items.indexOf(item.viewId) === -1;
          }
          item.path = valid;
        }
      });
    });
    this.path = path;
  }
  static hostedView$(data, path) {
    this.setDataAndPath(data, path);
    this.editor = false;
    const waitingRoom = this.getWaitingRoom();
    return rxjs.combineLatest([this.view$(), this.hosted$()]).pipe(operators.map(datas => {
      const view = datas[0];
      const hosted = datas[1];
      return hosted ? view : waitingRoom;
    }), operators.distinctUntilChanged((a, b) => {
      return a.id === b.id;
    }), operators.tap(view => {
      if (view.id !== waitingRoom.id) {
        MeetingUrl.replaceWithOptions({
          viewId: view.id
        });
        const prefetchAssets = ViewService.getPrefetchAssets(view);
        view.prefetchAssets = prefetchAssets;
      }
    }));
  }
  static editorView$(data, path) {
    this.setDataAndPath(data, path);
    this.editor = true;
    const waitingRoom = this.getWaitingRoom();
    return this.view$().pipe(operators.map(view => {
      // console.log('ViewService.editorView$.view', view.updateIndices);
      const options = {
        pathId: null
      };
      if (view.id !== waitingRoom.id) {
        options.viewId = view.id;
      }
      if (path && path.id !== null) {
        options.pathId = path.id;
      }
      MeetingUrl.replaceWithOptions(options);
      return view;
    }));
  }
  static hosted$() {
    return StateService.state$.pipe(operators.map(state => state.hosted), operators.distinctUntilChanged());
  }
  static viewById$(viewId) {
    return this.data$().pipe(operators.map(data => this.dataViews.find(x => x.id === viewId)));
  }
  static viewLike$(view) {
    if (!view.liked) {
      view.liked = true;
      if (environment.flags.production) {
        return HttpService.get$(`/api/view/${view.id}/like`);
      } else {
        view.likes = view.likes || 0;
        view.likes++;
        return rxjs.of(view);
      }
    } else {
      return rxjs.of(null);
    }
  }
  static setViewLike$(message) {
    return this.viewById$(message.viewId).pipe(operators.tap(view => {
      if (view) {
        view.likes = message.likes;
      }
    }));
  }
  static getWaitingRoom() {
    return this.dataViews.find(x => x.type.name === ViewType.WaitingRoom.name) || DEFAULT_WAITING_ROOM;
  }
  static getPrefetchAssets(view) {
    const views = this.validPathViews;
    const assets = view.items
    // filter nav items
    .filter(x => x.type.name === ViewItemType.Nav.name && x.viewId != null)
    // map to view
    .map(x => views.find(v => v.id === x.viewId))
    // filter view with image
    .filter(v => v && v.asset && v.asset.type.name === AssetType.Image.name)
    // map to asset
    .map(v => environment.getPath(v.asset.folder + v.asset.file));
    // console.log('ViewService.getPrefetchAssets', assets);
    return assets;
  }
  static addView(view) {
    const data = this.data;
    const views = data.views.slice();
    views.push(view);
    data.views = views;
    this.viewId = view.id;
  }
  static deleteView(view) {
    const data = this.data;
    const views = data.views.slice();
    const index = views.reduce((p, c, i) => {
      return c.id === view.id ? i : p;
    }, -1);
    if (index > 0) {
      views.splice(index, 1);
      data.views = views;
      const dataViews = this.dataViews;
      if (dataViews.length > 0) {
        this.viewId = dataViews[0].id;
      }
    }
    // this.pushChanges();
  }
}
ViewService.action$_ = new rxjs.BehaviorSubject(null);let items$_ = null;
class WishlistService {
  static get items$() {
    if (!items$_) {
      const items = LocalStorageService.get('wishlist') || [];
      items$_ = new rxjs.BehaviorSubject(items);
    }
    return items$_;
  }
  static getItems() {
    return this.items$.getValue();
  }
  static indexOf(item) {
    const items = this.getItems();
    return items.reduce((p, c, i) => {
      return p === -1 && c.viewId === item.viewId && c.itemId === item.itemId ? i : p;
    }, -1);
  }
  static has(item) {
    return this.indexOf(item) !== -1;
  }
  static add$(item) {
    const items = this.getItems();
    if (!this.has(item)) {
      items.push(item);
      LocalStorageService.set('wishlist', items);
      this.items$.next(items);
    }
    return this.items$;
  }
  static remove$(item) {
    const items = this.getItems();
    const index = this.indexOf(item);
    if (index !== -1) {
      items.splice(index, 1);
      LocalStorageService.set('wishlist', items);
      this.items$.next(items);
    }
    return this.items$;
  }
  static toggle$(item) {
    const items = this.getItems();
    const index = this.indexOf(item);
    if (index !== -1) {
      items.splice(index, 1);
      LocalStorageService.set('wishlist', items);
      this.items$.next(items);
    } else {
      items.push(item);
      LocalStorageService.set('wishlist', items);
      this.items$.next(items);
    }
    return this.items$;
  }
}class MediaLoaderEvent {
  constructor(loader) {
    this.loader = loader;
  }
}
class MediaLoaderPlayEvent extends MediaLoaderEvent {}
class MediaLoaderPauseEvent extends MediaLoaderEvent {}
class MediaLoaderDisposeEvent extends MediaLoaderEvent {}
class MediaLoaderTimeUpdateEvent extends MediaLoaderEvent {}
class MediaLoaderTimeSetEvent extends MediaLoaderEvent {}
class MediaLoader {
  static getLoader() {
    return MediaLoader.loader || (MediaLoader.loader = new THREE.TextureLoader());
  }
  static getPath(item) {
    return environment.getPath(item.asset.folder + item.asset.file);
  }
  static loadTexture(item, callback) {
    const path = MediaLoader.getPath(item);
    return MediaLoader.getLoader().load(path, callback);
  }
  static isVideo(item) {
    return item.asset && item.asset.file && (item.asset.file.indexOf('.mp4') !== -1 || item.asset.file.indexOf('.webm') !== -1);
  }
  static isStream(item) {
    return assetIsStream(item.asset);
  }
  static isMutedStream(item) {
    let isMutedStream = false;
    switch (item.asset.type.name) {
      case AssetType.PublisherStream.name:
        isMutedStream = StateService.state.role === RoleType.Publisher;
        break;
      case AssetType.AttendeeStream.name:
        isMutedStream = StateService.state.role === RoleType.Attendee;
        break;
      case AssetType.PublisherScreen.name:
        isMutedStream = true;
        break;
      case AssetType.AttendeeScreen.name:
        isMutedStream = true;
        break;
      case AssetType.SmartDeviceStream.name:
        isMutedStream = StateService.state.role === RoleType.SmartDevice;
        break;
    }
    // console.log('isMutedStream', isMutedStream, item.asset.type.name, AssetType.PublisherStream.name, StateService.state.role, RoleType.Publisher);
    return isMutedStream;
  }
  static isPublisherStream(item) {
    return item.asset && item.asset.type.name === AssetType.PublisherStream.name;
  }
  static isAttendeeStream(item) {
    return item.asset && item.asset.type.name === AssetType.AttendeeStream.name;
  }
  static isSmartDeviceStream(item) {
    return item.asset && item.asset.type.name === AssetType.SmartDeviceStream.name;
  }
  static isPublisherScreen(item) {
    return item.asset && item.asset.type.name === AssetType.PublisherScreen.name;
  }
  static isAttendeeScreen(item) {
    return item.asset && item.asset.type.name === AssetType.AttendeeScreen.name;
  }
  get isVideo() {
    return MediaLoader.isVideo(this.item);
  }
  get isStream() {
    return MediaLoader.isStream(this.item);
  }
  get isMutedStream() {
    return MediaLoader.isMutedStream(this.item);
  }
  get isPublisherStream() {
    return MediaLoader.isPublisherStream(this.item);
  }
  get isAttendeeStream() {
    return MediaLoader.isAttendeeStream(this.item);
  }
  get isSmartDeviceStream() {
    return MediaLoader.isSmartDeviceStream(this.item);
  }
  get isPublisherScreen() {
    return MediaLoader.isPublisherScreen(this.item);
  }
  get isAttendeeScreen() {
    return MediaLoader.isAttendeeScreen(this.item);
  }
  get isPlayableVideo() {
    return this.isVideo; // && !this.item.asset.autoplay;
  }

  get isAutoplayVideo() {
    return this.isStream; // || (this.isVideo && (this.item.asset.autoplay != null));
  }

  get muted() {
    return this.muted_;
  }
  set muted(muted) {
    this.muted_ = muted;
    // console.log('MediaLoader.muted', muted, this.video);
    if (this.video && this.isVideo) {
      this.video.muted = muted === true;
    }
  }
  constructor(item) {
    this.item = item;
    this.toggle = this.toggle.bind(this);
    this.muted_ = false;
    this.subscription = StateService.state$.subscribe(state => this.muted = state.volumeMuted);
  }
  load(callback) {
    const item = this.item;
    let texture;
    // console.log('MediaLoader.load', item, this.isStream);
    if (this.isStream && item.streamId) {
      const streamId = item.streamId;
      const video = document.querySelector(`#stream-${streamId} video`); // document.querySelector(`#stream-remote-${streamId} video`) || document.querySelector(`#stream-local-${streamId} video`);
      if (!video) {
        return;
      }
      const onCanPlay = () => {
        if (this.disposed) {
          return;
        }
        video.removeEventListener('canplay', onCanPlay);
        texture = this.texture = new THREE.VideoTexture(video);
        texture.minFilter = THREE.LinearFilter;
        texture.magFilter = THREE.LinearFilter;
        texture.mapping = THREE.UVMapping;
        // texture.format = THREE.RGBAFormat;
        // texture.image.width = video.videoWidth;
        // texture.image.height = video.videoHeight;
        texture.needsUpdate = true;
        if (typeof callback === 'function') {
          callback(texture, this);
        }
      };
      const isMutedStream = this.isMutedStream;
      video.crossOrigin = 'anonymous';
      video.volume = isMutedStream ? 0 : 1;
      video.muted = isMutedStream;
      if (video.readyState >= video.HAVE_FUTURE_DATA) {
        onCanPlay();
      } else {
        video.addEventListener('canplay', onCanPlay);
      }
    } else if (this.isVideo) {
      // create the video element
      const autoplay = item.asset && item.asset.autoplay || false;
      const loop = item.asset && item.asset.loop || false;
      const video = this.video = document.createElement('video');
      video.crossOrigin = 'anonymous';
      video.preload = 'metadata';
      video.volume = 0.8;
      video.muted = autoplay;
      video.playsInline = true;
      video.loop = loop;
      const onCanPlay = () => {
        if (this.disposed) {
          return;
        }
        // console.log('MediaLoader', 'onCanPlay');
        video.oncanplay = null;
        texture = new THREE.VideoTexture(video);
        texture.minFilter = THREE.LinearFilter;
        texture.magFilter = THREE.LinearFilter;
        texture.mapping = THREE.UVMapping;
        // texture.encoding = THREE.sRGBEncoding;
        // texture.format = THREE.RGBAFormat;
        // texture.image.width = video.videoWidth;
        // texture.image.height = video.videoHeight;
        texture.needsUpdate = true;
        if (typeof callback === 'function') {
          callback(texture, this);
        }
        if (autoplay) {
          this.play(item.silent);
        } else {
          video.pause();
        }
      };
      const onTimeUpdate = () => {
        if (this.disposed) {
          return;
        }
        MediaLoader.events$.next(new MediaLoaderTimeUpdateEvent(this));
      };
      const onEnded = () => {
        if (this.disposed) {
          return;
        }
        if (!loop) {
          MediaLoader.events$.next(new MediaLoaderPauseEvent(this));
        }
      };
      video.oncanplay = onCanPlay;
      video.ontimeupdate = onTimeUpdate;
      video.onended = onEnded;
      video.src = MediaLoader.getPath(item);
      video.load(); // must call after setting/changing source
    } else if (item.asset) {
      MediaLoader.loadTexture(item, texture => {
        if (this.disposed) {
          return;
        }
        texture.minFilter = THREE.LinearFilter;
        texture.magFilter = THREE.LinearFilter;
        texture.mapping = THREE.UVMapping;
        // texture.format = THREE.RGBAFormat;
        texture.wrapS = THREE.RepeatWrapping;
        texture.wrapT = THREE.RepeatWrapping;
        if (typeof callback === 'function') {
          callback(texture, this);
        }
      });
    } else {
      callback(null, this);
    }
    return this;
  }
  get progress() {
    if (this.video) {
      return this.video.currentTime / this.video.duration;
    } else {
      return 0;
    }
  }
  set progress(progress) {
    if (this.video) {
      const currentTime = this.video.duration * progress;
      if (this.video.seekable.length > progress && this.video.currentTime !== currentTime) {
        // console.log('MediaLoader', 'progress', progress, 'currentTime', currentTime, 'duration', this.video.duration, 'seekable', this.video.seekable);
        this.video.currentTime = currentTime;
        MediaLoader.events$.next(new MediaLoaderTimeSetEvent(this));
      }
    }
  }
  play(silent) {
    // console.log('MediaLoader.play');
    if (this.video) {
      this.video.muted = this.muted_;
      this.video.play().then(() => {
        // console.log('MediaLoader.play.success', this.item.asset.file);
        if (!silent) {
          MediaLoader.events$.next(new MediaLoaderPlayEvent(this));
        }
      }, error => {
        console.log('MediaLoader.play.error', this.item.asset.file, error);
      });
    }
  }
  pause(silent) {
    // console.log('MediaLoader.pause');
    if (this.video && this.isVideo) {
      this.video.muted = true;
      this.video.pause();
      if (!silent) {
        MediaLoader.events$.next(new MediaLoaderPauseEvent(this));
      }
    }
  }
  toggle() {
    // console.log('MediaLoader.toggle', this.video);
    if (this.video && this.isVideo) {
      if (this.video.paused) {
        this.video.muted = this.muted_;
        this.play();
        return true;
      } else {
        this.pause();
        return false;
      }
    }
  }
  dispose() {
    // console.log('MediaLoader.dispose');
    this.subscription.unsubscribe();
    this.pause(true);
    if (this.isVideo && this.video) {
      this.video.ontimeupdate = null;
      this.video.onended = null;
      MediaLoader.events$.next(new MediaLoaderDisposeEvent(this));
    }
    this.disposed = true;
    delete this.video;
  }
}
MediaLoader.events$ = new rxjs.ReplaySubject(1);const PANORAMA_RADIUS = 101;
class Geometry {
  static get defaultGeometry() {
    return Geometry.defaultGeometry_ || (Geometry.defaultGeometry_ = new THREE.BoxBufferGeometry(1, 1, 1));
  }
  static get planeGeometry() {
    return Geometry.planeGeometry_ || (Geometry.planeGeometry_ = new THREE.PlaneBufferGeometry(1, 1, 2, 2));
  }
  static get sphereGeometry() {
    return Geometry.sphereGeometry_ || (Geometry.sphereGeometry_ = new THREE.SphereBufferGeometry(3, 12, 12));
  }
  static get panoramaGeometry() {
    return Geometry.panoramaGeometry_ || (Geometry.panoramaGeometry_ = new THREE.SphereBufferGeometry(PANORAMA_RADIUS, 36, 36)); // 101, 44, 30
    // return Geometry.panoramaGeometry_ || (Geometry.panoramaGeometry_ = new THREE.IcosahedronBufferGeometry(PANORAMA_RADIUS, 4)); // 101, 44, 30
    // return Geometry.panoramaGeometry_ || (Geometry.panoramaGeometry_ = new THREE.SphereBufferGeometry(PANORAMA_RADIUS, 40, 40)); // 101, 44, 30
  }
}new THREE.Vector3();
class Host {
  static get origin() {
    const host = this.host;
    if (host) {
      const origin = this.origin_;
      origin.set(0, 0, 0);
      const camera = host.renderer.xr.isPresenting ? host.renderer.xr.getCamera(host.camera) : host.camera;
      camera.localToWorld(origin);
      // return host.cameraGroup.position;
    }

    return this.origin_;
  }
  static getDistanceToCamera(camera, fov, aspect, size, fitOffset) {
    if (fitOffset === void 0) {
      fitOffset = 0.88;
    }
    const factor = 2 * Math.atan(Math.PI * fov / 360);
    const heightDistance = size.y * camera.zoom / factor;
    const widthDistance = size.x * camera.zoom / factor / aspect;
    const distance = fitOffset * Math.max(heightDistance, widthDistance);
    return distance;
  }
}
Host.origin_ = new THREE.Vector3();// import DebugService from '../debug.service';
class Interactive {}
Interactive.items = [];
Interactive.hittest = interactiveHittest.bind(Interactive);
Interactive.dispose = interactiveDispose.bind(Interactive);
function interactiveHittest(raycaster, down, event) {
  if (down === void 0) {
    down = false;
  }
  // const debugService = DebugService.getService();
  let dirty = false;
  if (this.down !== down) {
    this.down = down;
    this.lock = false;
    dirty = true;
  }
  const items = this.items.filter(x => x.parent && !x.freezed);
  const intersections = raycaster.intersectObjects(items);
  let key, hit;
  const hash = {};
  intersections.forEach((intersection, i) => {
    const object = intersection.object;
    key = object.uuid;
    if (i === 0) {
      if (this.lastIntersectedObject !== object || dirty) {
        this.lastIntersectedObject = object;
        hit = object;
        // debugService.setMessage(hit.name || hit.id);
        // haptic feedback
      } else if (object.intersection && (Math.abs(object.intersection.point.x - intersection.point.x) > 0.01 || Math.abs(object.intersection.point.y - intersection.point.y) > 0.01)) {
        object.intersection = intersection;
        object.emit('move', object);
      }
    }
    hash[key] = intersection;
  });
  if (intersections.length === 0) {
    this.lastIntersectedObject = null;
  }
  items.forEach(x => {
    x.intersection = hash[x.uuid];
    x.over = x === this.lastIntersectedObject || x.intersection && !x.depthTest && (!this.lastIntersectedObject || this.lastIntersectedObject.depthTest);
    x.down = down && x.over && !this.lock;
    if (x.down) {
      this.lock = true;
    }
  });
  return hit;
}
function interactiveDispose(object) {
  if (object) {
    const index = this.items.indexOf(object);
    if (index !== -1) {
      this.items.splice(index, 1);
    }
  }
}class FreezableMesh extends three.Mesh {
  get freezed() {
    return this.freezed_;
  }
  set freezed(freezed) {
    // !!! cycle through freezable and not freezable
    this.freezed_ = freezed;
    this.children.filter(x => x.__lookupGetter__('freezed')).forEach(x => x.freezed = freezed);
  }
  constructor(geometry, material) {
    geometry = geometry || Geometry.defaultGeometry;
    material = material || new THREE.MeshBasicMaterial({
      color: 0xff00ff
      // opacity: 1,
      // transparent: true,
    });

    super(geometry, material);
    this.freezed = false;
  }
  freeze() {
    this.freezed = true;
  }
  unfreeze() {
    this.freezed = false;
  }
}class EmittableMesh extends FreezableMesh {
  constructor(geometry, material) {
    geometry = geometry || Geometry.defaultGeometry;
    material = material || new THREE.MeshBasicMaterial({
      color: 0xff00ff
      // opacity: 1,
      // transparent: true,
    });

    super(geometry, material);
    this.events = {};
  }
  on(type, callback) {
    const event = this.events[type] = this.events[type] || [];
    event.push(callback);
    return () => {
      this.events[type] = event.filter(x => x !== callback);
    };
  }
  off(type, callback) {
    const event = this.events[type];
    if (event) {
      this.events[type] = event.filter(x => x !== callback);
    }
  }
  emit(type, data) {
    const event = this.events[type];
    if (event) {
      event.forEach(callback => {
        // callback.call(this, data);
        callback(data);
      });
    }
    const broadcast = this.events.broadcast;
    if (broadcast) {
      broadcast.forEach(callback => {
        callback(type, data);
      });
    }
  }
}class InteractiveMesh extends EmittableMesh {
  constructor(geometry, material) {
    super(geometry, material);
    this.depthTest = true;
    this.over_ = false;
    this.down_ = false;
    Interactive.items.push(this);
  }
  get isInteractiveMesh() {
    return true;
  }
  get over() {
    return this.over_;
  }
  set over(over) {
    if (this.over_ != over) {
      this.over_ = over;
      /*
      if (over) {
      	this.emit('hit', this);
      }
      */
      if (over) {
        this.emit('over', this);
      } else {
        this.emit('out', this);
      }
    }
  }
  get down() {
    return this.down_;
  }
  set down(down) {
    down = down && this.over;
    if (this.down_ != down) {
      this.down_ = down;
      if (down) {
        this.emit('down', this);
      } else {
        this.emit('up', this);
      }
    }
  }
}// https://github.com/mrdoob/three.js/issues/5552
// http://en.wikipedia.org/wiki/RGBE_image_format

class RGBELoader extends three.DataTextureLoader {

	constructor( manager ) {

		super( manager );

		this.type = three.HalfFloatType;

	}

	// adapted from http://www.graphics.cornell.edu/~bjw/rgbe.html

	parse( buffer ) {

		const
			/* return codes for rgbe routines */
			//RGBE_RETURN_SUCCESS = 0,
			RGBE_RETURN_FAILURE = - 1,

			/* default error routine.  change this to change error handling */
			rgbe_read_error = 1,
			rgbe_write_error = 2,
			rgbe_format_error = 3,
			rgbe_memory_error = 4,
			rgbe_error = function ( rgbe_error_code, msg ) {

				switch ( rgbe_error_code ) {

					case rgbe_read_error: console.error( 'THREE.RGBELoader Read Error: ' + ( msg || '' ) );
						break;
					case rgbe_write_error: console.error( 'THREE.RGBELoader Write Error: ' + ( msg || '' ) );
						break;
					case rgbe_format_error: console.error( 'THREE.RGBELoader Bad File Format: ' + ( msg || '' ) );
						break;
					default:
					case rgbe_memory_error: console.error( 'THREE.RGBELoader: Error: ' + ( msg || '' ) );

				}

				return RGBE_RETURN_FAILURE;

			},

			/* offsets to red, green, and blue components in a data (float) pixel */
			//RGBE_DATA_RED = 0,
			//RGBE_DATA_GREEN = 1,
			//RGBE_DATA_BLUE = 2,

			/* number of floats per pixel, use 4 since stored in rgba image format */
			//RGBE_DATA_SIZE = 4,

			/* flags indicating which fields in an rgbe_header_info are valid */
			RGBE_VALID_PROGRAMTYPE = 1,
			RGBE_VALID_FORMAT = 2,
			RGBE_VALID_DIMENSIONS = 4,

			NEWLINE = '\n',

			fgets = function ( buffer, lineLimit, consume ) {

				const chunkSize = 128;

				lineLimit = ! lineLimit ? 1024 : lineLimit;
				let p = buffer.pos,
					i = - 1, len = 0, s = '',
					chunk = String.fromCharCode.apply( null, new Uint16Array( buffer.subarray( p, p + chunkSize ) ) );

				while ( ( 0 > ( i = chunk.indexOf( NEWLINE ) ) ) && ( len < lineLimit ) && ( p < buffer.byteLength ) ) {

					s += chunk; len += chunk.length;
					p += chunkSize;
					chunk += String.fromCharCode.apply( null, new Uint16Array( buffer.subarray( p, p + chunkSize ) ) );

				}

				if ( - 1 < i ) {

					/*for (i=l-1; i>=0; i--) {
						byteCode = m.charCodeAt(i);
						if (byteCode > 0x7f && byteCode <= 0x7ff) byteLen++;
						else if (byteCode > 0x7ff && byteCode <= 0xffff) byteLen += 2;
						if (byteCode >= 0xDC00 && byteCode <= 0xDFFF) i--; //trail surrogate
					}*/
					if ( false !== consume ) buffer.pos += len + i + 1;
					return s + chunk.slice( 0, i );

				}

				return false;

			},

			/* minimal header reading.  modify if you want to parse more information */
			RGBE_ReadHeader = function ( buffer ) {


				// regexes to parse header info fields
				const magic_token_re = /^#\?(\S+)/,
					gamma_re = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,
					exposure_re = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,
					format_re = /^\s*FORMAT=(\S+)\s*$/,
					dimensions_re = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,

					// RGBE format header struct
					header = {

						valid: 0, /* indicate which fields are valid */

						string: '', /* the actual header string */

						comments: '', /* comments found in header */

						programtype: 'RGBE', /* listed at beginning of file to identify it after "#?". defaults to "RGBE" */

						format: '', /* RGBE format, default 32-bit_rle_rgbe */

						gamma: 1.0, /* image has already been gamma corrected with given gamma. defaults to 1.0 (no correction) */

						exposure: 1.0, /* a value of 1.0 in an image corresponds to <exposure> watts/steradian/m^2. defaults to 1.0 */

						width: 0, height: 0 /* image dimensions, width/height */

					};

				let line, match;

				if ( buffer.pos >= buffer.byteLength || ! ( line = fgets( buffer ) ) ) {

					return rgbe_error( rgbe_read_error, 'no header found' );

				}

				/* if you want to require the magic token then uncomment the next line */
				if ( ! ( match = line.match( magic_token_re ) ) ) {

					return rgbe_error( rgbe_format_error, 'bad initial token' );

				}

				header.valid |= RGBE_VALID_PROGRAMTYPE;
				header.programtype = match[ 1 ];
				header.string += line + '\n';

				while ( true ) {

					line = fgets( buffer );
					if ( false === line ) break;
					header.string += line + '\n';

					if ( '#' === line.charAt( 0 ) ) {

						header.comments += line + '\n';
						continue; // comment line

					}

					if ( match = line.match( gamma_re ) ) {

						header.gamma = parseFloat( match[ 1 ] );

					}

					if ( match = line.match( exposure_re ) ) {

						header.exposure = parseFloat( match[ 1 ] );

					}

					if ( match = line.match( format_re ) ) {

						header.valid |= RGBE_VALID_FORMAT;
						header.format = match[ 1 ];//'32-bit_rle_rgbe';

					}

					if ( match = line.match( dimensions_re ) ) {

						header.valid |= RGBE_VALID_DIMENSIONS;
						header.height = parseInt( match[ 1 ], 10 );
						header.width = parseInt( match[ 2 ], 10 );

					}

					if ( ( header.valid & RGBE_VALID_FORMAT ) && ( header.valid & RGBE_VALID_DIMENSIONS ) ) break;

				}

				if ( ! ( header.valid & RGBE_VALID_FORMAT ) ) {

					return rgbe_error( rgbe_format_error, 'missing format specifier' );

				}

				if ( ! ( header.valid & RGBE_VALID_DIMENSIONS ) ) {

					return rgbe_error( rgbe_format_error, 'missing image size specifier' );

				}

				return header;

			},

			RGBE_ReadPixels_RLE = function ( buffer, w, h ) {

				const scanline_width = w;

				if (
					// run length encoding is not allowed so read flat
					( ( scanline_width < 8 ) || ( scanline_width > 0x7fff ) ) ||
					// this file is not run length encoded
					( ( 2 !== buffer[ 0 ] ) || ( 2 !== buffer[ 1 ] ) || ( buffer[ 2 ] & 0x80 ) )
				) {

					// return the flat buffer
					return new Uint8Array( buffer );

				}

				if ( scanline_width !== ( ( buffer[ 2 ] << 8 ) | buffer[ 3 ] ) ) {

					return rgbe_error( rgbe_format_error, 'wrong scanline width' );

				}

				const data_rgba = new Uint8Array( 4 * w * h );

				if ( ! data_rgba.length ) {

					return rgbe_error( rgbe_memory_error, 'unable to allocate buffer space' );

				}

				let offset = 0, pos = 0;

				const ptr_end = 4 * scanline_width;
				const rgbeStart = new Uint8Array( 4 );
				const scanline_buffer = new Uint8Array( ptr_end );
				let num_scanlines = h;

				// read in each successive scanline
				while ( ( num_scanlines > 0 ) && ( pos < buffer.byteLength ) ) {

					if ( pos + 4 > buffer.byteLength ) {

						return rgbe_error( rgbe_read_error );

					}

					rgbeStart[ 0 ] = buffer[ pos ++ ];
					rgbeStart[ 1 ] = buffer[ pos ++ ];
					rgbeStart[ 2 ] = buffer[ pos ++ ];
					rgbeStart[ 3 ] = buffer[ pos ++ ];

					if ( ( 2 != rgbeStart[ 0 ] ) || ( 2 != rgbeStart[ 1 ] ) || ( ( ( rgbeStart[ 2 ] << 8 ) | rgbeStart[ 3 ] ) != scanline_width ) ) {

						return rgbe_error( rgbe_format_error, 'bad rgbe scanline format' );

					}

					// read each of the four channels for the scanline into the buffer
					// first red, then green, then blue, then exponent
					let ptr = 0, count;

					while ( ( ptr < ptr_end ) && ( pos < buffer.byteLength ) ) {

						count = buffer[ pos ++ ];
						const isEncodedRun = count > 128;
						if ( isEncodedRun ) count -= 128;

						if ( ( 0 === count ) || ( ptr + count > ptr_end ) ) {

							return rgbe_error( rgbe_format_error, 'bad scanline data' );

						}

						if ( isEncodedRun ) {

							// a (encoded) run of the same value
							const byteValue = buffer[ pos ++ ];
							for ( let i = 0; i < count; i ++ ) {

								scanline_buffer[ ptr ++ ] = byteValue;

							}
							//ptr += count;

						} else {

							// a literal-run
							scanline_buffer.set( buffer.subarray( pos, pos + count ), ptr );
							ptr += count; pos += count;

						}

					}


					// now convert data from buffer into rgba
					// first red, then green, then blue, then exponent (alpha)
					const l = scanline_width; //scanline_buffer.byteLength;
					for ( let i = 0; i < l; i ++ ) {

						let off = 0;
						data_rgba[ offset ] = scanline_buffer[ i + off ];
						off += scanline_width; //1;
						data_rgba[ offset + 1 ] = scanline_buffer[ i + off ];
						off += scanline_width; //1;
						data_rgba[ offset + 2 ] = scanline_buffer[ i + off ];
						off += scanline_width; //1;
						data_rgba[ offset + 3 ] = scanline_buffer[ i + off ];
						offset += 4;

					}

					num_scanlines --;

				}

				return data_rgba;

			};

		const RGBEByteToRGBFloat = function ( sourceArray, sourceOffset, destArray, destOffset ) {

			const e = sourceArray[ sourceOffset + 3 ];
			const scale = Math.pow( 2.0, e - 128.0 ) / 255.0;

			destArray[ destOffset + 0 ] = sourceArray[ sourceOffset + 0 ] * scale;
			destArray[ destOffset + 1 ] = sourceArray[ sourceOffset + 1 ] * scale;
			destArray[ destOffset + 2 ] = sourceArray[ sourceOffset + 2 ] * scale;
			destArray[ destOffset + 3 ] = 1;

		};

		const RGBEByteToRGBHalf = function ( sourceArray, sourceOffset, destArray, destOffset ) {

			const e = sourceArray[ sourceOffset + 3 ];
			const scale = Math.pow( 2.0, e - 128.0 ) / 255.0;

			// clamping to 65504, the maximum representable value in float16
			destArray[ destOffset + 0 ] = three.DataUtils.toHalfFloat( Math.min( sourceArray[ sourceOffset + 0 ] * scale, 65504 ) );
			destArray[ destOffset + 1 ] = three.DataUtils.toHalfFloat( Math.min( sourceArray[ sourceOffset + 1 ] * scale, 65504 ) );
			destArray[ destOffset + 2 ] = three.DataUtils.toHalfFloat( Math.min( sourceArray[ sourceOffset + 2 ] * scale, 65504 ) );
			destArray[ destOffset + 3 ] = three.DataUtils.toHalfFloat( 1 );

		};

		const byteArray = new Uint8Array( buffer );
		byteArray.pos = 0;
		const rgbe_header_info = RGBE_ReadHeader( byteArray );

		if ( RGBE_RETURN_FAILURE !== rgbe_header_info ) {

			const w = rgbe_header_info.width,
				h = rgbe_header_info.height,
				image_rgba_data = RGBE_ReadPixels_RLE( byteArray.subarray( byteArray.pos ), w, h );

			if ( RGBE_RETURN_FAILURE !== image_rgba_data ) {

				let data, format, type;
				let numElements;

				switch ( this.type ) {

					case three.FloatType:

						numElements = image_rgba_data.length / 4;
						const floatArray = new Float32Array( numElements * 4 );

						for ( let j = 0; j < numElements; j ++ ) {

							RGBEByteToRGBFloat( image_rgba_data, j * 4, floatArray, j * 4 );

						}

						data = floatArray;
						type = three.FloatType;
						break;

					case three.HalfFloatType:

						numElements = image_rgba_data.length / 4;
						const halfArray = new Uint16Array( numElements * 4 );

						for ( let j = 0; j < numElements; j ++ ) {

							RGBEByteToRGBHalf( image_rgba_data, j * 4, halfArray, j * 4 );

						}

						data = halfArray;
						type = three.HalfFloatType;
						break;

					default:

						console.error( 'THREE.RGBELoader: unsupported type: ', this.type );
						break;

				}

				return {
					width: w, height: h,
					data: data,
					header: rgbe_header_info.string,
					gamma: rgbe_header_info.gamma,
					exposure: rgbe_header_info.exposure,
					format: format,
					type: type
				};

			}

		}

		return null;

	}

	setDataType( value ) {

		this.type = value;
		return this;

	}

	load( url, onLoad, onProgress, onError ) {

		function onLoadCallback( texture, texData ) {

			switch ( texture.type ) {

				case three.FloatType:

					texture.encoding = three.LinearEncoding;
					texture.minFilter = three.LinearFilter;
					texture.magFilter = three.LinearFilter;
					texture.generateMipmaps = false;
					texture.flipY = true;
					break;

				case three.HalfFloatType:

					texture.encoding = three.LinearEncoding;
					texture.minFilter = three.LinearFilter;
					texture.magFilter = three.LinearFilter;
					texture.generateMipmaps = false;
					texture.flipY = true;
					break;

			}

			if ( onLoad ) onLoad( texture, texData );

		}

		return super.load( url, onLoadCallback, onProgress, onError );

	}

}class KeyboardService {
  static keydown$() {
    if (!this.keydown$_) {
      this.keydown$_ = rxjs.fromEvent(window, 'keydown').pipe(operators.shareReplay(1));
    }
    return this.keydown$_;
  }
  static keyup$() {
    if (!this.keyup$_) {
      this.keyup$_ = rxjs.fromEvent(window, 'keyup').pipe(operators.shareReplay(1));
    }
    return this.keyup$_;
  }
  static keys$() {
    if (!this.keys$_) {
      this.keys$_ = rxjs.merge(this.keydown$(), this.keyup$()).pipe(operators.map(event => {
        const keys = this.keys;
        if (event.type === 'keydown') {
          keys[event.key] = true;
        } else {
          delete keys[event.key];
        }
        return this.keys;
      }), operators.startWith(this.keys), operators.shareReplay(1));
    }
    return this.keys$_;
  }
  static key$() {
    if (!this.key$_) {
      const regexp = /\w/;
      this.key$_ = this.keydown$().pipe(operators.filter(event => event.key && event.key.match(regexp)), operators.map(event => event.key), operators.shareReplay(1));
    }
    return this.key$_;
  }
  static typing$() {
    if (!this.typing$_) {
      let typing = '',
        to;
      this.typing$_ = this.key$().pipe(operators.map(key => {
        if (to) {
          clearTimeout(to);
        }
        typing += key;
        to = setTimeout(() => {
          typing = '';
        }, 1500);
        return typing;
      }), operators.shareReplay(1));
    }
    return this.typing$_;
  }
}
KeyboardService.keys = {};let LOADER_UID = 0;
class LoaderService {
  // merge(this.statusSubject, this.validatorsSubject)

  static switchLoaders() {
    const items = Object.keys(this.items).map(key => this.items[key]);
    const items$ = items.length ? rxjs.combineLatest(items) : rxjs.of(items);
    this.progress$.next(items$);
  }
  static getRef() {
    const ref = ++LOADER_UID;
    this.items[ref] = new rxjs.BehaviorSubject({
      loaded: 0,
      total: 1
    });
    this.switchLoaders();
    return ref;
  }
  static setProgress(ref, loaded, total) {
    if (total === void 0) {
      total = 1;
    }
    // console.log('LoaderService.setProgress');
    const item = this.items[ref];
    if (item) {
      item.next({
        loaded,
        total
      });
    }
    if (loaded >= total) {
      setTimeout(() => {
        delete this.items[ref];
        this.switchLoaders();
      }, 300);
    }
    this.switchLoaders();
  }
}
LoaderService.progress = {
  value: 0,
  loaded: 0,
  total: 0,
  count: 0,
  title: ''
};
LoaderService.items = {};
LoaderService.progress$ = new rxjs.ReplaySubject(1).pipe(operators.switchAll(), operators.map(() => {
  const items = Object.keys(LoaderService.items).map(key => LoaderService.items[key]);
  const progress = items.reduce((progress, subject, i, items) => {
    const item = subject.getValue();
    const loaded = item.loaded || 0;
    const total = item.total || 1;
    const value = loaded / total;
    progress.value += value;
    progress.loaded += loaded;
    progress.total += total;
    return progress;
  }, {
    value: 0,
    loaded: 0,
    total: 0
  });
  progress.count = items.length;
  if (items.length) {
    progress.value /= progress.count;
  }
  progress.title = `${Math.round(progress.value * 100)}%`;
  LoaderService.progress = progress;
  return progress;
}));let UID$1 = 0;
const PrefetchServiceEvent = {
  Progress: 'progress',
  Complete: 'complete'
};
class PrefetchService {
  static worker() {
    if (!this.worker_) {
      this.worker_ = new Worker(environment.workers.prefetch);
    }
    return this.worker_;
  }
  static events$(assets) {
    if (!('Worker' in window)) {
      return rxjs.of({
        type: PrefetchServiceEvent.Complete,
        data: assets
      });
    }
    const worker = this.worker();
    worker.postMessage({
      id: UID$1
    });
    const id = ++UID$1;
    worker.postMessage({
      id,
      assets
    });
    return rxjs.fromEvent(worker, 'message').pipe(operators.map(event => event.data), operators.filter(event => event.assets === assets), operators.tap(event => {
    }), operators.takeWhile(event => event.type !== PrefetchServiceEvent.Complete, true), operators.finalize(() => {
      // console.log('PrefetchService.finalize', lastEvent);
      worker.postMessage({
        id
      });
    }));
  }
  static load$(assets) {
    return this.events$(assets).pipe(operators.filter(event => event.type === PrefetchServiceEvent.Complete), operators.map(event => event.data));
  }
  static prefetch(assets) {
    if (environment.flags.usePrefetch) {
      this.load$(assets).pipe(operators.first()).subscribe(event => {
        // console.log('PrefetchService.prefetch', event);
      });
    }
  }
  static cancel() {
    if (!('Worker' in window)) {
      return null;
    }
    const worker = this.worker();
    worker.postMessage({
      id: UID$1
    });
    return worker;
  }
}class Rect {
  constructor(rect) {
    this.x = 0;
    this.y = 0;
    this.top = 0;
    this.right = 0;
    this.bottom = 0;
    this.left = 0;
    this.width = 0;
    this.height = 0;
    this.set(rect);
  }
  static contains(rect, left, top) {
    return rect.top <= top && top <= rect.bottom && rect.left <= left && left <= rect.right;
  }
  static intersectRect(r1, r2) {
    return !(r2.left > r1.right || r2.right < r1.left || r2.top > r1.bottom || r2.bottom < r1.top);
  }
  static fromNode(node) {
    if (!node) {
      return;
    }
    const rect = node.rect_ || (node.rect_ = new Rect());
    const rects = node.getClientRects();
    if (!rects.length) {
      // console.log(rects, node);
      return rect;
    }
    const boundingRect = node.getBoundingClientRect();
    // rect.top: boundingRect.top + defaultView.pageYOffset,
    // rect.left: boundingRect.left + defaultView.pageXOffset,
    rect.x = boundingRect.left;
    rect.y = boundingRect.top;
    rect.top = boundingRect.top;
    rect.left = boundingRect.left;
    rect.width = boundingRect.width;
    rect.height = boundingRect.height;
    rect.right = rect.left + rect.width;
    rect.bottom = rect.top + rect.height;
    rect.setCenter();
    return rect;
  }
  set(rect) {
    if (rect) {
      Object.assign(this, rect);
      this.right = this.left + this.width;
      this.bottom = this.top + this.height;
    }
    this.setCenter();
  }
  setSize(w, h) {
    this.width = w;
    this.height = h;
    this.right = this.left + this.width;
    this.bottom = this.top + this.height;
    this.setCenter();
    // console.log(w, h);
  }

  setCenter() {
    const center = this.center || (this.center = {});
    center.top = this.top + this.height / 2;
    center.left = this.left + this.width / 2;
    center.x = center.left;
    center.y = center.top;
  }
  contains(left, top) {
    return Rect.contains(this, left, top);
  }
  intersect(rect) {
    return Rect.intersectRect(this, rect);
  }
  intersection(rect) {
    const intersection = this.intersection_ || (this.intersection_ = {
      left: 0,
      top: 0,
      width: 0,
      height: 0,
      x: 0,
      y: 0,
      pow: {
        x: -1,
        y: -1
      },
      offset: function (offset) {
        offset = offset || 0;
        const pow = (this.top - this.rect.height / 2 + offset) / -this.height;
        return pow;
      },
      scroll: function (offset) {
        offset = offset || 0;
        const pow = (this.top - this.rect.height / 2 + offset) / -this.height;
        return pow;
      }
    });
    intersection.left = this.left;
    intersection.top = this.top;
    intersection.width = this.width;
    intersection.height = this.height;
    intersection.x = this.left + this.width / 2;
    intersection.y = this.top + this.height / 2;
    intersection.rect = rect;
    const pow = intersection.offset(0);
    intersection.pow.y = pow;
    return intersection;
  }
}const W$1 = 320;
const H$1 = 240;
const COLORS$1 = [0xffcc00, 0x00ffcc, 0x00ccff, 0xccff00, 0xcc00ff, 0xffffff];
class AvatarElement {
  static get headGeometry() {
    if (!this.headGeometry_) {
      this.headGeometry_ = new THREE.SphereBufferGeometry(0.2, 36, 24);
    }
    return this.headGeometry_;
  }
  constructor(message) {
    const clientId = this.clientId = message.clientId;
    const container = this.container = message.container;
    const renderer = this.renderer = new THREE.WebGLRenderer({
      antialias: true,
      alpha: false,
      premultipliedAlpha: true
      // physicallyCorrectLights: true,
    });

    renderer.setClearColor(0x000000, 1);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(W$1, H$1);
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 0.8;
    renderer.outputEncoding = THREE.sRGBEncoding;
    container.appendChild(renderer.domElement);
    const camera = this.camera = new THREE.PerspectiveCamera(70, W$1 / H$1, 0.01, 1000);
    camera.position.set(0, 0, -0.5);
    camera.target = new THREE.Vector3();
    camera.lookAt(camera.target);
    const scene = this.scene = new THREE.Scene();

    /*
    const ambient = this.ambient = new THREE.AmbientLight(0x202020);
    scene.add(ambient);
    */

    const light = this.light = new THREE.PointLight(0xffffff, 1, 100);
    light.position.set(0, 2, -2);
    scene.add(light);
    const head = this.head = this.addHead();
    scene.add(head);
    this.remote = StreamService.getRemoteById(clientId);
    /*
    if (remote) {
    	this.subscription = AudioStreamService.volume$(remote.stream).pipe(
    		auditTime(Math.floor(1000 / 15)),
    		tap(meter => {
    			this.chalk(meter.volume);
    		})
    	);
    }
    */
  }

  addHead() {
    const geometry = AvatarElement.headGeometry;
    const canvas = this.canvas = document.createElement('canvas');
    canvas.width = 1024;
    canvas.height = 512;
    this.ctx = this.canvas.getContext('2d');
    const map = this.map = new THREE.CanvasTexture(canvas);
    map.offset.x = -0.25;
    const color = COLORS$1[this.clientId % COLORS$1.length];
    const material = new THREE.MeshStandardMaterial({
      map: map,
      color: color
    });
    this.chalk(0);
    return new THREE.Mesh(geometry, material);
  }
  render() {
    this.tick_ ? ++this.tick_ : this.tick_ = 1;
    // if (tick % 2 === 1) {
    if (this.remote) {
      const audioLevel = this.remote.getAudioLevel() * 12;
      this.chalk(audioLevel);
    }
    const renderer = this.renderer,
      scene = this.scene,
      camera = this.camera;
    renderer.render(scene, camera);
    // }
  }

  update(message) {
    const camera = message.camera;
    const head = this.head;
    head.quaternion.set(camera[3], camera[4], camera[5], camera[6]);
    /*
    head.position.set(camera[0], camera[1], camera[2]);
    */
  }

  dispose() {
    // !!! dispose threejs
    if (this.subscription) {
      this.subscription.unsubscribe();
    }
  }
  chalk(i) {
    i = (i + Math.PI * 0.5) % (Math.PI * 2);
    const vol = Math.sin(i) * 30;
    const smile = Math.cos(i) * 10;
    const x = 512;
    const y = 256;
    const ctx = this.ctx;
    ctx.fillStyle = '#888888';
    ctx.fillRect(0, 0, 1024, 512);
    ctx.fillStyle = 'white';
    ctx.beginPath();
    ctx.arc(x - 40, y - 50, 7, 0, 2 * Math.PI);
    ctx.arc(x + 40, y - 50, 7, 0, 2 * Math.PI);
    ctx.closePath();
    ctx.fill();
    ctx.beginPath();
    // ctx.quadraticCurveTo(x - 30, y + 30, x - 30, y + 30);
    // ctx.quadraticCurveTo(x - 30, y + 60, x, y + 60);
    // ctx.quadraticCurveTo(x + 30, y + 60, x + 30, y + 30);
    // ctx.quadraticCurveTo(x + 30, y, x, y);
    ctx.moveTo(x - 40 - smile, y + 30);
    ctx.bezierCurveTo(x - 40 - smile, y + 60, x + 40 + smile, y + 60, x + 40 + smile, y + 30);
    ctx.bezierCurveTo(x + 40 + smile, y + vol, x - 40 - smile, y + vol, x - 40 - smile, y + 30);
    // ctx.arc(x, 256 + 50, 50, 0, 2 * Math.PI);
    ctx.closePath();
    ctx.fill();
    this.map.needsUpdate = true;
  }
}class Texture {
  static get defaultTexture() {
    return Texture.defaultTexture_ || (Texture.defaultTexture_ = new THREE.TextureLoader().load('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyNpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDYuMC1jMDA2IDc5LjE2NDc1MywgMjAyMS8wMi8xNS0xMTo1MjoxMyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIDIyLjMgKFdpbmRvd3MpIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjcyODFGQkE0QUMxODExRUJBQkRBQTEyMzUzMjUxRjg2IiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOjcyODFGQkE1QUMxODExRUJBQkRBQTEyMzUzMjUxRjg2Ij4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6NzI4MUZCQTJBQzE4MTFFQkFCREFBMTIzNTMyNTFGODYiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6NzI4MUZCQTNBQzE4MTFFQkFCREFBMTIzNTMyNTFGODYiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz55AlN+AAAAZUlEQVR42uzQAQEAAAQDMPTvfD3YIqyT1GdTzwkQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAAAECBAgQIECAgAtWgAEAVbYDfaostxgAAAAASUVORK5CYII='));
  }
  static get gridTexture() {
    return Texture.gridTexture_ || (Texture.gridTexture_ = new THREE.TextureLoader().load(environment.getPath(environment.textures.grid)));
  }
}class MediaPlayMesh extends InteractiveMesh {
  static getLoader() {
    return MediaPlayMesh.loader || (MediaPlayMesh.loader = new THREE.TextureLoader());
  }
  static getTextureOff() {
    return MediaPlayMesh.textureOff || (MediaPlayMesh.textureOff = MediaPlayMesh.getLoader().load(environment.getPath('textures/ui/play-off.png')));
  }
  static getTextureOn() {
    return MediaPlayMesh.textureOn || (MediaPlayMesh.textureOn = MediaPlayMesh.getLoader().load(environment.getPath('textures/ui/play-on.png')));
  }
  static getMaterial() {
    const material = new THREE.MeshBasicMaterial({
      map: MediaPlayMesh.getTextureOff(),
      color: 0xffffff,
      opacity: 1,
      transparent: true
    });
    return material;
  }
  get playing() {
    return this.playing_;
  }
  set playing(playing) {
    if (this.playing_ !== playing) {
      this.playing_ = playing;
      const material = this.material;
      material.map = playing ? MediaPlayMesh.getTextureOn() : MediaPlayMesh.getTextureOff();
      this.onOut();
      // material.needsUpdate = true;
      // this.emit('playing', playing);
      // console.log('MediaPlayMesh.playing', playing);
    }
  }

  constructor(host) {
    const geometry = Geometry.planeGeometry;
    const material = MediaPlayMesh.getMaterial();
    super(geometry, material);
    this.playing_ = false;
    this.material = material;
    this.host = host;
    // this.color = new THREE.Color(material.color.getHex());
    this.colorOff = new THREE.Color(material.color.getHex());
    this.colorOn = new THREE.Color('#888888'); // new THREE.Color('#0099ff');
    this.addEventListener();
  }
  update(parent) {
    const scale = this.scale;
    const parentRatio = parent.scale.x / parent.scale.y;
    const size = 0.3;
    scale.set(size / parentRatio, size, 1);
    // console.log('MediaPlayMesh.setParentScale', parent.scale, scale, position);
  }

  disposeMaterial() {
    if (this.material) {
      if (this.material.map && this.material.map.disposable !== false) {
        this.material.map.dispose();
      }
      this.material.dispose();
      // this.material = null;
    }
  }

  dispose() {
    this.removeEventListener();
    this.disposeMaterial();
  }
  onOver() {
    const color = this.material.color;
    const target = this.colorOn;
    const material = this.material;
    // console.log('MediaPlayMesh.onOver');
    gsap.to(color, {
      r: target.r,
      g: target.g,
      b: target.b,
      duration: 0.2,
      ease: Power2.easeInOut
    });
    gsap.to(material, {
      opacity: 1,
      duration: 0.2,
      ease: Power2.easeInOut
    });
  }
  onOut() {
    const color = this.material.color;
    const target = this.colorOff;
    const material = this.material;
    // console.log('MediaPlayMesh.onOut');
    gsap.to(color, {
      r: target.r,
      g: target.g,
      b: target.b,
      duration: 0.2,
      ease: Power2.easeInOut
    });
    gsap.to(material, {
      opacity: this.playing ? 0 : 1,
      duration: 0.2,
      ease: Power2.easeInOut
    });
  }
  addEventListener() {
    this.onOver = this.onOver.bind(this);
    this.onOut = this.onOut.bind(this);
    this.on('over', this.onOver);
    this.on('out', this.onOut);
  }
  removeEventListener() {
    this.off('over', this.onOver);
    this.off('out', this.onOut);
  }
}class MediaZoomMesh extends InteractiveMesh {
  static getLoader() {
    return MediaZoomMesh.loader || (MediaZoomMesh.loader = new THREE.TextureLoader());
  }
  static getTextureOff() {
    return MediaZoomMesh.textureOff || (MediaZoomMesh.textureOff = MediaZoomMesh.getLoader().load(environment.getPath('textures/ui/zoom-off.png')));
  }
  static getTextureOn() {
    return MediaZoomMesh.textureOn || (MediaZoomMesh.textureOn = MediaZoomMesh.getLoader().load(environment.getPath('textures/ui/zoom-on.png')));
  }
  static getMaterial() {
    const material = new THREE.MeshBasicMaterial({
      map: MediaZoomMesh.getTextureOff(),
      color: 0xffffff,
      opacity: 1,
      transparent: true
    });
    return material;
  }
  get zoomed() {
    return this.zoomed_;
  }
  set zoomed(zoomed) {
    if (this.zoomed_ !== zoomed) {
      this.zoomed_ = zoomed;
      const material = this.material;
      material.map = zoomed ? MediaZoomMesh.getTextureOn() : MediaZoomMesh.getTextureOff();
      // material.needsUpdate = true;
      /*
      if (zoomed) {
      	// this.originalPosition = this.parent.position.clone();
      	// this.originalQuaternion = this.parent.rotation.clone();
      	// this.originalScale = this.parent.scale.clone();
      } else {
      	this.object.position.copy(this.originalPosition);
      	this.object.scale.copy(this.originalScale);
      	this.object.quaternion.copy(this.originalQuaternion);
      }
      this.updateObjectMatrix();
      */
      // console.log('MediaZoomMesh.zoomed', zoomed);
    }
  }

  constructor(host) {
    const geometry = Geometry.planeGeometry;
    const material = MediaZoomMesh.getMaterial();
    super(geometry, material);
    this.zoomed_ = false;
    this.material = material;
    this.host = host;
    // this.color = new THREE.Color(material.color.getHex());
    this.colorOff = new THREE.Color(material.color.getHex());
    this.colorOn = new THREE.Color('#888888'); // new THREE.Color('#0099ff');
    this.object = new THREE.Object3D();
    this.addEventListener();
  }
  disposeMaterial() {
    if (this.material) {
      if (this.material.map && this.material.map.disposable !== false) {
        this.material.map.dispose();
      }
      this.material.dispose();
      // this.material = null;
    }
  }

  dispose() {
    this.removeEventListener();
    this.disposeMaterial();
  }
  onOver() {
    const color = this.material.color;
    const target = this.colorOn;
    this.material;
    // console.log('MediaZoomMesh.onOver');
    gsap.to(color, {
      r: target.r,
      g: target.g,
      b: target.b,
      duration: 0.2,
      ease: Power2.easeInOut
      /*
      onUpdate: () => {
      	material.needsUpdate = true;
      },
      */
    });
    // this.innerVisible = true;
  }

  onOut() {
    const color = this.material.color;
    const target = this.colorOff;
    this.material;
    // console.log('MediaZoomMesh.onOut');
    gsap.to(color, {
      r: target.r,
      g: target.g,
      b: target.b,
      duration: 0.2,
      ease: Power2.easeInOut
      /*
      onUpdate: () => {
      	material.needsUpdate = true;
      },
      */
    });
    // this.innerVisible = false;
  }

  onToggle() {
    // console.log('MediaZoomMesh.onToggle', !this.zoomed);
    // this.zoomed = !this.zoomed;
    this.emit('zoomed', !this.zoomed);
  }
  addEventListener() {
    this.onOver = this.onOver.bind(this);
    this.onOut = this.onOut.bind(this);
    this.onToggle = this.onToggle.bind(this);
    this.on('over', this.onOver);
    this.on('out', this.onOut);
    this.on('down', this.onToggle);
  }
  removeEventListener() {
    this.off('over', this.onOver);
    this.off('out', this.onOut);
    this.off('down', this.onToggle);
  }
}const VERTEX_SHADER$1 = `
varying vec2 vUvShader;

#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>

void main() {
	vUvShader = uv;

	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}
`;
const FRAGMENT_SHADER$1 = `
#define USE_MAP

varying vec2 vUvShader;

uniform vec3 diffuse;
uniform float opacity;

#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif

#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

// uniform sampler2D map;
uniform sampler2D playMap;
uniform vec2 mapResolution;
uniform vec2 playMapResolution;
uniform float mapTween;
uniform float playMapTween;
uniform vec3 playMapColor;
uniform bool isVideo;

void main() {
	#include <clipping_planes_fragment>

	vec4 diffuseColor = vec4(vec3(1.0), opacity);

	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>

	// main
	vec4 mapRgba = texture2D(map, vUvShader);
	if (isVideo) {
		vec4 playMapRgba = texture2D(playMap, vUvShader);
		diffuseColor = vec4(mapRgba.rgb + (playMapColor * playMapTween * 0.2) + (playMapRgba.rgb * mapTween * playMapRgba.a), opacity);
	} else {
		diffuseColor = vec4(mapRgba.rgb + (playMapColor * playMapTween * 0.2), opacity);
	}

	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>

	ReflectedLight reflectedLight = ReflectedLight(vec3(0.0), vec3(0.0), vec3(0.0), vec3(0.0));

	// accumulation (baked indirect lighting only)
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif

	// modulation
	#include <aomap_fragment>

	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;

	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}
`;
const FRAGMENT_CHROMA_KEY_SHADER = `
#define USE_MAP
#define threshold 0.55
#define padding 0.05
varying vec2 vUvShader;

uniform vec3 diffuse;
uniform float opacity;

#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif

#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>

// uniform sampler2D map;
uniform sampler2D playMap;
uniform vec2 mapResolution;
uniform vec2 playMapResolution;
uniform float mapTween;
uniform float playMapTween;
uniform vec3 playMapColor;
uniform vec3 chromaKeyColor;
uniform bool isVideo;

void main() {
	#include <clipping_planes_fragment>

	vec4 diffuseColor = vec4( diffuse, opacity );

	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>

	// main
	vec4 mapRgba = texture2D(map, vUvShader);
	vec4 chromaKey = vec4(chromaKeyColor, 1.0);
    vec3 chromaKeyDiff = mapRgba.rgb - chromaKey.rgb;
    float chromaKeyValue = smoothstep(threshold - padding, threshold + padding, dot(chromaKeyDiff, chromaKeyDiff));
	/*
	if (isVideo) {
		vec4 playMapRgba = texture2D(playMap, vUvShader);
		diffuseColor = vec4(mapRgba.rgb + (playMapColor * playMapTween * 0.2) + (playMapRgba.rgb * mapTween * playMapRgba.a), opacity * chromaKeyValue);
	} else {
		diffuseColor = vec4(mapRgba.rgb + (playMapColor * playMapTween * 0.2), opacity * chromaKeyValue);
	}
	*/
	// diffuseColor = vec4(mapRgba.rgb + (playMapColor * playMapTween * 0.2), opacity * chromaKeyValue);
	diffuseColor = vec4(mapRgba.rgb, opacity * chromaKeyValue);

	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>

	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	// accumulation (baked indirect lighting only)
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	// modulation
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;

	#include <envmap_fragment>

	gl_FragColor = vec4(outgoingLight, diffuseColor.a);

	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}
`;
class MediaMesh extends InteractiveMesh {
  static getMaterial(useChromaKey) {
    const material = new THREE.ShaderMaterial({
      depthTest: true,
      // !!!
      depthWrite: true,
      transparent: true,
      toneMapped: false,
      // side: THREE.DoubleSide,
      // blending: THREE.AdditiveBlending,
      vertexShader: VERTEX_SHADER$1,
      fragmentShader: useChromaKey ? FRAGMENT_CHROMA_KEY_SHADER : FRAGMENT_SHADER$1,
      uniforms: {
        map: {
          type: 't',
          value: Texture.defaultTexture
        },
        mapResolution: {
          value: new THREE.Vector2()
        },
        mapTween: {
          value: 1
        },
        color: {
          value: new THREE.Color('#FFFFFF')
        },
        playMap: {
          type: 't',
          value: Texture.defaultTexture
        },
        playMapResolution: {
          value: new THREE.Vector2()
        },
        playMapTween: {
          value: 0
        },
        playMapColor: {
          value: new THREE.Color('#000000')
        },
        opacity: {
          value: 0
        },
        isVideo: {
          value: false
        }
      },
      extensions: {
        fragDepth: true
      }
    });
    return material;
  }
  static getChromaKeyMaterial(chromaKeyColor) {
    if (chromaKeyColor === void 0) {
      chromaKeyColor = [0.0, 1.0, 0.0];
    }
    const material = new THREE.ShaderMaterial({
      depthTest: true,
      // !!!
      depthWrite: true,
      transparent: true,
      toneMapped: false,
      // side: THREE.DoubleSide,
      // blending: THREE.AdditiveBlending,
      vertexShader: VERTEX_SHADER$1,
      fragmentShader: FRAGMENT_CHROMA_KEY_SHADER,
      uniforms: {
        map: {
          type: 't',
          value: null
        },
        // Texture.defaultTexture
        mapResolution: {
          value: new THREE.Vector2()
        },
        mapTween: {
          value: 1
        },
        color: {
          value: new THREE.Color('#FFFFFF')
        },
        chromaKeyColor: {
          value: new THREE.Color(chromaKeyColor[0], chromaKeyColor[1], chromaKeyColor[2])
        },
        playMap: {
          type: 't',
          value: Texture.defaultTexture
        },
        playMapResolution: {
          value: new THREE.Vector2()
        },
        playMapTween: {
          value: 0
        },
        playMapColor: {
          value: new THREE.Color('#000000')
        },
        opacity: {
          value: 0
        },
        isVideo: {
          value: false
        }
      },
      extensions: {
        fragDepth: true
      }
    });
    material.map = true;
    return material;
  }
  static isPublisherStream(stream) {
    return stream.clientInfo && stream.clientInfo.role === RoleType.Publisher && stream.clientInfo.uid === stream.streamId;
  }
  static isAttendeeStream(stream) {
    return stream.clientInfo && stream.clientInfo.role === RoleType.Attendee && stream.clientInfo.uid === stream.streamId;
  }
  static isSmartDeviceStream(stream) {
    return stream.clientInfo && stream.clientInfo.role === RoleType.SmartDevice && stream.clientInfo.uid === stream.streamId;
  }
  static isPublisherScreen(stream) {
    // console.log(stream.clientInfo, stream.clientInfo ? [stream.clientInfo.role, stream.clientInfo.screenUid, stream.streamId] : null);
    return stream.clientInfo && stream.clientInfo.role === RoleType.Publisher && stream.clientInfo.screenUid === stream.streamId;
  }
  static isAttendeeScreen(stream) {
    return stream.clientInfo && stream.clientInfo.role === RoleType.Attendee && stream.clientInfo.screenUid === stream.streamId;
  }
  static getTypeMatcher(assetType) {
    let matcher;
    switch (assetType.name) {
      case AssetType.PublisherStream.name:
        matcher = this.isPublisherStream;
        break;
      case AssetType.AttendeeStream.name:
        matcher = this.isAttendeeStream;
        break;
      case AssetType.SmartDeviceStream.name:
        matcher = this.isSmartDeviceStream;
        break;
      case AssetType.PublisherScreen.name:
        matcher = this.isPublisherScreen;
        break;
      case AssetType.AttendeeScreen.name:
        matcher = this.isAttendeeScreen;
        break;
      default:
        matcher = stream => {
          return false;
        };
    }
    return matcher;
  }
  static getStreamId$(item) {
    if (!item.asset) {
      return rxjs.of(null);
    }
    const assetType = item.asset.type;
    const file = item.asset.file;
    // console.log(item.asset, assetIsStream(item.asset));
    if (assetIsStream(item.asset)) {
      // console.log('MediaMesh.getStreamId$', item.asset.type.name);
      return StreamService.streams$.pipe(operators.map(streams => {
        let stream;
        let i = 0;
        const matchType = this.getTypeMatcher(assetType);
        streams.forEach(x => {
          // console.log('MediaMesh.getStreamId$', x.clientInfo, x.clientInfo ? [x.clientInfo.screenUid, x.streamId] : null);
          if (matchType(x)) {
            if (i === item.asset.index) {
              stream = x;
            }
            i++;
          }
        });
        if (stream) {
          // console.log('MediaMesh.getStreamId$', assetType.name, stream.clientInfo.role, stream.streamId);
          return stream.streamId;
        } else {
          // console.log('MediaMesh.getStreamId$.notfound', assetType.name);
          return null;
        }
      }));
    } else {
      return rxjs.of(file);
    }
  }
  static getMaterialByItem(item) {
    let material;
    if (item.asset && item.asset.chromaKeyColor) {
      material = MediaMesh.getChromaKeyMaterial(item.asset.chromaKeyColor);
    } else if (item.asset) {
      // material = new THREE.MeshBasicMaterial({ color: 0x888888 });
      // material = new THREE.MeshBasicMaterial({ color: 0xffffff, toneMapped: false });
      material = new THREE.MeshBasicMaterial({
        color: 0xffffff,
        toneMapped: false
      });
      // material = new THREE.MeshPhysicalMaterial({ clearcoat: 1, clearcoatRoughness: 0, toneMapped: false, encoding: THREE.sRGBEncoding });
    } else {
      material = new THREE.MeshBasicMaterial({
        color: 0xffffff,
        toneMapped: false
      });
    }
    return material;
  }
  static getUniformsByItem(item) {
    let uniforms = null;
    if (item.asset) {
      uniforms = {
        mapTween: 1,
        playMapTween: 0,
        opacity: 0
      };
    }
    return uniforms;
  }
  get editing() {
    return this.editing_;
  }
  set editing(editing) {
    if (this.editing_ !== editing) {
      this.editing_ = editing;
      // this.zoomed = editing ? false : (this.view.type.name === 'media' ? true : this.zoomed);
      this.zoomed = this.view.type.name === 'media' ? true : editing ? false : this.zoomed;
    }
  }
  constructor(item, view, geometry, host) {
    const material = MediaMesh.getMaterialByItem(item);
    super(geometry, material);
    // this.renderOrder = environment.renderOrder.plane;
    this.zoomed_ = false;
    this.item = item;
    this.view = view;
    this.items = view.items;
    this.host = host;
    this.uniforms = MediaMesh.getUniformsByItem(item);
    this.object = new THREE.Object3D();
    this.tempPosition = new THREE.Vector3();
    this.tempRotation = new THREE.Vector3();
    item.silent = this.isAutoplayLoop; // !!!
    this.mediaLoader = new MediaLoader(item);
    this.onOver = this.onOver.bind(this);
    this.onOut = this.onOut.bind(this);
    this.onToggle = this.onToggle.bind(this);
    this.onZoomed = this.onZoomed.bind(this);
    this.addPlayBtn();
    this.addZoomBtn();
    this.userData.render = (time, tick) => {
      this.render(this, time, tick);
    };
  }
  load(callback) {
    if (this.playBtn) {
      this.remove(this.playBtn);
    }
    if (this.zoomBtn) {
      this.remove(this.zoomBtn);
    }
    if (!this.item.asset) {
      this.onAppear();
      if (typeof callback === 'function') {
        callback(this);
      }
      return;
    }
    const material = this.material;
    const mediaLoader = this.mediaLoader;
    const onMediaLoaderLoaded = texture => {
      // console.log('MediaMesh.texture', texture);
      const loader = this.mediaLoader;
      if (!loader) {
        return;
      }
      if (texture) {
        // texture.encoding = THREE.sRGBEncoding;
        material.map = texture; // !!! Enables USE_MAP
        if (material.uniforms) {
          material.uniforms.map.value = texture;
          // material.uniforms.mapResolution.value.x = texture.image.width;
          // material.uniforms.mapResolution.value.y = texture.image.height;
          material.uniforms.mapResolution.value = new THREE.Vector2(texture.image.width || texture.image.videoWidth, texture.image.height || texture.image.videoHeight);
          if (loader.isPlayableVideo) {
            this.makePlayMap(texture, playMap => {
              // console.log('MediaMesh.playMap', playMap);
              playMap.minFilter = THREE.LinearFilter;
              playMap.magFilter = THREE.LinearFilter;
              playMap.mapping = THREE.UVMapping;
              // playMap.format = THREE.RGBAFormat;
              playMap.wrapS = THREE.RepeatWrapping;
              playMap.wrapT = THREE.RepeatWrapping;
              material.uniforms.playMap.value = playMap;
              // material.uniforms.playMapResolution.value.x = playMap.image.width;
              // material.uniforms.playMapResolution.value.y = playMap.image.height;
              material.uniforms.playMapResolution.value = new THREE.Vector2(playMap.image.width, playMap.image.height);
              // console.log(material.uniforms.playMapResolution.value, playMap);
              material.needsUpdate = true;
            });
          }
        }
      }
      material.needsUpdate = true;
      this.onAppear();
      if (loader.isPlayableVideo && this.playBtn) {
        if (material.uniforms) {
          material.uniforms.isVideo.value = true;
        }
        this.on('over', this.onOver);
        this.on('out', this.onOut);
        this.on('down', this.onToggle);
        this.add(this.playBtn);
      }
      if (this.zoomBtn) {
        this.add(this.zoomBtn);
      }
      if (typeof callback === 'function') {
        callback(this);
      }
    };
    /*
    setTimeout(() => {
    	mediaLoader.load(onMediaLoaderLoaded);
    }, 5000);
    */
    mediaLoader.load(onMediaLoaderLoaded);
  }
  makePlayMap(texture, callback) {
    const aw = texture.image.width || texture.image.videoWidth;
    const ah = texture.image.height || texture.image.videoHeight;
    const ar = aw / ah;
    const scale = 0.32;
    const canvas = document.createElement('canvas');
    // document.querySelector('body').appendChild(canvas);
    canvas.width = aw;
    canvas.height = ah;
    const ctx = canvas.getContext('2d');
    ctx.imageSmoothingEnabled = true;
    ctx.imageSmoothingQuality = 'high';
    const image = new Image();
    image.onload = function () {
      const bw = image.width;
      const bh = image.height;
      const br = bw / bh;
      let w;
      let h;
      if (ar > br) {
        w = ah * scale;
        h = w / br;
      } else {
        h = aw * scale;
        w = h * br;
      }
      ctx.drawImage(image, aw / 2 - w / 2, ah / 2 - h / 2, w, h);
      const playMap = new THREE.CanvasTexture(canvas);
      if (typeof callback === 'function') {
        callback(playMap);
      }
    };
    image.crossOrigin = 'anonymous';
    image.src = environment.getPath('textures/ui/play.png');
  }
  events$() {
    const item = this.item;
    const items = this.items;
    if (item.asset && item.asset.linkedPlayId) {
      this.freeze();
    }
    return MediaLoader.events$.pipe(operators.filter(event => event.loader.item && event.loader.item.id === item.id), operators.map(event => {
      if (event instanceof MediaLoaderPlayEvent) {
        this.playing = true;
        if (!this.isAutoplayLoop) {
          if (this.playBtn) {
            this.playBtn.playing = true;
          }
          this.emit('playing', true);
        }
        this.onOut();
      } else if (event instanceof MediaLoaderPauseEvent) {
        this.playing = false;
        if (this.playBtn) {
          this.playBtn.playing = false;
        }
        this.emit('playing', false);
        this.onOut();
      } else if (event instanceof MediaLoaderTimeSetEvent) {
        this.emit('currentTime', event.loader.video.currentTime);
      }
      // console.log('MediaMesh', this.playing);
      if (item.asset && item.asset.linkedPlayId) {
        const eventItem = items.find(x => x.asset && event.src.indexOf(x.asset.file) !== -1 && event.id === item.asset.linkedPlayId);
        if (eventItem) {
          // console.log('MediaLoader.events$.eventItem', event, eventItem);
          if (event instanceof MediaLoaderPlayEvent) {
            this.play();
          } else if (event instanceof MediaLoaderPauseEvent) {
            this.pause();
          }
        }
      }
      return event;
    }));
  }
  onAppear() {
    const uniforms = this.uniforms;
    const material = this.material;
    if (material.uniforms) {
      gsap.to(uniforms, {
        duration: 0.4,
        opacity: 1,
        ease: Power2.easeInOut,
        onUpdate: () => {
          material.uniforms.opacity.value = uniforms.opacity;
          // material.needsUpdate = true;
        }
      });
    }

    this.zoomed = this.view.type.name === 'media' ? true : this.editing ? false : this.zoomed;
  }
  onDisappear() {
    const uniforms = this.uniforms;
    const material = this.material;
    if (material.uniforms) {
      gsap.to(uniforms, {
        duration: 0.4,
        opacity: 0,
        ease: Power2.easeInOut,
        onUpdate: () => {
          material.uniforms.opacity.value = uniforms.opacity;
          // material.needsUpdate = true;
        }
      });
    }
  }

  onOver() {
    const uniforms = this.uniforms;
    const material = this.material;
    if (material.uniforms) {
      gsap.to(uniforms, {
        duration: 0.4,
        mapTween: this.playing ? 0 : 1,
        playMapTween: 1,
        opacity: 1,
        ease: Power2.easeInOut,
        overwrite: true,
        onUpdate: () => {
          material.uniforms.mapTween.value = uniforms.mapTween;
          material.uniforms.playMapTween.value = uniforms.playMapTween;
          material.uniforms.opacity.value = uniforms.opacity;
          // material.needsUpdate = true;
        }
      });
    }

    if (this.playBtn) {
      this.playBtn.onOver();
    }
  }
  onOut() {
    const uniforms = this.uniforms;
    const material = this.material;
    if (material.uniforms) {
      gsap.to(uniforms, {
        duration: 0.4,
        mapTween: this.playing ? 0 : 1,
        playMapTween: 0,
        opacity: 1,
        ease: Power2.easeInOut,
        overwrite: true,
        onUpdate: () => {
          material.uniforms.mapTween.value = uniforms.mapTween;
          material.uniforms.playMapTween.value = uniforms.playMapTween;
          material.uniforms.opacity.value = uniforms.opacity;
          // material.needsUpdate = true;
        }
      });
    }

    if (this.playBtn) {
      this.playBtn.onOut();
    }
  }
  onToggle() {
    this.playing = this.mediaLoader.toggle();
    if (this.playBtn) {
      this.playBtn.playing = this.playing;
    }
    this.emit('playing', this.playing);
    this.onOut();
  }
  play() {
    this.mediaLoader.play();
  }
  pause() {
    this.mediaLoader.pause();
  }
  setPlayingState(playing) {
    if (this.playing !== playing) {
      this.playing = playing;
      playing ? this.mediaLoader.play() : this.mediaLoader.pause();
      this.onOut();
      if (this.playBtn) {
        this.playBtn.playing = playing;
      }
    }
  }
  setZoomedState(zoomed) {
    this.zoomed = zoomed;
  }
  setCurrentTime(currentTime) {
    // !!!
    if (this.mediaLoader.video) {
      this.mediaLoader.video.currentTime = currentTime;
    }
  }
  disposeMaterial() {
    if (this.material) {
      if (this.material.map && this.material.map.disposable !== false) {
        this.material.map.dispose();
      }
      this.material.dispose();
      // this.material = null;
    }
  }

  disposeMediaLoader() {
    const mediaLoader = this.mediaLoader;
    if (mediaLoader) {
      if (mediaLoader.isPlayableVideo) {
        this.off('over', this.onOver);
        this.off('out', this.onOut);
        this.off('down', this.onToggle);
      }
      mediaLoader.dispose();
      this.mediaLoader = null;
    }
  }
  dispose() {
    // console.log('MediaMesh.dispose');
    this.removePlayBtn();
    this.removeZoomBtn();
    this.disposeMediaLoader();
  }
  get isAutoplayLoop() {
    const isAutoplayLoop = this.view.type.name !== 'media' && this.item.asset && this.item.asset.autoplay && this.item.asset.loop;
    // console.log('MediaMesh', isAutoplayLoop);
    return isAutoplayLoop;
  }
  addPlayBtn() {
    this.removePlayBtn();
    if (!this.isAutoplayLoop) {
      const playBtn = this.playBtn = new MediaPlayMesh(this.host);
      playBtn.on('over', this.onOver);
      playBtn.on('out', this.onOut);
      playBtn.on('down', this.onToggle);
      playBtn.position.z = 0.01;
    }
  }
  removePlayBtn() {
    if (this.playBtn) {
      this.remove(this.playBtn);
      this.playBtn.off('over', this.onOver);
      this.playBtn.off('out', this.onOut);
      this.playBtn.off('down', this.onToggle);
      this.playBtn.dispose();
      delete this.playBtn;
    }
  }
  onZoomed(zoomed) {
    this.zoomed = zoomed;
    this.emit('zoomed', zoomed);
  }
  addZoomBtn() {
    this.removeZoomBtn();
    if (this.view.type.name !== 'media' && (!this.item.asset || !this.item.asset.chromaKeyColor)) {
      const zoomBtn = this.zoomBtn = new MediaZoomMesh(this.host);
      zoomBtn.on('zoomed', this.onZoomed);
    }
  }
  removeZoomBtn() {
    if (this.zoomBtn) {
      this.remove(this.zoomBtn);
      this.zoomBtn.off('zoomed', this.onZoomed);
      this.zoomBtn.dispose();
      this.zoomBtn = null;
      delete this.zoomBtn;
    }
  }
  updateByItem(item) {
    this.disposeMaterial();
    this.disposeMediaLoader();
    this.material = MediaMesh.getMaterialByItem(item);
    this.uniforms = MediaMesh.getUniformsByItem(item);
    this.addPlayBtn();
    this.addZoomBtn();
    item.silent = this.isAutoplayLoop; // !!!
    this.mediaLoader = new MediaLoader(item);
  }
  updateFromItem(item) {
    // console.log('MediaMesh.updateFromItem', item);
    if (item.position) {
      this.position.fromArray(item.position);
    }
    if (item.rotation) {
      this.rotation.fromArray(item.rotation);
    }
    if (item.scale) {
      this.scale.fromArray(item.scale);
    }
    if (this.playBtn) {
      this.playBtn.update(this);
    }
    /*
    if (this.zoomBtn) {
    	this.zoomBtn.update(this);
    }
    */
    this.updateZoom();
  }
  updateZoom() {
    this.originalPosition = this.position.clone();
    this.originalScale = this.scale.clone();
    this.originalQuaternion = this.quaternion.clone();
    this.object.position.copy(this.originalPosition);
    this.object.scale.copy(this.originalScale);
    this.object.quaternion.copy(this.originalQuaternion);
    if (this.zoomBtn) {
      const scale = this.zoomBtn.scale;
      const position = this.zoomBtn.position;
      const ratio = this.scale.x / this.scale.y;
      const size = 0.1;
      scale.set(size / ratio, size, 1);
      position.x = 0.5 - size / ratio / 2;
      position.y = size / 2 - 0.5;
      position.z = 0.01;
    }
    // console.log('MediaMesh.updateZoom', this.scale);
  }

  // zoom

  render(time, tick) {
    /*
    if (this.zoomBtn && !this.editing) {
    	this.zoomBtn.render(time, tick);
    }
    */
    if (!this.editing) {
      const object = this.object;
      /*
      parent.position.lerp(object.position, 0.2);
      parent.scale.lerp(object.scale, 0.2);
      parent.quaternion.slerp(object.quaternion, 0.2);
      */
      if (this.zoomed && !this.host.renderer.xr.isPresenting) {
        this.updateObjectMatrix();
      }
      this.position.copy(object.position);
      this.scale.copy(object.scale);
      this.quaternion.copy(object.quaternion);
    }
  }
  updateObjectMatrix() {
    const object = this.object;
    const host = this.host;
    if (this.zoomed) {
      // const cameraGroup = host.cameraGroup;
      const originalScale = this.originalScale;
      let camera = host.camera,
        fov = camera.fov,
        aspect = camera.aspect,
        scale;
      const position = this.tempPosition;
      const rotation = this.tempRotation;
      // const aspect = originalScale.x / originalScale.y;
      scale = 0.01; // 0.01;
      const xr = host.renderer.xr;
      if (xr.isPresenting) {
        camera = xr.getCamera(camera);
        const mat = camera.projectionMatrix.elements;
        const a = mat[0];
        const b = mat[5];
        // const c = mat[10];
        // const d = mat[14];
        aspect = b / a;
        // const k = (c - 1) / (c + 1);
        // const clip_min = (d * (1 - k)) / (2 * k);
        // const clip_max = k * clip_min;
        // const RAD2DEG = 180 / 3.14159265358979323846;
        const RAD2DEG = 180 / 3.141592653589793;
        fov = RAD2DEG * (2 * Math.atan(1 / b));
        scale = 1;
      }
      object.scale.copy(originalScale).multiplyScalar(scale);
      const distance = Host.getDistanceToCamera(camera, fov, aspect, object.scale);
      camera.getWorldDirection(rotation);
      rotation.multiplyScalar(distance);
      position.set(0, 0, 0);
      camera.localToWorld(position);
      position.add(rotation);
      object.position.copy(position);
      object.lookAt(Host.origin);
      if (xr.isPresenting) {
        object.position.y -= object.scale.y / 2;
      }
    }
  }
  get zoomed() {
    return this.zoomed_;
  }
  set zoomed(zoomed) {
    if (this.zoomed_ !== zoomed) {
      this.zoomed_ = zoomed;
      if (zoomed) {
        this.renderOrder = environment.renderOrder.panel + 5;
        this.material.depthTest = true; // !!! false
        // this.originalPosition = this.position.clone();
        // this.originalQuaternion = this.rotation.clone();
        // this.originalScale = this.scale.clone();
      } else {
        this.renderOrder = 0;
        this.material.depthTest = true;
        this.object.position.copy(this.originalPosition);
        this.object.scale.copy(this.originalScale);
        this.object.quaternion.copy(this.originalQuaternion);
      }
      this.material.needsUpdate = true;
      this.updateObjectMatrix();
      if (this.zoomBtn) {
        this.zoomBtn.zoomed = zoomed;
      }
    }
  }
}class DragPoint {
  constructor() {
    this.x = 0;
    this.y = 0;
  }
}
class DragEvent {
  constructor(options) {
    if (options) {
      Object.assign(this, options);
    }
  }
}
class DragDownEvent extends DragEvent {
  constructor(options) {
    super(options);
    this.distance = new DragPoint();
    this.strength = new DragPoint();
    this.speed = new DragPoint();
  }
}
class DragMoveEvent extends DragEvent {
  constructor(options) {
    super(options);
    this.distance = new DragPoint();
    this.strength = new DragPoint();
    this.speed = new DragPoint();
  }
}
class DragUpEvent extends DragEvent {
  constructor(options) {
    super(options);
  }
}
let upEvent;
class DragService {
  static getPosition(event, point) {
    if (event instanceof MouseEvent) {
      point ? (point.x = event.clientX, point.y = event.clientY) : point = {
        x: event.clientX,
        y: event.clientY
      };
    } else if (window.TouchEvent && event instanceof TouchEvent) {
      if (event.touches.length > 0) {
        point ? (point.x = event.touches[0].pageX, point.y = event.touches[0].pageY) : point = {
          x: event.touches[0].pageX,
          y: event.touches[0].pageY
        };
      }
    }
    return point;
  }
  static down$(target, events$) {
    let downEvent;
    return rxjs.merge(rxjs.fromEvent(target, 'mousedown').pipe(operators.filter(event => event.button === 0)), rxjs.fromEvent(target, 'touchstart')).pipe(operators.map(event => {
      downEvent = downEvent || new DragDownEvent();
      downEvent.node = target;
      downEvent.target = event.target;
      downEvent.originalEvent = event;
      downEvent.down = this.getPosition(event, downEvent.down);
      if (downEvent.down) {
        downEvent.distance = new DragPoint();
        downEvent.strength = new DragPoint();
        downEvent.speed = new DragPoint();
        events$.next(downEvent);
        return downEvent;
      }
    }), operators.filter(event => event !== undefined));
  }
  static move$(target, events$, dismiss$, downEvent) {
    let moveEvent;
    return rxjs.fromEvent(document, downEvent.originalEvent instanceof MouseEvent ? 'mousemove' : 'touchmove').pipe(operators.startWith(downEvent), operators.map(event => {
      moveEvent = moveEvent || new DragMoveEvent();
      moveEvent.node = target;
      moveEvent.target = event.target;
      moveEvent.originalEvent = event;
      moveEvent.position = this.getPosition(event, moveEvent.position);
      const dragging = downEvent.down !== undefined && moveEvent.position !== undefined;
      if (dragging) {
        moveEvent.distance.x = moveEvent.position.x - downEvent.down.x;
        moveEvent.distance.y = moveEvent.position.y - downEvent.down.y;
        moveEvent.strength.x = moveEvent.distance.x / window.innerWidth * 2;
        moveEvent.strength.y = moveEvent.distance.y / window.innerHeight * 2;
        moveEvent.speed.x = downEvent.speed.x + (moveEvent.strength.x - downEvent.strength.x) * 0.1;
        moveEvent.speed.y = downEvent.speed.y + (moveEvent.strength.y - downEvent.strength.y) * 0.1;
        downEvent.distance.x = moveEvent.distance.x;
        downEvent.distance.y = moveEvent.distance.y;
        downEvent.speed.x = moveEvent.speed.x;
        downEvent.speed.y = moveEvent.speed.y;
        downEvent.strength.x = moveEvent.strength.x;
        downEvent.strength.y = moveEvent.strength.y;
        events$.next(moveEvent);
        return moveEvent;
      }
    }));
  }
  static dismissEvent(event, events$, dismiss$, downEvent) {
    // console.log('DragService.dismissEvent', event);
    upEvent = upEvent || new DragUpEvent();
    events$.next(upEvent);
    dismiss$.next();
    // console.log(downEvent.distance);
    if (downEvent && Math.abs(downEvent.distance.x) > 10) {
      event.preventDefault();
      event.stopImmediatePropagation();
    }
    return upEvent;
  }
  static up$(target, events$, dismiss$, downEvent) {
    return rxjs.fromEvent(document, downEvent.originalEvent instanceof MouseEvent ? 'mouseup' : 'touchend').pipe(operators.map(event => this.dismissEvent(event, events$, dismiss$, downEvent)));
  }
  static observe$(target) {
    target = target || document;
    const events$ = DragService.events$;
    const dismiss$ = DragService.dismiss$;
    return this.down$(target, events$).pipe(operators.switchMap(downEvent => {
      DragService.downEvent = downEvent;
      return rxjs.merge(this.move$(target, events$, dismiss$, downEvent), this.up$(target, events$, dismiss$, downEvent)).pipe(operators.takeUntil(dismiss$));
    }), operators.switchMap(() => events$));
  }
}
DragService.events$ = new rxjs.ReplaySubject(1);
DragService.dismiss$ = new rxjs.Subject();// https://github.com/google/model-viewer/blob/master/packages/model-viewer/src/three-components/SmoothControls.ts

const OrbitMode = {
  Panorama: 'panorama',
  PanoramaGrid: 'panorama-grid',
  Model: 'model'
};
class OrbitEvent {}
class OrbitDragEvent extends OrbitEvent {}
class OrbitResizeEvent extends OrbitEvent {}
class OrbitMoveEvent extends OrbitEvent {}
const orbitMoveEvent = new OrbitMoveEvent();
const orbitDragEvent = new OrbitDragEvent();
const orbitResizeEvent = new OrbitResizeEvent();
const DOLLY_MIN = 1; // 15;
const DOLLY_MAX = 75; // 115
const ZOOM_MIN = 1; // 15;
const ZOOM_MAX = 75;
class OrbitService {
  get dolly() {
    return this.dolly_;
  }
  set dolly(dolly) {
    const clampedDolly = THREE.Math.clamp(dolly, DOLLY_MIN, DOLLY_MAX);
    if (this.dolly_ !== clampedDolly) {
      this.dolly_ = clampedDolly;
      this.markAsDirty();
    }
  }
  getDollyValue() {
    return 1 - (this.dolly_ - DOLLY_MIN) / (DOLLY_MAX - DOLLY_MIN) - 0.5;
  }
  get zoom() {
    return this.zoom_;
  }
  set zoom(zoom) {
    const clampedDolly = THREE.Math.clamp(zoom, DOLLY_MIN, DOLLY_MAX);
    if (this.zoom_ !== clampedDolly) {
      this.zoom_ = clampedDolly;
      this.markAsDirty();
    }
  }
  getZoomValue() {
    return 1 + 1 - (this.zoom_ - ZOOM_MIN) / (ZOOM_MAX - ZOOM_MIN);
  }
  get mode() {
    return this.mode_;
  }
  set mode(mode) {
    if (this.mode_ !== mode) {
      this.mode_ = mode;
      OrbitService.mode = mode;
      this.markAsDirty();
    }
  }
  get controlled() {
    return StateService.state.controlling && StateService.state.controlling !== StateService.state.uid;
  }
  get controlling() {
    return StateService.state.controlling && StateService.state.controlling === StateService.state.uid;
  }
  get silencing() {
    return StateService.state.silencing;
  }
  get silenced() {
    return StateService.state.silencing && StateService.state.role === RoleType.Streamer;
  }
  get spyed() {
    return StateService.state.spying && StateService.state.spying === StateService.state.uid;
  }
  get spying() {
    return StateService.state.spying && StateService.state.spying !== StateService.state.uid;
  }
  get isMediaView() {
    const currentView = ViewService.currentView;
    return currentView && currentView.type.name === ViewType.Media.name;
  }
  get locked() {
    return this.controlled || this.spying || this.isMediaView;
  }
  constructor(camera) {
    this.mode_ = OrbitService.mode = OrbitMode.Panorama;
    this.dolly_ = 70;
    this.zoom_ = 70;
    this.longitude = 0;
    this.latitude = 0;
    this.direction = 1;
    this.radius = 101;
    this.position = new THREE.Vector3();
    // this.speed = 1;
    this.inertia = new THREE.Vector2();
    this.rotation = new THREE.Euler(0, 0, 0, 'XYZ');
    this.target = new THREE.Vector3();
    this.updatePosition = new THREE.Vector3();
    this.updateTarget = new THREE.Vector3();
    this.camera = camera;
    this.setLongitudeLatitude(0, 0);
    this.events$ = new rxjs.ReplaySubject(1);
  }
  setOrientation(orientation) {
    if (orientation) {
      this.setLongitudeLatitude(orientation.longitude, orientation.latitude);
      this.markAsDirty();
    }
  }
  getOrientation() {
    return {
      latitude: this.latitude,
      longitude: this.longitude
    };
  }
  setLongitudeLatitude(longitude, latitude) {
    latitude = Math.max(-80, Math.min(80, latitude));
    this.longitude = (longitude < 0 ? 360 + longitude : longitude) % 360;
    this.latitude = latitude;
    // console.log(this.longitude);
    const phi = THREE.Math.degToRad(90 - latitude);
    const theta = THREE.Math.degToRad(longitude);
    this.phi = phi;
    this.theta = theta;
  }
  observe$(node) {
    // const camera = this.camera;
    let latitude, longitude;
    return rxjs.combineLatest([KeyboardService.keys$(), DragService.observe$(node)]).pipe(operators.filter(event => !this.locked), operators.map(datas => {
      const keys = datas[0];
      const event = datas[1];
      // const group = this.objects.children[this.index];
      if (event instanceof DragDownEvent) {
        latitude = this.latitude;
        longitude = this.longitude;
      } else if (event instanceof DragMoveEvent) {
        if (keys.Shift) {
          this.events$.next(orbitDragEvent);
        } else if (keys.Control) {
          this.events$.next(orbitResizeEvent);
        } else {
          const flip = this.mode_ === OrbitMode.Model ? -1 : 1;
          this.setLongitudeLatitude(longitude - event.distance.x * 0.1 * flip, latitude + event.distance.y * 0.1);
        }
      } /* else if (event instanceof DragUpEvent) {
        }
        */
      return event;
    }), operators.filter(event => event instanceof DragMoveEvent), operators.startWith({
      latitude: this.latitude,
      longitude: this.longitude
    }), operators.tap(event => this.markAsDirty()), operators.switchMap(event => this.events$));
  }
  walk(position, callback) {
    let radius;
    switch (this.mode_) {
      case OrbitMode.Model:
        radius = 3;
        break;
      default:
        radius = this.radius;
    }
    const heading = new THREE.Vector2(position.x, position.y).normalize().multiplyScalar(radius);
    const headingTheta = Math.atan2(heading.y, heading.x);
    let headingLongitude = THREE.MathUtils.radToDeg(headingTheta);
    headingLongitude = (headingLongitude < 0 ? 360 + headingLongitude : headingLongitude) % 360;
    const headingLatitude = 0;
    const latitude = this.latitude;
    const longitude = this.longitude;
    let differenceLongitude = headingLongitude - longitude;
    differenceLongitude = Math.abs(differenceLongitude) > 180 ? differenceLongitude - 360 * (differenceLongitude / Math.abs(differenceLongitude)) : differenceLongitude;
    let differenceLatitude = headingLatitude - latitude;
    differenceLatitude = Math.abs(differenceLatitude) > 90 ? differenceLatitude - 90 * (differenceLatitude / Math.abs(differenceLatitude)) : differenceLatitude;
    // console.log('headingTheta', headingTheta, 'headingLongitude', headingLongitude, 'differenceLongitude', differenceLongitude);
    const from = {
      tween: 0
    };
    gsap.to(from, {
      duration: 0.7,
      tween: 1,
      delay: 0,
      ease: Power2.easeInOut,
      onUpdate: () => {
        this.setLongitudeLatitude(longitude + differenceLongitude * from.tween, latitude + differenceLatitude * from.tween);
        this.position.set(position.x * from.tween, 0, position.y * from.tween);
        this.markAsDirty();
      },
      onComplete: () => {
        // this.walkComplete(headingLongitude, headingLatitude);
        if (typeof callback === 'function') {
          callback(headingLongitude, headingLatitude);
        }
      }
    });
  }
  walkComplete(headingLongitude, headingLatitude) {
    this.setLongitudeLatitude(headingLongitude, headingLatitude);
    this.position.set(0, 0, 0);
    this.markAsDirty();
  }
  lookAt(object) {
    // console.log('OrbitService.lookAt', object);
    if (object) {
      let position = object.position.clone();
      const camera = this.camera;
      const cameraGroup = camera.parent;
      position = cameraGroup.worldToLocal(position);
      let radius;
      switch (this.mode_) {
        case OrbitMode.Model:
          radius = 3;
          break;
        default:
          radius = this.radius;
      }
      const heading = new THREE.Vector3(position.x, position.z, position.y).normalize().multiplyScalar(radius);
      const theta = Math.atan2(heading.y, heading.x);
      const phi = Math.acos(heading.z / radius);
      let longitude = THREE.MathUtils.radToDeg(theta);
      longitude = (longitude < 0 ? 360 + longitude : longitude) % 360;
      let latitude = 90 - THREE.MathUtils.radToDeg(phi);
      latitude = Math.max(-80, Math.min(80, latitude));
      this.setLongitudeLatitude(longitude, latitude);
      this.markAsDirty();
    }
  }
  setVRCamera(camera) {
    if (camera) {
      const radius = this.radius;
      const position = new THREE.Vector3(0, 0, -radius);
      const quaternion = new THREE.Quaternion(camera[3], camera[4], camera[5], camera[6]);
      position.applyQuaternion(quaternion);
      const heading = new THREE.Vector3(position.x, position.z, position.y).normalize().multiplyScalar(radius);
      const theta = Math.atan2(heading.y, heading.x);
      const phi = Math.acos(heading.z / radius);
      let longitude = THREE.MathUtils.radToDeg(theta);
      longitude = (longitude < 0 ? 360 + longitude : longitude) % 360;
      let latitude = 90 - THREE.MathUtils.radToDeg(phi);
      latitude = Math.max(-80, Math.min(80, latitude));
      this.setLongitudeLatitude(longitude, latitude);
      this.markAsDirty();
    }
  }
  render() {
    // slowly rotate scene when not hosted
    if (!StateService.state.hosted) {
      this.longitude += 0.025;
      this.isDirty = true;
    }
    if (this.isDirty) {
      this.isDirty = false;
      this.update();
    }
  }
  markAsDirty() {
    this.isDirty = true;
  }
  update() {
    let radius,
      position = this.updatePosition,
      target = this.updateTarget;
    const zoom = this.getZoomValue();
    this.getDollyValue();
    // console.log('dolly', dolly);
    const phi = THREE.MathUtils.degToRad(90 - this.latitude);
    const theta = THREE.MathUtils.degToRad(this.longitude);
    const camera = this.camera;
    const cameraGroup = camera.parent;
    switch (this.mode_) {
      case OrbitMode.Model:
        radius = 3;
        position.copy(this.position);
        target.x = this.position.x + radius * Math.sin(phi) * Math.cos(theta);
        target.y = this.position.y + radius * Math.cos(phi);
        target.z = this.position.z + radius * Math.sin(phi) * Math.sin(theta);
        // position = cameraGroup.worldToLocal(position);
        target = cameraGroup.worldToLocal(target);
        camera.target.copy(position);
        camera.position.copy(target);
        break;
      default:
        radius = this.radius;
        target.x = this.position.x + radius * Math.sin(phi) * Math.cos(theta);
        target.y = this.position.y + radius * Math.cos(phi);
        target.z = this.position.z + radius * Math.sin(phi) * Math.sin(theta);
        {
          position.copy(this.position);
        }
        // !!! position for walking panorama-grid
        // position = cameraGroup.worldToLocal(position);
        target = cameraGroup.worldToLocal(target);
        // camera.position.copy(position);
        camera.target.copy(target);
        camera.position.copy(position);
    }
    // console.log(camera.position.x, camera.position.y, camera.position.z);
    // console.log(camera.target.x, camera.target.y, camera.target.z);
    // console.log('phi', phi, 'theta', theta);
    // this.inverse();
    {
      camera.zoom = zoom;
    }
    camera.lookAt(camera.target);
    camera.updateProjectionMatrix();
    const currentView = ViewService.currentView;
    if (currentView) {
      currentView.lastOrientation.longitude = this.longitude;
      currentView.lastOrientation.latitude = this.latitude;
    }
    this.events$.next(orbitMoveEvent);
  }
}
OrbitService.orbitMoveEvent = orbitMoveEvent;let UID = 0;
const ImageServiceEvent = {
  Progress: 'progress',
  Complete: 'complete'
};
class ImageService {
  static worker() {
    if (!this.worker_) {
      this.worker_ = new Worker(environment.workers.image);
    }
    return this.worker_;
  }
  static events$(src, size) {
    if (!('Worker' in window) || this.isBlob(src) || this.isCors(src)) {
      return rxjs.of({
        type: ImageServiceEvent.Complete,
        data: src
      });
    }
    const id = ++UID;
    const worker = this.worker();
    worker.postMessage({
      src,
      id,
      size
    });
    return rxjs.fromEvent(worker, 'message').pipe(operators.map(event => event.data), operators.filter(event => event.src === src), operators.auditTime(100), operators.map(event => {
      // console.log('ImageService', event);
      if (event.type === ImageServiceEvent.Complete && event.data instanceof Blob) {
        const url = URL.createObjectURL(event.data);
        event.data = url;
      }
      return event;
    }), operators.takeWhile(event => event.type !== ImageServiceEvent.Complete, true), operators.finalize(() => {
      // console.log('ImageService.finalize', lastEvent);
      worker.postMessage({
        id
      });
      /*
      if (lastEvent && lastEvent.type === ImageServiceEvent.Complete && lastEvent.data) {
      	URL.revokeObjectURL(lastEvent.data);
      }
      */
    }));
  }

  static load$(src, size) {
    return this.events$(src, size).pipe(operators.filter(event => event.type === ImageServiceEvent.Complete), operators.map(event => event.data));
  }
  static isCors(src) {
    // !!! handle cors environment flag
    return false;
    // return src.indexOf('://') !== -1 && src.indexOf(window.location.host) === -1;
  }

  static isBlob(src) {
    return src.indexOf('blob:') === 0;
  }
}class PanoramaLoader {
  static get video() {
    return this.video_;
  }
  static set video(video) {
    if (this.video_) {
      this.video_.muted = true;
      this.video_.pause();
      if (this.video_.parentNode) {
        this.video_.parentNode.removeChild(this.video_);
      }
      this.video_ = null;
    }
    if (video) {
      const video = this.video_ = document.createElement('video');
      video.loop = true;
      video.playsInline = true;
      video.crossOrigin = 'anonymous';
      // document.querySelector('body').appendChild(video);
    }
  }

  static get muted() {
    return this.muted_;
  }
  static set muted(muted) {
    this.muted_ = muted;
    // console.log('PanoramaLoader.muted', muted, this.video);
    if (this.video) {
      this.video.muted = muted === true;
    }
  }
  static set cubeRenderTarget(cubeRenderTarget) {
    if (this.cubeRenderTarget_) {
      this.cubeRenderTarget_.texture.dispose();
      this.cubeRenderTarget_.dispose();
    }
    this.cubeRenderTarget_ = cubeRenderTarget;
  }
  static set texture(texture) {
    if (this.texture_) {
      this.texture_.dispose();
    }
    this.texture_ = texture;
  }
  static load(asset, renderer, callback) {
    MediaLoader.events$.next(new MediaLoaderDisposeEvent(this));
    this.video = null;
    if (!asset) {
      return;
    }
    // console.log('PanoramaLoader.load', asset.type.name, AssetType);
    if (asset.type.name === AssetType.PublisherStream.name) {
      return this.loadPublisherStreamBackground(renderer, callback);
    } else if (asset.type.name === AssetType.AttendeeStream.name) {
      return this.loadAttendeeStreamBackground(renderer, callback);
      /*} else if (assetIsStream(asset)) {
      	return this.loadStreamBackground(renderer, callback, asset);
      	*/
    } else if (asset.file.indexOf('.mp4') !== -1 || asset.file.indexOf('.webm') !== -1) {
      return this.loadVideoBackground(environment.getPath(asset.folder), asset.file, renderer, callback);
    } else if (asset.file.indexOf('.m3u8') !== -1) {
      return this.loadHlslVideoBackground(asset.file, renderer, callback);
    } else if (asset.file.indexOf('.hdr') !== -1) {
      return this.loadRgbeBackground(environment.getPath(asset.folder), asset.file, renderer, callback);
    } else {
      return this.loadBackgroundImageService(environment.getPath(asset.folder), asset.file, renderer, callback);
    }
  }
  static loadBackgroundImageService(folder, file, renderer, callback) {
    const progressRef = LoaderService.getRef();
    const image = new Image();
    ImageService.events$(folder + file).pipe(operators.tap(event => {
      if (event.type === ImageServiceEvent.Progress) {
        LoaderService.setProgress(progressRef, event.data.loaded, event.data.total);
      }
    }), operators.filter(event => event.type === ImageServiceEvent.Complete), operators.switchMap(event => {
      const load = rxjs.fromEvent(image, 'load');
      image.crossOrigin = 'anonymous';
      image.src = event.data;
      return load;
    }), operators.takeWhile(event => event.type !== ImageServiceEvent.Complete, true)).subscribe(event => {
      const texture = new THREE.Texture(image);
      texture.minFilter = THREE.LinearFilter;
      texture.magFilter = THREE.LinearFilter;
      texture.mapping = THREE.UVMapping;
      // console.log('texture', texture, THREE.RGBAFormat, THREE.LinearEncoding);
      // texture.format = THREE.RGBAFormat;
      // texture.encoding = THREE.LinearEncoding;
      texture.toneMapped = false;
      texture.needsUpdate = true;
      if (typeof callback === 'function') {
        callback(texture);
        URL.revokeObjectURL(event.data);
      }
      LoaderService.setProgress(progressRef, 1);
    });
  }
  static loadBackground(folder, file, renderer, callback) {
    const progressRef = LoaderService.getRef();
    const loader = new THREE.TextureLoader();
    loader.setPath(folder).load(file, texture => {
      texture.minFilter = THREE.LinearFilter;
      texture.magFilter = THREE.LinearFilter;
      texture.mapping = THREE.UVMapping;
      // texture.format = THREE.RGBAFormat;
      // texture.encoding = THREE.LinearEncoding;
      texture.needsUpdate = true;
      if (typeof callback === 'function') {
        callback(texture);
      }
      LoaderService.setProgress(progressRef, 1);
    }, request => {
      LoaderService.setProgress(progressRef, request.loaded, request.total);
    });
    return loader;
  }
  static loadRgbeBackground(folder, file, renderer, callback) {
    const progressRef = LoaderService.getRef();
    const loader = new RGBELoader();
    loader.setDataType(THREE.UnsignedByteType).setPath(folder).load(file, texture => {
      if (typeof callback === 'function') {
        callback(texture, true);
      }
      LoaderService.setProgress(progressRef, 1);
    }, request => {
      LoaderService.setProgress(progressRef, request.loaded, request.total);
    });
    return loader;
  }
  static loadHlslVideoBackground(src, renderer, callback) {
    const progressRef = LoaderService.getRef();
    const video = document.createElement('video');
    const onPlaying = () => {
      video.oncanplay = null;
      const texture = new THREE.VideoTexture(video);
      texture.minFilter = THREE.LinearFilter;
      texture.magFilter = THREE.LinearFilter;
      texture.mapping = THREE.UVMapping;
      // texture.format = THREE.RGBAFormat;
      // texture.encoding = THREE.LinearEncoding;
      texture.needsUpdate = true;
      if (typeof callback === 'function') {
        callback(texture);
      }
      LoaderService.setProgress(progressRef, 1);
    };
    video.oncanplay = () => {
      // console.log('videoReady', videoReady);
      onPlaying();
    };
    if (Hls.isSupported()) {
      var hls = new Hls();
      hls.attachMedia(video);
      hls.on(Hls.Events.MEDIA_ATTACHED, () => {
        hls.loadSource(src);
        hls.on(Hls.Events.MANIFEST_PARSED, (event, data) => {
          video.play();
        });
      });
    }
  }

  // !!! implementing medialoader interface
  // static get progress
  // static set progress
  // static play
  // static pause

  static get progress() {
    const video = this.video;
    if (video) {
      return video.currentTime / video.duration;
    } else {
      return 0;
    }
  }
  static set progress(progress) {
    const video = this.video;
    if (video) {
      const currentTime = video.duration * progress;
      if (video.seekable.length > progress && video.currentTime !== currentTime) {
        // console.log('PanoramaLoader', 'progress', progress, 'currentTime', currentTime, 'duration', this.video.duration, 'seekable', this.video.seekable);
        video.currentTime = currentTime;
        MediaLoader.events$.next(new MediaLoaderTimeSetEvent(this));
      }
    }
  }
  static play(silent) {
    // console.log('PanoramaLoader.play');
    const video = this.video;
    if (video) {
      video.muted = this.muted_;
      video.play().then(() => {
        // console.log('PanoramaLoader.play.success', this.video.src);
        if (!silent) {
          MediaLoader.events$.next(new MediaLoaderPlayEvent(this));
        }
      }, error => {
        console.log('PanoramaLoader.play.error', video.src, error);
      });
    }
  }
  static pause(silent) {
    // console.log('PanoramaLoader.pause');
    const video = this.video;
    if (video) {
      video.muted = true;
      video.pause();
      if (!silent) {
        MediaLoader.events$.next(new MediaLoaderPauseEvent(this));
      }
    }
  }
  static loadVideoBackground(folder, file, renderer, callback) {
    const progressRef = LoaderService.getRef();
    this.video = true;
    const video = this.video;
    const onCanPlay = () => {
      // console.log('PanoramaLoader', 'onPlaying');
      video.oncanplay = null;
      const texture = new THREE.VideoTexture(video);
      texture.minFilter = THREE.LinearFilter;
      texture.magFilter = THREE.LinearFilter;
      texture.mapping = THREE.UVMapping;
      // texture.format = THREE.RGBAFormat;
      // texture.encoding = THREE.LinearEncoding;
      texture.needsUpdate = true;
      if (typeof callback === 'function') {
        callback(texture);
      }
      // console.log('loadVideoBackground.loaded');
      LoaderService.setProgress(progressRef, 1);
      {
        this.play();
      }
    };
    const onTimeUpdate = () => {
      MediaLoader.events$.next(new MediaLoaderTimeUpdateEvent(this));
    };
    const onEnded = () => {
    };
    video.oncanplay = onCanPlay;
    video.ontimeupdate = onTimeUpdate;
    video.onended = onEnded;
    video.crossOrigin = 'anonymous';
    video.src = folder + file;
    video.load();
  }
  static loadPublisherStreamBackground(renderer, callback) {
    const onPublisherStreamId = publisherStreamId => {
      const video = document.querySelector(`#stream-${publisherStreamId} video`);
      if (!video) {
        return;
      }
      const onPlaying = () => {
        const texture = this.texture = new THREE.VideoTexture(video);
        texture.minFilter = THREE.LinearFilter;
        texture.magFilter = THREE.LinearFilter;
        texture.mapping = THREE.UVMapping;
        // texture.format = THREE.RGBAFormat;
        // texture.encoding = THREE.LinearEncoding;
        texture.needsUpdate = true;
        if (typeof callback === 'function') {
          callback(texture);
        }
      };
      video.crossOrigin = 'anonymous';
      if (video.readyState >= video.HAVE_FUTURE_DATA) {
        onPlaying();
      } else {
        video.oncanplay = () => {
          onPlaying();
        };
      }
    };
    StreamService.getPublisherStreamId$().pipe(operators.first()).subscribe(publisherStreamId => onPublisherStreamId(publisherStreamId));
  }
  static loadAttendeeStreamBackground(renderer, callback) {
    const onAttendeeStreamId = attendeeStreamId => {
      const video = document.querySelector(`#stream-${attendeeStreamId} video`);
      if (!video) {
        return;
      }
      const onPlaying = () => {
        const texture = this.texture = new THREE.VideoTexture(video);
        texture.minFilter = THREE.LinearFilter;
        texture.magFilter = THREE.LinearFilter;
        texture.mapping = THREE.UVMapping;
        // texture.format = THREE.RGBAFormat;
        // texture.encoding = THREE.LinearEncoding;
        texture.needsUpdate = true;
        if (typeof callback === 'function') {
          callback(texture);
        }
      };
      video.crossOrigin = 'anonymous';
      if (video.readyState >= video.HAVE_FUTURE_DATA) {
        onPlaying();
      } else {
        video.oncanplay = () => {
          onPlaying();
        };
      }
    };
    StreamService.getAttendeeStreamId$().pipe(operators.first()).subscribe(attendeeStreamId => onAttendeeStreamId(attendeeStreamId));
  }
  static loadStreamBackground(renderer, callback, asset) {
    const onStreamId = streamId => {
      const video = document.querySelector(`#stream-${streamId} video`);
      if (!video) {
        return;
      }
      const onPlaying = () => {
        const texture = this.texture = new THREE.VideoTexture(video);
        texture.minFilter = THREE.LinearFilter;
        texture.magFilter = THREE.LinearFilter;
        texture.mapping = THREE.UVMapping;
        // texture.format = THREE.RGBAFormat;
        // texture.encoding = THREE.LinearEncoding;
        texture.needsUpdate = true;
        if (typeof callback === 'function') {
          callback(texture);
        }
      };
      video.crossOrigin = 'anonymous';
      if (video.readyState >= video.HAVE_FUTURE_DATA) {
        onPlaying();
      } else {
        video.oncanplay = () => {
          onPlaying();
        };
      }
    };
    PanoramaLoader.getStreamId$(asset).pipe(operators.takeUntil(MediaLoader.events$.pipe(operators.filter(event => event instanceof MediaLoaderDisposeEvent)))).subscribe(streamId => {
      onStreamId(streamId);
    });
  }
  static getStreamId$(asset) {
    const assetType = asset.type;
    return StreamService.streams$.pipe(operators.map(streams => {
      // console.log('streams', streams);
      let stream;
      let i = 0;
      const matchType = MediaMesh.getTypeMatcher(assetType);
      streams.forEach(x => {
        // console.log('streams', matchType(x), x, asset);
        if (matchType(x)) {
          if (i === asset.index) {
            stream = x;
          }
          i++;
        }
      });
      if (stream) {
        return stream.streamId;
      } else {
        return null;
      }
    }));
  }
}class Panorama {
  constructor(renderer) {
    this.muted_ = false;
    this.subscription = StateService.state$.subscribe(state => PanoramaLoader.muted = state.volumeMuted);
    this.tween = 0;
    this.create(renderer);
  }
  create(renderer) {
    this.renderer = renderer;
    this.onCubeMapDispose = this.onCubeMapDispose.bind(this);
    const geometry = new THREE.BoxGeometry(202, 202, 202);
    const material = this.getBlackMaterial();
    const mesh = new InteractiveMesh(geometry, material);
    mesh.userData = {
      render: (time, tick, renderer, scene, camera) => {
        mesh.matrixWorld.copyPosition(camera.matrixWorld);
        const cubeMap = this.cubeMap;
        const texture = this.texture;
        if (cubeMap && texture && texture.isVideoTexture) {
          this.updateCubeMapEquirectangularTexture(cubeMap, renderer, texture);
        }
      }
    };
    mesh.name = '[panorama]';
    this.mesh = mesh;
  }
  getBlackMaterial() {
    return new THREE.MeshBasicMaterial({
      name: 'PanoramaStandardMaterial',
      color: 0x000000,
      side: THREE.BackSide,
      depthTest: false,
      depthWrite: false,
      fog: false
    });
  }
  getShaderMaterial(texture) {
    const material = new THREE.ShaderMaterial({
      name: 'PanoramaCubeMaterial',
      uniforms: this.cloneUniforms(THREE.ShaderLib.cube.uniforms),
      vertexShader: THREE.ShaderLib.cube.vertexShader,
      fragmentShader: THREE.ShaderLib.cube.fragmentShader,
      side: THREE.BackSide,
      depthTest: false,
      depthWrite: false,
      fog: false,
      toneMapped: false
    });
    texture.mapping = THREE.EquirectangularReflectionMapping;
    const cubeMap = this.toCubeMap(texture, this.renderer);
    material.map = cubeMap;
    material.uniforms.envMap.value = cubeMap;
    material.uniforms.flipEnvMap.value = cubeMap.isCubeTexture && cubeMap._needsFlipEnvMap ? -1 : 1;
    material.needsUpdate = true;
    this.mesh.geometry.deleteAttribute('normal');
    this.mesh.geometry.deleteAttribute('uv');
    Object.defineProperty(material, 'envMap', {
      get: function () {
        return this.uniforms.envMap.value;
      },
      configurable: true
    });
    return material;
  }
  makeEnvMap(texture) {
    let material = this.mesh.material;
    if (!material.uniforms) {
      material.dispose();
      material = this.getShaderMaterial(texture);
      this.mesh.material = material;
    } else {
      texture.mapping = THREE.EquirectangularReflectionMapping;
      const cubeMap = this.toCubeMap(texture, this.renderer);
      material.map = cubeMap;
      material.uniforms.envMap.value = cubeMap;
      material.uniforms.flipEnvMap.value = cubeMap.isCubeTexture && cubeMap._needsFlipEnvMap ? -1 : 1;
      material.needsUpdate = true;
    }
    // console.log('Panorama.makeEnvMap', this.texture, this.cubeMap);
  }

  toCubeMap(texture, renderer) {
    if (this.cubeMap) {
      this.cubeMap.dispose();
    }
    const image = texture.image;
    const height = image.height || image.videoHeight;
    const cubeMap = new THREE.WebGLCubeRenderTarget(height / 2, {
      generateMipmaps: true,
      type: THREE.HalfFloatType,
      encoding: THREE.LinearEncoding,
      // minFilter: THREE.LinearMipmapLinearFilter,
      minFilter: THREE.LinearFilter,
      magFilter: THREE.LinearFilter,
      // mapping: THREE.CubeReflectionMapping,
      // mapping: THREE.EquirectangularReflectionMapping,
      mapping: THREE.CubeUVReflectionMapping,
      // mapping: THREE.UVMapping,
      format: THREE.RGBAFormat
    });
    cubeMap.addEventListener('dispose', this.onCubeMapDispose);
    this.setCubeMapEquirectangularTexture(cubeMap, texture);
    this.updateCubeMapEquirectangularTexture(cubeMap, renderer, texture);
    this.cubeMap = cubeMap;
    this.texture = texture;
    return this.mapTextureMapping(cubeMap.texture, texture.mapping);
  }
  setCubeMapEquirectangularTexture(cubeMap, texture) {
    cubeMap.texture.type = texture.type;
    cubeMap.texture.format = THREE.RGBAFormat;
    cubeMap.texture.encoding = THREE.sRGBEncoding;
    cubeMap.texture.generateMipmaps = texture.generateMipmaps;
    cubeMap.texture.minFilter = texture.minFilter;
    cubeMap.texture.magFilter = texture.magFilter;
    cubeMap.texture.needsUpdate = true;
    const shader = {
      uniforms: {
        tEquirect: {
          value: null
        }
      },
      vertexShader: /* glsl */`
					varying vec3 vWorldDirection;
					vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
						return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
					}
					void main() {
						vWorldDirection = transformDirection( position, modelMatrix );
						#include <begin_vertex>
						#include <project_vertex>
					}
				`,
      fragmentShader: /* glsl */`
					uniform sampler2D tEquirect;
					varying vec3 vWorldDirection;
					#include <common>
					void main() {
						vec3 direction = normalize( vWorldDirection );
						vec2 sampleUV = equirectUv( direction );
						gl_FragColor = texture2D( tEquirect, sampleUV );
					}
				`
    };
    const geometry = new THREE.BoxGeometry(5, 5, 5);
    const material = new THREE.ShaderMaterial({
      name: 'CubemapFromEquirect',
      uniforms: this.cloneUniforms(shader.uniforms),
      vertexShader: shader.vertexShader,
      fragmentShader: shader.fragmentShader,
      side: THREE.BackSide,
      blending: THREE.NoBlending
    });
    material.uniforms.tEquirect.value = texture;
    const mesh = new THREE.Mesh(geometry, material);
    const camera = new THREE.CubeCamera(1, 10, cubeMap);
    cubeMap.camera = camera;
    cubeMap.mesh = mesh;
    return cubeMap;
  }
  updateCubeMapEquirectangularTexture(cubeMap, renderer, texture) {
    const previousMinFilter = texture.minFilter;
    // Avoid blurred poles
    if (texture.minFilter === THREE.LinearMipmapLinearFilter) {
      texture.minFilter = THREE.LinearFilter;
    }
    /*
    const outputEncoding = renderer.outputEncoding;
    const toneMapping = renderer.toneMapping;
    const toneMappingExposure = renderer.toneMappingExposure;
    renderer.toneMapping = THREE.NoToneMapping;
    renderer.outputEncoding = THREE.LinearEncoding;
    renderer.toneMappingExposure = 2;
    */
    cubeMap.camera.update(renderer, cubeMap.mesh);
    /*
    renderer.toneMapping = toneMapping;
    renderer.outputEncoding = outputEncoding;
    renderer.toneMappingExposure = toneMappingExposure;
    */
    texture.minFilter = previousMinFilter;
    // console.log('updateCubeMapEquirectangularTexture');
  }

  cloneUniforms(src) {
    const dst = {};
    for (const u in src) {
      dst[u] = {};
      for (const p in src[u]) {
        const property = src[u][p];
        if (property && (property.isColor || property.isMatrix3 || property.isMatrix4 || property.isVector2 || property.isVector3 || property.isVector4 || property.isTexture || property.isQuaternion)) {
          dst[u][p] = property.clone();
        } else if (Array.isArray(property)) {
          dst[u][p] = property.slice();
        } else {
          dst[u][p] = property;
        }
      }
    }
    return dst;
  }
  mapTextureMapping(texture, mapping) {
    if (mapping === THREE.EquirectangularReflectionMapping) {
      texture.mapping = THREE.CubeReflectionMapping;
    } else if (mapping === THREE.EquirectangularRefractionMapping) {
      texture.mapping = THREE.CubeRefractionMapping;
    }
    return texture;
  }
  onCubeMapDispose() {
    const cubeMap = this.cubeMap;
    if (cubeMap) {
      // console.log('Panorama.onCubeMapDispose', cubeMap);
      cubeMap.removeEventListener('dispose', this.onCubeMapDispose);
      cubeMap.texture.dispose();
      cubeMap.mesh.geometry.dispose();
      cubeMap.mesh.material.dispose();
      if (cubeMap !== undefined) {
        this.cubeMap = null;
      }
    }
  }
  change(view, renderer, callback, onexit) {
    const item = view instanceof PanoramaGridView ? view.tiles[view.index_] : view;
    const material = this.mesh.material;
    this.load(item, renderer, envMap => {
      if (typeof onexit === 'function') {
        onexit(view);
      }
      if (material.uniforms && material.uniforms.uTween) {
        material.uniforms.uTween.value = 1;
        material.needsUpdate = true;
      }
      if (typeof callback === 'function') {
        callback(envMap);
      }
    });
  }
  crossfade(item, renderer, callback) {
    const material = this.mesh.material;
    this.load(item, renderer, envMap => {
      if (material.uniforms && material.uniforms.uTween) {
        material.uniforms.uTween.value = 1;
        material.needsUpdate = true;
      }
      if (typeof callback === 'function') {
        callback(envMap);
      }
    });
  }
  getLocalizedAsset(asset) {
    if (asset && asset.locale) {
      const localizedAsset = asset.locale[LanguageService.lang];
      if (localizedAsset) {
        asset = localizedAsset;
      }
    }
    return asset;
  }
  load(item, renderer, callback) {
    const asset = item.type.name === ViewType.Media.name ? Asset.defaultMediaAsset : item.asset;
    if (!asset) {
      return;
    }
    if (asset.type.name === AssetType.Model.name) {
      if (typeof callback === 'function') {
        callback(null);
      }
      return;
    }
    const localizedAsset = this.getLocalizedAsset(asset);
    // console.log('Panorama.load.localizedAsset', localizedAsset, 'asset', asset);
    this.currentAsset = localizedAsset.folder + localizedAsset.file;
    PanoramaLoader.load(localizedAsset, renderer, (texture, rgbe) => {
      if (localizedAsset.folder + localizedAsset.file !== this.currentAsset) {
        texture.dispose();
        return;
      }
      const envMap = this.makeEnvMap(texture);
      if (typeof callback === 'function') {
        callback(envMap);
      }
    });
  }
  dispose() {
    this.subscription.unsubscribe();
    if (this.cubeMap) {
      this.cubeMap.dispose();
    }
  }
}const W = 12;
const H = 27;
const D = 0.5;
const R = 4 / 3;
const COLORS = [0xffffff, 0xffcc00, 0x00ffcc, 0x00ccff, 0xccff00, 0xcc00ff];
class PhoneStreamElement {
  static get geometry() {
    const geometry = new THREE.PlaneBufferGeometry(0.01 * W, 0.01 * W / R, 2, 2);
    return geometry;
  }
  setRemote(remote, i, total) {
    this.remote = remote;
    let s,
      c,
      r,
      w,
      h,
      sx,
      sy,
      sz = 0.01 * D; // !!! double distance
    if (total < 4) {
      s = 1;
      c = 0;
      r = i;
      w = 0.01 * W * s;
      h = w / R;
      sx = 0;
      sy = h / 2 - total * h / 2;
      this.plane.position.set(sx, sy + h * i, sz);
    } else {
      s = 0.5;
      c = i % 2;
      r = Math.floor(i / 2);
      w = 0.01 * W * s;
      h = w / R;
      sx = -w / 2;
      sy = h / 2 - Math.ceil(total / 2) * h / 2;
      this.plane.position.set(sx + c * w, sy + r * h, sz);
    }
    this.plane.scale.set(s, s, s);
    // console.log(this.plane.position);
    if (typeof remote === 'number') {
      this.plane.material.color.set(COLORS[i % COLORS.length]);
    } else {
      if (remote.texture) {
        this.plane.material.map = remote.texture;
        this.plane.material.needsUpdate = true;
      } else {
        this.addStreamTexture(remote.streamId, texture => {
          remote.texture = texture;
          this.plane.material.map = texture;
          this.plane.material.needsUpdate = true;
        });
      }
    }
  }
  addStreamTexture(streamId, callback) {
    const target = `#stream-${streamId}`; // `#stream-remote-${streamId}`;
    const video = document.querySelector(`${target} video`);
    if (!video) {
      return;
    }
    const onPlaying = () => {
      const texture = new THREE.VideoTexture(video);
      texture.minFilter = THREE.LinearFilter;
      texture.magFilter = THREE.LinearFilter;
      texture.mapping = THREE.UVMapping;
      // texture.format = THREE.RGBAFormat;
      // texture.encoding = THREE.sRGBEncoding;
      texture.needsUpdate = true;
      if (typeof callback === 'function') {
        callback(texture);
      }
    };
    video.crossOrigin = 'anonymous';
    if (video.readyState >= video.HAVE_FUTURE_DATA) {
      onPlaying();
    } else {
      video.oncanplay = () => {
        onPlaying();
      };
    }
  }
  constructor() {
    const geometry = PhoneStreamElement.geometry;
    const material = new THREE.MeshBasicMaterial({
      // depthTest: false,
      color: 0xffffff
      // side: THREE.DoubleSide,
    });

    this.plane = new THREE.Mesh(geometry, material);
  }
}
class PhoneElement {
  set remotes(remotes) {
    // console.log('PhoneElement', remotes);
    remotes.forEach((remote, i) => {
      let stream = this.streams[i];
      if (!stream) {
        stream = new PhoneStreamElement();
      }
      stream.setRemote(remote, i, remotes.length);
      this.phone.add(stream.plane);
      this.streams[i] = stream;
    });
    for (let i = remotes.length; i < this.streams.length; i++) {
      this.phone.remove(this.streams[i].plane);
    }
    this.streams.length = remotes.length;
  }
  constructor() {
    const mesh = this.mesh = new THREE.Group();
    const phone = this.phone = this.create();
    mesh.add(phone);
    this.streams = [];
    StreamService.remotes$.subscribe(remotes => {
      this.remotes = remotes;
    });
  }
  create() {
    const geometry = new THREE.BoxBufferGeometry(0.01 * W, 0.01 * H, 0.01 * D, 2, 2, 1);
    const material = new THREE.MeshStandardMaterial({
      // depthTest: false,
      color: 0x000000,
      transparent: true,
      opacity: 0.6
    });
    const phone = new THREE.Mesh(geometry, material);
    phone.rotation.set(-Math.PI / 4, 0, 0);
    return phone;
  }
}class PointerElement {
  constructor(color) {
    if (color === void 0) {
      color = '#ffffff';
    }
    this.position = new THREE.Vector3();
    // const targetPosition = this.targetPosition = new THREE.Vector3();
    const geometry = Geometry.planeGeometry; // new THREE.PlaneBufferGeometry(1.2, 1.2, 2, 2);
    const loader = new THREE.TextureLoader();
    const texture = loader.load(environment.getPath('textures/ui/nav-point.png'));
    const material = new THREE.MeshBasicMaterial({
      color: new THREE.Color(color),
      depthTest: false,
      depthWrite: false,
      map: texture,
      transparent: true,
      opacity: 0.9
    });
    const mesh = this.mesh = new THREE.Mesh(geometry, material);
    mesh.renderOrder = environment.renderOrder.pointer;
    mesh.position.set(-100000, -100000, -100000);
  }
  update(camera) {
    if (Interactive.lastIntersectedObject) {
      const position = this.position;
      position.copy(Interactive.lastIntersectedObject.intersection.point);
      position.multiplyScalar(0.99);
      const mesh = this.mesh;
      mesh.position.set(position.x, position.y, position.z);
      position.sub(camera.position);
      const s = position.length() / 80;
      mesh.scale.set(s, s, s);
      /*
      const targetPosition = this.targetPosition;
      targetPosition.set(0, 0, 0);
      camera.localToWorld(targetPosition);
      */
      mesh.lookAt(Host.origin);
    }
  }
  setPosition(x, y, z, camera) {
    const position = this.position;
    position.set(x, y, z).multiplyScalar(80);
    const mesh = this.mesh;
    mesh.position.copy(position);
    position.sub(camera.position);
    const s = position.length() / 80;
    mesh.scale.set(s, s, s);
    /*
    const targetPosition = this.targetPosition;
    targetPosition.set(0, 0, 0);
    camera.localToWorld(targetPosition);
    */
    mesh.lookAt(Host.origin);
  }
}const LINE_SEGMENTS = 10;
class TeleportElement {
  constructor() {
    this.gravity = new THREE.Vector3(0, -9.8, 0);
    this.controllerPosition = new THREE.Vector3();
    this.controllerDirection = new THREE.Vector3();
    this.currentPosition = new THREE.Vector3();
    this.targetPosition = new THREE.Vector3();
    const geometry = new THREE.BufferGeometry();
    const vertices = this.vertices = new Float32Array((LINE_SEGMENTS + 1) * 3);
    vertices.fill(0);
    const colors = new Float32Array((LINE_SEGMENTS + 1) * 3);
    colors.fill(0.5);
    geometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
    const lineMaterial = new THREE.LineBasicMaterial({
      vertexColors: true,
      blending: THREE.AdditiveBlending
    });
    this.line = new THREE.Line(geometry, lineMaterial);
    // const light = this.light = new THREE.PointLight(0xffeeaa, 0, 2);
    const loader = new THREE.TextureLoader();
    const texture = loader.load(environment.getPath('textures/ui/nav-point.png'));
    const target = this.target = new THREE.Mesh(new THREE.PlaneBufferGeometry(0.3, 0.3, 1, 1), new THREE.MeshBasicMaterial({
      map: texture,
      blending: THREE.AdditiveBlending,
      color: 0x555555,
      transparent: true
    }));
    target.rotation.x = -Math.PI / 2;
  }
  addToController(controller, scene) {
    this.currentController = controller;
    // this.light.intensity = 1;
    controller.add(this.line);
    scene.add(this.target);
  }
  removeFromController(controller, scene, renderer, camera, cameraGroup) {
    const currentController = this.currentController;
    if (currentController === controller) {
      const gravity = this.gravity;
      const currentPosition = this.currentPosition;
      const controllerPosition = this.controllerPosition;
      const controllerDirection = this.controllerDirection;
      renderer.xr.getCamera(camera).getWorldPosition(currentPosition);
      currentPosition.y = 0;
      currentController.getWorldPosition(controllerPosition);
      currentController.getWorldDirection(controllerDirection);
      controllerDirection.multiplyScalar(6);
      const T = (-controllerDirection.y + Math.sqrt(controllerDirection.y ** 2 - 2 * controllerPosition.y * gravity.y)) / gravity.y;
      const targetPosition = this.getPositionT(this.targetPosition, T, controllerPosition, controllerDirection, gravity);
      targetPosition.addScaledVector(currentPosition, -1);
      cameraGroup.position.add(targetPosition);
      // this.teleport(targetPosition, cameraGroup);
      this.currentController = null;
      // this.light.intensity = 0;
      currentController.remove(this.line);
      scene.remove(this.target);
    }
  }
  update() {
    const currentController = this.currentController;
    if (currentController) {
      const gravity = this.gravity;
      const controllerPosition = this.controllerPosition;
      const controllerDirection = this.controllerDirection;
      const targetPosition = this.targetPosition;
      // Controller start position
      currentController.getWorldPosition(controllerPosition);
      // Set Vector V to the direction of the controller, at 1m/s
      currentController.getWorldDirection(controllerDirection);
      // Scale the initial velocity to 6m/s
      controllerDirection.multiplyScalar(6);
      // Time for tele ball to hit ground
      const T = (-controllerDirection.y + Math.sqrt(controllerDirection.y ** 2 - 2 * controllerPosition.y * gravity.y)) / gravity.y;
      const vertex = targetPosition.set(0, 0, 0);
      for (let i = 1; i <= LINE_SEGMENTS; i++) {
        // set vertex to current position of the virtual ball at time t
        this.getPositionT(vertex, i * T / LINE_SEGMENTS, controllerPosition, controllerDirection, gravity);
        currentController.worldToLocal(vertex);
        vertex.toArray(this.vertices, i * 3);
      }
      this.line.geometry.attributes.position.needsUpdate = true;
      // Place the light and sprite near the end of the poing
      // this.getPositionT(this.light.position, T * 0.98, controllerPosition, controllerDirection, gravity);
      this.getPositionT(this.target.position, T * 0.98, controllerPosition, controllerDirection, gravity);
    }
  }
  getPositionT(position, T, controllerPosition, controllerDirection, gravity) {
    position.copy(controllerPosition);
    position.addScaledVector(controllerDirection, T);
    position.addScaledVector(gravity, 0.5 * T ** 2);
    return position;
  }

  /*
  teleport(offsetPosition, cameraGroup) {
  	const position = new THREE.Vector3();
  	position.copy(cameraGroup.position);
  	position.add(offsetPosition);
  	// const distance = offsetPosition.length();
  	cameraGroup.position.copy(position);
  }
  */
}const XRStatus = {
  Waiting: 'waiting',
  Enabled: 'enabled',
  Ended: 'ended',
  Started: 'started',
  Disabled: 'disabled',
  NeedsHttps: 'needs-https',
  Unavailable: 'unavailable'
};
class VRService {
  static getService() {
    if (!this.service_) {
      this.service_ = new VRService();
    }
    return this.service_;
  }
  get status() {
    return this.status$.getValue();
  }
  get state() {
    return this.state$.getValue();
  }
  constructor() {
    if (VRService.service_) {
      throw 'VRService is a singleton class!';
    }
    const state = this.state_ = {
      camera: {
        position: new THREE.Vector3(),
        quaternion: new THREE.Quaternion(),
        scale: new THREE.Vector3(),
        array: new Array(3 + 4 + 3).fill(0)
      }
    };
    this.onSessionStarted = this.onSessionStarted.bind(this);
    this.onSessionEnded = this.onSessionEnded.bind(this);
    this.status$ = new rxjs.BehaviorSubject(XRStatus.Waiting);
    this.session$ = new rxjs.Subject();
    this.state$ = new rxjs.BehaviorSubject(state);
    this.currentSession = null;
    if ('xr' in navigator) {
      navigator.xr.isSessionSupported('immersive-vr').then(supported => {
        if (supported) {
          this.status$.next(XRStatus.Enabled);
        } else {
          this.status$.next(XRStatus.Disabled);
        }
      });
    } else {
      if (window.isSecureContext === false) {
        this.status$.next(XRStatus.NeedsHttps);
      } else {
        this.status$.next(XRStatus.Unavailable);
        // 'https://immersiveweb.dev/';
      }
    }
  }

  onSessionStarted(session) {
    session.addEventListener('end', this.onSessionEnded);
    this.currentSession = session;
    this.session$.next(session);
    this.status$.next(XRStatus.Started);
  }
  onSessionEnded( /*event*/
  ) {
    this.currentSession.removeEventListener('end', this.onSessionEnded);
    this.currentSession = null;
    this.session$.next(null);
    this.status$.next(XRStatus.Ended);
  }
  toggleVR(event) {
    if (this.currentSession === null) {
      // WebXR's requestReferenceSpace only works if the corresponding feature
      // was requested at session creation time. For simplicity, just ask for
      // the interesting ones as optional features, but be aware that the
      // requestReferenceSpace call will fail if it turns out to be unavailable.
      // ('local' is always available for immersive sessions and doesn't need to
      // be requested separately.)
      const sessionInit = {
        optionalFeatures: ['local-floor', 'bounded-floor']
      };
      navigator.xr.requestSession('immersive-vr', sessionInit).then(this.onSessionStarted);
    } else {
      this.currentSession.end();
    }
  }
  isDisabled() {
    const status = this.status$.getValue();
    switch (status) {
      case XRStatus.Waiting:
      case XRStatus.Disabled:
      case XRStatus.NeedsHttps:
      case XRStatus.Unavailable:
        return true;
      default:
        return false;
    }
  }
  getLabel() {
    let label;
    const status = this.status$.getValue();
    switch (status) {
      case XRStatus.Waiting:
        label = 'Waiting VR';
        break;
      case XRStatus.Enabled:
      case XRStatus.Ended:
        label = 'Enter VR';
        break;
      case XRStatus.Started:
        label = 'Exit VR';
        break;
      case XRStatus.Disabled:
        label = 'VR Disabled';
        break;
      case XRStatus.NeedsHttps:
        label = 'VR Needs Https';
        break;
      case XRStatus.Unavailable:
        label = 'VR Unavailable';
        break;
    }
    return label;
  }
  updateState(world) {
    if (this.status === XRStatus.Started) {
      world.renderer;
        world.scene;
        const camera = world.camera,
        state = this.state_;
      camera.matrixWorld.decompose(state.camera.position, state.camera.quaternion, state.camera.scale);
      state.camera.array[0] = state.camera.position.x;
      state.camera.array[1] = state.camera.position.y;
      state.camera.array[2] = state.camera.position.z;
      state.camera.array[3] = state.camera.quaternion.x;
      state.camera.array[4] = state.camera.quaternion.y;
      state.camera.array[5] = state.camera.quaternion.z;
      state.camera.array[6] = state.camera.quaternion.w;
      state.camera.array[7] = state.camera.scale.x;
      state.camera.array[8] = state.camera.scale.y;
      state.camera.array[9] = state.camera.scale.z;
      this.state$.next(state);
    }
  }
}class Emittable {
  constructor() {
    this.events = {};
  }
  on(type, callback) {
    const event = this.events[type] = this.events[type] || [];
    event.push(callback);
    return () => {
      this.events[type] = event.filter(x => x !== callback);
    };
  }
  off(type, callback) {
    const event = this.events[type];
    if (event) {
      this.events[type] = event.filter(x => x !== callback);
    }
  }
  emit(type, data) {
    const event = this.events[type];
    if (event) {
      event.forEach(callback => {
        // callback.call(this, data);
        callback(data);
      });
    }
    const broadcast = this.events.broadcast;
    if (broadcast) {
      broadcast.forEach(callback => {
        callback(type, data);
      });
    }
  }
}class Gamepad extends Emittable {
  constructor(gamepad) {
    super();
    this.gamepad = gamepad;
    this.buttons = {};
    this.axes = {};
  }
  update() {
    this.updateButtons();
    this.updateAxes();
  }
  updateButtons() {
    this.gamepad.buttons.forEach((x, i) => {
      const pressed = x.pressed;
      const button = this.buttons[i] || (this.buttons[i] = new GamepadButton(i, this));
      if (button.pressed !== pressed) {
        button.pressed = pressed;
        if (pressed) {
          this.emit('press', button);
        } else if (status !== undefined) {
          this.emit('release', button);
        }
      }
    });
  }
  updateAxes() {
    const axes = this.gamepad.axes;
    for (let i = 0; i < axes.length; i += 2) {
      const index = Math.floor(i / 2);
      const axis = this.axes[index] || (this.axes[index] = new GamepadAxis(index, this));
      const x = axes[i];
      const y = axes[i + 1];
      if (axis.x !== x || axis.y !== y) {
        axis.x = x;
        axis.y = y;
        if (Math.abs(x) > Math.abs(y)) {
          const left = x < -0.85;
          const right = x > 0.85;
          if (axis.left !== left) {
            axis.left = left;
            this.emit(left ? 'left' : 'none', axis);
            // console.log(`${axis.gamepad.hand} ${axis.gamepad.index} left ${left}`);
          }

          if (axis.right !== right) {
            axis.right = right;
            this.emit(right ? 'right' : 'none', axis);
            // console.log(`${axis.gamepad.hand} ${axis.gamepad.index} right ${right}`);
          }
        } else {
          const up = y < -0.85;
          const down = y > 0.85;
          if (axis.up !== up) {
            axis.up = up;
            this.emit(up ? 'up' : 'none', axis);
            // console.log(`${axis.gamepad.hand} ${axis.gamepad.index} up ${up}`);
          }

          if (axis.down !== down) {
            axis.down = down;
            this.emit(down ? 'down' : 'none', axis);
            // console.log(`${axis.gamepad.hand} ${axis.gamepad.index} down ${down}`);
          }
        }

        this.emit('axis', axis);
      }
    }
  }
  feedback(strength, duration) {
    if (strength === void 0) {
      strength = 0.1;
    }
    if (duration === void 0) {
      duration = 50;
    }
    // !!! care for battery
    const actuators = this.gamepad.hapticActuators;
    if (actuators && actuators.length) {
      return actuators[0].pulse(strength, duration);
    } else {
      return Promise.reject();
    }
  }
}
class GamepadButton {
  constructor(index, gamepad) {
    this.index = index;
    this.gamepad = gamepad;
    this.pressed = false;
  }
}
class GamepadAxis extends THREE.Vector2 {
  constructor(index, gamepad) {
    super();
    this.index = index;
    this.gamepad = gamepad;
    this.left = this.right = this.up = this.down = false;
  }
}class GLTFLoader extends three.Loader {

	constructor( manager ) {

		super( manager );

		this.dracoLoader = null;
		this.ktx2Loader = null;
		this.meshoptDecoder = null;

		this.pluginCallbacks = [];

		this.register( function ( parser ) {

			return new GLTFMaterialsClearcoatExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFTextureBasisUExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFTextureWebPExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFMaterialsSheenExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFMaterialsTransmissionExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFMaterialsVolumeExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFMaterialsIorExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFMaterialsSpecularExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFLightsExtension( parser );

		} );

		this.register( function ( parser ) {

			return new GLTFMeshoptCompression( parser );

		} );

	}

	load( url, onLoad, onProgress, onError ) {

		const scope = this;

		let resourcePath;

		if ( this.resourcePath !== '' ) {

			resourcePath = this.resourcePath;

		} else if ( this.path !== '' ) {

			resourcePath = this.path;

		} else {

			resourcePath = three.LoaderUtils.extractUrlBase( url );

		}

		// Tells the LoadingManager to track an extra item, which resolves after
		// the model is fully loaded. This means the count of items loaded will
		// be incorrect, but ensures manager.onLoad() does not fire early.
		this.manager.itemStart( url );

		const _onError = function ( e ) {

			if ( onError ) {

				onError( e );

			} else {

				console.error( e );

			}

			scope.manager.itemError( url );
			scope.manager.itemEnd( url );

		};

		const loader = new three.FileLoader( this.manager );

		loader.setPath( this.path );
		loader.setResponseType( 'arraybuffer' );
		loader.setRequestHeader( this.requestHeader );
		loader.setWithCredentials( this.withCredentials );

		loader.load( url, function ( data ) {

			try {

				scope.parse( data, resourcePath, function ( gltf ) {

					onLoad( gltf );

					scope.manager.itemEnd( url );

				}, _onError );

			} catch ( e ) {

				_onError( e );

			}

		}, onProgress, _onError );

	}

	setDRACOLoader( dracoLoader ) {

		this.dracoLoader = dracoLoader;
		return this;

	}

	setDDSLoader() {

		throw new Error(

			'THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".'

		);

	}

	setKTX2Loader( ktx2Loader ) {

		this.ktx2Loader = ktx2Loader;
		return this;

	}

	setMeshoptDecoder( meshoptDecoder ) {

		this.meshoptDecoder = meshoptDecoder;
		return this;

	}

	register( callback ) {

		if ( this.pluginCallbacks.indexOf( callback ) === - 1 ) {

			this.pluginCallbacks.push( callback );

		}

		return this;

	}

	unregister( callback ) {

		if ( this.pluginCallbacks.indexOf( callback ) !== - 1 ) {

			this.pluginCallbacks.splice( this.pluginCallbacks.indexOf( callback ), 1 );

		}

		return this;

	}

	parse( data, path, onLoad, onError ) {

		let content;
		const extensions = {};
		const plugins = {};

		if ( typeof data === 'string' ) {

			content = data;

		} else {

			const magic = three.LoaderUtils.decodeText( new Uint8Array( data, 0, 4 ) );

			if ( magic === BINARY_EXTENSION_HEADER_MAGIC ) {

				try {

					extensions[ EXTENSIONS.KHR_BINARY_GLTF ] = new GLTFBinaryExtension( data );

				} catch ( error ) {

					if ( onError ) onError( error );
					return;

				}

				content = extensions[ EXTENSIONS.KHR_BINARY_GLTF ].content;

			} else {

				content = three.LoaderUtils.decodeText( new Uint8Array( data ) );

			}

		}

		const json = JSON.parse( content );

		if ( json.asset === undefined || json.asset.version[ 0 ] < 2 ) {

			if ( onError ) onError( new Error( 'THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.' ) );
			return;

		}

		const parser = new GLTFParser( json, {

			path: path || this.resourcePath || '',
			crossOrigin: this.crossOrigin,
			requestHeader: this.requestHeader,
			manager: this.manager,
			ktx2Loader: this.ktx2Loader,
			meshoptDecoder: this.meshoptDecoder

		} );

		parser.fileLoader.setRequestHeader( this.requestHeader );

		for ( let i = 0; i < this.pluginCallbacks.length; i ++ ) {

			const plugin = this.pluginCallbacks[ i ]( parser );
			plugins[ plugin.name ] = plugin;

			// Workaround to avoid determining as unknown extension
			// in addUnknownExtensionsToUserData().
			// Remove this workaround if we move all the existing
			// extension handlers to plugin system
			extensions[ plugin.name ] = true;

		}

		if ( json.extensionsUsed ) {

			for ( let i = 0; i < json.extensionsUsed.length; ++ i ) {

				const extensionName = json.extensionsUsed[ i ];
				const extensionsRequired = json.extensionsRequired || [];

				switch ( extensionName ) {

					case EXTENSIONS.KHR_MATERIALS_UNLIT:
						extensions[ extensionName ] = new GLTFMaterialsUnlitExtension();
						break;

					case EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
						extensions[ extensionName ] = new GLTFMaterialsPbrSpecularGlossinessExtension();
						break;

					case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:
						extensions[ extensionName ] = new GLTFDracoMeshCompressionExtension( json, this.dracoLoader );
						break;

					case EXTENSIONS.KHR_TEXTURE_TRANSFORM:
						extensions[ extensionName ] = new GLTFTextureTransformExtension();
						break;

					case EXTENSIONS.KHR_MESH_QUANTIZATION:
						extensions[ extensionName ] = new GLTFMeshQuantizationExtension();
						break;

					default:

						if ( extensionsRequired.indexOf( extensionName ) >= 0 && plugins[ extensionName ] === undefined ) {

							console.warn( 'THREE.GLTFLoader: Unknown extension "' + extensionName + '".' );

						}

				}

			}

		}

		parser.setExtensions( extensions );
		parser.setPlugins( plugins );
		parser.parse( onLoad, onError );

	}

	parseAsync( data, path ) {

		const scope = this;

		return new Promise( function ( resolve, reject ) {

			scope.parse( data, path, resolve, reject );

		} );

	}

}

/* GLTFREGISTRY */

function GLTFRegistry() {

	let objects = {};

	return	{

		get: function ( key ) {

			return objects[ key ];

		},

		add: function ( key, object ) {

			objects[ key ] = object;

		},

		remove: function ( key ) {

			delete objects[ key ];

		},

		removeAll: function () {

			objects = {};

		}

	};

}

/*********************************/
/********** EXTENSIONS ***********/
/*********************************/

const EXTENSIONS = {
	KHR_BINARY_GLTF: 'KHR_binary_glTF',
	KHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',
	KHR_LIGHTS_PUNCTUAL: 'KHR_lights_punctual',
	KHR_MATERIALS_CLEARCOAT: 'KHR_materials_clearcoat',
	KHR_MATERIALS_IOR: 'KHR_materials_ior',
	KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: 'KHR_materials_pbrSpecularGlossiness',
	KHR_MATERIALS_SHEEN: 'KHR_materials_sheen',
	KHR_MATERIALS_SPECULAR: 'KHR_materials_specular',
	KHR_MATERIALS_TRANSMISSION: 'KHR_materials_transmission',
	KHR_MATERIALS_UNLIT: 'KHR_materials_unlit',
	KHR_MATERIALS_VOLUME: 'KHR_materials_volume',
	KHR_TEXTURE_BASISU: 'KHR_texture_basisu',
	KHR_TEXTURE_TRANSFORM: 'KHR_texture_transform',
	KHR_MESH_QUANTIZATION: 'KHR_mesh_quantization',
	EXT_TEXTURE_WEBP: 'EXT_texture_webp',
	EXT_MESHOPT_COMPRESSION: 'EXT_meshopt_compression'
};

/**
 * Punctual Lights Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual
 */
class GLTFLightsExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;

		// Object3D instance caches
		this.cache = { refs: {}, uses: {} };

	}

	_markDefs() {

		const parser = this.parser;
		const nodeDefs = this.parser.json.nodes || [];

		for ( let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex ++ ) {

			const nodeDef = nodeDefs[ nodeIndex ];

			if ( nodeDef.extensions
					&& nodeDef.extensions[ this.name ]
					&& nodeDef.extensions[ this.name ].light !== undefined ) {

				parser._addNodeRef( this.cache, nodeDef.extensions[ this.name ].light );

			}

		}

	}

	_loadLight( lightIndex ) {

		const parser = this.parser;
		const cacheKey = 'light:' + lightIndex;
		let dependency = parser.cache.get( cacheKey );

		if ( dependency ) return dependency;

		const json = parser.json;
		const extensions = ( json.extensions && json.extensions[ this.name ] ) || {};
		const lightDefs = extensions.lights || [];
		const lightDef = lightDefs[ lightIndex ];
		let lightNode;

		const color = new three.Color( 0xffffff );

		if ( lightDef.color !== undefined ) color.fromArray( lightDef.color );

		const range = lightDef.range !== undefined ? lightDef.range : 0;

		switch ( lightDef.type ) {

			case 'directional':
				lightNode = new three.DirectionalLight( color );
				lightNode.target.position.set( 0, 0, - 1 );
				lightNode.add( lightNode.target );
				break;

			case 'point':
				lightNode = new three.PointLight( color );
				lightNode.distance = range;
				break;

			case 'spot':
				lightNode = new three.SpotLight( color );
				lightNode.distance = range;
				// Handle spotlight properties.
				lightDef.spot = lightDef.spot || {};
				lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== undefined ? lightDef.spot.innerConeAngle : 0;
				lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== undefined ? lightDef.spot.outerConeAngle : Math.PI / 4.0;
				lightNode.angle = lightDef.spot.outerConeAngle;
				lightNode.penumbra = 1.0 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;
				lightNode.target.position.set( 0, 0, - 1 );
				lightNode.add( lightNode.target );
				break;

			default:
				throw new Error( 'THREE.GLTFLoader: Unexpected light type: ' + lightDef.type );

		}

		// Some lights (e.g. spot) default to a position other than the origin. Reset the position
		// here, because node-level parsing will only override position if explicitly specified.
		lightNode.position.set( 0, 0, 0 );

		lightNode.decay = 2;

		if ( lightDef.intensity !== undefined ) lightNode.intensity = lightDef.intensity;

		lightNode.name = parser.createUniqueName( lightDef.name || ( 'light_' + lightIndex ) );

		dependency = Promise.resolve( lightNode );

		parser.cache.add( cacheKey, dependency );

		return dependency;

	}

	createNodeAttachment( nodeIndex ) {

		const self = this;
		const parser = this.parser;
		const json = parser.json;
		const nodeDef = json.nodes[ nodeIndex ];
		const lightDef = ( nodeDef.extensions && nodeDef.extensions[ this.name ] ) || {};
		const lightIndex = lightDef.light;

		if ( lightIndex === undefined ) return null;

		return this._loadLight( lightIndex ).then( function ( light ) {

			return parser._getNodeRef( self.cache, lightIndex, light );

		} );

	}

}

/**
 * Unlit Materials Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit
 */
class GLTFMaterialsUnlitExtension {

	constructor() {

		this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;

	}

	getMaterialType() {

		return three.MeshBasicMaterial;

	}

	extendParams( materialParams, materialDef, parser ) {

		const pending = [];

		materialParams.color = new three.Color( 1.0, 1.0, 1.0 );
		materialParams.opacity = 1.0;

		const metallicRoughness = materialDef.pbrMetallicRoughness;

		if ( metallicRoughness ) {

			if ( Array.isArray( metallicRoughness.baseColorFactor ) ) {

				const array = metallicRoughness.baseColorFactor;

				materialParams.color.fromArray( array );
				materialParams.opacity = array[ 3 ];

			}

			if ( metallicRoughness.baseColorTexture !== undefined ) {

				pending.push( parser.assignTexture( materialParams, 'map', metallicRoughness.baseColorTexture ) );

			}

		}

		return Promise.all( pending );

	}

}

/**
 * Clearcoat Materials Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat
 */
class GLTFMaterialsClearcoatExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;

	}

	getMaterialType( materialIndex ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

		return three.MeshPhysicalMaterial;

	}

	extendMaterialParams( materialIndex, materialParams ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

			return Promise.resolve();

		}

		const pending = [];

		const extension = materialDef.extensions[ this.name ];

		if ( extension.clearcoatFactor !== undefined ) {

			materialParams.clearcoat = extension.clearcoatFactor;

		}

		if ( extension.clearcoatTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'clearcoatMap', extension.clearcoatTexture ) );

		}

		if ( extension.clearcoatRoughnessFactor !== undefined ) {

			materialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;

		}

		if ( extension.clearcoatRoughnessTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'clearcoatRoughnessMap', extension.clearcoatRoughnessTexture ) );

		}

		if ( extension.clearcoatNormalTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'clearcoatNormalMap', extension.clearcoatNormalTexture ) );

			if ( extension.clearcoatNormalTexture.scale !== undefined ) {

				const scale = extension.clearcoatNormalTexture.scale;

				materialParams.clearcoatNormalScale = new three.Vector2( scale, scale );

			}

		}

		return Promise.all( pending );

	}

}

/**
 * Sheen Materials Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_sheen
 */
class GLTFMaterialsSheenExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_MATERIALS_SHEEN;

	}

	getMaterialType( materialIndex ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

		return three.MeshPhysicalMaterial;

	}

	extendMaterialParams( materialIndex, materialParams ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

			return Promise.resolve();

		}

		const pending = [];

		materialParams.sheenColor = new three.Color( 0, 0, 0 );
		materialParams.sheenRoughness = 0;
		materialParams.sheen = 1;

		const extension = materialDef.extensions[ this.name ];

		if ( extension.sheenColorFactor !== undefined ) {

			materialParams.sheenColor.fromArray( extension.sheenColorFactor );

		}

		if ( extension.sheenRoughnessFactor !== undefined ) {

			materialParams.sheenRoughness = extension.sheenRoughnessFactor;

		}

		if ( extension.sheenColorTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'sheenColorMap', extension.sheenColorTexture ) );

		}

		if ( extension.sheenRoughnessTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'sheenRoughnessMap', extension.sheenRoughnessTexture ) );

		}

		return Promise.all( pending );

	}

}

/**
 * Transmission Materials Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission
 * Draft: https://github.com/KhronosGroup/glTF/pull/1698
 */
class GLTFMaterialsTransmissionExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION;

	}

	getMaterialType( materialIndex ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

		return three.MeshPhysicalMaterial;

	}

	extendMaterialParams( materialIndex, materialParams ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

			return Promise.resolve();

		}

		const pending = [];

		const extension = materialDef.extensions[ this.name ];

		if ( extension.transmissionFactor !== undefined ) {

			materialParams.transmission = extension.transmissionFactor;

		}

		if ( extension.transmissionTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'transmissionMap', extension.transmissionTexture ) );

		}

		return Promise.all( pending );

	}

}

/**
 * Materials Volume Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_volume
 */
class GLTFMaterialsVolumeExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_MATERIALS_VOLUME;

	}

	getMaterialType( materialIndex ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

		return three.MeshPhysicalMaterial;

	}

	extendMaterialParams( materialIndex, materialParams ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

			return Promise.resolve();

		}

		const pending = [];

		const extension = materialDef.extensions[ this.name ];

		materialParams.thickness = extension.thicknessFactor !== undefined ? extension.thicknessFactor : 0;

		if ( extension.thicknessTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'thicknessMap', extension.thicknessTexture ) );

		}

		materialParams.attenuationDistance = extension.attenuationDistance || 0;

		const colorArray = extension.attenuationColor || [ 1, 1, 1 ];
		materialParams.attenuationColor = new three.Color( colorArray[ 0 ], colorArray[ 1 ], colorArray[ 2 ] );

		return Promise.all( pending );

	}

}

/**
 * Materials ior Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_ior
 */
class GLTFMaterialsIorExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_MATERIALS_IOR;

	}

	getMaterialType( materialIndex ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

		return three.MeshPhysicalMaterial;

	}

	extendMaterialParams( materialIndex, materialParams ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

			return Promise.resolve();

		}

		const extension = materialDef.extensions[ this.name ];

		materialParams.ior = extension.ior !== undefined ? extension.ior : 1.5;

		return Promise.resolve();

	}

}

/**
 * Materials specular Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_specular
 */
class GLTFMaterialsSpecularExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_MATERIALS_SPECULAR;

	}

	getMaterialType( materialIndex ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) return null;

		return three.MeshPhysicalMaterial;

	}

	extendMaterialParams( materialIndex, materialParams ) {

		const parser = this.parser;
		const materialDef = parser.json.materials[ materialIndex ];

		if ( ! materialDef.extensions || ! materialDef.extensions[ this.name ] ) {

			return Promise.resolve();

		}

		const pending = [];

		const extension = materialDef.extensions[ this.name ];

		materialParams.specularIntensity = extension.specularFactor !== undefined ? extension.specularFactor : 1.0;

		if ( extension.specularTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'specularIntensityMap', extension.specularTexture ) );

		}

		const colorArray = extension.specularColorFactor || [ 1, 1, 1 ];
		materialParams.specularColor = new three.Color( colorArray[ 0 ], colorArray[ 1 ], colorArray[ 2 ] );

		if ( extension.specularColorTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'specularColorMap', extension.specularColorTexture ).then( function ( texture ) {

				texture.encoding = three.sRGBEncoding;

			} ) );

		}

		return Promise.all( pending );

	}

}

/**
 * BasisU Texture Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_basisu
 */
class GLTFTextureBasisUExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.KHR_TEXTURE_BASISU;

	}

	loadTexture( textureIndex ) {

		const parser = this.parser;
		const json = parser.json;

		const textureDef = json.textures[ textureIndex ];

		if ( ! textureDef.extensions || ! textureDef.extensions[ this.name ] ) {

			return null;

		}

		const extension = textureDef.extensions[ this.name ];
		const loader = parser.options.ktx2Loader;

		if ( ! loader ) {

			if ( json.extensionsRequired && json.extensionsRequired.indexOf( this.name ) >= 0 ) {

				throw new Error( 'THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures' );

			} else {

				// Assumes that the extension is optional and that a fallback texture is present
				return null;

			}

		}

		return parser.loadTextureImage( textureIndex, extension.source, loader );

	}

}

/**
 * WebP Texture Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_texture_webp
 */
class GLTFTextureWebPExtension {

	constructor( parser ) {

		this.parser = parser;
		this.name = EXTENSIONS.EXT_TEXTURE_WEBP;
		this.isSupported = null;

	}

	loadTexture( textureIndex ) {

		const name = this.name;
		const parser = this.parser;
		const json = parser.json;

		const textureDef = json.textures[ textureIndex ];

		if ( ! textureDef.extensions || ! textureDef.extensions[ name ] ) {

			return null;

		}

		const extension = textureDef.extensions[ name ];
		const source = json.images[ extension.source ];

		let loader = parser.textureLoader;
		if ( source.uri ) {

			const handler = parser.options.manager.getHandler( source.uri );
			if ( handler !== null ) loader = handler;

		}

		return this.detectSupport().then( function ( isSupported ) {

			if ( isSupported ) return parser.loadTextureImage( textureIndex, source, loader );

			if ( json.extensionsRequired && json.extensionsRequired.indexOf( name ) >= 0 ) {

				throw new Error( 'THREE.GLTFLoader: WebP required by asset but unsupported.' );

			}

			// Fall back to PNG or JPEG.
			return parser.loadTexture( textureIndex );

		} );

	}

	detectSupport() {

		if ( ! this.isSupported ) {

			this.isSupported = new Promise( function ( resolve ) {

				const image = new Image();

				// Lossy test image. Support for lossy images doesn't guarantee support for all
				// WebP images, unfortunately.
				image.src = 'data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA';

				image.onload = image.onerror = function () {

					resolve( image.height === 1 );

				};

			} );

		}

		return this.isSupported;

	}

}

/**
 * meshopt BufferView Compression Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_meshopt_compression
 */
class GLTFMeshoptCompression {

	constructor( parser ) {

		this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION;
		this.parser = parser;

	}

	loadBufferView( index ) {

		const json = this.parser.json;
		const bufferView = json.bufferViews[ index ];

		if ( bufferView.extensions && bufferView.extensions[ this.name ] ) {

			const extensionDef = bufferView.extensions[ this.name ];

			const buffer = this.parser.getDependency( 'buffer', extensionDef.buffer );
			const decoder = this.parser.options.meshoptDecoder;

			if ( ! decoder || ! decoder.supported ) {

				if ( json.extensionsRequired && json.extensionsRequired.indexOf( this.name ) >= 0 ) {

					throw new Error( 'THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files' );

				} else {

					// Assumes that the extension is optional and that fallback buffer data is present
					return null;

				}

			}

			return Promise.all( [ buffer, decoder.ready ] ).then( function ( res ) {

				const byteOffset = extensionDef.byteOffset || 0;
				const byteLength = extensionDef.byteLength || 0;

				const count = extensionDef.count;
				const stride = extensionDef.byteStride;

				const result = new ArrayBuffer( count * stride );
				const source = new Uint8Array( res[ 0 ], byteOffset, byteLength );

				decoder.decodeGltfBuffer( new Uint8Array( result ), count, stride, source, extensionDef.mode, extensionDef.filter );
				return result;

			} );

		} else {

			return null;

		}

	}

}

/* BINARY EXTENSION */
const BINARY_EXTENSION_HEADER_MAGIC = 'glTF';
const BINARY_EXTENSION_HEADER_LENGTH = 12;
const BINARY_EXTENSION_CHUNK_TYPES = { JSON: 0x4E4F534A, BIN: 0x004E4942 };

class GLTFBinaryExtension {

	constructor( data ) {

		this.name = EXTENSIONS.KHR_BINARY_GLTF;
		this.content = null;
		this.body = null;

		const headerView = new DataView( data, 0, BINARY_EXTENSION_HEADER_LENGTH );

		this.header = {
			magic: three.LoaderUtils.decodeText( new Uint8Array( data.slice( 0, 4 ) ) ),
			version: headerView.getUint32( 4, true ),
			length: headerView.getUint32( 8, true )
		};

		if ( this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC ) {

			throw new Error( 'THREE.GLTFLoader: Unsupported glTF-Binary header.' );

		} else if ( this.header.version < 2.0 ) {

			throw new Error( 'THREE.GLTFLoader: Legacy binary file detected.' );

		}

		const chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH;
		const chunkView = new DataView( data, BINARY_EXTENSION_HEADER_LENGTH );
		let chunkIndex = 0;

		while ( chunkIndex < chunkContentsLength ) {

			const chunkLength = chunkView.getUint32( chunkIndex, true );
			chunkIndex += 4;

			const chunkType = chunkView.getUint32( chunkIndex, true );
			chunkIndex += 4;

			if ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON ) {

				const contentArray = new Uint8Array( data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength );
				this.content = three.LoaderUtils.decodeText( contentArray );

			} else if ( chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN ) {

				const byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;
				this.body = data.slice( byteOffset, byteOffset + chunkLength );

			}

			// Clients must ignore chunks with unknown types.

			chunkIndex += chunkLength;

		}

		if ( this.content === null ) {

			throw new Error( 'THREE.GLTFLoader: JSON content not found.' );

		}

	}

}

/**
 * DRACO Mesh Compression Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression
 */
class GLTFDracoMeshCompressionExtension {

	constructor( json, dracoLoader ) {

		if ( ! dracoLoader ) {

			throw new Error( 'THREE.GLTFLoader: No DRACOLoader instance provided.' );

		}

		this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;
		this.json = json;
		this.dracoLoader = dracoLoader;
		this.dracoLoader.preload();

	}

	decodePrimitive( primitive, parser ) {

		const json = this.json;
		const dracoLoader = this.dracoLoader;
		const bufferViewIndex = primitive.extensions[ this.name ].bufferView;
		const gltfAttributeMap = primitive.extensions[ this.name ].attributes;
		const threeAttributeMap = {};
		const attributeNormalizedMap = {};
		const attributeTypeMap = {};

		for ( const attributeName in gltfAttributeMap ) {

			const threeAttributeName = ATTRIBUTES[ attributeName ] || attributeName.toLowerCase();

			threeAttributeMap[ threeAttributeName ] = gltfAttributeMap[ attributeName ];

		}

		for ( const attributeName in primitive.attributes ) {

			const threeAttributeName = ATTRIBUTES[ attributeName ] || attributeName.toLowerCase();

			if ( gltfAttributeMap[ attributeName ] !== undefined ) {

				const accessorDef = json.accessors[ primitive.attributes[ attributeName ] ];
				const componentType = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];

				attributeTypeMap[ threeAttributeName ] = componentType;
				attributeNormalizedMap[ threeAttributeName ] = accessorDef.normalized === true;

			}

		}

		return parser.getDependency( 'bufferView', bufferViewIndex ).then( function ( bufferView ) {

			return new Promise( function ( resolve ) {

				dracoLoader.decodeDracoFile( bufferView, function ( geometry ) {

					for ( const attributeName in geometry.attributes ) {

						const attribute = geometry.attributes[ attributeName ];
						const normalized = attributeNormalizedMap[ attributeName ];

						if ( normalized !== undefined ) attribute.normalized = normalized;

					}

					resolve( geometry );

				}, threeAttributeMap, attributeTypeMap );

			} );

		} );

	}

}

/**
 * Texture Transform Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_transform
 */
class GLTFTextureTransformExtension {

	constructor() {

		this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;

	}

	extendTexture( texture, transform ) {

		if ( transform.texCoord !== undefined ) {

			console.warn( 'THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.' );

		}

		if ( transform.offset === undefined && transform.rotation === undefined && transform.scale === undefined ) {

			// See https://github.com/mrdoob/three.js/issues/21819.
			return texture;

		}

		texture = texture.clone();

		if ( transform.offset !== undefined ) {

			texture.offset.fromArray( transform.offset );

		}

		if ( transform.rotation !== undefined ) {

			texture.rotation = transform.rotation;

		}

		if ( transform.scale !== undefined ) {

			texture.repeat.fromArray( transform.scale );

		}

		texture.needsUpdate = true;

		return texture;

	}

}

/**
 * Specular-Glossiness Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Archived/KHR_materials_pbrSpecularGlossiness
 */

/**
 * A sub class of StandardMaterial with some of the functionality
 * changed via the `onBeforeCompile` callback
 * @pailhead
 */
class GLTFMeshStandardSGMaterial extends three.MeshStandardMaterial {

	constructor( params ) {

		super();

		this.isGLTFSpecularGlossinessMaterial = true;

		//various chunks that need replacing
		const specularMapParsFragmentChunk = [
			'#ifdef USE_SPECULARMAP',
			'	uniform sampler2D specularMap;',
			'#endif'
		].join( '\n' );

		const glossinessMapParsFragmentChunk = [
			'#ifdef USE_GLOSSINESSMAP',
			'	uniform sampler2D glossinessMap;',
			'#endif'
		].join( '\n' );

		const specularMapFragmentChunk = [
			'vec3 specularFactor = specular;',
			'#ifdef USE_SPECULARMAP',
			'	vec4 texelSpecular = texture2D( specularMap, vUv );',
			'	// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture',
			'	specularFactor *= texelSpecular.rgb;',
			'#endif'
		].join( '\n' );

		const glossinessMapFragmentChunk = [
			'float glossinessFactor = glossiness;',
			'#ifdef USE_GLOSSINESSMAP',
			'	vec4 texelGlossiness = texture2D( glossinessMap, vUv );',
			'	// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture',
			'	glossinessFactor *= texelGlossiness.a;',
			'#endif'
		].join( '\n' );

		const lightPhysicalFragmentChunk = [
			'PhysicalMaterial material;',
			'material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );',
			'vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );',
			'float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );',
			'material.roughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.',
			'material.roughness += geometryRoughness;',
			'material.roughness = min( material.roughness, 1.0 );',
			'material.specularColor = specularFactor;',
		].join( '\n' );

		const uniforms = {
			specular: { value: new three.Color().setHex( 0xffffff ) },
			glossiness: { value: 1 },
			specularMap: { value: null },
			glossinessMap: { value: null }
		};

		this._extraUniforms = uniforms;

		this.onBeforeCompile = function ( shader ) {

			for ( const uniformName in uniforms ) {

				shader.uniforms[ uniformName ] = uniforms[ uniformName ];

			}

			shader.fragmentShader = shader.fragmentShader
				.replace( 'uniform float roughness;', 'uniform vec3 specular;' )
				.replace( 'uniform float metalness;', 'uniform float glossiness;' )
				.replace( '#include <roughnessmap_pars_fragment>', specularMapParsFragmentChunk )
				.replace( '#include <metalnessmap_pars_fragment>', glossinessMapParsFragmentChunk )
				.replace( '#include <roughnessmap_fragment>', specularMapFragmentChunk )
				.replace( '#include <metalnessmap_fragment>', glossinessMapFragmentChunk )
				.replace( '#include <lights_physical_fragment>', lightPhysicalFragmentChunk );

		};

		Object.defineProperties( this, {

			specular: {
				get: function () {

					return uniforms.specular.value;

				},
				set: function ( v ) {

					uniforms.specular.value = v;

				}
			},

			specularMap: {
				get: function () {

					return uniforms.specularMap.value;

				},
				set: function ( v ) {

					uniforms.specularMap.value = v;

					if ( v ) {

						this.defines.USE_SPECULARMAP = ''; // USE_UV is set by the renderer for specular maps

					} else {

						delete this.defines.USE_SPECULARMAP;

					}

				}
			},

			glossiness: {
				get: function () {

					return uniforms.glossiness.value;

				},
				set: function ( v ) {

					uniforms.glossiness.value = v;

				}
			},

			glossinessMap: {
				get: function () {

					return uniforms.glossinessMap.value;

				},
				set: function ( v ) {

					uniforms.glossinessMap.value = v;

					if ( v ) {

						this.defines.USE_GLOSSINESSMAP = '';
						this.defines.USE_UV = '';

					} else {

						delete this.defines.USE_GLOSSINESSMAP;
						delete this.defines.USE_UV;

					}

				}
			}

		} );

		delete this.metalness;
		delete this.roughness;
		delete this.metalnessMap;
		delete this.roughnessMap;

		this.setValues( params );

	}

	copy( source ) {

		super.copy( source );

		this.specularMap = source.specularMap;
		this.specular.copy( source.specular );
		this.glossinessMap = source.glossinessMap;
		this.glossiness = source.glossiness;
		delete this.metalness;
		delete this.roughness;
		delete this.metalnessMap;
		delete this.roughnessMap;
		return this;

	}

}


class GLTFMaterialsPbrSpecularGlossinessExtension {

	constructor() {

		this.name = EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS;

		this.specularGlossinessParams = [
			'color',
			'map',
			'lightMap',
			'lightMapIntensity',
			'aoMap',
			'aoMapIntensity',
			'emissive',
			'emissiveIntensity',
			'emissiveMap',
			'bumpMap',
			'bumpScale',
			'normalMap',
			'normalMapType',
			'displacementMap',
			'displacementScale',
			'displacementBias',
			'specularMap',
			'specular',
			'glossinessMap',
			'glossiness',
			'alphaMap',
			'envMap',
			'envMapIntensity',
			'refractionRatio',
		];

	}

	getMaterialType() {

		return GLTFMeshStandardSGMaterial;

	}

	extendParams( materialParams, materialDef, parser ) {

		const pbrSpecularGlossiness = materialDef.extensions[ this.name ];

		materialParams.color = new three.Color( 1.0, 1.0, 1.0 );
		materialParams.opacity = 1.0;

		const pending = [];

		if ( Array.isArray( pbrSpecularGlossiness.diffuseFactor ) ) {

			const array = pbrSpecularGlossiness.diffuseFactor;

			materialParams.color.fromArray( array );
			materialParams.opacity = array[ 3 ];

		}

		if ( pbrSpecularGlossiness.diffuseTexture !== undefined ) {

			pending.push( parser.assignTexture( materialParams, 'map', pbrSpecularGlossiness.diffuseTexture ) );

		}

		materialParams.emissive = new three.Color( 0.0, 0.0, 0.0 );
		materialParams.glossiness = pbrSpecularGlossiness.glossinessFactor !== undefined ? pbrSpecularGlossiness.glossinessFactor : 1.0;
		materialParams.specular = new three.Color( 1.0, 1.0, 1.0 );

		if ( Array.isArray( pbrSpecularGlossiness.specularFactor ) ) {

			materialParams.specular.fromArray( pbrSpecularGlossiness.specularFactor );

		}

		if ( pbrSpecularGlossiness.specularGlossinessTexture !== undefined ) {

			const specGlossMapDef = pbrSpecularGlossiness.specularGlossinessTexture;
			pending.push( parser.assignTexture( materialParams, 'glossinessMap', specGlossMapDef ) );
			pending.push( parser.assignTexture( materialParams, 'specularMap', specGlossMapDef ) );

		}

		return Promise.all( pending );

	}

	createMaterial( materialParams ) {

		const material = new GLTFMeshStandardSGMaterial( materialParams );
		material.fog = true;

		material.color = materialParams.color;

		material.map = materialParams.map === undefined ? null : materialParams.map;

		material.lightMap = null;
		material.lightMapIntensity = 1.0;

		material.aoMap = materialParams.aoMap === undefined ? null : materialParams.aoMap;
		material.aoMapIntensity = 1.0;

		material.emissive = materialParams.emissive;
		material.emissiveIntensity = 1.0;
		material.emissiveMap = materialParams.emissiveMap === undefined ? null : materialParams.emissiveMap;

		material.bumpMap = materialParams.bumpMap === undefined ? null : materialParams.bumpMap;
		material.bumpScale = 1;

		material.normalMap = materialParams.normalMap === undefined ? null : materialParams.normalMap;
		material.normalMapType = three.TangentSpaceNormalMap;

		if ( materialParams.normalScale ) material.normalScale = materialParams.normalScale;

		material.displacementMap = null;
		material.displacementScale = 1;
		material.displacementBias = 0;

		material.specularMap = materialParams.specularMap === undefined ? null : materialParams.specularMap;
		material.specular = materialParams.specular;

		material.glossinessMap = materialParams.glossinessMap === undefined ? null : materialParams.glossinessMap;
		material.glossiness = materialParams.glossiness;

		material.alphaMap = null;

		material.envMap = materialParams.envMap === undefined ? null : materialParams.envMap;
		material.envMapIntensity = 1.0;

		material.refractionRatio = 0.98;

		return material;

	}

}

/**
 * Mesh Quantization Extension
 *
 * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization
 */
class GLTFMeshQuantizationExtension {

	constructor() {

		this.name = EXTENSIONS.KHR_MESH_QUANTIZATION;

	}

}

/*********************************/
/********** INTERPOLATION ********/
/*********************************/

// Spline Interpolation
// Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#appendix-c-spline-interpolation
class GLTFCubicSplineInterpolant extends three.Interpolant {

	constructor( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

		super( parameterPositions, sampleValues, sampleSize, resultBuffer );

	}

	copySampleValue_( index ) {

		// Copies a sample value to the result buffer. See description of glTF
		// CUBICSPLINE values layout in interpolate_() function below.

		const result = this.resultBuffer,
			values = this.sampleValues,
			valueSize = this.valueSize,
			offset = index * valueSize * 3 + valueSize;

		for ( let i = 0; i !== valueSize; i ++ ) {

			result[ i ] = values[ offset + i ];

		}

		return result;

	}

}

GLTFCubicSplineInterpolant.prototype.beforeStart_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;

GLTFCubicSplineInterpolant.prototype.afterEnd_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;

GLTFCubicSplineInterpolant.prototype.interpolate_ = function ( i1, t0, t, t1 ) {

	const result = this.resultBuffer;
	const values = this.sampleValues;
	const stride = this.valueSize;

	const stride2 = stride * 2;
	const stride3 = stride * 3;

	const td = t1 - t0;

	const p = ( t - t0 ) / td;
	const pp = p * p;
	const ppp = pp * p;

	const offset1 = i1 * stride3;
	const offset0 = offset1 - stride3;

	const s2 = - 2 * ppp + 3 * pp;
	const s3 = ppp - pp;
	const s0 = 1 - s2;
	const s1 = s3 - pp + p;

	// Layout of keyframe output values for CUBICSPLINE animations:
	//   [ inTangent_1, splineVertex_1, outTangent_1, inTangent_2, splineVertex_2, ... ]
	for ( let i = 0; i !== stride; i ++ ) {

		const p0 = values[ offset0 + i + stride ]; // splineVertex_k
		const m0 = values[ offset0 + i + stride2 ] * td; // outTangent_k * (t_k+1 - t_k)
		const p1 = values[ offset1 + i + stride ]; // splineVertex_k+1
		const m1 = values[ offset1 + i ] * td; // inTangent_k+1 * (t_k+1 - t_k)

		result[ i ] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;

	}

	return result;

};

const _q = new three.Quaternion();

class GLTFCubicSplineQuaternionInterpolant extends GLTFCubicSplineInterpolant {

	interpolate_( i1, t0, t, t1 ) {

		const result = super.interpolate_( i1, t0, t, t1 );

		_q.fromArray( result ).normalize().toArray( result );

		return result;

	}

}


/*********************************/
/********** INTERNALS ************/
/*********************************/

/* CONSTANTS */

const WEBGL_CONSTANTS = {
	FLOAT: 5126,
	//FLOAT_MAT2: 35674,
	FLOAT_MAT3: 35675,
	FLOAT_MAT4: 35676,
	FLOAT_VEC2: 35664,
	FLOAT_VEC3: 35665,
	FLOAT_VEC4: 35666,
	LINEAR: 9729,
	REPEAT: 10497,
	SAMPLER_2D: 35678,
	POINTS: 0,
	LINES: 1,
	LINE_LOOP: 2,
	LINE_STRIP: 3,
	TRIANGLES: 4,
	TRIANGLE_STRIP: 5,
	TRIANGLE_FAN: 6,
	UNSIGNED_BYTE: 5121,
	UNSIGNED_SHORT: 5123
};

const WEBGL_COMPONENT_TYPES = {
	5120: Int8Array,
	5121: Uint8Array,
	5122: Int16Array,
	5123: Uint16Array,
	5125: Uint32Array,
	5126: Float32Array
};

const WEBGL_FILTERS = {
	9728: three.NearestFilter,
	9729: three.LinearFilter,
	9984: three.NearestMipmapNearestFilter,
	9985: three.LinearMipmapNearestFilter,
	9986: three.NearestMipmapLinearFilter,
	9987: three.LinearMipmapLinearFilter
};

const WEBGL_WRAPPINGS = {
	33071: three.ClampToEdgeWrapping,
	33648: three.MirroredRepeatWrapping,
	10497: three.RepeatWrapping
};

const WEBGL_TYPE_SIZES = {
	'SCALAR': 1,
	'VEC2': 2,
	'VEC3': 3,
	'VEC4': 4,
	'MAT2': 4,
	'MAT3': 9,
	'MAT4': 16
};

const ATTRIBUTES = {
	POSITION: 'position',
	NORMAL: 'normal',
	TANGENT: 'tangent',
	TEXCOORD_0: 'uv',
	TEXCOORD_1: 'uv2',
	COLOR_0: 'color',
	WEIGHTS_0: 'skinWeight',
	JOINTS_0: 'skinIndex',
};

const PATH_PROPERTIES = {
	scale: 'scale',
	translation: 'position',
	rotation: 'quaternion',
	weights: 'morphTargetInfluences'
};

const INTERPOLATION = {
	CUBICSPLINE: undefined, // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each
		                        // keyframe track will be initialized with a default interpolation type, then modified.
	LINEAR: three.InterpolateLinear,
	STEP: three.InterpolateDiscrete
};

const ALPHA_MODES = {
	OPAQUE: 'OPAQUE',
	MASK: 'MASK',
	BLEND: 'BLEND'
};

/**
 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#default-material
 */
function createDefaultMaterial( cache ) {

	if ( cache[ 'DefaultMaterial' ] === undefined ) {

		cache[ 'DefaultMaterial' ] = new three.MeshStandardMaterial( {
			color: 0xFFFFFF,
			emissive: 0x000000,
			metalness: 1,
			roughness: 1,
			transparent: false,
			depthTest: true,
			side: three.FrontSide
		} );

	}

	return cache[ 'DefaultMaterial' ];

}

function addUnknownExtensionsToUserData( knownExtensions, object, objectDef ) {

	// Add unknown glTF extensions to an object's userData.

	for ( const name in objectDef.extensions ) {

		if ( knownExtensions[ name ] === undefined ) {

			object.userData.gltfExtensions = object.userData.gltfExtensions || {};
			object.userData.gltfExtensions[ name ] = objectDef.extensions[ name ];

		}

	}

}

/**
 * @param {Object3D|Material|BufferGeometry} object
 * @param {GLTF.definition} gltfDef
 */
function assignExtrasToUserData( object, gltfDef ) {

	if ( gltfDef.extras !== undefined ) {

		if ( typeof gltfDef.extras === 'object' ) {

			Object.assign( object.userData, gltfDef.extras );

		} else {

			console.warn( 'THREE.GLTFLoader: Ignoring primitive type .extras, ' + gltfDef.extras );

		}

	}

}

/**
 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#morph-targets
 *
 * @param {BufferGeometry} geometry
 * @param {Array<GLTF.Target>} targets
 * @param {GLTFParser} parser
 * @return {Promise<BufferGeometry>}
 */
function addMorphTargets( geometry, targets, parser ) {

	let hasMorphPosition = false;
	let hasMorphNormal = false;
	let hasMorphColor = false;

	for ( let i = 0, il = targets.length; i < il; i ++ ) {

		const target = targets[ i ];

		if ( target.POSITION !== undefined ) hasMorphPosition = true;
		if ( target.NORMAL !== undefined ) hasMorphNormal = true;
		if ( target.COLOR_0 !== undefined ) hasMorphColor = true;

		if ( hasMorphPosition && hasMorphNormal && hasMorphColor ) break;

	}

	if ( ! hasMorphPosition && ! hasMorphNormal && ! hasMorphColor ) return Promise.resolve( geometry );

	const pendingPositionAccessors = [];
	const pendingNormalAccessors = [];
	const pendingColorAccessors = [];

	for ( let i = 0, il = targets.length; i < il; i ++ ) {

		const target = targets[ i ];

		if ( hasMorphPosition ) {

			const pendingAccessor = target.POSITION !== undefined
				? parser.getDependency( 'accessor', target.POSITION )
				: geometry.attributes.position;

			pendingPositionAccessors.push( pendingAccessor );

		}

		if ( hasMorphNormal ) {

			const pendingAccessor = target.NORMAL !== undefined
				? parser.getDependency( 'accessor', target.NORMAL )
				: geometry.attributes.normal;

			pendingNormalAccessors.push( pendingAccessor );

		}

		if ( hasMorphColor ) {

			const pendingAccessor = target.COLOR_0 !== undefined
				? parser.getDependency( 'accessor', target.COLOR_0 )
				: geometry.attributes.color;

			pendingColorAccessors.push( pendingAccessor );

		}

	}

	return Promise.all( [
		Promise.all( pendingPositionAccessors ),
		Promise.all( pendingNormalAccessors ),
		Promise.all( pendingColorAccessors )
	] ).then( function ( accessors ) {

		const morphPositions = accessors[ 0 ];
		const morphNormals = accessors[ 1 ];
		const morphColors = accessors[ 2 ];

		if ( hasMorphPosition ) geometry.morphAttributes.position = morphPositions;
		if ( hasMorphNormal ) geometry.morphAttributes.normal = morphNormals;
		if ( hasMorphColor ) geometry.morphAttributes.color = morphColors;
		geometry.morphTargetsRelative = true;

		return geometry;

	} );

}

/**
 * @param {Mesh} mesh
 * @param {GLTF.Mesh} meshDef
 */
function updateMorphTargets( mesh, meshDef ) {

	mesh.updateMorphTargets();

	if ( meshDef.weights !== undefined ) {

		for ( let i = 0, il = meshDef.weights.length; i < il; i ++ ) {

			mesh.morphTargetInfluences[ i ] = meshDef.weights[ i ];

		}

	}

	// .extras has user-defined data, so check that .extras.targetNames is an array.
	if ( meshDef.extras && Array.isArray( meshDef.extras.targetNames ) ) {

		const targetNames = meshDef.extras.targetNames;

		if ( mesh.morphTargetInfluences.length === targetNames.length ) {

			mesh.morphTargetDictionary = {};

			for ( let i = 0, il = targetNames.length; i < il; i ++ ) {

				mesh.morphTargetDictionary[ targetNames[ i ] ] = i;

			}

		} else {

			console.warn( 'THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.' );

		}

	}

}

function createPrimitiveKey( primitiveDef ) {

	const dracoExtension = primitiveDef.extensions && primitiveDef.extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ];
	let geometryKey;

	if ( dracoExtension ) {

		geometryKey = 'draco:' + dracoExtension.bufferView
				+ ':' + dracoExtension.indices
				+ ':' + createAttributesKey( dracoExtension.attributes );

	} else {

		geometryKey = primitiveDef.indices + ':' + createAttributesKey( primitiveDef.attributes ) + ':' + primitiveDef.mode;

	}

	return geometryKey;

}

function createAttributesKey( attributes ) {

	let attributesKey = '';

	const keys = Object.keys( attributes ).sort();

	for ( let i = 0, il = keys.length; i < il; i ++ ) {

		attributesKey += keys[ i ] + ':' + attributes[ keys[ i ] ] + ';';

	}

	return attributesKey;

}

function getNormalizedComponentScale( constructor ) {

	// Reference:
	// https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization#encoding-quantized-data

	switch ( constructor ) {

		case Int8Array:
			return 1 / 127;

		case Uint8Array:
			return 1 / 255;

		case Int16Array:
			return 1 / 32767;

		case Uint16Array:
			return 1 / 65535;

		default:
			throw new Error( 'THREE.GLTFLoader: Unsupported normalized accessor component type.' );

	}

}

function getImageURIMimeType( uri ) {

	if ( uri.search( /\.jpe?g($|\?)/i ) > 0 || uri.search( /^data\:image\/jpeg/ ) === 0 ) return 'image/jpeg';
	if ( uri.search( /\.webp($|\?)/i ) > 0 || uri.search( /^data\:image\/webp/ ) === 0 ) return 'image/webp';

	return 'image/png';

}

/* GLTF PARSER */

class GLTFParser {

	constructor( json = {}, options = {} ) {

		this.json = json;
		this.extensions = {};
		this.plugins = {};
		this.options = options;

		// loader object cache
		this.cache = new GLTFRegistry();

		// associations between Three.js objects and glTF elements
		this.associations = new Map();

		// BufferGeometry caching
		this.primitiveCache = {};

		// Object3D instance caches
		this.meshCache = { refs: {}, uses: {} };
		this.cameraCache = { refs: {}, uses: {} };
		this.lightCache = { refs: {}, uses: {} };

		this.sourceCache = {};
		this.textureCache = {};

		// Track node names, to ensure no duplicates
		this.nodeNamesUsed = {};

		// Use an ImageBitmapLoader if imageBitmaps are supported. Moves much of the
		// expensive work of uploading a texture to the GPU off the main thread.
		if ( typeof createImageBitmap !== 'undefined' && /Firefox|^((?!chrome|android).)*safari/i.test( navigator.userAgent ) === false ) {

			this.textureLoader = new three.ImageBitmapLoader( this.options.manager );

		} else {

			this.textureLoader = new three.TextureLoader( this.options.manager );

		}

		this.textureLoader.setCrossOrigin( this.options.crossOrigin );
		this.textureLoader.setRequestHeader( this.options.requestHeader );

		this.fileLoader = new three.FileLoader( this.options.manager );
		this.fileLoader.setResponseType( 'arraybuffer' );

		if ( this.options.crossOrigin === 'use-credentials' ) {

			this.fileLoader.setWithCredentials( true );

		}

	}

	setExtensions( extensions ) {

		this.extensions = extensions;

	}

	setPlugins( plugins ) {

		this.plugins = plugins;

	}

	parse( onLoad, onError ) {

		const parser = this;
		const json = this.json;
		const extensions = this.extensions;

		// Clear the loader cache
		this.cache.removeAll();

		// Mark the special nodes/meshes in json for efficient parse
		this._invokeAll( function ( ext ) {

			return ext._markDefs && ext._markDefs();

		} );

		Promise.all( this._invokeAll( function ( ext ) {

			return ext.beforeRoot && ext.beforeRoot();

		} ) ).then( function () {

			return Promise.all( [

				parser.getDependencies( 'scene' ),
				parser.getDependencies( 'animation' ),
				parser.getDependencies( 'camera' ),

			] );

		} ).then( function ( dependencies ) {

			const result = {
				scene: dependencies[ 0 ][ json.scene || 0 ],
				scenes: dependencies[ 0 ],
				animations: dependencies[ 1 ],
				cameras: dependencies[ 2 ],
				asset: json.asset,
				parser: parser,
				userData: {}
			};

			addUnknownExtensionsToUserData( extensions, result, json );

			assignExtrasToUserData( result, json );

			Promise.all( parser._invokeAll( function ( ext ) {

				return ext.afterRoot && ext.afterRoot( result );

			} ) ).then( function () {

				onLoad( result );

			} );

		} ).catch( onError );

	}

	/**
	 * Marks the special nodes/meshes in json for efficient parse.
	 */
	_markDefs() {

		const nodeDefs = this.json.nodes || [];
		const skinDefs = this.json.skins || [];
		const meshDefs = this.json.meshes || [];

		// Nothing in the node definition indicates whether it is a Bone or an
		// Object3D. Use the skins' joint references to mark bones.
		for ( let skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex ++ ) {

			const joints = skinDefs[ skinIndex ].joints;

			for ( let i = 0, il = joints.length; i < il; i ++ ) {

				nodeDefs[ joints[ i ] ].isBone = true;

			}

		}

		// Iterate over all nodes, marking references to shared resources,
		// as well as skeleton joints.
		for ( let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex ++ ) {

			const nodeDef = nodeDefs[ nodeIndex ];

			if ( nodeDef.mesh !== undefined ) {

				this._addNodeRef( this.meshCache, nodeDef.mesh );

				// Nothing in the mesh definition indicates whether it is
				// a SkinnedMesh or Mesh. Use the node's mesh reference
				// to mark SkinnedMesh if node has skin.
				if ( nodeDef.skin !== undefined ) {

					meshDefs[ nodeDef.mesh ].isSkinnedMesh = true;

				}

			}

			if ( nodeDef.camera !== undefined ) {

				this._addNodeRef( this.cameraCache, nodeDef.camera );

			}

		}

	}

	/**
	 * Counts references to shared node / Object3D resources. These resources
	 * can be reused, or "instantiated", at multiple nodes in the scene
	 * hierarchy. Mesh, Camera, and Light instances are instantiated and must
	 * be marked. Non-scenegraph resources (like Materials, Geometries, and
	 * Textures) can be reused directly and are not marked here.
	 *
	 * Example: CesiumMilkTruck sample model reuses "Wheel" meshes.
	 */
	_addNodeRef( cache, index ) {

		if ( index === undefined ) return;

		if ( cache.refs[ index ] === undefined ) {

			cache.refs[ index ] = cache.uses[ index ] = 0;

		}

		cache.refs[ index ] ++;

	}

	/** Returns a reference to a shared resource, cloning it if necessary. */
	_getNodeRef( cache, index, object ) {

		if ( cache.refs[ index ] <= 1 ) return object;

		const ref = object.clone();

		// Propagates mappings to the cloned object, prevents mappings on the
		// original object from being lost.
		const updateMappings = ( original, clone ) => {

			const mappings = this.associations.get( original );
			if ( mappings != null ) {

				this.associations.set( clone, mappings );

			}

			for ( const [ i, child ] of original.children.entries() ) {

				updateMappings( child, clone.children[ i ] );

			}

		};

		updateMappings( object, ref );

		ref.name += '_instance_' + ( cache.uses[ index ] ++ );

		return ref;

	}

	_invokeOne( func ) {

		const extensions = Object.values( this.plugins );
		extensions.push( this );

		for ( let i = 0; i < extensions.length; i ++ ) {

			const result = func( extensions[ i ] );

			if ( result ) return result;

		}

		return null;

	}

	_invokeAll( func ) {

		const extensions = Object.values( this.plugins );
		extensions.unshift( this );

		const pending = [];

		for ( let i = 0; i < extensions.length; i ++ ) {

			const result = func( extensions[ i ] );

			if ( result ) pending.push( result );

		}

		return pending;

	}

	/**
	 * Requests the specified dependency asynchronously, with caching.
	 * @param {string} type
	 * @param {number} index
	 * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}
	 */
	getDependency( type, index ) {

		const cacheKey = type + ':' + index;
		let dependency = this.cache.get( cacheKey );

		if ( ! dependency ) {

			switch ( type ) {

				case 'scene':
					dependency = this.loadScene( index );
					break;

				case 'node':
					dependency = this.loadNode( index );
					break;

				case 'mesh':
					dependency = this._invokeOne( function ( ext ) {

						return ext.loadMesh && ext.loadMesh( index );

					} );
					break;

				case 'accessor':
					dependency = this.loadAccessor( index );
					break;

				case 'bufferView':
					dependency = this._invokeOne( function ( ext ) {

						return ext.loadBufferView && ext.loadBufferView( index );

					} );
					break;

				case 'buffer':
					dependency = this.loadBuffer( index );
					break;

				case 'material':
					dependency = this._invokeOne( function ( ext ) {

						return ext.loadMaterial && ext.loadMaterial( index );

					} );
					break;

				case 'texture':
					dependency = this._invokeOne( function ( ext ) {

						return ext.loadTexture && ext.loadTexture( index );

					} );
					break;

				case 'skin':
					dependency = this.loadSkin( index );
					break;

				case 'animation':
					dependency = this.loadAnimation( index );
					break;

				case 'camera':
					dependency = this.loadCamera( index );
					break;

				default:
					throw new Error( 'Unknown type: ' + type );

			}

			this.cache.add( cacheKey, dependency );

		}

		return dependency;

	}

	/**
	 * Requests all dependencies of the specified type asynchronously, with caching.
	 * @param {string} type
	 * @return {Promise<Array<Object>>}
	 */
	getDependencies( type ) {

		let dependencies = this.cache.get( type );

		if ( ! dependencies ) {

			const parser = this;
			const defs = this.json[ type + ( type === 'mesh' ? 'es' : 's' ) ] || [];

			dependencies = Promise.all( defs.map( function ( def, index ) {

				return parser.getDependency( type, index );

			} ) );

			this.cache.add( type, dependencies );

		}

		return dependencies;

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
	 * @param {number} bufferIndex
	 * @return {Promise<ArrayBuffer>}
	 */
	loadBuffer( bufferIndex ) {

		const bufferDef = this.json.buffers[ bufferIndex ];
		const loader = this.fileLoader;

		if ( bufferDef.type && bufferDef.type !== 'arraybuffer' ) {

			throw new Error( 'THREE.GLTFLoader: ' + bufferDef.type + ' buffer type is not supported.' );

		}

		// If present, GLB container is required to be the first buffer.
		if ( bufferDef.uri === undefined && bufferIndex === 0 ) {

			return Promise.resolve( this.extensions[ EXTENSIONS.KHR_BINARY_GLTF ].body );

		}

		const options = this.options;

		return new Promise( function ( resolve, reject ) {

			loader.load( three.LoaderUtils.resolveURL( bufferDef.uri, options.path ), resolve, undefined, function () {

				reject( new Error( 'THREE.GLTFLoader: Failed to load buffer "' + bufferDef.uri + '".' ) );

			} );

		} );

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
	 * @param {number} bufferViewIndex
	 * @return {Promise<ArrayBuffer>}
	 */
	loadBufferView( bufferViewIndex ) {

		const bufferViewDef = this.json.bufferViews[ bufferViewIndex ];

		return this.getDependency( 'buffer', bufferViewDef.buffer ).then( function ( buffer ) {

			const byteLength = bufferViewDef.byteLength || 0;
			const byteOffset = bufferViewDef.byteOffset || 0;
			return buffer.slice( byteOffset, byteOffset + byteLength );

		} );

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors
	 * @param {number} accessorIndex
	 * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}
	 */
	loadAccessor( accessorIndex ) {

		const parser = this;
		const json = this.json;

		const accessorDef = this.json.accessors[ accessorIndex ];

		if ( accessorDef.bufferView === undefined && accessorDef.sparse === undefined ) {

			// Ignore empty accessors, which may be used to declare runtime
			// information about attributes coming from another source (e.g. Draco
			// compression extension).
			return Promise.resolve( null );

		}

		const pendingBufferViews = [];

		if ( accessorDef.bufferView !== undefined ) {

			pendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.bufferView ) );

		} else {

			pendingBufferViews.push( null );

		}

		if ( accessorDef.sparse !== undefined ) {

			pendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.sparse.indices.bufferView ) );
			pendingBufferViews.push( this.getDependency( 'bufferView', accessorDef.sparse.values.bufferView ) );

		}

		return Promise.all( pendingBufferViews ).then( function ( bufferViews ) {

			const bufferView = bufferViews[ 0 ];

			const itemSize = WEBGL_TYPE_SIZES[ accessorDef.type ];
			const TypedArray = WEBGL_COMPONENT_TYPES[ accessorDef.componentType ];

			// For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.
			const elementBytes = TypedArray.BYTES_PER_ELEMENT;
			const itemBytes = elementBytes * itemSize;
			const byteOffset = accessorDef.byteOffset || 0;
			const byteStride = accessorDef.bufferView !== undefined ? json.bufferViews[ accessorDef.bufferView ].byteStride : undefined;
			const normalized = accessorDef.normalized === true;
			let array, bufferAttribute;

			// The buffer is not interleaved if the stride is the item size in bytes.
			if ( byteStride && byteStride !== itemBytes ) {

				// Each "slice" of the buffer, as defined by 'count' elements of 'byteStride' bytes, gets its own InterleavedBuffer
				// This makes sure that IBA.count reflects accessor.count properly
				const ibSlice = Math.floor( byteOffset / byteStride );
				const ibCacheKey = 'InterleavedBuffer:' + accessorDef.bufferView + ':' + accessorDef.componentType + ':' + ibSlice + ':' + accessorDef.count;
				let ib = parser.cache.get( ibCacheKey );

				if ( ! ib ) {

					array = new TypedArray( bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes );

					// Integer parameters to IB/IBA are in array elements, not bytes.
					ib = new three.InterleavedBuffer( array, byteStride / elementBytes );

					parser.cache.add( ibCacheKey, ib );

				}

				bufferAttribute = new three.InterleavedBufferAttribute( ib, itemSize, ( byteOffset % byteStride ) / elementBytes, normalized );

			} else {

				if ( bufferView === null ) {

					array = new TypedArray( accessorDef.count * itemSize );

				} else {

					array = new TypedArray( bufferView, byteOffset, accessorDef.count * itemSize );

				}

				bufferAttribute = new three.BufferAttribute( array, itemSize, normalized );

			}

			// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#sparse-accessors
			if ( accessorDef.sparse !== undefined ) {

				const itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;
				const TypedArrayIndices = WEBGL_COMPONENT_TYPES[ accessorDef.sparse.indices.componentType ];

				const byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;
				const byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;

				const sparseIndices = new TypedArrayIndices( bufferViews[ 1 ], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices );
				const sparseValues = new TypedArray( bufferViews[ 2 ], byteOffsetValues, accessorDef.sparse.count * itemSize );

				if ( bufferView !== null ) {

					// Avoid modifying the original ArrayBuffer, if the bufferView wasn't initialized with zeroes.
					bufferAttribute = new three.BufferAttribute( bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized );

				}

				for ( let i = 0, il = sparseIndices.length; i < il; i ++ ) {

					const index = sparseIndices[ i ];

					bufferAttribute.setX( index, sparseValues[ i * itemSize ] );
					if ( itemSize >= 2 ) bufferAttribute.setY( index, sparseValues[ i * itemSize + 1 ] );
					if ( itemSize >= 3 ) bufferAttribute.setZ( index, sparseValues[ i * itemSize + 2 ] );
					if ( itemSize >= 4 ) bufferAttribute.setW( index, sparseValues[ i * itemSize + 3 ] );
					if ( itemSize >= 5 ) throw new Error( 'THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.' );

				}

			}

			return bufferAttribute;

		} );

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures
	 * @param {number} textureIndex
	 * @return {Promise<THREE.Texture>}
	 */
	loadTexture( textureIndex ) {

		const json = this.json;
		const options = this.options;
		const textureDef = json.textures[ textureIndex ];
		const sourceIndex = textureDef.source;
		const sourceDef = json.images[ sourceIndex ];

		let loader = this.textureLoader;

		if ( sourceDef.uri ) {

			const handler = options.manager.getHandler( sourceDef.uri );
			if ( handler !== null ) loader = handler;

		}

		return this.loadTextureImage( textureIndex, sourceIndex, loader );

	}

	loadTextureImage( textureIndex, sourceIndex, loader ) {

		const parser = this;
		const json = this.json;

		const textureDef = json.textures[ textureIndex ];
		const sourceDef = json.images[ sourceIndex ];

		const cacheKey = ( sourceDef.uri || sourceDef.bufferView ) + ':' + textureDef.sampler;

		if ( this.textureCache[ cacheKey ] ) {

			// See https://github.com/mrdoob/three.js/issues/21559.
			return this.textureCache[ cacheKey ];

		}

		const promise = this.loadImageSource( sourceIndex, loader ).then( function ( texture ) {

			texture.flipY = false;

			if ( textureDef.name ) texture.name = textureDef.name;

			const samplers = json.samplers || {};
			const sampler = samplers[ textureDef.sampler ] || {};

			texture.magFilter = WEBGL_FILTERS[ sampler.magFilter ] || three.LinearFilter;
			texture.minFilter = WEBGL_FILTERS[ sampler.minFilter ] || three.LinearMipmapLinearFilter;
			texture.wrapS = WEBGL_WRAPPINGS[ sampler.wrapS ] || three.RepeatWrapping;
			texture.wrapT = WEBGL_WRAPPINGS[ sampler.wrapT ] || three.RepeatWrapping;

			parser.associations.set( texture, { textures: textureIndex } );

			return texture;

		} ).catch( function () {

			return null;

		} );

		this.textureCache[ cacheKey ] = promise;

		return promise;

	}

	loadImageSource( sourceIndex, loader ) {

		const parser = this;
		const json = this.json;
		const options = this.options;

		if ( this.sourceCache[ sourceIndex ] !== undefined ) {

			return this.sourceCache[ sourceIndex ].then( function ( texture ) {

				return texture.clone();

			} ).catch( function ( error ) {

				throw error;

			} );

		}

		const sourceDef = json.images[ sourceIndex ];

		const URL = self.URL || self.webkitURL;

		let sourceURI = sourceDef.uri || '';
		let isObjectURL = false;

		if ( sourceDef.bufferView !== undefined ) {

			// Load binary image data from bufferView, if provided.

			sourceURI = parser.getDependency( 'bufferView', sourceDef.bufferView ).then( function ( bufferView ) {

				isObjectURL = true;
				const blob = new Blob( [ bufferView ], { type: sourceDef.mimeType } );
				sourceURI = URL.createObjectURL( blob );
				return sourceURI;

			} );

		} else if ( sourceDef.uri === undefined ) {

			throw new Error( 'THREE.GLTFLoader: Image ' + sourceIndex + ' is missing URI and bufferView' );

		}

		const promise = Promise.resolve( sourceURI ).then( function ( sourceURI ) {

			return new Promise( function ( resolve, reject ) {

				let onLoad = resolve;

				if ( loader.isImageBitmapLoader === true ) {

					onLoad = function ( imageBitmap ) {

						const texture = new three.Texture( imageBitmap );
						texture.needsUpdate = true;

						resolve( texture );

					};

				}

				loader.load( three.LoaderUtils.resolveURL( sourceURI, options.path ), onLoad, undefined, reject );

			} );

		} ).then( function ( texture ) {

			// Clean up resources and configure Texture.

			if ( isObjectURL === true ) {

				URL.revokeObjectURL( sourceURI );

			}

			texture.userData.mimeType = sourceDef.mimeType || getImageURIMimeType( sourceDef.uri );

			return texture;

		} ).catch( function ( error ) {

			console.error( 'THREE.GLTFLoader: Couldn\'t load texture', sourceURI );
			throw error;

		} );

		this.sourceCache[ sourceIndex ] = promise;
		return promise;

	}

	/**
	 * Asynchronously assigns a texture to the given material parameters.
	 * @param {Object} materialParams
	 * @param {string} mapName
	 * @param {Object} mapDef
	 * @return {Promise<Texture>}
	 */
	assignTexture( materialParams, mapName, mapDef ) {

		const parser = this;

		return this.getDependency( 'texture', mapDef.index ).then( function ( texture ) {

			// Materials sample aoMap from UV set 1 and other maps from UV set 0 - this can't be configured
			// However, we will copy UV set 0 to UV set 1 on demand for aoMap
			if ( mapDef.texCoord !== undefined && mapDef.texCoord != 0 && ! ( mapName === 'aoMap' && mapDef.texCoord == 1 ) ) {

				console.warn( 'THREE.GLTFLoader: Custom UV set ' + mapDef.texCoord + ' for texture ' + mapName + ' not yet supported.' );

			}

			if ( parser.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ] ) {

				const transform = mapDef.extensions !== undefined ? mapDef.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ] : undefined;

				if ( transform ) {

					const gltfReference = parser.associations.get( texture );
					texture = parser.extensions[ EXTENSIONS.KHR_TEXTURE_TRANSFORM ].extendTexture( texture, transform );
					parser.associations.set( texture, gltfReference );

				}

			}

			materialParams[ mapName ] = texture;

			return texture;

		} );

	}

	/**
	 * Assigns final material to a Mesh, Line, or Points instance. The instance
	 * already has a material (generated from the glTF material options alone)
	 * but reuse of the same glTF material may require multiple threejs materials
	 * to accommodate different primitive types, defines, etc. New materials will
	 * be created if necessary, and reused from a cache.
	 * @param  {Object3D} mesh Mesh, Line, or Points instance.
	 */
	assignFinalMaterial( mesh ) {

		const geometry = mesh.geometry;
		let material = mesh.material;

		const useDerivativeTangents = geometry.attributes.tangent === undefined;
		const useVertexColors = geometry.attributes.color !== undefined;
		const useFlatShading = geometry.attributes.normal === undefined;

		if ( mesh.isPoints ) {

			const cacheKey = 'PointsMaterial:' + material.uuid;

			let pointsMaterial = this.cache.get( cacheKey );

			if ( ! pointsMaterial ) {

				pointsMaterial = new three.PointsMaterial();
				three.Material.prototype.copy.call( pointsMaterial, material );
				pointsMaterial.color.copy( material.color );
				pointsMaterial.map = material.map;
				pointsMaterial.sizeAttenuation = false; // glTF spec says points should be 1px

				this.cache.add( cacheKey, pointsMaterial );

			}

			material = pointsMaterial;

		} else if ( mesh.isLine ) {

			const cacheKey = 'LineBasicMaterial:' + material.uuid;

			let lineMaterial = this.cache.get( cacheKey );

			if ( ! lineMaterial ) {

				lineMaterial = new three.LineBasicMaterial();
				three.Material.prototype.copy.call( lineMaterial, material );
				lineMaterial.color.copy( material.color );

				this.cache.add( cacheKey, lineMaterial );

			}

			material = lineMaterial;

		}

		// Clone the material if it will be modified
		if ( useDerivativeTangents || useVertexColors || useFlatShading ) {

			let cacheKey = 'ClonedMaterial:' + material.uuid + ':';

			if ( material.isGLTFSpecularGlossinessMaterial ) cacheKey += 'specular-glossiness:';
			if ( useDerivativeTangents ) cacheKey += 'derivative-tangents:';
			if ( useVertexColors ) cacheKey += 'vertex-colors:';
			if ( useFlatShading ) cacheKey += 'flat-shading:';

			let cachedMaterial = this.cache.get( cacheKey );

			if ( ! cachedMaterial ) {

				cachedMaterial = material.clone();

				if ( useVertexColors ) cachedMaterial.vertexColors = true;
				if ( useFlatShading ) cachedMaterial.flatShading = true;

				if ( useDerivativeTangents ) {

					// https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995
					if ( cachedMaterial.normalScale ) cachedMaterial.normalScale.y *= - 1;
					if ( cachedMaterial.clearcoatNormalScale ) cachedMaterial.clearcoatNormalScale.y *= - 1;

				}

				this.cache.add( cacheKey, cachedMaterial );

				this.associations.set( cachedMaterial, this.associations.get( material ) );

			}

			material = cachedMaterial;

		}

		// workarounds for mesh and geometry

		if ( material.aoMap && geometry.attributes.uv2 === undefined && geometry.attributes.uv !== undefined ) {

			geometry.setAttribute( 'uv2', geometry.attributes.uv );

		}

		mesh.material = material;

	}

	getMaterialType( /* materialIndex */ ) {

		return three.MeshStandardMaterial;

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials
	 * @param {number} materialIndex
	 * @return {Promise<Material>}
	 */
	loadMaterial( materialIndex ) {

		const parser = this;
		const json = this.json;
		const extensions = this.extensions;
		const materialDef = json.materials[ materialIndex ];

		let materialType;
		const materialParams = {};
		const materialExtensions = materialDef.extensions || {};

		const pending = [];

		if ( materialExtensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ] ) {

			const sgExtension = extensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ];
			materialType = sgExtension.getMaterialType();
			pending.push( sgExtension.extendParams( materialParams, materialDef, parser ) );

		} else if ( materialExtensions[ EXTENSIONS.KHR_MATERIALS_UNLIT ] ) {

			const kmuExtension = extensions[ EXTENSIONS.KHR_MATERIALS_UNLIT ];
			materialType = kmuExtension.getMaterialType();
			pending.push( kmuExtension.extendParams( materialParams, materialDef, parser ) );

		} else {

			// Specification:
			// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#metallic-roughness-material

			const metallicRoughness = materialDef.pbrMetallicRoughness || {};

			materialParams.color = new three.Color( 1.0, 1.0, 1.0 );
			materialParams.opacity = 1.0;

			if ( Array.isArray( metallicRoughness.baseColorFactor ) ) {

				const array = metallicRoughness.baseColorFactor;

				materialParams.color.fromArray( array );
				materialParams.opacity = array[ 3 ];

			}

			if ( metallicRoughness.baseColorTexture !== undefined ) {

				pending.push( parser.assignTexture( materialParams, 'map', metallicRoughness.baseColorTexture ) );

			}

			materialParams.metalness = metallicRoughness.metallicFactor !== undefined ? metallicRoughness.metallicFactor : 1.0;
			materialParams.roughness = metallicRoughness.roughnessFactor !== undefined ? metallicRoughness.roughnessFactor : 1.0;

			if ( metallicRoughness.metallicRoughnessTexture !== undefined ) {

				pending.push( parser.assignTexture( materialParams, 'metalnessMap', metallicRoughness.metallicRoughnessTexture ) );
				pending.push( parser.assignTexture( materialParams, 'roughnessMap', metallicRoughness.metallicRoughnessTexture ) );

			}

			materialType = this._invokeOne( function ( ext ) {

				return ext.getMaterialType && ext.getMaterialType( materialIndex );

			} );

			pending.push( Promise.all( this._invokeAll( function ( ext ) {

				return ext.extendMaterialParams && ext.extendMaterialParams( materialIndex, materialParams );

			} ) ) );

		}

		if ( materialDef.doubleSided === true ) {

			materialParams.side = three.DoubleSide;

		}

		const alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;

		if ( alphaMode === ALPHA_MODES.BLEND ) {

			materialParams.transparent = true;

			// See: https://github.com/mrdoob/three.js/issues/17706
			materialParams.depthWrite = false;

		} else {

			materialParams.transparent = false;

			if ( alphaMode === ALPHA_MODES.MASK ) {

				materialParams.alphaTest = materialDef.alphaCutoff !== undefined ? materialDef.alphaCutoff : 0.5;

			}

		}

		if ( materialDef.normalTexture !== undefined && materialType !== three.MeshBasicMaterial ) {

			pending.push( parser.assignTexture( materialParams, 'normalMap', materialDef.normalTexture ) );

			materialParams.normalScale = new three.Vector2( 1, 1 );

			if ( materialDef.normalTexture.scale !== undefined ) {

				const scale = materialDef.normalTexture.scale;

				materialParams.normalScale.set( scale, scale );

			}

		}

		if ( materialDef.occlusionTexture !== undefined && materialType !== three.MeshBasicMaterial ) {

			pending.push( parser.assignTexture( materialParams, 'aoMap', materialDef.occlusionTexture ) );

			if ( materialDef.occlusionTexture.strength !== undefined ) {

				materialParams.aoMapIntensity = materialDef.occlusionTexture.strength;

			}

		}

		if ( materialDef.emissiveFactor !== undefined && materialType !== three.MeshBasicMaterial ) {

			materialParams.emissive = new three.Color().fromArray( materialDef.emissiveFactor );

		}

		if ( materialDef.emissiveTexture !== undefined && materialType !== three.MeshBasicMaterial ) {

			pending.push( parser.assignTexture( materialParams, 'emissiveMap', materialDef.emissiveTexture ) );

		}

		return Promise.all( pending ).then( function () {

			let material;

			if ( materialType === GLTFMeshStandardSGMaterial ) {

				material = extensions[ EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS ].createMaterial( materialParams );

			} else {

				material = new materialType( materialParams );

			}

			if ( materialDef.name ) material.name = materialDef.name;

			// baseColorTexture, emissiveTexture, sheenColorMap, specularColorMap and specularGlossinessTexture use sRGB encoding.
			if ( material.map ) material.map.encoding = three.sRGBEncoding;
			if ( material.emissiveMap ) material.emissiveMap.encoding = three.sRGBEncoding;
			if ( material.sheenColorMap ) material.sheenColorMap.encoding = three.sRGBEncoding;
			if ( material.specularColorMap ) material.specularColorMap.encoding = three.sRGBEncoding;
			if ( material.specularMap ) material.specularMap.encoding = three.sRGBEncoding;

			assignExtrasToUserData( material, materialDef );

			parser.associations.set( material, { materials: materialIndex } );

			if ( materialDef.extensions ) addUnknownExtensionsToUserData( extensions, material, materialDef );

			return material;

		} );

	}

	/** When Object3D instances are targeted by animation, they need unique names. */
	createUniqueName( originalName ) {

		const sanitizedName = three.PropertyBinding.sanitizeNodeName( originalName || '' );

		let name = sanitizedName;

		for ( let i = 1; this.nodeNamesUsed[ name ]; ++ i ) {

			name = sanitizedName + '_' + i;

		}

		this.nodeNamesUsed[ name ] = true;

		return name;

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry
	 *
	 * Creates BufferGeometries from primitives.
	 *
	 * @param {Array<GLTF.Primitive>} primitives
	 * @return {Promise<Array<BufferGeometry>>}
	 */
	loadGeometries( primitives ) {

		const parser = this;
		const extensions = this.extensions;
		const cache = this.primitiveCache;

		function createDracoPrimitive( primitive ) {

			return extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ]
				.decodePrimitive( primitive, parser )
				.then( function ( geometry ) {

					return addPrimitiveAttributes( geometry, primitive, parser );

				} );

		}

		const pending = [];

		for ( let i = 0, il = primitives.length; i < il; i ++ ) {

			const primitive = primitives[ i ];
			const cacheKey = createPrimitiveKey( primitive );

			// See if we've already created this geometry
			const cached = cache[ cacheKey ];

			if ( cached ) {

				// Use the cached geometry if it exists
				pending.push( cached.promise );

			} else {

				let geometryPromise;

				if ( primitive.extensions && primitive.extensions[ EXTENSIONS.KHR_DRACO_MESH_COMPRESSION ] ) {

					// Use DRACO geometry if available
					geometryPromise = createDracoPrimitive( primitive );

				} else {

					// Otherwise create a new geometry
					geometryPromise = addPrimitiveAttributes( new three.BufferGeometry(), primitive, parser );

				}

				// Cache this geometry
				cache[ cacheKey ] = { primitive: primitive, promise: geometryPromise };

				pending.push( geometryPromise );

			}

		}

		return Promise.all( pending );

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes
	 * @param {number} meshIndex
	 * @return {Promise<Group|Mesh|SkinnedMesh>}
	 */
	loadMesh( meshIndex ) {

		const parser = this;
		const json = this.json;
		const extensions = this.extensions;

		const meshDef = json.meshes[ meshIndex ];
		const primitives = meshDef.primitives;

		const pending = [];

		for ( let i = 0, il = primitives.length; i < il; i ++ ) {

			const material = primitives[ i ].material === undefined
				? createDefaultMaterial( this.cache )
				: this.getDependency( 'material', primitives[ i ].material );

			pending.push( material );

		}

		pending.push( parser.loadGeometries( primitives ) );

		return Promise.all( pending ).then( function ( results ) {

			const materials = results.slice( 0, results.length - 1 );
			const geometries = results[ results.length - 1 ];

			const meshes = [];

			for ( let i = 0, il = geometries.length; i < il; i ++ ) {

				const geometry = geometries[ i ];
				const primitive = primitives[ i ];

				// 1. create Mesh

				let mesh;

				const material = materials[ i ];

				if ( primitive.mode === WEBGL_CONSTANTS.TRIANGLES ||
						primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ||
						primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ||
						primitive.mode === undefined ) {

					// .isSkinnedMesh isn't in glTF spec. See ._markDefs()
					mesh = meshDef.isSkinnedMesh === true
						? new three.SkinnedMesh( geometry, material )
						: new three.Mesh( geometry, material );

					if ( mesh.isSkinnedMesh === true && ! mesh.geometry.attributes.skinWeight.normalized ) {

						// we normalize floating point skin weight array to fix malformed assets (see #15319)
						// it's important to skip this for non-float32 data since normalizeSkinWeights assumes non-normalized inputs
						mesh.normalizeSkinWeights();

					}

					if ( primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ) {

						mesh.geometry = toTrianglesDrawMode( mesh.geometry, three.TriangleStripDrawMode );

					} else if ( primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ) {

						mesh.geometry = toTrianglesDrawMode( mesh.geometry, three.TriangleFanDrawMode );

					}

				} else if ( primitive.mode === WEBGL_CONSTANTS.LINES ) {

					mesh = new three.LineSegments( geometry, material );

				} else if ( primitive.mode === WEBGL_CONSTANTS.LINE_STRIP ) {

					mesh = new three.Line( geometry, material );

				} else if ( primitive.mode === WEBGL_CONSTANTS.LINE_LOOP ) {

					mesh = new three.LineLoop( geometry, material );

				} else if ( primitive.mode === WEBGL_CONSTANTS.POINTS ) {

					mesh = new three.Points( geometry, material );

				} else {

					throw new Error( 'THREE.GLTFLoader: Primitive mode unsupported: ' + primitive.mode );

				}

				if ( Object.keys( mesh.geometry.morphAttributes ).length > 0 ) {

					updateMorphTargets( mesh, meshDef );

				}

				mesh.name = parser.createUniqueName( meshDef.name || ( 'mesh_' + meshIndex ) );

				assignExtrasToUserData( mesh, meshDef );

				if ( primitive.extensions ) addUnknownExtensionsToUserData( extensions, mesh, primitive );

				parser.assignFinalMaterial( mesh );

				meshes.push( mesh );

			}

			for ( let i = 0, il = meshes.length; i < il; i ++ ) {

				parser.associations.set( meshes[ i ], {
					meshes: meshIndex,
					primitives: i
				} );

			}

			if ( meshes.length === 1 ) {

				return meshes[ 0 ];

			}

			const group = new three.Group();

			parser.associations.set( group, { meshes: meshIndex } );

			for ( let i = 0, il = meshes.length; i < il; i ++ ) {

				group.add( meshes[ i ] );

			}

			return group;

		} );

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras
	 * @param {number} cameraIndex
	 * @return {Promise<THREE.Camera>}
	 */
	loadCamera( cameraIndex ) {

		let camera;
		const cameraDef = this.json.cameras[ cameraIndex ];
		const params = cameraDef[ cameraDef.type ];

		if ( ! params ) {

			console.warn( 'THREE.GLTFLoader: Missing camera parameters.' );
			return;

		}

		if ( cameraDef.type === 'perspective' ) {

			camera = new three.PerspectiveCamera( three.MathUtils.radToDeg( params.yfov ), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6 );

		} else if ( cameraDef.type === 'orthographic' ) {

			camera = new three.OrthographicCamera( - params.xmag, params.xmag, params.ymag, - params.ymag, params.znear, params.zfar );

		}

		if ( cameraDef.name ) camera.name = this.createUniqueName( cameraDef.name );

		assignExtrasToUserData( camera, cameraDef );

		return Promise.resolve( camera );

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins
	 * @param {number} skinIndex
	 * @return {Promise<Object>}
	 */
	loadSkin( skinIndex ) {

		const skinDef = this.json.skins[ skinIndex ];

		const skinEntry = { joints: skinDef.joints };

		if ( skinDef.inverseBindMatrices === undefined ) {

			return Promise.resolve( skinEntry );

		}

		return this.getDependency( 'accessor', skinDef.inverseBindMatrices ).then( function ( accessor ) {

			skinEntry.inverseBindMatrices = accessor;

			return skinEntry;

		} );

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations
	 * @param {number} animationIndex
	 * @return {Promise<AnimationClip>}
	 */
	loadAnimation( animationIndex ) {

		const json = this.json;

		const animationDef = json.animations[ animationIndex ];

		const pendingNodes = [];
		const pendingInputAccessors = [];
		const pendingOutputAccessors = [];
		const pendingSamplers = [];
		const pendingTargets = [];

		for ( let i = 0, il = animationDef.channels.length; i < il; i ++ ) {

			const channel = animationDef.channels[ i ];
			const sampler = animationDef.samplers[ channel.sampler ];
			const target = channel.target;
			const name = target.node !== undefined ? target.node : target.id; // NOTE: target.id is deprecated.
			const input = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.input ] : sampler.input;
			const output = animationDef.parameters !== undefined ? animationDef.parameters[ sampler.output ] : sampler.output;

			pendingNodes.push( this.getDependency( 'node', name ) );
			pendingInputAccessors.push( this.getDependency( 'accessor', input ) );
			pendingOutputAccessors.push( this.getDependency( 'accessor', output ) );
			pendingSamplers.push( sampler );
			pendingTargets.push( target );

		}

		return Promise.all( [

			Promise.all( pendingNodes ),
			Promise.all( pendingInputAccessors ),
			Promise.all( pendingOutputAccessors ),
			Promise.all( pendingSamplers ),
			Promise.all( pendingTargets )

		] ).then( function ( dependencies ) {

			const nodes = dependencies[ 0 ];
			const inputAccessors = dependencies[ 1 ];
			const outputAccessors = dependencies[ 2 ];
			const samplers = dependencies[ 3 ];
			const targets = dependencies[ 4 ];

			const tracks = [];

			for ( let i = 0, il = nodes.length; i < il; i ++ ) {

				const node = nodes[ i ];
				const inputAccessor = inputAccessors[ i ];
				const outputAccessor = outputAccessors[ i ];
				const sampler = samplers[ i ];
				const target = targets[ i ];

				if ( node === undefined ) continue;

				node.updateMatrix();
				node.matrixAutoUpdate = true;

				let TypedKeyframeTrack;

				switch ( PATH_PROPERTIES[ target.path ] ) {

					case PATH_PROPERTIES.weights:

						TypedKeyframeTrack = three.NumberKeyframeTrack;
						break;

					case PATH_PROPERTIES.rotation:

						TypedKeyframeTrack = three.QuaternionKeyframeTrack;
						break;

					case PATH_PROPERTIES.position:
					case PATH_PROPERTIES.scale:
					default:

						TypedKeyframeTrack = three.VectorKeyframeTrack;
						break;

				}

				const targetName = node.name ? node.name : node.uuid;

				const interpolation = sampler.interpolation !== undefined ? INTERPOLATION[ sampler.interpolation ] : three.InterpolateLinear;

				const targetNames = [];

				if ( PATH_PROPERTIES[ target.path ] === PATH_PROPERTIES.weights ) {

					node.traverse( function ( object ) {

						if ( object.morphTargetInfluences ) {

							targetNames.push( object.name ? object.name : object.uuid );

						}

					} );

				} else {

					targetNames.push( targetName );

				}

				let outputArray = outputAccessor.array;

				if ( outputAccessor.normalized ) {

					const scale = getNormalizedComponentScale( outputArray.constructor );
					const scaled = new Float32Array( outputArray.length );

					for ( let j = 0, jl = outputArray.length; j < jl; j ++ ) {

						scaled[ j ] = outputArray[ j ] * scale;

					}

					outputArray = scaled;

				}

				for ( let j = 0, jl = targetNames.length; j < jl; j ++ ) {

					const track = new TypedKeyframeTrack(
						targetNames[ j ] + '.' + PATH_PROPERTIES[ target.path ],
						inputAccessor.array,
						outputArray,
						interpolation
					);

					// Override interpolation with custom factory method.
					if ( sampler.interpolation === 'CUBICSPLINE' ) {

						track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline( result ) {

							// A CUBICSPLINE keyframe in glTF has three output values for each input value,
							// representing inTangent, splineVertex, and outTangent. As a result, track.getValueSize()
							// must be divided by three to get the interpolant's sampleSize argument.

							const interpolantType = ( this instanceof three.QuaternionKeyframeTrack ) ? GLTFCubicSplineQuaternionInterpolant : GLTFCubicSplineInterpolant;

							return new interpolantType( this.times, this.values, this.getValueSize() / 3, result );

						};

						// Mark as CUBICSPLINE. `track.getInterpolation()` doesn't support custom interpolants.
						track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;

					}

					tracks.push( track );

				}

			}

			const name = animationDef.name ? animationDef.name : 'animation_' + animationIndex;

			return new three.AnimationClip( name, undefined, tracks );

		} );

	}

	createNodeMesh( nodeIndex ) {

		const json = this.json;
		const parser = this;
		const nodeDef = json.nodes[ nodeIndex ];

		if ( nodeDef.mesh === undefined ) return null;

		return parser.getDependency( 'mesh', nodeDef.mesh ).then( function ( mesh ) {

			const node = parser._getNodeRef( parser.meshCache, nodeDef.mesh, mesh );

			// if weights are provided on the node, override weights on the mesh.
			if ( nodeDef.weights !== undefined ) {

				node.traverse( function ( o ) {

					if ( ! o.isMesh ) return;

					for ( let i = 0, il = nodeDef.weights.length; i < il; i ++ ) {

						o.morphTargetInfluences[ i ] = nodeDef.weights[ i ];

					}

				} );

			}

			return node;

		} );

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy
	 * @param {number} nodeIndex
	 * @return {Promise<Object3D>}
	 */
	loadNode( nodeIndex ) {

		const json = this.json;
		const extensions = this.extensions;
		const parser = this;

		const nodeDef = json.nodes[ nodeIndex ];

		// reserve node's name before its dependencies, so the root has the intended name.
		const nodeName = nodeDef.name ? parser.createUniqueName( nodeDef.name ) : '';

		return ( function () {

			const pending = [];

			const meshPromise = parser._invokeOne( function ( ext ) {

				return ext.createNodeMesh && ext.createNodeMesh( nodeIndex );

			} );

			if ( meshPromise ) {

				pending.push( meshPromise );

			}

			if ( nodeDef.camera !== undefined ) {

				pending.push( parser.getDependency( 'camera', nodeDef.camera ).then( function ( camera ) {

					return parser._getNodeRef( parser.cameraCache, nodeDef.camera, camera );

				} ) );

			}

			parser._invokeAll( function ( ext ) {

				return ext.createNodeAttachment && ext.createNodeAttachment( nodeIndex );

			} ).forEach( function ( promise ) {

				pending.push( promise );

			} );

			return Promise.all( pending );

		}() ).then( function ( objects ) {

			let node;

			// .isBone isn't in glTF spec. See ._markDefs
			if ( nodeDef.isBone === true ) {

				node = new three.Bone();

			} else if ( objects.length > 1 ) {

				node = new three.Group();

			} else if ( objects.length === 1 ) {

				node = objects[ 0 ];

			} else {

				node = new three.Object3D();

			}

			if ( node !== objects[ 0 ] ) {

				for ( let i = 0, il = objects.length; i < il; i ++ ) {

					node.add( objects[ i ] );

				}

			}

			if ( nodeDef.name ) {

				node.userData.name = nodeDef.name;
				node.name = nodeName;

			}

			assignExtrasToUserData( node, nodeDef );

			if ( nodeDef.extensions ) addUnknownExtensionsToUserData( extensions, node, nodeDef );

			if ( nodeDef.matrix !== undefined ) {

				const matrix = new three.Matrix4();
				matrix.fromArray( nodeDef.matrix );
				node.applyMatrix4( matrix );

			} else {

				if ( nodeDef.translation !== undefined ) {

					node.position.fromArray( nodeDef.translation );

				}

				if ( nodeDef.rotation !== undefined ) {

					node.quaternion.fromArray( nodeDef.rotation );

				}

				if ( nodeDef.scale !== undefined ) {

					node.scale.fromArray( nodeDef.scale );

				}

			}

			if ( ! parser.associations.has( node ) ) {

				parser.associations.set( node, {} );

			}

			parser.associations.get( node ).nodes = nodeIndex;

			return node;

		} );

	}

	/**
	 * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes
	 * @param {number} sceneIndex
	 * @return {Promise<Group>}
	 */
	loadScene( sceneIndex ) {

		const json = this.json;
		const extensions = this.extensions;
		const sceneDef = this.json.scenes[ sceneIndex ];
		const parser = this;

		// Loader returns Group, not Scene.
		// See: https://github.com/mrdoob/three.js/issues/18342#issuecomment-578981172
		const scene = new three.Group();
		if ( sceneDef.name ) scene.name = parser.createUniqueName( sceneDef.name );

		assignExtrasToUserData( scene, sceneDef );

		if ( sceneDef.extensions ) addUnknownExtensionsToUserData( extensions, scene, sceneDef );

		const nodeIds = sceneDef.nodes || [];

		const pending = [];

		for ( let i = 0, il = nodeIds.length; i < il; i ++ ) {

			pending.push( buildNodeHierarchy( nodeIds[ i ], scene, json, parser ) );

		}

		return Promise.all( pending ).then( function () {

			// Removes dangling associations, associations that reference a node that
			// didn't make it into the scene.
			const reduceAssociations = ( node ) => {

				const reducedAssociations = new Map();

				for ( const [ key, value ] of parser.associations ) {

					if ( key instanceof three.Material || key instanceof three.Texture ) {

						reducedAssociations.set( key, value );

					}

				}

				node.traverse( ( node ) => {

					const mappings = parser.associations.get( node );

					if ( mappings != null ) {

						reducedAssociations.set( node, mappings );

					}

				} );

				return reducedAssociations;

			};

			parser.associations = reduceAssociations( scene );

			return scene;

		} );

	}

}

function buildNodeHierarchy( nodeId, parentObject, json, parser ) {

	const nodeDef = json.nodes[ nodeId ];

	return parser.getDependency( 'node', nodeId ).then( function ( node ) {

		if ( nodeDef.skin === undefined ) return node;

		// build skeleton here as well

		let skinEntry;

		return parser.getDependency( 'skin', nodeDef.skin ).then( function ( skin ) {

			skinEntry = skin;

			const pendingJoints = [];

			for ( let i = 0, il = skinEntry.joints.length; i < il; i ++ ) {

				pendingJoints.push( parser.getDependency( 'node', skinEntry.joints[ i ] ) );

			}

			return Promise.all( pendingJoints );

		} ).then( function ( jointNodes ) {

			node.traverse( function ( mesh ) {

				if ( ! mesh.isMesh ) return;

				const bones = [];
				const boneInverses = [];

				for ( let j = 0, jl = jointNodes.length; j < jl; j ++ ) {

					const jointNode = jointNodes[ j ];

					if ( jointNode ) {

						bones.push( jointNode );

						const mat = new three.Matrix4();

						if ( skinEntry.inverseBindMatrices !== undefined ) {

							mat.fromArray( skinEntry.inverseBindMatrices.array, j * 16 );

						}

						boneInverses.push( mat );

					} else {

						console.warn( 'THREE.GLTFLoader: Joint "%s" could not be found.', skinEntry.joints[ j ] );

					}

				}

				mesh.bind( new three.Skeleton( bones, boneInverses ), mesh.matrixWorld );

			} );

			return node;

		} );

	} ).then( function ( node ) {

		// build node hierachy

		parentObject.add( node );

		const pending = [];

		if ( nodeDef.children ) {

			const children = nodeDef.children;

			for ( let i = 0, il = children.length; i < il; i ++ ) {

				const child = children[ i ];
				pending.push( buildNodeHierarchy( child, node, json, parser ) );

			}

		}

		return Promise.all( pending );

	} );

}

/**
 * @param {BufferGeometry} geometry
 * @param {GLTF.Primitive} primitiveDef
 * @param {GLTFParser} parser
 */
function computeBounds( geometry, primitiveDef, parser ) {

	const attributes = primitiveDef.attributes;

	const box = new three.Box3();

	if ( attributes.POSITION !== undefined ) {

		const accessor = parser.json.accessors[ attributes.POSITION ];

		const min = accessor.min;
		const max = accessor.max;

		// glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.

		if ( min !== undefined && max !== undefined ) {

			box.set(
				new three.Vector3( min[ 0 ], min[ 1 ], min[ 2 ] ),
				new three.Vector3( max[ 0 ], max[ 1 ], max[ 2 ] )
			);

			if ( accessor.normalized ) {

				const boxScale = getNormalizedComponentScale( WEBGL_COMPONENT_TYPES[ accessor.componentType ] );
				box.min.multiplyScalar( boxScale );
				box.max.multiplyScalar( boxScale );

			}

		} else {

			console.warn( 'THREE.GLTFLoader: Missing min/max properties for accessor POSITION.' );

			return;

		}

	} else {

		return;

	}

	const targets = primitiveDef.targets;

	if ( targets !== undefined ) {

		const maxDisplacement = new three.Vector3();
		const vector = new three.Vector3();

		for ( let i = 0, il = targets.length; i < il; i ++ ) {

			const target = targets[ i ];

			if ( target.POSITION !== undefined ) {

				const accessor = parser.json.accessors[ target.POSITION ];
				const min = accessor.min;
				const max = accessor.max;

				// glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.

				if ( min !== undefined && max !== undefined ) {

					// we need to get max of absolute components because target weight is [-1,1]
					vector.setX( Math.max( Math.abs( min[ 0 ] ), Math.abs( max[ 0 ] ) ) );
					vector.setY( Math.max( Math.abs( min[ 1 ] ), Math.abs( max[ 1 ] ) ) );
					vector.setZ( Math.max( Math.abs( min[ 2 ] ), Math.abs( max[ 2 ] ) ) );


					if ( accessor.normalized ) {

						const boxScale = getNormalizedComponentScale( WEBGL_COMPONENT_TYPES[ accessor.componentType ] );
						vector.multiplyScalar( boxScale );

					}

					// Note: this assumes that the sum of all weights is at most 1. This isn't quite correct - it's more conservative
					// to assume that each target can have a max weight of 1. However, for some use cases - notably, when morph targets
					// are used to implement key-frame animations and as such only two are active at a time - this results in very large
					// boxes. So for now we make a box that's sometimes a touch too small but is hopefully mostly of reasonable size.
					maxDisplacement.max( vector );

				} else {

					console.warn( 'THREE.GLTFLoader: Missing min/max properties for accessor POSITION.' );

				}

			}

		}

		// As per comment above this box isn't conservative, but has a reasonable size for a very large number of morph targets.
		box.expandByVector( maxDisplacement );

	}

	geometry.boundingBox = box;

	const sphere = new three.Sphere();

	box.getCenter( sphere.center );
	sphere.radius = box.min.distanceTo( box.max ) / 2;

	geometry.boundingSphere = sphere;

}

/**
 * @param {BufferGeometry} geometry
 * @param {GLTF.Primitive} primitiveDef
 * @param {GLTFParser} parser
 * @return {Promise<BufferGeometry>}
 */
function addPrimitiveAttributes( geometry, primitiveDef, parser ) {

	const attributes = primitiveDef.attributes;

	const pending = [];

	function assignAttributeAccessor( accessorIndex, attributeName ) {

		return parser.getDependency( 'accessor', accessorIndex )
			.then( function ( accessor ) {

				geometry.setAttribute( attributeName, accessor );

			} );

	}

	for ( const gltfAttributeName in attributes ) {

		const threeAttributeName = ATTRIBUTES[ gltfAttributeName ] || gltfAttributeName.toLowerCase();

		// Skip attributes already provided by e.g. Draco extension.
		if ( threeAttributeName in geometry.attributes ) continue;

		pending.push( assignAttributeAccessor( attributes[ gltfAttributeName ], threeAttributeName ) );

	}

	if ( primitiveDef.indices !== undefined && ! geometry.index ) {

		const accessor = parser.getDependency( 'accessor', primitiveDef.indices ).then( function ( accessor ) {

			geometry.setIndex( accessor );

		} );

		pending.push( accessor );

	}

	assignExtrasToUserData( geometry, primitiveDef );

	computeBounds( geometry, primitiveDef, parser );

	return Promise.all( pending ).then( function () {

		return primitiveDef.targets !== undefined
			? addMorphTargets( geometry, primitiveDef.targets, parser )
			: geometry;

	} );

}

/**
 * @param {BufferGeometry} geometry
 * @param {Number} drawMode
 * @return {BufferGeometry}
 */
function toTrianglesDrawMode( geometry, drawMode ) {

	let index = geometry.getIndex();

	// generate index if not present

	if ( index === null ) {

		const indices = [];

		const position = geometry.getAttribute( 'position' );

		if ( position !== undefined ) {

			for ( let i = 0; i < position.count; i ++ ) {

				indices.push( i );

			}

			geometry.setIndex( indices );
			index = geometry.getIndex();

		} else {

			console.error( 'THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.' );
			return geometry;

		}

	}

	//

	const numberOfTriangles = index.count - 2;
	const newIndices = [];

	if ( drawMode === three.TriangleFanDrawMode ) {

		// gl.TRIANGLE_FAN

		for ( let i = 1; i <= numberOfTriangles; i ++ ) {

			newIndices.push( index.getX( 0 ) );
			newIndices.push( index.getX( i ) );
			newIndices.push( index.getX( i + 1 ) );

		}

	} else {

		// gl.TRIANGLE_STRIP

		for ( let i = 0; i < numberOfTriangles; i ++ ) {

			if ( i % 2 === 0 ) {

				newIndices.push( index.getX( i ) );
				newIndices.push( index.getX( i + 1 ) );
				newIndices.push( index.getX( i + 2 ) );


			} else {

				newIndices.push( index.getX( i + 2 ) );
				newIndices.push( index.getX( i + 1 ) );
				newIndices.push( index.getX( i ) );

			}

		}

	}

	if ( ( newIndices.length / 3 ) !== numberOfTriangles ) {

		console.error( 'THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.' );

	}

	// build final geometry

	const newGeometry = geometry.clone();
	newGeometry.setIndex( newIndices );

	return newGeometry;

}/**
 * @webxr-input-profiles/motion-controllers 1.0.0 https://github.com/immersive-web/webxr-input-profiles
 */

const Constants = {
  Handedness: Object.freeze({
    NONE: 'none',
    LEFT: 'left',
    RIGHT: 'right'
  }),
  ComponentState: Object.freeze({
    DEFAULT: 'default',
    TOUCHED: 'touched',
    PRESSED: 'pressed'
  }),
  ComponentProperty: Object.freeze({
    BUTTON: 'button',
    X_AXIS: 'xAxis',
    Y_AXIS: 'yAxis',
    STATE: 'state'
  }),
  ComponentType: Object.freeze({
    TRIGGER: 'trigger',
    SQUEEZE: 'squeeze',
    TOUCHPAD: 'touchpad',
    THUMBSTICK: 'thumbstick',
    BUTTON: 'button'
  }),
  ButtonTouchThreshold: 0.05,
  AxisTouchThreshold: 0.1,
  VisualResponseProperty: Object.freeze({
    TRANSFORM: 'transform',
    VISIBILITY: 'visibility'
  })
};

/** @constant {Object} */
const defaultComponentValues = {
  xAxis: 0,
  yAxis: 0,
  button: 0,
  state: Constants.ComponentState.DEFAULT
};

/**
 * @description Static helper function to fetch a JSON file and turn it into a JS object
 * @param {string} path - Path to JSON file to be fetched
 */
async function fetchJsonFile(path) {
  const response = await fetch(path);
  if (!response.ok) {
    throw new Error(response.statusText);
  } else {
    return response.json();
  }
}
async function fetchProfilesList(basePath) {
  if (!basePath) {
    throw new Error('No basePath supplied');
  }
  const profileListFileName = 'profilesList.json';
  const profilesList = await fetchJsonFile(`${basePath}/${profileListFileName}`);
  return profilesList;
}
async function fetchProfile(xrInputSource, basePath, defaultProfile, getAssetPath) {
  if (defaultProfile === void 0) {
    defaultProfile = null;
  }
  if (getAssetPath === void 0) {
    getAssetPath = true;
  }
  if (!xrInputSource) {
    throw new Error('No xrInputSource supplied');
  }
  if (!basePath) {
    throw new Error('No basePath supplied');
  }

  // Get the list of profiles
  const supportedProfilesList = await fetchProfilesList(basePath);

  // Find the relative path to the first requested profile that is recognized
  let match;
  xrInputSource.profiles.some(profileId => {
    const supportedProfile = supportedProfilesList[profileId];
    if (supportedProfile) {
      match = {
        profileId,
        profilePath: `${basePath}/${supportedProfile.path}`,
        deprecated: !!supportedProfile.deprecated
      };
    }
    return !!match;
  });
  if (!match) {
    if (!defaultProfile) {
      throw new Error('No matching profile name found');
    }
    const supportedProfile = supportedProfilesList[defaultProfile];
    if (!supportedProfile) {
      throw new Error(`No matching profile name found and default profile "${defaultProfile}" missing.`);
    }
    match = {
      profileId: defaultProfile,
      profilePath: `${basePath}/${supportedProfile.path}`,
      deprecated: !!supportedProfile.deprecated
    };
  }
  const profile = await fetchJsonFile(match.profilePath);
  let assetPath;
  if (getAssetPath) {
    let layout;
    if (xrInputSource.handedness === 'any') {
      layout = profile.layouts[Object.keys(profile.layouts)[0]];
    } else {
      layout = profile.layouts[xrInputSource.handedness];
    }
    if (!layout) {
      throw new Error(`No matching handedness, ${xrInputSource.handedness}, in profile ${match.profileId}`);
    }
    if (layout.assetPath) {
      assetPath = match.profilePath.replace('profile.json', layout.assetPath);
    }
  }
  return {
    profile,
    assetPath
  };
}

/**
 * @description Converts an X, Y coordinate from the range -1 to 1 (as reported by the Gamepad
 * API) to the range 0 to 1 (for interpolation). Also caps the X, Y values to be bounded within
 * a circle. This ensures that thumbsticks are not animated outside the bounds of their physical
 * range of motion and touchpads do not report touch locations off their physical bounds.
 * @param {number} x The original x coordinate in the range -1 to 1
 * @param {number} y The original y coordinate in the range -1 to 1
 */
function normalizeAxes(x, y) {
  if (x === void 0) {
    x = 0;
  }
  if (y === void 0) {
    y = 0;
  }
  let xAxis = x;
  let yAxis = y;

  // Determine if the point is outside the bounds of the circle
  // and, if so, place it on the edge of the circle
  const hypotenuse = Math.sqrt(x * x + y * y);
  if (hypotenuse > 1) {
    const theta = Math.atan2(y, x);
    xAxis = Math.cos(theta);
    yAxis = Math.sin(theta);
  }

  // Scale and move the circle so values are in the interpolation range.  The circle's origin moves
  // from (0, 0) to (0.5, 0.5). The circle's radius scales from 1 to be 0.5.
  const result = {
    normalizedXAxis: xAxis * 0.5 + 0.5,
    normalizedYAxis: yAxis * 0.5 + 0.5
  };
  return result;
}

/**
 * Contains the description of how the 3D model should visually respond to a specific user input.
 * This is accomplished by initializing the object with the name of a node in the 3D model and
 * property that need to be modified in response to user input, the name of the nodes representing
 * the allowable range of motion, and the name of the input which triggers the change. In response
 * to the named input changing, this object computes the appropriate weighting to use for
 * interpolating between the range of motion nodes.
 */

class VisualResponse {
  constructor(visualResponseDescription) {
    this.componentProperty = visualResponseDescription.componentProperty;
    this.states = visualResponseDescription.states;
    this.valueNodeName = visualResponseDescription.valueNodeName;
    this.valueNodeProperty = visualResponseDescription.valueNodeProperty;
    if (this.valueNodeProperty === Constants.VisualResponseProperty.TRANSFORM) {
      this.minNodeName = visualResponseDescription.minNodeName;
      this.maxNodeName = visualResponseDescription.maxNodeName;
    }
    // Initializes the response's current value based on default data
    this.value = 0;
    this.updateFromComponent(defaultComponentValues);
  }

  /**
   * Computes the visual response's interpolation weight based on component state
   * @param {Object} componentValues - The component from which to update
   * @param {number} xAxis - The reported X axis value of the component
   * @param {number} yAxis - The reported Y axis value of the component
   * @param {number} button - The reported value of the component's button
   * @param {string} state - The component's active state
   */
  updateFromComponent(_ref) {
    let {
      xAxis,
      yAxis,
      button,
      state
    } = _ref;
    const {
      normalizedXAxis,
      normalizedYAxis
    } = normalizeAxes(xAxis, yAxis);
    switch (this.componentProperty) {
      case Constants.ComponentProperty.X_AXIS:
        this.value = this.states.includes(state) ? normalizedXAxis : 0.5;
        break;
      case Constants.ComponentProperty.Y_AXIS:
        this.value = this.states.includes(state) ? normalizedYAxis : 0.5;
        break;
      case Constants.ComponentProperty.BUTTON:
        this.value = this.states.includes(state) ? button : 0;
        break;
      case Constants.ComponentProperty.STATE:
        if (this.valueNodeProperty === Constants.VisualResponseProperty.VISIBILITY) {
          this.value = this.states.includes(state);
        } else {
          this.value = this.states.includes(state) ? 1.0 : 0.0;
        }
        break;
      default:
        throw new Error(`Unexpected visualResponse componentProperty ${this.componentProperty}`);
    }
  }
}
class Component {
  /**
   * @param {Object} componentId - Id of the component
   * @param {Object} componentDescription - Description of the component to be created
   */
  constructor(componentId, componentDescription) {
    if (!componentId || !componentDescription || !componentDescription.visualResponses || !componentDescription.gamepadIndices || Object.keys(componentDescription.gamepadIndices).length === 0) {
      throw new Error('Invalid arguments supplied');
    }
    this.id = componentId;
    this.type = componentDescription.type;
    this.rootNodeName = componentDescription.rootNodeName;
    this.touchPointNodeName = componentDescription.touchPointNodeName;
    // Build all the visual responses for this component
    this.visualResponses = {};
    Object.keys(componentDescription.visualResponses).forEach(responseName => {
      const visualResponse = new VisualResponse(componentDescription.visualResponses[responseName]);
      this.visualResponses[responseName] = visualResponse;
    });
    // Set default values
    this.gamepadIndices = Object.assign({}, componentDescription.gamepadIndices);
    this.values = {
      state: Constants.ComponentState.DEFAULT,
      button: this.gamepadIndices.button !== undefined ? 0 : undefined,
      xAxis: this.gamepadIndices.xAxis !== undefined ? 0 : undefined,
      yAxis: this.gamepadIndices.yAxis !== undefined ? 0 : undefined
    };
  }
  get data() {
    const data = _objectSpread2({
      id: this.id
    }, this.values);
    return data;
  }

  /**
   * @description Poll for updated data based on current gamepad state
   * @param {Object} gamepad - The gamepad object from which the component data should be polled
   */
  updateFromGamepad(gamepad) {
    // Set the state to default before processing other data sources
    this.values.state = Constants.ComponentState.DEFAULT;
    // Get and normalize button
    if (this.gamepadIndices.button !== undefined && gamepad.buttons.length > this.gamepadIndices.button) {
      const gamepadButton = gamepad.buttons[this.gamepadIndices.button];
      this.values.button = gamepadButton.value;
      this.values.button = this.values.button < 0 ? 0 : this.values.button;
      this.values.button = this.values.button > 1 ? 1 : this.values.button;
      // Set the state based on the button
      if (gamepadButton.pressed || this.values.button === 1) {
        this.values.state = Constants.ComponentState.PRESSED;
      } else if (gamepadButton.touched || this.values.button > Constants.ButtonTouchThreshold) {
        this.values.state = Constants.ComponentState.TOUCHED;
      }
    }
    // Get and normalize x axis value
    if (this.gamepadIndices.xAxis !== undefined && gamepad.axes.length > this.gamepadIndices.xAxis) {
      this.values.xAxis = gamepad.axes[this.gamepadIndices.xAxis];
      this.values.xAxis = this.values.xAxis < -1 ? -1 : this.values.xAxis;
      this.values.xAxis = this.values.xAxis > 1 ? 1 : this.values.xAxis;
      // If the state is still default, check if the xAxis makes it touched
      if (this.values.state === Constants.ComponentState.DEFAULT && Math.abs(this.values.xAxis) > Constants.AxisTouchThreshold) {
        this.values.state = Constants.ComponentState.TOUCHED;
      }
    }

    // Get and normalize Y axis value
    if (this.gamepadIndices.yAxis !== undefined && gamepad.axes.length > this.gamepadIndices.yAxis) {
      this.values.yAxis = gamepad.axes[this.gamepadIndices.yAxis];
      this.values.yAxis = this.values.yAxis < -1 ? -1 : this.values.yAxis;
      this.values.yAxis = this.values.yAxis > 1 ? 1 : this.values.yAxis;

      // If the state is still default, check if the yAxis makes it touched
      if (this.values.state === Constants.ComponentState.DEFAULT && Math.abs(this.values.yAxis) > Constants.AxisTouchThreshold) {
        this.values.state = Constants.ComponentState.TOUCHED;
      }
    }
    // Update the visual response weights based on the current component data
    Object.values(this.visualResponses).forEach(visualResponse => {
      visualResponse.updateFromComponent(this.values);
    });
  }
}

/**
  * @description Builds a motion controller with components and visual responses based on the
  * supplied profile description. Data is polled from the xrInputSource's gamepad.
  * @author Nell Waliczek / https://github.com/NellWaliczek
*/
class MotionController {
  /**
   * @param {Object} xrInputSource - The XRInputSource to build the MotionController around
   * @param {Object} profile - The best matched profile description for the supplied xrInputSource
   * @param {Object} assetUrl
   */
  constructor(xrInputSource, profile, assetUrl) {
    if (!xrInputSource) {
      throw new Error('No xrInputSource supplied');
    }
    if (!profile) {
      throw new Error('No profile supplied');
    }
    this.xrInputSource = xrInputSource;
    this.assetUrl = assetUrl;
    this.id = profile.profileId;
    // Build child components as described in the profile description
    this.layoutDescription = profile.layouts[xrInputSource.handedness];
    this.components = {};
    Object.keys(this.layoutDescription.components).forEach(componentId => {
      const componentDescription = this.layoutDescription.components[componentId];
      this.components[componentId] = new Component(componentId, componentDescription);
    });
    // Initialize components based on current gamepad state
    this.updateFromGamepad();
  }
  get gripSpace() {
    return this.xrInputSource.gripSpace;
  }
  get targetRaySpace() {
    return this.xrInputSource.targetRaySpace;
  }

  /**
   * @description Returns a subset of component data for simplified debugging
   */
  get data() {
    const data = [];
    Object.values(this.components).forEach(component => {
      data.push(component.data);
    });
    return data;
  }

  /**
   * @description Poll for updated data based on current gamepad state
   */
  updateFromGamepad() {
    Object.values(this.components).forEach(component => {
      component.updateFromGamepad(this.xrInputSource.gamepad);
    });
  }
}const DEFAULT_PROFILES_PATH = 'https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0/dist/profiles';
const DEFAULT_PROFILE = 'generic-trigger';
class XRControllerModel extends THREE.Object3D {
  constructor() {
    super();
    this.motionController = null;
    this.envMap = null;
  }
  setEnvironmentMap(envMap) {
    if (this.envMap == envMap) {
      return this;
    }
    this.envMap = envMap;
    this.traverse(child => {
      if (child.isMesh) {
        child.material.envMap = this.envMap;
        child.material.needsUpdate = true;
      }
    });
    return this;
  }

  /**
   * Polls data from the XRInputSource and updates the model's components to match
   * the real world data
   */
  updateMatrixWorld(force) {
    super.updateMatrixWorld(force);
    if (!this.motionController) {
      return;
    }
    // Cause the MotionController to poll the Gamepad for data
    this.motionController.updateFromGamepad();
    // Update the 3D model to reflect the button, thumbstick, and touchpad state
    Object.values(this.motionController.components).forEach(component => {
      // Update node data based on the visual responses' current states
      Object.values(component.visualResponses).forEach(visualResponse => {
        const {
          valueNode,
          minNode,
          maxNode,
          value,
          valueNodeProperty
        } = visualResponse;
        // Skip if the visual response node is not found. No error is needed,
        // because it will have been reported at load time.
        if (!valueNode) {
          return;
        }
        // Calculate the new properties based on the weight supplied
        if (valueNodeProperty === Constants.VisualResponseProperty.VISIBILITY) {
          valueNode.visible = value;
        } else if (valueNodeProperty === Constants.VisualResponseProperty.TRANSFORM) {
          valueNode.quaternion.slerpQuaternions(minNode.quaternion, maxNode.quaternion, value);
          valueNode.position.lerpVectors(minNode.position, maxNode.position, value);
        }
      });
    });
  }
}

/**
 * Walks the model's tree to find the nodes needed to animate the components and
 * saves them to the motionContoller components for use in the frame loop. When
 * touchpads are found, attaches a touch dot to them.
 */
function findNodes(motionController, scene) {
  // Loop through the components and find the nodes needed for each components' visual responses
  Object.values(motionController.components).forEach(component => {
    const {
      type,
      touchPointNodeName,
      visualResponses
    } = component;
    if (type === Constants.ComponentType.TOUCHPAD) {
      component.touchPointNode = scene.getObjectByName(touchPointNodeName);
      if (component.touchPointNode) {
        // Attach a touch dot to the touchpad.
        const sphereGeometry = new THREE.SphereGeometry(0.001);
        const material = new THREE.MeshBasicMaterial({
          color: 0x0000FF
        });
        const sphere = new THREE.Mesh(sphereGeometry, material);
        component.touchPointNode.add(sphere);
      } else {
        console.warn(`Could not find touch dot, ${component.touchPointNodeName}, in touchpad component ${component.id}`);
      }
    }
    // Loop through all the visual responses to be applied to this component
    Object.values(visualResponses).forEach(visualResponse => {
      const {
        valueNodeName,
        minNodeName,
        maxNodeName,
        valueNodeProperty
      } = visualResponse;
      // If animating a transform, find the two nodes to be interpolated between.
      if (valueNodeProperty === Constants.VisualResponseProperty.TRANSFORM) {
        visualResponse.minNode = scene.getObjectByName(minNodeName);
        visualResponse.maxNode = scene.getObjectByName(maxNodeName);
        // If the extents cannot be found, skip this animation
        if (!visualResponse.minNode) {
          console.warn(`Could not find ${minNodeName} in the model`);
          return;
        }
        if (!visualResponse.maxNode) {
          console.warn(`Could not find ${maxNodeName} in the model`);
          return;
        }
      }
      // If the target node cannot be found, skip this animation
      visualResponse.valueNode = scene.getObjectByName(valueNodeName);
      if (!visualResponse.valueNode) {
        console.warn(`Could not find ${valueNodeName} in the model`);
      }
    });
  });
}
function addAssetSceneToControllerModel(controllerModel, scene) {
  // Find the nodes needed for animation and cache them on the motionController.
  findNodes(controllerModel.motionController, scene);
  // Apply any environment map that the mesh already has set.
  if (controllerModel.envMap) {
    scene.traverse(child => {
      if (child.isMesh) {
        child.material.envMap = controllerModel.envMap;
        child.material.needsUpdate = true;
      }
    });
  }
  // Add the glTF scene to the controllerModel.
  controllerModel.add(scene);
}
class XRControllerModelFactory {
  constructor(gltfLoader) {
    if (gltfLoader === void 0) {
      gltfLoader = null;
    }
    this.gltfLoader = gltfLoader;
    this.path = DEFAULT_PROFILES_PATH;
    this._assetCache = {};
    // If a GLTFLoader wasn't supplied to the constructor create a new one.
    if (!this.gltfLoader) {
      this.gltfLoader = new GLTFLoader();
    }
  }
  createControllerModel(controller) {
    const controllerModel = new XRControllerModel();
    let scene = null;
    controller.addEventListener('connected', event => {
      const xrInputSource = event.data;
      if (xrInputSource.targetRayMode !== 'tracked-pointer' || !xrInputSource.gamepad) {
        return;
      }
      fetchProfile(xrInputSource, this.path, DEFAULT_PROFILE).then(_ref => {
        let {
          profile,
          assetPath
        } = _ref;
        controllerModel.motionController = new MotionController(xrInputSource, profile, assetPath);
        const cachedAsset = this._assetCache[controllerModel.motionController.assetUrl];
        if (cachedAsset) {
          scene = cachedAsset.scene.clone();
          addAssetSceneToControllerModel(controllerModel, scene);
        } else {
          if (!this.gltfLoader) {
            throw new Error('GLTFLoader not set.');
          }
          this.gltfLoader.setPath('');
          this.gltfLoader.load(controllerModel.motionController.assetUrl, asset => {
            this._assetCache[controllerModel.motionController.assetUrl] = asset;
            scene = asset.scene.clone();
            addAssetSceneToControllerModel(controllerModel, scene);
          }, null, () => {
            throw new Error(`Asset ${controllerModel.motionController.assetUrl} missing or malformed.`);
          });
        }
      }).catch(err => {
        console.warn(err);
      });
    });
    controller.addEventListener('disconnected', () => {
      controllerModel.motionController = null;
      controllerModel.remove(scene);
      scene = null;
    });
    return controllerModel;
  }
}const ZERO = new THREE.Vector3();
const DOWN = new THREE.Vector3(0, -1, 0);
const CONTROL_INFO = {
  type: MessageType.ControlInfo,
  orientation: {
    latitude: 0,
    longitude: 0
  },
  zoom: 1,
  cameraGroup: {
    position: [0, 0, 0],
    rotation: [0, 0, 0]
  },
  pointer: [0, 0, 0]
};
class WorldComponent extends rxcomp.Component {
  get error() {
    return this.error_;
  }
  set error(error) {
    if (this.error_ !== error) {
      this.error_ = error;
      this.pushChanges();
    }
  }
  get view() {
    return this.view_;
  }
  set view(view) {
    if (this.view_ !== view) {
      this.view_ = view;
      this.setView();
    }
  }
  get debugging() {
    // return STATIC || DEBUG;
    return DEBUG;
  }
  get controlled() {
    return StateService.state.controlling && StateService.state.controlling !== StateService.state.uid;
  }
  get controlling() {
    return StateService.state.controlling && StateService.state.controlling === StateService.state.uid;
  }
  get silencing() {
    return StateService.state.silencing;
  }
  get silenced() {
    return StateService.state.silencing && StateService.state.role === RoleType.Streamer;
  }
  get spyed() {
    return StateService.state.spying && StateService.state.spying === StateService.state.uid;
  }
  get spying() {
    return StateService.state.spying && StateService.state.spying !== StateService.state.uid;
  }
  get locked() {
    return this.controlled || this.spying;
  }
  get lockedOrXR() {
    return this.locked || this.renderer.xr.isPresenting;
  }
  get showMenu() {
    return StateService.state.hosted && StateService.state.navigable && (StateService.state.mode !== 'embed' || environment.flags.menuEmbed);
  }
  get showPointer() {
    return this.pointer.mesh.parent != null;
  }
  set showPointer(showPointer) {
    if (this.showPointer !== showPointer) {
      showPointer ? this.scene.add(this.pointer.mesh) : this.scene.remove(this.pointer.mesh);
      // Logger.log('WorldComponent.showPointer', showPointer);
    }
  }

  set menu(menu) {
    if (this.menu_ !== menu) {
      this.menu_ = menu;
      this.scene.traverse(object => {
        if (object instanceof MediaMesh || object instanceof MediaPlayMesh) {
          object.freezed = menu != null;
        }
      });
    }
  }
  get menu() {
    return this.menu_;
  }
  onInit() {
    // Logger.log('WorldComponent.onInit');
    Host.host = this;
    this.defaultTexture = Texture.gridTexture;
    this.index = 0;
    this.error_ = null;
    this.loading = null;
    this.waiting = null;
    this.avatars = {};
    this.createScene();
    // this.setView();
    this.addListeners();
    this.animate(); // !!!
    KeyboardService.keys$().pipe(operators.takeUntil(this.unsubscribe$)).subscribe(keys => {
      this.keys = keys;
      // console.log(keys);
    });

    LanguageService.lang$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(_ => {
      this.setView();
    });
  }

  /*
  onChanges() {
  	if (this.view) {
  		const selected = this.view.items.find(item => item.selected);
  		if (selected && selected.mesh) {
  			if (this.view.type.name !== 'model') {
  				this.orbitService.lookAt(selected.mesh);
  			}
  		}
  	}
  }
  */

  onDestroy() {
    this.removeListeners();
    const renderer = this.renderer;
    renderer.setAnimationLoop(() => {});
  }
  createScene() {
    const {
      node
    } = rxcomp.getContext(this);
    this.size = {
      left: 0,
      top: 0,
      width: 0,
      height: 0,
      aspect: 0
    };
    this.mouse = new THREE.Vector2();
    this.controllerMatrix_ = new THREE.Matrix4();
    this.controllerWorldPosition_ = new THREE.Vector3();
    this.controllerWorldDirection_ = new THREE.Vector3();
    const container = this.container = node;
    this.info = node.querySelector('.world__info');
    this.worldRect = Rect.fromNode(container);
    this.cameraRect = new Rect();
    const cameraGroup = this.cameraGroup = new THREE.Group();
    // new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, ROOM_RADIUS * 2);
    // const camera = this.camera = new THREE.PerspectiveCamera(70, container.offsetWidth / container.offsetHeight, 0.01, 1000);
    const camera = this.camera = new THREE.PerspectiveCamera(70, container.offsetWidth / container.offsetHeight, 0.01, 1000);
    camera.target = new THREE.Vector3();
    cameraGroup.add(camera);
    // cameraGroup.target = new THREE.Vector3();

    this.orbitService = new OrbitService(camera);
    const renderer = this.renderer = new THREE.WebGLRenderer({
      antialias: environment.flags.antialias || false,
      alpha: environment.flags.alpha || false,
      premultipliedAlpha: environment.flags.premultipliedAlpha || false,
      logarithmicDepthBuffer: true,
      // physicallyCorrectLights: true,
      powerPreference: 'high-performance'
    });
    renderer.setClearColor(0x000000, 1);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(container.offsetWidth, container.offsetHeight);
    renderer.xr.enabled = true;
    renderer.outputEncoding = THREE.LinearEncoding;
    // renderer.toneMapping = THREE.NoToneMapping;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = environment.toneMappingExposure || 1; // 2;

    if (container.childElementCount > 0) {
      container.insertBefore(renderer.domElement, container.children[0]);
    } else {
      container.appendChild(renderer.domElement);
    }
    const raycaster = this.raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(this.mouse, camera);
    const scene = this.scene = new THREE.Scene();
    scene.add(cameraGroup);
    if (environment.flags.useTextureEnvironment) {
      this.addEnvironment();
    }
    const objects = this.objects = new THREE.Group();
    objects.name = '[objects]';
    scene.add(objects);
    const panorama = this.panorama = new Panorama(renderer);
    this.panoramaIntersectObjects = [panorama.mesh];
    this.intersectObjects = this.panoramaIntersectObjects;
    objects.add(panorama.mesh);
    this.indicator = new PointerElement();
    this.pointer = new PointerElement('#ff4332');
    const light1 = new THREE.PointLight(0xffffff, 0.8);
    light1.position.set(-50, 0, 0);
    objects.add(light1);
    const light2 = new THREE.PointLight(0xffffff, 0.3);
    light2.position.set(50, 0, 0);
    objects.add(light2);
    const light3 = new THREE.PointLight(0xffffff, 0.5);
    light3.position.set(0, 50, 0);
    objects.add(light3);
    const light4 = new THREE.PointLight(0xffffff, 0.1);
    light4.position.set(0, -50, 0);
    objects.add(light4);
    const ambient = this.ambient = new THREE.AmbientLight(0xffffff, 0.25);
    objects.add(ambient);

    /*
    const direct = this.direct = new THREE.DirectionalLight(0xffffff, 1);
    direct.position.set(-40, -40, -40);
    direct.target.position.set(0, 0, 0);
    objects.add(direct);
    */

    this.addControllers();
    this.resize();

    // show hide items
    LoaderService.progress$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(progress => {
      const complete = progress.count === 0;
      const view = this.view_;
      // this.panorama.mesh.visible = complete;
      if (view.items) {
        view.items.forEach(item => {
          item.visible = complete;
        });
      }
      // console.log(view, complete, progress);
    });

    // Logger.log('WorldComponent.createScene', this);
  }

  toggleLights(enabled) {
    if (this.ambient) {
      this.ambient.visible = enabled;
    }
    if (this.direct) {
      this.direct.visible = enabled;
    }
  }
  addEnvironment() {
    const segments = environment.textures.envMap.split('/');
    const filename = segments.pop();
    const folder = segments.join('/') + '/';
    const isHdr = filename.indexOf('.hdr') !== -1;
    // const loader = isHdr ? new RGBELoader().setDataType(THREE.UnsignedByteType) : new THREE.TextureLoader();
    let loader;
    if (isHdr) {
      loader = new RGBELoader();
      loader.setDataType(THREE.HalfFloatType);
    } else {
      loader = new THREE.TextureLoader();
    }
    loader.setPath(environment.getPath(folder)).load(filename, texture => {
      if (isHdr && texture) {
        texture.mapping = THREE.EquirectangularReflectionMapping;
        this.scene.background = texture;
        this.scene.environment = texture;
      } else {
        this.setBackground(texture);
      }
    });
  }
  addOffCanvasScene(message) {
    const avatar = new AvatarElement(message);
    this.avatars[message.clientId] = avatar;
    // avatar.container.appendChild(avatar.element);
  }

  removeOffCanvasScene(message) {
    this.avatars[message.clientId];
    /*
    if (avatar && avatar.element.parentNode) {
    	avatar.element.parentNode.removeChild(avatar.element);
    }
    */
    delete this.avatars[message.clientId];
  }
  updateOffCanvasScene(message) {
    const avatar = this.avatars[message.clientId];
    if (avatar) {
      avatar.update(message);
    }
  }
  setBackground(texture) {
    let background = texture || this.defaultTexture;
    background.mapping = THREE.EquirectangularReflectionMapping;
    // background.encoding = THREE.LinearEncoding;
    background.encoding = THREE.sRGBEncoding;
    // background.encoding = THREE.GammaEncoding;
    // background.encoding = THREE.RGBEEncoding;
    // background.encoding = THREE.LogLuvEncoding;
    // background.encoding = THREE.RGBM7Encoding;
    // background.encoding = THREE.RGBM16Encoding;
    // background.encoding = THREE.RGBDEncoding;
    // background.encoding = THREE.BasicDepthPacking;
    // background.encoding = THREE.RGBADepthPacking;
    // this.scene.background = background;
    this.scene.environment = background;
  }
  setView() {
    if (!this.renderer) {
      return;
    }
    if (!this.panorama) {
      return;
    }
    const view = this.view_;
    if (view) {
      if (StateService.state.zoomedId != null) {
        StateService.patchState({
          zoomedId: null
        });
      }
      if (this.views) {
        this.views.forEach(view => delete view.onUpdateAsset);
      }
      const message = this.requestInfoResult;
      if (message) {
        if (view instanceof PanoramaGridView && message.gridIndex !== undefined) {
          view.index_ = message.gridIndex;
        }
      }
      view.ready = false;
      this.cameraGroup.position.set(0, 0, 0);
      this.cameraGroup.rotation.set(0, 0, 0);
      if (view.type.name === ViewType.Room3d.name) {
        this.renderer.setClearColor(0x000000, 1);
        this.objects.remove(this.panorama.mesh);
        this.toggleLights(false);
      } else {
        this.renderer.setClearColor(0x000000, 1);
        this.objects.add(this.panorama.mesh);
        this.toggleLights(true);
      }
      // this.waiting = null;
      this.pushChanges();
      PrefetchService.cancel();
      this.panorama.change(view, this.renderer, texture => {
        // Logger.log('WorldComponent.panorama.change', texture);
        if (!environment.flags.useTextureEnvironment) {
          this.setBackground(texture);
        }
        view.ready = true;
        view.onUpdateAsset = () => {
          this.onViewAssetDidChange();
        };
        const context = rxcomp.getContext(this);
        // Logger.log('WorldCompoent.setView.context', context);
        if (context) {
          this.pushChanges();
        }
      }, view => {
        this.setViewOrientation(view);
        PrefetchService.prefetch(view.prefetchAssets);
        // this.loading = null;
        // this.pushChanges();
      });
    }
  }

  onViewAssetDidChange() {
    if (this.panorama) {
      this.panorama.crossfade(this.view, this.renderer, texture => {
        if (!environment.flags.useTextureEnvironment) {
          this.setBackground(texture);
        }
      });
    }
  }
  setViewOrientation(view) {
    const message = this.requestInfoResult;
    this.requestInfoResult = null;
    if (this.orbitService) {
      this.orbitService.mode = view.type.name;
      if (!this.renderer.xr.isPresenting) {
        let orientation;
        if (message) {
          orientation = message.orientation;
          this.orbitService.setOrientation(orientation);
          this.orbitService.zoom = message.zoom;
          this.camera.updateProjectionMatrix();
        } else if (!view.keepOrientation) {
          // Logger.log('WorldComponent.setViewOrientation', view.useLastOrientation, view.lastOrientation);
          orientation = view.useLastOrientation ? view.lastOrientation : view.orientation;
          this.orbitService.setOrientation(orientation);
          this.orbitService.zoom = view.zoom;
          this.camera.updateProjectionMatrix();
        }
      }
    }
  }
  addControllers() {
    const controllerGroup = this.controllerGroup = new THREE.Group();
    this.teleport = new TeleportElement();
    this.controllers = [];
    this.controllerModelFactory = new XRControllerModelFactory();
    this.addController(0);
    this.addController(1);
    this.cameraGroup.add(controllerGroup);
  }
  addController(index) {
    const showPhone = StateService.state.live;
    const renderer = this.renderer;
    const controllerGroup = this.controllerGroup;
    const controller = renderer.xr.getController(index);
    const controllerModelFactory = this.controllerModelFactory;
    const teleport = this.teleport;
    const scene = this.scene;
    const camera = this.camera;
    const cameraGroup = this.cameraGroup;
    controller.name = `[controller${index + 1}]`;
    controllerGroup.add(controller);
    const setController = controller => {
      // Logger.log('WorldComponent.setController', this);
      this.controller = controller;
    };
    const onSelectStart = event => {
      controller.userData.isSelecting = true;
      setController(controller);
    };
    const onSelectEnd = event => {
      controller.userData.isSelecting = false;
    };
    const onSqueezeStart = event => {
      if (this.view && this.view.type.name === ViewType.Room3d.name) {
        teleport.addToController(controller, scene);
        // this.scene.remove(this.indicator.mesh);
        this.indicator.mesh.visible = false;
        controller.children[0].visible = false;
      }
    };
    const onSqueezeEnd = event => {
      // if (this.view && this.view.type.name === ViewType.Room3d.name) {
      teleport.removeFromController(controller, scene, renderer, camera, cameraGroup);
      // this.scene.add(this.indicator.mesh);
      this.indicator.mesh.visible = true;
      controller.children[0].visible = true;
      // }
    };
    // const debugService = DebugService.getService();
    // debugService.setMessage('DebugService 1001');
    const onPress = event => {
      // Logger.log('WorldComponent.Gamepad.onPress', event, controller);
      // debugService.setMessage('Gamepad.onPress ' + event.index);
      // 0: select
      // 1: squeeze
      // 4: x / a
      // 5: y / b
      switch (event.index) {
        case 0:
          // select
          break;
        case 1:
          // squeeze
          break;
        case 4:
          // x / a
          MessageService.send({
            type: MessageType.MenuToggle
          });
          break;
      }
    };
    const onRelease = event => {
      this.onModelUp();
    };
    const onLeft = event => {
      // Logger.log('WorldComponent.Gamepad.onLeft', event, controller);
      // debugService.setMessage('Gamepad.onLeft');
      this.cameraGroup.rotation.y += Math.PI / 180 * 45;
    };
    const onRight = event => {
      // Logger.log('WorldComponent.Gamepad.onRight', event, controller);
      // debugService.setMessage('Gamepad.onRight');
      this.cameraGroup.rotation.y -= Math.PI / 180 * 45;
    };
    /*
    const onAxis = (event) => {
    	// Logger.log('WorldComponent.Gamepad.onAxis', event, controller);
    	// debugService.setMessage('Gamepad.onAxis');
    	this.cameraGroup.rotation.y += (Math.PI / 180 * event.x);
    };
    */
    const onAxis = event => {
      // Logger.log('WorldComponent.Gamepad.onAxis', event, controller);
      // debugService.setMessage('Gamepad.onAxis');
      this.onModelDistance(event.y);
    };
    /*
    const onUp = (event) => {
    	// Logger.log('WorldComponent.Gamepad.onUp', event, controller);
    	// debugService.setMessage('Gamepad.onUp');
    	this.cameraGroup.position.y += 1;
    };
    const onDown = (event) => {
    	// Logger.log('WorldComponent.Gamepad.onDown', event, controller);
    	// debugService.setMessage('Gamepad.onDown');
    	this.cameraGroup.position.y -= 1;
    };
    */
    /*
    const onUp = (event) => {
    	this.onModelDistance(1);
    };
    const onDown = (event) => {
    	this.onModelDistance(-1);
    };
    */
    const onConnected = event => {
      controller.add(this.buildController(event.data));
      if (showPhone && event.data.handedness === 'left') {
        const phone = this.phone = new PhoneElement();
        controller.add(phone.mesh);
      }
      if (!showPhone || event.data.handedness === 'right') {
        const controllerGrip = renderer.xr.getControllerGrip(index);
        controllerGrip.name = `[controller-grip${index + 1}]`;
        const controllerModel = controllerModelFactory.createControllerModel(controllerGrip);
        controller.userData.model = controllerModel;
        controllerGrip.add(controllerModel);
        controllerGroup.add(controllerGrip);
      }
      const gamepad = new Gamepad(event.data.gamepad);
      gamepad.on('press', onPress);
      gamepad.on('release', onRelease);
      gamepad.on('left', onLeft);
      gamepad.on('right', onRight);
      gamepad.on('axis', onAxis);
      // gamepad.on('up', onUp);
      // gamepad.on('down', onDown);
      controller.userData.gamepad = gamepad;
      controller.userData.update = () => {
        gamepad.update();
      };
    };
    const onDisconnected = event => {
      while (controller.children.length) {
        controller.remove(controller.children[0]);
      }
      const controllerGrip = renderer.xr.getControllerGrip(index);
      while (controllerGrip.children.length) {
        controllerGrip.remove(controllerGrip.children[0]);
      }
      controllerGroup.remove(controllerGrip);
      controller.userData.update = () => {};
      const gamepad = controller.userData.gamepad;
      if (gamepad) {
        gamepad.off('press', onPress);
        gamepad.off('release', onRelease);
        gamepad.off('left', onLeft);
        gamepad.off('right', onRight);
        gamepad.off('axis', onAxis);
        // gamepad.off('up', onUp);
        // gamepad.off('down', onDown);
        delete controller.userData.gamepad;
      }
      teleport.removeFromController(controller, scene, renderer, camera, cameraGroup);
    };
    controller.userData.update = () => {};
    controller.addEventListener('selectstart', onSelectStart);
    controller.addEventListener('selectend', onSelectEnd);
    controller.addEventListener('connected', onConnected);
    controller.addEventListener('disconnected', onDisconnected);
    controller.addEventListener('squeezestart', onSqueezeStart);
    controller.addEventListener('squeezeend', onSqueezeEnd);
    const controllers = this.controllers;
    controllers.push(controller);
  }
  buildController(data) {
    // Logger.log('WorldComponent.buildController', data);
    let geometry, material;
    switch (data.targetRayMode) {
      case 'tracked-pointer':
        geometry = new THREE.BufferGeometry();
        geometry.setAttribute('position', new THREE.Float32BufferAttribute([0, 0, 0, 0, 0, -1], 3));
        geometry.setAttribute('color', new THREE.Float32BufferAttribute([0.5, 0.5, 0.5, 0, 0, 0], 3));
        material = new THREE.LineBasicMaterial({
          vertexColors: true,
          blending: THREE.AdditiveBlending
        });
        return new THREE.Line(geometry, material);
      case 'gaze':
        geometry = new THREE.RingBufferGeometry(0.02, 0.04, 32).translate(0, 0, -1);
        material = new THREE.MeshBasicMaterial({
          opacity: 0.5,
          transparent: true
        });
        return new THREE.Mesh(geometry, material);
    }
  }
  updateRaycasterXR(controller, raycaster) {
    if (controller) {
      this.controllerMatrix_.identity().extractRotation(controller.matrixWorld);
      raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
      raycaster.ray.direction.set(0, 0, -1).applyMatrix4(this.controllerMatrix_);
      // raycaster.camera = this.host.renderer.xr.getCamera(this.camera);
      return raycaster;
    }
  }
  repos(object, rect) {
    const worldRect = this.worldRect;
    const sx = 0.8;
    // const sx = rect.width / worldRect.width;
    // const sy = rect.height / worldRect.height;
    object.scale.set(sx, sx, sx);
    // const tx = ((rect.x + rect.width / 2) - worldRect.width / 2) / worldRect.width * 2.0 * this.camera.aspect; // * cameraRect.width / worldRect.width - cameraRect.width / 2;
    // const ty = ((rect.y + rect.height / 2) - worldRect.height / 2) / worldRect.height * 2.0 * this.camera.aspect; // * cameraRect.height / worldRect.height - cameraRect.height / 2;
    const tx = (rect.x + rect.width / 2 - worldRect.width / 2) / worldRect.width * 2.0 * this.camera.aspect;
    const ty = (rect.y + rect.height / 2 - worldRect.height / 2) / worldRect.height * 2.0 * this.camera.aspect;
    // console.log(tx);
    // const position = new THREE.Vector3(tx, ty, 0).unproject(this.camera);
    object.position.set(tx, -ty, 0);
    // console.log(tx, -ty, 0);
  }

  render(delta) {
    try {
      const renderer = this.renderer,
        scene = this.scene,
        camera = this.camera,
        avatars = this.avatars;
      const isPresenting = renderer.xr.isPresenting;
      if (!isPresenting && StateService.state.mode === UIMode.LiveMeeting) {
        // !!! || (StateService.state.remoteScreen !== null)
        return;
      }
      if (isPresenting) {
        gsap.ticker.tick();
        this.controllers.forEach(controller => controller.userData.update());
        this.teleport.update();
      } else {
        this.navWithKeys();
      }
      this.orbitService.render();
      const time = performance.now();
      const tick = this.tick_ ? ++this.tick_ : this.tick_ = 1;
      scene.traverse(child => {
        const render = child.userData.render;
        if (typeof render === 'function') {
          render(time, tick, renderer, scene, camera);
        }
      });
      Object.keys(avatars).forEach(key => {
        avatars[key].render();
      });
      this.vrService.updateState(this);
      this.raycasterXRHitTest();
      renderer.render(scene, camera);
    } catch (error) {
      this.error = error;
      // throw (error);
    }
  }

  navWithKeys() {
    if (this.view && this.view.type.name === ViewType.Room3d.name && this.view.mesh && !this.locked && !ModalService.hasModal) {
      this.intersectObjects = this.view.intersectObjects;
      const velocity = this.velocity || (this.velocity = new THREE.Vector3());
      const direction = this.direction || (this.direction = new THREE.Vector3());
      const camera = this.camera;
      const speed = 0.1;
      if (this.keys.w || this.keys.ArrowUp) {
        camera.getWorldDirection(direction);
        direction.multiplyScalar(speed);
        velocity.copy(direction);
      } else if (this.keys.s || this.keys.ArrowDown) {
        camera.getWorldDirection(direction);
        direction.multiplyScalar(-speed);
        velocity.copy(direction);
      } else if (this.keys.d || this.keys.ArrowRight) {
        camera.getWorldDirection(direction);
        direction.multiplyScalar(speed);
        const axisY = this.axisY || (this.direction = new THREE.Vector3(0, 1, 0));
        const angle = -Math.PI / 2;
        direction.applyAxisAngle(axisY, angle);
        velocity.copy(direction);
      } else if (this.keys.a || this.keys.ArrowLeft) {
        camera.getWorldDirection(direction);
        direction.multiplyScalar(-speed);
        const axisY = this.axisY || (this.direction = new THREE.Vector3(0, 1, 0));
        const angle = -Math.PI / 2;
        direction.applyAxisAngle(axisY, angle);
        velocity.copy(direction);
      }
      const manhattanLength = velocity.manhattanLength();
      if (manhattanLength > 0.00001) {
        // console.log(velocity.x, velocity.y, velocity.z);
        direction.copy(this.cameraGroup.position);
        direction.add(velocity);
        direction.y = 0;
        const raycaster = this.raycaster;
        raycaster.set(direction, DOWN);
        const intersects = raycaster.intersectObjects(this.view.navIntersectObjects);
        if (intersects.length) {
          // console.log(manhattanLength, intersects);
          this.cameraGroup.position.add(velocity);
          this.cameraGroup.position.y = 0;
          this.orbitService.markAsDirty();
          // this.orbitService.events$.next(OrbitService.orbitMoveEvent);
          // camera.updateProjectionMatrix();
        }

        velocity.lerp(ZERO, 0.1);
      } else {
        velocity.set(0, 0, 0);
      }
    } else {
      this.intersectObjects = this.panoramaIntersectObjects;
    }
  }
  animate() {
    const renderer = this.renderer;
    renderer.setAnimationLoop(this.render);
  }
  resize() {
    try {
      const container = this.container,
        renderer = this.renderer,
        camera = this.camera;
      const size = this.size;
      const rect = container.getBoundingClientRect();
      size.left = Math.floor(rect.left);
      size.top = Math.floor(rect.top);
      size.width = Math.ceil(rect.width);
      size.height = Math.ceil(rect.height);
      size.aspect = size.width / size.height;
      const worldRect = this.worldRect;
      worldRect.setSize(size.width, size.height);
      if (!renderer.xr.isPresenting) {
        renderer.setSize(size.width, size.height);
        if (camera) {
          camera.aspect = size.width / size.height;
          const angle = camera.fov * Math.PI / 180;
          const height = Math.abs(camera.position.z * Math.tan(angle / 2) * 2);
          const cameraRect = this.cameraRect;
          cameraRect.width = height * camera.aspect;
          cameraRect.height = height;
          // Logger.log('WorldComponent.position', camera.position.z, 'angle', angle, 'height', height, 'aspect', camera.aspect, cameraRect);
          camera.updateProjectionMatrix();
        }
      }
      // this.render();
    } catch (error) {
      this.error = error;
      // throw (error);
    }
  }

  updateRaycasterMouse(event) {
    const w2 = this.size.width / 2;
    const h2 = this.size.height / 2;
    this.mouse.x = (event.clientX - this.size.left - w2) / w2;
    this.mouse.y = -(event.clientY - this.size.top - h2) / h2;
    const raycaster = this.raycaster;
    raycaster.setFromCamera(this.mouse, this.camera);
    return raycaster;
  }
  raycasterXRHitTest() {
    if (this.renderer.xr.isPresenting && !this.locked) {
      const raycaster = this.updateRaycasterXR(this.controller, this.raycaster);
      if (raycaster) {
        Interactive.hittest(raycaster, this.controller.userData.isSelecting);
        this.indicator.update(this.renderer.xr.getCamera(this.camera));
        /*
        if (hit && hit !== this.panorama.mesh) {
        	// controllers.feedback();
        }
        */
      }
    }
  }

  raycasterDesktopHitTest(event) {
    const raycaster = this.updateRaycasterMouse(event);
    if (this.lockedOrXR) {
      return;
    }
    if (this.dragItem) {
      if (typeof this.dragItem.onDragMove === 'function') {
        const intersections = raycaster.intersectObjects(this.intersectObjects);
        if (intersections.length) {
          const intersection = intersections[0];
          // this.panorama.mesh.intersection = intersection;
          const intersectionPoint = this.intersectionPoint || (this.intersectionPoint = new THREE.Vector3());
          const intersectionNormal = this.intersectionNormal || (this.intersectionNormal = new THREE.Vector3());
          const position = intersectionPoint.copy(intersection.point);
          const normal = intersectionNormal.copy(intersection.face.normal);
          this.dragItem.onDragMove(position, normal, this.intersectObjects === this.panoramaIntersectObjects);
        }
      }
    } else if (this.resizeItem) ; else {
      Interactive.hittest(raycaster);
      this.controlEvent$.next(CONTROL_INFO);
    }
  }
  onMouseDown(event) {
    try {
      if (this.locked) {
        return;
      }
      if (event.button !== 0) {
        return;
      }
      const raycaster = this.updateRaycasterMouse(event);
      const hit = Interactive.hittest(raycaster, true);
      if (this.editor || DEBUG) {
        if (!(this.keys.Shift || this.keys.Control)) {
          this.select.next({
            item: null
          });
          const intersections = raycaster.intersectObjects(this.intersectObjects);
          if (intersections.length) {
            const intersection = intersections[0];
            const intersectionPoint = this.intersectionPoint || (this.intersectionPoint = new THREE.Vector3());
            const intersectionNormal = this.intersectionNormal || (this.intersectionNormal = new THREE.Vector3());
            const position = intersectionPoint.copy(intersection.point);
            const normal = intersectionNormal.copy(intersection.face.normal);
            this.viewHit.next({
              position,
              normal,
              spherical: this.intersectObjects === this.panoramaIntersectObjects
            });
          }
          /*
          if (this.panorama.mesh.intersection) {
          	const position = new THREE.Vector3().copy(this.panorama.mesh.intersection.point).normalize();
          	// console.log(JSON.stringify({ position: position.toArray() }));
          	this.viewHit.next(position);
          }
          */
        }
      } else if (this.isTouchDevice() && hit && hit.name === '[panorama]') {
        const item = this.view.items.find(item => item.showPanel);
        if (item) {
          item.showPanel = false;
          this.pushChanges();
          // console.log(item, hit, this.view.items);
        }
      }
    } catch (error) {
      this.error = error;
      // throw (error);
    }
  }

  onMouseMove(event) {
    try {
      this.raycasterDesktopHitTest(event);
    } catch (error) {
      this.error = error;
      // throw (error);
    }
  }

  onMouseUp(event) {
    try {
      if (this.lockedOrXR) {
        return;
      }
      if (this.dragItem) {
        if (typeof this.dragItem.onDragEnd === 'function') {
          this.dragItem.onDragEnd();
          this.dragEnd.next(this.dragItem);
        }
      }
      this.dragItem = null;
      if (this.resizeItem) {
        if (typeof this.resizeItem.onResizeEnd === 'function') {
          this.resizeItem.onResizeEnd();
          this.resizeEnd.next(this.resizeItem);
        }
      }
      this.resizeItem = null;
      const raycaster = this.updateRaycasterMouse(event);
      const hit = Interactive.hittest(raycaster, false);
      this.checkSelectedItem();
    } catch (error) {
      this.error = error;
      // throw (error);
    }
  }

  onMouseWheel(event) {
    try {
      if (this.lockedOrXR) {
        return;
      }
      const deltaY = event.deltaY * (event.wheelDeltaY !== undefined ? 1 : 37);
      const orbitService = this.orbitService;
      gsap.to(orbitService, {
        duration: 0.5,
        zoom: orbitService.zoom + deltaY * 0.1,
        ease: Power4.easeOut,
        overwrite: true
      });
    } catch (error) {
      this.error = error;
      // throw (error);
    }
  }

  onOrientationDidChange() {
    this.controlEvent$.next(CONTROL_INFO);
  }
  checkSelectedItem() {
    if (this.view) {
      const selected = this.view.items.find(item => item.selected);
      if (selected && selected.mesh) {
        if (this.view.type.name !== 'model') {
          this.orbitService.lookAt(selected.mesh);
        }
      }
    }
  }
  onVRStarted() {
    // this.objects.rotation.y = - Math.PI / 2;
    this.objects.position.y = 1.3;
    this.scene.add(this.indicator.mesh);
    MessageService.send({
      type: MessageType.VRStarted
    });
  }
  onVREnded() {
    // this.objects.rotation.y = 0;
    this.objects.position.y = 0;
    this.cameraGroup.rotation.y = 0;
    this.cameraGroup.position.y = 0;
    this.scene.remove(this.indicator.mesh);
    this.orbitService.markAsDirty();
    MessageService.send({
      type: MessageType.VREnded
    });
  }
  onVRStateDidChange(state) {
    MessageService.send({
      type: MessageType.VRState,
      camera: state.camera.array
    });
  }
  onMenuNav(event) {
    // Logger.log('WorldComponent.onMenuNav', event.id, event);
    this.menu = undefined;
    this.navTo.next({
      viewId: event.id
    });
  }
  onMenuToggle(event) {
    // Logger.log('WorldComponent.onMenuToggle', event.id, event);
    if (this.locked) {
      return;
    }
    this.menu = event;
    this.view.items.forEach(item => item.showPanel = false);
    this.pushChanges();
  }
  onNavOver(nav) {
    if (this.menu) {
      return;
      // this.menu.removeMenu();
    }

    this.view.items.forEach(item => item.showPanel = false);
    if (nav.item.to) {
      clearTimeout(nav.item.to);
    }
    nav.item.showPanel = nav.shouldShowPanel();
    // Logger.log('WorldComponent.onNavOver', nav, nav.item.showPanel);
    this.pushChanges();
    MessageService.send({
      type: MessageType.ShowPanel,
      itemId: nav.item.showPanel ? nav.item.id : null
    });
  }
  onNavOut(nav) {
    // Logger.log('WorldComponent.onNavOut', nav);
    if (this.isTouchDevice()) {
      return;
    }
    // nav.item.showPanel = false;
    nav.item.to = setTimeout(() => {
      nav.item.showPanel = false;
      this.pushChanges();
    }, 6000);
    this.pushChanges();
  }
  onNavDown(event) {
    if (!this.isTouchDevice()) {
      event.item.showPanel = false;
    }
    // Logger.log('WorldComponent.onNavDown', this.keys);
    if (this.locked) {
      return;
    }
    if (this.editor && this.keys.Shift) {
      this.dragItem = event;
      this.select.next(event);
    } else if (this.editor && this.keys.Control) {
      this.resizeItem = event;
      this.select.next(event);
    } else {
      this.navTo.next(event.item);
    }
  }
  onNavLink(event) {
    // Logger.log('WorldComponent.onNavLink', event.link.href);
    if (this.locked || this.editor) {
      return;
    }
    if (environment.flags.useIframe) {
      MessageService.send({
        type: MessageType.NavLink,
        itemId: event.item.id,
        linkIndex: event.linkIndex
      });
      this.navLink.next(event);
    } else {
      window.open(event.link.href, '_blank');
    }
  }
  isTouchDevice() {
    return 'ontouchstart' in window || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0;
  }
  onModelDown(event) {
    if (this.editor) {
      return this.onObjectDown(event);
    }
    // vr controller model grab
    const controller = this.controller;
    if (controller && this.renderer.xr.isPresenting) {
      const target = this.tempTarget = event.mesh;
      // Logger.log('WorldComponent.onModelDown', target);
      // DebugService.getService().setMessage('onModelDown ', target.name);
      this.tempParent = target.parent;
      const position = new THREE.Vector3();
      target.localToWorld(position);
      controller.worldToLocal(position);
      controller.add(target);
      target.position.copy(position);
    }
  }
  onModelDistance(direction) {
    // vr controller model distance
    const controller = this.controller;
    const target = this.tempTarget;
    if (controller && target && this.renderer.xr.isPresenting) {
      let position = new THREE.Vector3();
      position = position.copy(target.position);
      const distance = Math.max(1, Math.min(8, position.distanceTo(ZERO) + 0.02 * direction));
      position.normalize();
      position = position.multiplyScalar(distance);
      // DebugService.getService().setMessage('onModelDistance ' + distance);
      target.position.copy(position);
    }
  }
  onModelUp() {
    // vr controller model release
    const target = this.tempTarget;
    const parent = this.tempParent;
    if (target && parent) {
      // Logger.log('WorldComponent.onModelUp', target, parent);
      const position = new THREE.Vector3();
      target.localToWorld(position);
      parent.worldToLocal(position);
      parent.add(target);
      target.position.copy(position);
      this.tempTarget = null;
      this.tempParent = null;
    }
  }
  onObjectDown(event) {
    // Logger.log('WorldComponent.onObjectDown', this.keys);
    if (this.lockedOrXR) {
      return;
    }
    if (this.editor && this.keys.Shift) {
      this.dragItem = event;
      this.select.next(event);
    } else if (this.editor && this.keys.Control) {
      this.resizeItem = event;
      this.select.next(event);
    }
  }
  onPanelDown(event) {
    // Logger.log('WorldComponent.onPanelDown', event.link.href);
    if (this.locked) {
      return;
    }
    if (environment.flags.useIframe) {
      MessageService.send({
        type: MessageType.NavLink,
        itemId: event.item.id,
        linkIndex: event.linkIndex
      });
      this.navLink.next(event);
    } else {
      window.open(event.link.href, '_blank');
      /*
      const href = event.getAttribute('href');
      const target = event.getAttribute('target') || '_self';
      if (href) {
      	window.open(href, '_blank');
      }
      */
    }
  }

  onPlayMedia(event) {
    if (this.editor) {
      return;
    }
    MessageService.send({
      type: MessageType.PlayMedia,
      itemId: event.itemId,
      playing: event.playing
    });
  }
  onZoomMedia(event) {
    if (event.zoomed) {
      this.view.items.forEach(item => {
        if (item.mesh instanceof MediaMesh) {
          // console.log(item.id, event.itemId, item.id !== event.itemId);
          if (item.id !== event.itemId) {
            item.mesh.setZoomedState(false);
          }
        }
      });
    }
    this.view.items.forEach(item => item.showPanel = false);
    StateService.patchState({
      zoomedId: event.zoomed ? event.itemId : null
    });
    MessageService.send({
      type: MessageType.ZoomMedia,
      itemId: event.itemId,
      zoomed: event.zoomed
    });
  }
  onCurrentTimeMedia(event) {
    if (this.editor) {
      return;
    }
    MessageService.send({
      type: MessageType.CurrentTimeMedia,
      itemId: event.itemId,
      currentTime: event.currentTime
    });
  }
  onPlayModel(event) {
    if (this.editor) {
      return;
    }
    MessageService.send({
      type: MessageType.PlayModel,
      itemId: event.itemId,
      actionIndex: event.actionIndex
    });
  }
  onGridMove(event) {
    // Logger.log('WorldComponent.onGridMove', event, this.view);
    this.view.items = [];
    this.pushChanges();
    this.orbitService.walk(event.position, (headingLongitude, headingLatitude) => {
      const tile = this.view.getTile(event.indices.x, event.indices.y);
      if (tile) {
        this.panorama.crossfade(tile, this.renderer, texture => {
          if (!environment.flags.useTextureEnvironment) {
            this.setBackground(texture);
          }
          this.orbitService.walkComplete(headingLongitude, headingLatitude);
          this.view.updateCurrentItems();
          // this.loading = null;
          this.pushChanges();
          // this.render();
          // this.pushChanges();
        });
      }
    });
  }

  onGridNav(event) {
    // Logger.log('WorldComponent.onGridNav', event);
    if (this.locked) {
      return;
    }
    MessageService.send({
      type: MessageType.NavToGrid,
      viewId: this.view.id,
      gridIndex: event
    });
    this.pushChanges();
  }
  setSnapshot(snapshot) {
    if (ViewService.viewId !== snapshot.viewId) {
      ViewService.viewId = snapshot.viewId;
      this.requestInfoResult = snapshot;
    } else {
      if (!this.renderer.xr.isPresenting) {
        this.orbitService.setOrientation(snapshot.orientation);
        this.orbitService.zoom = snapshot.zoom;
        this.cameraGroup.position.set(snapshot.cameraGroup.position[0], snapshot.cameraGroup.position[1], snapshot.cameraGroup.position[2]);
        this.cameraGroup.rotation.set(snapshot.cameraGroup.rotation[0], snapshot.cameraGroup.rotation[1], snapshot.cameraGroup.rotation[2]);
        // this.camera.updateProjectionMatrix();
      }

      if (this.view instanceof PanoramaGridView && snapshot.gridIndex) {
        this.view.index = snapshot.gridIndex;
      }
      if (!this.view || !this.view.ready) {
        this.requestInfoResult = snapshot;
      }
    }
  }
  getSnapshot() {
    const snapshot = _objectSpread2(_objectSpread2({}, CONTROL_INFO), {}, {
      viewId: this.view.id,
      type: MessageType.SetSnapshot
    });
    if (this.view instanceof PanoramaGridView) {
      snapshot.gridIndex = this.view.index;
    }
    return snapshot;
  }
  sendSetSnapshot() {
    const snapshot = this.getSnapshot();
    // snapshot.type = MessageType.SetSnapshot;
    MessageService.send(snapshot);
  }
  control$() {
    return this.controlEvent$.pipe(operators.filter(() => this.controlling || this.spyed || this.editor), operators.auditTime(Math.floor(1000 / 15)), operators.map(control => {
      /**
       * here we are updating original CONTROL_INFO object
       */
      control.orientation.latitude = this.orbitService.latitude;
      control.orientation.longitude = this.orbitService.longitude;
      control.zoom = this.orbitService.zoom;
      control.cameraGroup = {
        position: this.cameraGroup.position.toArray(),
        rotation: this.cameraGroup.rotation.toArray()
      };
      const intersections = this.raycaster.intersectObjects(this.intersectObjects);
      const point = intersections.length ? intersections[0].point.normalize() : null;
      if (point) {
        control.pointer[0] = point.x;
        control.pointer[1] = point.y;
        control.pointer[2] = point.z;
      }
      MessageService.send(control);
      return control;
    }), operators.auditTime(4000), operators.tap(control => {
      /**
       * !!! every 4 seconds we save the last view snapshot
       */
      const snapshot = this.getSnapshot();
      // snapshot.type = MessageType.SetSnapshot;
      MessageService.send(snapshot);
    }));
  }
  addListeners() {
    this.controlEvent$ = new rxjs.ReplaySubject(1);
    this.control$().pipe(operators.takeUntil(this.unsubscribe$)).subscribe();
    const vrService = this.vrService = VRService.getService();
    vrService.session$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(session => {
      this.renderer.xr.setSession(session);
      if (session) {
        this.onVRStarted();
      } else {
        this.onVREnded();
      }
    });
    vrService.state$.pipe(operators.takeUntil(this.unsubscribe$), operators.auditTime(Math.floor(1000 / 15))).subscribe(state => {
      this.onVRStateDidChange(state);
    });
    const orbit$ = this.orbitService.observe$(this.container).pipe(operators.shareReplay(1));
    /*
    const drag$ = orbit$.pipe(
    	filter(event => event instanceof OrbitDragEvent),
    );
    */
    const orientation$ = orbit$.pipe(operators.filter(event => event instanceof OrbitMoveEvent), operators.auditTime(Math.floor(1000 / 15)));
    orientation$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(event => {
      // this.render();
      this.onOrientationDidChange();
    });
    MessageService.out$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(message => {
      Logger.log('WorldComponent.addListeners', 'MessageService.out$', message);
      switch (message.type) {
        case MessageType.RequestControl:
          {
            Logger.log('WorldComponent.MessageType.RequestControl', message.controllingId);
            StateService.patchState({
              controlling: message.controllingId,
              spying: false
            });
            if (message.controllingId === StateService.state.uid) {
              this.sendSetSnapshot();
            }
            break;
          }
        case MessageType.RequestSpy:
          {
            Logger.log('WorldComponent.MessageType.RequestSpy', message.spyingId);
            StateService.patchState({
              spying: message.spyingId,
              controlling: false
            });
            if (message.spyingId === StateService.state.uid) {
              this.sendSetSnapshot();
            }
            break;
          }
        case MessageType.SetSnapshot:
          this.setSnapshot(message);
          break;
        case MessageType.ShowPanel:
          if (this.menu) {
            this.menu.removeMenu();
          }
          this.view.items.forEach(item => item.showPanel = item.id === message.itemId);
          this.pushChanges();
          break;
        case MessageType.NavLink:
          {
            const item = this.view.items.find(item => item.id === message.itemId);
            if (item) {
              const link = item.links[message.linkIndex];
              this.navLink.next({
                item,
                link,
                linkIndex: message.linkIndex
              });
            }
            break;
          }
        case MessageType.NavLinkClose:
          {
            const closeItem = this.view.items.find(item => item.id === message.itemId);
            if (closeItem) {
              ModalService.resolve();
            }
            break;
          }
        case MessageType.PlayMedia:
          {
            // !!! uniformare a PlayModel
            const item = this.view.items.find(item => item.id === message.itemId);
            if (item && item.mesh instanceof MediaMesh) {
              item.mesh.setPlayingState(message.playing);
            }
            break;
          }
        case MessageType.ZoomMedia:
          {
            this.view.items.forEach(item => {
              if (item.mesh instanceof MediaMesh) {
                if (item.id === message.itemId) {
                  item.mesh.setZoomedState(message.zoomed);
                } else {
                  item.mesh.setZoomedState(false);
                }
              }
            });
            StateService.patchState({
              zoomedId: message.zoomed ? message.itemId : null
            });
            break;
          }
        case MessageType.CurrentTimeMedia:
          {
            const item = this.view.items.find(item => item.id === message.itemId);
            if (item && item.mesh instanceof MediaMesh) {
              item.mesh.setCurrentTime(message.currentTime);
            }
            break;
          }
        case MessageType.PlayModel:
          {
            const item = this.view.items.find(item => item.id === message.itemId);
            if (item) {
              item.onMessage(message);
            }
            break;
          }
        case MessageType.NavToGrid:
          // Logger.log('WorldComponent.NavToGrid', this.view.id, message);
          if (this.view.id === message.viewId) {
            this.view.index = message.gridIndex;
          }
          break;
        case MessageType.VRStarted:
          this.addOffCanvasScene(message);
          break;
        case MessageType.VREnded:
          this.removeOffCanvasScene(message);
          break;
        case MessageType.VRState:
          this.updateOffCanvasScene(message);
          if (StateService.state.spying === message.clientId || StateService.state.controlling === message.clientId) {
            this.orbitService.setVRCamera(message.camera);
          }
          break;
        case MessageType.ControlInfo:
          if (!this.renderer.xr.isPresenting) {
            this.orbitService.setOrientation(message.orientation);
            this.orbitService.zoom = message.zoom;
            this.cameraGroup.position.set(message.cameraGroup.position[0], message.cameraGroup.position[1], message.cameraGroup.position[2]);
            this.cameraGroup.rotation.set(message.cameraGroup.rotation[0], message.cameraGroup.rotation[1], message.cameraGroup.rotation[2]);
            // this.camera.updateProjectionMatrix();
          }

          this.pointer.setPosition(message.pointer[0], message.pointer[1], message.pointer[2], this.camera);
          break;
      }
    });
    MessageService.in$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(message => {
      switch (message.type) {
        case MessageType.SelectItem:
          this.checkSelectedItem();
          break;
      }
    });
    StateService.state$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(state => {
      this.state = state;
      this.showPointer = this.locked;
      // console.log(state);
      // this.pushChanges();
    });

    this.resize = this.resize.bind(this);
    this.render = this.render.bind(this);
    this.onMouseDown = this.onMouseDown.bind(this);
    this.onMouseMove = this.onMouseMove.bind(this);
    this.onMouseUp = this.onMouseUp.bind(this);
    this.onMouseWheel = this.onMouseWheel.bind(this);
    // this.controls.addEventListener('change', this.render); // use if there is no animation loop
    window.addEventListener('resize', this.resize, false);
    this.container.addEventListener('wheel', this.onMouseWheel, false);
    this.container.addEventListener('mousedown', this.onMouseDown, false);
    this.container.addEventListener('mouseup', this.onMouseUp, false);
    document.addEventListener('mousemove', this.onMouseMove, false);
  }
  removeListeners() {
    window.removeEventListener('resize', this.resize, false);
    window.removeEventListener('resize', this.resize, false);
    document.removeEventListener('mousemove', this.onMouseMove, false);
    document.removeEventListener('wheel', this.onMouseWheel, false);
    this.container.removeEventListener('mousedown', this.onMouseDown, false);
    this.container.removeEventListener('mouseup', this.onMouseUp, false);
  }
}
WorldComponent.meta = {
  selector: '[world]',
  inputs: ['view', 'views', 'editor'],
  outputs: ['navTo', 'navLink', 'viewHit', 'dragEnd', 'resizeEnd', 'select'],
  template: /* html */`
	<div class="world__view" *if="view">
		<div class="grid" model-grid *if="view.type.name === 'panorama-grid'" [view]="view" (move)="onGridMove($event)" (nav)="onGridNav($event)"></div>
		<div *if="view.ready">
			<div model-room [view]="view" *if="view.type.name === 'room-3d'"></div>
			<div class="world__item" *for="let item of view.pathItems; let index = index;">
				<div model-nav [item]="item" [view]="view" (over)="onNavOver($event)" (out)="onNavOut($event)" (down)="onNavDown($event)" (link)="onNavLink($event)" *if="item.type.name == 'nav'"></div>
				<div model-plane [item]="item" [view]="view" (play)="onPlayMedia($event)" (zoom)="onZoomMedia($event)" (down)="onObjectDown($event)" (currentTime)="onCurrentTimeMedia($event)" *if="item.type.name == 'plane'"></div>
				<div model-curved-plane [item]="item" [view]="view" (play)="onPlayMedia($event)" (zoom)="onZoomMedia($event)" (down)="onObjectDown($event)" (currentTime)="onCurrentTimeMedia($event)" *if="item.type.name == 'curved-plane'"></div>
				<div class="model-viewer__item" model-model [item]="item" [view]="view" (down)="onModelDown($event)" (play)="onPlayModel($event)" *if="item.type.name == 'model'"></div>
				<div class="panel" [class]="{ 'panel--lg': item.asset != null }" model-panel [item]="item" (down)="onPanelDown($event)" *if="item.showPanel"></div>
			</div>
		</div>
	</div>
	<div class="progress-indicator" model-progress [view]="view">
		<div class="inner"></div>
	</div>
	<div model-menu [views]="views" (nav)="onMenuNav($event)" (toggle)="onMenuToggle($event)" *if="showMenu"></div>
	<div model-debug *if="debugging"></div>
	<div class="world__info" *if="error" [innerHTML]="error"></div>
	`
};class ModelComponent extends rxcomp.Component {
  set renderOrder(renderOrder) {
    this.group.renderOrder = renderOrder;
  }
  onInit() {
    // console.log('ModelComponent.onInit');
    // console.log('item', this.item, 'host', this.host);
    if (!this.host) {
      throw 'ModelComponent host is undefined';
    }
    this.scale = new THREE.Vector3(1.0, 1.0, 1.0);
    this.position = new THREE.Vector3();
    const group = this.group = new THREE.Group();
    group.name = this.getName();
    group.userData.render = (time, tick) => {
      // if (this.intersection) {
      this.render(this, time, tick);
      // }
    };

    this.getContainer().add(group);
    this.onCreate((mesh, item) => this.onMount(mesh, item), (mesh, item) => this.onDismount(mesh, item));
  }
  onDestroy() {
    // console.log('ModelComponent', this);
    const group = this.group;
    this.getContainer().remove(group);
    delete group.userData.render;
    this.disposeObject(group);
    this.group = null;
  }
  getContainer() {
    return this.host.objects;
  }
  getName(name) {
    return `${this.constructor.meta.selector}-${this.rxcompId}${name ? `-${name}` : ''}`;
  }
  onCreate(mounth, dismount) {
    const material = new THREE.MeshStandardMaterial({
      color: new THREE.Color('#ffcc00'),
      roughness: 0.4,
      metalness: 0.01,
      flatShading: true,
      transparent: true,
      opacity: 0.9
    });
    const mesh = new THREE.Mesh(Geometry.defaultGeometry, material);
    if (typeof mounth === 'function') {
      mounth(mesh);
    }
    return mesh;
  }
  onMount(mesh, item) {
    if (this.mesh) {
      // console.log('ModelComponent.dismount.mesh');
      this.onDismount(this.mesh);
    }
    mesh.name = this.getName('mesh');
    this.mesh = mesh;
    if (item) {
      item.mesh = mesh;
      Object.defineProperty(item, 'visible', {
        get: () => {
          return mesh.visible;
        },
        set: visible => {
          this.setVisible(visible);
        },
        configurable: true
      });
      item.onUpdate = () => {
        this.onUpdate(item, mesh);
      };
      item.onUpdateAsset = () => {
        this.onUpdateAsset(item, mesh);
      };
      item.onMessage = message => {
        this.onMessage(message);
      };
    }
    if (this.group) {
      this.group.add(mesh);
    }
    // this.host.render(); !!!
    /*
    const node = this.node;
    DomService.scrollIntersection$(node).subscribe(event => {
    	this.scroll = event.scroll;
    	this.intersection = event.intersection;
    	this.calculateScaleAndPosition();
    });
    */
    // console.log('Model.loaded', mesh);
  }

  onDismount(mesh, item) {
    this.group.remove(mesh);
    if (typeof mesh.dispose === 'function') {
      mesh.dispose();
    }
    this.disposeObject(mesh);
    this.mesh = null;
    if (item) {
      delete item.mesh;
      delete item.onUpdate;
      delete item.onUpdateAsset;
      delete item.onMessage;
    }
  }
  disposeObject(object) {
    object.traverse(child => {
      if (child.isInteractiveMesh || child.isInteractiveSprite) {
        Interactive.dispose(child);
      }
      if (child.isMesh) {
        if (child.material.map && child.material.map.disposable !== false) {
          child.material.map.dispose();
        }
        child.material.dispose();
        child.geometry.dispose();
      } else if (child.isSprite) {
        if (child.material.map && child.material.map.disposable !== false) {
          child.material.map.dispose();
        }
        child.material.dispose();
      }
    });
    // console.log('ModelComponent.disposeObject', object);
  }

  calculateScaleAndPosition() {
    const {
      node
    } = rxcomp.getContext(this);
    this.host.repos(this, node.getBoundingClientRect());
  }
  render(time, tick) {
    /*
    this.calculateScaleAndPosition();
    const group = this.group;
    const scale = this.scale;
    // group.scale.set(scale.x, scale.y, scale.z);
    const position = this.position;
    group.position.set(position.x, 0, 0);
    // const tween = this.tween();
    // group.rotation.x = THREE.Math.degToRad(180) * tween;
    // group.rotation.y = THREE.Math.degToRad(360) * tween;
    */
  }
  setVisible(visible) {
    if (this.mesh) {
      this.mesh.visible = visible;
    }
  }
  getScroll(offset) {
    const scroll = this.intersection.scroll(offset);
    // console.log(scroll);
    return scroll;
  }
  getTween(offset) {
    let tween = Math.min(0.0, this.intersection.offset(offset)) + 1;
    tween = Math.max(0.0, tween);
    // tween = Ease.Sine.InOut(tween);
    tween -= 1;
    return tween;
  }

  // called by UpdateViewItemComponent
  onUpdate(item, mesh) {}

  // called by UpdateViewItemComponent
  onUpdateAsset(item, mesh) {}

  // called by remote events
  onMessage(message) {}
}
ModelComponent.meta = {
  selector: '[model]',
  hosts: {
    host: WorldComponent
  },
  inputs: ['item']
};class ModelEditableComponent extends ModelComponent {
  get editing() {
    return this.editing_;
  }
  set editing(editing) {
    if (this.editing_ !== editing) {
      this.editing_ = editing;
      this.setHelper(editing);
    }
  }
  onInit() {
    super.onInit();
    this.RADIUS = 100;
  }
  onDestroy() {
    // console.log('ModelEditableComponent', this);
    this.editing = false;
    super.onDestroy();
  }
  setHelper(showHelper) {
    if (showHelper) {
      if (!this.helper) {
        this.helper = new THREE.BoxHelper(this.mesh, 0x00ff00);
      }
      this.host.scene.add(this.helper);
    } else if (this.helper) {
      this.host.scene.remove(this.helper);
    }
  }
  updateHelper() {
    if (this.helper) {
      this.helper.setFromObject(this.mesh);
      // this.helper.update();
    }
  }
}

ModelEditableComponent.meta = {
  selector: '[model-editable]',
  hosts: {
    host: WorldComponent
  },
  inputs: ['item']
};const NavModeType = {
  None: 'none',
  Move: 'move',
  Info: 'info',
  Point: 'point',
  Title: 'title',
  Transparent: 'transparent',
  Wishlist: 'wishlist'
};
class ModelNavComponent extends ModelEditableComponent {
  constructor() {
    super(...arguments);
    this.hidden_ = false;
    this.isMobile_ = void 0;
  }
  static getLoader() {
    return ModelNavComponent.loader || (ModelNavComponent.loader = new THREE.TextureLoader());
  }
  static getTexturePoint() {
    return ModelNavComponent.texturePoint || (ModelNavComponent.texturePoint = ModelNavComponent.getLoader().load(environment.getPath('textures/ui/nav-point.png')));
  }
  static getTexturePointImportant() {
    return ModelNavComponent.texturePointImportant || (ModelNavComponent.texturePointImportant = ModelNavComponent.getLoader().load(environment.getPath('textures/ui/nav-point-important.png')));
  }
  static getTextureMove() {
    return ModelNavComponent.textureMove || (ModelNavComponent.textureMove = ModelNavComponent.getLoader().load(environment.getPath('textures/ui/nav-more.png')));
  }
  static getTextureMoveImportant() {
    return ModelNavComponent.textureMoveImportant || (ModelNavComponent.textureMoveImportant = ModelNavComponent.getLoader().load(environment.getPath('textures/ui/nav-more-important.png')));
  }
  static getTextureInfo() {
    return ModelNavComponent.textureInfo || (ModelNavComponent.textureInfo = ModelNavComponent.getLoader().load(environment.getPath('textures/ui/nav-info.png')));
  }
  static getTextureInfoImportant() {
    return ModelNavComponent.textureInfoImportant || (ModelNavComponent.textureInfoImportant = ModelNavComponent.getLoader().load(environment.getPath('textures/ui/nav-info-important.png')));
  }
  static getTextureWishlist() {
    return ModelNavComponent.textureWishlist || (ModelNavComponent.textureWishlist = ModelNavComponent.getLoader().load(environment.getPath('textures/ui/nav-wishlist-off.png')));
  }
  static getTextureWishlistAdded() {
    return ModelNavComponent.textureWishlistAdded || (ModelNavComponent.textureWishlistAdded = ModelNavComponent.getLoader().load(environment.getPath('textures/ui/nav-wishlist-on.png')));
  }
  static getTexture(mode, item) {
    let texture;
    switch (mode) {
      case NavModeType.Move:
        texture = item.important ? this.getTextureMoveImportant() : this.getTextureMove();
        break;
      case NavModeType.Info:
        texture = item.important ? this.getTextureInfoImportant() : this.getTextureInfo();
        break;
      case NavModeType.Point:
      case NavModeType.Title:
        texture = item.important ? this.getTexturePointImportant() : this.getTexturePoint();
        break;
      case NavModeType.Wishlist:
        texture = item.added ? this.getTextureWishlistAdded() : this.getTextureWishlist();
        break;
    }
    texture.disposable = false;
    texture.encoding = THREE.sRGBEncoding;
    return texture;
  }
  static getTitleTexture(item, mode) {
    let texture;
    if (mode === NavModeType.Title) {
      const text = item.title;
      const canvas = document.createElement('canvas');
      // document.querySelector('body').appendChild(canvas);
      canvas.width = 512;
      canvas.height = 32;
      const ctx = canvas.getContext('2d');
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = 'high';
      ctx.font = `24px ${environment.fontFamily}`;
      const metrics = ctx.measureText(text);
      let w = metrics.width + 8;
      w = Math.pow(2, Math.ceil(Math.log(w) / Math.log(2)));
      const x = w / 2;
      const y = 16;
      canvas.width = w;
      ctx.font = `24px ${environment.fontFamily}`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.strokeStyle = 'rgba(0, 0, 0, 0.5)';
      ctx.lineWidth = 6;
      ctx.lineJoin = 'round'; // Experiment with 'bevel' & 'round' for the effect you want!
      ctx.miterLimit = 2;
      ctx.strokeText(text, x, y);
      ctx.fillStyle = 'white';
      ctx.fillText(text, x, y);
      texture = new THREE.CanvasTexture(canvas);
    }
    return texture;
  }
  static getNavMode(item, view) {
    let mode = NavModeType.None;
    if (item.hook && item.hook === 'ToggleWishlist') {
      mode = NavModeType.Wishlist;
    } else if (item.transparent) {
      mode = NavModeType.Transparent;
    } else if (item.viewId !== view.id) {
      mode = NavModeType.Move;
      if (this.isValidText(item.title)) {
        mode = NavModeType.Title;
      }
      if (this.isValidText(item.abstract) || item.asset && item.asset.id || item.link && item.link.href) {
        mode = NavModeType.Point;
      }
    } else if (this.isValidText(item.title) || this.isValidText(item.abstract) || item.asset && item.asset.id || item.link && item.link.href) {
      mode = NavModeType.Info;
    }
    return mode;
  }
  static hasNavInfo(view) {
    const item = view.items.find(x => this.getNavMode(x, view) === NavModeType.Info);
    // console.log('ModelNavComponent.hasNavInfo', item);
    return item != null;
  }
  static isValidText(text) {
    return text && text.length > 0;
  }
  get hidden() {
    return this.hidden_;
  }
  set hidden(hidden) {
    if (this.hidden_ !== hidden) {
      this.hidden_ = hidden;
      this.updateVisibility(!hidden);
    }
  }
  get isHidden() {
    return StateService.state.zoomedId != null || environment.flags.hideNavInfo && !this.host.editor && !StateService.state.showNavInfo && !(this.host.renderer.xr.isPresenting || StateService.state.role === RoleType.SelfService || StateService.state.role === RoleType.Embed) && this.mode === NavModeType.Info;
  }
  get isAnimated() {
    let isAnimated = false;
    const mode = this.mode;
    const important = this.item.important;
    switch (mode) {
      case NavModeType.Info:
        isAnimated = important ? environment.flags.navInfoImportantAnimated : environment.flags.navInfoAnimated;
        break;
      case NavModeType.Move:
        isAnimated = important ? environment.flags.navMoveImportantAnimated : environment.flags.navMoveAnimated;
        break;
      case NavModeType.Point:
        isAnimated = important ? environment.flags.navPointImportantAnimated : environment.flags.navPointAnimated;
        break;
      case NavModeType.Title:
        isAnimated = important ? environment.flags.navTitleImportantAnimated : environment.flags.navTitleAnimated;
        break;
      case NavModeType.Transparent:
        isAnimated = important ? environment.flags.navTransparentImportantAnimated : environment.flags.navTransparentAnimated;
        break;
    }
    return isAnimated;
  }
  get iconMinScale() {
    return (environment.navs.iconMinScale || 1) * 0.03 * (this.isMobile ? 1.6 : 1);
  }
  get iconMaxScale() {
    return (environment.navs.iconMaxScale || 1.5) * 0.03 * (this.isMobile ? 1.6 : 1);
  }
  get isMobile() {
    return this.isMobile_;
  }
  set isMobile(isMobile) {
    if (this.isMobile_ !== isMobile) {
      this.isMobile_ = isMobile;
      this.setScale();
    }
  }
  render(time, tick) {
    // console.log('render', this.host.worldRect.width);
    this.isMobile = this.host.worldRect.width < 768;
  }
  setScale(pow) {
    if (pow === void 0) {
      pow = 0;
    }
    const icon = this.icon;
    if (icon) {
      const scale = this.iconMinScale + pow * (this.iconMaxScale - this.iconMinScale);
      icon.scale.set(scale, scale, scale);
    }
  }
  shouldShowPanel() {
    return !this.editing && this.mode !== NavModeType.Move && this.mode !== NavModeType.Title && this.mode !== NavModeType.Wishlist && (this.mode !== NavModeType.Transparent || ModelNavComponent.isValidText(this.item.title));
  }
  updateVisibility(visible) {
    if (this.mesh) {
      this.mesh.visible = visible;
    }
    if (this.sphere) {
      this.sphere.freezed = !visible;
    }
    if (!visible && this.item) {
      this.item.showPanel = false;
    }
  }
  setVisible(visible) {
    if (this.mesh) {
      this.mesh.visible = visible && !this.hidden_;
    }
  }
  onInit() {
    super.onInit();
  }
  onChanges() {
    const view = this.view;
    const item = this.item;
    const mode = this.mode = ModelNavComponent.getNavMode(item, this.view);
    if (mode === NavModeType.Wishlist) {
      item.added = WishlistService.has({
        viewId: view.id,
        itemId: item.id
      });
      this.onCreateSprites(this.mesh, 1);
    }
    this.editing = item.selected;
    this.hidden = this.isHidden;
  }
  onCreate(mount, dismount) {
    // this.renderOrder = environment.renderOrder.nav;
    const view = this.view;
    const item = this.item;
    const mode = this.mode = ModelNavComponent.getNavMode(item, this.view);
    if (mode === NavModeType.None) {
      return;
    }
    if (mode === NavModeType.Wishlist) {
      item.added = WishlistService.has({
        viewId: view.id,
        itemId: item.id
      });
    }
    const isAnimated = this.isAnimated;
    const nav = new THREE.Group();
    if (mode === NavModeType.Transparent) {
      const opacityIdle = this.host.editor ? 0.1 : 0.0;
      const opacityOver = 0.2;
      const opacityDown = 0.3;
      nav.position.fromArray(item.position);
      nav.rotation.fromArray(item.rotation);
      nav.scale.fromArray(item.scale);
      const geometry = Geometry.planeGeometry;
      const plane = this.plane = new InteractiveMesh(geometry, new THREE.MeshBasicMaterial({
        depthTest: false,
        depthWrite: false,
        transparent: true,
        opacity: opacityIdle,
        color: new THREE.Color(environment.colors.menuOverBackground),
        toneMapped: false
      }));
      plane.name = `[nav] ${item.id}`;
      plane.depthTest = false;
      nav.add(plane);
      if (isAnimated) {
        const from = {
          pow: 0
        };
        gsap.to(from, {
          pow: 1,
          duration: 0.6,
          delay: 0.5 + 0.1 * item.index,
          ease: Power2.easeOut,
          repeat: -1,
          yoyo: true,
          onUpdate: () => {
            plane.material.opacity = from.pow * opacityDown;
          }
        });
      }
      plane.on('over', () => {
        if (!isAnimated) {
          plane.material.opacity = opacityOver;
        }
        this.over.next(this);
      });
      plane.on('out', () => {
        if (!isAnimated) {
          plane.material.opacity = opacityIdle;
        }
        this.out.next(this);
      });
      plane.on('down', () => {
        if (!isAnimated) {
          plane.material.opacity = opacityDown;
        }
        this.down.next(this);
        // opening nav link
        const item = this.item;
        const link = item.firstLink;
        if (!this.host.editor && !this.shouldShowPanel() && link && link.href) {
          this.shouldNavToLink = link.href;
        }
        console.log('ModelNavComponent.down');
      });
      plane.on('up', () => {
        if (!isAnimated) {
          plane.material.opacity = opacityIdle;
        }
        // opening nav link
        if (this.shouldNavToLink != null) {
          /*
          const link = this.shouldNavToLink;
          window.open(link, '_blank');
          */
          this.shouldNavToLink = null;
          const item = this.item;
          const link = item.firstLink;
          this.link.next({
            item,
            link
          });
        }
      });
    } else {
      // !! fixing normalized positions;
      const position = new THREE.Vector3(item.position[0], item.position[1], item.position[2]);
      const normalizedPosition = new THREE.Vector3(item.position[0], item.position[1], item.position[2]).normalize();
      if (position.distanceToSquared(normalizedPosition) < 0.0001) {
        position.multiplyScalar(ModelNavComponent.RADIUS);
      }
      // console.log('!!! fixing normalized positions', 'position', position, 'normalizedPosition', normalizedPosition, 'distanceToSquared', position.distanceToSquared(normalizedPosition));
      nav.position.copy(position);
      this.onCreateSprites(nav);
      const geometry = Geometry.sphereGeometry;
      const sphere = this.sphere = new InteractiveMesh(geometry, new THREE.MeshBasicMaterial({
        depthTest: false,
        depthWrite: false,
        transparent: true,
        opacity: 0.0,
        color: 0x00ffff,
        toneMapped: false
      }));
      sphere.name = `[nav] ${item.id}`;
      // sphere.lookAt(Host.origin); ??
      sphere.depthTest = false;
      // sphere.renderOrder = 0;
      nav.add(sphere);
      const from = {
        pow: 0
      };
      gsap.to(from, {
        pow: 1,
        duration: 0.7,
        delay: 0.5 + 0.1 * item.index,
        ease: Power2.easeInOut,
        overwrite: true,
        onUpdate: () => {
          this.materials.forEach(material => {
            material.opacity = from.pow;
            // material.needsUpdate = true;
          });
        },

        onComplete: () => {
          if (isAnimated) {
            const icon = this.icon;
            from.pow = 0;
            gsap.to(from, {
              pow: 1,
              duration: 0.6,
              delay: 0.5 + 0.1 * item.index,
              ease: Power2.easeOut,
              repeat: -1,
              yoyo: true,
              onUpdate: () => {
                this.setScale(from.pow);
                icon.material.opacity = from.pow;
              }
            });
          }
        }
      });
      sphere.on('over', () => {
        this.over.next(this);
        if (!isAnimated) {
          const icon = this.icon;
          const from = {
            scale: icon.scale.x
          };
          gsap.to(from, {
            duration: 0.35,
            scale: this.iconMaxScale,
            delay: 0,
            ease: Power2.easeOut,
            overwrite: true,
            onUpdate: () => {
              icon.scale.set(from.scale, from.scale, from.scale);
            }
          });
        }
      });
      sphere.on('out', () => {
        this.out.next(this);
        if (!isAnimated) {
          const icon = this.icon;
          const from = {
            scale: icon.scale.x
          };
          gsap.to(from, {
            duration: 0.35,
            scale: this.iconMinScale,
            delay: 0,
            ease: Power2.easeOut,
            overwrite: true,
            onUpdate: () => {
              icon.scale.set(from.scale, from.scale, from.scale);
            }
          });
        }
      });
      sphere.on('down', () => {
        this.down.next(this);
      });
    }
    if (typeof mount === 'function') {
      mount(nav, item);
    }
  }
  onCreateSprites(mesh, opacity) {
    if (opacity === void 0) {
      opacity = 0;
    }
    this.onRemoveSprite(this.icon);
    this.onRemoveSprite(this.title);
    const item = this.item;
    const mode = this.mode = ModelNavComponent.getNavMode(item, this.view);
    if (mode === NavModeType.None) {
      return;
    }
    if (mode === NavModeType.Transparent) {
      this.materials = [];
    } else {
      const map = ModelNavComponent.getTexture(mode, item);
      const material = new THREE.SpriteMaterial({
        map: map,
        depthTest: false,
        depthWrite: false,
        transparent: true,
        sizeAttenuation: false,
        opacity: opacity,
        toneMapped: false
        // color: 0xff0000,
      });

      const materials = [material];
      const icon = this.icon = new THREE.Sprite(material);
      icon.renderOrder = environment.renderOrder.nav;
      this.setScale();
      mesh.add(icon);
      let titleMaterial;
      const titleTexture = ModelNavComponent.getTitleTexture(item, mode);
      if (titleTexture) {
        titleMaterial = new THREE.SpriteMaterial({
          depthTest: false,
          depthWrite: false,
          transparent: true,
          map: titleTexture,
          sizeAttenuation: false,
          opacity: opacity,
          toneMapped: false
          // color: 0xff0000,
        });
        // console.log(titleTexture);
        const image = titleTexture.image;
        const title = this.title = new THREE.Sprite(titleMaterial);
        const scale = this.iconMinScale;
        title.scale.set(scale * image.width / image.height, scale, scale);
        title.position.set(0, -3.5, 0);
        mesh.add(title);
        materials.push(titleMaterial);
      }
      this.materials = materials;
    }
  }
  onRemoveSprite(sprite) {
    if (sprite) {
      if (sprite.parent) {
        sprite.parent.remove(sprite);
      }
      if (sprite.material.map && sprite.material.map.disposable !== false) {
        sprite.material.map.dispose();
      }
      sprite.material.dispose();
    }
  }
  onDestroy() {
    Interactive.dispose(this.sphere);
    super.onDestroy();
  }

  // called by UpdateViewItemComponent
  onUpdate(item, mesh) {
    this.item = item;
    this.onCreateSprites(mesh, 1);
    if (this.mode === NavModeType.Transparent) {
      if (item.position) {
        mesh.position.fromArray(item.position);
      }
      if (item.rotation) {
        mesh.rotation.fromArray(item.rotation);
      }
      if (item.scale) {
        mesh.scale.fromArray(item.scale);
      }
    } else {
      // const position = new THREE.Vector3().set(...item.position).normalize().multiplyScalar(ModelNavComponent.RADIUS);
      // mesh.position.set(position.x, position.y, position.z);
      mesh.position.fromArray(item.position);
      mesh.rotation.set(0, 0, 0);
      mesh.scale.set(1, 1, 1);
    }
    // console.log('onUpdate', item, mesh.position);
    this.updateHelper();
    /*
    this.onCreate(
    	(mesh, item) => this.onMount(mesh, item),
    	(mesh, item) => this.onDismount(mesh, item)
    );
    */
  }

  // called by WorldComponent
  onDragMove(position, normal, spherical) {
    // console.log('ModelNavComponent.onDragMove', position, normal, spherical);
    const item = this.item;
    const mesh = this.mesh;
    this.editing = true;
    item.showPanel = false;
    if (this.mode === NavModeType.Transparent) {
      if (spherical) {
        position.normalize().multiplyScalar(ModelNavComponent.RADIUS);
        mesh.position.set(position.x, position.y, position.z);
        mesh.lookAt(Host.origin);
      } else {
        mesh.position.set(0, 0, 0);
        mesh.lookAt(normal);
        mesh.position.set(position.x, position.y, position.z);
        mesh.position.add(normal.multiplyScalar(0.01));
      }
    } else {
      if (spherical) {
        position.normalize().multiplyScalar(ModelNavComponent.RADIUS);
        mesh.position.set(position.x, position.y, position.z);
      } else {
        mesh.position.set(position.x, position.y, position.z);
        mesh.position.add(normal.multiplyScalar(0.01));
      }
    }
    this.updateHelper();
  }

  // called by WorldComponent
  onDragEnd() {
    const item = this.item;
    const mesh = this.mesh;
    if (this.mode === NavModeType.Transparent) {
      item.position = mesh.position.toArray();
      item.rotation = mesh.rotation.toArray();
      item.scale = mesh.scale.toArray();
    } else {
      item.position = mesh.position.toArray(); // new THREE.Vector3().copy(mesh.position).normalize().toArray();
    }

    this.editing = false;
  }
}
ModelNavComponent.RADIUS = 100;
ModelNavComponent.meta = {
  selector: '[model-nav]',
  hosts: {
    host: WorldComponent
  },
  outputs: ['over', 'out', 'down', 'link'],
  inputs: ['item', 'view']
};class AgoraComponent extends rxcomp.Component {
  get meetingUrl() {
    if (!this.meetingUrl_) {
      this.meetingUrl_ = new MeetingUrl();
    }
    return this.meetingUrl_;
  }
  get isVirtualTourUser() {
    return [RoleType.Publisher, RoleType.Attendee, RoleType.Streamer, RoleType.Viewer].indexOf(StateService.state.role) !== -1;
  }
  get isEmbed() {
    return this.route && this.route.params.mode === 'embed';
  }
  get isSelfServiceTour() {
    return this.route && this.route.params.mode === 'selfServiceTour';
  }
  get isNavigable() {
    const embedViewId = this.meetingUrl.embedViewId;
    const navigable = embedViewId == null;
    return navigable;
  }
  get isBackButtonVisible() {
    return this.view && (this.view.type.name === ViewType.Media.name || this.view.type.name === ViewType.Model.name);
  }
  get isSelfServiceProposition() {
    return StateService.state.role === RoleType.SelfService && environment.flags.selfServiceProposition;
  }
  get isSelfServiceSupport() {
    return StateService.state.role === RoleType.Publisher && environment.flags.selfServiceProposition && this.meetingUrl.support;
  }
  get showNavInfoToggler() {
    return environment.flags.hideNavInfo && this.state.mode !== UIMode.LiveMeeting && this.view && ModelNavComponent.hasNavInfo(this.view);
  }
  get uiClass() {
    const uiClass = {};
    uiClass[this.state.role] = true;
    // uiClass[this.state.mode] = true;
    uiClass.chat = this.state.chat;
    uiClass.remotes = this.state.mode === UIMode.LiveMeeting;
    uiClass.remoteScreen = this.remoteScreen != null && !this.hasScreenViewItem;
    uiClass.locked = this.locked;
    // uiClass.media = !uiClass.remotes && this.media;
    return uiClass;
  }
  get remoteClass() {
    return `group--remote--${Math.min(9, this.remotes.length)}`;
  }
  get controlled() {
    return StateService.state.controlling && StateService.state.controlling !== StateService.state.uid;
  }
  get controlling() {
    return StateService.state.controlling && StateService.state.controlling === StateService.state.uid;
  }
  get silencing() {
    return StateService.state.silencing;
  }
  get silenced() {
    return StateService.state.silencing && StateService.state.role === RoleType.Streamer;
  }
  get spyed() {
    return StateService.state.spying && StateService.state.spying === StateService.state.uid;
  }
  get spying() {
    return StateService.state.spying && StateService.state.spying !== StateService.state.uid;
  }
  get locked() {
    return this.controlled || this.spying;
  }
  get remoteScreen() {
    return this.remoteScreen_;
  }
  set remoteScreen(remoteScreen) {
    if (this.remoteScreen_ !== remoteScreen) {
      this.remoteScreen_ = remoteScreen;
      setTimeout(() => {
        window.dispatchEvent(new Event('resize'));
      }, 1);
    }
  }
  get pathViews() {
    return ViewService.pathViews;
  }
  onInit() {
    // Logger.log('AgoraComponent.onInit', this.host);
    const {
      node
    } = rxcomp.getContext(this);
    node.classList.remove('hidden');
    this.platform = DeviceService.platform;
    this.route = this.host ? this.host.route : null;
    this.state = {};
    this.hosted = null;
    this.view = null;
    this.previousView = null;
    this.form = null;
    this.local = null;
    this.screen = null;
    this.remoteScreen_ = null;
    this.navmaps = [];
    this.navmap = null;
    // this.media = null;
    this.hasScreenViewItem = false;
    this.remotes = [];
    const vrService = this.vrService = VRService.getService();
    vrService.status$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(status => this.pushChanges());
    this.resolveUser();
  }
  getName(user) {
    return StateService.state.name || MeetingUrl.getName(user);
  }
  getLinkRole() {
    let linkRole = null;
    if (this.isSelfServiceTour) {
      linkRole = RoleType.SelfService;
      return linkRole;
    }
    const meetingUrl = new MeetingUrl();
    const match = (meetingUrl.link || '').match(/\d{9}-(\d{4})-\d{13}/);
    if (match) {
      const index = parseInt(match[1]);
      linkRole = Object.keys(RoleType).reduce((p, c, i) => {
        return i === index ? RoleType[c] : p;
      }, null);
    }
    return linkRole;
  }
  resolveUser() {
    if (this.isEmbed) {
      UserService.temporaryUser$(RoleType.Embed).pipe(operators.first()).subscribe(user => {
        this.initWithUser(user);
      });
    } else if (this.isSelfServiceTour) {
      UserService.overrideUser$(RoleType.SelfService).pipe(operators.first()).subscribe(user => {
        this.initWithUser(user);
      });
    } else {
      UserService.me$().pipe(operators.first()).subscribe(user => {
        this.initWithUser(user);
        // this.userGuard(user);
      });
    }
  }

  userGuard(user) {
    // Logger.log('AgoraComponent.userGuard', user);
    const linkRole = this.getLinkRole();
    if (user && (!linkRole || user.type === linkRole)) {
      this.initWithUser(user);
    } else {
      this.initWithUser({
        type: linkRole
      });
    }
  }
  userGuardRedirect(user) {
    // Logger.log('AgoraComponent.userGuardRedirect', user);
    const linkRole = this.getLinkRole();
    if (user && (!linkRole || linkRole === user.type)) {
      this.initWithUser(user);
    } else if (linkRole === RoleType.Publisher || linkRole === RoleType.Attendee) {
      RouterService.setRouterLink(RoutePipe.transform(':lang.access'));
    } else {
      this.initWithUser({
        type: linkRole
      });
    }
  }
  setNextStatus() {
    let status = AgoraStatus.Idle;
    const state = StateService.state;
    if (state.role === RoleType.SmartDevice) {
      state.name = state.name || 'Smart Device';
    }
    if (!state.checklist) {
      status = AgoraStatus.Checklist;
    } else if (!state.link) {
      status = AgoraStatus.Link;
    } else if (!state.user.id && (state.role === RoleType.Publisher || state.role === RoleType.Attendee)) {
      status = AgoraStatus.Login;
    } else if (!state.name) {
      status = AgoraStatus.Name;
    } else if (state.role !== RoleType.Viewer && state.role !== RoleType.SmartDevice) {
      status = AgoraStatus.Device;
    } else {
      status = AgoraStatus.ShouldConnect;
    }
    StateService.patchState({
      status
    });
    return status;
  }
  getPathId() {
    const meetingUrl = new MeetingUrl();
    let pathId = meetingUrl.pathId;
    if (pathId) {
      // Logger.log('AgoraComponent.getPathId', pathId);
      return parseInt(pathId);
    }
    const link = meetingUrl.link;
    if (link) {
      const meetingId = new MeetingId(link);
      pathId = meetingId.pathId;
    }
    // Logger.log('AgoraComponent.getPathId', pathId);
    return pathId;
  }
  initWithUser(user) {
    // Logger.log('AgoraComponent.initWithUser', user);
    const meetingUrl = new MeetingUrl();
    const link = meetingUrl.link;
    const pathId = this.getPathId();
    const role = this.getLinkRole() || (user ? user.type : null);
    switch (role) {
      case RoleType.SelfService:
        if (!user || user.type !== RoleType.SelfService && user.type !== RoleType.Publisher) {
          RouterService.setRouterLink(RoutePipe.transform(':lang.access'));
          return;
        } else {
          // forcing role type to RoleType.SelfService
          user = Object.assign({}, user, {
            type: RoleType.SelfService
          });
        }
        break;
      default:
        user = user || {
          type: role
        };
        if (role !== user.type) {
          user = {
            type: role
          };
        }
    }
    // Logger.log('AgoraComponent.initWithUser', role, user);
    const mode = UserService.getMode(role);
    const name = this.getMeetingName(user);
    // const name = meetingUrl.name || this.getName(user);
    const checklist = null;
    const hosted = role === RoleType.Publisher ? true : false;
    const live = role === RoleType.SelfService || role === RoleType.Embed || DEBUG ? false : true;
    const navigable = this.isNavigable;
    const state = {
      user: user,
      role: role,
      mode: mode,
      name: name,
      checklist: checklist,
      pathId: pathId,
      link: link,
      channelName: environment.channelName,
      uid: null,
      status: AgoraStatus.Idle,
      connecting: false,
      connected: false,
      controlling: false,
      spying: false,
      silencing: false,
      hosted: hosted,
      live: live,
      navigable: navigable,
      cameraMuted: false,
      audioMuted: false,
      showNavInfo: true
    };
    StateService.state = state;
    StateService.state$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(state => {
      this.state = state;
      this.hosted = state.hosted;
      this.pushChanges();
      // console.log(state);
      this.locked ? document.body.classList.add('locked') : document.body.classList.remove('locked');
    });
    this.initAgora();
  }
  getMeetingName(user) {
    const meetingUrl = new MeetingUrl();
    let name = null;
    if (environment.flags.useExtendedUserInfo) {
      name = meetingUrl.firstName && meetingUrl.lastName ? `${meetingUrl.firstName} ${meetingUrl.lastName}` : null;
    } else {
      name = meetingUrl.name ? meetingUrl.name : null;
    }
    if (!name && user.firstName && user.lastName) {
      name = `${user.firstName} ${user.lastName}`;
    }
    return name;
  }
  viewObserver$() {
    return ViewService.data$().pipe(operators.switchMap(data => {
      // Logger.log('AgoraComponent.viewObserver$', 'pathId', StateService.state.pathId);
      return PathService.getCurrentPath$(StateService.state.pathId).pipe(operators.switchMap(path => {
        return ViewService.hostedView$(data, path);
      }));
    }),
    /*
    tap(view => {
    	this.view = null;
    	this.pushChanges();
    }),
    delay(1),
    */
    operators.map(view => {
      // Logger.log('AgoraComponent.viewObserver$', view);
      // !!! move navToView to user action?
      if (this.agora) {
        this.agora.navToView(view.id, view.keepOrientation, view.useLastOrientation);
      }
      this.previousView = this.view;
      this.view = view;
      this.setNavmap(view);
      this.hasScreenViewItem = view.items.find(x => MediaLoader.isPublisherScreen(x) || MediaLoader.isAttendeeScreen(x)) != null;
      this.pushChanges();
      const state = this.state;
      GtmService.push({
        action: 'b-here-view',
        viewId: view.id,
        userType: state.role // aggiunto
      });

      return view;
    }));
  }
  load(callback) {
    this.loadNavmaps();
    this.viewObserver$().pipe(operators.takeUntil(this.unsubscribe$)).subscribe(view => {
      // Logger.log('AgoraComponent.load', view);
      if (typeof callback === 'function') {
        callback();
        callback = null;
      }
    });
  }
  loadNavmaps() {
    if (environment.flags.navmaps) {
      NavmapService.navmapGet$().pipe(operators.first()).subscribe(navmaps => {
        this.navmaps = navmaps;
      });
    }
  }
  setNavmap(view) {
    const navmaps = this.navmaps;
    const navmap = (navmaps || []).find(x => (x.items || []).find(i => i.viewId === view.id) != null) || null;
    // Logger.log('AgoraComponent.setNavmap', navmap);
    this.navmap = navmap;
  }
  toggleNavmap() {
    StateService.patchState({
      showNavmap: !StateService.state.showNavmap
    });
  }
  onNavmapItem(item) {
    StateService.patchState({
      showNavmap: false
    });
    this.onNavTo(item);
  }
  loadAndConnect(preferences) {
    this.load(() => {
      this.connect(preferences);
    });
  }
  initAgora() {
    if (this.state.role === RoleType.SelfService || this.state.role === RoleType.Embed || DEBUG) {
      this.load(() => {
        StateService.patchState({
          status: AgoraStatus.Connected,
          hosted: true
        });
      });
      this.checkSelfServiceProposition();
      this.checkSelfServiceAudio();
    } else {
      AgoraChecklistService.isChecked$().pipe(operators.first()).subscribe(checked => {
        StateService.patchState({
          checklist: checked
        });
        this.agora = AgoraService.getSingleton();
        this.getLinkRole();
        this.setNextStatus();
        // Logger.log('AgoraComponent.initAgora', status, role);
      });
    }

    StreamService.local$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(local => {
      // Logger.log('AgoraComponent.initAgora', 'StreamService.local$', local);
      this.local = local;
      this.pushChanges();
    });
    StreamService.screen$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(screen => {
      // Logger.log('AgoraComponent.initAgora', 'StreamService.screen$', screen);
      if (this.screen === this.remoteScreen) {
        this.remoteScreen = null;
      }
      this.screen = screen;
      this.remoteScreen = screen || this.remoteScreen;
      this.pushChanges();
    });
    StreamService.orderedRemotes$().pipe(operators.takeUntil(this.unsubscribe$)).subscribe(remotes => {
      this.remotes = [];
      this.remoteScreen = this.screen;
      remotes.forEach(x => {
        if (x.clientInfo && x.clientInfo.screenUid === x.streamId) {
          this.remoteScreen = x;
        } else {
          this.remotes.push(x);
        }
      });
      // Logger.log('AgoraComponent.initAgora', 'StreamService.orderedRemotes$', this.remotes, this.remoteScreen, remotes.map(x => `${x.clientInfo ? x.clientInfo.uid : 'null'}-${x.clientInfo ? x.clientInfo.screenUid : 'null'}`).join(','));
      this.pushChanges();
    });
    /*
    MediaLoader.events$.pipe(
    	tap(event => {
    		if (event instanceof MediaLoaderPlayEvent) {
    			this.media = event.loader;
    			// this.pushChanges();
    		} else if (event instanceof MediaLoaderDisposeEvent) {
    			if (this.media === event.loader) {
    				this.media = null;
    				// this.pushChanges();
    			}
    		}
    		// Logger.log('AgoraComponent.initAgora', 'MediaLoader.events$', event);
    	}),
    	takeUntil(this.unsubscribe$)
    ).subscribe();
    */
    MessageService.out$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(message => {
      // Logger.log('AgoraComponent.initAgora', 'MessageService.out$', message);
      switch (message.type) {
        case MessageType.ChannelMembers:
          if (this.isSelfServiceSupport) {
            const members = message.members;
            // Logger.log('AgoraComponent.initAgora', 'MessageService.out$', members, members.length);
            if (members.length > 0) {
              ToastService.open$({
                message: LabelPipe.transform('bhere_support_request_sent'),
                type: ToastType.Alert,
                position: ToastPosition.BottomRight
              });
              MessageService.send({
                type: MessageType.SupportRequest
              });
            } else {
              ToastService.open$({
                message: LabelPipe.transform('bhere_support_request_leaved'),
                type: ToastType.Alert,
                position: ToastPosition.BottomRight
              });
            }
          }
          break;
        case MessageType.SupportRequest:
          if (this.isSelfServiceProposition) {
            this.openSupportRequestDialog(message.clientInfo);
          }
          break;
        case MessageType.SupportRequestAccepted:
          ToastService.open$({
            message: LabelPipe.transform('bhere_support_request_accepted'),
            type: ToastType.Alert,
            position: ToastPosition.BottomRight
          });
          break;
        case MessageType.SupportRequestRejected:
          ToastService.open$({
            message: LabelPipe.transform('bhere_support_request_rejected'),
            type: ToastType.Alert,
            position: ToastPosition.BottomRight
          });
          break;
        case MessageType.RemoteSilencing:
          StateService.patchState({
            silencing: message.silencing
          });
          this.setAudio(message.silencing);
          break;
        case MessageType.NavToView:
          this.onRemoteNavTo(message);
          break;
        case MessageType.Mode:
          StateService.patchState({
            mode: message.mode
          });
          window.dispatchEvent(new Event('resize'));
          break;
        case MessageType.NavInfo:
          this.hidePanels();
          StateService.patchState({
            showNavInfo: message.showNavInfo
          });
          break;
        case MessageType.AddLike:
          ViewService.setViewLike$(message).pipe(operators.first()).subscribe(view => this.showLove(view));
          break;
        case MessageType.ChatMessage:
          if (!StateService.state.chat) {
            StateService.patchState({
              chatDirty: true
            });
          }
          break;
      }
    });
    MessageService.in$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(message => {
      if (this.agora) {
        this.agora.sendMessage(message);
      }
    });
    this.fullscreen$().pipe(operators.takeUntil(this.unsubscribe$)).subscribe();
    if (this.agora && StateService.state.status === AgoraStatus.ShouldConnect) {
      this.loadAndConnect();
    }
  }
  onChecked(checklist) {
    // Logger.log('AgoraComponent.onChecked', checklist);
    StateService.patchState({
      checklist: true
    });
    this.setNextStatus();
  }
  onLink(link) {
    const meetingId = new MeetingId(link);
    // Logger.log('AgoraComponent.onLink', meetingId);
    const pathId = meetingId.pathId;
    const role = this.getLinkRole();
    const mode = UserService.getMode(role);
    const user = StateService.state.user;
    if ((role === RoleType.Publisher || role === RoleType.Attendee) && (!user.id || user.type !== role)) {
      StateService.patchState({
        link,
        pathId,
        role,
        mode,
        status: AgoraStatus.Login
      });
    } else if (StateService.state.name) {
      if (role === RoleType.Viewer || role === RoleType.SmartDevice) {
        StateService.patchState({
          link,
          pathId,
          role,
          mode
        });
        this.loadAndConnect();
      } else {
        StateService.patchState({
          link,
          pathId,
          role,
          mode,
          status: AgoraStatus.Device
        });
      }
    } else {
      StateService.patchState({
        link,
        pathId,
        role,
        mode,
        status: AgoraStatus.Name
      });
    }
  }
  onLogin(user) {
    const name = this.getName(user);
    if (name) {
      StateService.patchState({
        user,
        name,
        status: AgoraStatus.Device
      });
    } else {
      StateService.patchState({
        user,
        status: AgoraStatus.Name
      });
    }
  }
  onName(name) {
    if (StateService.state.role === RoleType.Viewer || StateService.state.role === RoleType.SmartDevice) {
      StateService.patchState({
        name
      });
      this.loadAndConnect();
    } else {
      StateService.patchState({
        name,
        status: AgoraStatus.Device
      });
    }
  }
  onEnter(preferences) {
    this.loadAndConnect(preferences);
  }
  connect(preferences) {
    // Logger.log('AgoraComponent.connect', preferences);
    this.agora.connect$(preferences).pipe(operators.takeUntil(this.unsubscribe$)).subscribe();
    const state = this.state;
    // Logger.log('AgoraComponent.connect', this.state.role);
    if (state.role === RoleType.SelfService) {
      GtmService.push({
        action: 'b-here-tour',
        userType: state.role
      });
    } else if (state.role === RoleType.Embed) {
      GtmService.push({
        action: 'b-here-embed',
        userType: state.role
      });
    } else {
      const meetingUrl = new MeetingUrl();
      const sharedMeetingId = state.link.replace(/-\d+-/, '-');
      const log = {
        meetingId: state.link,
        sharedMeetingId: sharedMeetingId,
        userType: state.role
      };
      if (environment.flags.useExtendedUserInfo) {
        // !!! update server side logic to use extended user info
        log.firstName = meetingUrl.firstName;
        log.lastName = meetingUrl.lastName;
        log.email = meetingUrl.email;
      } else {
        log.fullName = state.name;
      }
      // Logger.log('AgoraComponent.connect', log);
      UserService.log$(log).pipe(operators.first()).subscribe();
      // do not share user data in gtm
      GtmService.push({
        action: 'b-here-meeting',
        meetingId: state.link,
        sharedMeetingId: sharedMeetingId,
        userType: state.role
      });
    }
  }
  disconnect() {
    if (this.agora) {
      this.agora.leaveChannel().then(() => {
        // StateService.patchState({ status: AgoraStatus.Disconnected, connected: false });
        // window.location.href = window.location.href;
        // window.location.replace(window.location.href);
        window.location.reload();
      }, console.log);
    } else {
      this.patchState({
        connecting: false,
        connected: false
      });
    }
  }
  onNavTo(item) {
    const viewId = item.viewId;
    const view = this.pathViews.find(x => x.id === viewId);
    if (view) {
      // Logger.log('AgoraComponent.onNavTo', item, view);
      ViewService.action = {
        viewId,
        keepOrientation: item.keepOrientation,
        useLastOrientation: item.useLastOrientation
      };
      this.onHandleHook(view, item);
    }
  }
  onNavLink(event) {
    // Logger.log('AgoraComponent.onNavLink', event.link.href);
    ModalService.open$({
      iframe: event.link.href
    }).pipe(operators.first()).subscribe(_ => {
      MessageService.send({
        type: MessageType.NavLinkClose,
        itemId: event.item.id
      });
    });
  }
  onRemoteNavTo(message) {
    const viewId = message.viewId;
    const gridIndex = message.gridIndex;
    if (viewId && ViewService.viewId !== viewId) {
      const view = this.pathViews.find(x => x.id === viewId);
      if (view) {
        // Logger.log('AgoraComponent.onRemoteNavTo', message, view);
        ViewService.action = {
          viewId,
          keepOrientation: message.keepOrientation,
          useLastOrientation: message.useLastOrientation
        };
        if (gridIndex != null && view instanceof PanoramaGridView) {
          view.index = gridIndex;
        }
      }
      // Logger.log('AgoraComponent.onRemoteNavTo', viewId, gridIndex);
    }
  }

  onHandleHook(view, item) {
    switch (item.hook) {
      case 'ToggleWishlist':
        {
          const payload = {
            viewId: view.id,
            itemId: item.id
          };
          WishlistService.toggle$(payload).pipe(operators.switchMap(items => {
            payload.added = WishlistService.has(payload);
            return WebhookService.send$(item.hook, payload, item.extra);
          }), operators.first()).subscribe(response => {
            Logger.log('AgoraComponent.onHandleHook', response);
            item.added = payload.added;
            this.pushChanges();
          });
          break;
        }
    }
  }

  // !!! why locally?
  patchState(state) {
    this.state = Object.assign({}, this.state, state);
    this.pushChanges();
    // console.log(this.state);
  }

  toggleCamera() {
    if (this.agora) {
      this.agora.toggleCamera();
    } else {
      this.patchState({
        cameraMuted: !this.state.cameraMuted
      });
    }
  }
  toggleAudio() {
    if (this.agora) {
      this.agora.toggleAudio();
    } else {
      this.patchState({
        audioMuted: !this.state.audioMuted
      });
    }
  }
  setAudio(audioMuted) {
    if (this.agora) {
      this.agora.setAudio(audioMuted);
    } else {
      this.patchState({
        audioMuted
      });
    }
  }
  toggleScreen() {
    if (this.agora) {
      this.agora.toggleScreen();
    } else {
      this.patchState({
        screen: !this.state.screen
      });
    }
    window.dispatchEvent(new Event('resize'));
  }
  toggleVolume() {
    const volumeMuted = !this.state.volumeMuted;
    StateService.patchState({
      volumeMuted
    });
    const selfServiceAudio = this.selfServiceAudio;
    if (selfServiceAudio) {
      selfServiceAudio.volume = volumeMuted ? 0 : 0.5;
    }
  }
  toggleMode() {
    if (this.agora && StateService.state.role === RoleType.Publisher) {
      this.agora.toggleMode();
    } else {
      const mode = this.state.mode === UIMode.VirtualTour ? UIMode.LiveMeeting : UIMode.VirtualTour;
      StateService.patchState({
        mode
      });
      // this.patchState({ mode });
    }

    window.dispatchEvent(new Event('resize'));
  }
  toggleFullScreen() {
    const {
      node
    } = rxcomp.getContext(this);
    const fullScreen = !this.state.fullScreen;
    if (fullScreen) {
      if (node.requestFullscreen) {
        node.requestFullscreen();
      } else if (node.webkitRequestFullscreen) {
        node.webkitRequestFullscreen();
      } else if (node.msRequestFullscreen) {
        node.msRequestFullscreen();
      }
    } else {
      if (document.exitFullscreen) {
        document.exitFullscreen();
      } else if (document.webkitExitFullscreen) {
        document.webkitExitFullscreen();
      } else if (document.msExitFullscreen) {
        document.msExitFullscreen();
      }
    }
    // StateService.patchState({ fullScreen });
  }

  fullscreen$() {
    return rxjs.fromEvent(document, 'fullscreenchange').pipe(operators.tap(_ => {
      const fullScreen = document.fullscreenElement != null;
      // Logger.log('AgoraComponent.fullscreen$', fullScreen);
      StateService.patchState({
        fullScreen
      });
    }));
  }
  toggleChat() {
    StateService.patchState({
      chat: !StateService.state.chat,
      chatDirty: false
    });
    window.dispatchEvent(new Event('resize'));
  }
  onChatClose() {
    StateService.patchState({
      chat: false
    });
    window.dispatchEvent(new Event('resize'));
  }
  toggleNavInfo() {
    this.hidePanels();
    if (this.agora) {
      this.agora.toggleNavInfo();
    } else {
      this.patchState({
        showNavInfo: !this.state.showNavInfo
      });
    }
  }
  onBack() {
    // Logger.log('AgoraCompoent.onBack');
    if (this.previousView && this.view && this.previousView.id !== this.view.id) {
      ViewService.action = {
        viewId: this.previousView.id,
        useLastOrientation: true
      };
    }
  }
  hidePanels() {
    this.view.items.forEach(item => item.showPanel = false);
  }
  onToggleControl(remoteId) {
    if (this.agora) {
      this.agora.toggleControl(remoteId);
    } else {
      const controlling = this.state.controlling === remoteId ? null : remoteId;
      this.patchState({
        controlling,
        spying: false
      });
    }
  }
  onToggleSilence() {
    if (this.agora) {
      this.agora.toggleSilence();
    } else {
      this.patchState({
        silencing: !this.state.silencing
      });
    }
  }
  onToggleSpy(remoteId) {
    if (this.agora) {
      this.agora.toggleSpy(remoteId);
    } else {
      const spying = this.state.spying === remoteId ? null : remoteId;
      this.patchState({
        spying,
        controlling: false
      });
    }
  }
  addLike() {
    ViewService.viewLike$(this.view).pipe(operators.first()).subscribe(view => {
      if (view) {
        this.view.liked = true; // view.liked;
        this.showLove(view);
        // this.view.likes = view.likes;
        // this.pushChanges();
        MessageService.send({
          type: MessageType.AddLike,
          viewId: this.view.id,
          likes: this.view.likes
        });
      }
    });
  }
  showLove(view) {
    if (view && this.view.id === view.id) {
      const skipTimeout = this.view.showLove;
      this.view.likes = view.likes;
      this.view.showLove = true;
      this.pushChanges();
      if (!skipTimeout) {
        setTimeout(() => {
          this.view.showLove = false;
          this.pushChanges();
        }, 3100);
      }
    }
  }
  tryInAr() {
    if (this.platform === DevicePlatform.IOS || this.platform === DevicePlatform.Android) {
      TryInARModalComponent.openInAR(this.view);
    } else {
      ModalService.open$({
        template: TryInARModalComponent.chunk(),
        data: this.view
      }).pipe(operators.first()).subscribe(event => {
        // this.pushChanges();
      });
    }
  }
  checkSelfServiceProposition() {
    // self service proposition
    const isSelfServiceProposition = this.isSelfServiceProposition;
    // Logger.log('AgoraComponent.checkSelfServiceProposition', isSelfServiceProposition);
    if (isSelfServiceProposition) {
      AgoraChecklistService.check$().pipe(operators.first()).subscribe(event => {
        const meetingId = new MeetingId({
          pathId: StateService.state.pathId
        });
        const meetingIdRoles = meetingId.toRoles();
        const meetingUrl = new MeetingUrl({
          link: meetingIdRoles.id,
          support: true
        });
        const href = window.location.origin + meetingUrl.toGuidedTourUrl();
        Logger.log('AgoraComponent.checkSelfServiceProposition', href);
        UserService.selfServiceSupportRequest$(StateService.state.user, meetingIdRoles.id, href).pipe(operators.first()).subscribe(_ => {
          const name = this.getName(StateService.state.user);
          StateService.patchState({
            checklist: true,
            link: meetingIdRoles.idSelfService,
            name
          });
          this.agora = AgoraService.getSingleton();
          this.connect();
        });
      }, error => {
        Logger.error('AgoraComponent.checkSelfServiceProposition.error', error);
        /*
        UserService.selfServiceTourSupportFailedRequest$(StateService.state.user).pipe(
        	first(),
        ).subscribe();
        */
      });
    }
  }

  checkSelfServiceAudio() {
    if (StateService.state.role === RoleType.SelfService && environment.selfServiceAudio) {
      const selfServiceAudio = document.createElement('audio');
      selfServiceAudio.setAttribute('playsinline', 'true');
      selfServiceAudio.setAttribute('autoplay', 'true');
      selfServiceAudio.setAttribute('loop', 'true');
      selfServiceAudio.volume = 0.5;
      selfServiceAudio.src = environment.getPath(environment.selfServiceAudio);
      const {
        node
      } = rxcomp.getContext(this);
      node.parentNode.appendChild(selfServiceAudio);
      this.selfServiceAudio = selfServiceAudio;
      MediaLoader.events$.pipe(operators.tap(event => {
        // Logger.log('AgoraComponent.checkSelfServiceAudio', 'MediaLoader.event$', event);
        if (event instanceof MediaLoaderPlayEvent) {
          selfServiceAudio.pause();
          // selfServiceAudio.volume = 0;
        } else if (event instanceof MediaLoaderPauseEvent || event instanceof MediaLoaderDisposeEvent) {
          selfServiceAudio.play();
          // selfServiceAudio.volume = 0.5;
        }
      }), operators.takeUntil(this.unsubscribe$)).subscribe();
    }
  }
  openSupportRequestDialog(clientInfo) {
    ToastService.open$({
      message: LabelPipe.transform('bhere_support_request_dialog'),
      acceptMessage: LabelPipe.transform('bhere_support_request_dialog_accept'),
      rejectMessage: LabelPipe.transform('bhere_support_request_dialog_reject'),
      type: ToastType.Dialog,
      position: ToastPosition.BottomRight
    }).pipe(operators.takeUntil(this.unsubscribe$)).subscribe(event => {
      if (event instanceof ToastResolveEvent) {
        MessageService.send({
          type: MessageType.SupportRequestAccepted
        });
        const name = StateService.state.name;
        const meetingId = new MeetingId(StateService.state.link);
        meetingId.role = RoleType.Streamer;
        const options = {
          link: meetingId.toString()
        };
        if (environment.flags.useExtendedUserInfo) {
          const user = StateService.state.user;
          options.firstName = user.firstName;
          options.lastName = user.lastName;
          options.email = user.email;
        } else {
          options.name = name;
        }
        const meetingUrl = new MeetingUrl(options);
        const href = meetingUrl.toGuidedTourUrl();
        setTimeout(() => {
          window.location.href = href;
        }, 1000);
      } else {
        MessageService.send({
          type: MessageType.SupportRequestRejected
        });
      }
    });
    /*
    ModalService.open$({ template: SupportRequestModalComponent.chunk(), data: clientInfo }).pipe(
    	first(),
    ).subscribe(event => {
    	if (event instanceof ModalResolveEvent) {
    		MessageService.send({ type: MessageType.SupportRequestAccepted });
    		const name = StateService.state.name;
    		const meetingId = new MeetingId(StateService.state.link);
    		meetingId.role = RoleType.Streamer;
    		const meetingUrl = new MeetingUrl({ link: meetingId.toString(), name });
    		const href = meetingUrl.toGuidedTourUrl();
    		setTimeout(() => {
    			window.location.href = href;
    		}, 1000);
    	} else {
    		MessageService.send({ type: MessageType.SupportRequestRejected });
    	}
    });
    */
  }

  /*
  onPrevent(event) {
  	event.preventDefault();
  	event.stopImmediatePropagation();
  }
  */
}

AgoraComponent.meta = {
  selector: '[agora-component]',
  hosts: {
    host: RouterOutletStructure
  },
  template: /* html */`
	<div class="page page--agora">
		${CHUNK_BACKGROUND}
		<!-- Status Checklist -->
		<div class="ui ui--info ui--info-centered" *if="state.status == 'checklist'" [agora-checklist] (checked)="onChecked($event)"></div>
		<!-- Status Link -->
		<div class="ui ui--info ui--info-centered" *if="state.status == 'link'" [agora-link] (link)="onLink($event)"></div>
		<!-- Status Login -->
		<div class="ui ui--info ui--info-centered" *if="state.status == 'login'" [agora-login] (login)="onLogin($event)"></div>
		<!-- Status Name -->
		<div class="ui ui--info ui--info-centered" *if="state.status == 'name' || (state.status == 'disconnected' && state.role === 'viewer')" [agora-name] (name)="onName($event)"></div>
		<!-- Status Device -->
		<div class="ui ui--info" *if="state.status == 'device' || (state.status == 'disconnected' && state.role !== 'viewer')" [agora-device] (enter)="onEnter($event)"></div>
		${CHUNK_VIRTUAL_TOUR}
		${CHUNK_SMART_DEVICE}
		${CHUNK_SELF_SERVICE_TOUR}
		${CHUNK_EMBED}
		<header>
			${CHUNK_LOGO}
			${CHUNK_LANGUAGE}
		</header>
		<footer *if="state.status != 'connected'">
			<span class="group--colophon">
				${CHUNK_CREDITS}
				${CHUNK_COPYRIGHT}
			</span>
			<a [routerLink]="':lang.editor' | route" class="btn--absolute" *if="('editor' | flag) && !('deployed' | flag) && state.role == 'publisher' && (state.status == 'checklist' || state.status == 'link')">
				<span [innerHTML]="'bhere_editor' | label"></span> <svg class="edit" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#edit"></use></svg>
			</a>
		</footer>
	</div>
	`
};class AssetService {
  static assetCreate$(asset) {
    return HttpService.post$('/api/asset', asset).pipe(operators.map(asset => mapAsset(asset)));
  }
  static assetUpdate$(asset) {
    return HttpService.put$(`/api/asset/${asset.id}`, asset).pipe(operators.map(asset => mapAsset(asset)));
  }
  static assetDelete$(asset) {
    if (asset && asset.id) {
      return HttpService.delete$(`/api/asset/${asset.id}`).pipe(operators.map(() => null));
    } else {
      return rxjs.of(null);
    }
  }
  static localizedAssetCreate$(lg, asset) {
    return HttpService.post$(`/api/${lg}/asset`, asset).pipe(operators.map(asset => mapAsset(asset)));
  }
  static localizedAssetUpdate$(lg, asset) {
    return HttpService.put$(`/api/${lg}/asset/${asset.id}`, asset).pipe(operators.map(asset => mapAsset(asset)));
  }
  static upload$(files) {
    const formData = new FormData();
    files.forEach(file => formData.append('file', file, file.name));
    const xhr = new XMLHttpRequest();
    const events$ = rxjs.merge(rxjs.fromEvent(xhr.upload, 'loadstart'), rxjs.fromEvent(xhr.upload, 'progress'), rxjs.fromEvent(xhr.upload, 'load'), rxjs.fromEvent(xhr, 'readystatechange')).pipe(operators.map(event => {
      switch (event.type) {
        case 'readystatechange':
          if (xhr.readyState === 4) {
            return JSON.parse(xhr.responseText);
          } else {
            return null;
          }
        default:
          return null;
      }
    }), operators.filter(event => event !== null));
    xhr.open('POST', '/api/upload/', true);
    xhr.send(formData);
    return events$;
  }
  static createOrUpdateAsset$(uploads, control) {
    const upload = uploads[0];
    const asset = Asset.fromUrl(upload.url);
    if (control.value && control.value.id) {
      // !!! must check for id
      asset.id = control.value.id;
      return AssetService.assetUpdate$(asset);
    } else {
      return AssetService.assetCreate$(asset);
    }
  }
  static createOrUpdateLocalizedAsset$(uploads, control, lg) {
    const upload = uploads[0];
    const asset = Asset.fromUrl(upload.url);
    if (control.value && control.value.id) {
      // !!! must check for id
      asset.id = control.value.id;
      return AssetService.localizedAssetUpdate$(lg, asset);
    } else {
      return AssetService.localizedAssetCreate$(lg, asset);
    }
  }
  static assetDidChange(previous, current) {
    let previousId = null;
    let previousFile = null;
    let currentId = null;
    let currentFile = null;
    if (previous) {
      previousId = previous.id;
      previousFile = previous.file;
    }
    if (current) {
      currentId = current.id;
      currentFile = current.file;
    }
    return previousId !== currentId || previousFile !== currentFile;
  }
}class EditorService {
  static data$() {
    if (!this.data$_) {
      this.data$_ = HttpService.get$('/api/view').pipe(operators.map(data => {
        data.views = data.views.map(view => mapView(view));
        return data;
      }), operators.shareReplay(1));
    }
    return this.data$_;
  }
  static viewIdOptions$() {
    return this.data$().pipe(operators.map(data => {
      const options = data.views.filter(x => x.type.name !== ViewType.WaitingRoom.name).map(view => ({
        id: view.id,
        name: view.name
      }));
      options.unshift({
        id: null,
        name: 'select'
      }); // LabelPipe.transform('select')
      return options;
    }));
  }
  static viewCreate$(view) {
    return HttpService.post$('/api/view', view).pipe(operators.map(view => mapView(view)));
  }
  static viewUpdate$(view) {
    return HttpService.put$(`/api/view/${view.id}`, view.payload).pipe(operators.map(view => mapView(view)));
  }
  static viewDelete$(view) {
    return HttpService.delete$(`/api/view/${view.id}`);
  }
  static getTile(view) {
    let tile;
    if (view.type.name === ViewType.PanoramaGrid.name) {
      tile = view.tiles[view.index];
    }
    return tile;
  }
  static inferItemCreate$(view, item) {
    const tile = this.getTile(view);
    if (tile) {
      return this.tileItemCreate$(view, tile, item);
    } else {
      return this.itemCreate$(view, item);
    }
  }
  static inferItemUpdate$(view, item) {
    const tile = this.getTile(view);
    if (tile) {
      return this.tileItemUpdate$(view, tile, item);
    } else {
      return this.itemUpdate$(view, item);
    }
  }
  static inferItemDelete$(view, item) {
    const tile = this.getTile(view);
    if (tile) {
      return this.tileItemDelete$(view, tile, item);
    } else {
      return this.itemDelete$(view, item);
    }
  }
  static inferItemUpdateResult$(view, item) {
    const tile = this.getTile(view);
    let currentItem;
    if (tile) {
      currentItem = tile.navs.find(i => i.id === item.id);
    } else {
      currentItem = view.items.find(i => i.id === item.id);
    }
    if (currentItem) {
      Object.assign(currentItem, item);
    }
  }
  static inferItemDeleteResult$(view, item) {
    const tile = this.getTile(view);
    let items;
    if (tile) {
      items = tile.navs;
    } else {
      items = view.items;
    }
    if (items) {
      const index = items.indexOf(item);
      if (index !== -1) {
        items.splice(index, 1);
      }
      if (tile) {
        view.updateCurrentItems();
      }
    }
  }
  static itemCreate$(view, item) {
    return HttpService.post$(`/api/view/${view.id}/item`, item).pipe(operators.map(item => mapViewItem(item)));
  }
  static itemUpdate$(view, item) {
    return HttpService.put$(`/api/view/${view.id}/item/${item.id}`, item.payload).pipe(operators.map(item => mapViewItem(item)));
  }
  static itemDelete$(view, item) {
    return HttpService.delete$(`/api/view/${view.id}/item/${item.id}`);
  }
  static tileItemCreate$(view, tile, item) {
    return HttpService.post$(`/api/view/${view.id}/tile/${tile.id}/item`, item).pipe(operators.map(item => mapViewItem(item)));
  }
  static tileItemUpdate$(view, tile, item) {
    return HttpService.put$(`/api/view/${view.id}/tile/${tile.id}/item/${item.id}`, item.payload).pipe(operators.map(item => mapViewItem(item)));
  }
  static tileItemDelete$(view, tile, item) {
    return HttpService.delete$(`/api/view/${view.id}/tile/${tile.id}/item/${item.id}`);
  }
}class CurvedPlaneModalComponent extends rxcomp.Component {
  get data() {
    let data = null;
    const {
      parentInstance
    } = rxcomp.getContext(this);
    if (parentInstance instanceof ModalOutletComponent) {
      data = parentInstance.modal.data;
    }
    return data;
  }
  get view() {
    let view = null;
    const data = this.data;
    if (data) {
      view = data.view;
    }
    return view;
  }
  get object() {
    const object = new THREE.Object3D();
    const data = this.data;
    if (data) {
      const position = data.hit.position.clone();
      const normal = data.hit.normal.clone();
      const spherical = data.hit.spherical;
      if (spherical) {
        position.normalize().multiplyScalar(20);
        object.position.copy(position);
        object.lookAt(Host.origin);
      } else {
        object.lookAt(normal);
        object.position.set(position.x, position.y, position.z);
        object.position.add(normal.multiplyScalar(0.01));
      }
    }
    return object;
  }
  onInit() {
    const object = this.object;
    const form = this.form = new rxcompForm.FormGroup({
      type: ViewItemType.CurvedPlane,
      position: new rxcompForm.FormControl(object.position.toArray(), rxcompForm.RequiredValidator()),
      rotation: new rxcompForm.FormControl(object.rotation.toArray(), rxcompForm.RequiredValidator()),
      scale: new rxcompForm.FormControl([1, 1, 1], rxcompForm.RequiredValidator()),
      radius: new rxcompForm.FormControl(35, rxcompForm.RequiredValidator()),
      height: new rxcompForm.FormControl(20, rxcompForm.RequiredValidator()),
      arc: new rxcompForm.FormControl(90, rxcompForm.RequiredValidator()),
      asset: null
    });
    this.controls = form.controls;
    form.changes$.subscribe(changes => {
      // console.log('CurvedPlaneModalComponent.form.changes$', changes, form.valid, form);
      this.pushChanges();
    });
  }
  onSubmit() {
    if (this.form.valid) {
      const item = Object.assign({}, this.form.value);
      // item.viewId = parseInt(item.viewId);
      // console.log('CurvedPlaneModalComponent.onSubmit', this.view, item);
      EditorService.inferItemCreate$(this.view, item).pipe(operators.first()).subscribe(response => {
        // console.log('CurvedPlaneModalComponent.onSubmit.success', response);
        ModalService.resolve(response);
      }, error => console.log('CurvedPlaneModalComponent.onSubmit.error', error));
    } else {
      this.form.touched = true;
    }
  }
  onClose() {
    ModalService.reject();
  }
}
CurvedPlaneModalComponent.meta = {
  selector: '[curved-plane-modal]',
  template: /* html */`
		<div class="modal__header">
			<button type="button" class="btn--close" (click)="onClose()">
				<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#close"></use></svg>
			</button>
		</div>
		<div class="container">
			<div class="form">
				<div class="title">Create Curved Plane.</div>
				<form [formGroup]="form" (submit)="onSubmit()" name="form" role="form" novalidate autocomplete="off">
					<div class="form-controls">
						<!-- <div control-text [control]="controls.title" label="Title"></div> -->
						<div control-vector [control]="controls.position" label="Position" [precision]="2" [disabled]="true"></div>
						<div control-vector [control]="controls.rotation" label="Rotation" [precision]="3" [increment]="Math.PI / 360" [disabled]="true"></div>
						<!--
						<div control-vector [control]="controls.scale" label="Scale" [precision]="2" [disabled]="true"></div>
						<div control-number [control]="controls.radius" label="Radius" [precision]="2" [disabled]="true"></div>
						<div control-number [control]="controls.height" label="Height" [precision]="2" [disabled]="true"></div>
						<div control-number [control]="controls.arc" label="Arc" [precision]="0" [disabled]="true"></div>
						-->
						<div control-localized-asset [control]="controls.asset" label="Image or Video" accept="image/jpeg, video/mp4"></div>
					</div>
					<div class="group--cta">
						<button type="submit" class="btn--accept">
							<span>Create</span>
						</button>
					</div>
				</form>
			</div>
		</div>
	`
};
CurvedPlaneModalComponent.chunk = () => /* html */'<div class="curved-plane-modal" curved-plane-modal></div>';class ItemModelModalComponent extends rxcomp.Component {
  get data() {
    let data = null;
    const {
      parentInstance
    } = rxcomp.getContext(this);
    if (parentInstance instanceof ModalOutletComponent) {
      data = parentInstance.modal.data;
    }
    return data;
  }
  get view() {
    let view = null;
    const data = this.data;
    if (data) {
      view = data.view;
    }
    return view;
  }
  get object() {
    const object = new THREE.Object3D();
    const data = this.data;
    if (data) {
      const position = data.hit.position.clone();
      const normal = data.hit.normal.clone();
      const spherical = data.hit.spherical;
      if (spherical) {
        position.normalize().multiplyScalar(4);
        object.position.copy(position);
        object.lookAt(Host.origin);
      } else {
        object.lookAt(normal);
        object.position.set(position.x, position.y, position.z);
        object.position.add(normal.multiplyScalar(0.01));
      }
    }
    return object;
  }
  onInit() {
    const object = this.object;
    const form = this.form = new rxcompForm.FormGroup({
      type: ViewItemType.Model,
      position: new rxcompForm.FormControl(object.position.toArray(), rxcompForm.RequiredValidator()),
      rotation: new rxcompForm.FormControl([0, 0, 0], rxcompForm.RequiredValidator()),
      // [0, -Math.PI / 2, 0],
      // rotation: new FormControl(object.rotation.toArray(), RequiredValidator()), // [0, -Math.PI / 2, 0],
      scale: new rxcompForm.FormControl([1, 1, 1], rxcompForm.RequiredValidator()),
      asset: new rxcompForm.FormControl(null, rxcompForm.RequiredValidator())
    });
    this.controls = form.controls;
    form.changes$.subscribe(changes => {
      // console.log('ItemModelModalComponent.form.changes$', changes, form.valid, form);
      this.pushChanges();
    });
  }
  onSubmit() {
    if (this.form.valid) {
      const item = Object.assign({}, this.form.value);
      // item.viewId = parseInt(item.viewId);
      // console.log('ItemModelModalComponent.onSubmit', this.view, item);
      EditorService.inferItemCreate$(this.view, item).pipe(operators.first()).subscribe(response => {
        // console.log('ItemModelModalComponent.onSubmit.success', response);
        ModalService.resolve(response);
      }, error => console.log('ItemModelModalComponent.onSubmit.error', error));
    } else {
      this.form.touched = true;
    }
  }
  onClose() {
    ModalService.reject();
  }
}
ItemModelModalComponent.meta = {
  selector: '[item-model-modal]',
  template: /* html */`
		<div class="modal__header">
			<button type="button" class="btn--close" (click)="onClose()">
				<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#close"></use></svg>
			</button>
		</div>
		<div class="container">
			<div class="form">
				<div class="title">Create Model Item.</div>
				<form [formGroup]="form" (submit)="onSubmit()" name="form" role="form" novalidate autocomplete="off">
					<div class="form-controls">
						<div control-vector [control]="controls.position" label="Position" [precision]="2" [disabled]="true"></div>
						<div control-vector [control]="controls.rotation" label="Rotation" [precision]="3" [increment]="Math.PI / 360" [disabled]="true"></div>
						<div control-vector [control]="controls.scale" label="Scale" [precision]="2" [disabled]="true"></div>
						<div control-model [control]="controls.asset" label="Model (.glb)" accept=".glb"></div>
					</div>
					<div class="group--cta">
						<button type="submit" class="btn--accept">
							<span>Create</span>
						</button>
					</div>
				</form>
			</div>
		</div>
	`
};
ItemModelModalComponent.chunk = () => /* html */'<div class="item-model-modal" item-model-modal></div>';class MediaModalComponent extends rxcomp.Component {
  onInit() {
    this.error = null;
    const form = this.form = new rxcompForm.FormGroup({
      type: ViewType.Media,
      name: new rxcompForm.FormControl(null, rxcompForm.RequiredValidator()),
      asset: new rxcompForm.FormControl(null, rxcompForm.RequiredValidator())
    });
    this.controls = form.controls;
    form.changes$.subscribe(changes => {
      // console.log('MediaModalComponent.form.changes$', changes, form.valid, form);
      this.pushChanges();
    });
  }
  onSubmit() {
    if (this.form.valid) {
      this.form.submitted = true;
      const values = this.form.value;
      const view = {
        type: values.type,
        name: values.name,
        asset: values.asset,
        orientation: {
          latitude: 0,
          longitude: 0
        },
        zoom: 75
      };
      // console.log('MediaModalComponent.onSubmit.view', view);
      return EditorService.viewCreate$(view).pipe(operators.switchMap(view => {
        const item = {
          type: ViewItemType.Plane,
          position: [20, 0, 0],
          rotation: [0, -Math.PI / 2, 0],
          scale: [12, 6.75, 1],
          asset: values.asset
        };
        return EditorService.itemCreate$(view, item).pipe(operators.map(item => {
          view.items = [item];
          return view;
        }));
      }), operators.first()).subscribe(response => {
        // console.log('MediaModalComponent.onSubmit.success', response);
        ModalService.resolve(response);
      }, error => {
        console.log('MediaModalComponent.onSubmit.error', error);
        this.error = error;
        this.form.reset();
      });
    } else {
      this.form.touched = true;
    }
  }
  onClose() {
    ModalService.reject();
  }
}
MediaModalComponent.meta = {
  selector: '[media-modal]',
  template: /* html */`
		<div class="modal__header">
			<button type="button" class="btn--close" (click)="onClose()">
				<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#close"></use></svg>
			</button>
		</div>
		<div class="container">
			<div class="form">
				<div class="title">Create Media.</div>
				<form [formGroup]="form" (submit)="onSubmit()" name="form" role="form" novalidate autocomplete="off">
					<div class="form-controls">
						<div control-text [control]="controls.name" label="Name"></div>
						<div control-asset [control]="controls.asset" label="Image or Video" accept="image/jpeg, video/mp4"></div>
					</div>
					<div class="group--cta">
						<button type="submit" class="btn--accept">
							<span>Create</span>
						</button>
					</div>
				</form>
			</div>
		</div>
	`
};
MediaModalComponent.chunk = () => /* html */'<div class="media-modal" media-modal></div>';class ModelModalComponent extends rxcomp.Component {
  onInit() {
    this.error = null;
    const form = this.form = new rxcompForm.FormGroup({
      type: ViewType.Model,
      name: new rxcompForm.FormControl(null, rxcompForm.RequiredValidator()),
      asset: new rxcompForm.FormControl(null, rxcompForm.RequiredValidator()),
      model: new rxcompForm.FormControl(null, rxcompForm.RequiredValidator())
    });
    this.controls = form.controls;
    form.changes$.subscribe(changes => {
      // console.log('ModelModalComponent.form.changes$', changes, form.valid, form);
      this.pushChanges();
    });
  }
  onSubmit() {
    if (this.form.valid) {
      this.form.submitted = true;
      const values = this.form.value;
      const view = {
        type: values.type,
        name: values.name,
        asset: values.asset,
        orientation: {
          latitude: 0,
          longitude: 0
        },
        zoom: 75
      };
      // console.log('ModelModalComponent.onSubmit.view', view);
      return EditorService.viewCreate$(view).pipe(operators.switchMap(view => {
        const item = {
          type: ViewItemType.Model,
          asset: values.model
        };
        return EditorService.itemCreate$(view, item).pipe(operators.map(item => {
          view.items = [item];
          return view;
        }));
      }), operators.first()).subscribe(response => {
        // console.log('ModelModalComponent.onSubmit.success', response);
        ModalService.resolve(response);
      }, error => {
        console.log('ModelModalComponent.onSubmit.error', error);
        this.error = error;
        this.form.reset();
      });
    } else {
      this.form.touched = true;
    }
  }
  onClose() {
    ModalService.reject();
  }
}
ModelModalComponent.meta = {
  selector: '[model-modal]',
  template: /* html */`
		<div class="modal__header">
			<button type="button" class="btn--close" (click)="onClose()">
				<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#close"></use></svg>
			</button>
		</div>
		<div class="container">
			<div class="form">
				<div class="title">Create Model View.</div>
				<form [formGroup]="form" (submit)="onSubmit()" name="form" role="form" novalidate autocomplete="off">
					<div class="form-controls">
						<div control-text [control]="controls.name" label="Name"></div>
						<div control-asset [control]="controls.asset" label="Image" accept="image/jpeg"></div>
						<div control-model [control]="controls.model" label="Model (.glb)" accept=".glb"></div>
					</div>
					<div class="group--cta">
						<button type="submit" class="btn--accept">
							<span>Create</span>
						</button>
					</div>
				</form>
			</div>
		</div>
	`
};
ModelModalComponent.chunk = () => /* html */'<div class="model-modal" model-modal></div>';class NavModalComponent extends rxcomp.Component {
  get data() {
    let data = null;
    const {
      parentInstance
    } = rxcomp.getContext(this);
    if (parentInstance instanceof ModalOutletComponent) {
      data = parentInstance.modal.data;
    }
    return data;
  }
  get view() {
    let view = null;
    const data = this.data;
    if (data) {
      view = data.view;
    }
    return view;
  }
  get position() {
    let position = null;
    const data = this.data;
    if (data) {
      position = data.hit.position;
    }
    return position;
  }
  get object() {
    const object = new THREE.Object3D();
    const data = this.data;
    if (data) {
      const position = data.hit.position.clone();
      const normal = data.hit.normal.clone();
      const spherical = data.hit.spherical;
      if (spherical) {
        position.normalize().multiplyScalar(ModelNavComponent.RADIUS);
        object.position.copy(position);
        object.lookAt(Host.origin);
      } else {
        object.lookAt(normal);
        object.position.set(position.x, position.y, position.z);
        object.position.add(normal.multiplyScalar(0.01));
      }
    }
    return object;
  }
  onInit() {
    const object = this.object;
    this.error = null;
    this.useHooks = WebhookService.enabled;
    const form = this.form = new rxcompForm.FormGroup({
      type: ViewItemType.Nav,
      title: null,
      abstract: null,
      viewId: null,
      // new FormControl(null, RequiredValidator()),
      hook: null,
      hookExtra: null,
      keepOrientation: false,
      important: false,
      transparent: false,
      //
      position: new rxcompForm.FormControl(object.position.toArray(), rxcompForm.RequiredValidator()),
      rotation: new rxcompForm.FormControl(object.rotation.toArray(), rxcompForm.RequiredValidator()),
      // [0, -Math.PI / 2, 0],
      scale: new rxcompForm.FormControl([20, 5, 1], rxcompForm.RequiredValidator()),
      //
      asset: null,
      link: new rxcompForm.FormGroup({
        title: new rxcompForm.FormControl(null),
        href: new rxcompForm.FormControl(null),
        target: '_blank'
      })
      // upload: new FormControl(null, RequiredValidator()),
      // items: new FormArray([null, null, null], RequiredValidator()),
    });

    this.controls = form.controls;
    if (WebhookService.enabled) {
      const options = environment.webhook.methods.nav.map(x => ({
        id: x,
        name: x
      }));
      options.unshift({
        id: null,
        name: 'select'
      });
      this.controls.hook.options = options;
    }
    // !!! mode validator
    // form.addValidators(NavModalValidator(form, this.view));
    /*
    this.controls.viewId.options = [{
    	name: 'Name',
    	id: 2,
    }];
    */
    form.changes$.subscribe(changes => {
      // console.log('NavModalComponent.form.changes$', changes, form.valid, form);
      this.pushChanges();
    });
    EditorService.viewIdOptions$().pipe(operators.first()).subscribe(options => {
      this.controls.viewId.options = options;
      this.pushChanges();
    });
  }
  onSubmit() {
    if (this.form.valid) {
      this.form.submitted = true;
      const item = Object.assign({}, this.form.value);
      item.viewId = item.viewId ? parseInt(item.viewId) : this.view.id;
      if (item.link && (!item.link.title || !item.link.href)) {
        item.link = null;
      }
      // console.log('NavModalComponent.onSubmit', this.view, item);
      EditorService.inferItemCreate$(this.view, item).pipe(operators.first()).subscribe(response => {
        // console.log('NavModalComponent.onSubmit.success', response);
        ModalService.resolve(response);
      }, error => {
        console.log('NavModalComponent.onSubmit.error', error);
        this.error = error;
        this.form.submitted = false;
        // this.form.reset();
      });
    } else {
      this.form.touched = true;
    }
  }
  onViewIdDidChange(viewId) {
    // console.log('NavModalComponent.onViewIdDidChange', viewId, this.form.value);
    // const viewId = this.form.value.viewId;
    if (viewId != null && environment.flags.navAutoUpdateTitle) {
      const options = this.controls.viewId.options;
      const selectedOption = options.find(x => x.id === viewId);
      // console.log('NavModalComponent.onViewIdDidChange', selectedOption, options);
      if (selectedOption != null) {
        const title = selectedOption.name;
        const currentTitle = this.form.value.title;
        // console.log('NavModalComponent.onViewIdDidChange', title, currentTitle);
        if (!currentTitle || options.find(x => x.name === currentTitle)) {
          this.form.patch({
            title
          });
        }
      }
    }
  }
  onClose() {
    ModalService.reject();
  }
}
NavModalComponent.meta = {
  selector: '[nav-modal]',
  template: /* html */`
		<div class="modal__header">
			<button type="button" class="btn--close" (click)="onClose()">
				<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#close"></use></svg>
			</button>
		</div>
		<div class="container">
			<div class="form">
				<div class="title">Create Nav.</div>
				<form [formGroup]="form" (submit)="onSubmit()" name="form" role="form" novalidate autocomplete="off">
					<div class="form-controls">
						<div control-text [control]="controls.title" label="Title"></div>
						<div control-textarea [control]="controls.abstract" label="Abstract"></div>
						<div control-custom-select [control]="controls.viewId" label="NavToView" (change)="onViewIdDidChange($event)"></div>
						<div control-checkbox [control]="controls.keepOrientation" label="Keep Orientation"></div>
						<div control-checkbox [control]="controls.important" label="Important"></div>
						<div control-checkbox [control]="controls.transparent" label="Transparent"></div>
						<div control-vector [control]="controls.position" label="Position" [precision]="3" [disabled]="true"></div>
						<div *if="controls.transparent.value == true">
							<div control-vector [control]="controls.rotation" label="Rotation" [precision]="3" [increment]="Math.PI / 360" [disabled]="true"></div>
							<div control-vector [control]="controls.scale" label="Scale" [precision]="2" [disabled]="true"></div>
						</div>
						<div control-asset [control]="controls.asset" label="Image" accept="image/png, image/jpeg"></div>
						<div control-text [control]="controls.link.controls.title" label="Link Title"></div>
						<div control-text [control]="controls.link.controls.href" label="Link Url"></div>
						<div control-custom-select [control]="controls.hook" label="Hook" *if="useHooks"></div>
						<div control-text [control]="controls.hookExtra" label="Hook Extra" *if="useHooks"></div>
					</div>
					<div class="group--cta">
						<button type="submit" class="btn--accept">
							<span>Create</span>
						</button>
					</div>
				</form>
			</div>
		</div>
	`
};
NavModalComponent.chunk = () => /* html */'<div class="nav-modal" nav-modal></div>';class PanoramaGridModalComponent extends rxcomp.Component {
  onInit() {
    this.error = null;
    const form = this.form = new rxcompForm.FormGroup({
      type: ViewType.PanoramaGrid,
      name: new rxcompForm.FormControl(null, rxcompForm.RequiredValidator()),
      assets: new rxcompForm.FormControl(null, rxcompForm.RequiredValidator())
    });
    this.controls = form.controls;
    form.changes$.subscribe(changes => {
      // console.log('PanoramaGridModalComponent.form.changes$', changes, form.valid, form);
      this.pushChanges();
    });
  }
  onSubmit() {
    if (this.form.valid) {
      this.form.submitted = true;
      // console.log('PanoramaGridModalComponent.onSubmit', this.form.value);
      const assets = this.form.value.assets;
      const tiles = PanoramaGridView.mapTiles(assets.map(asset => ({
        asset,
        navs: []
      })), false, true);
      tiles.sort((a, b) => {
        const ai = a.indices.x * 10000 + a.indices.y;
        const bi = b.indices.x * 10000 + b.indices.y;
        return ai - bi;
      });
      // console.log('PanoramaGridModalComponent.onSubmit', tiles);
      const asset = tiles[0].asset;
      const view = {
        type: this.form.value.type,
        name: this.form.value.name,
        asset,
        tiles: tiles,
        invertAxes: true,
        flipAxes: false,
        orientation: {
          latitude: 0,
          longitude: 0
        },
        zoom: 75
      };
      EditorService.viewCreate$(view).pipe(operators.first()).subscribe(response => {
        // console.log('PanoramaGridModalComponent.onSubmit.success', response);
        ModalService.resolve(response);
      }, error => {
        console.log('PanoramaGridModalComponent.onSubmit.error', error);
        this.error = error;
        this.form.reset();
      });
    } else {
      this.form.touched = true;
    }
  }
  onClose() {
    ModalService.reject();
  }
}
PanoramaGridModalComponent.meta = {
  selector: '[panorama-grid-modal]',
  template: /* html */`
		<div class="modal__header">
			<button type="button" class="btn--close" (click)="onClose()">
				<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#close"></use></svg>
			</button>
		</div>
		<div class="container">
			<div class="form">
				<div class="title">Create Panorama Grid.</div>
				<form [formGroup]="form" (submit)="onSubmit()" name="form" role="form" novalidate autocomplete="off">
					<div class="form-controls">
						<div control-text [control]="controls.name" label="Name"></div>
						<div control-assets [control]="controls.assets" label="Image" accept="image/jpeg"></div>
					</div>
					<div class="group--cta">
						<button type="submit" class="btn--accept">
							<span>Create</span>
						</button>
					</div>
				</form>
			</div>
		</div>
	`
};
PanoramaGridModalComponent.chunk = () => /* html */'<div class="panorama-grid-modal" panorama-grid-modal></div>';class PanoramaModalComponent extends rxcomp.Component {
  onInit() {
    this.error = null;
    const form = this.form = new rxcompForm.FormGroup({
      type: ViewType.Panorama,
      name: new rxcompForm.FormControl(null, rxcompForm.RequiredValidator()),
      asset: new rxcompForm.FormControl(null, rxcompForm.RequiredValidator())
      // upload: new FormControl(null, RequiredValidator()),
      // items: new FormArray([null, null, null], RequiredValidator()),
    });

    this.controls = form.controls;
    form.changes$.subscribe(changes => {
      // console.log('PanoramaModalComponent.form.changes$', changes, form.valid, form);
      this.pushChanges();
    });
  }
  onSubmit() {
    if (this.form.valid) {
      this.form.submitted = true;
      const values = this.form.value;
      const view = {
        type: values.type,
        name: values.name,
        asset: values.asset,
        orientation: {
          latitude: 0,
          longitude: 0
        },
        zoom: 75
      };
      // console.log('PanoramaModalComponent.onSubmit.view', view);
      return EditorService.viewCreate$(view).pipe(operators.first()).subscribe(response => {
        // console.log('PanoramaModalComponent.onSubmit.success', response);
        ModalService.resolve(response);
      }, error => {
        console.log('PanoramaModalComponent.onSubmit.error', error);
        this.error = error;
        this.form.reset();
      });
    } else {
      this.form.touched = true;
    }
  }
  onClose() {
    ModalService.reject();
  }
}
PanoramaModalComponent.meta = {
  selector: '[panorama-modal]',
  template: /* html */`
		<div class="modal__header">
			<button type="button" class="btn--close" (click)="onClose()">
				<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#close"></use></svg>
			</button>
		</div>
		<div class="container">
			<div class="form">
				<div class="title">Create Panorama.</div>
				<form [formGroup]="form" (submit)="onSubmit()" name="form" role="form" novalidate autocomplete="off">
					<div class="form-controls">
						<div control-text [control]="controls.name" label="Name"></div>
						<div control-asset [control]="controls.asset" label="Image or Video" accept="image/jpeg, video/mp4"></div>
					</div>
					<div class="group--cta">
						<button type="submit" class="btn--accept">
							<span>Create</span>
						</button>
					</div>
					<!--
					<div class="group--form group--form--fixed">
						<code [innerHTML]="form.value | json"></code>
						<button type="button" class="btn--test" (click)="test()"><span>test</span></button>
					</div>
					-->
				</form>
			</div>
		</div>
	`
};
PanoramaModalComponent.chunk = () => /* html */'<div class="panorama-modal" panorama-modal></div>';class PathAddModalComponent extends rxcomp.Component {
  onInit() {
    const {
      parentInstance
    } = rxcomp.getContext(this);
    if (parentInstance instanceof ModalOutletComponent) {
      this.data = parentInstance.modal.data;
    }
    this.error = null;
    const form = this.form = new rxcompForm.FormGroup({
      name: new rxcompForm.FormControl(null, rxcompForm.RequiredValidator())
    });
    this.controls = form.controls;
    form.changes$.subscribe(changes => {
      // console.log('PathAddModalComponent.form.changes$', changes, form.valid, form);
      this.pushChanges();
    });
  }
  onSubmit() {
    if (this.form.valid) {
      this.form.submitted = true;
      const values = this.form.value;
      const path = {
        name: values.name,
        items: this.data ? this.data.item.items : []
      };
      // console.log('PathAddModalComponent.onSubmit.path', path);
      return PathService.pathCreate$(path).pipe(operators.first()).subscribe(response => {
        // console.log('PathAddModalComponent.onSubmit.success', response);
        ModalService.resolve(response);
      }, error => {
        console.log('PathAddModalComponent.onSubmit.error', error);
        this.error = error;
        this.form.reset();
      });
    } else {
      this.form.touched = true;
    }
  }
  onClose() {
    ModalService.reject();
  }
}
PathAddModalComponent.meta = {
  selector: '[path-add-modal]',
  template: /* html */`
		<div class="modal__header">
			<button type="button" class="btn--close" (click)="onClose()">
				<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#close"></use></svg>
			</button>
		</div>
		<div class="container">
			<div class="form">
				<div class="title">Add Path.</div>
				<div class="description">Aggiungi un percorso</div>
				<form [formGroup]="form" (submit)="onSubmit()" name="form" role="form" novalidate autocomplete="off">
					<div class="form-controls">
						<div control-text [control]="controls.name" label="Name"></div>
					</div>
					<div class="group--cta">
						<button type="submit" class="btn--accept">
							<span>Create</span>
						</button>
					</div>
				</form>
			</div>
		</div>
	`
};
PathAddModalComponent.chunk = () => /* html */'<div class="panorama-modal" path-add-modal></div>';class PathEditModalComponent extends rxcomp.Component {
  onInit() {
    this.item = null;
    this.views = null;
    const {
      parentInstance
    } = rxcomp.getContext(this);
    if (parentInstance instanceof ModalOutletComponent) {
      const data = parentInstance.modal.data;
      if (data) {
        this.item = data.item ? data.item : null;
        this.views = this.parseViews(data.views, this.item);
      }
    }
    this.error = null;
    const form = this.form = new rxcompForm.FormGroup({
      name: new rxcompForm.FormControl(this.item ? this.item.name : null, rxcompForm.RequiredValidator())
    });
    this.controls = form.controls;
    form.changes$.subscribe(changes => {
      // console.log('PathEditModalComponent.form.changes$', changes, form.valid, form);
      this.pushChanges();
    });
  }
  parseViews(views, item) {
    if (views && item) {
      return views.map(view => {
        return {
          id: view.id,
          name: view.name,
          type: view.type,
          active: item.items.indexOf(view.id) === -1
        };
      });
    } else {
      return [];
    }
  }
  onToggleView(view) {
    view.active = !view.active;
    this.pushChanges();
  }
  onSubmit() {
    if (this.form.valid) {
      this.form.submitted = true;
      const values = this.form.value;
      const payload = {
        id: this.item.id,
        name: values.name,
        items: this.views.filter(x => !x.active).map(x => x.id)
      };
      // console.log('PathEditModalComponent.onSubmit', payload);
      return PathService.pathUpdate$(payload).pipe(operators.first()).subscribe(response => {
        // console.log('PathEditModalComponent.onSubmit.success', response);
        ModalService.resolve(response);
      }, error => {
        console.log('PathEditModalComponent.onSubmit.error', error);
        this.error = error;
        this.form.reset();
      });
    } else {
      this.form.touched = true;
    }
  }
  onSelectAll() {
    this.views.forEach(view => view.active = true);
    this.pushChanges();
  }
  onSelectNone() {
    this.views.forEach(view => view.active = false);
    this.pushChanges();
  }
  onClose() {
    ModalService.reject();
  }
}
PathEditModalComponent.meta = {
  selector: '[path-edit-modal]',
  template: /* html */`
		<div class="modal__header">
			<button type="button" class="btn--close" (click)="onClose()">
				<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#close"></use></svg>
			</button>
		</div>
		<div class="container">
			<div class="form">
				<div class="title">Edit Path <span *if="item">&ldquo;<span [innerHTML]="item.title || item.name"></span>&rdquo;</span>.</div>
				<div class="description">Modifica il percorso</div>
				<form [formGroup]="form" (submit)="onSubmit()" name="form" role="form" novalidate autocomplete="off">
					<div class="form-controls">
						<div control-text [control]="controls.name" label="Name"></div>
					</div>
					<ul class="nav--flag" *if="views">
						<li class="nav__item" *for="let view of views">
							<button type="button" class="btn--flag" [class]="{ active: view.active }" [title]="view.name" (click)="onToggleView(view)">
								<div class="icon">
									<svg-icon [name]="view.type.name"></svg-icon>
								</div>
								<span class="name" [innerHTML]="view.name"></span>
								<span class="flag">
									<svg class="check" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#check"></use></svg>
									<svg class="close" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#close"></use></svg>
								</span>
							</button>
						</li>
					</ul>
					<div class="group--cta">
						<div class="group--options">
							<button type="button" class="btn--link" (click)="onSelectAll()">
								<span>Select all</span>
							</button>
							<button type="button" class="btn--link" (click)="onSelectNone()">
								<span>Select none</span>
							</button>
						</div>
						<button type="submit" class="btn--accept">
							<span>Save</span>
						</button>
					</div>
				</form>
			</div>
		</div>
	`
};
PathEditModalComponent.chunk = () => /* html */'<div class="path-edit-modal" path-edit-modal></div>';class PlaneModalComponent extends rxcomp.Component {
  get data() {
    let data = null;
    const {
      parentInstance
    } = rxcomp.getContext(this);
    if (parentInstance instanceof ModalOutletComponent) {
      data = parentInstance.modal.data;
    }
    return data;
  }
  get view() {
    let view = null;
    const data = this.data;
    if (data) {
      view = data.view;
    }
    return view;
  }
  get object() {
    const object = new THREE.Object3D();
    const data = this.data;
    if (data) {
      const position = data.hit.position.clone();
      const normal = data.hit.normal.clone();
      const spherical = data.hit.spherical;
      if (spherical) {
        position.normalize().multiplyScalar(20);
        object.position.copy(position);
        object.lookAt(Host.origin);
      } else {
        object.lookAt(normal);
        object.position.set(position.x, position.y, position.z);
        object.position.add(normal.multiplyScalar(0.01));
      }
    }
    return object;
  }
  onInit() {
    const object = this.object;
    const form = this.form = new rxcompForm.FormGroup({
      type: ViewItemType.Plane,
      position: new rxcompForm.FormControl(object.position.toArray(), rxcompForm.RequiredValidator()),
      rotation: new rxcompForm.FormControl(object.rotation.toArray(), rxcompForm.RequiredValidator()),
      // [0, -Math.PI / 2, 0],
      scale: new rxcompForm.FormControl([12, 6.75, 1], rxcompForm.RequiredValidator()),
      asset: null
    });
    this.controls = form.controls;
    form.changes$.subscribe(changes => {
      // console.log('PlaneModalComponent.form.changes$', changes, form.valid, form);
      this.pushChanges();
    });
  }
  onSubmit() {
    if (this.form.valid) {
      const item = Object.assign({}, this.form.value);
      // item.viewId = parseInt(item.viewId);
      // console.log('PlaneModalComponent.onSubmit', this.view, item);
      EditorService.inferItemCreate$(this.view, item).pipe(operators.first()).subscribe(response => {
        // console.log('PlaneModalComponent.onSubmit.success', response);
        ModalService.resolve(response);
      }, error => console.log('PlaneModalComponent.onSubmit.error', error));
    } else {
      this.form.touched = true;
    }
  }
  onClose() {
    ModalService.reject();
  }
}
PlaneModalComponent.meta = {
  selector: '[plane-modal]',
  template: /* html */`
		<div class="modal__header">
			<button type="button" class="btn--close" (click)="onClose()">
				<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#close"></use></svg>
			</button>
		</div>
		<div class="container">
			<div class="form">
				<div class="title">Create Plane.</div>
				<form [formGroup]="form" (submit)="onSubmit()" name="form" role="form" novalidate autocomplete="off">
					<div class="form-controls">
						<!-- <div control-text [control]="controls.title" label="Title"></div> -->
						<div control-vector [control]="controls.position" label="Position" [precision]="2" [disabled]="true"></div>
						<div control-vector [control]="controls.rotation" label="Rotation" [precision]="3" [increment]="Math.PI / 360" [disabled]="true"></div>
						<div control-vector [control]="controls.scale" label="Scale" [precision]="2" [disabled]="true"></div>
						<div control-localized-asset [control]="controls.asset" label="Image or Video" accept="image/jpeg, video/mp4"></div>
					</div>
					<div class="group--cta">
						<button type="submit" class="btn--accept">
							<span>Create</span>
						</button>
					</div>
				</form>
			</div>
		</div>
	`
};
PlaneModalComponent.chunk = () => /* html */'<div class="plane-modal" plane-modal></div>';class RemoveModalComponent extends rxcomp.Component {
  get data() {
    let data = null;
    const {
      parentInstance
    } = rxcomp.getContext(this);
    if (parentInstance instanceof ModalOutletComponent) {
      data = parentInstance.modal.data;
    }
    return data;
  }
  get item() {
    let item = null;
    const data = this.data;
    if (data) {
      item = data.item;
    }
    return item;
  }
  onRemove() {
    ModalService.resolve();
  }
  onCancel() {
    ModalService.reject();
  }
  onClose() {
    ModalService.reject();
  }
}
RemoveModalComponent.meta = {
  selector: '[remove-modal]',
  template: /* html */`
		<div class="modal__header">
			<button type="button" class="btn--close" (click)="onClose()">
				<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#close"></use></svg>
			</button>
		</div>
		<div class="container">
			<div class="form">
				<div class="title">Remove <span *if="item">&ldquo;<span [innerHTML]="item.title || item.name"></span>&rdquo;</span>.</div>
				<div class="abstract">are you sure?</div>
				<div class="group--cta">
					<button type="button" class="btn--remove" (click)="onRemove($event)">
						<span>Remove</span>
					</button>
					<button type="button" class="btn--accept" (click)="onCancel($event)">
						<span>Cancel</span>
					</button>
				</div>
			</div>
		</div>
	`
};
RemoveModalComponent.chunk = () => /* html */'<div class="remove-modal" remove-modal></div>';class Room3DModalComponent extends rxcomp.Component {
  onInit() {
    this.error = null;
    const form = this.form = new rxcompForm.FormGroup({
      type: ViewType.Room3d,
      name: new rxcompForm.FormControl(null, rxcompForm.RequiredValidator()),
      asset: new rxcompForm.FormControl(null, rxcompForm.RequiredValidator())
      // model: new FormControl(null, RequiredValidator()),
    });

    this.controls = form.controls;
    form.changes$.subscribe(changes => {
      // console.log('Room3DModalComponent.form.changes$', changes, form.valid, form);
      this.pushChanges();
    });
  }
  onSubmit() {
    if (this.form.valid) {
      this.form.submitted = true;
      const values = this.form.value;
      const view = {
        type: values.type,
        name: values.name,
        asset: values.asset,
        orientation: {
          latitude: 0,
          longitude: 0
        },
        zoom: 75
      };
      // console.log('Room3DModalComponent.onSubmit.view', view);
      return EditorService.viewCreate$(view).pipe(
      /*
      switchMap(view => {
      	const item = {
      		type: ViewItemType.Model,
      		asset: values.model,
      	};
      	return EditorService.itemCreate$(view, item).pipe(
      		map(item => {
      			view.items = [item];
      			return view;
      		})
      	);
      }),
      */
      operators.first()).subscribe(response => {
        // console.log('Room3DModalComponent.onSubmit.success', response);
        ModalService.resolve(response);
      }, error => {
        console.log('Room3DModalComponent.onSubmit.error', error);
        this.error = error;
        this.form.reset();
      });
    } else {
      this.form.touched = true;
    }
  }
  onClose() {
    ModalService.reject();
  }
}
Room3DModalComponent.meta = {
  selector: '[room-3d-modal]',
  template: /* html */`
		<div class="modal__header">
			<button type="button" class="btn--close" (click)="onClose()">
				<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#close"></use></svg>
			</button>
		</div>
		<div class="container">
			<div class="form">
				<div class="title">Create Room 3D View.</div>
				<form [formGroup]="form" (submit)="onSubmit()" name="form" role="form" novalidate autocomplete="off">
					<div class="form-controls">
						<div control-text [control]="controls.name" label="Name"></div>
						<!--
						<div control-asset [control]="controls.asset" label="Image" accept="image/jpeg"></div>
						<div control-model [control]="controls.model" label="Model (.glb)" accept=".glb"></div>
						-->
						<div control-model [control]="controls.asset" label="Model (.glb)" accept=".glb"></div>
					</div>
					<div class="group--cta">
						<button type="submit" class="btn--accept">
							<span>Create</span>
						</button>
					</div>
				</form>
			</div>
		</div>
	`
};
Room3DModalComponent.chunk = () => /* html */'<div class="room-3d-modal" room-3d-modal></div>';const SETTINGS = {
  menu: [{
    id: 'menu',
    title: 'editor_menu',
    active: true
  }, {
    id: 'navmaps',
    title: 'editor_navmaps',
    active: true
  }],
  current: null,
  active: false
};
class EditorComponent extends rxcomp.Component {
  get dataViews() {
    return ViewService.dataViews;
  }
  get pathViews() {
    return ViewService.pathViews;
  }
  onInit() {
    const {
      node
    } = rxcomp.getContext(this);
    node.classList.remove('hidden');
    this.settings = this.getSettings();
    this.aside = false;
    this.state = {};
    this.view = null;
    this.paths = null;
    this.path = null;
    this.form = null;
    this.local = null;
    this.remotes = [];
    this.viewHit = new rxjs.Subject();
    const vrService = this.vrService = VRService.getService();
    vrService.status$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(status => this.pushChanges());
    this.resolveUser();
  }
  resolveUser() {
    UserService.me$().pipe(operators.takeUntil(this.unsubscribe$)).subscribe(user => {
      if (user && user.type === RoleType.Publisher) {
        this.user = user;
        this.initState();
      } else {
        RouterService.setRouterLink(RoutePipe.transform(':lang.access'));
      }
    });
  }
  initState() {
    const user = this.user;
    const role = user.type;
    const name = user.firstName && user.lastName ? `${user.firstName} ${user.lastName}` : null;
    const state = {
      user: user,
      role: role,
      name: name,
      mode: UIMode.VirtualTour,
      link: null,
      channelName: environment.channelName,
      uid: null,
      status: AgoraStatus.Connected,
      connecting: false,
      connected: true,
      controlling: false,
      spying: false,
      silencing: false,
      hosted: true,
      live: false,
      navigable: true,
      cameraMuted: false,
      audioMuted: false,
      showNavInfo: true
    };
    StateService.state = state;
    StateService.state$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(state => {
      this.state = state;
      this.hosted = state.hosted;
      this.pushChanges();
    });
    this.viewObserver$().pipe(operators.takeUntil(this.unsubscribe$)).subscribe(view => {
      // console.log('EditorComponent.viewObserver$', view);
    });
    StreamService.mode = StreamServiceMode.Editor;
    // this.getUserMedia();
  }

  viewObserver$() {
    return EditorService.data$().pipe(operators.switchMap(data => {
      // console.log('viewObserver$', data);
      const meetingUrl = new MeetingUrl();
      const pathId = meetingUrl.pathId;
      return PathService.getCurrentPath$(pathId).pipe(operators.switchMap(path => {
        this.paths = PathService.paths;
        this.path = path;
        return ViewService.editorView$(data, path);
      }));
    }), operators.tap(view => {
      this.view = null;
      this.pushChanges();
    }), operators.delay(1), operators.tap(view => {
      // console.log('EditorComponent.viewObserver$', view, ViewService.pathViews, ViewService.dataViews);
      this.view = view;
      this.pushChanges();
    }));
  }
  onAddPath() {
    // console.log('EditorComponent.onAddPath');
    ModalService.open$({
      template: PathAddModalComponent.chunk()
    }).pipe(operators.first()).subscribe(event => {
      if (event instanceof ModalResolveEvent) {
        PathService.addPath(event.data);
      }
    });
  }
  onEditPath(item) {
    // console.log('EditorComponent.onEditPath', item);
    ModalService.open$({
      template: PathEditModalComponent.chunk(),
      data: {
        item: item,
        views: ViewService.validViews
      }
    }).pipe(operators.first()).subscribe(event => {
      if (event instanceof ModalResolveEvent) {
        PathService.editPath(event.data);
      }
    });
  }
  onDuplicatePath(item) {
    // console.log('EditorComponent.onDuplicatePath', item);
    ModalService.open$({
      template: PathAddModalComponent.chunk(),
      data: {
        item
      }
    }).pipe(operators.first()).subscribe(event => {
      if (event instanceof ModalResolveEvent) {
        PathService.addPath(event.data);
      }
    });
  }
  onDeletePath(item) {
    // console.log('EditorComponent.onDeletePath', item);
    ModalService.open$({
      template: RemoveModalComponent.chunk(),
      data: {
        item: item
      }
    }).pipe(operators.first()).subscribe(event => {
      if (event instanceof ModalResolveEvent) {
        PathService.pathDelete$(item).pipe(operators.first()).subscribe(_ => {
          PathService.deletePath(item);
        });
      }
    });
  }
  onSelectPath(item) {
    // console.log('EditorComponent.onSelectPath', item);
    PathService.path = item;
  }
  isPathSelected(item) {
    // console.log('EditorComponent.isPathSelected', item);
    return PathService.path.id === item.id;
  }
  onNavTo(item) {
    // console.log('EditorComponent.onNavTo', item);
    const viewId = item.viewId;
    const view = ViewService.pathViews.find(x => x.id === viewId);
    if (view) {
      ViewService.action = {
        viewId,
        keepOrientation: item.keepOrientation,
        useLastOrientation: item.useLastOrientation
      };
    }
  }
  onNavLink(event) {
    // console.log('EditorComponent.onNavLink', event);
    ModalService.open$({
      iframe: event.link.href
    }).pipe(operators.first()).subscribe(_ => {
      MessageService.send({
        type: MessageType.NavLinkClose,
        itemId: event.item.id
      });
    });
  }
  patchState(state) {
    this.state = Object.assign({}, this.state, state);
    this.pushChanges();
    // console.log(this.state);
  }

  tryInAr() {
    ModalService.open$({
      template: TryInARModalComponent.chunk(),
      data: this.view
    }).pipe(operators.first()).subscribe(event => {
      // this.pushChanges();
    });
  }
  onToggleAside() {
    this.aside = !this.aside;
    this.pushChanges();
    window.dispatchEvent(new Event('resize'));
  }
  getSettings() {
    const settings = Object.assign({}, SETTINGS);
    settings.menu = settings.menu.filter(x => environment.flags[x.id]);
    settings.current = settings.menu.length ? settings.menu[0].id : null;
    return settings;
  }
  onToggleSettings() {
    const settings = this.settings;
    settings.active = !settings.active;
    this.pushChanges();
  }
  onSelectSetting(item) {
    this.settings.current = item.id;
    this.pushChanges();
  }

  // editor

  onViewHit(event) {
    // console.log('onViewHit');
    this.viewHit.next(event);
  }
  onViewHitted(callback) {
    if (this.viewHitSubscription) {
      this.viewHitSubscription.unsubscribe();
      this.viewHitSubscription = null;
    }
    if (typeof callback === 'function') {
      this.viewHitSubscription = this.viewHit.pipe(operators.first()).subscribe(event => callback(event));
    }
  }
  onDragEnd(event) {
    EditorService.inferItemUpdate$(this.view, event.item).pipe(operators.first()).subscribe(response => {
      // console.log('EditorComponent.onDragEnd.inferItemUpdate$.success', response);
      this.pushChanges();
    }, error => console.log('EditorComponent.onDragEnd.inferItemUpdate$.error', error, this.view, event.item, event.item.payload));
  }
  onResizeEnd(event) {
    // console.log('EditorComponent.onResizeEnd');
    /*
    EditorService.inferItemUpdate$(this.view, event.item).pipe(
    	first(),
    ).subscribe(response => {
    	// console.log('EditorComponent.onResizeEnd.inferItemUpdate$.success', response);
    	this.pushChanges();
    }, error => console.log('EditorComponent.onResizeEnd.inferItemUpdate$.error', error));
    */
  }
  onWorldSelect(event) {
    // console.log('EditorComponent.onWorldSelect', this.view);
    if (this.view) {
      let selectedItem;
      this.view.items.forEach(item => item.showPanel = false);
      this.view.items.forEach(item => {
        item.selected = item === event.item;
        selectedItem = item.selected ? item : selectedItem;
      });
      this.view.selected = !selectedItem;
      this.pushChanges();
      if (selectedItem) {
        this.aside = true;
        this.pushChanges();
        window.dispatchEvent(new Event('resize'));
      }
    }
  }
  onOpenModal(modal, data) {
    let template = null;
    switch (modal.type) {
      case 'view':
        switch (modal.value) {
          case ViewType.Panorama.name:
            template = PanoramaModalComponent.chunk();
            break;
          case ViewType.PanoramaGrid.name:
            template = PanoramaGridModalComponent.chunk();
            break;
          case ViewType.Model.name:
            template = ModelModalComponent.chunk();
            break;
          case ViewType.Room3d.name:
            template = Room3DModalComponent.chunk();
            break;
          case ViewType.Media.name:
            template = MediaModalComponent.chunk();
            break;
        }
        break;
      case 'viewItem':
        switch (modal.value) {
          case ViewItemType.Nav.name:
            template = NavModalComponent.chunk();
            break;
          case ViewItemType.Plane.name:
            template = PlaneModalComponent.chunk();
            break;
          case ViewItemType.CurvedPlane.name:
            template = CurvedPlaneModalComponent.chunk();
            break;
          case ViewItemType.Model.name:
            template = ItemModelModalComponent.chunk();
            break;
        }
        break;
    }
    if (!template) {
      return;
    }
    ModalService.open$({
      template,
      data
    }).pipe(operators.first()).subscribe(event => {
      if (event instanceof ModalResolveEvent) {
        // console.log('EditorComponent.onOpenModal.resolve', event);
        switch (modal.type) {
          case 'view':
            switch (modal.value) {
              case ViewType.Panorama.name:
              case ViewType.PanoramaGrid.name:
              case ViewType.Model.name:
              case ViewType.Room3d.name:
              case ViewType.Media.name:
                ViewService.addView(event.data);
                break;
            }
            break;
          case 'viewItem':
            switch (modal.value) {
              case ViewItemType.Nav.name:
              case ViewItemType.Plane.name:
              case ViewItemType.CurvedPlane.name:
              case ViewItemType.Model.name:
                {
                  const item = event.data; // Object.assign({}, event.data);
                  const tile = EditorService.getTile(this.view);
                  if (tile) {
                    const navs = tile.navs || [];
                    navs.push(item);
                    tile.navs = navs;
                    this.view.updateCurrentItems();
                  } else {
                    item.path = true;
                    const items = this.view.items || [];
                    items.push(item);
                    this.view.items = items;
                  }
                  this.pushChanges();
                  break;
                }
            }
            break;
        }
      }
      this.pushChanges();
    });
  }
  onAsideSelect(event) {
    // console.log('onAsideSelect', event);
    if (event.value) {
      switch (event.value) {
        case ViewItemType.Nav.name:
        case ViewItemType.Plane.name:
        case ViewItemType.CurvedPlane.name:
          this.onViewHitted(hit => {
            this.onOpenModal(event, {
              view: this.view,
              hit
            });
          });
          ToastService.open$({
            message: 'Click a point on the view'
          });
          break;
        case ViewItemType.Model.name:
          if (event.type === 'viewItem') {
            if (this.view.type.name === ViewType.Model.name) {
              return;
            }
            this.onViewHitted(hit => {
              this.onOpenModal(event, {
                view: this.view,
                hit
              });
            });
            ToastService.open$({
              message: 'Click a point on the view'
            });
          } else {
            this.onOpenModal(event, {
              view: this.view
            });
          }
          break;
        default:
          this.onOpenModal(event, {
            view: this.view
          });
      }
    } else if (event.view && (event.item || event.item === null)) {
      event.view.selected = false;
      event.view.items.forEach(item => item.selected = item === event.item);
      MessageService.send({
        type: MessageType.SelectItem
      });
      this.pushChanges();
    } else if (event.view && (event.tile || event.tile === null)) {
      event.view.selected = false;
      event.view.tiles.forEach(tile => tile.selected = tile === event.tile);
      MessageService.send({
        type: MessageType.SelectItem
      });
      /*
      // if tile selected
      // send ChangeTile message to world component
      this.orbitService.walk(event.position, (headingLongitude, headingLatitude) => {
      	const item = this.view.getTile(event.indices.x, event.indices.y);
      	if (item) {
      		this.panorama.crossfade(item, this.renderer, (envMap, texture, rgbe) => {
      			// this.scene.background = envMap;
      			this.scene.environment = envMap;
      			this.orbitService.walkComplete(headingLongitude, headingLatitude);
      			// this.render();
      			// this.pushChanges();
      		});
      	}
      });
      */
      this.pushChanges();
    } else if (event.view || event.view === null) {
      this.view.selected = this.view === event.view;
      this.view.items.forEach(item => item.selected = false);
      const currentTile = EditorService.getTile(this.view);
      if (currentTile) {
        this.view.tiles.forEach(tile => tile.selected = tile === currentTile);
      }
      MessageService.send({
        type: MessageType.SelectItem
      });
      this.pushChanges();
    }
  }
  onAsideUpdate(event) {
    // console.log('onAsideUpdate', event);
    if (event.item && event.view) {
      this.pushChanges();
    } else if (event.tile && event.view) ; else if (event.view) {
      if (ViewService.viewId !== event.view.id) {
        ViewService.viewId = event.view.id;
      } else {
        const assetDidChange = AssetService.assetDidChange(this.view.asset, event.view.asset);
        Object.assign(this.view, event.view);
        if (assetDidChange) {
          if (typeof this.view.onUpdateAsset === 'function') {
            this.view.onUpdateAsset();
          }
        }
        this.pushChanges();
      }
    }
  }
  onAsideDelete(event) {
    // console.log('onAsideDelete', event);
    if (event.item && event.view) {
      EditorService.inferItemDelete$(event.view, event.item).pipe(operators.first()).subscribe(response => {
        // console.log('EditorComponent.onAsideDelete.inferItemDelete$.success', response);
        EditorService.inferItemDeleteResult$(event.view, event.item);
        this.pushChanges();
      }, error => console.log('EditorComponent.onAsideDelete.inferItemDelete$.error', error));
    } else if (event.view) {
      EditorService.viewDelete$(event.view).pipe(operators.first()).subscribe(response => {
        // console.log('EditorComponent.onAsideDelete.viewDelete$.success', response);
        ViewService.deleteView(event.view);
      }, error => console.log('EditorComponent.onAsideDelete.viewDelete$.error', error));
    }
  }
}
EditorComponent.meta = {
  selector: '[editor-component]',
  hosts: {
    host: RouterOutletStructure
  },
  template: /* html */`
	<div class="page page--editor">
		<div class="ui" [class]="{ open: aside }" *if="dataViews.length">
			<div class="ui__navbar">
				<div class="btn--settings" [class]="{ active: settings.active }" (click)="onToggleSettings($event)" *if="settings.menu.length > 0">
					<svg class="settings" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#settings-full"></use></svg>
				</div>
				<div class="headline" *if="view">
					<div class="headline__id" [innerHTML]="view.id"></div>
					<div class="headline__icon">
						<svg-icon [name]="view.type.name"></svg-icon>
					</div>
					<div class="headline__name" [innerHTML]="view.name"></div>
				</div>
				<div class="group--path" *if="('usePaths' | flag) && path">
					<div class="group--path__select">
						<div class="group--form--select" [dropdown]="'path'">
							<label>Percorso</label>
							<span class="control--custom-select" [innerHTML]="path.name"></span>
							<svg class="icon--caret-down"><use xlink:href="#caret-down"></use></svg>
						</div>
						<div class="dropdown dropdown-item" [dropdown-item]="'path'">
							<div class="category">Percorso</div>
							<ul class="nav--dropdown">
								<li [class]="{ active: isPathSelected(item) }" *for="let item of paths">
									<span [innerHTML]="item.name" (click)="onSelectPath(item)"></span>
									<div class="check">
										<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#check"></use></svg>
									</div>
									<div class="btn--flags" (click)="onEditPath(item)" title="Edit" *if="item.id">
										<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#flags"></use></svg>
									</div>
									<div class="btn--duplicate" (click)="onDuplicatePath(item)" title="Duplicate" *if="item.id">
										<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#duplicate"></use></svg>
									</div>
									<div class="btn--trash" (click)="onDeletePath(item)" title="Delete" *if="item.id">
										<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#trash"></use></svg>
									</div>
								</li>
							</ul>
							<div class="btn--mode" (click)="onAddPath()">Aggiungi un percorso</div>
						</div>
					</div>
				</div>
				<div class="btn--edit" [class]="{ active: aside }" (click)="onToggleAside($event)">
					<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#edit"></use></svg>
				</div>
			</div>
			<div class="ui__body">
				<div class="world" world [view]="view" [views]="pathViews" [editor]="true" (navTo)="onNavTo($event)" (viewHit)="onViewHit($event)" (dragEnd)="onDragEnd($event)" (select)="onWorldSelect($event)"></div>
			</div>
			<!-- footer -->
			<div class="group--footer">
				<div class="group--ar-vr">
					<button type="button" class="btn--ar" [href]="view?.ar" (click)="tryInAr()" *if="view?.ar">
						<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#ar"></use></svg> <span>Try in AR</span>
					</button>
					<button type="button" class="btn--vr" [class]="{ disabled: vrService.isDisabled() }" (click)="vrService.toggleVR()">
						<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#vr"></use></svg> <span [innerHTML]="vrService.getLabel()"></span>
					</button>
				</div>
			</div>
			<div class="ui__settings" *if="settings.active">
				<!-- settings navs -->
				<div class="group--nav">
					<ul class="nav--menu">
						<li class="nav__item" *for="let item of settings.menu" [class]="{ active: settings.current === item.id }" (click)="onSelectSetting(item)"><span class="title" [innerHTML]="item.title | label"></span></li>
					</ul>
				</div>
				<!-- menu -->
				<div class="group--content" menu-builder [views]="dataViews" *if="settings.current === 'menu'"></div>
				<!-- navmaps -->
				<div class="group--content" navmap-builder [views]="dataViews" *if="settings.current === 'navmaps'"></div>
			</div>
		</div>
		<div class="aside" [class]="{ active: aside }" aside [view]="view" (select)="onAsideSelect($event)" (update)="onAsideUpdate($event)" (delete)="onAsideDelete($event)" *if="view && aside"></div>
	</div>
	`
};class GenericService {
  static currentLanguagePage$(key) {
    return LanguageService.lang$.pipe(operators.switchMap(lang => {
      return this.page$(lang, key);
    }));
  }
  static page$(lang, key) {
    const url = environment.flags.production ? `/api/${lang}/pages/${key}/` : `./api/${lang}/pages/${key}.json`;
    return HttpService.get$(url);
  }
}class GenericComponent extends rxcomp.Component {
  onInit() {
    this.route = this.host ? this.host.route : null;
    this.state = {
      status: 'generic'
    };
    this.page = null;
    GenericService.currentLanguagePage$(this.route.params.mode).pipe(operators.takeUntil(this.unsubscribe$)).subscribe(page => {
      this.page = page;
      this.pushChanges();
    });
  }
}
GenericComponent.meta = {
  selector: '[generic-component]',
  hosts: {
    host: RouterOutletStructure
  },
  template: /*html*/`
		<div class="page page--generic">
			<!-- generic -->
			<div class="ui ui--generic" *if="page">
				<div class="group--generic">
					<div class="group--generic__content stagger--childs">
						<h1 class="title" [innerHTML]="page.title"></h1>
						<div class="description" [innerHTML]="page.description"></div>
					</div>
				</div>
			</div>
			<header>
				${CHUNK_LOGO}
				${CHUNK_LANGUAGE}
			</header>
			<footer>
				<span class="group--colophon" *if="state.status != 'connected'">
					${CHUNK_CREDITS}
					${CHUNK_COPYRIGHT}
				</span>
			</footer>
		</div>
	`
};class LayoutComponent extends rxcomp.Component {
  get meetingUrl() {
    if (!this.meetingUrl_) {
      this.meetingUrl_ = new MeetingUrl();
    }
    return this.meetingUrl_;
  }
  get isVirtualTourUser() {
    return [RoleType.Publisher, RoleType.Attendee, RoleType.Streamer, RoleType.Viewer].indexOf(this.state.role) !== -1;
  }
  get isEmbed() {
    return this.route && this.route.params.mode === 'embed';
  }
  get isSelfServiceTour() {
    return this.route && this.route.params.mode === 'selfServiceTour';
  }
  get isNavigable() {
    const embedViewId = this.meetingUrl.embedViewId;
    const navigable = embedViewId == null;
    return navigable;
  }
  get isBackButtonVisible() {
    return this.view && (this.view.type.name === ViewType.Media.name || this.view.type.name === ViewType.Model.name);
  }
  get showNavInfoToggler() {
    return environment.flags.hideNavInfo && this.state.mode !== UIMode.LiveMeeting;
  }
  get uiClass() {
    const uiClass = {};
    uiClass[this.state.role] = true;
    // uiClass[this.state.mode] = true;
    uiClass.chat = this.state.chat;
    uiClass.remotes = this.state.mode === UIMode.LiveMeeting;
    uiClass.remoteScreen = this.remoteScreen != null && !this.hasScreenViewItem;
    uiClass.media = !uiClass.remotes && this.media;
    uiClass.locked = this.locked;
    return uiClass;
  }
  get remoteClass() {
    return `group--remote--${Math.min(9, this.remotes.length)}`;
  }
  get controlled() {
    return this.state.controlling && this.state.controlling !== this.state.uid;
  }
  get controlling() {
    return this.state.controlling && this.state.controlling === this.state.uid;
  }
  get silencing() {
    return StateService.state.silencing;
  }
  get silenced() {
    return StateService.state.silencing && StateService.state.role === RoleType.Streamer;
  }
  get spyed() {
    return this.state.spying && this.state.spying === this.state.uid;
  }
  get spying() {
    return this.state.spying && this.state.spying !== this.state.uid;
  }
  get locked() {
    return this.controlled || this.spying;
  }
  get remoteScreen() {
    return this.remoteScreen_;
  }
  set remoteScreen(remoteScreen) {
    if (this.remoteScreen_ !== remoteScreen) {
      this.remoteScreen_ = remoteScreen;
      window.dispatchEvent(new Event('resize'));
    }
  }
  onInit() {
    const meetingUrl = this.meetingUrl;
    const embedViewId = meetingUrl.embedViewId;
    this.state = {
      status: LocationService.get('status') || AgoraStatus.Connected,
      role: LocationService.get('role') || RoleType.Publisher,
      // Publisher, Attendee, Streamer, Viewer, SmartDevice, SelfService, Embed
      membersCount: 3,
      controlling: false,
      spying: false,
      silencing: false,
      hosted: true,
      chat: false,
      chatDirty: true,
      name: 'Jhon Appleseed',
      uid: '7341614597544882',
      showNavInfo: true
    };
    this.state.live = this.state.role === RoleType.SelfService || this.state.role === RoleType.Embed || DEBUG ? false : true;
    this.state.navigable = embedViewId == null;
    this.state.mode = UserService.getMode(this.state.role);
    this.view = {
      likes: 41,
      type: {
        id: 2,
        name: 'panorama'
      }
    };
    this.local = {};
    this.screen = null;
    this.remoteScreen_ = null;
    this.media = null;
    this.hasScreenViewItem = false;
    this.media = true;
    this.remotes = new Array(8).fill(0).map((x, i) => ({
      id: i + 1
    }));
    this.languageService = LanguageService;
    this.showLanguages = false;
    StateService.patchState(this.state);
    this.fullscreen$().pipe(operators.takeUntil(this.unsubscribe$)).subscribe();
    this.vrService = VRService.getService();
    console.log('LayoutComponent', this);
    setTimeout(() => {
      const type = ToastType.Dialog;
      switch (type) {
        case ToastType.Info:
          ToastService.open$({
            message: LabelPipe.transform('bhere_support_request_sent')
          }).pipe(operators.takeUntil(this.unsubscribe$)).subscribe(event => {
            if (event instanceof ToastResolveEvent) {
              console.log('ToastResolveEvent', event);
            }
          });
          break;
        case ToastType.Alert:
          ToastService.open$({
            message: LabelPipe.transform('bhere_support_request_sent'),
            type: type,
            position: ToastPosition.BottomRight
          }).pipe(operators.takeUntil(this.unsubscribe$)).subscribe(event => {
            if (event instanceof ToastResolveEvent) {
              console.log('ToastResolveEvent', event);
            } else if (event instanceof ToastRejectEvent) {
              console.log('ToastRejectEvent', event);
            }
          });
          break;
        case ToastType.Dialog:
          ToastService.open$({
            message: LabelPipe.transform('bhere_support_request_dialog'),
            acceptMessage: LabelPipe.transform('bhere_support_request_dialog_accept'),
            rejectMessage: LabelPipe.transform('bhere_support_request_dialog_reject'),
            type: type,
            position: ToastPosition.BottomRight
          }).pipe(operators.takeUntil(this.unsubscribe$)).subscribe(event => {
            if (event instanceof ToastResolveEvent) {
              console.log('ToastResolveEvent', event);
            } else if (event instanceof ToastRejectEvent) {
              console.log('ToastRejectEvent', event);
            }
          });
          break;
      }
    }, 3000);
  }
  setLanguage(language) {
    this.languageService.setLanguage$(language).pipe(operators.first()).subscribe(_ => {
      this.showLanguages = false;
      this.pushChanges();
    });
  }
  toggleLanguages() {
    this.showLanguages = !this.showLanguages;
    this.pushChanges();
  }
  patchState(state) {
    this.state = Object.assign({}, this.state, state);
    this.screen = this.state.screen || null;
    this.remoteScreen = this.screen;
    this.pushChanges();
  }
  toggleCamera() {
    this.patchState({
      cameraMuted: !this.state.cameraMuted
    });
  }
  toggleAudio() {
    this.patchState({
      audioMuted: !this.state.audioMuted
    });
  }
  toggleScreen() {
    this.patchState({
      screen: !this.state.screen
    });
    window.dispatchEvent(new Event('resize'));
  }
  toggleVolume() {
    this.patchState({
      volumeMuted: !this.state.volumeMuted
    });
  }
  toggleMode() {
    const mode = this.state.mode === UIMode.VirtualTour ? UIMode.LiveMeeting : UIMode.VirtualTour;
    this.patchState({
      mode: mode
    });
    // this.pushChanges();
  }

  toggleFullScreen() {
    const {
      node
    } = rxcomp.getContext(this);
    const fullScreen = !this.state.fullScreen;
    if (fullScreen) {
      if (node.requestFullscreen) {
        node.requestFullscreen();
      } else if (node.webkitRequestFullscreen) {
        node.webkitRequestFullscreen();
      } else if (node.msRequestFullscreen) {
        node.msRequestFullscreen();
      }
    } else {
      if (document.exitFullscreen) {
        document.exitFullscreen();
      } else if (document.webkitExitFullscreen) {
        document.webkitExitFullscreen();
      } else if (document.msExitFullscreen) {
        document.msExitFullscreen();
      }
    }
    // this.patchState({ fullScreen });
  }

  fullscreen$() {
    return rxjs.fromEvent(document, 'fullscreenchange').pipe(operators.tap(_ => {
      const fullScreen = document.fullscreenElement != null;
      // console.log('fullscreen$', fullScreen);
      this.patchState({
        fullScreen
      });
    }));
  }
  toggleChat() {
    this.patchState({
      chat: !this.state.chat,
      chatDirty: false
    });
    window.dispatchEvent(new Event('resize'));
  }
  toggleNavInfo() {
    this.patchState({
      showNavInfo: !this.state.showNavInfo
    });
  }
  onBack() {
    console.log('LayoutComponent.onBack');
  }
  onChatClose() {
    this.patchState({
      chat: false
    });
    window.dispatchEvent(new Event('resize'));
  }
  onToggleControl(remoteId) {
    const controlling = this.state.controlling === remoteId ? null : remoteId;
    this.patchState({
      controlling,
      spying: false
    });
  }
  onToggleSilence() {
    this.patchState({
      silencing: !this.state.silencing
    });
  }
  onToggleSpy(remoteId) {
    const spying = this.state.spying === remoteId ? null : remoteId;
    this.patchState({
      spying,
      controlling: false
    });
  }
  addLike() {
    this.view.liked = true; // view.liked;
    this.showLove(this.view);
  }
  showLove(view) {
    if (view && this.view.id === view.id) {
      const skipTimeout = this.view.showLove;
      this.view.likes = view.likes;
      this.view.showLove = true;
      this.pushChanges();
      if (!skipTimeout) {
        setTimeout(() => {
          this.view.showLove = false;
          this.pushChanges();
        }, 3100);
      }
    }
  }
  disconnect() {}
}
LayoutComponent.meta = {
  selector: '[layout-component]',
  hosts: {
    host: RouterOutletStructure
  },
  template: /* html */`
	<div class="page page--agora">
		${CHUNK_BACKGROUND}
		<!-- Status Checklist -->
		<div class="ui ui--info ui--info-centered" *if="state.status == 'checklist'" [agora-checklist] (checked)="onChecked($event)"></div>
		<!-- Status Link -->
		<div class="ui ui--info ui--info-centered" *if="state.status == 'link'" [agora-link] (link)="onLink($event)"></div>
		<!-- Status Login -->
		<div class="ui ui--info ui--info-centered" *if="state.status == 'login'" [agora-login] (login)="onLogin($event)"></div>
		<!-- Status Name -->
		<div class="ui ui--info ui--info-centered" *if="state.status == 'name' || (state.status == 'disconnected' && state.role === 'viewer')" [agora-name] (name)="onName($event)"></div>
		<!-- Status Device -->
		<div class="ui ui--info" *if="state.status == 'device' || (state.status == 'disconnected' && state.role !== 'viewer')" [agora-device] (enter)="onEnter($event)"></div>
		<!-- Virtual Tour -->
		<div class="ui virtual-tour" [class]="uiClass" *if="state.status == 'connected' && isVirtualTourUser">
			<!-- world -->
			<div class="ui__body">
				<div class="world"></div>
			</div>
			<!-- remote sidebar -->
			<div class="group--remote" [class]="remoteClass" *if="state.live">
				<div class="agora-stream" *for="let remote of remotes">
					<div class="agora-stream__player"></div>
					<div class="agora-stream__info" [class]="{ spyed: state.spying == remote.streamId, controlling: state.controlling == remote.streamId }">
						<svg class="cam-muted" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#cam-muted"></use></svg>
						<svg class="mic-muted" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#mic-muted"></use></svg>
						<div class="id">name</div>
						<button type="button" class="btn--control" [title]="'title_control' | label" (click)="onToggleControl(remote.streamId)" *if="state.role === 'publisher'">
							<svg class="control" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#control"></use></svg>
						</button>
						<button type="button" class="btn--spy" [title]="'title_spy' | label" (click)="onToggleSpy(remote.streamId)" *if="state.role === 'publisher'">
							<svg class="spy" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#spy"></use></svg>
						</button>
					</div>
				</div>
				<div class="group--members" *if="state.mode == 'virtual-tour'">
					<div class="members" *if="state.role === 'publisher'">
						<svg class="spy" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#users"></use></svg>
						<span class="members__count" [innerHTML]="state.membersCount"></span>
					</div>
					<div class="credits">
						<a class="btn--credits" href="https://www.websolute.com/" target="_blank" rel="noopener">
							<svg viewBox="0 0 270 98"><use xlink:href="#b-here"></use></svg>
						</a>
					</div>
				</div>
			</div>
			<!-- remote screen -->
			<div class="group--remote-screen" *if="remoteScreen">
				<div class="agora-stream">
					<div class="agora-stream__player"></div>
					<div class="agora-stream__info">
						<div class="id">name</div>
					</div>
				</div>
			</div>
			<div class="group--header">
				<!-- service -->
				<div class="group--service">
					<button type="button" class="btn--back" [title]="'title_back' | label" (click)="onBack($event)" *if="isBackButtonVisible">
						<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#arrow-prev"></use></svg>
					</button>
					<button type="button" class="btn--view-mode" [title]="'title_view_mode' | label" (click)="toggleMode($event)" *if="state.mode != 'embed'">
						<svg width="24" height="24" viewBox="0 0 24 24" *if="state.mode == 'virtual-tour'"><use xlink:href="#live-meeting"></use></svg>
						<svg width="24" height="24" viewBox="0 0 24 24" *if="state.mode == 'live-meeting'"><use xlink:href="#virtual-tour"></use></svg>
					</button>
					<button type="button" class="btn--volume" [title]="'title_volume' | label" [class]="{ muted: state.volumeMuted }" (click)="toggleVolume($event)">
						<svg width="24" height="24" viewBox="0 0 24 24" *if="!state.volumeMuted"><use xlink:href="#volume-on"></use></svg>
						<svg width="24" height="24" viewBox="0 0 24 24" *if="state.volumeMuted"><use xlink:href="#volume-off"></use></svg>
					</button>
					<button type="button" class="btn--fullscreen" [title]="'title_fullscreen' | label" [class]="{ muted: state.fullScreen }" (click)="toggleFullScreen($event)">
						<svg width="24" height="24" viewBox="0 0 24 24" *if="!state.fullScreen"><use xlink:href="#fullscreen-on"></use></svg>
						<svg width="24" height="24" viewBox="0 0 24 24" *if="state.fullScreen"><use xlink:href="#fullscreen-off"></use></svg>
					</button>
					<button type="button" class="btn--navmap" [title]="'title_navmap' | label" [class]="{ active: state.showNavmap }" (click)="toggleNavmap($event)" *if="navmap && state.mode != 'live-meeting'">
						<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#navmap"></use></svg>
					</button>
				</div>
				<!-- local streams -->
				<div class="group--local" [class]="{ publisher: state.role == 'publisher', viewer: state.role == 'viewer' }" *if="state.live">
					<button type="button" class="btn--silence" [title]="'title_silence' | label" [class]="{ active: state.silencing }" (click)="onToggleSilence()" *if="state.role === 'publisher'">
						<svg class="mic-muted" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#mic-muted"></use></svg>
					</button>
					<button type="button" class="btn--control" [title]="'title_control' | label" [class]="{ active: state.controlling == state.uid }" (click)="onToggleControl(state.uid)" *if="state.role == 'publisher'">
						<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#control"></use></svg>
					</button>
					<div class="agora-stream" *if="!local"></div>
					<div class="agora-stream" *if="local">
						<div class="agora-stream__player"></div>
						<div class="agora-stream__info">
							<svg class="cam-muted" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#cam-muted"></use></svg>
							<svg class="mic-muted" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#mic-muted"></use></svg>
						</div>
					</div>
					<div class="agora-stream agora-stream--screen" *if="screen">
						<div class="agora-stream__player"></div>
					</div>
				</div>
			</div>
			<div class="group--footer">
				${CHUNK_CONTROLS}
				${CHUNK_MEDIA}
				${CHUNK_AR_VR}
				${CHUNK_LIKE}
			</div>
			<!-- members -->
			<div class="group--members" *if="state.mode == 'live-meeting'">
				<div class="members" *if="state.role === 'publisher'">
					<svg class="spy" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#users"></use></svg>
					<span class="members__count" [innerHTML]="state.membersCount"></span>
				</div>
				<div class="credits">
					<a class="btn--credits" href="https://www.websolute.com/" target="_blank" rel="noopener">
						<svg viewBox="0 0 270 98"><use xlink:href="#b-here"></use></svg>
					</a>
				</div>
			</div>
			${CHUNK_CHAT}
			${CHUNK_LOCK}
			${CHUNK_NAVMAP}
		</div>
		<!-- Smart Device -->
		<div class="ui remotes" [class]="uiClass" *if="state.status == 'connected' && state.role == 'smart-device'">
			<!-- world -->
			<div class="ui__body">
			</div>
			<!-- remote sidebar -->
			<div class="group--remote" [class]="remoteClass" *if="state.live">
				<div class="agora-stream" *for="let remote of remotes">
					<div class="agora-stream__player"></div>
					<div class="agora-stream__info">
						<svg class="cam-muted" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#cam-muted"></use></svg>
						<svg class="mic-muted" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#mic-muted"></use></svg>
						<div class="id">name</div>
						<button type="button" class="btn--spy" [title]="'title_spy' | label" *if="state.role === 'publisher'" (click)="onToggleSpy(remote.streamId)">
							<svg class="spy" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#spy"></use></svg>
						</button>
					</div>
				</div>
			</div>
			<!-- remote screen -->
			<div class="group--remote-screen" *if="remoteScreen">
				<div class="agora-stream">
					<div class="agora-stream__player"></div>
					<div class="agora-stream__info">
						<div class="id">name</div>
					</div>
				</div>
			</div>
			<!-- local streams -->
			<div class="group--local" [class]="{ publisher: state.role == 'publisher', viewer: state.role == 'viewer' }" *if="state.live">
				<div class="agora-stream" *if="local">
					<div class="agora-stream__player"></div>
					<div class="agora-stream__info">
						<svg class="cam-muted" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#cam-muted"></use></svg>
						<svg class="mic-muted" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#mic-muted"></use></svg>
					</div>
				</div>
			</div>
			<!-- controls -->
			<div class="group--controls" *if="state.live">
				<div class="group--actions">
					<button type="button" class="btn--call" [title]="'title_disconnect' | label" (click)="disconnect()">
						<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#call"></use></svg>
					</button>
					<button type="button" class="btn--cam" [title]="'title_mute_camera' | label" [class]="{ muted: state.cameraMuted, disabled: !local }" (click)="toggleCamera()">
						<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#cam"></use></svg>
					</button>
					<button type="button" class="btn--mic" [title]="'title_mute_mic' | label" [class]="{ muted: state.audioMuted, disabled: !local || silenced }" (click)="toggleAudio()">
						<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#mic"></use></svg>
					</button>
					<button type="button" class="btn--screen" [title]="'title_share_screen' | label" [class]="{ active: screen }" (click)="toggleScreen()" *if="('screenShare' | flag) && (state.role == 'publisher' || state.role == 'attendee' || controlling)">
						<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#screen"></use></svg>
					</button>
					<button type="button" class="btn--chat" [title]="'title_chat' | label" [class]="{ active: state.chatDirty }" (click)="toggleChat()" *if="('chat' | flag)">
						<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#chat"></use></svg>
					</button>
					<button type="button" class="btn--navinfo" [title]="'title_navinfo' | label" [class]="{ active: state.showNavInfo }" (click)="toggleNavInfo()" *if="showNavInfoToggler">
						<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#navinfo"></use></svg>
					</button>
				</div>
			</div>
			<!-- members -->
			<div class="group--members">
				<div class="members" *if="state.role === 'publisher'">
					<svg class="spy" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#users"></use></svg>
					<span class="members__count" [innerHTML]="state.membersCount"></span>
				</div>
				<div class="credits">
					<a class="btn--credits" href="https://www.websolute.com/" target="_blank" rel="noopener">
						<svg viewBox="0 0 270 98"><use xlink:href="#b-here"></use></svg>
					</a>
				</div>
			</div>
		</div>
		<!-- Self Service Tour -->
		<div class="ui" [class]="uiClass" *if="state.status == 'connected' && state.mode == 'self-service-tour'">
			<!-- world -->
			<div class="ui__body">
				<div class="world"></div>
			</div>
			<!-- service -->
			<div class="group--service">
				<button type="button" class="btn--volume" [title]="'title_volume' | label" [class]="{ muted: state.volumeMuted }" (click)="toggleVolume($event)">
					<svg width="24" height="24" viewBox="0 0 24 24" *if="!state.volumeMuted"><use xlink:href="#volume-on"></use></svg>
					<svg width="24" height="24" viewBox="0 0 24 24" *if="state.volumeMuted"><use xlink:href="#volume-off"></use></svg>
				</button>
				<button type="button" class="btn--fullscreen" [title]="'title_fullscreen' | label" [class]="{ muted: state.fullScreen }" (click)="toggleFullScreen($event)">
					<svg width="24" height="24" viewBox="0 0 24 24" *if="!state.fullScreen"><use xlink:href="#fullscreen-on"></use></svg>
					<svg width="24" height="24" viewBox="0 0 24 24" *if="state.fullScreen"><use xlink:href="#fullscreen-off"></use></svg>
				</button>
			</div>
			${CHUNK_AR_VR}
			${CHUNK_LIKE}
		</div>
		<!-- Embed -->
		<div class="ui" [class]="uiClass" *if="state.status == 'connected' && state.mode == 'embed'">
			<!-- world -->
			<div class="ui__body">
				<div class="world"></div>
			</div>
			<!-- service -->
			<div class="group--service">
				<button type="button" class="btn--volume" [title]="'title_volume' | label" [class]="{ muted: state.volumeMuted }" (click)="toggleVolume($event)">
					<svg width="24" height="24" viewBox="0 0 24 24" *if="!state.volumeMuted"><use xlink:href="#volume-on"></use></svg>
					<svg width="24" height="24" viewBox="0 0 24 24" *if="state.volumeMuted"><use xlink:href="#volume-off"></use></svg>
				</button>
				<button type="button" class="btn--fullscreen" [title]="'title_fullscreen' | label" [class]="{ muted: state.fullScreen }" (click)="toggleFullScreen($event)">
					<svg width="24" height="24" viewBox="0 0 24 24" *if="!state.fullScreen"><use xlink:href="#fullscreen-on"></use></svg>
					<svg width="24" height="24" viewBox="0 0 24 24" *if="state.fullScreen"><use xlink:href="#fullscreen-off"></use></svg>
				</button>
			</div>
			${CHUNK_AR_VR}
			${CHUNK_LIKE}
		</div>
		<a class="btn--logo" [routerLink]="':lang.access' | route" *if="state.status != 'connected'">
			<img [src]="'logo' | env" *if="'logo' | env" />
			<svg viewBox="0 0 270 98" *if="!('logo' | env)"><use xlink:href="#b-here"></use></svg>
		</a>
		<a class="btn--credits" href="https://www.websolute.com/" target="_blank" rel="noopener" *if="state.status != 'connected'">
			<svg viewBox="0 0 270 98"><use xlink:href="#b-here"></use></svg>
		</a>
		<div class="group--language" language *if="state.status != 'connected'"></div>
	</div>
	`
};class TryInARComponent extends rxcomp.Component {
  get viewId() {
    const viewId = this.route ? this.route.params.viewId : undefined;
    return viewId ? parseInt(viewId) : null;
  }
  onInit() {
    this.platform = DeviceService.platform;
    this.route = this.host ? this.host.route : null;
    this.missingAr = false;
    this.missingUsdz = false;
    this.missingGltf = false;
    const viewId = this.viewId;
    // console.log('TryInARComponent.viewId', viewId);
    if (viewId) {
      ViewService.viewById$(viewId).pipe(operators.first()).subscribe(view => {
        if (!view.ar) {
          this.missingAr = true;
          this.pushChanges();
          return;
        }
        // console.log('TryInARComponent.view', view);
        if (this.platform === DevicePlatform.IOS) {
          const usdzSrc = this.getUsdzSrc(view);
          if (usdzSrc) {
            window.location.href = usdzSrc;
          } else {
            this.missingUsdz = true;
            this.pushChanges();
          }
        } else if (this.getGltfSrc(view) !== null) {
          const modelViewerNode = this.getModelViewerNode(view);
          const {
            node
          } = rxcomp.getContext(this);
          node.appendChild(modelViewerNode);
          this.addARScripts();
        } else {
          this.missingGltf = true;
          this.pushChanges();
        }
      });
    }
  }
  addARScripts() {
    let script = document.createElement('script');
    script.setAttribute('type', 'module');
    script.setAttribute('src', 'https://unpkg.com/@google/model-viewer/dist/model-viewer.min.js');
    document.head.appendChild(script);
    script = document.createElement('script');
    script.setAttribute('nomodule', '');
    script.setAttribute('src', 'https://unpkg.com/@google/model-viewer/dist/model-viewer-legacy.js');
    document.head.appendChild(script);
  }
  getUsdzSrc(view) {
    return view.ar && view.ar.usdz ? environment.getPath(view.ar.usdz.folder + view.ar.usdz.file) : null;
  }
  getGltfSrc(view) {
    return view.ar && view.ar.gltf ? environment.getPath(view.ar.gltf.folder + view.ar.gltf.file) : null;
  }
  getViewId() {
    const meetingUrl = new MeetingUrl();
    let viewId = null;
    if (meetingUrl.viewId) {
      viewId = parseInt(meetingUrl.viewId);
    }
    return viewId;
  }
  getModelViewerNode(view) {
    const environmentImage = environment.getPath(environment.textures.envMap);
    const skyboxImage = environment.getPath(view.asset.folder + view.asset.file);
    const usdzSrc = this.getUsdzSrc(view);
    const gltfSrc = this.getGltfSrc(view);
    const template = /* html */`
			<model-viewer alt="${view.name}" environment-image="${environmentImage}" skybox-image="${skyboxImage}" ios-src="${usdzSrc}" src="${gltfSrc}" ar ar-modes="webxr scene-viewer quick-look" ar-scale="auto" camera-controls></model-viewer>
		`;
    const div = document.createElement('div');
    div.innerHTML = template;
    const node = div.firstElementChild;
    return node;
  }
}
TryInARComponent.meta = {
  selector: '[try-in-ar]',
  hosts: {
    host: RouterOutletStructure
  },
  template: /* html */`
		<div class="page page--try-in-ar">
			<!--
			<div *if="platform != 'ios'">
				<script type="module" src="https://unpkg.com/@google/model-viewer/dist/model-viewer.min.js"></script>
				<script nomodule src="https://unpkg.com/@google/model-viewer/dist/model-viewer-legacy.js"></script>
			</div>
			-->
			<div class="ui" *if="!viewId">
				<div class="group--info">
					<div class="group--info__content">
						<div class="info">Not found.</div>
					</div>
				</div>
			</div>
			<div class="ui" *if="missingAr">
				<div class="group--info">
					<div class="group--info__content">
						<div class="info">Missing AR in view.</div>
					</div>
				</div>
			</div>
			<div class="ui" *if="missingUsdz">
				<div class="group--info">
					<div class="group--info__content">
						<div class="info">Missing .usdz in ar.</div>
					</div>
				</div>
			</div>
			<div class="ui" *if="missingGltf">
				<div class="group--info">
					<div class="group--info__content">
						<div class="info">Missing .gltf in ar.</div>
					</div>
				</div>
			</div>
		</div>
	`
};console.log('environment.defaultLanguage', environment.defaultLanguage);
const AppRoutesInit = () => [{
  name: 'index',
  path: '/',
  forwardTo: environment.defaultLanguage || 'it'
},
// it
{
  name: 'it',
  path: '/it',
  defaultParams: {
    lang: 'it',
    mode: 'access'
  },
  factory: AccessComponent
}, {
  name: 'it.access',
  path: '/accesso',
  defaultParams: {
    lang: 'it',
    mode: 'access'
  },
  factory: AccessComponent
}, {
  name: 'it.accessCode',
  path: '/codice-di-accesso?:p&:link&:name&:role&:viewId&:pathId&:support',
  defaultParams: {
    lang: 'it',
    mode: 'accessCode'
  },
  factory: AccessCodeComponent
}, {
  name: 'it.guidedTour',
  path: '/tour-guidato?:p&:link&:name&:role&:viewId&:pathId&:support',
  defaultParams: {
    lang: 'it',
    mode: 'guidedTour'
  },
  factory: AgoraComponent
},
// { name: 'it.guidedTour', path: '/tour-guidato', defaultParams: { lang: 'it', mode: 'guidedTour' }, factory: AgoraComponent },
{
  name: 'it.selfServiceTour',
  path: '/tour-self-service?:p&:viewId&:pathId',
  defaultParams: {
    lang: 'it',
    mode: 'selfServiceTour'
  },
  factory: AgoraComponent
}, {
  name: 'it.embed',
  path: '/embed',
  defaultParams: {
    lang: 'it',
    mode: 'embed'
  },
  factory: AgoraComponent
}, {
  name: 'it.tryInAr',
  path: '/prova-in-ar?:p&:viewId',
  defaultParams: {
    lang: 'it',
    mode: 'tryInAr'
  },
  factory: TryInARComponent
}, {
  name: 'it.editor',
  path: '/editor?:p&:viewId',
  defaultParams: {
    lang: 'it',
    mode: 'editor'
  },
  factory: EditorComponent
}, {
  name: 'it.layout',
  path: '/layout',
  defaultParams: {
    lang: 'it',
    mode: 'layout'
  },
  factory: LayoutComponent
}, {
  name: 'it.privacy',
  path: '/informativa-sulla-privacy',
  defaultParams: {
    lang: 'it',
    mode: 'privacy_policy'
  },
  factory: GenericComponent
}, {
  name: 'it.terms',
  path: '/termini-di-utilizzo',
  defaultParams: {
    lang: 'it',
    mode: 'terms'
  },
  factory: GenericComponent
},
// en
{
  name: 'en',
  path: '/en',
  defaultParams: {
    lang: 'en',
    mode: 'access'
  },
  factory: AccessComponent
}, {
  name: 'en.access',
  path: '/access',
  defaultParams: {
    lang: 'en',
    mode: 'access'
  },
  factory: AccessComponent
}, {
  name: 'en.accessCode',
  path: '/accesso-code?:p&:link&:name&:role&:viewId&:pathId&:support',
  defaultParams: {
    lang: 'en',
    mode: 'accessCode'
  },
  factory: AccessCodeComponent
}, {
  name: 'en.guidedTour',
  path: '/guided-tour?:p&:link&:name&:role&:viewId&:pathId&:support',
  defaultParams: {
    lang: 'en',
    mode: 'guidedTour'
  },
  factory: AgoraComponent
},
// { name: 'en.guidedTour', path: '/guided-tour', defaultParams: { lang: 'en', mode: 'guidedTour' }, factory: AgoraComponent },
{
  name: 'en.selfServiceTour',
  path: '/self-service-tour?:p&:viewId&:pathId',
  defaultParams: {
    lang: 'en',
    mode: 'selfServiceTour'
  },
  factory: AgoraComponent
}, {
  name: 'en.embed',
  path: '/embed',
  defaultParams: {
    lang: 'en',
    mode: 'embed'
  },
  factory: AgoraComponent
}, {
  name: 'en.tryInAr',
  path: '/try-in-ar?:p&:viewId',
  defaultParams: {
    lang: 'en',
    mode: 'tryInAr'
  },
  factory: TryInARComponent
}, {
  name: 'en.editor',
  path: '/editor?:p&:viewId',
  defaultParams: {
    lang: 'en',
    mode: 'editor'
  },
  factory: EditorComponent
}, {
  name: 'en.layout',
  path: '/layout',
  defaultParams: {
    lang: 'en',
    mode: 'layout'
  },
  factory: LayoutComponent
}, {
  name: 'en.privacy',
  path: '/privacy-policy',
  defaultParams: {
    lang: 'en',
    mode: 'privacy_policy'
  },
  factory: GenericComponent
}, {
  name: 'en.terms',
  path: '/terms-of-service',
  defaultParams: {
    lang: 'en',
    mode: 'terms'
  },
  factory: GenericComponent
}];const SVG_CHUNK = /* html */`
		<svg width="0" height="0" class="hidden" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true">
			<symbol id="arrow-down" viewBox="0 0 24 24">
				<path d="M0 7.33l2.829-2.83 9.175 9.339 9.167-9.339 2.829 2.83-11.996 12.17z"></path>
			</symbol>
			<symbol id="arrow-next" viewBox="0 0 24 24">
				<path d="M7.33 24l-2.83-2.829 9.339-9.175-9.339-9.167 2.83-2.829 12.17 11.996z"></path>
			</symbol>
			<symbol id="arrow-prev" viewBox="0 0 24 24">
				<path d="M16.67 0l2.83 2.829-9.339 9.175 9.339 9.167-2.83 2.829-12.17-11.996z"></path>
			</symbol>
			<symbol id="call" viewBox="0 0 24 24">
				<path d="M20 22.621l-3.521-6.795c-.008.004-1.974.97-2.064 1.011-2.24 1.086-6.799-7.82-4.609-8.994l2.083-1.026-3.493-6.817-2.106 1.039c-7.202 3.755 4.233 25.982 11.6 22.615.121-.055 2.102-1.029 2.11-1.033z"></path>
			</symbol>
			<symbol id="heart" viewBox="0 0 24 24">
				<path d="M12 4.435c-1.989-5.399-12-4.597-12 3.568 0 4.068 3.06 9.481 12 14.997 8.94-5.516 12-10.929 12-14.997 0-8.118-10-8.999-12-3.568z"></path>
			</symbol>
			<symbol id="heart-outline" viewBox="0 0 24 24">
				<path d="M12 9.229c.234-1.12 1.547-6.229 5.382-6.229 2.22 0 4.618 1.551 4.618 5.003 0 3.907-3.627 8.47-10 12.629-6.373-4.159-10-8.722-10-12.629 0-3.484 2.369-5.005 4.577-5.005 3.923 0 5.145 5.126 5.423 6.231zm-12-1.226c0 4.068 3.06 9.481 12 14.997 8.94-5.516 12-10.929 12-14.997 0-7.962-9.648-9.028-12-3.737-2.338-5.262-12-4.27-12 3.737z"/>
			</symbol>
			<symbol id="cam" viewBox="0 0 24 24">
				<path d="M16 18c0 1.104-.896 2-2 2h-12c-1.105 0-2-.896-2-2v-12c0-1.104.895-2 2-2h12c1.104 0 2 .896 2 2v12zm8-14l-6 6.223v3.554l6 6.223v-16z"></path>
			</symbol>
			<symbol id="cam-muted" viewBox="0 0 24 24">
				<path d="M0.7,19.5L15.5,4.7C15.1,4.3,14.6,4,14,4H2C0.9,4,0,4.9,0,6v12C0,18.6,0.3,19.1,0.7,19.5z"></path>
				<path d="M18 13.8L24 20 24 4 18 10.2z"></path>
				<path d="M7.8,20H14c1.1,0,2-0.9,2-2v-6.2L7.8,20z"></path>
				<path d="M-3.4 11.2H27.400000000000002V12.7H-3.4z" transform="rotate(-45.001 12 12)"></path>
			</symbol>
			<symbol id="mic" viewBox="0 0 24 24">
				<path d="M16 11c0 2.209-1.791 4-4 4s-4-1.791-4-4v-7c0-2.209 1.791-4 4-4s4 1.791 4 4v7zm4-2v2c0 4.418-3.582 8-8 8s-8-3.582-8-8v-2h2v2c0 3.309 2.691 6 6 6s6-2.691 6-6v-2h2zm-7 13v-2h-2v2h-4v2h10v-2h-4z"></path>
			</symbol>
			<symbol id="mic-muted" viewBox="0 0 24 24">
				<path d="M16,11.4L12.4,15C14.3,14.8,15.8,13.3,16,11.4z"></path>
				<path d="M16,4.6V4c0-2.2-1.8-4-4-4S8,1.8,8,4v7c0,0.5,0.1,0.9,0.3,1.4L16,4.6z"></path>
				<path d="M13 20L11 20 11 22 7 22 7 24 17 24 17 22 13 22z"></path>
				<path d="M18,11c0,3.3-2.7,6-6,6c-0.5,0-1-0.1-1.4-0.2L9,18.4c0.9,0.4,2,0.6,3,0.6c4.4,0,8-3.6,8-8V9h-2V11z"></path>
				<path d="M6.7,13.9C6.3,13,6,12,6,11V9H4v2c0,1.6,0.5,3.1,1.3,4.3L6.7,13.9z"></path>
				<path d="M-3.4 11.2H27.400000000000002V12.7H-3.4z" transform="rotate(-45.001 12 12)"></path>
			</symbol>
			<symbol id="gamepad" viewBox="0 0 24 24">
				<path d="M17.622 3c-1.913 0-2.558 1.382-5.623 1.382-3.009 0-3.746-1.382-5.623-1.382-5.209 0-6.376 10.375-6.376 14.348 0 2.145.817 3.652 2.469 3.652 3.458 0 2.926-5 6.915-5h5.23c3.989 0 3.457 5 6.915 5 1.652 0 2.471-1.506 2.471-3.651 0-3.973-1.169-14.349-6.378-14.349zm-10.622 10c-1.657 0-3-1.343-3-3s1.343-3 3-3 3 1.343 3 3-1.343 3-3 3zm10-6c.552 0 1 .447 1 1 0 .553-.448 1-1 1s-1-.447-1-1c0-.553.448-1 1-1zm-2 4c-.552 0-1-.447-1-1 0-.553.448-1 1-1s1 .447 1 1c0 .553-.448 1-1 1zm2 2c-.552 0-1-.447-1-1 0-.553.448-1 1-1s1 .447 1 1c0 .553-.448 1-1 1zm2-2c-.552 0-1-.447-1-1 0-.553.448-1 1-1s1 .447 1 1c0 .553-.448 1-1 1zm-10.25-1c0 .965-.785 1.75-1.75 1.75s-1.75-.785-1.75-1.75.785-1.75 1.75-1.75 1.75.785 1.75 1.75z"></path>
			</symbol>
			<symbol id="ar" viewBox="0 0 24 24">
				<path d="M12 0l-11 6v12.131l11 5.869 11-5.869v-12.066l-11-6.065zm7.91 6.646l-7.905 4.218-7.872-4.294 7.862-4.289 7.915 4.365zm-16.91 1.584l8 4.363v8.607l-8-4.268v-8.702zm10 12.97v-8.6l8-4.269v8.6l-8 4.269zm6.678-5.315c.007.332-.256.605-.588.612-.332.007-.604-.256-.611-.588-.006-.331.256-.605.588-.612.331-.007.605.256.611.588zm-2.71-1.677c-.332.006-.595.28-.588.611.006.332.279.595.611.588s.594-.28.588-.612c-.007-.331-.279-.594-.611-.587zm-2.132-1.095c-.332.007-.595.281-.588.612.006.332.279.594.611.588.332-.007.594-.28.588-.612-.007-.331-.279-.594-.611-.588zm-9.902 2.183c.332.007.594.281.588.612-.007.332-.279.595-.611.588-.332-.006-.595-.28-.588-.612.005-.331.279-.594.611-.588zm1.487-.5c-.006.332.256.605.588.612s.605-.257.611-.588c.007-.332-.256-.605-.588-.611-.332-.008-.604.255-.611.587zm2.132-1.094c-.006.332.256.605.588.612.332.006.605-.256.611-.588.007-.332-.256-.605-.588-.612-.332-.007-.604.256-.611.588zm3.447-5.749c-.331 0-.6.269-.6.6s.269.6.6.6.6-.269.6-.6-.269-.6-.6-.6zm0-2.225c-.331 0-.6.269-.6.6s.269.6.6.6.6-.269.6-.6-.269-.6-.6-.6zm0-2.031c-.331 0-.6.269-.6.6s.269.6.6.6.6-.269.6-.6-.269-.6-.6-.6z"></path>
			</symbol>
			<symbol id="close" viewBox="0 0 24 24">
				<path d="M23 20.168l-8.185-8.187 8.185-8.174-2.832-2.807-8.182 8.179-8.176-8.179-2.81 2.81 8.186 8.196-8.186 8.184 2.81 2.81 8.203-8.192 8.18 8.192z"></path>
			</symbol>
			<symbol id="vr" viewBox="0 0 24 24">
				<path d="M22.3,4.3H1.7C0.8,4.3,0,5.1,0,6v12c0,0.9,0.8,1.7,1.7,1.7h5.6c0.7,0,1.4-0.5,1.6-1.2l1.4-4.2c0.5-1.6,2.7-1.6,3.3,0 l1.4,4.2c0.2,0.7,0.9,1.2,1.6,1.2h5.6c0.9,0,1.7-0.8,1.7-1.7V6C24,5.1,23.2,4.3,22.3,4.3z M6,14.6c-1.4,0-2.6-1.2-2.6-2.6 S4.6,9.4,6,9.4s2.6,1.2,2.6,2.6S7.4,14.6,6,14.6z M18,14.6c-1.4,0-2.6-1.2-2.6-2.6s1.2-2.6,2.6-2.6s2.6,1.2,2.6,2.6 S19.4,14.6,18,14.6z"></path>
			</symbol>
			<symbol id="vr-02" viewBox="0 0 24 24">
				<path d="M22.5,8.6c-0.3,0-0.6,0.1-0.8,0.3c-0.3-1.9-1.9-3.4-3.9-3.4H6.2c-2,0-3.6,1.5-3.9,3.4C2,8.7,1.7,8.6,1.4,8.6 C0.6,8.6,0,9.3,0,10.1v3.9c0,0.8,0.6,1.4,1.4,1.4c0.3,0,0.6-0.1,0.8-0.3c0.3,1.9,1.9,3.4,3.9,3.4h11.6c2,0,3.6-1.5,3.9-3.4 c0.2,0.2,0.5,0.3,0.8,0.3c0.8,0,1.4-0.6,1.4-1.4v-3.9C24,9.3,23.3,8.6,22.5,8.6z M20.7,14.6c0,1.6-1.3,2.8-2.8,2.8H6.2 c-1.6,0-2.8-1.3-2.8-2.8V9.4c0-1.6,1.3-2.8,2.8-2.8h11.6c1.6,0,2.8,1.3,2.8,2.8V14.6z"></path><circle cx="5.7" cy="8.7" r=".8"></circle><circle cx="18.3" cy="8.6" r=".8"></circle><circle cx="5.7" cy="15.4" r=".8"></circle><circle cx="18.3" cy="15.3" r=".8"></circle>
			</symbol>
			<symbol id="the-spy" viewBox="0 0 24 24">
				<path d="M17,14c-1.8,0-3.3,1.3-3.7,3h-2.5c-0.5-2.1-2.5-3.4-4.6-2.9c-2.1,0.5-3.4,2.5-2.9,4.6s2.5,3.4,4.6,2.9 c1.4-0.3,2.6-1.5,2.9-2.9h2.5c0.5,2.1,2.5,3.4,4.6,2.9s3.4-2.5,2.9-4.6C20.4,15.3,18.8,14,17,14z"></path>
				<path d="M23.2,11.5h-2.6V6c0-0.7-0.5-1.4-1.2-1.6l-5.5-1.8c-1.2-0.4-2.6-0.4-3.8,0L4.6,4.4C3.9,4.6,3.4,5.3,3.4,6v5.4H0.8 c-0.5,0-0.8,0.4-0.8,0.8s0.4,0.8,0.8,0.8h22.3c0.5,0,0.8-0.4,0.8-0.8S23.6,11.5,23.2,11.5z"></path>
			</symbol>
			<symbol id="spy-eye" viewBox="0 0 24 24">
				<path d="M12,19.6c-4.6,0-8.9-3.5-11.7-6.8c-0.4-0.5-0.4-1.2,0-1.6C3.1,7.9,7.4,4.4,12,4.4s8.9,3.5,11.7,6.8 c0.4,0.5,0.4,1.2,0,1.6C20.9,16.1,16.6,19.6,12,19.6z M12,7.5c2.5,0,4.4,1.9,4.4,4.4s-1.9,4.4-4.4,4.4s-4.4-1.9-4.4-4.4 S9.5,7.5,12,7.5z" clip-rule="evenodd"></path>
				<path d="M12,9.3c1.4,0,2.6,1.2,2.6,2.6s-1.2,2.6-2.6,2.6s-2.6-1.2-2.6-2.6S10.6,9.3,12,9.3z" fill-rule="evenodd" ></path>
			</symbol>
			<symbol id="copy" viewBox="0 0 24 24">
				<path d="M7 16h10v1h-10v-1zm0-1h10v-1h-10v1zm15-13v22h-20v-22h3c1.229 0 2.18-1.084 3-2h8c.82.916 1.771 2 3 2h3zm-11 1c0 .552.448 1 1 1s1-.448 1-1-.448-1-1-1-1 .448-1 1zm9 1h-4l-2 2h-3.898l-2.102-2h-4v18h16v-18zm-13 9h10v-1h-10v1zm0-2h10v-1h-10v1z"></path>
			</symbol>
			<symbol id="menu" viewBox="0 0 24 24">
				<path d="M12 18c1.657 0 3 1.343 3 3s-1.343 3-3 3-3-1.343-3-3 1.343-3 3-3zm0-9c1.657 0 3 1.343 3 3s-1.343 3-3 3-3-1.343-3-3 1.343-3 3-3zm0-9c1.657 0 3 1.343 3 3s-1.343 3-3 3-3-1.343-3-3 1.343-3 3-3z"></path>
			</symbol>
			<symbol id="menu-light" viewBox="0 0 24 24">
				<path d="M14 19h-14v-1h14v1zm9.247-8.609l-3.247 4.049-3.263-4.062-.737.622 4 5 4-5-.753-.609zm-9.247 2.609h-14v-1h14v1zm0-6h-14v-1h14v1z"/>
			</symbol>
			<symbol id="settings" viewBox="0 0 24 24">
				<path d="M24 14.187v-4.374c-2.148-.766-2.726-.802-3.027-1.529-.303-.729.083-1.169 1.059-3.223l-3.093-3.093c-2.026.963-2.488 1.364-3.224 1.059-.727-.302-.768-.889-1.527-3.027h-4.375c-.764 2.144-.8 2.725-1.529 3.027-.752.313-1.203-.1-3.223-1.059l-3.093 3.093c.977 2.055 1.362 2.493 1.059 3.224-.302.727-.881.764-3.027 1.528v4.375c2.139.76 2.725.8 3.027 1.528.304.734-.081 1.167-1.059 3.223l3.093 3.093c1.999-.95 2.47-1.373 3.223-1.059.728.302.764.88 1.529 3.027h4.374c.758-2.131.799-2.723 1.537-3.031.745-.308 1.186.099 3.215 1.062l3.093-3.093c-.975-2.05-1.362-2.492-1.059-3.223.3-.726.88-.763 3.027-1.528zm-4.875.764c-.577 1.394-.068 2.458.488 3.578l-1.084 1.084c-1.093-.543-2.161-1.076-3.573-.49-1.396.581-1.79 1.693-2.188 2.877h-1.534c-.398-1.185-.791-2.297-2.183-2.875-1.419-.588-2.507-.045-3.579.488l-1.083-1.084c.557-1.118 1.066-2.18.487-3.58-.579-1.391-1.691-1.784-2.876-2.182v-1.533c1.185-.398 2.297-.791 2.875-2.184.578-1.394.068-2.459-.488-3.579l1.084-1.084c1.082.538 2.162 1.077 3.58.488 1.392-.577 1.785-1.69 2.183-2.875h1.534c.398 1.185.792 2.297 2.184 2.875 1.419.588 2.506.045 3.579-.488l1.084 1.084c-.556 1.121-1.065 2.187-.488 3.58.577 1.391 1.689 1.784 2.875 2.183v1.534c-1.188.398-2.302.791-2.877 2.183zm-7.125-5.951c1.654 0 3 1.346 3 3s-1.346 3-3 3-3-1.346-3-3 1.346-3 3-3zm0-2c-2.762 0-5 2.238-5 5s2.238 5 5 5 5-2.238 5-5-2.238-5-5-5z"/>
			</symbol>
			<symbol id="settings-full" viewBox="0 0 24 24">
				<path d="M24 13.616v-3.232l-2.869-1.02c-.198-.687-.472-1.342-.811-1.955l1.308-2.751-2.285-2.285-2.751 1.307c-.613-.339-1.269-.613-1.955-.811l-1.021-2.869h-3.232l-1.021 2.869c-.686.198-1.342.471-1.955.811l-2.751-1.308-2.285 2.285 1.308 2.752c-.339.613-.614 1.268-.811 1.955l-2.869 1.02v3.232l2.869 1.02c.197.687.472 1.342.811 1.955l-1.308 2.751 2.285 2.286 2.751-1.308c.613.339 1.269.613 1.955.811l1.021 2.869h3.232l1.021-2.869c.687-.198 1.342-.472 1.955-.811l2.751 1.308 2.285-2.286-1.308-2.751c.339-.613.613-1.268.811-1.955l2.869-1.02zm-12 2.384c-2.209 0-4-1.791-4-4s1.791-4 4-4 4 1.791 4 4-1.791 4-4 4z"/>
			</symbol>
			<symbol id="emoji" viewBox="0 0 24 24">
				<path d="M12,2c5.5,0,10,4.5,10,10s-4.5,10-10,10S2,17.5,2,12S6.5,2,12,2z M12,0C5.4,0,0,5.4,0,12s5.4,12,12,12s12-5.4,12-12 S18.6,0,12,0z M18,14H6c0.3,1.5,2.8,4,6,4C15.1,18,17.7,15.5,18,14z M8.5,8C7.7,8,7,8.7,7,9.5S7.7,11,8.5,11S10,10.3,10,9.5 S9.3,8,8.5,8z M15.5,8C14.7,8,14,8.7,14,9.5s0.7,1.5,1.5,1.5c0.8,0,1.5-0.7,1.5-1.5S16.3,8,15.5,8z"/>
			</symbol>
			<symbol id="pencil" viewBox="0 0 24 24">
				<path d="M19.769 9.923l-12.642 12.639-7.127 1.438 1.438-7.128 12.641-12.64 5.69 5.691zm1.414-1.414l2.817-2.82-5.691-5.689-2.816 2.817 5.69 5.692z"/>
			</symbol>
			<symbol id="erase" viewBox="0 0 24 24">
				<path d="M5.662 23l-5.369-5.365c-.195-.195-.293-.45-.293-.707 0-.256.098-.512.293-.707l14.929-14.928c.195-.194.451-.293.707-.293.255 0 .512.099.707.293l7.071 7.073c.196.195.293.451.293.708 0 .256-.097.511-.293.707l-11.216 11.219h5.514v2h-12.343zm3.657-2l-5.486-5.486-1.419 1.414 4.076 4.072h2.829zm.456-11.429l-4.528 4.528 5.658 5.659 4.527-4.53-5.657-5.657z"/>
			</symbol>
			<symbol id="move" viewBox="0 0 24 24">
				<path d="M12 10c1.104 0 2 .896 2 2s-.896 2-2 2-2-.896-2-2 .896-2 2-2zm-3.857 3c-.084-.321-.143-.652-.143-1s.059-.679.143-1h-2.143v-4l-6 5 6 5v-4h2.143zm7.714-2c.084.321.143.652.143 1s-.059.679-.143 1h2.143v4l6-5-6-5v4h-2.143zm-2.857 4.857c-.321.084-.652.143-1 .143s-.679-.059-1-.143v2.143h-4l5 6 5-6h-4v-2.143zm-2-7.714c.321-.084.652-.143 1-.143s.679.059 1 .143v-2.143h4l-5-6-5 6h4v2.143z"/>
			</symbol>
			<symbol id="caret-down" viewBox="0 0 8 5">
				<path d="M0 0h8L4 5 0 0z" fill-rule="evenodd" clip-rule="evenodd"></path>
			</symbol>
			<symbol id="caret-right" viewBox="0 0 8 12">
				<path d="M0 12V0l8 6-8 6z" fill-rule="evenodd" clip-rule="evenodd"></path>
			</symbol>
			<symbol id="websolute" viewBox="0 0 20 20">
				<path d="M20 10c0 5.5-4.5 10-10 10S0 15.5 0 10 4.5 0 10 0s10 4.5 10 10m-10 2.3c.5.5 1.3.8 2.1.8s1.5-.3 2.1-.8c.5-.5.8-1.2.8-2V7.5h-1.7v2.8c0 .3-.1.6-.4.8-.1.1-.3.2-.4.3-.2.1-.3.1-.5.1s-.3 0-.5-.1c-.1-.1-.3-.2-.4-.3-.2-.2-.4-.5-.4-.8V7.6H9.2v2.8c0 .3-.1.6-.4.9-.2.2-.5.4-.8.4-.3 0-.7-.1-.9-.3-.2-.2-.4-.5-.3-.8V7.5H5v2.8c0 .7.3 1.5.8 2 .6.5 1.3.8 2.1.8.8.1 1.6-.2 2.1-.8z" fill-rule="evenodd" clip-rule="evenodd"></path>
			</symbol>
			<symbol id="search" viewBox="0 0 21 23">
				<path d="M20.6 20.3l-4.9-5.2c1.2-1.7 1.8-3.7 1.8-5.7 0-5.2-3.9-9.4-8.7-9.4S0 4.2 0 9.4s3.7 7.8 6.3 8.4c1.8.4 3.9.6 7.1-.7l5.1 5.4c.5.6 1.4.6 2 .1l.1-.1c.5-.6.5-1.6 0-2.2zM15 9.4c-.2 3.5-3.2 6.1-6.7 5.8S2.2 12 2.5 8.5c.2-3.3 3-5.8 6.3-5.8 3.5.1 6.3 3.1 6.2 6.7z" fill-rule="evenodd" clip-rule="evenodd"></path>
			</symbol>
			<symbol id="result-indicator" viewBox="0 0 24 24">
				<path d="M11 21.883l-6.235-7.527-.765.644 7.521 9 7.479-9-.764-.645-6.236 7.529v-21.884h-1v21.883z"></path>
			</symbol>
			<symbol id="bullet" viewBox="0 0 18 18">
				<path d="M9 2c3.9 0 7 3.1 7 7s-3.1 7-7 7-7-3.1-7-7 3.1-7 7-7m0-2C4 0 0 4 0 9s4 9 9 9 9-4 9-9-4-9-9-9z" opacity=".15" fill="#17265a"></path>
				<circle cx="9" cy="9" r="4" fill="#17265a"></circle>
			</symbol>
			<symbol id="play" viewBox="0 0 16 20">
				<path d="M0,0v19.8l15.4-11L0,0z" fill-rule="evenodd" clip-rule="evenodd" ></path>
			</symbol>
			<symbol id="play-progress" viewBox="0 0 196 196">
				<path d="M195.5,98c0,53.8-43.7,97.5-97.5,97.5S0.5,151.8,0.5,98S44.2,0.5,98,0.5S195.5,44.2,195.5,98z" stroke-width="2px" stroke-linecap="square" ></path>
			</symbol>
			<symbol id="pause" viewBox="0 0 16 20">
				<path d="M0 0.9H4V18.9H0z"></path>
				<path d="M11.4 0.9H15.4V18.9H11.4z"></path>
			</symbol>
			<symbol id="wishlist-add" viewBox="0 0 25 20">
				<path d="M12.5,20.8c-0.3,0-0.5-0.1-0.8-0.3c-0.3-0.2-0.6-0.4-0.9-0.6c-0.7-0.5-1.4-0.9-2.1-1.5 c-1.1-0.8-2.1-1.6-3.1-2.4C4.2,15,3,13.8,1.9,12.4c-0.9-1.1-1.4-2.3-1.7-3.7C0.1,8.5,0.1,8.2,0,7.9l0-0.2l0.1-1.4 c0-0.1,0.1-0.3,0.1-0.4c0.1-0.3,0.1-0.7,0.3-1c0.6-1.7,1.8-3.2,3.4-4c1.5-0.8,3.3-1.1,5-0.8c1.4,0.2,2.6,0.8,3.7,1.7 c2.9-2.4,7.2-2.4,10,0.1c1.1,0.9,1.9,2.2,2.2,3.5c0.1,0.3,0.1,0.6,0.2,0.8L25,6.7l-0.1,1.4c-0.2,1.2-0.6,2.4-1.2,3.4 c-0.5,0.8-1.1,1.6-1.8,2.3c-0.8,0.9-1.7,1.7-2.6,2.5c-0.7,0.6-1.6,1.3-2.6,2c-0.8,0.5-1.5,1.1-2.3,1.6c-0.4,0.3-0.8,0.5-1.2,0.8 C13.1,20.8,12.8,20.8,12.5,20.8z M2.1,7.6c0,0.2,0.1,0.4,0.1,0.6c0.2,1.1,0.7,2,1.4,2.9c1,1.2,2.1,2.3,3.3,3.3c1,0.8,2,1.6,3,2.4 c0.7,0.5,1.4,0.9,2.1,1.4l0.5,0.3c0.2-0.2,0.5-0.3,0.7-0.5c0.8-0.5,1.5-1,2.3-1.6c0.9-0.7,1.8-1.4,2.5-1.9c0.9-0.7,1.7-1.5,2.4-2.3 c0.6-0.6,1.1-1.2,1.5-1.9c0.5-0.8,0.8-1.7,0.9-2.6c0-0.1,0-0.1,0-0.2l0-0.9c0-0.2-0.1-0.4-0.1-0.6c-0.3-1-0.8-1.9-1.6-2.5 c-2.1-1.8-5.2-1.8-7.3,0c-0.1,0.1-0.3,0.2-0.4,0.4l-0.9,1.2l-1-1.3c-0.8-0.8-1.9-1.4-3-1.6C7.2,2,5.9,2.2,4.9,2.8 c-1.1,0.6-2,1.6-2.4,2.8C2.4,5.9,2.3,6.1,2.3,6.4c0,0.1-0.1,0.3-0.1,0.4l0,0L2.1,7.6L2.1,7.6z" clip-rule="evenodd" fill-rule="evenodd" ></path>
			</symbol>
			<symbol id="wishlist-added" viewBox="0 0 25 20">
				<path d="M12.5,20.8c-0.3,0-0.5-0.1-0.8-0.3c-0.3-0.2-0.6-0.4-0.9-0.6c-0.7-0.5-1.4-0.9-2.1-1.5 c-1.1-0.8-2.1-1.6-3.1-2.4c-1.4-1-2.6-2.2-3.7-3.6C1,11.3,0.5,10.1,0.2,8.7C0.1,8.5,0.1,8.2,0,7.9V7.7l0.1-1.4 c0-0.1,0.1-0.3,0.1-0.4c0.1-0.3,0.1-0.7,0.3-1c0.6-1.7,1.8-3.2,3.4-4c1.5-0.8,3.3-1.1,5-0.8c1.4,0.2,2.6,0.8,3.7,1.7 c2.9-2.4,7.2-2.4,10,0.1c1.1,0.9,1.9,2.2,2.2,3.5C24.9,5.7,24.9,6,25,6.2v0.5l-0.1,1.4c-0.2,1.2-0.6,2.4-1.2,3.4 c-0.5,0.8-1.1,1.6-1.8,2.3c-0.8,0.9-1.7,1.7-2.6,2.5c-0.7,0.6-1.6,1.3-2.6,2c-0.8,0.5-1.5,1.1-2.3,1.6c-0.4,0.3-0.8,0.5-1.2,0.8 C13.1,20.8,12.8,20.8,12.5,20.8z" clip-rule="evenodd" fill-rule="evenodd" ></path>
			</symbol>
			<symbol id="wishlist" viewBox="0 0 16 14">
				<path d="M8,14c-0.2,0-0.3-0.1-0.5-0.2l-0.6-0.4c-0.5-0.3-0.9-0.6-1.4-1c-0.7-0.5-1.4-1.1-2-1.6 c-0.9-0.7-1.6-1.6-2.3-2.5C0.7,7.6,0.3,6.8,0.1,5.9c0-0.2-0.1-0.4-0.1-0.5l0-0.1l0-1c0-0.1,0-0.2,0.1-0.3c0.1-0.2,0.1-0.4,0.2-0.7 c0.4-1.1,1.2-2.1,2.2-2.7c1.8-1,4-0.8,5.5,0.6c1.8-1.6,4.6-1.6,6.4,0.1c0.7,0.6,1.2,1.5,1.4,2.4C15.9,3.8,15.9,4,16,4.2l0,0.3l0,0.9 c-0.1,0.8-0.4,1.6-0.8,2.3c-0.3,0.5-0.7,1-1.1,1.5c-0.5,0.6-1.1,1.1-1.7,1.7c-0.4,0.4-1,0.9-1.7,1.3c-0.5,0.4-1,0.7-1.5,1.1 c-0.2,0.2-0.5,0.3-0.7,0.5C8.4,13.9,8.2,14,8,14z M1.4,5.1c0,0.1,0.1,0.3,0.1,0.4c0.1,0.7,0.4,1.4,0.9,1.9C2.9,8.3,3.6,9,4.4,9.7 c0.6,0.5,1.3,1.1,1.9,1.6c0.4,0.3,0.9,0.6,1.3,0.9c0.1,0.1,0.2,0.2,0.3,0.2c0.2-0.1,0.3-0.2,0.5-0.3c0.5-0.3,1-0.7,1.5-1 c0.6-0.4,1.2-0.9,1.6-1.3c0.5-0.5,1.1-1,1.5-1.5c0.4-0.4,0.7-0.8,1-1.3c0.3-0.5,0.5-1.1,0.6-1.7c0,0,0-0.1,0-0.1l0-0.6 c0-0.1,0-0.3-0.1-0.4c-0.2-0.7-0.5-1.2-1-1.7c-1.3-1.2-3.4-1.2-4.7,0C8.7,2.4,8.6,2.5,8.5,2.6L8,3.4L7.3,2.5 C6.3,1.4,4.5,1.1,3.1,1.9C2.4,2.3,1.8,3,1.6,3.8C1.5,3.9,1.5,4.1,1.4,4.3L1.4,4.6l0,0L1.4,5.1L1.4,5.1z" clip-rule="evenodd" fill-rule="evenodd" ></path>
			</symbol>
			<symbol id="expand" viewBox="0 0 29 30">
				<path d="M26 16.3V5.9L2.2 29.7.1 27.6 24 3.3H13v-3h16v16h-3z" fill-rule="evenodd" clip-rule="evenodd"></path>
			</symbol>
			<symbol id="download" viewBox="0 0 9 13">
				<path d="M8.5 7.9c-.3-.4-.8-.4-1.2-.1l-.1.1-2 2V1.2c0-.2-.1-.4-.2-.6-.2-.3-.7-.3-1 0-.2.2-.3.4-.3.6v8.6l-2-2c-.2-.1-.4-.2-.7-.2-.2 0-.4.1-.6.3-.1.2-.1.4-.1.6 0 .2.1.4.2.5l3.4 3.4c.2.2.4.2.6.2.2 0 .4-.1.6-.2L8.4 9c.2-.1.2-.3.3-.6 0-.1-.1-.4-.2-.5z" fill-rule="evenodd" clip-rule="evenodd"></path>
			</symbol>
			<symbol id="upload" viewBox="0 0 24 24">
				<path d="M10 9H4l8-9 8 9h-6v11h-4V9zm11 11v2H3v-2H1v4h22v-4h-2z"></path>
			</symbol>
			<symbol id="user" viewBox="0 0 24 24">
				<path d="M20.822 18.096c-3.439-.794-6.64-1.49-5.09-4.418C20.452 4.766 16.983 0 12 0 6.918 0 3.536 4.949 8.268 13.678c1.597 2.945-1.725 3.641-5.09 4.418C.105 18.806-.01 20.332 0 23l.004 1h23.99l.004-.969c.012-2.688-.092-4.222-3.176-4.935z"></path>
			</symbol>
			<symbol id="back" viewBox="0 0 24 24">
				<path d="M2.117 12l7.527 6.235L9 19l-9-7.521L9 4l.645.764L2.116 11H24v1H2.117z" fill-rule="evenodd" clip-rule="evenodd"></path>
			</symbol>
			<symbol id="add" viewBox="0 0 24 24">
				<path d="M24 10h-10v-10h-4v10h-10v4h10v10h4v-10h10z"></path>
			</symbol>
			<symbol id="remove" viewBox="0 0 24 24">
				<path d="M0 10h24v4h-24z"></path>
			</symbol>
			<symbol id="link" viewBox="0 0 24 24">
				<path d="M6.188 8.719c.439-.439.926-.801 1.444-1.087 2.887-1.591 6.589-.745 8.445 2.069l-2.246 2.245c-.644-1.469-2.243-2.305-3.834-1.949-.599.134-1.168.433-1.633.898l-4.304 4.306c-1.307 1.307-1.307 3.433 0 4.74 1.307 1.307 3.433 1.307 4.74 0l1.327-1.327c1.207.479 2.501.67 3.779.575l-2.929 2.929c-2.511 2.511-6.582 2.511-9.093 0s-2.511-6.582 0-9.093l4.304-4.306zm6.836-6.836l-2.929 2.929c1.277-.096 2.572.096 3.779.574l1.326-1.326c1.307-1.307 3.433-1.307 4.74 0 1.307 1.307 1.307 3.433 0 4.74l-4.305 4.305c-1.311 1.311-3.44 1.3-4.74 0-.303-.303-.564-.68-.727-1.051l-2.246 2.245c.236.358.481.667.796.982.812.812 1.846 1.417 3.036 1.704 1.542.371 3.194.166 4.613-.617.518-.286 1.005-.648 1.444-1.087l4.304-4.305c2.512-2.511 2.512-6.582.001-9.093-2.511-2.51-6.581-2.51-9.092 0z"></path>
			</symbol>
			<symbol id="up" viewBox="0 0 24 24">
				<path d="M7 11h-6l11-11 11 11h-6v13h-10z"></path>
			</symbol>
			<symbol id="down" viewBox="0 0 24 24">
				<path d="M17,13h6L12,24L1,13h6V0h10V13z"></path>
			</symbol>
			<symbol id="waiting-room" viewBox="0 0 24 24">
				<path d="M2,6c0-2.2,1.8-4,4-4h12c2.2,0,4,1.8,4,4v12c0,2.2-1.8,4-4,4H6c-2.2,0-4-1.8-4-4V6z" opacity=".2"></path>
				<path d="M17.8,10.7c0.7,0,1.3,0.6,1.3,1.3s-0.6,1.3-1.3,1.3H6.2c-0.7,0-1.3-0.6-1.3-1.3s0.6-1.3,1.3-1.3H17.8z M19.7,12 c0-1.1-0.9-1.9-1.9-1.9H6.2c-1.1,0-1.9,0.9-1.9,1.9s0.9,1.9,1.9,1.9h11.6C18.9,13.9,19.7,13.1,19.7,12z M13.9,11.4H6.2 c-0.4,0-0.6,0.3-0.6,0.6s0.3,0.6,0.6,0.6h7.7c0.4,0,0.6-0.3,0.6-0.6S14.3,11.4,13.9,11.4z"></path>
			</symbol>
			<symbol id="panorama" viewBox="0 0 24 24">
				<path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path>
				<path d="M 9 15 C 9 14.448 9.448 14 10 14 L 14 14 C 14.552 14 15 14.448 15 15 L 15 16 C 15 16.552 14.552 17 14 17 L 10 17 C 9.448 17 9 16.552 9 16 Z" fill="var(--svg-icon-tint)" opacity="0.4"></path>
				<path d="M 7 8 C 7 7.448 7.448 7 8 7 L 16 7 C 16.552 7 17 7.448 17 8 L 17 12 C 17 12.552 16.552 13 16 13 L 8 13 C 7.448 13 7 12.552 7 12 Z" fill="var(--svg-icon-tint)"></path>
			</symbol>
			<symbol id="panorama-grid" viewBox="0 0 24 24">
				<path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path>
				<path d="M 7.333 8.333 C 7.333 7.781 7.781 7.333 8.333 7.333 L 10.333 7.333 C 10.886 7.333 11.333 7.781 11.333 8.333 L 11.333 10.333 C 11.333 10.886 10.886 11.333 10.333 11.333 L 8.333 11.333 C 7.781 11.333 7.333 10.886 7.333 10.333 Z" fill="var(--svg-icon-tint)" opacity="0.4"></path>
				<path d="M 12.333 8.333 C 12.333 7.781 12.781 7.333 13.333 7.333 L 15.333 7.333 C 15.886 7.333 16.333 7.781 16.333 8.333 L 16.333 10.333 C 16.333 10.886 15.886 11.333 15.333 11.333 L 13.333 11.333 C 12.781 11.333 12.333 10.886 12.333 10.333 Z" fill="var(--svg-icon-tint)" opacity="0.4"></path>
				<path d="M 7.333 13.667 C 7.333 13.114 7.781 12.667 8.333 12.667 L 10.333 12.667 C 10.886 12.667 11.333 13.114 11.333 13.667 L 11.333 15.667 C 11.333 16.219 10.886 16.667 10.333 16.667 L 8.333 16.667 C 7.781 16.667 7.333 16.219 7.333 15.667 Z" fill="var(--svg-icon-tint)"></path>
				<path d="M 12.333 13.667 C 12.333 13.114 12.781 12.667 13.333 12.667 L 15.333 12.667 C 15.886 12.667 16.333 13.114 16.333 13.667 L 16.333 15.667 C 16.333 16.219 15.886 16.667 15.333 16.667 L 13.333 16.667 C 12.781 16.667 12.333 16.219 12.333 15.667 Z" fill="var(--svg-icon-tint)" opacity="0.4"></path>
			</symbol>
			<symbol id="room-3d" viewBox="0 0 24 24">
				<path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path>
				<path d="M 6.6 9.056 C 6.6 8.533 6.905 8.059 7.381 7.842 L 8.995 7.108 C 9.436 6.907 9.938 7.23 9.938 7.715 L 9.938 16.272 C 9.938 16.757 9.436 17.08 8.995 16.879 L 7.381 16.145 C 6.905 15.928 6.6 15.454 6.6 14.931 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path>
				<path d="M 10.754 7.453 C 10.754 6.795 11.378 6.316 12.014 6.487 L 16.32 7.647 C 17.193 7.882 17.8 8.674 17.8 9.578 L 17.8 14.105 C 17.8 15.009 17.193 15.801 16.32 16.036 L 12.014 17.196 C 11.378 17.367 10.754 16.889 10.754 16.231 Z" fill="var(--svg-icon-tint)"></path>
			</symbol>
			<symbol id="model" viewBox="0 0 24 24">
				<path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.3"></path>
				<path d="M 11.298 7.283 C 11.602 6.729 12.398 6.729 12.702 7.283 L 14.009 9.673 C 14.082 9.807 14.193 9.918 14.327 9.991 L 16.717 11.298 C 17.271 11.602 17.271 12.398 16.717 12.702 L 14.327 14.009 C 14.193 14.082 14.082 14.193 14.009 14.327 L 12.702 16.717 C 12.398 17.271 11.602 17.271 11.298 16.717 L 9.991 14.327 C 9.918 14.193 9.807 14.082 9.673 14.009 L 7.283 12.702 C 6.729 12.398 6.729 11.602 7.283 11.298 L 9.673 9.991 C 9.807 9.918 9.918 9.807 9.991 9.673 Z" fill="var(--svg-icon-tint)"></path>
			</symbol>
			<symbol id="media" viewBox="0 0 24 24">
				<path d="M2,6c0-2.2,1.8-4,4-4h12c2.2,0,4,1.8,4,4v12c0,2.2-1.8,4-4,4H6c-2.2,0-4-1.8-4-4V6z" fill="var(--svg-icon-tint)" opacity="0.3"></path>
				<path d="M12,19c-2.2,0-4.3-1-5.6-2.7L7,15.9c1.2,1.5,3,2.4,5,2.4c1.9,0,3.8-0.9,5-2.4l0.6,0.4C16.3,18,14.2,19,12,19z M5.5,14.7C5.2,13.8,5,12.8,5,12c0-3.5,2.7-6.5,6.2-7v0.6C8,6.1,5.7,8.8,5.7,12c0,0.8,0.1,1.5,0.4,2.4L5.5,14.7z M18,14.4 c0.3-0.8,0.4-1.6,0.4-2.4c0-3.2-2.3-5.9-5.5-6.4c0-0.2,0-0.5,0-0.6c3.5,0.4,6.2,3.4,6.2,7c0,0.8-0.2,1.8-0.5,2.7L18,14.4z" fill="var(--svg-icon-tint)" opacity="0.3"></path>
				<path d="M10.2,15V8.9l5.5,3.1L10.2,15z" fill="var(--svg-icon-tint)"></path>
			</symbol>
			<symbol id="nav" viewBox="0 0 24 24">
				<path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path>
				<path d="M 6.5 8.667 C 6.5 8.114 6.948 7.667 7.5 7.667 L 16.5 7.667 C 17.052 7.667 17.5 8.114 17.5 8.667 L 17.5 14.495 C 17.5 15.046 17.053 15.494 16.502 15.495 L 14.189 15.499 C 13.959 15.5 13.736 15.58 13.558 15.725 L 12.211 16.827 C 12.088 16.928 11.912 16.928 11.789 16.827 L 10.442 15.725 C 10.264 15.58 10.041 15.5 9.811 15.499 L 7.498 15.495 C 6.947 15.494 6.5 15.046 6.5 14.495 Z" fill="var(--svg-icon-tint)"></path>
			</symbol>
			<symbol id="plane" viewBox="0 0 24 24">
				<path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path>
				<path d="M 2 1 L 1 0 L 0 1" transform="translate(4.667 11.5) rotate(-90 1 0.5)" fill="transparent" opacity="0.4" stroke="var(--svg-icon-tint)" stroke-linecap="round" stroke-linejoin="round"></path>
				<path d="M 2 1 L 1 0 L 0 1" transform="translate(17.333 11.5) rotate(90 1 0.5)" fill="transparent" opacity="0.4" stroke="var(--svg-icon-tint)" stroke-linecap="round" stroke-linejoin="round"></path>
				<path d="M 8 9 C 8 8.448 8.448 8 9 8 L 15 8 C 15.552 8 16 8.448 16 9 L 16 15 C 16 15.552 15.552 16 15 16 L 9 16 C 8.448 16 8 15.552 8 15 Z" fill="var(--svg-icon-tint)"></path>
			</symbol>
			<symbol id="curved-plane" viewBox="0 0 24 24">
				<path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path>
				<path d="M 2 1 L 1 0 L 0 1" transform="translate(4.667 11.5) rotate(-90 1 0.5)" fill="transparent" opacity="0.4" stroke="var(--svg-icon-tint)" stroke-linecap="round" stroke-linejoin="round"></path>
				<path d="M 2 1 L 1 0 L 0 1" transform="translate(17.333 11.5) rotate(90 1 0.5)" fill="transparent" opacity="0.4" stroke="var(--svg-icon-tint)" stroke-linecap="round" stroke-linejoin="round"></path>
				<path d="M 8 9 C 8 8.448 8.448 8 9 8 L 15 8 C 15.552 8 16 8.448 16 9 L 16 15 C 16 15.552 15.552 16 15 16 L 9 16 C 8.448 16 8 15.552 8 15 Z" fill="var(--svg-icon-tint)"></path>
			</symbol>
			<symbol id="texture" viewBox="0 0 24 24">
				<path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path>
				<path d="M 7.333 8.95 C 7.333 8.274 7.839 7.705 8.511 7.626 L 14.805 6.886 C 15.796 6.769 16.667 7.543 16.667 8.541 L 16.667 15.49 C 16.667 16.477 15.814 17.247 14.833 17.148 L 8.533 16.513 C 7.852 16.444 7.333 15.871 7.333 15.187 Z" fill="var(--svg-icon-tint)"></path>
			</symbol>
			<symbol id="gltf" viewBox="0 0 24 24">
				<path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.3"></path>
				<path d="M 11.298 7.283 C 11.602 6.729 12.398 6.729 12.702 7.283 L 14.009 9.673 C 14.082 9.807 14.193 9.918 14.327 9.991 L 16.717 11.298 C 17.271 11.602 17.271 12.398 16.717 12.702 L 14.327 14.009 C 14.193 14.082 14.082 14.193 14.009 14.327 L 12.702 16.717 C 12.398 17.271 11.602 17.271 11.298 16.717 L 9.991 14.327 C 9.918 14.193 9.807 14.082 9.673 14.009 L 7.283 12.702 C 6.729 12.398 6.729 11.602 7.283 11.298 L 9.673 9.991 C 9.807 9.918 9.918 9.807 9.991 9.673 Z" fill="var(--svg-icon-tint)"></path>
			</symbol>
			<symbol id="tile" viewBox="0 0 24 24">
				<path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path>
				<path d="M 15.667 13 C 17.139 13 18.333 14.194 18.333 15.667 C 18.333 17.139 17.139 18.333 15.667 18.333 C 14.194 18.333 13 17.139 13 15.667 C 13 14.194 14.194 13 15.667 13 Z" fill="var(--svg-icon-tint)"></path>
			</symbol>
			<symbol id="image" viewBox="0 0 24 24">
				<path d="M5 8.5c0-.828.672-1.5 1.5-1.5s1.5.672 1.5 1.5c0 .829-.672 1.5-1.5 1.5s-1.5-.671-1.5-1.5zm9 .5l-2.519 4-2.481-1.96-4 5.96h14l-5-8zm8-4v14h-20v-14h20zm2-2h-24v18h24v-18z"></path>
			</symbol>
			<symbol id="video" viewBox="0 0 24 24">
				<path d="M2.184 7.874l-2.184-.918 2.967-2.956.933 2.164-1.716 1.71zm21.816 2.126l-3 2v4l3 2v-8zm-7-2h-7.018l.79.787c.356.355.629.769.831 1.213h4.897c.276 0 .5.224.5.5v7c0 .276-.224.5-.5.5h-11c-.276 0-.5-.224-.5-.5v-2.909l-.018-.014-1.982-1.975v5.398c0 1.104.896 2 2 2h12c1.104 0 2-.896 2-2v-8c0-1.104-.896-2-2-2zm-14.65 1.13l2.967-2.956 4.044 4.029c.819.816.819 2.14 0 2.956-.819.816-2.147.815-2.967 0l-4.044-4.029z"></path>
			</symbol>
			<symbol id="stream" viewBox="0 0 24 24">
				<path d="M6.613 18.581m9.387-9.581c0 2.209-1.791 4-4 4s-4-1.791-4-4 1.791-4 4-4 4 1.791 4 4zm-2 0c0-1.103-.896-2-2-2s-2 .897-2 2 .896 2 2 2 2-.897 2-2zm-9 0c0 3.86 3.141 7 7 7s7-3.14 7-7-3.141-7-7-7-7 3.14-7 7zm16 0c0 4.97-4.029 9-9 9s-9-4.03-9-9 4.029-9 9-9 9 4.03 9 9zm-.404 12.501c1.007 1.142-.014 2.679-1.448 2.481-1.795-.245-3.236-1.702-7.147-1.702-3.91 0-5.352 1.458-7.146 1.702-1.436.198-2.456-1.34-1.449-2.481l2.898-3.289c.559.388 1.156.725 1.79.994l-2.025 2.298c1.295-.524 3.065-1.225 5.933-1.225s4.638.7 5.933 1.224l-2.025-2.298c.634-.27 1.231-.606 1.79-.994l2.896 3.29z"></path>
			</symbol>
			<symbol id="spinner" viewBox="0 0 24 24">
				<path d="M8.175 7.377l-3.042-5.27 1.732-1 3.045 5.273c-.635.238-1.222.573-1.735.997zm-.799.8l-5.27-3.042-1 1.732 5.274 3.045c.237-.635.572-1.223.996-1.735zm-1.376 3.823c0-.341.035-.673.09-.999h-6.09v1.999h6.09c-.055-.326-.09-.659-.09-1zm11.351-2.705l5.208-3.007-.333-.577-5.206 3.007c.121.185.23.379.331.577zm-5.351-3.295c.341 0 .673.035.999.09v-6.09h-1.999v6.09c.326-.055.659-.09 1-.09zm3.14.894l3.004-5.204-.288-.166-3 5.197.284.173zm1.685 8.662l5.234 3.022.666-1.154-5.229-3.019c-.181.41-.408.794-.671 1.151zm-10.444-1.467l-5.274 3.046 1 1.732 5.27-3.042c-.424-.513-.759-1.1-.996-1.736zm11.594-2.589l.025.5-.025.5h6.025v-1h-6.025zm-3.727 6.061l3.03 5.249 1.442-.833-3.031-5.25c-.437.34-.92.623-1.441.834zm-2.248.439c-.341 0-.674-.035-1-.09v6.09h1.999v-6.09c-.326.055-.658.09-.999.09zm-3.824-1.376l-3.042 5.27 1.732 1 3.045-5.274c-.635-.237-1.222-.572-1.735-.996z"></path>
			</symbol>
			<symbol id="update" viewBox="0 0 24 24">
				<path d="M23 12c0 1.042-.154 2.045-.425 3h-2.101c.335-.94.526-1.947.526-3 0-4.962-4.037-9-9-9-1.706 0-3.296.484-4.655 1.314l1.858 2.686h-6.994l2.152-7 1.849 2.673c1.684-1.049 3.659-1.673 5.79-1.673 6.074 0 11 4.925 11 11zm-6.354 7.692c-1.357.826-2.944 1.308-4.646 1.308-4.962 0-9-4.038-9-9 0-1.053.191-2.06.525-3h-2.1c-.271.955-.425 1.958-.425 3 0 6.075 4.925 11 11 11 2.127 0 4.099-.621 5.78-1.667l1.853 2.667 2.152-6.989h-6.994l1.855 2.681z"></path>
			</symbol>
			<symbol id="edit" viewBox="0 0 24 24">
				<path d="M0 1h24v2h-24v-2zm11 7h13v-2h-13v2zm0 5h13v-2h-13v2zm0 5h13v-2h-13v2zm-11 5h24v-2h-24v2zm8-17l-8 6 8 6v-12z"></path>
			</symbol>
			<symbol id="lock" viewBox="0 0 24 24">
				<path d="M18 10v-4c0-3.313-2.687-6-6-6s-6 2.687-6 6v4h-3v14h18v-14h-3zm-10 0v-4c0-2.206 1.794-4 4-4s4 1.794 4 4v4h-8z"></path>
			</symbol>
			<symbol id="volume-off" viewBox="0 0 24 24">
				<path d="M5 17h-5v-10h5v10zm2-10v10l9 5v-20l-9 5zm15.324 4.993l1.646-1.659-1.324-1.324-1.651 1.67-1.665-1.648-1.316 1.318 1.67 1.657-1.65 1.669 1.318 1.317 1.658-1.672 1.666 1.653 1.324-1.325-1.676-1.656z"></path>
			</symbol>
			<symbol id="volume-on" viewBox="0 0 24 24">
				<path d="M5 17h-5v-10h5v10zm2-10v10l9 5v-20l-9 5zm11.008 2.093c.742.743 1.2 1.77 1.198 2.903-.002 1.133-.462 2.158-1.205 2.9l1.219 1.223c1.057-1.053 1.712-2.511 1.715-4.121.002-1.611-.648-3.068-1.702-4.125l-1.225 1.22zm2.142-2.135c1.288 1.292 2.082 3.073 2.079 5.041s-.804 3.75-2.096 5.039l1.25 1.254c1.612-1.608 2.613-3.834 2.616-6.291.005-2.457-.986-4.681-2.595-6.293l-1.254 1.25z"></path>
			</symbol>
			<symbol id="fullscreen-off" viewBox="0 0 24 24">
				<path d="M15 2h2v5h7v2h-9v-7zm9 13v2h-7v5h-2v-7h9zm-15 7h-2v-5h-7v-2h9v7zm-9-13v-2h7v-5h2v7h-9z"></path>
			</symbol>
			<symbol id="fullscreen-on" viewBox="0 0 24 24">
				<path d="M24 9h-2v-7h-7v-2h9v9zm-9 15v-2h7v-7h2v9h-9zm-15-9h2v7h7v2h-9v-9zm9-15v2h-7v7h-2v-9h9z"></path>
			</symbol>
			<symbol id="navmap" viewBox="0 0 24 24">
				<path d="M24 22.586l-2.823-2.823c.526-.792.836-1.74.836-2.763 0-2.762-2.238-5-5-5s-5 2.238-5 5 2.238 5 5 5c1.016 0 1.957-.307 2.746-.827l2.827 2.827 1.414-1.414zm-9.987-5.586c0-1.654 1.346-3 3-3s3 1.346 3 3-1.346 3-3 3-3-1.346-3-3zm-4 0l.002-.034-3.015 2.175v-13.068l4-2.886v10.247c.508-.854 1.189-1.591 2-2.161v-8.086l4 2.886v3.927h.013c.336 0 .664.032.987.078v-4.007l4-2.479v8.504c1.188 1.208 1.936 2.844 2 4.653v-16.749l-6.455 4-5.545-4-5.545 4-6.455-4v18l6.455 4 3.91-2.82c-.226-.687-.352-1.419-.352-2.18zm-4.013 2.365l-4-2.479v-13.294l4 2.479v13.294z"/>
			</symbol>
			<symbol id="screen" viewBox="0 0 24 24">
				<path d="M0 0v19h24v-19h-24zm22 14h-20v-12h20v12zm-6.599 7l2.599 3h-12l2.599-3h6.802z"></path>
			</symbol>
			<symbol id="chat" viewBox="0 0 24 24">
				<path d="M22 3v13h-11.643l-4.357 3.105v-3.105h-4v-13h20zm2-2h-24v16.981h4v5.019l7-5.019h13v-16.981z"></path>
			</symbol>
			<symbol id="send" viewBox="0 0 24 24">
				<path d="M22 12l-20 12 5-12-5-12z"></path>
			</symbol>
			<symbol id="users" viewBox="0 0 24 24">
				<path d="M10.644 17.08c2.866-.662 4.539-1.241 3.246-3.682-3.932-7.427-1.042-11.398 3.111-11.398 4.235 0 7.054 4.124 3.11 11.398-1.332 2.455.437 3.034 3.242 3.682 2.483.574 2.647 1.787 2.647 3.889v1.031h-18c0-2.745-.22-4.258 2.644-4.92zm-12.644 4.92h7.809c-.035-8.177 3.436-5.313 3.436-11.127 0-2.511-1.639-3.873-3.748-3.873-3.115 0-5.282 2.979-2.333 8.549.969 1.83-1.031 2.265-3.181 2.761-1.862.43-1.983 1.34-1.983 2.917v.773z"></path>
			</symbol>
			<symbol id="virtual-tour" viewBox="0 0 24 24">
				<path d="M17 17h-10v-10h10v10zm7 3l-5-3v-10l5-3v16zm-24-16l5 3v10l-5 3v-16z"></path>
			</symbol>
			<symbol id="live-meeting" viewBox="0 0 24 24">
				<path d="M18 18h6v6h-6v-6zm-9 6h6v-6h-6v6zm-9 0h6v-6h-6v6zm0-8h24v-16h-24v16z"></path>
			</symbol>
			<symbol id="control" viewBox="0 0 24 24">
				<circle cx="7" cy="10" r="1"></circle>
				<path d="M17,3H7c-3.9,0-7,3.1-7,7v6c0,2.8,2.2,5,5,5c2.4,0,4.4-1.7,4.9-4h4.2c0.5,2.7,3.2,4.5,5.9,3.9c2.3-0.5,4-2.5,4-4.9v-6 C24,6.1,20.9,3,17,3z M17,7c0.6,0,1,0.4,1,1s-0.4,1-1,1s-1-0.4-1-1S16.4,7,17,7z M7,13c-1.7,0-3-1.3-3-3s1.3-3,3-3s3,1.3,3,3 S8.7,13,7,13z M15,11c-0.6,0-1-0.4-1-1s0.4-1,1-1s1,0.4,1,1S15.6,11,15,11z M17,13c-0.6,0-1-0.4-1-1c0-0.6,0.4-1,1-1s1,0.4,1,1 C18,12.5,17.6,13,17,13z M19,11c-0.6,0-1-0.4-1-1s0.4-1,1-1s1,0.4,1,1S19.6,11,19,11z"></path>
			</symbol>
			<symbol id="spy" viewBox="0 0 24 24">
				<path fill-rule="evenodd" d="M0.2,11.4c5.2-8.6,18.3-8.5,23.6,0c0.2,0.3,0.2,0.8,0,1.2c-5.3,8.4-18.4,8.6-23.6,0 C-0.1,12.2-0.1,11.7,0.2,11.4z M12,7.8c2.3,0,4.2,1.9,4.2,4.3s-1.9,4.2-4.2,4.2S7.8,14.3,7.8,12S9.7,7.8,12,7.8z" clip-rule="evenodd"></path>
			</symbol>
			<symbol id="joystick" viewBox="0 0 24 24">
				<path d="M10.7,10.5V16H9.3C8.6,16,8,16.6,8,17.3h8c0-0.7-0.6-1.3-1.3-1.3h-1.3v-5.5c2.8-0.7,4.5-3.6,3.8-6.5 c-0.7-2.8-3.6-4.5-6.5-3.8S6.1,3.9,6.9,6.7C7.3,8.6,8.8,10,10.7,10.5z"></path>
				<path d="M1.4,18.6h21.2c0.7,0,1.3,0.6,1.3,1.3v2.7c0,0.7-0.6,1.3-1.3,1.3H1.4c-0.7,0-1.3-0.6-1.3-1.3V20 C0.1,19.2,0.7,18.6,1.4,18.6z"></path>
			</symbol>
			<symbol id="navinfo" viewBox="0 0 24 24">
				<path d="M12,2c5.5,0,10,4.5,10,10s-4.5,10-10,10S2,17.5,2,12S6.5,2,12,2z M12,0C5.4,0,0,5.4,0,12s5.4,12,12,12s12-5.4,12-12 S18.6,0,12,0z"/>
				<path d="M13,18h-2v-8h2V18z M12,5.8c0.7,0,1.2,0.6,1.2,1.2S12.7,8.2,12,8.2S10.8,7.7,10.8,7S11.3,5.8,12,5.8z"/>
			</symbol>
			<symbol id="check" viewBox="0 0 24 24">
				<path d="M9,21l-9-8.6l2.8-2.9l6.2,5.9L21.2,3L24,5.8L9,21z"/>
			</symbol>
			<symbol id="duplicate" viewBox="0 0 24 24">
				<path d="M18,6V0H0v18h6v6h18V6H18z M6,16H2V2h14v4H6V16z M22,22H8V8h14V22z M19,14h-3v-3h-2v3h-3v2h3v3h2v-3h3V14z"/>
			</symbol>
			<symbol id="trash" viewBox="0 0 24 24">
				<path fill-rule="evenodd" d="M19,24H5c-1.1,0-2-0.9-2-2V5H2V3h6V1.5C8,0.7,8.7,0,9.5,0h5C15.3,0,16,0.7,16,1.5V3h6v2h-1v17 C21,23.1,20.1,24,19,24z M19,5H5v16.5C5,21.8,5.2,22,5.5,22h13c0.3,0,0.5-0.2,0.5-0.5V5z M10,9c0-0.6-0.4-1-1-1S8,8.4,8,9v9 c0,0.6,0.4,1,1,1s1-0.4,1-1V9z M16,9c0-0.6-0.4-1-1-1s-1,0.4-1,1v9c0,0.6,0.4,1,1,1s1-0.4,1-1V9z M14,2h-4v1h4V2z" clip-rule="evenodd"/>
			</symbol>
			<symbol id="flags" viewBox="0 0 24 24">
				<path d="M19,18c0,1.1-0.9,2-2,2s-2-0.9-2-2s0.9-2,2-2S19,16.9,19,18z M5,15c-1.7,0-3,1.3-3,3s1.3,3,3,3h14c1.7,0,3-1.3,3-3 s-1.3-3-3-3H5z M24,18c0,2.8-2.2,5-5,5H5c-2.8,0-5-2.2-5-5s2.2-5,5-5h14C21.8,13,24,15.2,24,18z M7,4C5.9,4,5,4.9,5,6s0.9,2,2,2 s2-0.9,2-2S8.1,4,7,4z M5,3C3.3,3,2,4.3,2,6s1.3,3,3,3h14c1.7,0,3-1.3,3-3s-1.3-3-3-3H5z M24,6c0,2.8-2.2,5-5,5H5c-2.8,0-5-2.2-5-5 s2.2-5,5-5h14C21.8,1,24,3.2,24,6z"/>
			</symbol>
			<symbol id="b-here" viewBox="0 0 270 98">
				<path d="M61.5,87.9c0-2.7,0.9-5,2.8-6.9c1.9-1.9,4.2-2.8,7-2.8c1.4,0,2.7,0.2,3.9,0.8c1.2,0.5,2.2,1.2,3.2,2 c0.9,0.9,1.6,1.9,2.1,3.1s0.8,2.5,0.8,3.8s-0.2,2.6-0.8,3.8c-0.5,1.2-1.2,2.2-2.1,3.1s-1.9,1.6-3.2,2.1c-1.2,0.5-2.5,0.8-3.9,0.8 s-2.7-0.2-3.9-0.8c-1.2-0.5-2.2-1.2-3.1-2.1s-1.6-1.9-2.1-3.1S61.5,89.2,61.5,87.9z"></path>
				<path d="M16,70.2H0.7v-70H16V29c0.6-1.1,1.4-2.1,2.4-3.1s2.2-1.9,3.5-2.6s2.8-1.3,4.2-1.8c1.5-0.4,3-0.6,4.6-0.6 c3.5,0,6.7,0.6,9.6,1.9s5.4,3.1,7.4,5.3c2.1,2.2,3.7,4.9,4.8,8s1.7,6.4,1.7,10.1c0,3.6-0.6,6.9-1.7,10c-1.1,3.1-2.7,5.8-4.8,8 c-2.1,2.2-4.5,4-7.4,5.3s-6.1,2-9.6,2c-1.6,0-3.1-0.2-4.6-0.7c-1.5-0.4-2.9-1-4.2-1.7c-1.3-0.7-2.5-1.5-3.5-2.5s-1.8-2-2.4-3.1 C16,63.5,16,70.2,16,70.2z M27.6,58.5c1.7,0,3.2-0.3,4.6-1c1.4-0.7,2.6-1.5,3.6-2.7c1-1.1,1.8-2.4,2.4-3.9c0.6-1.5,0.8-3.1,0.8-4.8 s-0.3-3.2-0.8-4.7c-0.6-1.5-1.4-2.8-2.4-3.9c-1-1.1-2.2-2-3.6-2.7c-1.4-0.7-2.9-1-4.6-1s-3.3,0.3-4.8,1c-1.4,0.7-2.7,1.6-3.7,2.7 c-1,1.1-1.8,2.4-2.3,3.9c-0.6,1.5-0.8,3-0.8,4.7s0.3,3.2,0.8,4.8s1.3,2.8,2.3,3.9c1,1.1,2.2,2,3.7,2.7 C24.3,58.2,25.9,58.5,27.6,58.5z"></path>
				<path d="M64.1,0.2h14.8V29c1.3-2.5,3.3-4.5,6-6s5.9-2.2,9.6-2.2c3.1,0,5.8,0.5,7.9,1.4c2.1,1,3.9,2.3,5.2,4.1 c1.5,1.9,2.6,4,3.1,6.5s0.8,5.4,0.8,8.9v28.5H96.7V45.5c0-3.5-0.6-6.3-1.8-8.5c-1.2-2.2-3.5-3.2-6.7-3.2c-3.1,0-5.5,1.1-7,3.3 s-2.3,5.2-2.3,8.9v24.2H64.1V0.2z"></path>
				<path d="M135.9,49.8c0.1,1.5,0.3,2.9,0.7,4.2s1,2.4,1.8,3.4s1.9,1.7,3.2,2.3s3,0.8,5,0.8c2.7,0,4.7-0.5,6-1.6 c1.4-1.1,2.3-2.4,2.9-3.9h15c-0.3,2.3-1.1,4.4-2.4,6.4c-1.2,2-2.9,3.8-4.9,5.2c-2,1.5-4.4,2.7-7.2,3.5c-2.8,0.9-5.9,1.3-9.3,1.3 c-4.2,0-7.9-0.6-11.2-1.8c-3.2-1.2-6-3-8.2-5.2c-2.2-2.3-3.9-5-5-8c-1.1-3.1-1.7-6.5-1.7-10.2c0-3.5,0.5-6.8,1.6-9.9s2.7-5.8,4.9-8 c2.2-2.3,4.8-4.1,8-5.5c3.2-1.3,6.8-2,11-2c3.8,0,7.2,0.6,10.2,1.8c3,1.2,5.6,2.8,7.8,4.8s3.8,4.3,5,7s1.8,5.5,1.8,8.4 c0,1,0,2.1,0,3.2c0,1.1-0.2,2.4-0.5,3.9h-34.5V49.8z M146.2,31c-3,0-5.5,0.9-7.4,2.6c-1.9,1.7-2.9,4.2-2.9,7.5h20.2 c0-3.1-0.9-5.6-2.8-7.4C151.5,31.9,149.1,31,146.2,31z"></path>
				<path d="M216.1,36c-1.1-0.3-2-0.5-2.7-0.6c-0.7-0.1-1.6-0.1-2.7-0.1c-4.2,0-7.6,1.2-10.1,3.7s-3.8,6.6-3.8,12.5v18.8h-15.3V22h15.3 v7.8c1.1-2.3,3-4.3,5.7-6c2.6-1.7,5.6-2.6,9-2.6c1.8,0,3.3,0.3,4.6,0.8V36z"></path>
				<path d="M234.3,49.8c0.1,1.5,0.3,2.9,0.7,4.2s1,2.4,1.8,3.4s1.9,1.7,3.2,2.3s3,0.8,5,0.8c2.7,0,4.7-0.5,6-1.6 c1.4-1.1,2.3-2.4,2.9-3.9h15c-0.3,2.3-1.1,4.4-2.4,6.4c-1.2,2-2.9,3.8-4.9,5.2c-2,1.5-4.4,2.7-7.2,3.5c-2.8,0.9-5.9,1.3-9.3,1.3 c-4.2,0-7.9-0.6-11.2-1.8c-3.2-1.2-6-3-8.2-5.2c-2.2-2.3-3.9-5-5-8c-1.1-3.1-1.7-6.5-1.7-10.2c0-3.5,0.5-6.8,1.6-9.9s2.7-5.8,4.9-8 c2.2-2.3,4.8-4.1,8-5.5c3.2-1.3,6.8-2,11-2c3.8,0,7.2,0.6,10.2,1.8c3,1.2,5.6,2.8,7.8,4.8c2.2,2,3.8,4.3,5,7s1.8,5.5,1.8,8.4 c0,1,0,2.1,0,3.2c0,1.1-0.2,2.4-0.5,3.9h-34.5V49.8z M244.6,31c-3,0-5.5,0.9-7.4,2.6c-1.9,1.7-2.9,4.2-2.9,7.5h20.2 c0-3.1-0.9-5.6-2.8-7.4C249.9,31.9,247.5,31,244.6,31z"></path>
			</symbol>
		</svg>
	`;class AppComponent extends rxcomp.Component {
  onInit() {
    const routes = AppRoutesInit();
    RouterService.useBrowser(routes);
    AssetGroupTypeInit();
    RouterService.event$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(event => {
      const route = event.route;
      if (route && route.params.mode === 'embed') {
        environment.flags.like = false;
      }
      LanguageService.setRoute(route, routes);
    });
    LanguageService.lang$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(_ => {
      this.pushChanges();
    });
    const {
      node
    } = rxcomp.getContext(this);
    node.classList.remove('hidden');
  }
}
AppComponent.meta = {
  selector: '[b-here-component]',
  template: /* html */`
		<!-- svg -->
		${SVG_CHUNK}
		<!-- header -->
		<router-outlet></router-outlet>
		<!-- footer -->
		<div class="toast-outlet" toast-outlet></div>
		<div class="modal-outlet" modal-outlet></div>
	`
};const MIME_IMAGE = ['bmp', 'gif', 'ico', 'jpeg', 'jpg', 'png', 'svg', 'tif', 'tiff', 'webp', 'hdr'];
const MIME_VIDEO = ['mp4', 'avi', 'mpeg', 'ogv', 'ts', 'webm', '3gp', '3g2'];
const MIME_MODEL = ['fbx', 'gltf', 'glb', 'obj', 'usdz'];
const MIME_STREAM = ['publisherStream', 'nextAttendeeStream', 'publisherScreen', 'attendeeScreen'];
function isImage(path) {
  // eslint-disable-next-line no-useless-escape
  return new RegExp(`/\.(${MIME_IMAGE.join('|')})$/i`).test(path);
}
function isVideo(path) {
  // eslint-disable-next-line no-useless-escape
  return new RegExp(`/\.(${MIME_VIDEO.join('|')})$/i`).test(path);
}
function isModel(path) {
  // eslint-disable-next-line no-useless-escape
  return new RegExp(`/\.(${MIME_MODEL.join('|')})$/i`).test(path);
}
function isStream(path) {
  return MIME_STREAM.indexOf(path) !== -1;
}
class AssetPipe extends rxcomp.Pipe {
  static transform(asset, type) {
    if (type === void 0) {
      type = null;
    }
    if (type != null) {
      // keep loose equality
      asset = asset.type.name === type ? asset : null;
    }
    if (asset) {
      if (typeof asset === 'string') {
        return environment.getPath(asset);
      }
      // console.log(asset.type.name, AssetType.Image.name);
      switch (asset.type.name) {
        case AssetType.Image.name:
        case AssetType.Video.name:
          asset = asset.folder + asset.file;
          asset = environment.getPath(asset);
          break;
        case AssetType.Model.name:
          asset = asset.folder + asset.file;
          asset = environment.getPath(asset);
          break;
        case AssetType.PublisherStream.name:
        case AssetType.AttendeeStream.name:
        case AssetType.PublisherScreen.name:
        case AssetType.AttendeeScreen.name:
        case AssetType.SmartDeviceStream.name:
          asset = environment.getPath(asset.file);
          break;
        default:
          if (isImage(asset.file) || isVideo(asset.file)) {
            asset = asset.folder + asset.file;
            asset = environment.getPath(asset);
          } else if (isModel(asset.file)) {
            asset = asset.folder + asset.file;
            asset = environment.getPath(asset);
          } else if (isStream(asset.file)) {
            asset = asset.file;
          }
      }
      // asset = asset;
    } else {
      asset = null;
    }
    // console.log('AssetPipe.transform', asset);
    return asset;
  }
}
AssetPipe.meta = {
  name: 'asset'
};class ControlRequestModalComponent extends rxcomp.Component {
  onInit() {
    super.onInit();
    const {
      parentInstance
    } = rxcomp.getContext(this);
    if (parentInstance instanceof ModalOutletComponent) {
      this.data = parentInstance.modal.data;
    }
  }
  onAccept(user) {
    ModalService.resolve();
  }
  onReject(user) {
    ModalService.reject();
  }

  /*
  onDestroy() {
  	// console.log('ControlRequestModalComponent.onDestroy');
  }
  */

  onClose() {
    ModalService.reject();
  }
}
ControlRequestModalComponent.meta = {
  selector: '[control-request-modal]',
  template: /* html */`
		<div class="modal__header">
			<button type="button" class="btn--close" (click)="onClose()">
				<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#close"></use></svg>
			</button>
		</div>
		<div class="container">
			<div class="form">
				<div class="title">L'utente ha richiesto il controllo della navigazione. Accetti?</div>
				<div class="group--cta">
					<button type="button" class="btn--cancel" (click)="onReject()">
						<span>Rifiuta</span>
					</button>
					<button type="button" class="btn--accept" (click)="onAccept()">
						<span>Accetta</span>
					</button>
				</div>
			</div>
		</div>
	`
};
ControlRequestModalComponent.chunk = () => /* html */'<div class="control-request-modal" control-request-modal></div>';class DropDirective extends rxcomp.Directive {
  onInit() {
    const {
      module,
      node,
      parentInstance,
      selector
    } = rxcomp.getContext(this);
    const event = 'drop';
    const event$ = rxjs.fromEvent(node, event).pipe(operators.shareReplay(1));
    const expression = node.getAttribute(`(${event})`);
    if (expression) {
      const outputFunction = module.makeFunction(expression, ['$event']);
      event$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(event => {
        module.resolve(outputFunction, parentInstance, event);
      });
      rxjs.fromEvent(node, 'dragover').pipe(operators.takeUntil(this.unsubscribe$)).subscribe(event => event.preventDefault());
    } else {
      parentInstance[`${event}$`] = event$;
    }
    // console.log('DropDirective.onInit', 'selector', selector, 'event', event);
  }
}

DropDirective.meta = {
  selector: '[(drop)]'
};let DROPDOWN_ID = 1000000;
class DropdownDirective extends rxcomp.Directive {
  get id() {
    return this.dropdown || this.id_ || (this.id_ = DropdownDirective.nextId());
  }
  onInit() {
    const {
      node
    } = rxcomp.getContext(this);
    const trigger = node.getAttribute('dropdown-trigger');
    this.trigger = trigger ? node.querySelector(trigger) : node;
    this.opened = null;
    this.onClick = this.onClick.bind(this);
    this.onDocumentClick = this.onDocumentClick.bind(this);
    this.openDropdown = this.openDropdown.bind(this);
    this.closeDropdown = this.closeDropdown.bind(this);
    this.addListeners();
    DropdownDirective.dropdown$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(id => {
      // console.log('DropdownDirective', id, this['dropdown-item']);
      if (this.id === id) {
        node.classList.add('dropped');
      } else {
        node.classList.remove('dropped');
      }
    });
  }
  onClick(event) {
    const {
      node
    } = rxcomp.getContext(this);
    if (this.opened === null) {
      this.openDropdown();
    } else {
      const dropdownItemNode = node.querySelector('[dropdown-item]');
      // console.log('dropdownItemNode', dropdownItemNode);
      if (!dropdownItemNode) {
        // if (this.trigger !== node) {
        this.closeDropdown();
      }
    }
  }
  onDocumentClick(event) {
    const {
      node
    } = rxcomp.getContext(this);
    const clickedInside = node === event.target || node.contains(event.target);
    if (!clickedInside) {
      this.closeDropdown();
    }
  }
  openDropdown() {
    if (this.opened === null) {
      this.opened = true;
      this.addDocumentListeners();
      DropdownDirective.dropdown$.next(this.id);
      this.dropped.next(this.id);
    }
  }
  closeDropdown() {
    if (this.opened !== null) {
      this.removeDocumentListeners();
      this.opened = null;
      if (DropdownDirective.dropdown$.getValue() === this.id) {
        DropdownDirective.dropdown$.next(null);
        this.dropped.next(null);
      }
    }
  }
  addListeners() {
    this.trigger.addEventListener('click', this.onClick);
  }
  addDocumentListeners() {
    document.addEventListener('click', this.onDocumentClick);
  }
  removeListeners() {
    this.trigger.removeEventListener('click', this.onClick);
  }
  removeDocumentListeners() {
    document.removeEventListener('click', this.onDocumentClick);
  }
  onDestroy() {
    this.removeListeners();
    this.removeDocumentListeners();
  }
  static nextId() {
    return DROPDOWN_ID++;
  }
}
DropdownDirective.meta = {
  selector: '[dropdown]',
  inputs: ['dropdown', 'dropdown-trigger'],
  outputs: ['dropped']
};
DropdownDirective.dropdown$ = new rxjs.BehaviorSubject(null);class DropdownItemDirective extends rxcomp.Directive {
  get id() {
    return this['dropdown-item'];
  }
  onInit() {
    const {
      node
    } = rxcomp.getContext(this);
    node.classList.add('dropdown-item');
    DropdownDirective.dropdown$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(id => {
      // console.log('DropdownItemDirective', id, this['dropdown-item']);
      if (this.id === id) {
        node.classList.add('dropped');
      } else {
        node.classList.remove('dropped');
      }
    });
  }
}
DropdownItemDirective.meta = {
  selector: '[dropdown-item], [[dropdown-item]]',
  inputs: ['dropdown-item']
};class ToastOutletComponent extends rxcomp.Component {
  onInit() {
    this.toast = null;
    this.lastToast = null;
    ToastService.toast$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(toast => {
      if (toast) {
        this.lastToast = toast;
      }
      this.toast = toast;
      this.pushChanges();
    });
    // console.log('ToastOutletComponent.onInit');
  }

  getClass() {
    const classList = {};
    if (this.toast) {
      classList.active = true;
    }
    if (this.lastToast) {
      classList[this.lastToast.type] = true;
      classList[this.lastToast.position] = true;
    }
    return classList;
  }
  onClose() {
    ToastService.reject(this.toast);
  }
  onAccept() {
    ToastService.resolve(this.toast);
  }
  onReject() {
    ToastService.reject(this.toast);
  }
}
ToastOutletComponent.meta = {
  selector: '[toast-outlet]',
  template: /* html */`
	<div class="toast-outlet__container" [class]="getClass()">
		<div class="toast-outlet__toast" *if="lastToast">
			<span class="toast-outlet__message" [innerHTML]="lastToast.message"></span>
			<div class="group--cta" *if="lastToast.type != 'info'">
				<button type="button" class="btn--accept" (click)="onAccept()">
					<span [innerHTML]="lastToast.acceptMessage"></span>
				</button>
				<button type="button" class="btn--cancel" (click)="onReject()" *if="lastToast.type == 'dialog'">
					<span [innerHTML]="lastToast.rejectMessage"></span>
				</button>
			</div>
			<button type="button" class="btn--close" (click)="onClose()" *if="lastToast.type != 'info'">
				<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#close"></use></svg>
			</button>
		</div>
	</div>
	`
};class AsideComponent extends rxcomp.Component {
  onInit() {
    this.mode = 1;
    this.viewTypes = Object.keys(ViewType).map(key => {
      const type = ViewType[key];
      return {
        type: type,
        name: LabelPipe.getKeys('editor', type.name),
        disabled: environment.editor.disabledViewTypes.indexOf(type.name) !== -1
      };
    });
    this.viewItemTypes = Object.keys(ViewItemType).map(key => {
      const type = ViewItemType[key];
      return {
        type: type,
        name: LabelPipe.getKeys('editor', type.name),
        disabled: environment.editor.disabledViewItemTypes.indexOf(type.name) !== -1
      };
    });
    this.setSupportedViewTypes();
    this.setSupportedViewItemTypes();
  }
  onChanges() {
    this.setSupportedViewTypes();
    this.setSupportedViewItemTypes();
  }
  setSupportedViewTypes() {
    this.supportedViewTypes = this.viewTypes.filter(x => this.supportedViewType(x.type.name)).sort((a, b) => {
      if (a.disabled === b.disabled) {
        return 0; // (a.type.name < b.type.name) ? -1 : (a.type.name > b.type.name) ? 1 : 0;
      } else {
        return a.disabled ? 1 : -1;
      }
    });
  }
  setSupportedViewItemTypes() {
    if (this.view) {
      this.supportedViewItemTypes = this.viewItemTypes.filter(x => this.supportedViewItemType(this.view.type.name, x.type.name)).sort((a, b) => {
        if (a.disabled === b.disabled) {
          return 0; // (a.type.name < b.type.name) ? -1 : (a.type.name > b.type.name) ? 1 : 0;
        } else {
          return a.disabled ? 1 : -1;
        }
      });
    } else {
      this.supportedViewItemTypes = [];
    }
  }
  setMode(mode) {
    if (this.mode !== mode) {
      this.mode = mode;
      this.pushChanges();
    }
  }
  supportedViewType(viewTypeName) {
    let supported = [ViewType.Panorama.name, ViewType.PanoramaGrid.name, ViewType.Room3d.name, ViewType.Model.name, ViewType.Media.name].indexOf(viewTypeName) !== -1; // ViewType.WaitingRoom,
    // console.log('supportedViewType', viewType, supported);
    return supported;
  }
  supportedViewItemType(viewTypeName, viewItemTypeName) {
    let supported;
    switch (viewTypeName) {
      case ViewType.WaitingRoom.name:
        supported = false;
        break;
      case ViewType.Panorama.name:
        supported = [ViewItemType.Nav.name, ViewItemType.Model.name, ViewItemType.Plane.name, ViewItemType.CurvedPlane.name].indexOf(viewItemTypeName) !== -1;
        break;
      case ViewType.PanoramaGrid.name:
        supported = [ViewItemType.Nav.name, ViewItemType.Model.name, ViewItemType.Plane.name, ViewItemType.CurvedPlane.name].indexOf(viewItemTypeName) !== -1;
        break;
      case ViewType.Room3d.name:
        supported = [ViewItemType.Nav.name, ViewItemType.Model.name, ViewItemType.Plane.name, ViewItemType.Texture.name].indexOf(viewItemTypeName) !== -1;
        break;
      case ViewType.Model.name:
        supported = [ViewItemType.Nav.name, ViewItemType.Model.name, ViewItemType.Plane.name, ViewItemType.CurvedPlane.name].indexOf(viewItemTypeName) !== -1;
        break;
      case ViewType.Media.name:
        supported = [].indexOf(viewItemTypeName) !== -1;
        break;
    }
    // console.log('supportedViewItemType', viewTypeName, viewItemTypeName, supported);
    return supported;
  }
  onSelect(event) {
    this.select.next(event);
  }
  onUpdate(event) {
    this.update.next(event);
  }
  onDelete(event) {
    this.delete.next(event);
  }
}
AsideComponent.meta = {
  selector: '[aside]',
  outputs: ['select', 'update', 'delete'],
  inputs: ['view'],
  template: /* html */`
	<div class="headline">
		<ul class="nav--tab">
			<li [class]="{ active: mode === 1 }" (click)="setMode(1)" [innerHTML]="'editor_properties' | label"></li>
			<li [class]="{ active: mode === 2 }" (click)="setMode(2)" [innerHTML]="'editor_views' | label"></li>
			<li [class]="{ active: mode === 3 }" (click)="setMode(3)" [innerHTML]="'editor_view_items' | label"></li>
		</ul>
		<!--
		<div class="btn--mode" [class]="{ active: mode === 1 }" (click)="setMode(1)" [innerHTML]="'editor_properties' | label"></div>
		<div class="btn--mode" [class]="{ active: mode === 2 }" (click)="setMode(2)" [innerHTML]="'editor_views' | label"></div>
		<div class="btn--mode" [class]="{ active: mode === 3 }" (click)="setMode(3)" [innerHTML]="'editor_view_items' | label"></div>
		-->
	</div>
	<div class="scrollable">
		<ul class="nav--editor" *if="mode === 1">
			<li>
				<div class="title" [innerHTML]="'editor_properties' | label"></div>
				<update-view [view]="view" (select)="onSelect($event)" (update)="onUpdate($event)" (delete)="onDelete($event)"></update-view>
			</li>
			<li *if="view.type.name != 'panorama-grid'">
				<div class="title" [innerHTML]="'editor_items' | label"></div>
				<update-view-item [view]="view" [item]="item" (select)="onSelect($event)" (update)="onUpdate($event)" (delete)="onDelete($event)" *for="let item of view.pathItems"></update-view-item>
				<div class="abstract" *if="view.pathItems.length == 0" [innerHTML]="'editor_no_items' | label"></div>
				<div class="btn--mode" (click)="setMode(3)" [innerHTML]="'editor_add_item' | label"></div>
			</li>
			<li *if="view.type.name == 'panorama-grid'">
				<div class="title" [innerHTML]="'editor_tiles' | label"></div>
				<div *for="let tile of view.tiles">
					<div *if="tile.selected">
						<update-view-tile [view]="view" [tile]="tile" (update)="onUpdate($event)" (delete)="onDelete($event)"></update-view-tile>
						<ul class="nav--editor">
							<li>
								<update-view-item [view]="view" [item]="item" (select)="onSelect($event)" (update)="onUpdate($event)" (delete)="onDelete($event)" *for="let item of tile.navs"></update-view-item>
								<div class="abstract" *if="tile.navs.length == 0" [innerHTML]="'editor_no_navs' | label"></div>
								<div class="btn--mode" (click)="onSelect({ type:'viewItem', value: 'nav', tile: tile })" [innerHTML]="'editor_add_nav' | label"></div>
							</li>
							<!--
							<li>
								<div class="btn" (click)="onSelect({ type:'viewItem', value: 'nav', tile: tile })">
									<div class="icon">
										<svg-icon name="nav"></svg-icon>
									</div>
									<div class="title" [innerHTML]="'editor_add_nav' | label"></div>
								</div>
							</li>
							-->
						</ul>
					</div>
				</div>
				<div class="abstract" *if="view.tiles.length == 0" [innerHTML]="'editor_no_tiles' | label"></div>
				<!-- <div class="btn--mode" (click)="setMode(3)">Add Tile</div> -->
			</li>
			<!--
			<li *if="false">
				<div class="title">Icons</div>
				<ul class="nav--editor">
					<li>
						<div class="btn" (click)="onSelect('animated-tabs')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.3"></path><path d="M 2 8.4 L 12 8.4 L 12 2 L 6 2 C 3.791 2 2 3.791 2 6 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 12 8.4 L 22 8.4 L 22 6 C 22 3.791 20.209 2 18 2 L 12 2 Z" fill="var(--svg-icon-tint)"></path></svg></div>
							<div class="title">Animated Tabs</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('card-list')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.3"></path><path d="M 6.8 13.6 C 6.8 13.158 7.158 12.8 7.6 12.8 L 16.8 12.8 C 17.242 12.8 17.6 13.158 17.6 13.6 L 17.6 16.8 C 17.6 17.242 17.242 17.6 16.8 17.6 L 7.6 17.6 C 7.158 17.6 6.8 17.242 6.8 16.8 Z" fill="var(--svg-icon-tint)"></path><path d="M 6.8 7.2 C 6.8 6.758 7.158 6.4 7.6 6.4 L 16.8 6.4 C 17.242 6.4 17.6 6.758 17.6 7.2 L 17.6 10.4 C 17.6 10.842 17.242 11.2 16.8 11.2 L 7.6 11.2 C 7.158 11.2 6.8 10.842 6.8 10.4 Z" fill="var(--svg-icon-tint)"></path></svg></div>
							<div class="title">Card List</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('container-transitions')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 15.667 13 C 17.139 13 18.333 14.194 18.333 15.667 C 18.333 17.139 17.139 18.333 15.667 18.333 C 14.194 18.333 13 17.139 13 15.667 C 13 14.194 14.194 13 15.667 13 Z" fill="var(--svg-icon-tint)"></path></svg></svg></div>
							<div class="title">Container Transitions</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('dynamic-grid')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.3"></path><g transform="translate(6.6 6.6)"><path d="M 6.048 0.8 C 6.048 0.358 6.406 0 6.848 0 L 10 0 C 10.442 0 10.8 0.358 10.8 0.8 L 10.8 3.952 C 10.8 4.394 10.442 4.752 10 4.752 L 6.848 4.752 C 6.406 4.752 6.048 4.394 6.048 3.952 Z" fill="var(--svg-icon-tint)" opacity="0.5"></path><path d="M 6.048 6.848 C 6.048 6.406 6.406 6.048 6.848 6.048 L 10 6.048 C 10.442 6.048 10.8 6.406 10.8 6.848 L 10.8 10 C 10.8 10.442 10.442 10.8 10 10.8 L 6.848 10.8 C 6.406 10.8 6.048 10.442 6.048 10 Z" fill="var(--svg-icon-tint)"></path><path d="M 0 0.8 C 0 0.358 0.358 0 0.8 0 L 3.952 0 C 4.394 0 4.752 0.358 4.752 0.8 L 4.752 3.952 C 4.752 4.394 4.394 4.752 3.952 4.752 L 0.8 4.752 C 0.358 4.752 0 4.394 0 3.952 Z" fill="var(--svg-icon-tint)"></path><path d="M 0 6.848 C 0 6.406 0.358 6.048 0.8 6.048 L 3.952 6.048 C 4.394 6.048 4.752 6.406 4.752 6.848 L 4.752 10 C 4.752 10.442 4.394 10.8 3.952 10.8 L 0.8 10.8 C 0.358 10.8 0 10.442 0 10 Z" fill="var(--svg-icon-tint)" opacity="0.5"></path></g></svg></div>
							<div class="title">Dynamic Grid</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('expand-on-tap')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 0 0 L 7.833 0" transform="translate(8.583 11.583) rotate(270 3.917 0.5)" fill="transparent" stroke-width="1.67" stroke="var(--svg-icon-tint)" stroke-linecap="round" stroke-linejoin="round"></path><path d="M 14.667 9.333 L 12 6.667 L 9.333 9.333" stroke="var(--svg-icon-tint)" fill="transparent" stroke-width="1.67" stroke-linecap="round" stroke-linejoin="round"></path><path d="M 14.667 14.667 L 12 17.333 L 9.333 14.667" stroke="var(--svg-icon-tint)" fill="transparent" stroke-width="1.67" stroke-linecap="round" stroke-linejoin="round"></path> </svg></div>
							<div class="title">Expand on Tap</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('image-gallery-2')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 7.333 8.333 C 7.333 7.781 7.781 7.333 8.333 7.333 L 10.333 7.333 C 10.886 7.333 11.333 7.781 11.333 8.333 L 11.333 10.333 C 11.333 10.886 10.886 11.333 10.333 11.333 L 8.333 11.333 C 7.781 11.333 7.333 10.886 7.333 10.333 Z" fill="var(--svg-icon-tint)" opacity="0.4"></path><path d="M 12.333 8.333 C 12.333 7.781 12.781 7.333 13.333 7.333 L 15.333 7.333 C 15.886 7.333 16.333 7.781 16.333 8.333 L 16.333 10.333 C 16.333 10.886 15.886 11.333 15.333 11.333 L 13.333 11.333 C 12.781 11.333 12.333 10.886 12.333 10.333 Z" fill="var(--svg-icon-tint)" opacity="0.4"></path><path d="M 7.333 13.667 C 7.333 13.114 7.781 12.667 8.333 12.667 L 15.333 12.667 C 15.886 12.667 16.333 13.114 16.333 13.667 L 16.333 15.667 C 16.333 16.219 15.886 16.667 15.333 16.667 L 8.333 16.667 C 7.781 16.667 7.333 16.219 7.333 15.667 Z" fill="var(--svg-icon-tint)"></path></svg></div>
							<div class="title">Image Gallery 2</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('stories-ui')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.3"></path><path d="M 6.8 4.8 C 7.905 4.8 8.8 5.695 8.8 6.8 C 8.8 7.905 7.905 8.8 6.8 8.8 C 5.695 8.8 4.8 7.905 4.8 6.8 C 4.8 5.695 5.695 4.8 6.8 4.8 Z" fill="var(--svg-icon-tint)"></path><path d="M 12 4.8 C 13.105 4.8 14 5.695 14 6.8 C 14 7.905 13.105 8.8 12 8.8 C 10.895 8.8 10 7.905 10 6.8 C 10 5.695 10.895 4.8 12 4.8 Z" fill="var(--svg-icon-tint)"></path><path d="M 17.2 4.8 C 18.305 4.8 19.2 5.695 19.2 6.8 C 19.2 7.905 18.305 8.8 17.2 8.8 C 16.095 8.8 15.2 7.905 15.2 6.8 C 15.2 5.695 16.095 4.8 17.2 4.8 Z" fill="var(--svg-icon-tint)"></path></svg></div>
							<div class="title">Stories UI</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('todo-list')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 8 12.333 L 10.5 14.833 L 16 9.333" stroke="var(--svg-icon-tint)" fill="transparent" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path></svg></div>
							<div class="title">To-Do List</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('toggle-menu')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 17.333 15.333 C 18.438 15.333 19.333 16.229 19.333 17.333 C 19.333 18.438 18.438 19.333 17.333 19.333 C 16.229 19.333 15.333 18.438 15.333 17.333 C 15.333 16.229 16.229 15.333 17.333 15.333 Z" fill="var(--svg-icon-tint)"></path><path d="M 17.333 10 C 18.438 10 19.333 10.895 19.333 12 C 19.333 13.105 18.438 14 17.333 14 C 16.229 14 15.333 13.105 15.333 12 C 15.333 10.895 16.229 10 17.333 10 Z" fill="var(--svg-icon-tint)" opacity="0.4"></path><path d="M 17.333 4.667 C 18.438 4.667 19.333 5.562 19.333 6.667 C 19.333 7.771 18.438 8.667 17.333 8.667 C 16.229 8.667 15.333 7.771 15.333 6.667 C 15.333 5.562 16.229 4.667 17.333 4.667 Z" fill="var(--svg-icon-tint)" opacity="0.4"></path></svg></div>
							<div class="title">Toggle Menu</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('bottom-sheet')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 10.333 C 22 10.886 21.552 11.333 21 11.333 L 3 11.333 C 2.448 11.333 2 10.886 2 10.333 Z" fill="var(--svg-icon-tint)" opacity="0.4"></path><path d="M 2 13.333 C 2 12.781 2.448 12.333 3 12.333 L 21 12.333 C 21.552 12.333 22 12.781 22 13.333 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)"></path></svg></div>
							<div class="title">Bottom Sheet</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('draggable-sheet')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 2 14 C 2 12.895 2.895 12 4 12 L 20 12 C 21.105 12 22 12.895 22 14 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z M 10.667 15.333 L 13.333 15.333 C 13.702 15.333 14 15.035 14 14.667 C 14 14.298 13.702 14 13.333 14 L 10.667 14 C 10.298 14 10 14.298 10 14.667 C 10 15.035 10.298 15.333 10.667 15.333 Z" fill="var(--svg-icon-tint)"></path></svg></div>
							<div class="title">Draggable Sheet</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('modal-box')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 7.333 9.333 C 7.333 8.229 8.229 7.333 9.333 7.333 L 14.667 7.333 C 15.771 7.333 16.667 8.229 16.667 9.333 L 16.667 14.667 C 16.667 15.771 15.771 16.667 14.667 16.667 L 9.333 16.667 C 8.229 16.667 7.333 15.771 7.333 14.667 Z" fill="var(--svg-icon-tint)"></path></svg></div>
							<div class="title">Modal Box</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('side-menu')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 11 2 C 11.552 2 12 2.448 12 3 L 12 21 C 12 21.552 11.552 22 11 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)"></path></svg></div>
							<div class="title">Side Menu</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('input-form')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 7.333 8.333 C 7.333 7.781 7.781 7.333 8.333 7.333 L 11.667 7.333 C 11.667 7.333 11.667 7.333 11.667 7.333 L 15.667 7.333 C 16.219 7.333 16.667 7.781 16.667 8.333 L 16.667 9 C 16.667 9.552 16.219 10 15.667 10 L 13.333 10 L 13.333 15.667 C 13.333 16.219 12.886 16.667 12.333 16.667 L 11.667 16.667 C 11.114 16.667 10.667 16.219 10.667 15.667 L 10.667 10 L 8.333 10 C 7.781 10 7.333 9.552 7.333 9 Z" fill="var(--svg-icon-tint)"></path></svg></div>
							<div class="title">Input Form</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('loading-indicator')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.3"></path><path d="M 16.4 10.4 C 17.284 10.4 18 11.116 18 12 C 18 12.884 17.284 13.6 16.4 13.6 C 15.516 13.6 14.8 12.884 14.8 12 C 14.8 11.116 15.516 10.4 16.4 10.4 Z" fill="var(--svg-icon-tint)"></path><path d="M 12 10.4 C 12.884 10.4 13.6 11.116 13.6 12 C 13.6 12.884 12.884 13.6 12 13.6 C 11.116 13.6 10.4 12.884 10.4 12 C 10.4 11.116 11.116 10.4 12 10.4 Z" fill="var(--svg-icon-tint)"></path><path d="M 7.6 10.4 C 8.484 10.4 9.2 11.116 9.2 12 C 9.2 12.884 8.484 13.6 7.6 13.6 C 6.716 13.6 6 12.884 6 12 C 6 11.116 6.716 10.4 7.6 10.4 Z" fill="var(--svg-icon-tint)"></path></svg></div>
							<div class="title">Loading Indicator</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('radio-button-form')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 9.833 8.167 L 14.167 8.167 C 16.284 8.167 18 9.883 18 12 C 18 14.117 16.284 15.833 14.167 15.833 L 9.833 15.833 C 7.716 15.833 6 14.117 6 12 C 6 9.883 7.716 8.167 9.833 8.167 Z M 11.333 12 C 11.333 13.473 12.527 14.667 14 14.667 C 15.473 14.667 16.667 13.473 16.667 12 C 16.667 10.527 15.473 9.333 14 9.333 C 12.527 9.333 11.333 10.527 11.333 12 Z" fill="var(--svg-icon-tint)"></path></svg></div>
							<div class="title">Radio Button Form</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('checkbox-form')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 8.651 6.931 C 7.911 6.738 7.238 7.411 7.431 8.151 L 9.363 15.558 C 9.592 16.435 10.775 16.58 11.208 15.784 L 13 12.5 L 16.284 10.708 C 17.08 10.275 16.935 9.092 16.058 8.863 Z" fill="var(--svg-icon-tint)"></path><path d="M 16 15.5 L 11 10.5" fill="transparent" stroke-width="1.67" stroke="var(--svg-icon-tint)" stroke-linecap="round"></path></svg></div>
							<div class="title">Checkbox Form</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('splash-screen')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 7.757 13.414 C 6.976 12.633 6.976 11.367 7.757 10.586 L 10.586 7.757 C 11.367 6.976 12.633 6.976 13.414 7.757 L 16.243 10.586 C 17.024 11.367 17.024 12.633 16.243 13.414 L 13.414 16.243 C 12.633 17.024 11.367 17.024 10.586 16.243 Z" fill="var(--svg-icon-tint)"></path></svg></div>
							<div class="title">Splash Screen</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('timeout-transition')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 1 5.8 C 1 3.149 3.149 1 5.8 1 L 18.2 1 C 20.851 1 23 3.149 23 5.8 L 23 18.2 C 23 20.851 20.851 23 18.2 23 L 5.8 23 C 3.149 23 1 20.851 1 18.2 Z" fill="var(--svg-icon-tint)" opacity="0.3"></path><path d="M 12 6.72 C 14.916 6.72 17.28 9.084 17.28 12 C 17.28 14.916 14.916 17.28 12 17.28 C 9.084 17.28 6.72 14.916 6.72 12 C 6.72 9.084 9.084 6.72 12 6.72 Z M 11.34 12 C 11.34 12.365 11.635 12.66 12 12.66 L 14.2 12.66 C 14.565 12.66 14.86 12.365 14.86 12 C 14.86 11.635 14.565 11.34 14.2 11.34 L 12.66 11.34 L 12.66 9.8 C 12.66 9.435 12.365 9.14 12 9.14 C 11.635 9.14 11.34 9.435 11.34 9.8 Z" fill="var(--svg-icon-tint)"></path></svg></div>
							<div class="title">Timeout Transition</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('accordion-menu')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 16 10.667 L 12 14.667 L 8 10.667" fill="transparent" stroke-width="2" stroke="var(--svg-icon-tint)" stroke-linecap="round" stroke-linejoin="round"></path></svg></div>
							<div class="title">Accordion Menu</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('drop-on-scroll')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 0 0 L 8 0" transform="translate(8.5 11.5) rotate(270 4 0.5)" fill="transparent" stroke-width="1.67" stroke="var(--svg-icon-tint)" stroke-linecap="round" stroke-linejoin="round"></path><path d="M 15.333 11.333 L 12 8 L 8.667 11.333" fill="transparent" stroke-width="1.67" stroke="var(--svg-icon-tint)" stroke-linecap="round" stroke-linejoin="round"></path></svg></div>
							<div class="title">Drop on Scroll</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('nested-scroll')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 1.82 6 C 1.82 3.791 3.61 2 5.82 2 L 17.82 2 C 20.029 2 21.82 3.791 21.82 6 L 21.82 7 C 21.82 7.552 21.372 8 20.82 8 L 2.82 8 C 2.267 8 1.82 7.552 1.82 7 Z" fill="var(--svg-icon-tint)" opacity="0.4"></path><path d="M 1.82 17 C 1.82 16.448 2.267 16 2.82 16 L 20.82 16 C 21.372 16 21.82 16.448 21.82 17 L 21.82 18 C 21.82 20.209 20.029 22 17.82 22 L 5.82 22 C 3.61 22 1.82 20.209 1.82 18 Z" fill="var(--svg-icon-tint)" opacity="0.4"></path><path d="M 8.82 10 C 8.82 9.448 9.267 9 9.82 9 L 20.82 9 C 21.372 9 21.82 9.448 21.82 10 L 21.82 14 C 21.82 14.552 21.372 15 20.82 15 L 9.82 15 C 9.267 15 8.82 14.552 8.82 14 Z" fill="var(--svg-icon-tint)"></path><path d="M 1.82 10 C 1.82 9.448 2.267 9 2.82 9 L 6.82 9 C 7.372 9 7.82 9.448 7.82 10 L 7.82 14 C 7.82 14.552 7.372 15 6.82 15 L 2.82 15 C 2.267 15 1.82 14.552 1.82 14 Z" fill="var(--svg-icon-tint)"></path></svg></div>
							<div class="title">Nested Scroll</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('star-rating')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 11.399 6.884 C 11.645 6.386 12.355 6.386 12.601 6.884 L 13.705 9.122 C 13.803 9.32 13.992 9.457 14.21 9.489 L 16.68 9.848 C 17.229 9.928 17.449 10.603 17.051 10.99 L 15.264 12.733 C 15.106 12.887 15.034 13.108 15.071 13.326 L 15.493 15.786 C 15.587 16.333 15.013 16.75 14.521 16.492 L 12.312 15.331 C 12.117 15.228 11.883 15.228 11.688 15.331 L 9.479 16.492 C 8.987 16.75 8.413 16.333 8.507 15.786 L 8.929 13.326 C 8.966 13.108 8.894 12.887 8.736 12.733 L 6.949 10.99 C 6.551 10.603 6.771 9.928 7.32 9.848 L 9.79 9.489 C 10.008 9.457 10.197 9.32 10.295 9.122 Z" fill="var(--svg-icon-tint)"></path></svg></div>
							<div class="title">Star Rating</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('swipe-menu')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 17.33 C 2 16.595 2.595 16 3.33 16 L 21 16 C 21.552 16 22 16.448 22 17 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.4"></path><path d="M 2 10 C 2 9.448 2.448 9 3 9 L 14 9 C 14.552 9 15 9.448 15 10 L 15 14 C 15 14.552 14.552 15 14 15 L 3 15 C 2.448 15 2 14.552 2 14 Z M 19 9 C 20.657 9 22 10.343 22 12 C 22 13.657 20.657 15 19 15 C 17.343 15 16 13.657 16 12 C 16 10.343 17.343 9 19 9 Z" fill="var(--svg-icon-tint)"></path><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 7 C 22 7.552 21.552 8 21 8 L 3 8 C 2.448 8 2 7.552 2 7 Z" fill="var(--svg-icon-tint)" opacity="0.4"></path></svg></div>
							<div class="title">Swipe Menu</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('switch-sheet')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 15.667 13.333 C 17.139 13.333 18.333 14.527 18.333 16 C 18.333 17.473 17.139 18.667 15.667 18.667 C 14.194 18.667 13 17.473 13 16 C 13 14.527 14.194 13.333 15.667 13.333 Z" fill="var(--svg-icon-tint)"></path><path d="M 8.333 13.333 C 9.806 13.333 11 14.527 11 16 C 11 17.473 9.806 18.667 8.333 18.667 C 6.861 18.667 5.667 17.473 5.667 16 C 5.667 14.527 6.861 13.333 8.333 13.333 Z" fill="var(--svg-icon-tint)" opacity="0.4"></path></svg></div>
							<div class="title">Switch Sheet</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('tab-menu')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 10 15.333 L 14 15.333 L 14 18.667 L 10 18.667 Z" fill="var(--svg-icon-tint)" opacity="0.4"></path><path d="M 5.333 16.333 C 5.333 15.781 5.781 15.333 6.333 15.333 L 9.333 15.333 L 9.333 18.667 L 6.333 18.667 C 5.781 18.667 5.333 18.219 5.333 17.667 Z" fill="var(--svg-icon-tint)"></path><path d="M 18.667 16.333 C 18.667 15.781 18.219 15.333 17.667 15.333 L 14.667 15.333 L 14.667 18.667 L 17.667 18.667 C 18.219 18.667 18.667 18.219 18.667 17.667 Z" fill="var(--svg-icon-tint)" opacity="0.4"></path></svg></div>
							<div class="title">Tab Menu</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('wheel-picker')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 3.667 6 C 3.667 3.791 5.458 2 7.667 2 L 16.333 2 C 18.542 2 20.333 3.791 20.333 6 L 20.333 7 C 20.333 7.552 19.886 8 19.333 8 L 4.667 8 C 4.114 8 3.667 7.552 3.667 7 Z" fill="var(--svg-icon-tint)" opacity="0.4"></path><path d="M 2 11 C 2 9.895 2.895 9 4 9 L 20 9 C 21.105 9 22 9.895 22 11 L 22 13 C 22 14.105 21.105 15 20 15 L 4 15 C 2.895 15 2 14.105 2 13 Z" fill="var(--svg-icon-tint)"></path><path d="M 3.667 17 C 3.667 16.448 4.114 16 4.667 16 L 19.333 16 C 19.886 16 20.333 16.448 20.333 17 L 20.333 18 C 20.333 20.209 18.542 22 16.333 22 L 7.667 22 C 5.458 22 3.667 20.209 3.667 18 Z" fill="var(--svg-icon-tint)" opacity="0.4"></path></svg></div>
							<div class="title">Wheel Picker</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('cover-flow')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 11.333 17.962 C 11.333 18.385 11.068 18.762 10.67 18.904 L 4.673 21.045 C 3.37 21.511 2 20.545 2 19.162 L 2 4.838 C 2 3.455 3.37 2.489 4.673 2.955 L 10.67 5.096 C 11.068 5.238 11.333 5.615 11.333 6.038 Z" fill="var(--svg-icon-tint)"></path><path d="M 22 4.838 C 22 3.455 20.63 2.489 19.327 2.955 L 13.33 5.096 C 12.932 5.238 12.667 5.615 12.667 6.038 L 12.667 17.962 C 12.667 18.385 12.932 18.762 13.33 18.904 L 19.327 21.045 C 20.63 21.511 22 20.545 22 19.162 Z" fill="var(--svg-icon-tint)" opacity="0.4"></path></svg></div>
							<div class="title">Cover Flow</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('cube-effect')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6.743 C 2 5.898 2.531 5.144 3.327 4.859 L 9.997 2.477 C 10.648 2.245 11.333 2.727 11.333 3.419 L 11.333 20.581 C 11.333 21.273 10.648 21.755 9.997 21.523 L 3.327 19.141 C 2.531 18.856 2 18.102 2 17.257 Z" fill="var(--svg-icon-tint)" opacity="0.4"></path><path d="M 12.667 3.419 C 12.667 2.727 13.352 2.245 14.003 2.477 L 20.673 4.859 C 21.469 5.144 22 5.898 22 6.743 L 22 17.257 C 22 18.102 21.469 18.856 20.673 19.141 L 14.003 21.523 C 13.352 21.755 12.667 21.273 12.667 20.581 Z" fill="var(--svg-icon-tint)"></path></svg></div>
							<div class="title">Cube Effect</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('flip-effect')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 11.333 4.667 C 11.333 4.114 10.886 3.667 10.333 3.667 L 4 3.667 C 2.895 3.667 2 4.562 2 5.667 L 2 18.333 C 2 19.438 2.895 20.333 4 20.333 L 10.333 20.333 C 10.886 20.333 11.333 19.886 11.333 19.333 Z" fill="var(--svg-icon-tint)" opacity="0.4"></path><path d="M 20 4.167 C 20 3.891 20.224 3.667 20.5 3.667 L 20.5 3.667 C 21.328 3.667 22 4.338 22 5.167 L 22 18.833 C 22 19.662 21.328 20.333 20.5 20.333 L 20.5 20.333 C 20.224 20.333 20 20.109 20 19.833 Z" fill="var(--svg-icon-tint)" opacity="0.4"></path><path d="M 18.667 4.631 C 18.667 3.309 17.406 2.35 16.131 2.704 L 13.399 3.463 C 12.966 3.583 12.667 3.978 12.667 4.427 L 12.667 19.573 C 12.667 20.022 12.966 20.417 13.399 20.537 L 16.131 21.296 C 17.406 21.65 18.667 20.691 18.667 19.369 Z" fill="var(--svg-icon-tint)"></path></svg></div>
							<div class="title">Flip Effect</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('parallax-scroll')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 12 6.667 C 12 5.562 12.895 4.667 14 4.667 L 17.333 4.667 C 18.438 4.667 19.333 5.562 19.333 6.667 L 19.333 10 C 19.333 11.105 18.438 12 17.333 12 L 14 12 C 12.895 12 12 11.105 12 10 Z" fill="var(--svg-icon-tint)"></path><path d="M 4.667 14 C 4.667 12.895 5.562 12 6.667 12 L 10 12 C 11.105 12 12 12.895 12 14 L 12 17.333 C 12 18.438 11.105 19.333 10 19.333 L 6.667 19.333 C 5.562 19.333 4.667 18.438 4.667 17.333 Z" fill="var(--svg-icon-tint)"></path></svg></div>
							<div class="title">Parallax Scroll</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('pile-effect')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 6.5 4 C 6.224 4 6 3.776 6 3.5 L 6 3.5 C 6 2.672 6.672 2 7.5 2 L 16.5 2 C 17.328 2 18 2.672 18 3.5 L 18 3.5 C 18 3.776 17.776 4 17.5 4 Z" fill="var(--svg-icon-tint)" opacity="0.4"></path><path d="M 4.5 7 C 4.224 7 4 6.776 4 6.5 L 4 6.5 C 4 5.672 4.672 5 5.5 5 L 18.5 5 C 19.328 5 20 5.672 20 6.5 L 20 6.5 C 20 6.776 19.776 7 19.5 7 Z" fill="var(--svg-icon-tint)" opacity="0.7"></path><path d="M 0 2.67 C 0 1.195 1.195 0 2.67 0 L 11.33 0 C 12.805 0 14 1.195 14 2.67 L 14 17.33 C 14 18.805 12.805 20 11.33 20 L 2.67 20 C 1.195 20 0 18.805 0 17.33 Z" transform="translate(5 5) rotate(-90 7 10)" fill="var(--svg-icon-tint)"></path></svg></div>
							<div class="title">Pile Effect</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('shuffle')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 15.174 10.452 L 16.708 9.06 L 15.174 7.667" fill="transparent" stroke-width="1.33" stroke="var(--svg-icon-tint)" stroke-linecap="round" stroke-linejoin="round"></path><path d="M 15.174 16.333 L 16.708 14.94 L 15.174 13.548" fill="transparent" stroke-width="1.33" stroke="var(--svg-icon-tint)" stroke-linecap="round" stroke-linejoin="round"></path><path d="M 16.145 9.06 C 16.145 9.06 13.982 8.542 12.617 9.679 C 11.252 10.815 11.829 12.213 10.776 13.548 C 9.724 14.882 7.708 14.94 7.708 14.94" fill="transparent" stroke-width="1.33" stroke="var(--svg-icon-tint)" stroke-linecap="round" stroke-linejoin="round"></path><path d="M 16.145 14.823 C 16.145 14.823 13.982 15.34 12.617 14.204 C 11.252 13.068 11.829 11.669 10.776 10.335 C 9.724 9.001 7.708 8.942 7.708 8.942" fill="transparent" stroke-width="1.33" stroke="var(--svg-icon-tint)" stroke-linecap="round" stroke-linejoin="round"></path></svg></div>
							<div class="title">Shuffle</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('svg-animation')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 8 12.333 L 10.5 14.833 L 16 9.333" stroke="var(--svg-icon-tint)" fill="transparent" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path></svg></div>
							<div class="title">SVG Animation</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('google-sheets')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 7 8.667 C 7 8.206 7.373 7.833 7.833 7.833 L 7.833 7.833 C 8.294 7.833 8.667 8.206 8.667 8.667 L 8.667 8.667 C 8.667 9.127 8.294 9.5 7.833 9.5 L 7.833 9.5 C 7.373 9.5 7 9.127 7 8.667 Z" fill="var(--svg-icon-tint)"></path><path d="M 7 12 C 7 11.54 7.373 11.167 7.833 11.167 L 7.833 11.167 C 8.294 11.167 8.667 11.54 8.667 12 L 8.667 12 C 8.667 12.46 8.294 12.833 7.833 12.833 L 7.833 12.833 C 7.373 12.833 7 12.46 7 12 Z" fill="var(--svg-icon-tint)"></path><path d="M 7 15.333 C 7 14.873 7.373 14.5 7.833 14.5 L 7.833 14.5 C 8.294 14.5 8.667 14.873 8.667 15.333 L 8.667 15.333 C 8.667 15.794 8.294 16.167 7.833 16.167 L 7.833 16.167 C 7.373 16.167 7 15.794 7 15.333 Z" fill="var(--svg-icon-tint)"></path><path d="M 9.778 8.667 C 9.778 8.206 10.151 7.833 10.611 7.833 L 16.167 7.833 C 16.627 7.833 17 8.206 17 8.667 L 17 8.667 C 17 9.127 16.627 9.5 16.167 9.5 L 10.611 9.5 C 10.151 9.5 9.778 9.127 9.778 8.667 Z" fill="var(--svg-icon-tint)"></path><path d="M 9.778 12 C 9.778 11.54 10.151 11.167 10.611 11.167 L 16.167 11.167 C 16.627 11.167 17 11.54 17 12 L 17 12 C 17 12.46 16.627 12.833 16.167 12.833 L 10.611 12.833 C 10.151 12.833 9.778 12.46 9.778 12 Z" fill="var(--svg-icon-tint)"></path><path d="M 9.778 15.333 C 9.778 14.873 10.151 14.5 10.611 14.5 L 16.167 14.5 C 16.627 14.5 17 14.873 17 15.333 L 17 15.333 C 17 15.794 16.627 16.167 16.167 16.167 L 10.611 16.167 C 10.151 16.167 9.778 15.794 9.778 15.333 Z" fill="var(--svg-icon-tint)"></path></svg></div>
							<div class="title">Google Sheets</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('map')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 1.82 6 C 1.82 3.791 3.61 2 5.82 2 L 17.82 2 C 20.029 2 21.82 3.791 21.82 6 L 21.82 18 C 21.82 20.209 20.029 22 17.82 22 L 5.82 22 C 3.61 22 1.82 20.209 1.82 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 11.82 6.504 C 14.029 6.504 15.82 8.282 15.82 10.476 C 15.82 10.698 15.801 10.915 15.766 11.127 C 15.359 14.488 13.033 16.581 12.155 17.261 C 12.051 17.341 11.976 17.437 11.82 17.437 C 11.663 17.437 11.586 17.34 11.481 17.258 C 10.6 16.576 8.28 14.483 7.873 11.127 C 7.838 10.915 7.82 10.698 7.82 10.476 C 7.82 8.282 9.61 6.504 11.82 6.504 Z M 9.486 10.644 C 9.486 11.933 10.531 12.977 11.82 12.977 C 13.108 12.977 14.153 11.933 14.153 10.644 C 14.153 9.355 13.108 8.311 11.82 8.311 C 10.531 8.311 9.486 9.355 9.486 10.644 Z" fill="var(--svg-icon-tint)"></path></svg></div>
							<div class="title">Map</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('signature-pad')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 8.82 13.068 C 8.56 12.807 8.56 12.385 8.82 12.125 L 13.733 7.212 C 13.993 6.952 14.415 6.952 14.676 7.212 L 16.788 9.324 C 17.048 9.585 17.048 10.007 16.788 10.267 L 11.875 15.18 C 11.615 15.44 11.193 15.44 10.932 15.18 Z" fill="var(--svg-icon-tint)"></path><path d="M 3.096 0.303 C 3.318 0.17 3.6 0.33 3.6 0.589 L 3.6 3.732 C 3.6 3.991 3.318 4.151 3.096 4.018 L 0.953 2.732 C 0.521 2.473 0.521 1.848 0.953 1.589 Z" transform="translate(6.24 13.8) rotate(-45 1.8 2.16)" fill="var(--svg-icon-tint)"></path></svg></div>
							<div class="title">Signature Pad</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('sound-effects')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 14.225 10.793 C 14.471 11.102 14.623 11.529 14.623 12 C 14.623 12.471 14.471 12.898 14.225 13.207" fill="transparent" stroke-width="1.33" stroke="var(--svg-icon-tint)" stroke-linecap="round" stroke-linejoin="round"></path><path d="M 16.224 9.185 C 16.96 9.911 17.417 10.905 17.417 12 C 17.417 13.095 16.96 14.09 16.224 14.816" fill="transparent" stroke-width="1.33" stroke="var(--svg-icon-tint)" stroke-linecap="round" stroke-linejoin="round"></path><path d="M 6.083 10.656 C 6.083 10.288 6.382 9.989 6.75 9.989 L 7.674 9.989 L 11.021 7.835 C 11.464 7.549 12.048 7.868 12.048 8.396 L 12.048 15.604 C 12.048 16.132 11.464 16.451 11.021 16.165 L 7.674 14.011 L 6.75 14.011 C 6.382 14.011 6.083 13.712 6.083 13.344 Z" fill="var(--svg-icon-tint)"></path></svg></div>
							<div class="title">Sound Effects</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('card-swipe')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 3.423 7.423 C 3.423 5.214 5.214 3.423 7.423 3.423 L 16.756 3.423 C 18.965 3.423 20.756 5.214 20.756 7.423 L 20.756 16.756 C 20.756 18.965 18.965 20.756 16.756 20.756 L 7.423 20.756 C 5.214 20.756 3.423 18.965 3.423 16.756 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 9.172 3.377 C 10.734 1.815 13.266 1.815 14.828 3.377 L 20.721 9.269 C 22.283 10.831 22.283 13.364 20.721 14.926 L 14.828 20.819 C 13.266 22.381 10.734 22.381 9.172 20.819 L 3.279 14.926 C 1.717 13.364 1.717 10.831 3.279 9.269 Z" fill="var(--svg-icon-tint)"></path></svg></div>
							<div class="title">Card Swipe</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('custom-effect')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6.2 C 2 5.673 2.31 5.195 2.792 4.981 L 7.063 3.083 C 7.503 2.887 8 3.21 8 3.693 L 8 20.307 C 8 20.79 7.503 21.113 7.063 20.917 L 2.792 19.019 C 2.31 18.805 2 18.327 2 17.8 Z" fill="var(--svg-icon-tint)" opacity="0.4"></path><path d="M 9.333 3.297 C 9.333 2.642 9.954 2.163 10.588 2.33 L 20.509 4.941 C 21.388 5.172 22 5.967 22 6.875 L 22 17.125 C 22 18.033 21.388 18.828 20.509 19.059 L 10.588 21.67 C 9.954 21.837 9.333 21.358 9.333 20.703 Z" fill="var(--svg-icon-tint)"></path></svg></div>
							<div class="title">Custom Effect</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('drag-handle')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 5.333 2.667 L 2.667 0 L 0 2.667" transform="translate(5.667 10.667) rotate(-90 2.667 1.333)" fill="transparent" stroke-width="1.67" stroke="var(--svg-icon-tint)" stroke-linecap="round" stroke-linejoin="round"></path><path d="M 5.333 0 L 2.667 2.667 L 0 0" transform="translate(13 10.667) rotate(-90 2.667 1.333)" fill="transparent" stroke-width="1.67" stroke="var(--svg-icon-tint)" stroke-linecap="round" stroke-linejoin="round"></path></svg></div>
							<div class="title">Drag Handle</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('dynamic-header')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 8 L 2 8 Z" fill="var(--svg-icon-tint)"></path></svg></div>
							<div class="title">Dynamic Header</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('image-panning')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 12 14 C 12 12.895 12.895 12 14 12 L 20 12 C 21.105 12 22 12.895 22 14 L 22 18 C 22 20.209 20.209 22 18 22 L 14 22 C 12.895 22 12 21.105 12 20 Z" fill="var(--svg-icon-tint)"></path></svg></div>
							<div class="title">Image Panning</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('input-data')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 7.333 8.333 C 7.333 7.781 7.781 7.333 8.333 7.333 L 15.667 7.333 C 16.219 7.333 16.667 7.781 16.667 8.333 L 16.667 10.333 C 16.667 10.886 16.219 11.333 15.667 11.333 L 8.333 11.333 C 7.781 11.333 7.333 10.886 7.333 10.333 Z" fill="var(--svg-icon-tint)"></path><path d="M 7.333 13.667 C 7.333 13.114 7.781 12.667 8.333 12.667 L 15.667 12.667 C 16.219 12.667 16.667 13.114 16.667 13.667 L 16.667 15.667 C 16.667 16.219 16.219 16.667 15.667 16.667 L 8.333 16.667 C 7.781 16.667 7.333 16.219 7.333 15.667 Z" fill="var(--svg-icon-tint)" opacity="0.4"></path></svg></div>
							<div class="title">Input Data</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('input-validation')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 7.333 8.333 C 7.333 7.781 7.781 7.333 8.333 7.333 L 15.667 7.333 C 16.219 7.333 16.667 7.781 16.667 8.333 L 16.667 10.333 C 16.667 10.886 16.219 11.333 15.667 11.333 L 8.333 11.333 C 7.781 11.333 7.333 10.886 7.333 10.333 Z" fill="var(--svg-icon-tint)" opacity="0.4"></path><path d="M 7.333 13.667 C 7.333 13.114 7.781 12.667 8.333 12.667 L 15.667 12.667 C 16.219 12.667 16.667 13.114 16.667 13.667 L 16.667 15.667 C 16.667 16.219 16.219 16.667 15.667 16.667 L 8.333 16.667 C 7.781 16.667 7.333 16.219 7.333 15.667 Z" fill="var(--svg-icon-tint)"></path></svg></div>
							<div class="title">Input Validation</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('like-animation')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 5.28 0 C 7.017 0 7.747 2.366 6.357 3.755 C 4.968 5.144 3.543 5.905 3.543 5.905 C 3.543 5.905 2.118 5.144 0.728 3.755 C -0.661 2.365 0.069 -0 1.806 0 C 3.543 0 3.543 1.701 3.543 1.701 C 3.543 1.701 3.543 0 5.28 0 Z" transform="translate(11.213 11.787) rotate(15 3.543 2.953)" fill="var(--svg-icon-tint)"></path><path d="M 5.28 0 C 7.017 -0 7.747 2.365 6.357 3.755 C 4.968 5.144 3.543 5.905 3.543 5.905 C 3.543 5.905 2.118 5.144 0.728 3.755 C -0.661 2.366 0.069 0 1.806 0 C 3.543 0 3.543 1.701 3.543 1.701 C 3.543 1.701 3.543 0 5.28 0 Z" transform="translate(5.701 6.669) rotate(-15 3.543 2.953)" fill="var(--svg-icon-tint)" opacity="0.4"></path></svg></div>
							<div class="title">Like Animation</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('like-counter')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 14.778 7.333 C 17.556 7.333 18.724 11.072 16.502 13.268 C 14.279 15.464 12 16.667 12 16.667 C 12 16.667 9.721 15.464 7.498 13.268 C 5.276 11.072 6.444 7.333 9.222 7.333 C 12 7.333 12 10.022 12 10.022 C 12 10.022 12 7.333 14.778 7.333 Z" fill="var(--svg-icon-tint)"></path></svg></div>
							<div class="title">Like Counter</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('lock-screen')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 7.333 11 C 7.333 10.448 7.781 10 8.333 10 L 15.667 10 C 16.219 10 16.667 10.448 16.667 11 L 16.667 15.667 C 16.667 16.219 16.219 16.667 15.667 16.667 L 8.333 16.667 C 7.781 16.667 7.333 16.219 7.333 15.667 Z" fill="var(--svg-icon-tint)"></path><path d="M 12 7.333 C 13.289 7.333 14.333 8.378 14.333 9.667 C 14.333 10.955 13.289 12 12 12 C 10.711 12 9.667 10.955 9.667 9.667 C 9.667 8.378 10.711 7.333 12 7.333 Z" fill="transparent" stroke-width="1.67" stroke="var(--svg-icon-tint)"></path></svg></div>
							<div class="title">Lock Screen</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('long-press-menu')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 16.667 10.667 C 17.771 10.667 18.667 11.562 18.667 12.667 C 18.667 13.771 17.771 14.667 16.667 14.667 C 15.562 14.667 14.667 13.771 14.667 12.667 C 14.667 11.562 15.562 10.667 16.667 10.667 Z" fill="var(--svg-icon-tint)" opacity="0.4"></path><path d="M 12 8 C 13.105 8 14 8.895 14 10 C 14 11.105 13.105 12 12 12 C 10.895 12 10 11.105 10 10 C 10 8.895 10.895 8 12 8 Z" fill="var(--svg-icon-tint)"></path><path d="M 7.333 10.667 C 8.438 10.667 9.333 11.562 9.333 12.667 C 9.333 13.771 8.438 14.667 7.333 14.667 C 6.229 14.667 5.333 13.771 5.333 12.667 C 5.333 11.562 6.229 10.667 7.333 10.667 Z" fill="var(--svg-icon-tint)" opacity="0.4"></path></svg></div>
							<div class="title">Long Press Menu</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('perspective-3d')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 6.913 22 C 5.987 22 5.182 21.364 4.967 20.463 L 2.586 10.463 C 2.287 9.206 3.24 8 4.532 8 L 19.468 8 C 20.76 8 21.713 9.206 21.414 10.463 L 19.033 20.463 C 18.818 21.364 18.013 22 17.087 22 Z" fill="var(--svg-icon-tint)"></path><path d="M 3.833 7 C 3.557 7 3.333 6.776 3.333 6.5 L 3.333 6.5 C 3.333 5.672 4.005 5 4.833 5 L 19.167 5 C 19.995 5 20.667 5.672 20.667 6.5 L 20.667 6.5 C 20.667 6.776 20.443 7 20.167 7 Z" fill="var(--svg-icon-tint)" opacity="0.7"></path><path d="M 5.167 4 C 4.891 4 4.667 3.776 4.667 3.5 L 4.667 3.5 C 4.667 2.672 5.338 2 6.167 2 L 17.833 2 C 18.662 2 19.333 2.672 19.333 3.5 L 19.333 3.5 C 19.333 3.776 19.109 4 18.833 4 Z" fill="var(--svg-icon-tint)" opacity="0.4"></path></svg></div>
							<div class="title">Perspective 3D</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('progress-bar')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 1.82 6 C 1.82 3.791 3.61 2 5.82 2 L 17.82 2 C 20.029 2 21.82 3.791 21.82 6 L 21.82 18 C 21.82 20.209 20.029 22 17.82 22 L 5.82 22 C 3.61 22 1.82 20.209 1.82 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 5.153 17 C 5.153 16.08 5.899 15.333 6.82 15.333 L 16.82 15.333 C 17.74 15.333 18.486 16.08 18.486 17 L 18.486 17 C 18.486 17.92 17.74 18.667 16.82 18.667 L 6.82 18.667 C 5.899 18.667 5.153 17.92 5.153 17 Z" fill="var(--svg-icon-tint)" opacity="0.4"></path><path d="M 5.153 17 C 5.153 16.08 5.899 15.333 6.82 15.333 L 11.486 15.333 C 12.407 15.333 13.153 16.08 13.153 17 L 13.153 17 C 13.153 17.92 12.407 18.667 11.486 18.667 L 6.82 18.667 C 5.899 18.667 5.153 17.92 5.153 17 Z" fill="var(--svg-icon-tint)"></path></svg></div>
							<div class="title">Progress Bar</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('scroll-progress')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 7.333 10.333 C 7.333 9.781 7.781 9.333 8.333 9.333 L 15.667 9.333 C 16.219 9.333 16.667 9.781 16.667 10.333 L 16.667 11.667 C 16.667 12.219 16.219 12.667 15.667 12.667 L 8.333 12.667 C 7.781 12.667 7.333 12.219 7.333 11.667 Z" fill="var(--svg-icon-tint)" opacity="0.4"></path><path d="M 7.333 14.667 C 7.333 14.114 7.781 13.667 8.333 13.667 L 15.667 13.667 C 16.219 13.667 16.667 14.114 16.667 14.667 L 16.667 16 C 16.667 16.552 16.219 17 15.667 17 L 8.333 17 C 7.781 17 7.333 16.552 7.333 16 Z" fill="var(--svg-icon-tint)" opacity="0.4"></path><path d="M 7.333 7.667 C 7.333 7.298 7.632 7 8 7 L 16 7 C 16.368 7 16.667 7.298 16.667 7.667 L 16.667 7.667 C 16.667 8.035 16.368 8.333 16 8.333 L 8 8.333 C 7.632 8.333 7.333 8.035 7.333 7.667 Z" fill="var(--svg-icon-tint)" opacity="0.4"></path><path d="M 7.333 7.667 C 7.333 7.298 7.632 7 8 7 L 12.667 7 C 13.035 7 13.333 7.298 13.333 7.667 L 13.333 7.667 C 13.333 8.035 13.035 8.333 12.667 8.333 L 8 8.333 C 7.632 8.333 7.333 8.035 7.333 7.667 Z" fill="var(--svg-icon-tint)"></path></svg></div>
							<div class="title">Scroll Progress</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('show-password')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 10.6 12 C 10.6 11.227 11.227 10.6 12 10.6 L 12 10.6 C 12.773 10.6 13.4 11.227 13.4 12 L 13.4 12 C 13.4 12.773 12.773 13.4 12 13.4 L 12 13.4 C 11.227 13.4 10.6 12.773 10.6 12 Z" fill="var(--svg-icon-tint)"></path><path d="M 12.166 7.833 C 14.892 7.833 17.161 9.42 17.811 12 C 17.161 14.58 14.892 16.167 12.166 16.167 C 9.44 16.167 7.127 14.58 6.478 12 C 7.127 9.42 9.44 7.833 12.166 7.833 Z M 9.333 12 C 9.333 13.473 10.527 14.667 12 14.667 C 13.473 14.667 14.667 13.473 14.667 12 C 14.667 10.527 13.473 9.333 12 9.333 C 10.527 9.333 9.333 10.527 9.333 12 Z" fill="var(--svg-icon-tint)"></path></svg></div>
							<div class="title">Show Password</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('slider')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 5.667 12 L 18.333 12" stroke="var(--svg-icon-tint)" fill="transparent" opacity="0.4" stroke-width="2.67" stroke-linecap="round" stroke-linejoin="round"></path><path d="M 12 8.333 C 14.025 8.333 15.667 9.975 15.667 12 C 15.667 14.025 14.025 15.667 12 15.667 C 9.975 15.667 8.333 14.025 8.333 12 C 8.333 9.975 9.975 8.333 12 8.333 Z" fill="var(--svg-icon-tint)"></path></svg></div>
							<div class="title">Slider</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('stories-drag')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 5.333 6.667 C 5.333 5.93 5.93 5.333 6.667 5.333 L 10 5.333 C 10.736 5.333 11.333 5.93 11.333 6.667 L 11.333 6.667 C 11.333 7.403 10.736 8 10 8 L 6.667 8 C 5.93 8 5.333 7.403 5.333 6.667 Z" fill="var(--svg-icon-tint)" opacity="0.4"></path><path d="M 12.667 6.667 C 12.667 5.93 13.264 5.333 14 5.333 L 17.333 5.333 C 18.07 5.333 18.667 5.93 18.667 6.667 L 18.667 6.667 C 18.667 7.403 18.07 8 17.333 8 L 14 8 C 13.264 8 12.667 7.403 12.667 6.667 Z" fill="var(--svg-icon-tint)"></path></svg></div>
							<div class="title">Stories: Drag</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('stories-tap')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18 C 22 20.209 20.209 22 18 22 L 6 22 C 3.791 22 2 20.209 2 18 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 5.333 6.667 C 5.333 5.93 5.93 5.333 6.667 5.333 L 10 5.333 C 10.736 5.333 11.333 5.93 11.333 6.667 L 11.333 6.667 C 11.333 7.403 10.736 8 10 8 L 6.667 8 C 5.93 8 5.333 7.403 5.333 6.667 Z" fill="var(--svg-icon-tint)"></path><path d="M 12.667 6.667 C 12.667 5.93 13.264 5.333 14 5.333 L 17.333 5.333 C 18.07 5.333 18.667 5.93 18.667 6.667 L 18.667 6.667 C 18.667 7.403 18.07 8 17.333 8 L 14 8 C 13.264 8 12.667 7.403 12.667 6.667 Z" fill="var(--svg-icon-tint)" opacity="0.4"></path></svg></div>
							<div class="title">Stories: Tap</div>
						</div>
					</li>
					<li>
						<div class="btn" (click)="onSelect('toast-prompt')">
							<div class="icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M 2 6 C 2 3.791 3.791 2 6 2 L 18 2 C 20.209 2 22 3.791 22 6 L 22 18.333 C 22 20.542 20.209 22.333 18 22.333 L 6 22.333 C 3.791 22.333 2 20.542 2 18.333 Z" fill="var(--svg-icon-tint)" opacity="0.2"></path><path d="M 12 6.333 C 15.13 6.333 17.667 8.87 17.667 12 C 17.667 15.13 15.13 17.667 12 17.667 C 8.87 17.667 6.333 15.13 6.333 12 C 6.333 8.87 8.87 6.333 12 6.333 Z" fill="transparent" stroke-width="1.33" stroke="var(--svg-icon-tint)"></path><path d="M 12 13 C 12.552 13 13 13.448 13 14 C 13 14.552 12.552 15 12 15 C 11.448 15 11 14.552 11 14 C 11 13.448 11.448 13 12 13 Z" fill="var(--svg-icon-tint)"></path><path d="M 11.06 9.998 C 11.027 9.457 11.458 9 12 9 L 12 9 C 12.542 9 12.973 9.457 12.94 9.998 L 12.848 11.535 C 12.821 11.983 12.449 12.333 12 12.333 L 12 12.333 C 11.551 12.333 11.179 11.983 11.152 11.535 Z" fill="var(--svg-icon-tint)"></path></svg></div>
							<div class="title">Toast Prompt</div>
						</div>
					</li>
				</ul>
			</li>
			-->
		</ul>
		<ul class="nav--editor" *if="mode === 2">
			<li>
				<div class="title" [innerHTML]="'editor_views' | label"></div>
				<ul class="nav--editor">
					<li *for="let item of supportedViewTypes">
						<div class="btn" [class]="{ disabled: item.disabled }" (click)="onSelect({ type:'view', value: item.type.name })">
							<div class="icon">
								<svg-icon [name]="item.type.name"></svg-icon>
							</div>
							<div class="title" [innerHTML]="item.name"></div>
						</div>
					</li>
				</ul>
			</li>
		</ul>
		<ul class="nav--editor" *if="mode === 3">
			<li>
				<div class="title" [innerHTML]="'editor_view_items' | label"></div>
				<ul class="nav--editor">
					<li *for="let item of supportedViewItemTypes">
						<div class="btn" [class]="{ disabled: item.disabled }" (click)="onSelect({ type:'viewItem', value: item.type.name })" [title]="item.id">
							<div class="icon">
								<svg-icon [name]="item.type.name"></svg-icon>
							</div>
							<div class="title" [innerHTML]="item.name"></div>
						</div>
					</li>
				</ul>
				<div class="abstract" *if="supportedViewItemTypes.length == 0" [innerHTML]="'editor_type_no_items' | label"></div>
			</li>
		</ul>
	</div>
	`
};let MENU_UID = 0;
class MenuService {
  static set active(active) {
    this.active$.next(active);
  }
  static get active() {
    return this.active$.getValue();
  }
  static menu$() {
    return this.getMenu$().pipe(operators.switchMap(menu => {
      this.menu$_.next(menu);
      return this.menu$_;
    }));
  }
  static getMenu$() {
    return HttpService.get$('/api/menu').pipe(operators.map(data => {
      data.menu.sort((a, b) => {
        return a.order - b.order;
      });
      return data.menu;
    }));
  }
  static updateMenu$(menu) {
    return HttpService.put$('/api/menu', menu);
  }
  static createMenuItem$(parentId, order) {
    if (parentId === void 0) {
      parentId = null;
    }
    if (order === void 0) {
      order = 0;
    }
    const payload = {
      parentId: parentId,
      viewId: null,
      order: order * 10,
      name: 'Folder ' + ++MENU_UID
    };
    return HttpService.post$('/api/menu', payload);
  }
  static updateMenuItem$(item) {
    return HttpService.put$(`/api/menu/${item.id}`, item);
  }
  static deleteMenuItem$(item) {
    return HttpService.delete$(`/api/menu/${item.id}`);
  }
  static getModelMenu$(views, editor) {
    if (editor === void 0) {
      editor = false;
    }
    return this.menu$().pipe(operators.map(menu => {
      if (menu && menu.length) {
        menu = menu.filter(x => x.viewId == null || x.viewId == 0 || views.find(v => v.id === x.viewId) != null);
        // menu = menu.filter(x => x.viewId == null || views.find(v => v.id === x.viewId) != null);
        // console.log('getModelMenu$', menu);
        return this.mapMenuItems(menu);
      } else {
        // console.log('MenuService.getModelMenu$.Views', views);
        const keys = {};
        views.forEach(item => {
          if (item.type.name !== ViewType.WaitingRoom.name && (!item.hidden || editor)) {
            let group = keys[item.type.name];
            if (!group) {
              group = keys[item.type.name] = [];
            }
            group.push(item);
          }
        });
        const menu = Object.keys(keys).map(typeName => {
          let name = 'Button';
          switch (typeName) {
            case ViewType.WaitingRoom.name:
              name = 'Waiting Room';
              break;
            case ViewType.Panorama.name:
              name = 'Experience';
              break;
            case ViewType.PanoramaGrid.name:
              name = 'Virtual Tour';
              break;
            case ViewType.Room3d.name:
              name = 'Stanze 3D';
              break;
            case ViewType.Model.name:
              name = 'Modelli 3D';
              break;
            case ViewType.Media.name:
              name = 'Media';
              break;
          }
          return {
            name,
            type: {
              name: 'menu-group'
            },
            items: views.filter(x => x.type.name === typeName && (!x.hidden || editor))
          };
        });
        return menu;
      }
    }));
  }
  static mapMenuItem(item, items) {
    if (item.viewId) {
      return {
        id: item.viewId,
        name: item.name,
        type: {
          name: 'panorama'
        }
      };
    } else {
      return {
        name: item.name,
        type: {
          name: 'menu-group'
        },
        items: this.mapMenuItems(items, item.id)
      };
    }
  }
  static mapMenuItems(items, parentId) {
    if (parentId === void 0) {
      parentId = null;
    }
    return items.filter(item => {
      // console.log('MenuService.mapMenuItems', item);
      return (item.parentId || null) === parentId;
    }).map(item => this.mapMenuItem(item, items)).filter(x => x.id != null || x.items.length > 0);
  }
}
MenuService.active$ = new rxjs.BehaviorSubject(false);
MenuService.menu$_ = new rxjs.BehaviorSubject([]);class DropService {
  static drop$(input) {
    if (rxcomp.isPlatformBrowser && input) {
      const body = document.querySelector('body');
      return rxjs.merge(rxjs.fromEvent(body, 'drop'), rxjs.fromEvent(body, 'dragover')).pipe(operators.map(event => {
        // console.log('DropService.drop$', event);
        event.preventDefault();
        if (event.target === input) {
          input.files = event.dataTransfer.files;
        }
        return;
      }));
    } else {
      return rxjs.EMPTY;
    }
  }
  static change$(input) {
    if (rxcomp.isPlatformBrowser && input) {
      return rxjs.fromEvent(input, 'change').pipe(operators.filter(event => input.files && input.files.length), operators.map(event => Array.from(input.files)));
    } else {
      return rxjs.EMPTY;
    }
  }
  static asset$(input, previews) {
    if (previews === void 0) {
      previews = [];
    }
    return this.change$(input).pipe(operators.switchMap(files => {
      previews.length = files.length;
      previews.fill(null);
      // output.previews = files.map(() => null);
      const uploads$ = files.map((file, i) => this.read$(file, i, previews).pipe(operators.map(() => file), operators.switchMap(file => AssetService.upload$([file])), operators.switchMap(uploads => {
        const upload = uploads[0];
        const asset = Asset.fromUrl(upload.url);
        return AssetService.assetCreate$(asset);
      })));
      return rxjs.combineLatest(uploads$);
    }));
  }
  static read$(file, i, previews) {
    if (previews === void 0) {
      previews = [];
    }
    const reader = new FileReader();
    const reader$ = rxjs.fromEvent(reader, 'load').pipe(operators.switchMap(event => {
      const blob = event.target.result;
      return this.resize$(blob);
    }), operators.tap(resized => {
      previews[i] = resized;
    }));
    reader.readAsDataURL(file);
    return reader$;
  }
  static resize$(blob) {
    return rxjs.from(this.resize_(blob));
  }
  static resize_(blob) {
    return new Promise((resolve, reject) => {
      const img = document.createElement('img');
      img.onload = function () {
        const MAX_WIDTH = 320;
        const MAX_HEIGHT = 240;
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        let width = img.width;
        let height = img.height;
        if (width > height) {
          if (width > MAX_WIDTH) {
            height *= MAX_WIDTH / width;
            width = MAX_WIDTH;
          }
        } else {
          if (height > MAX_HEIGHT) {
            width *= MAX_HEIGHT / height;
            height = MAX_HEIGHT;
          }
        }
        canvas.width = width;
        canvas.height = height;
        ctx.drawImage(img, 0, 0, width, height);
        const dataUrl = canvas.toDataURL('image/jpeg', 0.9);
        resolve(dataUrl);
      };
      img.onerror = function () {
        reject(blob);
      };
      img.src = blob;
    });
  }
}class ControlComponent extends rxcomp.Component {
  onChanges() {
    const {
      node
    } = rxcomp.getContext(this);
    // console.log(this, node, this.control);
    const control = this.control;
    const flags = control.flags;
    Object.keys(flags).forEach(key => {
      flags[key] ? node.classList.add(key) : node.classList.remove(key);
    });
  }
}
ControlComponent.meta = {
  selector: '[control]',
  inputs: ['control']
};class ControlAssetComponent extends ControlComponent {
  onInit() {
    this.label = this.label || 'label';
    this.disabled = this.disabled || false;
    this.accept = this.accept || 'image/png, image/jpeg';
    const {
      node
    } = rxcomp.getContext(this);
    const input = node.querySelector('input');
    input.setAttribute('accept', this.accept);
    DropService.drop$(input).pipe(operators.takeUntil(this.unsubscribe$)).subscribe();
    DropService.change$(input).pipe(operators.switchMap(files => {
      const uploads$ = files.map((file, i) => AssetService.upload$([file]).pipe(operators.switchMap(uploads => AssetService.createOrUpdateAsset$(uploads, this.control))));
      return rxjs.combineLatest(uploads$);
    }), operators.takeUntil(this.unsubscribe$)).subscribe(assets => {
      // console.log('ControlAssetComponent.change$', assets);
      this.control.value = assets[0];
    });
  }
}
ControlAssetComponent.meta = {
  selector: '[control-asset]',
  inputs: ['control', 'label', 'disabled', 'accept'],
  template: /* html */`
		<div class="group--form" [class]="{ required: control.validators.length, disabled: disabled }">
			<div class="control--head">
				<label [innerHTML]="label"></label>
				<span class="required__badge" [innerHTML]="'required' | label"></span>
			</div>
			<div class="group--picture">
				<div class="group--picture__info">
					<span [innerHTML]="'browse' | label"></span>
				</div>
				<img [lazy]="control.value | asset" [size]="{ width: 320, height: 240 }" *if="control.value && control.value.type.name === 'image'" />
				<video [src]="control.value | asset" *if="control.value && control.value.type.name === 'video'"></video>
				<input type="file">
			</div>
			<div class="file-name" *if="control.value" [innerHTML]="control.value.file"></div>
		</div>
		<errors-component [control]="control"></errors-component>
	`
};class ControlMenuComponent extends ControlAssetComponent {
  static itemToFormGroup(item) {
    return new rxcompForm.FormGroup({
      id: item.id,
      parentId: item.parentId,
      viewId: item.viewId,
      name: item.name,
      items: new rxcompForm.FormArray()
    });
  }

  /*
  static newFormGroup(parentId = null) {
  	return new FormGroup({
  		id: null,
  		parentId: parentId,
  		viewId: null,
  		name: 'Folder ' + (++MENU_UID),
  		items: new FormArray(),
  	});
  }
  */

  onInit() {
    this.dropdownId = DropdownDirective.nextId();
    this.controls = this.control.controls;
    EditorService.viewIdOptions$().pipe(operators.first()).subscribe(options => {
      this.controls.viewId.options = options;
    });
  }
  onAddItem() {
    MenuService.createMenuItem$(this.controls.id.value, this.controls.items.length).pipe(operators.first()).subscribe(item => {
      this.controls.items.push(ControlMenuComponent.itemToFormGroup(item));
    });
    // this.controls.items.push(ControlMenuComponent.newFormGroup(this.controls.id.value));
  }

  onRemoveItem() {
    this.remove.next(this.control);
  }
  onRemoveControl(control) {
    MenuService.deleteMenuItem$(control.value).pipe(operators.first()).subscribe(() => {
      this.controls.items.remove(control);
    });
    // this.controls.items.remove(control);
  }

  onLinkItem() {
    this.link.next(this.control);
  }
  onLinkControl(control) {
    this.link.next(control);
  }
  onItemUp() {
    this.up.next(this.control);
  }
  onItemDown() {
    this.down.next(this.control);
  }
  onUpControl(control) {
    const items = this.controls.items;
    const length = items.controls.length;
    let index = items.controls.indexOf(control);
    items.controls.splice(index, 1);
    if (index > 0) {
      index--;
    } else {
      index = length - 1;
    }
    items.insert(control, index);
  }
  onDownControl(control) {
    const items = this.controls.items;
    const length = items.controls.length;
    let index = items.controls.indexOf(control);
    items.controls.splice(index, 1);
    if (index < length - 1) {
      index++;
    } else {
      index = 0;
    }
    items.insert(control, index);
  }
  setView(view) {
    // console.log('ControlMenuComponent.setView', view.id);
    const payload = Object.assign({}, this.control.value);
    payload.viewId = view.id;
    if (view.id) {
      payload.name = view.name;
    }
    MenuService.updateMenuItem$(payload).pipe(operators.first()).subscribe(() => {
      this.controls.viewId.value = view.id;
      if (view.id) {
        this.controls.name.value = view.name;
        // clear sub items
        this.controls.items.controls = [];
        this.controls.items.switchSubjects_();
      }
      // this.change.next(value);
    });
  }

  onTextDidChange(event) {
    // console.log('ControlMenuComponent.onTextDidChange', this.controls.name.value);
    MenuService.updateMenuItem$(this.control.value).pipe(operators.first()).subscribe();
  }
  hasOption(item) {
    return this.controls.viewId.value === item.id;
  }
  onDropped(id) {
    // console.log('ControlMenuComponent.onDropped', id);
  }
}
ControlMenuComponent.meta = {
  selector: '[control-menu]',
  outputs: ['remove', 'link', 'up', 'down'],
  inputs: ['control'],
  template: /* html */`
		<div class="group--form">
			<button type="button" class="control-menu__link" [class]="{ active: control.controls.viewId.value }" (click)="onLinkItem($event)" [dropdown]="dropdownId" (dropped)="onDropped($event)">
				<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#link"></use></svg>
				<div class="dropdown" [dropdown-item]="dropdownId">
					<div class="category">View</div>
					<ul class="nav--dropdown">
						<li (click)="setView(item)" [class]="{ empty: item.id == null }" *for="let item of control.controls.viewId.options">
							<span [class]="{ active: hasOption(item) }" [innerHTML]="item.name"></span>
						</li>
					</ul>
				</div>
			</button>
			<input type="text" class="control--text" [formControl]="control.controls.name" placeholder="Name" (change)="onTextDidChange($event)" />
			<!--
			<button type="button" class="control-menu__add" (click)="onAddItem($event)">
				<span [innerHTML]="control.controls.viewId.value"></span>
			</button>
			-->
			<!--
			<select class="control--select" [formControl]="control.controls.viewId">
				<option [value]="item.id" *for="let item of control.controls.viewId.options" [innerHTML]="item.name"></option>
			</select>
			-->
			<button type="button" class="control-menu__up" (click)="onItemUp($event)">
				<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#up"></use></svg>
			</button>
			<button type="button" class="control-menu__down" (click)="onItemDown($event)">
				<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#down"></use></svg>
			</button>
			<button type="button" class="control-menu__add" (click)="onAddItem($event)" *if="!control.controls.viewId.value">
				<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#add"></use></svg>
			</button>
			<button type="button" class="control-menu__remove" (click)="onRemoveItem($event)">
				<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#remove"></use></svg>
			</button>
		</div>
		<div class="group--items">
			<div control-menu *for="let sub of control.controls.items.controls" [control]="sub" (remove)="onRemoveControl($event)" (link)="onLinkControl($event)" (up)="onUpControl($event)" (down)="onDownControl($event)"></div>
		</div>
	`
};class MenuBuilderComponent extends rxcomp.Component {
  onInit() {
    this.changes = 0;
    this.form = null;
    MenuService.getMenu$().pipe(operators.first()).subscribe(menu => this.initForm(menu));
  }
  initForm(menu) {
    if (menu === void 0) {
      menu = [];
    }
    const items = this.menuToControls(menu);
    // console.log('MenuBuilderComponent', items);
    const form = this.form = new rxcompForm.FormGroup({
      items: items
    });
    this.controls = form.controls;
    form.changes$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(changes => {
      // console.log('MenuBuilderComponent', changes);
      this.changes++;
      this.pushChanges();
    });
  }
  onLinkControl(control) {}
  onUpControl(control) {
    const items = this.controls.items;
    const length = items.controls.length;
    let index = items.controls.indexOf(control);
    items.controls.splice(index, 1);
    if (index > 0) {
      index--;
    } else {
      index = length - 1;
    }
    items.insert(control, index);
  }
  onDownControl(control) {
    const items = this.controls.items;
    const length = items.controls.length;
    let index = items.controls.indexOf(control);
    items.controls.splice(index, 1);
    if (index < length - 1) {
      index++;
    } else {
      index = 0;
    }
    items.insert(control, index);
  }
  onAddItem() {
    MenuService.createMenuItem$(null, this.controls.items.length).pipe(operators.first()).subscribe(item => {
      this.controls.items.push(ControlMenuComponent.itemToFormGroup(item));
    });
    // this.controls.items.push(ControlMenuComponent.newFormGroup());
  }

  onRemoveControl(control) {
    MenuService.deleteMenuItem$(control.value).pipe(operators.first()).subscribe(() => {
      this.controls.items.remove(control);
    });
    // this.controls.items.remove(control);
  }

  isValid() {
    const isValid = this.form.valid;
    return isValid;
  }
  onSubmit(event) {
    if (this.form.valid) {
      const changes = this.form.value;
      const menu = this.controlsToMenu(changes);
      MenuService.updateMenu$(menu);
    } else {
      this.form.touched = true;
    }
  }
  menuToControls(menu, parentId) {
    if (parentId === void 0) {
      parentId = null;
    }
    const items = new rxcompForm.FormArray(menu.filter(x => {
      return (x.parentId || null) === parentId;
    }).map(x => {
      const subitems = this.menuToControls(menu, x.id);
      return new rxcompForm.FormGroup({
        id: x.id,
        parentId: x.parentId,
        viewId: x.viewId,
        name: x.name,
        items: subitems
      });
    }));
    return items;
  }
  controlsToMenu(changes) {
    const menu = [];
    const pushItem = items => {
      if (items) {
        items.forEach((item, i) => {
          const menuItem = Object.assign({}, item);
          menuItem.order = i * 10;
          delete menuItem.items;
          menu.push(menuItem);
          pushItem(item.items);
        });
      }
    };
    pushItem(changes.items);
    return menu;
  }
}
MenuBuilderComponent.meta = {
  selector: '[menu-builder]',
  inputs: ['views'],
  template: /* html */`
	<div class="group--head">
		<div class="title" [innerHTML]="'editor_menu' | label"></div>
	</div>
	<div class="group--main">
		<div class="nav--tree" *if="form">
			<form class="form" [formGroup]="form" (submit)="isValid() && onSubmit()" name="form" role="form" novalidate autocomplete="off">
				<div class="abstract" *if="controls.items.controls.length == 0" [innerHTML]="'editor_add_item' | label"></div>
				<div *for="let control of controls.items.controls">
					<div control-menu [control]="control" (remove)="onRemoveControl($event)" (link)="onLinkControl($event)" (up)="onUpControl($event)" (down)="onDownControl($event)"></div>
				</div>
			</form>
		</div>
	</div>
	<div class="group--foot">
		<button type="button" class="btn--mode" (click)="onAddItem($event)" [innerHTML]="'editor_add' | label"></button>
		<button type="button" class="btn--mode" (click)="isValid() && onSubmit()" *if="changes > 1" [innerHTML]="'editor_save' | label"></button>
	</div>
	`
};class NavmapItemModalComponent extends rxcomp.Component {
  get data() {
    let data = null;
    const {
      parentInstance
    } = rxcomp.getContext(this);
    if (parentInstance instanceof ModalOutletComponent) {
      data = parentInstance.modal.data;
    }
    return data;
  }
  get navmap() {
    let navmap = null;
    const data = this.data;
    if (data) {
      navmap = data.navmap;
    }
    return navmap;
  }
  get position() {
    let position = [0, 0, 0];
    const data = this.data;
    if (data) {
      position = [data.hit.x, data.hit.y, 0];
    }
    return position;
  }
  onInit() {
    const position = this.position;
    this.error = null;
    const form = this.form = new rxcompForm.FormGroup({
      type: ViewItemType.Nav,
      title: null,
      abstract: null,
      viewId: new rxcompForm.FormControl(null, rxcompForm.RequiredValidator()),
      keepOrientation: false,
      important: false,
      transparent: false,
      position: new rxcompForm.FormControl(position, rxcompForm.RequiredValidator()),
      asset: null
    });
    this.controls = form.controls;
    form.changes$.subscribe(changes => {
      // console.log('NavmapItemModalComponent.form.changes$', changes, form.valid, form);
      this.pushChanges();
    });
    EditorService.viewIdOptions$().pipe(operators.first()).subscribe(options => {
      this.controls.viewId.options = options;
      this.pushChanges();
    });
  }
  onSubmit() {
    if (this.form.valid) {
      this.form.submitted = true;
      const item = Object.assign({}, this.form.value);
      item.viewId = parseInt(item.viewId);
      // console.log('NavmapItemModalComponent.onSubmit', this.navmap, item);
      NavmapService.itemCreate$(this.navmap, item).pipe(operators.first()).subscribe(response => {
        // console.log('NavmapItemModalComponent.onSubmit.success', response);
        ModalService.resolve(response);
      }, error => {
        console.log('NavmapItemModalComponent.onSubmit.error', error);
        this.error = error;
        this.form.submitted = false;
        // this.form.reset();
      });
    } else {
      this.form.touched = true;
    }
  }
  onClose() {
    ModalService.reject();
  }
}
NavmapItemModalComponent.meta = {
  selector: '[navmap-item-modal]',
  template: /* html */`
		<div class="modal__header">
			<button type="button" class="btn--close" (click)="onClose()">
				<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#close"></use></svg>
			</button>
		</div>
		<div class="container">
			<div class="form">
				<div class="title">Create Map Nav.</div>
				<form [formGroup]="form" (submit)="onSubmit()" name="form" role="form" novalidate autocomplete="off">
					<div class="form-controls">
						<div control-text [control]="controls.title" label="Title"></div>
						<div control-textarea [control]="controls.abstract" label="Abstract"></div>
						<div control-custom-select [control]="controls.viewId" label="NavToView"></div>
						<div control-vector [control]="controls.position" label="Position" [precision]="3" [disabled]="true"></div>
					</div>
					<div class="group--cta">
						<button type="submit" class="btn--accept">
							<span>Create</span>
						</button>
					</div>
				</form>
			</div>
		</div>
	`
};
NavmapItemModalComponent.chunk = () => /* html */'<div class="nav-modal" navmap-item-modal></div>';class NavmapModalComponent extends rxcomp.Component {
  onInit() {
    this.error = null;
    const form = this.form = new rxcompForm.FormGroup({
      name: new rxcompForm.FormControl(null, rxcompForm.RequiredValidator()),
      asset: new rxcompForm.FormControl(null, rxcompForm.RequiredValidator())
    });
    this.controls = form.controls;
    form.changes$.subscribe(changes => {
      // console.log('NavmapModalComponent.form.changes$', changes, form.valid, form);
      this.pushChanges();
    });
  }
  onSubmit() {
    if (this.form.valid) {
      this.form.submitted = true;
      const values = this.form.value;
      const navmap = {
        name: values.name,
        asset: values.asset
      };
      // console.log('NavmapModalComponent.onSubmit.navmap', navmap);
      return NavmapService.navmapCreate$(navmap).pipe(operators.first()).subscribe(response => {
        // console.log('NavmapModalComponent.onSubmit.success', response);
        ModalService.resolve(response);
      }, error => {
        console.log('NavmapModalComponent.onSubmit.error', error);
        this.error = error;
        this.form.reset();
      });
    } else {
      this.form.touched = true;
    }
  }
  onClose() {
    ModalService.reject();
  }
}
NavmapModalComponent.meta = {
  selector: '[navmap-modal]',
  template: /* html */`
		<div class="modal__header">
			<button type="button" class="btn--close" (click)="onClose()">
				<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#close"></use></svg>
			</button>
		</div>
		<div class="container">
			<div class="form">
				<div class="title">Create Map.</div>
				<form [formGroup]="form" (submit)="onSubmit()" name="form" role="form" novalidate autocomplete="off">
					<div class="form-controls">
						<div control-text [control]="controls.name" label="Name"></div>
						<div control-asset [control]="controls.asset" label="Image" accept="image/png"></div>
					</div>
					<div class="description">Formato immagine .png con trasparenza (2048x1024 o 1024x512)</div>
					<div class="group--cta">
						<button type="submit" class="btn--accept">
							<span>Create</span>
						</button>
					</div>
				</form>
			</div>
		</div>
	`
};
NavmapModalComponent.chunk = () => /* html */'<div class="panorama-modal" navmap-modal></div>';class NavmapBuilderComponent extends rxcomp.Component {
  onInit() {
    this.navmap = null;
    this.navmaps = [];
    NavmapService.navmapGet$().pipe(operators.first()).subscribe(navmaps => {
      this.navmaps = navmaps;
      this.pushChanges();
    });
  }
  onBack(event) {
    this.navmap = null;
    this.pushChanges();
  }
  onAdd() {
    ModalService.open$({
      template: NavmapModalComponent.chunk()
    }).pipe(operators.first()).subscribe(event => {
      if (event instanceof ModalResolveEvent) {
        this.navmaps.push(event.data);
        this.navmap = event.data;
        this.pushChanges();
      }
    });
  }
  onSet(item) {
    this.navmap = this.navmaps.find(x => x.id === item.id);
    this.pushChanges();
  }
  onAddItem(navmap, hit) {
    ModalService.open$({
      template: NavmapItemModalComponent.chunk(),
      data: {
        navmap,
        hit
      }
    }).pipe(operators.first()).subscribe(event => {
      if (event instanceof ModalResolveEvent) {
        const items = navmap.items || [];
        items.push(event.data);
        Object.assign(navmap, {
          items
        });
        this.pushChanges();
      }
    });
  }
  onDelete(navmap) {
    const index = this.navmaps.indexOf(navmap);
    if (index !== -1) {
      this.navmaps.splice(index, 1);
    }
    this.navmap = null;
    this.pushChanges();
  }
}
NavmapBuilderComponent.meta = {
  selector: '[navmap-builder]',
  inputs: ['views'],
  template: /* html */`
	<div class="group--head">
		<div class="title" [innerHTML]="'editor_navmaps' | label"></div>
	</div>
	<div class="group--main">
		<!-- listing navmaps -->
		<div class="listing--navmaps" *if="!navmap">
			<div class="abstract" *if="navmaps.length == 0" [innerHTML]="'editor_add_item' | label"></div>
			<div class="listing__item" *for="let item of navmaps">
				<div class="card--navmap" (click)="onSet(item)">
					<div class="card__picture">
						<img [src]="item.asset | asset" *if="item.asset" />
					</div>
					<div class="card__content">
						<div class="card__name" [innerHTML]="item.name"></div>
					</div>
				</div>
			</div>
		</div>
		<!-- navmap edit -->
		<div class="navmap" navmap-edit [navmap]="navmap" (delete)="onDelete($event)" *if="navmap">
			<form class="form" [formGroup]="form" (submit)="onSubmit()" name="form" role="form" novalidate autocomplete="off">
				<div class="title"><span [innerHTML]="navmap.name"></span> <span [innerHTML]="navmap.id"></span></div>
				<div class="form-controls">
					<div control-text [control]="controls.name" label="Name"></div>
					<!--
					<div control-asset [control]="controls.asset" label="Image" accept="image/png"></div>
					-->
				</div>
				<div class="group--cta">
					<button type="submit" class="btn--accept">
						<span [innerHTML]="'editor_save' | label"></span>
					</button>
					<button type="button" class="btn--remove" (click)="onRemove($event)">
						<span [innerHTML]="'editor_remove' | label"></span>
					</button>
				</div>
				<div class="navmap-control" [class]="mode">
					<div class="navmap-control__image">
						<img draggable="false" [src]="navmap.asset | asset" *if="navmap.asset" />
						<div class="navmap__item" [style]="{ left: item.position[0] * 100 + '%', top: item.position[1] * 100 + '%' }" (mousedown)="onMoveItem($event, item)" (click)="onRemoveItem(item)" *for="let item of navmap.items">
							<img draggable="false" [src]="'textures/ui/nav-point.png' | asset" />
							<div class="title" [innerHTML]="item.title" *if="item.title"></div>
						</div>
					</div>
					<ul class="navmap-control__toolbar">
						<li class="nav__item"><span [class]="{ active: mode === 'insert' }" (click)="onToggleMode('insert')"><svg class="pencil" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#pencil"></use></svg></span></li>
						<li class="nav__item"><span [class]="{ active: mode === 'move' }" (click)="onToggleMode('move')"><svg class="move" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#move"></use></svg></span></li>
						<li class="nav__item"><span [class]="{ active: mode === 'remove' }" (click)="onToggleMode('remove')"><svg class="erase" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#erase"></use></svg></span></li>
					</ul>
				</div>
			</form>
		</div>
	</div>
	<div class="group--foot">
		<button type="button" class="btn--mode" (click)="onAdd($event)" [innerHTML]="'editor_add' | label" *if="!navmap"></button>
		<button type="button" class="btn--mode" (click)="onBack($event)" [innerHTML]="'editor_back' | label" *if="navmap"></button>
	</div>
	`
};const NavmapModes = {
  Idle: 'idle',
  Insert: 'insert',
  Remove: 'remove',
  Move: 'move'
};
class ControlEvent {
  constructor(element, event) {
    const rect = element.getBoundingClientRect();
    this.x = (event.clientX - rect.x) / rect.width;
    this.y = (event.clientY - rect.y) / rect.height;
    // console.log(this);
  }
}

class ControlDownEvent extends ControlEvent {}
class ControlMoveEvent extends ControlEvent {}
class ControlUpEvent extends ControlEvent {}
class NavmapEditComponent extends rxcomp.Component {
  onInit() {
    this.mode = NavmapModes.Idle;
    this.error = null;
    const navmap = this.navmap;
    const form = this.form = new rxcompForm.FormGroup({
      name: new rxcompForm.FormControl(navmap.name, rxcompForm.RequiredValidator()),
      asset: new rxcompForm.FormControl(navmap.asset, rxcompForm.RequiredValidator())
    });
    this.controls = form.controls;
    form.changes$.subscribe(changes => {
      // console.log('NavmapEditComponent.form.changes$', changes, form.valid, form);
      this.pushChanges();
    });
    this.insert$().pipe(operators.takeUntil(this.unsubscribe$)).subscribe(event => {
      // console.log('NavmapEditComponent.insert', event);
      const hit = event;
      ModalService.open$({
        template: NavmapItemModalComponent.chunk(),
        data: {
          navmap,
          hit
        }
      }).pipe(operators.first()).subscribe(event => {
        if (event instanceof ModalResolveEvent) {
          const items = navmap.items || [];
          items.push(event.data);
          Object.assign(navmap, {
            items
          });
          this.pushChanges();
        }
      });
    });
  }
  insert$() {
    const {
      node
    } = rxcomp.getContext(this);
    const image = node.querySelector('.navmap-control__image');
    return rxjs.fromEvent(image, 'pointerdown').pipe(operators.filter(x => this.mode === NavmapModes.Insert), operators.map(event => new ControlDownEvent(image, event)));
  }
  onToggleMode(mode) {
    this.mode = this.mode === mode ? NavmapModes.Idle : mode;
    this.pushChanges();
  }
  onMoveItem(event, item) {
    const navmap = this.navmap;
    switch (this.mode) {
      case NavmapModes.Move:
        {
          const {
            node
          } = rxcomp.getContext(this);
          const image = node.querySelector('.navmap-control__image');
          const position = item.position.slice();
          const down = new ControlDownEvent(image, event);
          const move$ = rxjs.fromEvent(image, 'mousemove').pipe(operators.map(event => new ControlMoveEvent(image, event)), operators.tap(event => {
            const diff = {
              x: event.x - down.x,
              y: event.y - down.y
            };
            item.position = [Math.max(0, Math.min(1, position[0] + diff.x)), Math.max(0, Math.min(1, position[1] + diff.y)), 0];
            this.pushChanges();
          }));
          const up$ = rxjs.fromEvent(image, 'mouseup').pipe(operators.map(event => new ControlUpEvent(image, event)), operators.tap(event => {
            const diff = {
              x: event.x - down.x,
              y: event.y - down.y
            };
            item.position = [Math.max(0, Math.min(1, position[0] + diff.x)), Math.max(0, Math.min(1, position[1] + diff.y)), 0];
            // console.log('NavmapEditComponent.onNavmapItem.Update', navmap, item);
            NavmapService.itemUpdate$(navmap, item).pipe(operators.first()).subscribe(item_ => {
              Object.assign(item, item_);
              // console.log('NavmapEditComponent.onNavmapItem.Update');
              this.pushChanges();
            });
          }));
          move$.pipe(operators.takeUntil(up$)).subscribe();
          break;
        }
    }
  }
  onRemoveItem(item) {
    const navmap = this.navmap;
    switch (this.mode) {
      case NavmapModes.Remove:
        NavmapService.itemDelete$(navmap, item).pipe(operators.first()).subscribe(_ => {
          // console.log('NavmapEditComponent.onNavmapItem.Remove');
          const items = navmap.items || [];
          const index = items.indexOf(item);
          if (index !== -1) {
            items.splice(index, 1);
          }
          Object.assign(navmap, {
            items
          });
          this.pushChanges();
        });
        break;
    }
  }
  onSubmit() {
    if (this.form.valid) {
      this.form.submitted = true;
      const values = this.form.value;
      const payload = Object.assign({
        items: []
      }, this.navmap, {
        name: values.name
      });
      // console.log('NavmapEditComponent.onSubmit.navmap', payload);
      NavmapService.navmapUpdate$(payload).pipe(operators.first()).subscribe(response => {
        // console.log('NavmapEditComponent.onSubmit.success', response);
        Object.assign(this.navmap, response);
        this.pushChanges();
      }, error => {
        // console.log('NavmapEditComponent.onSubmit.error', error);
        this.error = error;
        this.form.reset();
      });
    } else {
      this.form.touched = true;
    }
  }
  onRemove() {
    const navmap = this.navmap;
    ModalService.open$({
      template: RemoveModalComponent.chunk(),
      data: {
        item: navmap
      }
    }).pipe(operators.first()).subscribe(event => {
      if (event instanceof ModalResolveEvent) {
        NavmapService.navmapDelete$(navmap).pipe(operators.first()).subscribe(response => {
          this.delete.next(navmap);
        });
      }
    });
  }
}
NavmapEditComponent.meta = {
  selector: '[navmap-edit]',
  outputs: ['delete'],
  inputs: ['navmap']
};class UpdateViewItemComponent extends rxcomp.Component {
  onInit() {
    this.busy = false;
    this.active = false;
    this.useHooks = WebhookService.enabled;
    const form = this.form = new rxcompForm.FormGroup();
    this.controls = form.controls;
    const item = this.item;
    this.originalItem = Object.assign({}, item);
    item.hasChromaKeyColor = item.asset && item.asset.chromaKeyColor ? true : false;
    item.autoplay = item.asset && item.asset.type.name === AssetType.Video.name ? item.asset.autoplay : undefined;
    item.loop = item.asset && item.asset.type.name === AssetType.Video.name ? item.asset.loop : undefined;
    item.assetType = assetGroupTypeFromItem(item).id;
    this.doUpdateForm();
    form.changes$.subscribe(changes => {
      // console.log('UpdateViewItemComponent.form.changes$', changes);
      this.doUpdateItem(changes);
      this.pushChanges();
    });
  }
  getFlagsDidChange(item, changes) {
    const flags = ['hasChromaKeyColor', 'autoplay', 'loop'];
    return flags.reduce((p, c) => {
      const a = changes[c] || false;
      const b = item[c] || false;
      // console.log(c, a, b);
      return p || a !== b;
    }, false);
  }
  getAssetDidChange(item, changes) {
    // console.log('UpdateViewItemComponent.getAssetDidChange', item.asset, changes.asset);
    return AssetService.assetDidChange(item.asset, changes.asset);
  }
  doUpdateItem(changes) {
    const item = this.item;
    const assetDidChange = this.getAssetDidChange(item, changes);
    const flagsDidChange = this.getFlagsDidChange(item, changes);
    // console.log('UpdateViewItemCompoent.doUpdateItem', 'assetDidChange', assetDidChange, 'flagsDidChange', flagsDidChange);
    Object.assign(item, changes);
    if (item.asset) {
      item.asset.chromaKeyColor = item.hasChromaKeyColor ? [0.0, 1.0, 0.0] : null;
      item.asset.autoplay = item.autoplay;
      item.asset.loop = item.loop;
    }
    if (assetDidChange || flagsDidChange) {
      const asset$ = item.asset ? AssetService.assetUpdate$(item.asset) : rxjs.of(null);
      asset$.pipe(operators.switchMap(() => EditorService.inferItemUpdate$(this.view, item)), operators.first()).subscribe();
      // !!! create indices for nextAttendeeStream
      this.view.updateIndices(this.view.items);
      if (typeof item.onUpdateAsset === 'function') {
        item.onUpdateAsset();
      }
    }
    if (typeof item.onUpdate === 'function') {
      item.onUpdate();
    }
  }
  doUpdateForm() {
    const item = this.item;
    const form = this.form;
    if (!this.type || this.type.name !== item.type.name) {
      this.type = item.type;
      Object.keys(this.controls).forEach(key => {
        form.removeKey(key);
      });
      let keys;
      switch (item.type.name) {
        case ViewItemType.Nav.name:
          if (this.useHooks) {
            keys = ['id', 'type', 'title?', 'abstract?', 'viewId?', 'hook?', 'hookExtra?', 'keepOrientation?', 'important?', 'transparent?', 'position', 'rotation', 'scale', 'asset?', 'link?', 'links?'];
          } else {
            keys = ['id', 'type', 'title?', 'abstract?', 'viewId?', 'keepOrientation?', 'important?', 'transparent?', 'position', 'rotation', 'scale', 'asset?', 'link?', 'links?'];
          }
          break;
        case ViewItemType.Plane.name:
          keys = ['id', 'type', 'position', 'rotation', 'scale', 'assetType?', 'asset?', 'hasChromaKeyColor?', 'autoplay?', 'loop?'];
          break;
        case ViewItemType.CurvedPlane.name:
          keys = ['id', 'type', 'position', 'rotation', 'scale', 'radius', 'height', 'arc', 'assetType?', 'asset?', 'hasChromaKeyColor?', 'autoplay?', 'loop?'];
          break;
        case ViewItemType.Texture.name:
          keys = ['id', 'type', 'assetType?', 'asset?', 'hasChromaKeyColor?', 'autoplay?', 'loop?']; // asset, key no id!!
          break;
        case ViewItemType.Model.name:
          if (this.view.type.name === ViewType.Model) {
            keys = ['id', 'type', 'asset?'];
          } else {
            keys = ['id', 'type', 'position', 'rotation', 'asset?'];
          }
          break;
        default:
          keys = ['id', 'type'];
      }
      keys.forEach(key => {
        const optional = key.indexOf('?') !== -1;
        key = key.replace('?', '');
        const value = item[key] != null ? item[key] : null;
        let control;
        switch (key) {
          case 'viewId':
            control = new rxcompForm.FormControl(value, optional ? undefined : rxcompForm.RequiredValidator());
            EditorService.viewIdOptions$().pipe(operators.first()).subscribe(options => {
              control.options = options;
              control.value = control.value || null;
              this.pushChanges();
            });
            break;
          case 'hook':
            control = new rxcompForm.FormControl(value, optional ? undefined : rxcompForm.RequiredValidator());
            if (WebhookService.enabled) {
              const options = environment.webhook.methods.nav.map(x => ({
                id: x,
                name: x
              }));
              options.unshift({
                id: null,
                name: 'select'
              });
              control.options = options;
            }
            control.value = control.value || null;
            this.pushChanges();
            break;
          case 'assetType':
            control = new rxcompForm.FormControl(value, optional ? undefined : rxcompForm.RequiredValidator());
            control.options = Object.keys(AssetGroupType).map(x => AssetGroupType[x]);
            // console.log(control.options);
            break;
          case 'link':
            /*
            const title = item.link ? item.link.title : null;
            const href = item.link ? item.link.href : null;
            const target = '_blank';
            control = new FormGroup({
            	title: new FormControl(title),
            	href: new FormControl(href),
            	target
            });
            */
            break;
          case 'links':
            {
              const links = item.links;
              control = new rxcompForm.FormArray(links.map(link => new rxcompForm.FormGroup({
                title: new rxcompForm.FormControl(link.title),
                href: new rxcompForm.FormControl(link.href),
                target: '_blank'
              })));
              break;
            }
          default:
            control = new rxcompForm.FormControl(value, optional ? undefined : rxcompForm.RequiredValidator());
        }
        form.add(control, key);
      });
      this.controls = form.controls;
    } else {
      Object.keys(this.controls).forEach(key => {
        switch (key) {
          case 'link':
            /*
            const title = item.link ? item.link.title : null;
            const href = item.link ? item.link.href : null;
            const target = '_blank';
            this.controls[key].value = { title, href, target };
            */
            break;
          case 'links':
            {
              const links = item.links.map(link => ({
                title: link.title || null,
                href: link.href || null,
                target: '_blank'
              }));
              const formArray = this.controls[key];
              while (formArray.controls.length > links.length) {
                formArray.remove(formArray.controls[formArray.controls.length - 1]);
              }
              while (formArray.controls.length < links.length) {
                formArray.push(new rxcompForm.FormGroup({
                  title: new rxcompForm.FormControl(null),
                  href: new rxcompForm.FormControl(null),
                  target: '_blank'
                }));
              }
              // console.log(formArray, links);
              formArray.patch(links);
              break;
            }
          case 'hasChromaKeyColor':
            this.controls[key].value = item.asset && item.asset.chromaKeyColor ? true : false;
            break;
          case 'autoplay':
            this.controls[key].value = item.asset && item.asset.autoplay ? true : false;
            break;
          case 'loop':
            this.controls[key].value = item.asset && item.asset.loop ? true : false;
            break;
          case 'assetType':
            this.controls[key].value = assetGroupTypeFromItem(item).id;
            break;
          default:
            this.controls[key].value = item[key] != null ? item[key] : null;
        }
      });
    }
  }
  onAssetTypeDidChange(assetType) {
    const item = this.item;
    const currentType = assetGroupTypeFromItem(item).id;
    // console.log('UpdateViewItemComponent.onAssetTypeDidChange', assetType, currentType);
    if (assetType !== currentType) {
      item.assetType = assetType;
      let asset$ = rxjs.of(null); // AssetService.assetDelete$(item.asset);
      if (assetType !== AssetGroupType.ImageOrVideo.id) {
        asset$ = asset$.pipe(operators.switchMap(() => {
          const asset = assetPayloadFromGroupTypeId(assetType);
          return AssetService.assetCreate$(asset);
        }));
      }
      asset$.pipe(operators.first()).subscribe(asset => {
        // console.log('UpdateViewItemComponent.asset$', asset);
        this.controls.asset.value = asset;
      });
      /*
      asset$.pipe(
      	tap(asset => {
      		item.asset = asset;
      		if (typeof item.onUpdateAsset === 'function') {
      			item.onUpdateAsset();
      		}
      	}),
      	switchMap(() => EditorService.inferItemUpdate$(this.view, item)),
      	first()
      ).subscribe();
      */
    }
  }

  onChanges(changes) {
    // console.log('UpdateViewItemComponent.onChanges', changes);
    this.doUpdateForm();
  }
  onSubmit() {
    if (!this.busy && this.form.valid) {
      this.busy = true;
      this.pushChanges();
      const changes = this.form.value;
      const payload = Object.assign({}, changes);
      if (this.item.type.name === ViewItemType.Nav.name) {
        payload.viewId = payload.viewId || this.view.id;
      }
      const view = this.view;
      const item = new ViewItem(payload);
      EditorService.inferItemUpdate$(view, item).pipe(operators.first()).subscribe(response => {
        // console.log('UpdateViewItemComponent.onSubmit.inferItemUpdate$.success', response);
        EditorService.inferItemUpdateResult$(view, item);
        this.update.next({
          view,
          item
        });
        this.setTimeout(() => {
          this.busy = false;
          this.pushChanges();
        });
      }, error => console.log('UpdateViewItemComponent.onSubmit.inferItemUpdate$.error', error));
      // this.update.next({ view: this.view, item: new ViewItem(payload) });
    } else {
      this.form.touched = true;
    }
  }
  onRemove(event) {
    ModalService.open$({
      template: RemoveModalComponent.chunk(),
      data: {
        item: this.item
      }
    }).pipe(operators.first()).subscribe(event => {
      if (event instanceof ModalResolveEvent) {
        this.delete.next({
          view: this.view,
          item: this.item
        });
      }
    });
  }
  onSelect(event) {
    this.select.next({
      view: this.view,
      item: this.item.selected ? null : this.item
    });
    /*
    this.item.active = !this.item.active;
    this.pushChanges();
    */
  }

  getTitle(item) {
    return LabelPipe.getKeys('editor', item.type.name);
  }
  onAddLink(event) {
    this.controls.links.push(new rxcompForm.FormGroup({
      title: new rxcompForm.FormControl(null),
      href: new rxcompForm.FormControl(null),
      target: '_blank'
    }));
  }
  onRemoveLink(item) {
    this.controls.links.remove(item);
  }
  clearTimeout() {
    if (this.to) {
      clearTimeout(this.to);
    }
  }
  setTimeout(callback, msec) {
    if (msec === void 0) {
      msec = 300;
    }
    this.clearTimeout();
    if (typeof callback === 'function') {
      this.to = setTimeout(callback, msec);
    }
  }
  onDestroy() {
    this.clearTimeout();
  }
}
UpdateViewItemComponent.meta = {
  selector: 'update-view-item',
  outputs: ['select', 'update', 'delete'],
  inputs: ['view', 'item'],
  template: /* html */`
		<div class="group--headline" [class]="{ active: item.selected }" (click)="onSelect($event)">
			<!-- <div class="id" [innerHTML]="item.id"></div> -->
			<div class="icon">
				<svg-icon [name]="item.type.name"></svg-icon>
			</div>
			<div class="title" [innerHTML]="getTitle(item)"></div>
			<svg class="icon--caret-down"><use xlink:href="#caret-down"></use></svg>
		</div>
		<form [formGroup]="form" (submit)="onSubmit()" name="form" role="form" novalidate autocomplete="off" *if="item.selected">
			<div class="form-controls">
				<div control-text [control]="controls.id" label="Id" [disabled]="true"></div>
				<!-- <div control-text [control]="controls.type" label="Type" [disabled]="true"></div> -->
			</div>
			<div class="form-controls" *if="item.type.name == 'nav'">
				<div control-text [control]="controls.title" label="Title"></div>
				<div control-textarea [control]="controls.abstract" label="Abstract"></div>
				<div control-custom-select [control]="controls.viewId" label="NavToView"></div>
				<div control-checkbox [control]="controls.keepOrientation" label="Keep Orientation"></div>
				<div control-checkbox [control]="controls.important" label="Important"></div>
				<div control-checkbox [control]="controls.transparent" label="Transparent"></div>
				<div control-vector [control]="controls.position" label="Position" [precision]="3"></div>
				<div *if="controls.transparent.value == true">
					<div control-vector [control]="controls.rotation" label="Rotation" [precision]="3" [increment]="Math.PI / 360"></div>
					<div control-vector [control]="controls.scale" label="Scale" [precision]="2"></div>
				</div>
				<div control-localized-asset [control]="controls.asset" label="Image" accept="image/jpeg, image/png"></div>

				<div class="group--link" *for="let link of controls.links.controls">
					<div class="group--controls">
						<div control-text [control]="link.controls.title" label="Link Title"></div>
						<div control-text [control]="link.controls.href" label="Link Url"></div>
					</div>
					<button type="button" class="btn--remove" (click)="onRemoveLink(link)"><svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#remove"></use></svg></button>
				</div>

				<div class="group--cta">
					<button type="button" class="btn--update" (click)="onAddLink($event)">
						<span>Add Link</span>
					</button>
				</div>

				<div *if="useHooks">
					<div control-custom-select [control]="controls.hook" label="Hook"></div>
					<div control-text [control]="controls.hookExtra" label="Hook Extra"></div>
				</div>
			</div>
			<div class="form-controls" *if="item.type.name == 'plane' && view.type.name != 'media'">
				<div control-vector [control]="controls.position" label="Position" [precision]="2"></div>
				<div control-vector [control]="controls.rotation" label="Rotation" [precision]="3" [increment]="Math.PI / 360"></div>
				<div control-vector [control]="controls.scale" label="Scale" [precision]="2"></div>
				<div control-custom-select [control]="controls.assetType" label="Asset" (change)="onAssetTypeDidChange($event)"></div>
				<div control-localized-asset [control]="controls.asset" label="Localized Image or Video" accept="image/jpeg, video/mp4" *if="controls.assetType.value == 1"></div>
				<div control-checkbox [control]="controls.hasChromaKeyColor" label="Use Green Screen" *if="item.asset"></div>
				<div control-checkbox [control]="controls.autoplay" label="Autoplay" *if="item.asset && item.asset.type.name === 'video'"></div>
				<div control-checkbox [control]="controls.loop" label="Loop" *if="item.asset && item.asset.type.name === 'video'"></div>
			</div>
			<div class="form-controls" *if="item.type.name == 'plane' && view.type.name == 'media'">
				<div control-vector [control]="controls.scale" label="Scale" [precision]="2"></div>
				<div control-localized-asset [control]="controls.asset" label="Localized Image or Video" accept="image/jpeg, video/mp4"></div>
				<div control-checkbox [control]="controls.autoplay" label="Autoplay" *if="item.asset && item.asset.type.name === 'video'"></div>
				<div control-checkbox [control]="controls.loop" label="Loop" *if="item.asset && item.asset.type.name === 'video'"></div>
			</div>
			<div class="form-controls" *if="item.type.name == 'curved-plane'">
				<div control-vector [control]="controls.position" label="Position" [precision]="2"></div>
				<div control-vector [control]="controls.rotation" label="Rotation" [precision]="3" [increment]="Math.PI / 360"></div>
				<!-- <div control-vector [control]="controls.scale" label="Scale" [precision]="2" [disabled]="true"></div> -->
				<div control-number [control]="controls.radius" label="Radius" [precision]="2"></div>
				<div control-number [control]="controls.height" label="Height" [precision]="2"></div>
				<div control-number [control]="controls.arc" label="Arc" [precision]="0"></div>
				<div control-custom-select [control]="controls.assetType" label="Asset" (change)="onAssetTypeDidChange($event)"></div>
				<div control-localized-asset [control]="controls.asset" label="Image or Video" accept="image/jpeg, video/mp4" *if="controls.assetType.value == 1"></div>
				<div control-checkbox [control]="controls.hasChromaKeyColor" label="Use Green Screen" *if="item.asset"></div>
				<div control-checkbox [control]="controls.autoplay" label="Autoplay" *if="item.asset && item.asset.type.name === 'video'"></div>
				<div control-checkbox [control]="controls.loop" label="Loop" *if="item.asset && item.asset.type.name === 'video'"></div>
			</div>
			<div class="form-controls" *if="item.type.name == 'texture'">
				<div control-custom-select [control]="controls.assetType" label="Asset" (change)="onAssetTypeDidChange($event)"></div>
				<div control-localized-asset [control]="controls.asset" label="Image or Video" accept="image/jpeg, video/mp4" *if="controls.assetType.value == 1"></div>
				<div control-checkbox [control]="controls.hasChromaKeyColor" label="Use Green Screen" *if="item.asset"></div>
				<div control-checkbox [control]="controls.autoplay" label="Autoplay" *if="item.asset && item.asset.type.name === 'video'"></div>
				<div control-checkbox [control]="controls.loop" label="Loop" *if="item.asset && item.asset.type.name === 'video'"></div>
			</div>
			<div class="form-controls" *if="item.type.name == 'model'">
				<div control-vector [control]="controls.position" label="Position" [precision]="2" *if="view.type.name !== 'model'"></div>
				<div control-vector [control]="controls.rotation" label="Rotation" [precision]="3" [increment]="Math.PI / 360" *if="view.type.name !== 'model'"></div>
				<div control-model [control]="controls.asset" label="Model (.glb)" accept=".glb"></div>
			</div>
			<div class="group--cta">
				<button type="submit" class="btn--update" [class]="{ busy: busy }">
					<span [innerHTML]="'update' | label"></span>
				</button>
				<button type="button" class="btn--remove" (click)="onRemove($event)">
					<span [innerHTML]="'remove' | label"></span>
				</button>
			</div>
		</form>
	`
};class UpdateViewTileComponent extends rxcomp.Component {
  onInit() {
    this.busy = false;
    this.active = false;
    const form = this.form = new rxcompForm.FormGroup({
      id: new rxcompForm.FormControl(this.tile.id, rxcompForm.RequiredValidator()),
      asset: new rxcompForm.FormControl(this.tile.asset, rxcompForm.RequiredValidator()),
      navs: new rxcompForm.FormControl(this.tile.navs, rxcompForm.RequiredValidator())
    });
    this.controls = form.controls;
    form.changes$.subscribe(changes => {
      // console.log('UpdateViewTileComponent.form.changes$', changes);
      const tile = this.tile;
      Object.assign(tile, changes);
      if (typeof tile.onUpdate === 'function') {
        tile.onUpdate();
      }
      this.pushChanges();
    });
    // console.log('UpdateViewTileComponent.onInit', this.view, this.tile);
  }

  onSubmit() {
    if (!this.busy && this.form.valid) {
      this.busy = true;
      this.pushChanges();
      const payload = Object.assign({}, this.form.value);
      const view = this.view;
      const tile = payload;
      /*
      EditorService.tileUpdate$...
      */
      this.update.next({
        view,
        tile
      });
      this.setTimeout(() => {
        this.busy = false;
        this.pushChanges();
      });
    } else {
      this.form.touched = true;
    }
  }
  onRemove(event) {
    ModalService.open$({
      template: RemoveModalComponent.chunk(),
      data: {
        tile: this.tile
      }
    }).pipe(operators.first()).subscribe(event => {
      if (event instanceof ModalResolveEvent) {
        this.delete.next({
          view: this.view,
          tile: this.tile
        });
      }
    });
  }
  onSelect(event) {
    this.select.next({
      view: this.view,
      tile: this.tile.selected ? null : this.tile
    });
  }
  clearTimeout() {
    if (this.to) {
      clearTimeout(this.to);
    }
  }
  setTimeout(callback, msec) {
    if (msec === void 0) {
      msec = 300;
    }
    this.clearTimeout();
    if (typeof callback === 'function') {
      this.to = setTimeout(callback, msec);
    }
  }
  onDestroy() {
    this.clearTimeout();
  }
}
UpdateViewTileComponent.meta = {
  selector: 'update-view-tile',
  outputs: ['select', 'update', 'delete'],
  inputs: ['view', 'tile'],
  template: /* html */`
		<div class="group--headline" [class]="{ active: tile.selected }" (click)="onSelect($event)">
			<div class="icon">
				<svg-icon name="tile"></svg-icon>
			</div>
			<div class="title">Tile {{tile.id}}</div>
			<svg class="icon--caret-down"><use xlink:href="#caret-down"></use></svg>
		</div>
		<form [formGroup]="form" (submit)="onSubmit()" name="form" role="form" novalidate autocomplete="off" *if="tile.selected">
			<div class="form-controls">
				<div control-text [control]="controls.id" label="Id" [disabled]="true"></div>
				<div control-asset [control]="controls.asset" label="Image" accept="image/jpeg, image/png"></div>
			</div>
			<div class="group--cta">
				<button type="submit" class="btn--update" [class]="{ busy: busy }">
					<span [innerHTML]="'update' | label"></span>
				</button>
				<!--
				<button type="button" class="btn--remove" (click)="onRemove($event)">
					<span [innerHTML]="'remove' | label"></span>
				</button>
				-->
			</div>
		</form>
	`
};class UpdateViewComponent extends rxcomp.Component {
  onInit() {
    this.busy = false;
    const form = this.form = new rxcompForm.FormGroup();
    this.controls = form.controls;
    this.doUpdateForm();
    form.changes$.subscribe(changes => {
      // console.log('UpdateViewComponent.form.changes$', changes);
      this.doUpdateView(changes);
      this.pushChanges();
    });
    this.orbit$().pipe(operators.takeUntil(this.unsubscribe$)).subscribe(message => {
      switch (this.view.type.name) {
        case ViewType.WaitingRoom.name:
        case ViewType.Panorama.name:
        case ViewType.PanoramaGrid.name:
        case ViewType.Room3d.name:
        case ViewType.Model.name:
        case ViewType.Media.name:
          this.form.patch({
            latitude: message.orientation.latitude,
            longitude: message.orientation.longitude,
            zoom: message.zoom
          });
          break;
      }
    });
  }
  orbit$() {
    let latitude,
      longitude,
      zoom = null;
    return MessageService.in$.pipe(operators.filter(message => message.type === MessageType.ControlInfo), operators.auditTime(Math.floor(1000 / 15)), operators.distinctUntilChanged((previous, current) => {
      const didChange = latitude !== current.orientation.latitude || longitude !== current.orientation.longitude || zoom !== current.zoom;
      latitude = current.orientation.latitude;
      longitude = current.orientation.longitude;
      zoom = current.zoom;
      return !didChange;
    }));
  }
  getAssetDidChange(changes) {
    const view = this.view;
    if (view.type.name === ViewType.PanoramaGrid.name) {
      return false;
    }
    const assetDidChange = AssetService.assetDidChange(view.asset, changes.asset);
    const usdzDidChange = AssetService.assetDidChange(view.ar ? view.ar.usdz : null, changes.usdz);
    const gltfDidChange = AssetService.assetDidChange(view.ar ? view.ar.gltf : null, changes.gltf);
    if (assetDidChange || usdzDidChange || gltfDidChange) {
      // console.log('UpdateViewComponent.getAssetDidChange', assetDidChange, usdzDidChange, gltfDidChange);
      return true;
    } else {
      return false;
    }
  }
  doUpdateView(changes) {
    const assetDidChange = this.getAssetDidChange(changes);
    // console.log('doUpdateItem.assetDidChange', assetDidChange);
    if (assetDidChange) {
      this.onSubmit();
    }
  }
  doUpdateForm() {
    const view = this.view;
    if (!this.type || this.type.name !== view.type.name) {
      this.type = view.type;
      const form = this.form;
      Object.keys(this.controls).forEach(key => {
        form.removeKey(key);
      });
      let keys;
      switch (view.type.name) {
        case ViewType.WaitingRoom.name:
          keys = ['id', 'type', 'name', 'latitude', 'longitude', 'zoom', 'asset'];
          break;
        case ViewType.Panorama.name:
          keys = ['id', 'type', 'name', 'hidden?', 'latitude', 'longitude', 'zoom', 'asset'];
          break;
        case ViewType.PanoramaGrid.name:
          keys = ['id', 'type', 'name', 'hidden?', 'latitude', 'longitude', 'zoom'];
          break;
        case ViewType.Room3d.name:
          keys = ['id', 'type', 'name', 'hidden?', 'latitude', 'longitude', 'zoom', 'asset'];
          break;
        case ViewType.Model.name:
          keys = ['id', 'type', 'name', 'hidden?', 'latitude', 'longitude', 'zoom', 'asset'];
          break;
        case ViewType.Media.name:
          keys = ['id', 'type', 'name', 'hidden?', 'asset'];
          break;
        default:
          keys = ['id', 'type', 'name'];
      }
      if (view.type.name !== ViewType.WaitingRoom.name && environment.flags.ar) {
        keys.push('usdz?');
        keys.push('gltf?');
      }
      keys.forEach(key => {
        const optional = key.indexOf('?') !== -1;
        key = key.replace('?', '');
        switch (key) {
          case 'latitude':
          case 'longitude':
            {
              const orientation = view.orientation || {
                latitude: 0,
                longitude: 0
              };
              form.add(new rxcompForm.FormControl(orientation[key], rxcompForm.RequiredValidator()), key);
              break;
            }
          case 'usdz':
          case 'gltf':
            {
              form.add(new rxcompForm.FormControl(view.ar ? view.ar[key] || null : null, optional ? undefined : rxcompForm.RequiredValidator()), key);
              break;
            }
          default:
            {
              form.add(new rxcompForm.FormControl(view[key] != null ? view[key] : null, optional ? undefined : rxcompForm.RequiredValidator()), key);
            }
        }
      });
      this.controls = form.controls;
    }
  }
  onChanges(changes) {
    // console.log('UpdateViewComponent.onChanges');
    this.doUpdateForm();
  }
  onSubmit() {
    if (!this.busy && this.form.valid) {
      this.busy = true;
      this.pushChanges();
      const payload = Object.assign({}, this.form.value);
      if (payload.latitude != null) {
        // !!! keep loose inequality
        payload.orientation = {
          latitude: payload.latitude,
          longitude: payload.longitude
        };
        delete payload.latitude;
        delete payload.longitude;
      }
      const usdz = payload.usdz || null;
      const gltf = payload.gltf || null;
      delete payload.usdz;
      delete payload.gltf;
      payload.ar = usdz || gltf ? {
        usdz,
        gltf
      } : null;
      const view = new View(Object.assign({}, this.view, payload));
      /*
      let dataView = Object.assign({}, ViewService.getDataView(this.view.id), payload);
      dataView = new View(dataView);
      let pathView = Object.assign({}, this.view, payload);
      pathView = new View(pathView);
      */
      EditorService.viewUpdate$(view).pipe(operators.first()).subscribe(response => {
        // console.log('UpdateViewComponent.onSubmit.viewUpdate$.success', response);
        this.update.next({
          view: view
        });
        this.setTimeout(() => {
          this.busy = false;
          this.pushChanges();
        });
      }, error => console.log('UpdateViewComponent.onSubmit.viewUpdate$.error', error));
      // this.update.next({ view: new View(payload) });
    } else {
      this.form.touched = true;
    }
  }
  onRemove(event) {
    ModalService.open$({
      template: RemoveModalComponent.chunk(),
      data: {
        item: this.item
      }
    }).pipe(operators.first()).subscribe(event => {
      if (event instanceof ModalResolveEvent) {
        this.delete.next({
          view: this.view
        });
      }
    });
  }
  onSelect(event) {
    this.select.next({
      view: this.view.selected ? null : this.view
    });
  }
  getTitle(view) {
    return LabelPipe.getKeys('editor', view.type.name);
  }
  clearTimeout() {
    if (this.to) {
      clearTimeout(this.to);
    }
  }
  setTimeout(callback, msec) {
    if (msec === void 0) {
      msec = 300;
    }
    this.clearTimeout();
    if (typeof callback === 'function') {
      this.to = setTimeout(callback, msec);
    }
  }
  onDestroy() {
    this.clearTimeout();
  }
}
UpdateViewComponent.meta = {
  selector: 'update-view',
  outputs: ['select', 'update', 'delete'],
  inputs: ['view'],
  template: /* html */`
		<div class="group--headline" [class]="{ active: view.selected }" (click)="onSelect($event)">
			<!-- <div class="id" [innerHTML]="view.id"></div> -->
			<div class="icon">
				<svg-icon [name]="view.type.name"></svg-icon>
			</div>
			<div class="title" [innerHTML]="getTitle(view)"></div>
			<svg class="icon--caret-down"><use xlink:href="#caret-down"></use></svg>
		</div>
		<form [formGroup]="form" (submit)="onSubmit()" name="form" role="form" novalidate autocomplete="off" *if="view.selected">
			<div class="form-controls">
				<div control-text [control]="controls.id" label="Id" [disabled]="true"></div>
				<!-- <div control-text [control]="controls.type" label="Type" [disabled]="true"></div> -->
				<div control-text [control]="controls.name" label="Name"></div>
			</div>
			<div class="form-controls" *if="view.type.name == 'waiting-room'">
				<div control-localized-asset [control]="controls.asset" label="Image" accept="image/jpeg"></div>
				<div control-text [control]="controls.latitude" label="Latitude" [disabled]="true"></div>
				<div control-text [control]="controls.longitude" label="Longitude" [disabled]="true"></div>
				<div control-text [control]="controls.zoom" label="Zoom" [disabled]="true"></div>
			</div>
			<div class="form-controls" *if="view.type.name == 'panorama'">
				<div control-checkbox [control]="controls.hidden" label="Hide from menu"></div>
				<div control-localized-asset [control]="controls.asset" label="Image or Video" accept="image/jpeg, video/mp4"></div>
				<div control-text [control]="controls.latitude" label="Latitude" [disabled]="true"></div>
				<div control-text [control]="controls.longitude" label="Longitude" [disabled]="true"></div>
				<div control-text [control]="controls.zoom" label="Zoom" [disabled]="true"></div>
			</div>
			<div class="form-controls" *if="view.type.name == 'panorama-grid'">
				<div control-checkbox [control]="controls.hidden" label="Hide from menu"></div>
				<div control-text [control]="controls.latitude" label="Latitude" [disabled]="true"></div>
				<div control-text [control]="controls.longitude" label="Longitude" [disabled]="true"></div>
				<div control-text [control]="controls.zoom" label="Zoom" [disabled]="true"></div>
			</div>
			<div class="form-controls" *if="view.type.name == 'room-3d'">
				<div control-checkbox [control]="controls.hidden" label="Hide from menu"></div>
				<div control-model [control]="controls.asset" label="Model (.glb)" accept=".glb"></div>
				<div control-text [control]="controls.latitude" label="Latitude" [disabled]="true"></div>
				<div control-text [control]="controls.longitude" label="Longitude" [disabled]="true"></div>
				<div control-text [control]="controls.zoom" label="Zoom" [disabled]="true"></div>
			</div>
			<div class="form-controls" *if="view.type.name == 'model'">
				<div control-checkbox [control]="controls.hidden" label="Hide from menu"></div>
				<div control-localized-asset [control]="controls.asset" label="Image" accept="image/jpeg"></div>
				<div control-text [control]="controls.latitude" label="Latitude" [disabled]="true"></div>
				<div control-text [control]="controls.longitude" label="Longitude" [disabled]="true"></div>
				<div control-text [control]="controls.zoom" label="Zoom" [disabled]="true"></div>
			</div>
			<div class="form-controls" *if="view.type.name != 'waiting-room' && ('ar' | flag)">
				<div control-model [control]="controls.usdz" label="AR IOS (.usdz)" accept=".usdz"></div>
				<div control-model [control]="controls.gltf" label="AR Android (.glb)" accept=".glb"></div>
			</div>
			<div class="group--cta">
				<button type="submit" class="btn--update" [class]="{ busy: busy }">
					<span [innerHTML]="'update' | label"></span>
				</button>
				<button type="button" class="btn--remove" *if="view.type.name != 'waiting-room'" (click)="onRemove($event)">
					<span [innerHTML]="'remove' | label"></span>
				</button>
			</div>
		</form>
	`
};const factories = [AsideComponent, CurvedPlaneModalComponent, EditorComponent, ItemModelModalComponent, NavmapBuilderComponent, NavmapEditComponent, NavmapModalComponent, NavmapItemModalComponent, MediaModalComponent, MenuBuilderComponent, ModelModalComponent, NavModalComponent, PanoramaModalComponent, PanoramaGridModalComponent, PathAddModalComponent, PathEditModalComponent, PlaneModalComponent, RemoveModalComponent, Room3DModalComponent, ToastOutletComponent, UpdateViewItemComponent, UpdateViewTileComponent, UpdateViewComponent];
const pipes = [];
class EditorModule extends rxcomp.Module {}
EditorModule.meta = {
  imports: [],
  declarations: [...factories, ...pipes],
  exports: [...factories, ...pipes]
};class IframeModalComponent extends rxcomp.Component {
  onClose() {
    ModalService.reject();
  }
}
IframeModalComponent.meta = {
  selector: '[iframe-modal]',
  inputs: ['src'],
  template: /* html */`
		<div class="modal__header">
			<button type="button" class="btn--close" (click)="onClose()">
				<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#close"></use></svg>
			</button>
		</div>
		<div class="modal__content">
			<iframe [src]="src"></iframe>
		</div>
	`
};
IframeModalComponent.chunk = src => /* html */`<div class="iframe-modal" iframe-modal src="${src}"></div>`;class EnvPipe extends rxcomp.Pipe {
  static transform(keypath) {
    let env = environment;
    const keys = keypath.split('.');
    let k = keys.shift();
    while (keys.length > 0 && env[k]) {
      env = env[k];
      k = keys.shift();
    }
    const value = env[k] || null;
    return value;
  }
}
EnvPipe.meta = {
  name: 'env'
};class FlagPipe extends rxcomp.Pipe {
  static transform(key) {
    const flags = environment.flags;
    return flags[key] || false;
  }
}
FlagPipe.meta = {
  name: 'flag'
};class UploadItem {
  constructor(file) {
    this.file = file;
    this.name = file.name;
    this.type = assetTypeFromPath(file.name);
    this.progress = 0;
    this.size = file.size;
    this.uploading = false;
    this.paused = false;
    this.success = false;
    this.complete = false;
    this.error = null;
    this.preview = null;
  }
}
class UploadEvent {
  constructor(options) {
    if (options) {
      Object.assign(this, options);
    }
  }
}
class UploadStartEvent extends UploadEvent {}
class UploadCompleteEvent extends UploadEvent {}
class UploadAssetEvent extends UploadEvent {}
class UploadService {
  constructor() {
    this.concurrent$ = new rxjs.BehaviorSubject(0);
    this.items$ = new rxjs.BehaviorSubject([]);
    this.events$ = new rxjs.ReplaySubject(1);
  }
  upload$() {
    const items = this.items$.getValue();
    const uploadItems = items.filter(item => !item.uploading);
    return rxjs.combineLatest(uploadItems.map(item => this.uploadItem$(item)));
  }
  uploadItem$(item) {
    // max 4 concurrent upload
    item.uploading = true;
    this.events$.next(new UploadStartEvent({
      item
    }));
    const files = [item.file];
    return rxjs.of(files).pipe(operators.delayWhen(() => this.concurrent$.pipe(operators.filter(x => x < 4))), operators.tap(() => this.concurrent$.next(this.concurrent$.getValue() + 1)), operators.first(), operators.switchMap(files => AssetService.upload$(files)), operators.switchMap(uploads => {
      const upload = uploads[0];
      item.uploading = false;
      item.complete = true;
      const asset = Asset.fromUrl(upload.url);
      this.events$.next(new UploadCompleteEvent({
        item,
        asset
      }));
      return AssetService.assetCreate$(asset).pipe(operators.tap(asset => {
        this.remove(item);
        this.events$.next(new UploadAssetEvent({
          item,
          asset
        }));
        this.concurrent$.next(this.concurrent$.getValue() - 1);
      }));
    }));
    /*
    // concurrent upload
    return AssetService.upload$([item.file]).pipe(
    	switchMap((uploads) => {
    		const upload = uploads[0];
    		item.uploading = false;
    		item.complete = true;
    		const asset = Asset.fromUrl(upload.url);
    		this.events$.next(new UploadCompleteEvent({ item, asset }));
    		return AssetService.assetCreate$(asset).pipe(
    			tap(asset => {
    				this.remove(item);
    				this.events$.next(new UploadAssetEvent({ item, asset }));
    			}),
    		);
    	}),
    );
    */
  }

  addItems(files) {
    if (files && files.length) {
      // console.log('addItems', files);
      const items = this.items$.getValue();
      const newItems = Array.from(files).map(file => new UploadItem(file));
      items.push(...newItems);
      this.items$.next(items);
    }
  }
  remove(item) {
    const items = this.items$.getValue();
    const index = items.indexOf(item);
    if (index !== -1) {
      items.splice(index, 1);
    }
    this.items$.next(items);
  }
  removeAll() {
    // !!!
    this.items$.next([]);
  }
  drop$(input, dropArea) {
    if (rxcomp.isPlatformBrowser && input) {
      dropArea = dropArea || input;
      const body = document.querySelector('body');
      return rxjs.merge(rxjs.fromEvent(body, 'drop'), rxjs.fromEvent(body, 'dragover')).pipe(operators.map(event => {
        // console.log('UploadService.drop$', event);
        event.preventDefault();
        if (event.target === dropArea) {
          this.addItems(event.dataTransfer.files);
        }
        return this.items$;
      }));
    } else {
      return rxjs.EMPTY;
    }
  }
  change$(input) {
    if (rxcomp.isPlatformBrowser && input) {
      return rxjs.fromEvent(input, 'change').pipe(operators.switchMap(event => {
        if (input.files.length) {
          this.addItems(input.files);
          input.value = '';
        }
        return this.items$;
      }));
    } else {
      return rxjs.EMPTY;
    }
  }
  files$(files) {
    return rxjs.combineLatest(Array.from(files).map((file, i) => this.file$(file, i)));
  }
  file$(file, i) {
    return this.read$(file, i).pipe(operators.switchMap(() => this.uploadFile$(file)));
  }

  /*
  static files$(files) {
  	const fileArray = Array.from(files);
  	this.previews = fileArray.map(() => null);
  	const uploads$ = fileArray.map((file, i) => this.read$(file, i).pipe(
  		switchMap(() => this.uploadFile$(file)),
  	));
  	return combineLatest(uploads$);
  }
  */

  read$(file, i) {
    const reader = new FileReader();
    const reader$ = rxjs.fromEvent(reader, 'load').pipe(operators.tap(event => {
      const blob = event.target.result;
      this.resize(blob, resized => {
        this.previews[i] = resized;
        // console.log('resized', resized);
        this.pushChanges();
      });
    }));
    reader.readAsDataURL(file);
    return reader$;
  }
  uploadFile$(file) {
    return AssetService.upload$([file]).pipe(operators.switchMap(uploads => {
      const upload = uploads[0];
      /*
      id: 1601303293569
      type: 'image/jpeg'
      file: '1601303293569_ambiente1_x0_y2.jpg'
      originalFileName: 'ambiente1_x0_y2.jpg'
      url: '/uploads/1601303293569_ambiente1_x0_y2.jpg'
      */
      const asset = Asset.fromUrl(upload.url);
      return AssetService.assetCreate$(asset);
    }));
  }
  resize(blob, callback) {
    if (typeof callback === 'function') {
      const img = document.createElement('img');
      img.onload = function () {
        const MAX_WIDTH = 320;
        const MAX_HEIGHT = 240;
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        let width = img.width;
        let height = img.height;
        if (width > height) {
          if (width > MAX_WIDTH) {
            height *= MAX_WIDTH / width;
            width = MAX_WIDTH;
          }
        } else {
          if (height > MAX_HEIGHT) {
            width *= MAX_HEIGHT / height;
            height = MAX_HEIGHT;
          }
        }
        canvas.width = width;
        canvas.height = height;
        ctx.drawImage(img, 0, 0, width, height);
        const dataUrl = canvas.toDataURL('image/jpeg', 0.9);
        callback(dataUrl);
      };
      img.src = blob;
    }
  }
  supported() {
    return supportFileAPI() && supportAjaxUploadProgressEvents() && supportFormData();
    function supportFileAPI() {
      var input = document.createElement('input');
      input.type = 'file';
      return 'files' in input;
    }
    function supportAjaxUploadProgressEvents() {
      var xhr = new XMLHttpRequest();
      return !!(xhr && 'upload' in xhr && 'onprogress' in xhr.upload);
    }
    function supportFormData() {
      return !!window.FormData;
    }
  }
}class ControlAssetsComponent extends ControlComponent {
  get items() {
    return this.items_;
  }
  set items(items) {
    this.items_ = items;
    this.uploadCount = items.reduce((p, c) => {
      return p + (c.uploading || c.completed ? 0 : 1);
    }, 0);
  }
  onInit() {
    this.label = this.label || 'label';
    this.accept = this.accept || 'image/png, image/jpeg';
    this.multiple = this.multiple !== false;
    this.items = [];
    this.assets = this.control.value || [];
    this.hasFiles = false;
    const {
      node
    } = rxcomp.getContext(this);
    const input = node.querySelector('input');
    input.setAttribute('accept', this.accept);
    const dropArea = node.querySelector('.upload-drop');
    const service = this.service = new UploadService();
    service.drop$(input, dropArea).pipe(operators.takeUntil(this.unsubscribe$)).subscribe(items => {
      // console.log('ControlAssetComponent.drop$', items);
      this.items = items;
      this.pushChanges();
    });
    service.change$(input).pipe(operators.takeUntil(this.unsubscribe$)).subscribe(items => {
      // console.log('ControlAssetComponent.change$', items);
      this.items = items;
      this.pushChanges();
    });
    service.events$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(event => {
      // console.log('ControlAssetComponent.events$', event);
      if (event instanceof UploadAssetEvent) {
        this.assets.push(event.asset);
        this.control.value = this.assets;
      }
      this.items = this.items_;
      this.pushChanges();
      // this.control.value = assets;
    });
  }

  onUpload() {
    // console.log('ControlAssetsComponent.onUpload');
    this.service.upload$().pipe(operators.first()).subscribe();
  }
  onCancel() {
    // console.log('ControlAssetsComponent.onCancel');
    this.service.removeAll();
  }
  onItemPause(item) {
    // console.log('ControlAssetsComponent.onPause', item);
  }
  onItemResume(item) {
    // console.log('ControlAssetsComponent.onResume', item);
  }
  onItemCancel(item) {
    // console.log('ControlAssetsComponent.onCancel', item);
  }
  onItemRemove(item) {
    // console.log('ControlAssetsComponent.onRemove', item);
    this.service.remove(item);
  }
}
ControlAssetsComponent.meta = {
  selector: '[control-assets]',
  inputs: ['control', 'label', 'multiple'],
  template: /* html */`
		<div class="group--form" [class]="{ required: control.validators.length }">
			<div class="control--head">
				<label [innerHTML]="label"></label>
				<span class="required__badge" [innerHTML]="'required' | label"></span>
			</div>
			<div class="listing--assets">
				<div class="listing__item" *for="let item of assets">
					<div class="upload-item">
						<div class="picture">
							<img [lazy]="item | asset" [size]="{ width: 320, height: 240 }" *if="item.type.name === 'image'" />
							<video [src]="item | asset" *if="item.type.name === 'video'"></video>
						</div>
						<div class="name" [innerHTML]="item.file"></div>
					</div>
				</div>
				<div class="listing__item" *for="let item of items">
					<div upload-item [item]="item" (pause)="onItemPause($event)" (resume)="onItemResume($event)" (cancel)="onItemCancel($event)" (remove)="onItemRemove($event)"></div>
				</div>
			</div>
			<div class="group--cta">
				<div class="btn--browse">
					<span [innerHTML]="'browse' | label"></span>
					<input type="file" accept="image/jpeg" multiple />
				</div>
				<div class="btn--upload" (click)="onUpload()" *if="uploadCount > 0" [innerHTML]="'upload' | label"></div>
				<div class="btn--cancel" (click)="onCancel()" *if="uploadCount > 0" [innerHTML]="'cancel' | label"></div>
			</div>
			<div class="upload-drop">
    			<span [innerHTML]="'drag_and_drop_images' | label"></span>
			</div>
		</div>
		<errors-component [control]="control"></errors-component>
	`
};class GenericModalComponent extends rxcomp.Component {
  get data() {
    let data = null;
    const {
      parentInstance
    } = rxcomp.getContext(this);
    if (parentInstance instanceof ModalOutletComponent) {
      data = parentInstance.modal.data;
    }
    return data;
  }
  onInit() {
    console.log(this.data);
    this.page = null;
    GenericService.currentLanguagePage$(this.data.mode).pipe(operators.takeUntil(this.unsubscribe$)).subscribe(page => {
      this.page = page;
      this.pushChanges();
    });
  }
  onClose() {
    ModalService.reject();
  }
}
GenericModalComponent.meta = {
  selector: '[generic-modal]',
  template: /* html */`
		<div class="modal__header">
			<button type="button" class="btn--close" (click)="onClose()">
				<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#close"></use></svg>
			</button>
		</div>
		<div class="container" *if="page">
			<h1 class="title" [innerHTML]="page.title"></h1>
			<div class="description" [innerHTML]="page.description"></div>
		</div>
		<div class="modal__footer">
			<button type="button" class="btn--accept" (click)="onClose()">
				<span [innerHTML]="'title_close' | label"></span>
			</button>
		</div>
	`
};
GenericModalComponent.chunk = () => /* html */'<div class="generic-modal" generic-modal></div>';class ControlCheckboxComponent extends ControlComponent {
  onInit() {
    this.label = this.label || 'label';
    this.linksSubject = new rxjs.ReplaySubject();
    this.links$().pipe(operators.takeUntil(this.unsubscribe$)).subscribe();
  }
  onChanges() {
    const {
      node
    } = rxcomp.getContext(this);
    const links = Array.prototype.slice.call(node.querySelectorAll('a'));
    // console.log('ControlCheckboxComponent.onChanges', links);
    this.linksSubject.next(links.length ? rxjs.fromEvent(links, 'click') : rxjs.EMPTY);
  }
  links$() {
    const linksSubject = this.linksSubject.pipe(operators.switchAll(), operators.tap(event => {
      // console.log(event);
      if (environment.flags.gdprRoutes) {
        const template = GenericModalComponent.chunk();
        ModalService.open$({
          template,
          data: {
            mode: 'privacy_policy'
          }
        }).pipe(operators.first()).subscribe();
        event.preventDefault();
      }
    }));
    return linksSubject;
  }
}
ControlCheckboxComponent.meta = {
  selector: '[control-checkbox]',
  inputs: ['control', 'label'],
  template: /* html */`
		<div class="group--form--checkbox" [class]="{ required: control.validators.length }">
			<label>
				<input type="checkbox" class="control--checkbox" [formControl]="control" [value]="true" />
				<span [innerHTML]="label | html"></span>
			</label>
			<span class="required__badge" [innerHTML]="'required' | label"></span>
		</div>
		<errors-component [control]="control"></errors-component>
	`
};class ControlCustomSelectComponent extends ControlComponent {
  onInit() {
    this.label = this.label || 'label';
    this.dropped = false;
    this.dropdownId = DropdownDirective.nextId();
    KeyboardService.typing$().pipe(operators.takeUntil(this.unsubscribe$)).subscribe(word => {
      this.scrollToWord(word);
    });
    /*
    KeyboardService.key$().pipe(
    	takeUntil(this.unsubscribe$)
    ).subscribe(key => {
    	this.scrollToKey(key);
    });
    */
  }

  /*
  onChanges() {
  	// console.log('ControlCustomSelectComponent.onChanges');
  }
  */

  scrollToWord(word) {
    // console.log('ControlCustomSelectComponent.scrollToWord', word);
    const items = this.control.options || [];
    let index = -1;
    for (let i = 0; i < items.length; i++) {
      const x = items[i];
      if (x.name.toLowerCase().indexOf(word.toLowerCase()) === 0) {
        // console.log(word, x.name);
        index = i;
        break;
      }
    }
    if (index !== -1) {
      const {
        node
      } = rxcomp.getContext(this);
      const dropdown = node.querySelector('.dropdown');
      const navDropdown = node.querySelector('.nav--dropdown');
      const item = navDropdown.children[index];
      if (item) {
        dropdown.scrollTo(0, item.offsetTop);
      }
    }
  }
  setOption(item) {
    // console.log('setOption', item, this.isMultiple);
    let value;
    if (this.isMultiple) {
      value = this.control.value || [];
      const index = value.indexOf(item.id);
      if (index !== -1) {
        // if (value.length > 1) {
        value.splice(index, 1);
        // }
      } else {
        value.push(item.id);
      }
      value = value.length ? value.slice() : null;
    } else {
      value = item.id;
      // DropdownDirective.dropdown$.next(null);
    }

    this.control.value = value;
    this.change.next(value);
  }
  hasOption(item) {
    if (this.isMultiple) {
      const values = this.control.value || [];
      return values.indexOf(item.id) !== -1;
    } else {
      return this.control.value === item.id;
    }
  }
  getLabel() {
    let value = this.control.value;
    const items = this.control.options || [];
    if (this.isMultiple) {
      value = value || [];
      if (value.length) {
        return value.map(v => {
          const item = items.find(x => x.id === v || x.name === v);
          return item ? item.name : '';
        }).join(', ');
      } else {
        return 'select'; // LabelPipe.transform('select');
      }
    } else {
      const item = items.find(x => x.id === value || x.name === value);
      if (item) {
        return item.name;
      } else {
        return 'select'; // LabelPipe.transform('select');
      }
    }
  }

  onDropped($event) {
    // console.log('ControlCustomSelectComponent.onDropped', id);
    if (this.dropped && $event === null) {
      this.control.touched = true;
    }
    this.dropped = $event === this.dropdownId;
  }
  get isMultiple() {
    return this.multiple && this.multiple !== false && this.multiple !== 'false';
  }
}
ControlCustomSelectComponent.meta = {
  selector: '[control-custom-select]',
  outputs: ['change'],
  inputs: ['control', 'label', 'multiple'],
  template: /* html */`
		<div class="group--form--select" [class]="{ required: control.validators.length, multiple: isMultiple }" [dropdown]="dropdownId" (dropped)="onDropped($event)">
			<label [innerHTML]="label"></label>
			<span class="control--custom-select" [innerHTML]="getLabel() | label"></span>
			<svg class="icon--caret-down"><use xlink:href="#caret-down"></use></svg>
			<span class="required__badge" [innerHTML]="'required' | label"></span>
		</div>
		<errors-component [control]="control"></errors-component>
		<div class="dropdown" [dropdown-item]="dropdownId">
			<div class="category" [innerHTML]="label"></div>
			<ul class="nav--dropdown" [class]="{ multiple: isMultiple }">
				<li (click)="setOption(item)" [class]="{ empty: item.id == null }" *for="let item of control.options">
					<span [class]="{ active: hasOption(item) }" [innerHTML]="item.name | label"></span>
				</li>
			</ul>
		</div>
	`
};class ControlLinkComponent extends ControlComponent {
  onInit() {
    this.label = this.label || 'label';
    this.disabled = this.disabled || false;
    const {
      node
    } = rxcomp.getContext(this);
    const input = this.input = node.querySelector('input');
    rxjs.merge(rxjs.fromEvent(input, 'input')).pipe(operators.takeUntil(this.unsubscribe$)).subscribe(event => this.onInputDidChange(event));
    rxjs.fromEvent(input, 'blur').pipe(operators.takeUntil(this.unsubscribe$)).subscribe(event => this.onInputDidBlur(event));
  }
  onInputDidChange(event) {
    // console.log('ControlLinkComponent.onInputDidChange', event.target.value);
  }
  onInputDidBlur(event) {
    // console.log('ControlLinkComponent.onInputDidBlur', event.target.value);
    this.control.touched = true;
    this.value = this.input.value;
  }
}
ControlLinkComponent.meta = {
  selector: '[control-link]',
  inputs: ['control', 'label', 'disabled'],
  template: /* html */`
		<div class="group--form" [class]="{ required: control.validators.length, disabled: disabled }">
			<label [innerHTML]="label"></label>
			<input type="text" class="control--text" [formControl]="control" [placeholder]="label" [disabled]="disabled" />
			<span class="required__badge" [innerHTML]="'required' | label"></span>
		</div>
		<errors-component [control]="control"></errors-component>
	`
};class ControlLocalizedAssetComponent extends ControlComponent {
  get localizedValue() {
    let asset = this.control.value;
    if (asset && asset.locale) {
      const localizedAsset = asset.locale[this.currentLanguage];
      if (localizedAsset) {
        asset = localizedAsset;
      }
    }
    return asset;
  }
  onInit() {
    this.label = this.label || 'label';
    this.disabled = this.disabled || false;
    this.accept = this.accept || 'image/png, image/jpeg';
    this.languages = environment.languages;
    this.currentLanguage = LanguageService.lang;
    const {
      node
    } = rxcomp.getContext(this);
    const input = node.querySelector('input');
    input.setAttribute('accept', this.accept);
    DropService.drop$(input).pipe(operators.takeUntil(this.unsubscribe$)).subscribe();
    DropService.change$(input).pipe(operators.switchMap(files => {
      const uploads$ = files.map((file, i) => AssetService.upload$([file]).pipe(operators.switchMap(uploads => (this.languages.length > 1 ? AssetService.createOrUpdateLocalizedAsset$ : AssetService.createOrUpdateAsset$)(uploads, this.control, this.currentLanguage))));
      return rxjs.combineLatest(uploads$);
    }), operators.takeUntil(this.unsubscribe$)).subscribe(assets => {
      // console.log('ControlLocalizedAssetComponent.change$', assets);
      this.control.value = assets[0];
    });
  }
  setLanguage(language) {
    LanguageService.setLanguage$(language).pipe(operators.first()).subscribe(_ => {
      this.currentLanguage = language;
      this.pushChanges();
    });
  }
}
ControlLocalizedAssetComponent.meta = {
  selector: '[control-localized-asset]',
  inputs: ['control', 'label', 'disabled', 'accept'],
  template: /* html */`
		<div class="group--form" [class]="{ required: control.validators.length, disabled: disabled }">
			<div class="control--head">
				<label [innerHTML]="label"></label>
				<span class="required__badge" [innerHTML]="'required' | label"></span>
			</div>
			<div class="group--picture">
				<div class="group--picture__info">
					<span [innerHTML]="'browse' | label"></span>
				</div>
				<img [lazy]="localizedValue | asset" [size]="{ width: 320, height: 240 }" *if="localizedValue && localizedValue.type.name === 'image'" />
				<video [src]="localizedValue | asset" *if="localizedValue && localizedValue.type.name === 'video'"></video>
				<input type="file">
			</div>
			<div class="file-name" *if="localizedValue" [innerHTML]="localizedValue.file"></div>
			<ul class="nav--languages" *if="languages.length > 1">
				<li class="nav__item" [class]="{ active: lang == currentLanguage }" (click)="setLanguage(lang)" [innerHTML]="lang" *for="let lang of languages"></li>
			</ul>
		</div>
		<errors-component [control]="control"></errors-component>
	`
};class ControlModelComponent extends ControlAssetComponent {
  onInit() {
    this.label = this.label || 'label';
    this.disabled = this.disabled || false;
    this.accept = this.accept || '.glb';
    const {
      node
    } = rxcomp.getContext(this);
    const input = this.input = node.querySelector('input');
    input.setAttribute('accept', this.accept);
    /*
    this.click$(input).pipe(
    	takeUntil(this.unsubscribe$)
    ).subscribe();
    */
    DropService.change$(input).pipe(operators.switchMap(files => {
      const uploads$ = files.map((file, i) => AssetService.upload$([file]).pipe(operators.switchMap(uploads => AssetService.createOrUpdateAsset$(uploads, this.control))));
      return rxjs.combineLatest(uploads$);
    }), operators.takeUntil(this.unsubscribe$)).subscribe(assets => {
      // console.log('ControlModelComponent.change$', assets);
      this.control.value = assets[0];
    });
  }
  onRemove(event) {
    AssetService.assetDelete$(this.control.value).pipe(operators.first()).subscribe(() => {
      this.control.value = null;
      this.input.value = null;
      this.control.touched = true; // !!!
    });
    // !!! delete upload
    // !!! delete asset
  }

  /*
  click$(input) {
  	if (isPlatformBrowser && input) {
  		return fromEvent(input, 'click').pipe(
  			tap(() => input.value = null),
  		);
  	} else {
  		return EMPTY;
  	}
  }
  */

  read$(file, i) {
    return rxjs.of(file);
  }
}
ControlModelComponent.meta = {
  selector: '[control-model]',
  inputs: ['control', 'label', 'disabled', 'accept'],
  template: /* html */`
		<div class="group--form" [class]="{ required: control.validators.length, disabled: disabled }">
			<div class="control--head">
				<label [innerHTML]="label"></label>
				<span class="required__badge" [innerHTML]="'required' | label"></span>
			</div>
			<div class="group--model">
				<div class="file-name" *if="!control.value" [innerHTML]="'select_file' | label"></div>
				<div class="file-name" *if="control.value" [innerHTML]="control.value.file"></div>
				<div class="btn--upload"><input type="file"><span [innerHTML]="'browse' | label"></span></div>
				<div class="btn--remove" *if="control.value" (click)="onRemove($event)"><span [innerHTML]="'remove' | label"></span></div>
			</div>
		</div>
		<errors-component [control]="control"></errors-component>
	`
};class ControlNumberComponent extends ControlComponent {
  onInit() {
    this.label = this.label || 'label';
    this.precision = this.precision || 3;
    this.increment = this.increment || 1 / Math.pow(10, this.precision);
    this.disabled = this.disabled || false;
  }
  updateValue(value) {
    this.control.value = value;
  }
}
ControlNumberComponent.meta = {
  selector: '[control-number]',
  inputs: ['control', 'label', 'precision', 'increment', 'disabled'],
  template: /* html */`
		<div class="group--form" [class]="{ required: control.validators.length }">
			<div class="control--head">
				<label [innerHTML]="label"></label>
				<span class="required__badge" [innerHTML]="'required' | label"></span>
			</div>
			<div class="control--content control--number">
				<input-value label="" [precision]="precision" [increment]="increment" [disabled]="disabled" [value]="control.value" (update)="updateValue($event)"></input-value>
			</div>
		</div>
		<errors-component [control]="control"></errors-component>
	`
};class ControlPasswordComponent extends ControlComponent {
  onInit() {
    this.label = this.label || 'label';
  }
}
ControlPasswordComponent.meta = {
  selector: '[control-password]',
  inputs: ['control', 'label'],
  template: /* html */`
		<div class="group--form" [class]="{ required: control.validators.length }">
			<label [innerHTML]="label"></label>
			<input type="password" class="control--text" [formControl]="control" [placeholder]="label" />
			<span class="required__badge" [innerHTML]="'required' | label"></span>
		</div>
		<errors-component [control]="control"></errors-component>
	`
};class ControlSelectComponent extends ControlComponent {
  onInit() {
    this.label = this.label || 'label';
  }
}
ControlSelectComponent.meta = {
  selector: '[control-select]',
  inputs: ['control', 'label'],
  template: /* html */`
		<div class="group--form--select" [class]="{ required: control.validators.length }">
			<label [innerHTML]="label"></label>
			<select class="control--select" [formControl]="control" required>
				<option [value]="null" [innerHTML]="'select' | label"></option>
				<option [value]="item.id" *for="let item of control.options" [innerHTML]="item.name"></option>
			</select>
			<span class="required__badge" [innerHTML]="'required' | label"></span>
			<svg class="icon--caret-down"><use xlink:href="#caret-down"></use></svg>
		</div>
		<errors-component [control]="control"></errors-component>
	`
};class ControlTextComponent extends ControlComponent {
  onInit() {
    this.label = this.label || 'label';
    this.disabled = this.disabled || false;
  }
}
ControlTextComponent.meta = {
  selector: '[control-text]',
  inputs: ['control', 'label', 'disabled'],
  template: /* html */`
		<div class="group--form" [class]="{ required: control.validators.length, disabled: disabled }">
			<label [innerHTML]="label"></label>
			<span class="required__badge" [innerHTML]="'required' | label"></span>
			<input type="text" class="control--text" [formControl]="control" [placeholder]="label" [disabled]="disabled" />
		</div>
		<errors-component [control]="control"></errors-component>
	`
};class ControlTextareaComponent extends ControlComponent {
  onInit() {
    this.label = this.label || 'label';
    this.disabled = this.disabled || false;
  }
}
ControlTextareaComponent.meta = {
  selector: '[control-textarea]',
  inputs: ['control', 'label', 'disabled'],
  template: /* html */`
		<div class="group--form--textarea" [class]="{ required: control.validators.length, disabled: disabled }">
			<label [innerHTML]="label"></label>
			<textarea class="control--text" [formControl]="control" [placeholder]="label" [innerHTML]="label" rows="4" [disabled]="disabled"></textarea>
			<span class="required__badge" [innerHTML]="'required' | label"></span>
		</div>
		<errors-component [control]="control"></errors-component>
	`
};class ControlVectorComponent extends ControlComponent {
  onInit() {
    this.label = this.label || 'label';
    this.precision = this.precision || 3;
    this.increment = this.increment || 1 / Math.pow(10, this.precision);
    this.disabled = this.disabled || false;
  }
  updateValue(index, value) {
    const values = this.control.value;
    values[index] = value;
    this.control.value = values.slice();
  }
}
ControlVectorComponent.meta = {
  selector: '[control-vector]',
  inputs: ['control', 'label', 'precision', 'increment', 'disabled'],
  template: /* html */`
		<div class="group--form" [class]="{ required: control.validators.length }">
			<div class="control--head">
				<label [innerHTML]="label"></label>
				<span class="required__badge" [innerHTML]="'required' | label"></span>
			</div>
			<div class="control--content control--vector">
				<input-value label="x" [precision]="precision" [increment]="increment" [disabled]="disabled" [value]="control.value[0]" (update)="updateValue(0, $event)"></input-value>
				<input-value label="y" [precision]="precision" [increment]="increment" [disabled]="disabled" [value]="control.value[1]" (update)="updateValue(1, $event)"></input-value>
				<input-value label="z" [precision]="precision" [increment]="increment" [disabled]="disabled" [value]="control.value[2]" (update)="updateValue(2, $event)"></input-value>
			</div>
		</div>
		<errors-component [control]="control"></errors-component>
	`
};class DisabledDirective extends rxcomp.Directive {
  onChanges() {
    const {
      node
    } = rxcomp.getContext(this);
    // console.log('DisabledDirective.onChanges', this.disabled);
    if (this.disabled === true) {
      node.disabled = this.disabled;
      node.setAttribute('disabled', this.disabled);
    } else {
      delete node.disabled;
      node.removeAttribute('disabled');
    }
  }
}
DisabledDirective.meta = {
  selector: 'input[disabled],textarea[disabled]',
  inputs: ['disabled']
};class ErrorsComponent extends ControlComponent {
  getLabel(key, value) {
    const label = LabelPipe.transform(`error_${key}`);
    return label;
  }
}
ErrorsComponent.meta = {
  selector: 'errors-component',
  inputs: ['control'],
  template: /* html */`
	<div class="inner" [style]="{ display: control.invalid && control.touched ? 'block' : 'none' }">
		<div class="error" *for="let [key, value] of control.errors">
			<span [innerHTML]="getLabel(key, value)"></span>
			<!-- <span class="key" [innerHTML]="key"></span> <span class="value" [innerHTML]="value | json"></span> -->
		</div>
	</div>
	`
};class InputValueComponent extends rxcomp.Component {
  onInit() {
    this.label = this.label || 'label';
    this.value = this.value || 0;
    this.precision = this.precision || 3;
    this.increment = this.increment || 1 / Math.pow(10, this.precision);
    this.disabled = this.disabled || false;
    this.increment$('.btn--more', 1).pipe(operators.takeUntil(this.unsubscribe$)).subscribe(event => {
      // console.log('InputValueComponent.increment$', event);
      this.value += event;
      this.update.next(this.value);
      this.pushChanges();
    });
    this.increment$('.btn--less', -1).pipe(operators.takeUntil(this.unsubscribe$)).subscribe(event => {
      // console.log('InputValueComponent.increment$', event);
      this.value += event;
      this.update.next(this.value);
      this.pushChanges();
    });
    const {
      node
    } = rxcomp.getContext(this);
    const input = this.input = node.querySelector('input');
    // fromEvent(input, 'change')
    rxjs.merge(rxjs.fromEvent(input, 'input')).pipe(operators.takeUntil(this.unsubscribe$)).subscribe(event => this.onInputDidChange(event));
    rxjs.merge(rxjs.fromEvent(input, 'blur'), rxjs.fromEvent(input, 'keydown').pipe(operators.filter(event => event.key === 'Enter' || event.keyCode === 13))).pipe(operators.takeUntil(this.unsubscribe$)).subscribe(event => this.onInputDidBlur(event));
    // fromEvent(node, 'focus').pipe(takeUntil(this.unsubscribe$)).subscribe(event => this.onFocus(event));
  }

  onInputDidChange(event) {
    // const node = getContext(this).node;
    // const value = node.value === '' ? null : node.value;
    // eslint-disable-next-line no-useless-escape
    event.target.value = event.target.value.replace(/[^\d|\.|-]/g, '');
    // console.log('InputValueComponent.onInputDidChange', event.target.value);
    /*
    const value = parseFloat(event.target.value);
    if (this.value !== value) {
    	if (value !== NaN) {
    		this.value = value;
    		this.update.next(this.value);
    	}
    }
    */
  }

  onInputDidBlur(event) {
    // this.control.touched = true;
    // console.log('InputValueComponent.onInputDidBlur', event.target.value);
    const value = parseFloat(this.input.value);
    if (this.value !== value) {
      if (!isNaN(value)) {
        this.value = value;
        this.update.next(this.value);
      } else {
        this.input.value = this.getValue();
      }
    }
  }
  increment$(selector, sign) {
    const {
      node
    } = rxcomp.getContext(this);
    const element = node.querySelector(selector);
    let m, increment;
    return rxjs.race(rxjs.fromEvent(element, 'mousedown'), rxjs.fromEvent(element, 'touchstart')).pipe(operators.tap(() => {
      increment = this.increment;
      m = 16;
    }), operators.switchMap(e => {
      return rxjs.interval(30).pipe(operators.filter(i => {
        return i % m === 0;
      }), operators.map(() => {
        const i = increment * sign;
        // increment = Math.min(this.increment * 100, increment * 2);
        m = Math.max(1, Math.floor(m * 0.85));
        return i;
      }),
      // startWith(increment * sign),
      operators.takeUntil(rxjs.race(rxjs.fromEvent(element, 'mouseup'), rxjs.fromEvent(element, 'touchend'))));
    }));
  }
  getValue() {
    return this.value.toFixed(this.precision);
  }
  setValue(sign) {
    this.value += this.increment * sign;
    this.update.next(this.value);
    this.pushChanges();
  }
}
InputValueComponent.meta = {
  selector: 'input-value',
  outputs: ['update'],
  inputs: ['value', 'label', 'precision', 'increment', 'disabled'],
  template: /* html */`
		<div class="group--control" [class]="{ disabled: disabled }">
			<input type="text" class="control--text" [placeholder]="label" [value]="getValue()" [disabled]="disabled" />
			<div class="control--trigger">
				<div class="btn--more" (click)="setValue(1)">+</div>
				<div class="btn--less" (click)="setValue(-1)">-</div>
			</div>
		</div>
	`
};class TestComponent extends rxcomp.Component {
  onInit() {
    this.env = ENV;
  }
  onTest(event) {
    this.test.next(event);
  }
  onReset(event) {
    this.reset.next(event);
  }
}
TestComponent.meta = {
  selector: 'test-component',
  inputs: ['form'],
  outputs: ['test', 'reset'],
  template: /* html */`
	<div class="group--form--results" *if="env.DEVELOPMENT">
		<code [innerHTML]="form.value | json"></code>
		<button type="button" class="btn--mode" (click)="onReset($event)"><span>reset</span></button>
		<button type="button" class="btn--mode" (click)="onTest($event)"><span>test</span></button>
	</div>
	`
};class ValueDirective extends rxcomp.Directive {
  onChanges(changes) {
    const {
      node
    } = rxcomp.getContext(this);
    // console.log('ValueDirective.onChanges', this.value);
    node.value = this.value;
    node.setAttribute('value', this.value);
  }
}
ValueDirective.meta = {
  selector: '[value]',
  inputs: ['value']
};/*
['quot', 'amp', 'apos', 'lt', 'gt', 'nbsp', 'iexcl', 'cent', 'pound', 'curren', 'yen', 'brvbar', 'sect', 'uml', 'copy', 'ordf', 'laquo', 'not', 'shy', 'reg', 'macr', 'deg', 'plusmn', 'sup2', 'sup3', 'acute', 'micro', 'para', 'middot', 'cedil', 'sup1', 'ordm', 'raquo', 'frac14', 'frac12', 'frac34', 'iquest', 'Agrave', 'Aacute', 'Acirc', 'Atilde', 'Auml', 'Aring', 'AElig', 'Ccedil', 'Egrave', 'Eacute', 'Ecirc', 'Euml', 'Igrave', 'Iacute', 'Icirc', 'Iuml', 'ETH', 'Ntilde', 'Ograve', 'Oacute', 'Ocirc', 'Otilde', 'Ouml', 'times', 'Oslash', 'Ugrave', 'Uacute', 'Ucirc', 'Uuml', 'Yacute', 'THORN', 'szlig', 'agrave', 'aacute', 'atilde', 'auml', 'aring', 'aelig', 'ccedil', 'egrave', 'eacute', 'ecirc', 'euml', 'igrave', 'iacute', 'icirc', 'iuml', 'eth', 'ntilde', 'ograve', 'oacute', 'ocirc', 'otilde', 'ouml', 'divide', 'oslash', 'ugrave', 'uacute', 'ucirc', 'uuml', 'yacute', 'thorn', 'yuml', 'amp', 'bull', 'deg', 'infin', 'permil', 'sdot', 'plusmn', 'dagger', 'mdash', 'not', 'micro', 'perp', 'par', 'euro', 'pound', 'yen', 'cent', 'copy', 'reg', 'trade', 'alpha', 'beta', 'gamma', 'delta', 'epsilon', 'zeta', 'eta', 'theta', 'iota', 'kappa', 'lambda', 'mu', 'nu', 'xi', 'omicron', 'pi', 'rho', 'sigma', 'tau', 'upsilon', 'phi', 'chi', 'psi', 'omega', 'Alpha', 'Beta', 'Gamma', 'Delta', 'Epsilon', 'Zeta', 'Eta', 'Theta', 'Iota', 'Kappa', 'Lambda', 'Mu', 'Nu', 'Xi', 'Omicron', 'Pi', 'Rho', 'Sigma', 'Tau', 'Upsilon', 'Phi', 'Chi', 'Psi', 'Omega'];
['"', '&', ''', '<', '>', ' ', '¡', '¢', '£', '¤', '¥', '¦', '§', '¨', '©', 'ª', '«', '¬', '­', '®', '¯', '°', '±', '²', '³', '´', 'µ', '¶', '·', '¸', '¹', 'º', '»', '¼', '½', '¾', '¿', 'À', 'Á', 'Â', 'Ã', 'Ä', 'Å', 'Æ', 'Ç', 'È', 'É', 'Ê', 'Ë', 'Ì', 'Í', 'Î', 'Ï', 'Ð', 'Ñ', 'Ò', 'Ó', 'Ô', 'Õ', 'Ö', '×', 'Ø', 'Ù', 'Ú', 'Û', 'Ü', 'Ý', 'Þ', 'ß', 'à', 'á', 'ã', 'ä', 'å', 'æ', 'ç', 'è', 'é', 'ê', 'ë', 'ì', 'í', 'î', 'ï', 'ð', 'ñ', 'ò', 'ó', 'ô', 'õ', 'ö', '÷', 'ø', 'ù', 'ú', 'û', 'ü', 'ý', 'þ', 'ÿ', '&', '•', '°', '∞', '‰', '⋅', '±', '†', '—', '¬', 'µ', '⊥', '∥', '€', '£', '¥', '¢', '©', '®', '™', 'α', 'β', 'γ', 'δ', 'ε', 'ζ', 'η', 'θ', 'ι', 'κ', 'λ', 'μ', 'ν', 'ξ', 'ο', 'π', 'ρ', 'σ', 'τ', 'υ', 'φ', 'χ', 'ψ', 'ω', 'Α', 'Β', 'Γ', 'Δ', 'Ε', 'Ζ', 'Η', 'Θ', 'Ι', 'Κ', 'Λ', 'Μ', 'Ν', 'Ξ', 'Ο', 'Π', 'Ρ', 'Σ', 'Τ', 'Υ', 'Φ', 'Χ', 'Ψ', 'Ω'];
*/

class HtmlPipe extends rxcomp.Pipe {
  static transform(value) {
    if (value) {
      value = value.replace(/&#(\d+);/g, function (m, n) {
        return String.fromCharCode(parseInt(n));
      });
      const escapes = ['quot', 'amp', 'apos', 'lt', 'gt', 'nbsp', 'iexcl', 'cent', 'pound', 'curren', 'yen', 'brvbar', 'sect', 'uml', 'copy', 'ordf', 'laquo', 'not', 'shy', 'reg', 'macr', 'deg', 'plusmn', 'sup2', 'sup3', 'acute', 'micro', 'para', 'middot', 'cedil', 'sup1', 'ordm', 'raquo', 'frac14', 'frac12', 'frac34', 'iquest', 'Agrave', 'Aacute', 'Acirc', 'Atilde', 'Auml', 'Aring', 'AElig', 'Ccedil', 'Egrave', 'Eacute', 'Ecirc', 'Euml', 'Igrave', 'Iacute', 'Icirc', 'Iuml', 'ETH', 'Ntilde', 'Ograve', 'Oacute', 'Ocirc', 'Otilde', 'Ouml', 'times', 'Oslash', 'Ugrave', 'Uacute', 'Ucirc', 'Uuml', 'Yacute', 'THORN', 'szlig', 'agrave', 'aacute', 'atilde', 'auml', 'aring', 'aelig', 'ccedil', 'egrave', 'eacute', 'ecirc', 'euml', 'igrave', 'iacute', 'icirc', 'iuml', 'eth', 'ntilde', 'ograve', 'oacute', 'ocirc', 'otilde', 'ouml', 'divide', 'oslash', 'ugrave', 'uacute', 'ucirc', 'uuml', 'yacute', 'thorn', 'yuml', 'amp', 'bull', 'deg', 'infin', 'permil', 'sdot', 'plusmn', 'dagger', 'mdash', 'not', 'micro', 'perp', 'par', 'euro', 'pound', 'yen', 'cent', 'copy', 'reg', 'trade', 'alpha', 'beta', 'gamma', 'delta', 'epsilon', 'zeta', 'eta', 'theta', 'iota', 'kappa', 'lambda', 'mu', 'nu', 'xi', 'omicron', 'pi', 'rho', 'sigma', 'tau', 'upsilon', 'phi', 'chi', 'psi', 'omega', 'Alpha', 'Beta', 'Gamma', 'Delta', 'Epsilon', 'Zeta', 'Eta', 'Theta', 'Iota', 'Kappa', 'Lambda', 'Mu', 'Nu', 'Xi', 'Omicron', 'Pi', 'Rho', 'Sigma', 'Tau', 'Upsilon', 'Phi', 'Chi', 'Psi', 'Omega'];
      const unescapes = ['"', '&', '\'', '<', '>', ' ', '¡', '¢', '£', '¤', '¥', '¦', '§', '¨', '©', 'ª', '«', '¬', '­', '®', '¯', '°', '±', '²', '³', '´', 'µ', '¶', '·', '¸', '¹', 'º', '»', '¼', '½', '¾', '¿', 'À', 'Á', 'Â', 'Ã', 'Ä', 'Å', 'Æ', 'Ç', 'È', 'É', 'Ê', 'Ë', 'Ì', 'Í', 'Î', 'Ï', 'Ð', 'Ñ', 'Ò', 'Ó', 'Ô', 'Õ', 'Ö', '×', 'Ø', 'Ù', 'Ú', 'Û', 'Ü', 'Ý', 'Þ', 'ß', 'à', 'á', 'ã', 'ä', 'å', 'æ', 'ç', 'è', 'é', 'ê', 'ë', 'ì', 'í', 'î', 'ï', 'ð', 'ñ', 'ò', 'ó', 'ô', 'õ', 'ö', '÷', 'ø', 'ù', 'ú', 'û', 'ü', 'ý', 'þ', 'ÿ', '&', '•', '°', '∞', '‰', '⋅', '±', '†', '—', '¬', 'µ', '⊥', '∥', '€', '£', '¥', '¢', '©', '®', '™', 'α', 'β', 'γ', 'δ', 'ε', 'ζ', 'η', 'θ', 'ι', 'κ', 'λ', 'μ', 'ν', 'ξ', 'ο', 'π', 'ρ', 'σ', 'τ', 'υ', 'φ', 'χ', 'ψ', 'ω', 'Α', 'Β', 'Γ', 'Δ', 'Ε', 'Ζ', 'Η', 'Θ', 'Ι', 'Κ', 'Λ', 'Μ', 'Ν', 'Ξ', 'Ο', 'Π', 'Ρ', 'Σ', 'Τ', 'Υ', 'Φ', 'Χ', 'Ψ', 'Ω'];
      const rx = new RegExp(`(&${escapes.join(';)|(&')};)`, 'g');
      value = value.replace(rx, function () {
        for (let i = 1; i < arguments.length; i++) {
          if (arguments[i]) {
            // console.log(arguments[i], unescapes[i - 1]);
            return unescapes[i - 1];
          }
        }
      });
      // console.log(value);
      return value;
    }
  }
}
HtmlPipe.meta = {
  name: 'html'
};class IdDirective extends rxcomp.Directive {
  onChanges() {
    const {
      node
    } = rxcomp.getContext(this);
    node.setAttribute('id', this.id);
  }
}
IdDirective.meta = {
  selector: '[id]',
  inputs: ['id']
};class LanguageComponent extends rxcomp.Component {
  onInit() {
    this.showLanguages = false;
    this.languageService = LanguageService;
  }
  setLanguage(language) {
    this.languageService.setLanguage$(language).pipe(operators.first()).subscribe(_ => {
      this.showLanguages = false;
      this.pushChanges();
      this.set.next();
    });
  }
  toggleLanguages() {
    this.showLanguages = !this.showLanguages;
    this.pushChanges();
  }
}
LanguageComponent.meta = {
  selector: '[language]',
  outputs: ['set'],
  template: /* html */`
		<button type="button" class="btn--language" (click)="toggleLanguages()" *if="languageService.hasLanguages"><span [innerHTML]="languageService.activeLanguage.title"></span> <svg viewBox="0 0 8 5"><use xlink:href="#caret-down"></use></svg></button>
		<ul class="nav--language" *if="showLanguages">
			<li (click)="setLanguage(language)" *for="let language of languageService.languages"><span [innerHTML]="language.title"></span></li>
		</ul>
	`
};class IntersectionService {
  static observer() {
    if (!this.observer_) {
      this.readySubject_ = new rxjs.BehaviorSubject(false);
      this.observerSubject_ = new rxjs.Subject();
      this.observer_ = new IntersectionObserver(entries => {
        this.observerSubject_.next(entries);
      });
    }
    return this.observer_;
  }
  static intersection$(node) {
    if ('IntersectionObserver' in window) {
      const observer = this.observer();
      observer.observe(node);
      return this.observerSubject_.pipe(
      // tap(entries => console.log(entries.length)),
      operators.map(entries => entries.find(entry => entry.target === node)),
      // tap(entry => console.log('IntersectionService.intersection$', entry)),
      operators.filter(entry => entry !== undefined && entry.isIntersecting),
      // entry.intersectionRatio > 0
      operators.first(), operators.finalize(() => observer.unobserve(node)));
    } else {
      return rxjs.of({
        target: node
      });
    }

    /*
    function observer() {
    	if ('IntersectionObserver' in window) {
    		return new IntersectionObserver(entries => {
    			entries.forEach(function(entry) {
    				if (entry.isIntersecting) {
    					entry.target.classList.add('appear');
    				}
    			})
    		});
    	} else {
    		return { observe: function(node) { node.classList.add('appear')}, unobserve: function() {} };
    	}
    }
    observer.observe(node);
    observer.unobserve(node);
    */
  }
}class LazyCache {
  static get cache() {
    if (!this.cache_) {
      this.cache_ = {};
    }
    return this.cache_;
  }
  static get(src) {
    return this.cache[src];
  }
  static set(src, blob) {
    this.cache[src] = blob;
    const keys = Object.keys(this.cache);
    if (keys.length > 100) {
      this.remove(keys[0]);
    }
  }
  static remove(src) {
    delete this.cache[src];
  }
}class LazyDirective extends rxcomp.Directive {
  onInit() {
    const {
      node
    } = rxcomp.getContext(this);
    node.classList.add('lazy');
    this.input$ = new rxjs.Subject().pipe(operators.distinctUntilChanged(), operators.switchMap(input => {
      const src = LazyCache.get(input);
      if (src) {
        return rxjs.of(src);
      }
      node.classList.remove('lazyed');
      return this.lazy$(input);
    }), operators.takeUntil(this.unsubscribe$));
    this.input$.subscribe(src => {
      LazyCache.set(this.lazy, src);
      node.setAttribute('src', src);
      node.classList.add('lazyed');
    });
  }
  onChanges() {
    this.input$.next(this.lazy);
  }
  lazy$(input) {
    const {
      node
    } = rxcomp.getContext(this);
    return IntersectionService.intersection$(node).pipe(
    // first(),
    operators.switchMap(() => ImageService.load$(input, this.size)), operators.first()
    // takeUntil(this.unsubscribe$),
    );
  }
}

LazyDirective.meta = {
  selector: '[lazy],[[lazy]]',
  inputs: ['lazy', 'size']
};// export const URL_PATTERN = '/((http:\/\/|https:\/\/|www\.)([a-z0-9])([a-z0-9]|\.)+(\?[a-z]([a-z0-9]|\=|\&)+)?)';

class MessagePipe extends rxcomp.Pipe {
  static transform(text) {
    let html = MessagePipe.urlify(text);
    html = MessagePipe.breakLines(html);
    // console.log('MessagePipe', text, html);
    return html;
  }
  static urlify(text) {
    // const regex = new RegExp(URL_PATTERN, 'gim');
    // eslint-disable-next-line no-useless-escape
    const regex = /(?:(?:https?|ftp):\/\/|\b(?:[a-z\d]+\.))(?:(?:[^\s()<>]+|\((?:[^\s()<>]+|(?:\([^\s()<>]+\)))?\))+(?:\((?:[^\s()<>]+|(?:\(?:[^\s()<>]+\)))?\)|[^\s`!()\[\]{};:'".,<>?«»“”‘’]))?/gmi;
    return text.replace(regex, url => {
      return (/*html*/`<a href="${url}" target="_blank">${url}</a>`
      );
    });
    // or alternatively
    // return text.replace(urlRegex, '<a href="$1">$1</a>')
  }

  static breakLines(text) {
    const regex = /\n/gm;
    return text.replace(regex, text => {
      return (/*html*/'<br>'
      );
    });
  }
}
MessagePipe.meta = {
  name: 'message'
};class ModalComponent extends rxcomp.Component {
  onInit() {
    const {
      parentInstance
    } = rxcomp.getContext(this);
    if (parentInstance instanceof ModalOutletComponent) {
      this.data = parentInstance.modal.data;
    }
  }
  onClose() {
    ModalService.reject();
  }
}
ModalComponent.meta = {
  selector: '[modal]'
};class RouterLinkDirective extends rxcomp.Directive {
  constructor() {
    super(...arguments);
    this.path = void 0;
    this.segments = void 0;
    this.routerLink_ = void 0;
  }
  get routerLink() {
    return this.routerLink_;
  }
  set routerLink(routerLink) {
    this.routerLink_ = Array.isArray(routerLink) ? routerLink : [routerLink];
    // this.segments = this.getSegments(this.routerLink_);
  }

  onInit() {
    // const { node, module } = getContext(this);
    // console.log('RouterLinkDirective.onInit', this.routerLink, node, module);
    this.routerLink$().pipe(operators.takeUntil(this.unsubscribe$)).subscribe();
  }
  onChanges() {
    const {
      node
    } = rxcomp.getContext(this);
    // const routerLink = Array.isArray(this.routerLink) ? this.routerLink : [this.routerLink];
    const routerLink = this.routerLink;
    if (routerLink.length) {
      const routeUrl = RouterService.buildUrl(...routerLink);
      // RouterService.isActive(name, params, [strictEquality], [ignoreQueryParams])
      // console.log('RouterLinkDirective.routeUrl', routeUrl);
      node.setAttribute('href', routeUrl);
    } else {
      node.setAttribute('href', '');
    }
  }
  routerLink$() {
    const {
      node
    } = rxcomp.getContext(this);
    return rxjs.fromEvent(node, 'click').pipe(operators.map(event => {
      // console.log('RouterLinkDirective.routerLink$', this.routerLink);
      RouterService.setRouterLink(...this.routerLink);
      event.preventDefault();
      return false;
    }));
  }
  getSegments(routerLink) {
    // console.log('RouterLinkDirective.getSegments', routerLink);
    const segments = [];
    routerLink.forEach(item => {
      if (typeof item === 'string') {
        // eslint-disable-next-line no-useless-escape
        const regExp = /([^:]+)|\:([^\/]+)/g;
        const matches = item.matchAll(regExp);
        for (let match of matches) {
          const g1 = match[1];
          const g2 = match[2];
          if (g1) ; else if (g2) {
            const param = {};
            param[g2] = null;
          }
        }
      } else {
        // !!! todo fix RouteSegment
        segments.push(new RouteSegment('', {}));
      }
    });
    return segments;
  }
}

/*
get urlTree(): UrlTree {
	return RouterService.createUrlTree(this.routerLink, {
		relativeTo: this.route,
		queryParams: this.queryParams,
		fragment: this.fragment,
		preserveQueryParams: this.preserve,
		queryParamsHandling: this.queryParamsHandling,
		preserveFragment: this.preserveFragment,
	});
}
*/
RouterLinkDirective.meta = {
  selector: '[routerLink]',
  inputs: ['routerLink']
};class SupportRequestModalComponent extends rxcomp.Component {
  onInit() {
    super.onInit();
    const {
      parentInstance
    } = rxcomp.getContext(this);
    if (parentInstance instanceof ModalOutletComponent) {
      this.data = parentInstance.modal.data;
    }
  }
  onAccept(user) {
    ModalService.resolve();
  }
  onReject(user) {
    ModalService.reject();
  }
  onClose() {
    ModalService.reject();
  }
}
SupportRequestModalComponent.meta = {
  selector: '[support-request-modal]',
  template: /* html */`
		<div class="modal__header">
			<button type="button" class="btn--close" (click)="onClose()">
				<svg width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#close"></use></svg>
			</button>
		</div>
		<div class="container">
			<div class="form">
				<div class="title">Un operatore è disponibile per un tour guidato.<br>Desideri Accettare?</div>
				<div class="group--cta">
					<button type="button" class="btn--accept" (click)="onAccept()">
						<span>Accetta</span>
					</button>
					<button type="button" class="btn--cancel" (click)="onReject()">
						<span>Rifiuta</span>
					</button>
				</div>
			</div>
		</div>
	`
};
SupportRequestModalComponent.chunk = () => /* html */'<div class="support-request-modal" support-request-modal></div>';class SvgIconStructure extends rxcomp.Structure {
  onInit() {
    this.update();
  }
  onChanges() {
    this.update();
  }
  update() {
    if (this.name_ !== this.name) {
      this.name_ = this.name;
      const {
        node
      } = rxcomp.getContext(this);
      if (node.parentNode) {
        const xmlns = 'http://www.w3.org/2000/svg';
        const element = document.createElementNS(xmlns, 'svg');
        const w = this.width || 24;
        const h = this.height || 24;
        element.setAttribute('class', `icon--${this.name}`);
        // element.setAttributeNS(null, 'width', w);
        // element.setAttributeNS(null, 'height', h);
        element.setAttributeNS(null, 'viewBox', `0 0 ${w} ${h}`);
        element.innerHTML = `<use xlink:href="#${this.name}"></use>`;
        element.rxcompId = node.rxcompId;
        element.classList.add(...node.classList);
        node.parentNode.replaceChild(element, node);
      }
    }
  }
}
SvgIconStructure.meta = {
  selector: 'svg-icon',
  inputs: ['name', 'width', 'height']
};

/*
<svg class="copy" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#copy"></use></svg>
*/class TitleDirective extends rxcomp.Directive {
  set title(title) {
    if (this.title_ !== title) {
      this.title_ = title;
      const {
        node
      } = rxcomp.getContext(this);
      title ? node.setAttribute('title', title) : node.removeAttribute('title');
    }
  }
  get title() {
    return this.title_;
  }
}
TitleDirective.meta = {
  selector: '[[title]]',
  inputs: ['title']
};class UploadItemComponent extends rxcomp.Component {
  onInit() {
    // console.log('UploadItemComponent.onInit', this.item);
    if (this.item.preview === null) {
      this.read$(this.item.file).pipe(operators.takeUntil(this.unsubscribe$)).subscribe(preview => {
        this.item.preview = preview;
        this.pushChanges();
      });
    }
  }
  read$(file) {
    const reader = new FileReader();
    const reader$ = rxjs.fromEvent(reader, 'load').pipe(operators.switchMap(event => {
      const blob = event.target.result;
      if (this.item.type.name === AssetType.Image.name) {
        return this.resize$(blob);
      } else {
        return rxjs.of(blob);
      }
    }));
    reader.readAsDataURL(file);
    return reader$;
  }
  resize$(blob) {
    return new Promise((resolve, reject) => {
      const img = document.createElement('img');
      img.onload = function () {
        const MAX_WIDTH = 320;
        const MAX_HEIGHT = 240;
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        let width = img.width;
        let height = img.height;
        if (width > height) {
          if (width > MAX_WIDTH) {
            height *= MAX_WIDTH / width;
            width = MAX_WIDTH;
          }
        } else {
          if (height > MAX_HEIGHT) {
            width *= MAX_HEIGHT / height;
            height = MAX_HEIGHT;
          }
        }
        canvas.width = width;
        canvas.height = height;
        ctx.drawImage(img, 0, 0, width, height);
        const dataUrl = canvas.toDataURL('image/jpeg', 0.9);
        resolve(dataUrl);
      };
      img.onerror = function (error) {
        reject(error);
      };
      img.src = blob;
    });
  }
  onPause() {
    this.pause.next(this.item);
  }
  onResume() {
    this.resume.next(this.item);
  }
  onCancel() {
    this.cancel.next(this.item);
  }
  onRemove() {
    this.remove.next(this.item);
  }
}
UploadItemComponent.meta = {
  selector: '[upload-item]',
  outputs: ['pause', 'resume', 'cancel', 'remove'],
  inputs: ['item'],
  template: /* html */`
	<div class="upload-item" [class]="{ 'error': item.error, 'success': item.success }">
		<div class="picture">
			<img [lazy]="item.preview" [size]="{ width: 320, height: 240 }" *if="item.preview && item.type.name === 'image'" />
			<video [src]="item.preview" *if="item.preview && item.type.name === 'video'"></video>
			<svg class="spinner" width="24" height="24" viewBox="0 0 24 24" [class]="{ uploading: item.uploading }" *if="item.uploading"><use xlink:href="#spinner"></use></svg>
		</div>
		<div class="name">{{item.name}}</div>
		<!--
		<div class="group--info">
			<div>progress: {{item.progress}}</div>
			<div>size: {{item.size}} bytes</div>
			<div>current speed: {{item.currentSpeed}} bytes/s</div>
			<div>average speed: {{item.averageSpeed}} bytes/s</div>
			<div>time ramining: {{item.timeRemaining}}s</div>
			<div>paused: {{item.paused}}</div>
			<div>success: {{item.success}}</div>
			<div>complete: {{item.complete}}</div>
			<div>error: {{item.error}}</div>
		</div>
		-->
		<!--
		<div class="group--cta" *if="!item.complete && item.uploading">
			<div class="btn--pause" (click)="onPause()">pause</div>
			<div class="btn--resume" (click)="onResume()">resume</div>
			<div class="btn--cancel" (click)="onCancel()">cancel</div>
		</div>
		-->
		<div class="group--cta">
			<div class="btn--remove" (click)="onRemove()" *if="!item.complete">remove</div>
		</div>
	</div>
	`
};class HlsDirective extends rxcomp.Directive {
  set hls(hls) {
    if (this.hls_ !== hls) {
      this.hls_ = hls;
      this.play(hls);
    }
  }
  get hls() {
    return this.hls_;
  }
  play(src) {
    const {
      node
    } = rxcomp.getContext(this);
    if (Hls.isSupported()) {
      var hls = new Hls();
      // bind them together
      hls.attachMedia(node);
      hls.on(Hls.Events.MEDIA_ATTACHED, () => {
        hls.loadSource(src);
        hls.on(Hls.Events.MANIFEST_PARSED, (event, data) => {
          // console.log('HlsDirective', data.levels);
          node.play();
        });
      });
    }
  }
}
HlsDirective.meta = {
  selector: '[[hls]]',
  inputs: ['hls']
};class VirtualItem extends rxcomp.Context {
  constructor(key, $key, value, $value, index, count, parentInstance) {
    super(parentInstance);
    this[key] = $key;
    this[value] = $value;
    this.index = index;
    this.count = count;
  }
  get first() {
    return this.index === 0;
  }
  get last() {
    return this.index === this.count - 1;
  }
  get even() {
    return this.index % 2 === 0;
  }
  get odd() {
    return !this.even;
  }
}const VirtualMode = {
  Responsive: 1,
  Grid: 2,
  Centered: 3,
  List: 4
};
class VirtualStructure extends rxcomp.Structure {
  onInit() {
    const {
      module,
      node
    } = rxcomp.getContext(this);
    const template = node.firstElementChild;
    const expression = node.getAttribute('*virtual');
    node.removeAttribute('*virtual');
    node.removeChild(template);
    const tokens = this.tokens = this.getExpressionTokens(expression);
    this.virtualFunction = module.makeFunction(tokens.iterable);
    this.container = node;
    this.template = template;
    this.mode = this.mode || 1;
    this.width = this.width || 250;
    this.gutter = this.gutter !== undefined ? this.gutter : 20;
    this.reverse = this.reverse === true ? true : false;
    this.options = {
      width: this.width,
      gutter: this.gutter,
      reverse: this.reverse,
      containerWidth: 0,
      containerHeight: 0,
      top: 0,
      cols: [0]
    };
    this.cachedRects = {};
    this.cachedInstances = [];
    this.cacheNodes = [];
    this.items$ = new rxjs.BehaviorSubject([]);
    this.update$().pipe(operators.takeUntil(this.unsubscribe$)).subscribe(visibleItems => {
      // console.log(visibleItems.length);
    });
  }
  onChanges(changes) {
    const context = rxcomp.getContext(this);
    const module = context.module;
    // resolve
    const items = module.resolve(this.virtualFunction, context.parentInstance, this) || [];
    this.mode = this.mode || 1;
    this.width = this.width || 250;
    this.gutter = this.gutter !== undefined ? this.gutter : 20;
    this.options.width = this.width;
    this.updateView(true);
    this.items$.next(items);
    // console.log('VirtualStructure', 'items.length', items.length);
  }

  update$() {
    this.updateView(true);
    return rxjs.merge(this.scroll$(), this.resize$(), this.items$.pipe(operators.distinctUntilChanged())).pipe(operators.map(_ => {
      const visibleItems = this.updateForward();
      return visibleItems;
    }));
  }
  updateForward() {
    const options = this.options;
    const items = this.items$.getValue();
    const total = items.length;
    this.container.position = 'relative';
    let highestHeight = 0;
    const width = this.getWidth();
    const gutter = this.getGutter(width);
    const visibleItems = [];
    for (let i = 0, len = items.length; i < len; i++) {
      const item = items[i];
      let col, height, top, left, bottom;
      let rect = this.cachedRects[i];
      if (rect) {
        col = rect.col;
        height = rect.height;
        left = rect.left;
        // top = rect.top;
        // bottom = rect.bottom;
      } else {
        col = this.getCol();
        height = this.getHeight(width, item);
      }
      top = options.cols[col];
      if (this.intersect(top + options.top, top + height + options.top, 0, options.containerHeight)) {
        if (!rect) {
          left = this.getLeft(col, width, gutter);
        }
        const node = this.cachedNode(i, i, item, total);
        node.style.position = 'absolute';
        node.style.top = top + 'px';
        node.style.left = left + 'px';
        node.style.width = width + 'px';
        if (height !== node.offsetHeight) {
          height = node.offsetHeight;
        }
        bottom = top + height + options.gutter;
        highestHeight = Math.max(highestHeight, bottom);
        options.cols[col] = bottom;
        if (!rect) {
          this.cachedRects[i] = {
            col,
            width,
            height,
            left,
            top,
            bottom
          };
        } else {
          rect.height = height;
          rect.bottom = bottom;
        }
        visibleItems.push(item);
      } else {
        this.removeNode(i);
        bottom = top + height + options.gutter;
        options.cols[col] = bottom;
        highestHeight = Math.max(highestHeight, bottom);
      }
    }
    let removeIndex = items.length;
    while (removeIndex < this.cacheNodes.length) {
      this.removeNode(removeIndex);
      removeIndex++;
    }
    this.cacheNodes.length = items.length;
    const parentContainer = this.container.parentNode;
    if (this.reverse && highestHeight < parentContainer.offsetHeight - 1) {
      const diff = parentContainer.offsetHeight - 1 - highestHeight;
      items.forEach((item, i) => {
        if (visibleItems.indexOf(item) !== -1) {
          const rect = this.cachedRects[i];
          const node = this.cachedNode(i, i, item, total);
          node.style.top = rect.top + diff + 'px';
        }
      });
      this.container.style.height = `${parentContainer.offsetHeight - 1}px`;
    } else {
      this.container.style.height = `${highestHeight}px`;
    }
    // console.log('VirtualStructure.updateForward', 'items.length', items.length, highestHeight, visibleItems);
    return visibleItems;
  }

  /*
  updateForward__() {
  	const options = this.options;
  	const items = this.items$.getValue();
  	// console.log('VirtualStructure', 'items.length', items.length);
  	const total = items.length;
  	this.container.position = 'relative';
  	let highestHeight = 0;
  	const width = this.getWidth();
  	const gutter = this.getGutter(width);
  	const visibleItems = items.filter((item, i) => {
  		let col, height, top, left, bottom;
  		let rect = this.cachedRects[i];
  		if (rect) {
  			col = rect.col;
  			height = rect.height;
  			left = rect.left;
  			// top = rect.top;
  			// bottom = rect.bottom;
  		} else {
  			col = this.getCol();
  			height = this.getHeight(width, item);
  		}
  		top = options.cols[col];
  		if (this.intersect(top + options.top, top + height + options.top, options.top, options.top + options.containerHeight)) {
  			if (!rect) {
  				left = this.getLeft(col, width, gutter);
  			}
  			const node = this.cachedNode(i, i, item, total);
  			node.style.position = 'absolute';
  			node.style.top = top + 'px';
  			node.style.left = left + 'px';
  			node.style.width = width + 'px';
  			if (height !== node.offsetHeight) {
  				height = node.offsetHeight;
  			}
  			bottom = top + height + options.gutter;
  			highestHeight = Math.max(highestHeight, bottom);
  			options.cols[col] = bottom;
  			if (!rect) {
  				this.cachedRects[i] = { col, width, height, left, top, bottom };
  			} else {
  				rect.height = height;
  				rect.bottom = bottom;
  			}
  			return true;
  		} else {
  			this.removeNode(i);
  			bottom = top + height + options.gutter;
  			options.cols[col] = bottom;
  			highestHeight = Math.max(highestHeight, bottom);
  			return false;
  		}
  	});
  	let removeIndex = items.length;
  	while (removeIndex < this.cacheNodes.length) {
  		this.removeNode(removeIndex);
  		removeIndex++;
  	}
  	this.cacheNodes.length = items.length;
  	this.container.style.height = `${highestHeight}px`;
  	return visibleItems;
  }
  
  updateBackward__() {
  	const options = this.options;
  	const items = this.items$.getValue();
  	// console.log('VirtualStructure', 'items.length', items.length);
  	const total = items.length;
  	this.container.position = 'relative';
  	let lowestHeight = 0;
  	const width = this.getWidth();
  	const gutter = this.getGutter(width);
  	const visibleItems = [];
  	for (let i = items.length - 1; i >= 0; i--) {
  		const item = items[i];
  		let col, height, top, left, bottom;
  		let rect = this.cachedRects[i];
  		if (rect) {
  			col = rect.col;
  			height = rect.height;
  			left = rect.left;
  			// top = rect.top;
  			// bottom = rect.bottom;
  		} else {
  			col = this.getCol();
  			height = this.getHeight(width, item);
  		}
  		bottom = options.cols[col];
  		if (this.intersect(bottom - height + options.top, bottom + options.top, options.top, options.top + options.containerHeight)) {
  			if (!rect) {
  				left = this.getLeft(col, width, gutter);
  			}
  			const node = this.cachedNode(i, i, item, total);
  			node.style.position = 'absolute';
  			node.style.top = top + 'px';
  			node.style.left = left + 'px';
  			node.style.width = width + 'px';
  			if (height !== node.offsetHeight) {
  				height = node.offsetHeight;
  			}
  			top = bottom - height - options.gutter;
  			lowestHeight = Math.min(lowestHeight, -top);
  			options.cols[col] = top;
  			if (!rect) {
  				this.cachedRects[i] = { col, width, height, left, top, bottom: bottom };
  			} else {
  				rect.height = height;
  				rect.top = top;
  			}
  			visibleItems.push(item);
  		} else {
  			this.removeNode(i);
  			top = bottom - height - options.gutter;
  			options.cols[col] = top;
  			lowestHeight = Math.min(lowestHeight, top);
  		}
  	}
  	let removeIndex = items.length;
  	while (removeIndex < this.cacheNodes.length) {
  		this.removeNode(removeIndex);
  		removeIndex++;
  	}
  	this.cacheNodes.length = items.length;
  	this.container.style.height = `${-lowestHeight}px`;
  	return visibleItems;
  }
  */

  getCols() {
    const options = this.options;
    const cols = Math.floor((options.containerWidth + options.gutter) / (options.width + options.gutter)) || 1;
    return new Array(cols).fill(0);
  }
  getCol() {
    const options = this.options;
    let col;
    switch (this.mode) {
      case VirtualMode.Grid:
      case VirtualMode.Centered:
      case VirtualMode.Responsive:
        col = options.cols.reduce((p, c, i, a) => {
          return c < a[p] ? i : p;
        }, 0);
        break;
      case VirtualMode.List:
      default:
        col = 0;
    }
    return col;
  }
  getWidth() {
    const options = this.options;
    let width;
    switch (this.mode) {
      case VirtualMode.Grid:
      case VirtualMode.Centered:
        width = options.width;
        break;
      case VirtualMode.Responsive:
        width = (options.containerWidth - (options.cols.length - 1) * options.gutter) / options.cols.length;
        break;
      case VirtualMode.List:
      default:
        width = options.containerWidth;
    }
    return width;
  }
  getHeight(width, item) {
    const options = this.options;
    let height;
    switch (this.mode) {
      case VirtualMode.Grid:
      case VirtualMode.Centered:
      case VirtualMode.Responsive:
        height = options.width;
        break;
      case VirtualMode.List:
      default:
        height = 80;
    }
    return height;
  }
  getGutter(width) {
    const options = this.options;
    let gutter;
    switch (this.mode) {
      case VirtualMode.Grid:
      case VirtualMode.Centered:
        gutter = options.gutter;
        break;
      case VirtualMode.Responsive:
        gutter = (options.containerWidth - options.cols.length * width) / (options.cols.length - 1);
        break;
      case VirtualMode.List:
      default:
        gutter = 0;
    }
    return gutter;
  }
  getLeft(index, width, gutter) {
    const options = this.options;
    let left;
    switch (this.mode) {
      case VirtualMode.Grid:
      case VirtualMode.Responsive:
        left = index * (width + gutter);
        break;
      case VirtualMode.Centered:
        left = (options.containerWidth - options.cols.length * (width + gutter) + gutter) / 2 + index * (width + gutter);
        break;
      case VirtualMode.List:
      default:
        left = 0;
    }
    return left;
  }
  cachedNode(index, i, value, total) {
    if (this.cacheNodes[index]) {
      return this.updateNode(index, i, value);
    } else {
      return this.createNode(index, i, value, total);
    }
  }
  createNode(index, i, value, total) {
    const clonedNode = this.template.cloneNode(true);
    delete clonedNode.rxcompId;
    this.container.appendChild(clonedNode);
    this.cacheNodes[index] = clonedNode;
    const context = rxcomp.getContext(this);
    const module = context.module;
    const tokens = this.tokens;
    const args = [tokens.key, i, tokens.value, value, i, total, context.parentInstance];
    const instance = module.makeInstance(clonedNode, VirtualItem, context.selector, context.parentInstance, args);
    const forItemContext = rxcomp.getContext(instance);
    module.compile(clonedNode, forItemContext.instance);
    this.cachedInstances[index] = instance;
    return clonedNode;
  }
  updateNode(index, i, value) {
    const instance = this.cachedInstances[index];
    const tokens = this.tokens;
    if (instance[tokens.key] !== i) {
      instance[tokens.key] = i;
      instance[tokens.value] = value;
      instance.pushChanges();
    }
    // console.log(index, i, value);
    return this.cacheNodes[index];
  }
  removeNode(index) {
    this.cachedInstances[index] = undefined;
    const node = this.cacheNodes[index];
    if (node) {
      const context = rxcomp.getContext(this);
      const module = context.module;
      node.parentNode.removeChild(node);
      module.remove(node);
    }
    this.cacheNodes[index] = undefined;
    return node;
  }
  intersect(top1, bottom1, top2, bottom2) {
    // console.log(top2, '<', bottom1, bottom2, '>', top1);
    return top2 < bottom1 && bottom2 > top1;
  }
  resize$() {
    return rxjs.fromEvent(window, 'resize').pipe(operators.startWith(_ => null), operators.auditTime(100), operators.tap(() => this.updateView(true)));
  }
  scroll$() {
    const {
      node
    } = rxcomp.getContext(this);
    // console.log(node.parentNode, getComputedStyle(node.parentNode).overflowY, node.parentNode.style.overflowY);
    if (node.parentNode && getComputedStyle(node.parentNode).overflowY === 'auto') {
      return rxjs.fromEvent(node.parentNode, 'scroll').pipe(operators.tap(() => {
        this.updateView();
      }));
    } else {
      return rxjs.fromEvent(window, 'scroll').pipe(operators.tap(() => this.updateView()));
    }
  }
  updateView(reset) {
    const rect = this.container.getBoundingClientRect();
    const options = this.options;
    options.top = rect.top;
    options.containerWidth = rect.width;
    // options.containerHeight = rect.height;
    options.containerHeight = this.container.parentNode.offsetHeight;
    options.cols = this.getCols();
    if (reset) {
      this.cachedRects = {};
    }
  }
  getExpressionTokens(expression) {
    if (expression === null) {
      throw new Error('invalid virtual');
    }
    if (expression.trim().indexOf('let ') === -1 || expression.trim().indexOf(' of ') === -1) {
      throw new Error('invalid virtual');
    }
    const expressions = expression.split(';').map(x => x.trim()).filter(x => x !== '');
    const virtualExpressions = expressions[0].split(' of ').map(x => x.trim());
    let value = virtualExpressions[0].replace(/\s*let\s*/, '');
    const iterable = virtualExpressions[1];
    let key = 'index';
    const keyValueMatches = value.match(/\[(.+)\s*,\s*(.+)\]/);
    if (keyValueMatches) {
      key = keyValueMatches[1];
      value = keyValueMatches[2];
    }
    if (expressions.length > 1) {
      const indexExpressions = expressions[1].split(/\s*let\s*|\s*=\s*index/).map(x => x.trim());
      if (indexExpressions.length === 3) {
        key = indexExpressions[1];
      }
    }
    return {
      key,
      value,
      iterable
    };
  }
}
VirtualStructure.meta = {
  selector: '[*virtual]',
  inputs: ['mode', 'width', 'gutter', 'reverse']
};class MediaPlayerComponent extends rxcomp.Component {
  onInit() {
    // console.log('MediaPlayerComponent', this.media);
    this.playing = false;
    this.progress = 0;
    this.media$().pipe(operators.takeUntil(this.unsubscribe$)).subscribe();
    this.drag$().pipe(operators.takeUntil(this.unsubscribe$)).subscribe();
  }
  media$() {
    const {
      node
    } = rxcomp.getContext(this);
    const page = document.querySelector('.page');
    return MediaLoader.events$.pipe(
    // filter(event => event.loader.item.id === this.media.item.id),
    operators.tap(event => {
      if (event instanceof MediaLoaderPlayEvent) {
        this.media = event.loader;
        this.playing = true;
        node.classList.add('active');
        page.classList.add('media-player-active');
        this.pushChanges();
      } else if (this.media === event.loader) {
        if (event instanceof MediaLoaderPauseEvent) {
          this.playing = false;
          this.pushChanges();
        } else if (event instanceof MediaLoaderTimeUpdateEvent) {
          if (!this.dragging) {
            this.progress = this.media.progress;
            this.pushChanges();
          }
        } else if (event instanceof MediaLoaderDisposeEvent) {
          this.media = null;
          node.classList.remove('active');
          page.classList.remove('media-player-active');
          this.pushChanges();
        }
      }
      // console.log('MediaPlayerComponent.MediaLoader.events$', event);
    }));
  }

  drag$() {
    const {
      node
    } = rxcomp.getContext(this);
    const track = node.querySelector('.track');
    let initialProgress;
    return DragService.observe$(track).pipe(operators.filter(_ => this.media), operators.tap(event => {
      if (event instanceof DragDownEvent) {
        const rect = track.getBoundingClientRect();
        initialProgress = Math.max(0, Math.min(1, (event.down.x - rect.left) / rect.width));
        this.dragging = true;
      } else if (event instanceof DragMoveEvent) {
        const rect = track.getBoundingClientRect();
        const progress = Math.max(0, Math.min(1, initialProgress + event.distance.x / rect.width));
        this.progress = progress;
        this.pushChanges();
      } else if (event instanceof DragUpEvent) {
        this.media.progress = this.progress;
        this.dragging = false;
      }
    }));
  }
  onPlay() {
    this.media.play();
  }
  onPause() {
    this.media.pause();
  }
  onTrack(event) {
    const rect = event.currentTarget.getBoundingClientRect();
    const progress = (event.screenX - rect.left) / rect.width;
    this.media.progress = progress;
    // console.log(rect.left, event.screenX);
  }
}

MediaPlayerComponent.meta = {
  selector: '[media-player]'
};const PANEL_RADIUS$1 = PANORAMA_RADIUS - 0.01;
class ModelBannerComponent extends ModelComponent {
  get title() {
    return this.title_;
  }
  set title(title) {
    if (this.title_ !== title) {
      const init = this.title_ != null;
      this.title_ = title;
      if (!init) {
        this.createBanner();
      } else {
        this.updateBanner();
      }
    }
  }

  /*
  onInit() {
  	super.onInit();
  	// console.log('ModelBannerComponent.onInit', this.item);
  }
  
  onView() {
  	// console.log('ModelBannerComponent.onView', this.item);
  	if (this.viewed) {
  		return;
  	}
  	this.viewed = true;
  	// this.createBanner();
  }
  */

  onChanges() {
    // console.log('ModelBannerComponent.onChanges', this.item);
    this.title = this.item.title;
  }
  createBanner() {
    this.getCanvasTexture().then(result => {
      const texture = result.texture;
      const repeat = 24;
      texture.wrapS = texture.wrapY = THREE.RepeatWrapping;
      texture.repeat.x = repeat;
      texture.encoding = THREE.sRGBEncoding;
      const aspect = result.width * repeat / result.height;
      const arc = Math.PI / 180 * 360;
      const width = PANEL_RADIUS$1 * arc;
      const height = width / aspect;
      const geometry = new THREE.CylinderBufferGeometry(PANEL_RADIUS$1, PANEL_RADIUS$1, height, 80, 2, true, 0, arc);
      geometry.scale(-1, 1, 1);
      const material = new THREE.MeshBasicMaterial({
        map: texture,
        transparent: true,
        opacity: 0,
        toneMapped: false
        // side: THREE.DoubleSide,
      });

      const mesh = this.mesh;
      const banners = this.banners = new Array(1).fill(0).map(x => new THREE.Mesh(geometry, material));
      banners.forEach((banner, i) => {
        banner.rotation.y = Math.PI / 2 * i;
        // !!!
        // mesh.add(banner);
      });

      const from = {
        value: 0
      };
      gsap.to(from, {
        duration: 0.5,
        value: 1,
        delay: 0.0,
        ease: Power2.easeInOut,
        onUpdate: () => {
          material.opacity = from.value;
          material.needsUpdate = true;
        }
      });
      mesh.userData = {
        render: () => {
          mesh.rotation.y += Math.PI / 180 * 0.02;
          // texture.offset.x = (texture.offset.x - 0.01) % 1;
          material.needsUpdate = true;
        }
      };
    });
  }
  updateBanner() {
    this.getCanvasTexture().then(result => {
      // console.log('ModelBannerComponent.updateBanner', result);
    });
  }

  /*
  onViewBak() {
  	if (this.viewed) {
  		return;
  	}
  	this.viewed = true;
  	this.getCanvasTexture().then(result => {
  		const texture = result.texture;
  		const repeat = 3;
  		texture.wrapS = texture.wrapY = THREE.RepeatWrapping;
  		texture.repeat.x = repeat;
  		texture.encoding = THREE.sRGBEncoding;
  		const aspect = (result.width * repeat) / result.height;
  		const arc = Math.PI / 180 * 45;
  		const width = PANEL_RADIUS * arc;
  		const height = width / aspect;
  		const geometry = new THREE.CylinderBufferGeometry(PANEL_RADIUS, PANEL_RADIUS, height, 20, 2, true, 0, arc);
  		geometry.scale(-1, 1, 1);
  		const material = new THREE.MeshBasicMaterial({
  			map: texture,
  			transparent: true,
  			opacity: 0,
  			// side: THREE.DoubleSide,
  		});
  		const mesh = this.mesh;
  		const banners = this.banners = new Array(4).fill(0).map(x => new THREE.Mesh(geometry, material));
  		banners.forEach((banner, i) => {
  			banner.rotation.y = Math.PI / 2 * i;
  			mesh.add(banner);
  		});
  		const from = { value: 0 };
  		gsap.to(from, {
  			duration: 0.5,
  			value: 1,
  			delay: 0.0,
  			ease: Power2.easeInOut,
  			onUpdate: () => {
  				material.opacity = from.value;
  				material.needsUpdate = true;
  			}
  		});
  		mesh.userData = {
  			render: () => {
  				mesh.rotation.y += Math.PI / 180 * 0.2;
  				texture.offset.x = (texture.offset.x - 0.01) % 1;
  				material.needsUpdate = true;
  			}
  		};
  	});
  }
  */

  onCreate(mount, dismount) {
    const mesh = new THREE.Group();
    if (typeof mount === 'function') {
      mount(mesh);
    }
  }
  getCanvasTexture() {
    return new Promise((resolve, reject) => {
      const MIN_W = 512;
      let W = MIN_W;
      let H = 128;
      const F = Math.floor(H * 0.8);
      const L = Math.floor(H * 0.075);
      let canvas;
      if (this.canvas) {
        canvas = this.canvas;
      } else {
        canvas = this.canvas = document.createElement('canvas');
        // canvas.classList.add('canvas--debug');
        // document.querySelector('body').appendChild(canvas);
      }

      canvas.width = W;
      canvas.height = H;
      const text = this.item.title;
      const ctx = canvas.getContext('2d');
      // const ctx = text.material.map.image.getContext('2d');
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = 'high';
      ctx.font = `${F}px ${environment.fontFamily}`;
      const metrics = ctx.measureText(text);
      W = metrics.width + 8;
      W = Math.max(MIN_W, Math.pow(2, Math.ceil(Math.log(W) / Math.log(2))));
      // const x = W / 2;
      // const y = 16;
      canvas.width = W;
      ctx.clearRect(0, 0, W, H);
      ctx.fillStyle = '#0000005A'; // 35% // '#000000C0'; // 75%
      ctx.fillRect(0, 0, W, H);
      ctx.font = `${F}px ${environment.fontFamily}`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.strokeStyle = 'rgba(0, 0, 0, 0.5)';
      ctx.lineWidth = L;
      ctx.lineJoin = 'round'; // Experiment with 'bevel' & 'round' for the effect you want!
      ctx.miterLimit = 2;
      ctx.strokeText(text, W / 2, H / 2);
      ctx.fillStyle = 'white';
      ctx.fillText(text, W / 2, H / 2, W);
      // text.material.map.needsUpdate = true;
      let texture;
      if (this.texture) {
        texture = this.texture;
        texture.needsUpdate = true;
      } else {
        texture = this.texture = new THREE.CanvasTexture(canvas);
      }
      // console.log(F, L, W, H);
      resolve({
        texture: texture,
        width: W,
        height: H
      });
    });
  }

  /*
  getCanvasTexture_() {
  	return new Promise((resolve, reject) => {
  		if (this.item.bannerTexture) {
  			resolve(this.item.bannerTexture);
  		} else {
  			const { node } = getContext(this);
  			setTimeout(() => {
  				html2canvas(node, {
  					backgroundColor: '#00000000', // '#000000ff',
  					scale: 2,
  				}).then(canvas => {
  					// !!!
  					// document.body.appendChild(canvas);
  					// const alpha = this.getAlphaFromCanvas(canvas);
  					// document.body.appendChild(alpha);
  					const texture = new THREE.CanvasTexture(canvas);
  					// const alphaMap = new THREE.CanvasTexture(alpha);
  					this.item.bannerTexture = {
  						texture: texture,
  						width: canvas.width,
  						height: canvas.height,
  					};
  					resolve(this.item.bannerTexture);
  				}, error => {
  					reject(error);
  				});
  			}, 1);
  		}
  	});
  }
  */
}

ModelBannerComponent.meta = {
  selector: '[model-banner]',
  hosts: {
    host: WorldComponent
  },
  inputs: ['item']
};class ModelCurvedPlaneComponent extends ModelEditableComponent {
  onInit() {
    super.onInit();
    // console.log('ModelCurvedPlaneComponent.onInit');
  }

  onChanges() {
    const selected = this.item.selected;
    this.editing = selected;
    if (this.mesh) {
      this.mesh.editing = selected;
    }
  }
  onCreate(mount, dismount) {
    const item = this.item;
    const view = this.view;
    view.items;
    const geometry = this.getCurvedPanelGeometry(item);
    this.onMeshDown = this.onMeshDown.bind(this);
    this.onMeshPlaying = this.onMeshPlaying.bind(this);
    this.onMeshZoomed = this.onMeshZoomed.bind(this);
    this.onMeshCurrentTime = this.onMeshCurrentTime.bind(this);
    let mesh;
    let subscription;
    MediaMesh.getStreamId$(item).pipe(operators.takeUntil(this.unsubscribe$)).subscribe(streamId => {
      if (this.streamId !== streamId) {
        this.streamId = streamId;
        // !!! called by ModelComponent
        /*
        if (mesh) {
        	dismount(mesh, item);
        }
        */
        if (subscription) {
          subscription.unsubscribe();
          subscription = null;
        }
        // console.log('ModelCurvedPanel', streamId, item.asset)
        if (streamId || !item.asset) {
          item.streamId = streamId;
          mesh = this.disposableMesh = new MediaMesh(item, view, geometry, this.host);
          mesh.updateFromItem(item);
          mesh.name = 'curved-plane';
          mesh.load(() => {
            this.disposableMesh = null;
            if (typeof mount === 'function') {
              mount(mesh, item);
            }
            subscription = mesh.events$().pipe(operators.takeUntil(this.unsubscribe$)).subscribe(() => {});
          });
          this.addMeshListeners(mesh);
        } else if (this.mesh) {
          dismount(this.mesh, item);
        }
        // console.log('streamId', streamId, mesh);
      }
    });
  }

  addMeshListeners(mesh) {
    mesh.on('down', this.onMeshDown);
    mesh.on('playing', this.onMeshPlaying);
    mesh.on('zoomed', this.onMeshZoomed);
    mesh.on('currentTime', this.onMeshCurrentTime);
  }
  removeMeshListeners(mesh) {
    mesh.off('down', this.onMeshDown);
    mesh.off('playing', this.onMeshPlaying);
    mesh.off('zoomed', this.onMeshZoomed);
    mesh.off('currentTime', this.onMeshCurrentTime);
  }
  onMeshDown() {
    // console.log('ModelCurvedPanelComponent.onMeshDown');
    this.down.next(this);
  }
  onMeshPlaying(playing) {
    // console.log('ModelCurvedPanelComponent.playing', playing);
    this.play.next({
      itemId: this.item.id,
      playing
    });
  }
  onMeshZoomed(zoomed) {
    // console.log('ModelCurvedPanelComponent.zoomed', zoomed);
    this.zoom.next({
      itemId: this.item.id,
      zoomed
    });
  }
  onMeshCurrentTime(currentTime) {
    // console.log('ModelCurvedPanelComponent.playing', playing);
    this.currentTime.next({
      itemId: this.item.id,
      currentTime
    });
  }
  onDestroy() {
    // console.log('ModelCurvedPlaneComponent.onDestroy');
    super.onDestroy();
    if (this.disposableMesh) {
      this.removeMeshListeners(this.disposableMesh);
      this.disposableMesh.dispose();
    }
    if (this.mesh) {
      this.removeMeshListeners(this.mesh);
      this.mesh.dispose();
    }
  }

  // called by UpdateViewItemComponent
  onUpdate(item, mesh) {
    // console.log('ModelCurvedPlaneComponent.onUpdate', item);
    // !!! true
    if ((item.radius !== this.radius_ || item.height !== this.height_ || item.arc !== this.arc_)) {
      mesh.geometry.dispose();
      const geometry = this.getCurvedPanelGeometry(item);
      mesh.geometry = geometry;
    }
    mesh.updateFromItem(item);
    this.updateHelper();
  }

  // called by UpdateViewItemComponent
  onUpdateAsset(item, mesh) {
    // console.log('ModelCurvedPlaneComponent.onUpdateAsset', item);
    mesh.updateByItem(item);
    MediaMesh.getStreamId$(item).pipe(operators.filter(streamId => streamId !== null), operators.take(1)).subscribe(streamId => {
      item.streamId = streamId;
      mesh.load(() => {
        // console.log('ModelCurvedPlaneComponent.mesh.load.complete');
      });
    });
  }

  // called by WorldComponent
  onDragMove(position, normal, spherical) {
    // console.log('ModelCurvedPlaneComponent.onDragMove', position, normal, spherical);
    const item = this.item;
    const mesh = this.mesh;
    item.showPanel = false;
    this.editing = true;
    mesh.position.set(position.x, position.y, position.z);
    if (spherical) {
      position.normalize().multiplyScalar(20);
      mesh.lookAt(Host.origin);
    } else {
      mesh.position.set(0, 0, 0);
      mesh.lookAt(normal);
      mesh.position.set(position.x, position.y, position.z);
      mesh.position.add(normal.multiplyScalar(0.01));
    }
    this.updateHelper();
  }

  // called by WorldComponent
  onDragEnd() {
    const item = this.item;
    const mesh = this.mesh;
    item.position = mesh.position.toArray();
    item.rotation = mesh.rotation.toArray();
    item.scale = mesh.scale.toArray();
    mesh.updateFromItem(item);
    this.editing = false;
  }
  getCurvedPanelGeometry(item) {
    this.radius_ = item.radius;
    this.height_ = item.height;
    this.arc_ = item.arc;
    const arc = Math.PI / 180 * item.arc;
    const geometry = new THREE.CylinderBufferGeometry(item.radius, item.radius, item.height, 36, 2, true, 0, arc);
    geometry.rotateY(-Math.PI - arc / 2);
    geometry.scale(-1, 1, 1);
    return geometry;
  }
}
ModelCurvedPlaneComponent.textures = {};
ModelCurvedPlaneComponent.meta = {
  selector: '[model-curved-plane]',
  hosts: {
    host: WorldComponent
  },
  outputs: ['down', 'play', 'zoom', 'currentTime'],
  inputs: ['item', 'view']
};class DebugService {
  static getService() {
    if (!this.service_) {
      this.service_ = new DebugService();
    }
    return this.service_;
  }
  get message() {
    return this.message$.getValue();
  }
  constructor() {
    if (DebugService.service_) {
      throw 'DebugService is a singleton class!';
    }
    this.message$ = new rxjs.BehaviorSubject(null);
  }
  setMessage(message) {
    if (this.message !== message) {
      this.message$.next(message);
    }
  }
}class ModelDebugComponent extends ModelComponent {
  static getLoader() {
    return ModelDebugComponent.loader || (ModelDebugComponent.loader = new THREE.FontLoader());
  }
  static getFontLoader(callback) {
    return ModelDebugComponent.fontLoader || (ModelDebugComponent.fontLoader = ModelDebugComponent.getLoader().load(environment.getPath('fonts/helvetiker/helvetiker_regular.typeface.json'), callback));
  }
  get message() {
    return this.message_;
  }
  set message(message) {
    message = message && message !== '' ? message : null;
    if (this.message_ !== message) {
      this.message_ = message;
      // console.log('ModelDebugComponent.set.message', message);
      this.setText(message);
      /*
      if (this.font) {
      	this.setText(message);
      }
      */
    }
  }

  onInit() {
    super.onInit();
    // console.log('ModelDebugComponent.onInit');
    // this.loadFont();
    const vrService = this.vrService = VRService.getService();
    vrService.session$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(session => {
      if (session) {
        if (this.text) {
          this.textGroup.add(this.text);
        }
      } else {
        if (this.text) {
          this.text.parent.remove(this.text);
        }
      }
    });
    const debugService = this.debugService = DebugService.getService();
    debugService.message$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(message => this.message = message);
  }
  createText() {
    const canvas = document.createElement('canvas');
    // document.querySelector('body').appendChild(canvas);
    canvas.width = ModelDebugComponent.W;
    canvas.height = ModelDebugComponent.H;
    const texture = new THREE.CanvasTexture(canvas);
    texture.encoding = THREE.sRGBEncoding;
    texture.minFilter = THREE.LinearFilter;
    texture.magFilter = THREE.LinearFilter;
    texture.mapping = THREE.UVMapping;
    texture.needsUpdate = true;
    const geometry = new THREE.PlaneBufferGeometry(4, 1, 2, 2);
    const material = new THREE.MeshBasicMaterial({
      depthTest: false,
      depthWrite: false,
      map: texture,
      color: 0xffffff,
      // 0x33c5f6,
      transparent: true,
      opacity: 1,
      toneMapped: false
      // blending: THREE.AdditiveBlending,
      // side: THREE.DoubleSide
    });

    const text = new THREE.Mesh(geometry, material);
    text.renderOrder = environment.renderOrder.debug;
    text.position.y = 0;
    return text;
  }
  loadFont() {
    this.fontLoader = ModelDebugComponent.getFontLoader(font => {
      this.font = font;
      if (this.message_) {
        this.setText(this.message_);
      }
    });
  }
  onCreate(mount, dismount) {
    const textGroup = this.textGroup = new THREE.Group();
    this.material = new THREE.MeshBasicMaterial({
      depthTest: false,
      color: 0xffffff,
      // 0x33c5f6,
      transparent: true,
      opacity: 1,
      side: THREE.DoubleSide
    });
    this.text = this.createText();
    if (typeof mount === 'function') {
      mount(textGroup);
    }
  }

  // onView() { const context = getContext(this); }

  // onChanges() {}

  render(time, tick) {
    const group = this.group;
    let camera = this.host.camera;
    const position = this.position;
    if (this.host.renderer.xr.isPresenting) {
      camera = this.host.renderer.xr.getCamera(camera);
      // camera.updateMatrixWorld(); // make sure the camera matrix is updated
      // camera.matrixWorldInverse.getInverse(camera.matrixWorld);
    }

    camera.getWorldDirection(position);
    // console.log(position);
    // if (position.lengthSq() > 0.01) {
    // normalize so we can get a constant speed
    // position.normalize();
    position.multiplyScalar(3);
    // move body, not the camera
    // VR.body.position.add(lookDirection);
    // console.log(position.x + '|' + position.y + '|' + position.z);
    group.position.copy(position);
    group.lookAt(Host.origin);
    // }
  }

  setText(message) {
    const text = this.text;
    if (text) {
      if (this.host.renderer.xr.isPresenting && message != null) {
        // draw
        const ctx = text.material.map.image.getContext('2d');
        ctx.clearRect(0, 0, ModelDebugComponent.W, ModelDebugComponent.H);
        // ctx.fillRect(0, 0, 10, 10);
        // ctx.fillRect(ModelDebugComponent.W - 10, ModelDebugComponent.H - 10, 10, 10);
        ctx.font = `30px ${environment.fontFamily}`;
        ctx.textBaseline = 'middle';
        ctx.textAlign = 'center';
        ctx.fillStyle = '#FFFFFF';
        ctx.strokeStyle = '#000000';
        ctx.lineWidth = 5;
        ctx.fillText(message, ModelDebugComponent.W / 2, ModelDebugComponent.H / 2, ModelDebugComponent.W - 20);
        text.material.map.needsUpdate = true;
        // draw
        this.textGroup.add(text);
      } else if (text.parent) {
        text.parent.remove(text);
      }
    }
  }
}
ModelDebugComponent.W = 1024;
ModelDebugComponent.H = 256;
ModelDebugComponent.meta = {
  selector: '[model-debug]',
  hosts: {
    host: WorldComponent
  }
};const VERTEX_SHADER = `
varying vec2 vUv;
void main() {
	vUv = uv;
	gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}
`;
const FRAGMENT_SHADER = `
varying vec2 vUv;
uniform sampler2D textureA;
uniform sampler2D textureB;
uniform float opacity;
uniform float tween;

void main() {
	vec4 colorA = texture2D(textureA, vUv);
	vec4 colorB = texture2D(textureB, vUv);
	vec4 color = mix(colorA, colorB, tween);
	color.a = clamp(color.a * opacity, 0.0, 1.0);
	color.rgb /= color.a;
	gl_FragColor = color;
}
`;
class ModelGridComponent extends ModelComponent {
  static getLoader() {
    return ModelGridComponent.loader || (ModelGridComponent.loader = new THREE.TextureLoader());
  }
  static getTexture() {
    return ModelGridComponent.texture || (ModelGridComponent.texture = ModelGridComponent.getLoader().load(environment.getPath('textures/ui/floor-nav.png')));
  }
  static getOverTexture() {
    return ModelGridComponent.textureOver || (ModelGridComponent.textureOver = ModelGridComponent.getLoader().load(environment.getPath('textures/ui/floor-nav-over.png')));
  }
  set coords(coords) {
    if (!coords && this.coords_ !== coords || !this.coords_ || coords.x !== this.coords_.x || coords.y !== this.coords_.y) {
      // changed!
      const tileMap = this.tileMap;
      if (this.coords_) {
        const previousTile = tileMap[`${this.coords_.x}_${this.coords_.y}`];
        const previousUniforms = previousTile.uniforms;
        gsap.to(previousUniforms, {
          tween: 0,
          duration: 0.4,
          delay: 0,
          ease: Power2.easeInOut,
          onUpdate: () => {
            previousTile.material.uniforms.tween.value = previousUniforms.tween;
            previousTile.material.needsUpdate = true;
          }
        });
      }
      if (coords) {
        const currentTile = this.currentTile = tileMap[`${coords.x}_${coords.y}`];
        const currentUniforms = currentTile.uniforms;
        gsap.to(currentUniforms, {
          tween: 1,
          duration: 0.4,
          delay: 0,
          ease: Power2.easeInOut,
          onUpdate: () => {
            currentTile.material.uniforms.tween.value = currentUniforms.tween;
            currentTile.material.needsUpdate = true;
          }
        });
        // console.log(currentTile, `${coords.x}_${coords.y}`);
      }

      this.coords_ = coords;
    }
  }
  set coords__(coords) {
    if (!coords && this.coords_ !== coords || !this.coords_ || coords.x !== this.coords_.x || coords.y !== this.coords_.y) {
      // changed!
      const tileMap = this.tileMap;
      if (this.coords_) {
        const previousTile = tileMap[`${this.coords_.x}_${this.coords_.y}`];
        const from = {
          tween: 1
        };
        gsap.to(from, {
          duration: 0.4,
          tween: 0,
          delay: 0,
          ease: Power2.easeInOut,
          onUpdate: () => {
            previousTile.material.opacity = from.tween;
            // previousTile.material.needsUpdate = true;
          }
        });
      }

      if (coords) {
        const currentTile = this.currentTile = tileMap[`${coords.x}_${coords.y}`];
        const from = {
          tween: 0
        };
        gsap.to(from, {
          duration: 0.4,
          tween: 1,
          delay: 0,
          ease: Power2.easeInOut,
          onUpdate: () => {
            currentTile.material.opacity = from.tween;
            // currentTile.material.needsUpdate = true;
          }
        });
        // console.log(currentTile, `${coords.x}_${coords.y}`);
      }

      this.coords_ = coords;
    }
  }
  getCoords(point) {
    const outerTileSize = ModelGridComponent.RADIUS / 10; // assume room is 20m x 20m
    const col = Math.ceil((point.x + outerTileSize / 2) / outerTileSize) - 1;
    const row = Math.ceil((point.z + outerTileSize / 2) / outerTileSize) - 1;
    const dx = Math.floor(ModelGridComponent.COLS / 2);
    const dy = Math.floor(ModelGridComponent.ROWS / 2);
    const ci = Math.min(dx, Math.abs(col)) * (col ? Math.abs(col) / col : 1);
    const ri = Math.min(dy, Math.abs(row)) * (row ? Math.abs(row) / row : 1);
    if (this.view.hasTile(this.indices.x + ci, this.indices.y + ri)) {
      // console.log('col', col, 'row', row, 'ci', ci, 'ri', ri);
      return new THREE.Vector2(ci, ri);
    }
  }
  onInit() {
    super.onInit();
    this.indices = new THREE.Vector2();
    // console.log('ModelGridComponent.onInit', this.view);
    this.view.index$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(index => {
      this.moveToIndex(index);
    });
  }
  addTiles(mesh) {
    // console.log('addTiles');
    const outerTileSize = ModelGridComponent.RADIUS / 10; // assume room is 20m x 20m
    const innerTileSize = outerTileSize * 0.9;
    const geometry = new THREE.PlaneBufferGeometry(innerTileSize, innerTileSize, 2, 2);
    geometry.rotateX(-Math.PI / 2);
    const map = ModelGridComponent.getTexture();
    map.disposable = false;
    map.encoding = THREE.sRGBEncoding;
    const mapOver = ModelGridComponent.getOverTexture();
    mapOver.disposable = false;
    mapOver.encoding = THREE.sRGBEncoding;
    // geometry.scale(-1, 1, 1);
    const tileMap = this.tileMap = {};
    this.tiles = new Array(ModelGridComponent.COLS * ModelGridComponent.ROWS).fill(0).map((x, i) => {
      const material = new THREE.ShaderMaterial({
        depthTest: false,
        depthWrite: false,
        transparent: true,
        toneMapped: false,
        vertexShader: VERTEX_SHADER,
        fragmentShader: FRAGMENT_SHADER,
        uniforms: {
          textureA: {
            type: 't',
            value: map
          },
          textureB: {
            type: 't',
            value: mapOver
          },
          tween: {
            value: 0
          },
          opacity: {
            value: 0
          }
        },
        extensions: {
          fragDepth: true
        }
        // side: THREE.DoubleSide
      });
      /*
      const material = new THREE.MeshBasicMaterial({
      	depthTest: false,
      	depthWrite: false,
      	map: map,
      	transparent: true,
      	opacity: 0,
      	// side: THREE.DoubleSide,
      });
      */
      const tile = new THREE.Mesh(geometry, material);
      const dx = Math.floor(ModelGridComponent.COLS / 2);
      const dy = Math.floor(ModelGridComponent.ROWS / 2);
      const row = Math.floor(i / ModelGridComponent.COLS);
      const col = i % ModelGridComponent.COLS;
      const ci = -dx + col;
      const ri = -dy + row;
      // console.log(ci, ri);
      tile.position.set(ci * outerTileSize, -ModelGridComponent.RADIUS * 0.15, ri * outerTileSize);
      tile.name = this.getName(`tile_${ci}_${ri}`);
      tile.uniforms = {
        tween: 0,
        opacity: 0,
        ci: ci,
        ri: ri
      };
      tileMap[`${ci}_${ri}`] = tile;
      mesh.add(tile);
      return tile;
    });
    this.showTiles();
  }
  showTiles() {
    this.tiles.forEach((tile, i) => {
      const ix = this.indices ? this.indices.x : 0;
      const iy = this.indices ? this.indices.y : 0;
      const visible = this.view.hasTile(ix + tile.uniforms.ci, iy + tile.uniforms.ri);
      const uniforms = tile.uniforms;
      gsap.to(uniforms, {
        opacity: visible ? 1 : 0,
        duration: 0.4,
        // delay: 0 + i * 0.02,
        ease: Power2.easeInOut,
        onUpdate: () => {
          tile.material.uniforms.opacity.value = uniforms.opacity;
          tile.material.needsUpdate = true;
        }
      });
    });
  }
  addHitArea(mesh) {
    this.onGroundOver = this.onGroundOver.bind(this);
    this.onGroundMove = this.onGroundMove.bind(this);
    this.onGroundDown = this.onGroundDown.bind(this);
    this.onGroundOut = this.onGroundOut.bind(this);
    ModelGridComponent.RADIUS / 10; // assume room is 20m x 20m
    const geometry = new THREE.PlaneBufferGeometry(ModelGridComponent.RADIUS, ModelGridComponent.RADIUS, 8, 8); // 20, 20
    geometry.rotateX(-Math.PI / 2);
    // geometry.scale(-1, 1, 1);
    const material = new THREE.MeshBasicMaterial({
      depthTest: false,
      depthWrite: false,
      transparent: true,
      toneMapped: false,
      opacity: 0
      // side: THREE.DoubleSide,
    });

    const ground = this.ground = new InteractiveMesh(geometry, material);
    ground.name = this.getName('ground');
    ground.position.set(0, -ModelGridComponent.RADIUS * 0.15, 0);
    ground.on('over', this.onGroundOver);
    ground.on('move', this.onGroundMove);
    ground.on('out', this.onGroundOut);
    ground.on('down', this.onGroundDown);
    mesh.add(ground);
  }
  onGroundOver() {
    const ground = this.ground;
    const coords = this.getCoords(ground.intersection.point);
    this.coords = coords;
  }
  onGroundMove() {
    const ground = this.ground;
    const coords = this.getCoords(ground.intersection.point);
    this.coords = coords;
  }
  onGroundDown() {
    const ground = this.ground;
    const coords = this.getCoords(ground.intersection.point);
    this.coords = coords;
    if (coords) {
      const index = this.view.getTileIndex(this.indices.x + coords.x, this.indices.y + coords.y);
      this.view.index = index;
      this.nav.next(index);
      /*
      this.indices.x += coords.x;
      this.indices.y += coords.y;
      const outerTileSize = ModelGridComponent.RADIUS / 10; // assume room is 20m x 20m
      this.move.next({
      	indices: this.indices,
      	coords,
      	position: coords.clone().multiplyScalar(outerTileSize)
      });
      */
    }
  }

  onGroundOut() {
    this.coords = null;
  }
  moveToIndex(index) {
    // console.log('ModelGridComponent.moveToIndex', index);
    this.coords = null;
    const tile = this.view.tiles[index];
    const coords = new THREE.Vector2(tile.indices.x - this.indices.x, tile.indices.y - this.indices.y);
    this.indices.x = tile.indices.x;
    this.indices.y = tile.indices.y;
    this.showTiles();
    const outerTileSize = ModelGridComponent.RADIUS / 10; // assume room is 20m x 20m
    this.move.next({
      indices: this.indices,
      coords,
      position: coords.clone().multiplyScalar(outerTileSize)
    });
  }
  onCreate(mount, dismount) {
    // this.renderOrder = environment.renderOrder.tile;
    const mesh = new THREE.Group();
    this.addTiles(mesh);
    this.addHitArea(mesh);
    /*
    mesh.userData = {
    	render: () => {
    			}
    };
    */
    if (typeof mount === 'function') {
      mount(mesh);
    }
  }
  onDestroy() {
    super.onDestroy();
    const ground = this.ground;
    ground.off('over', this.onGroundOver);
    ground.off('move', this.onGroundMove);
    ground.off('down', this.onGroundDown);
    ground.off('out', this.onGroundOut);
  }
}
ModelGridComponent.RADIUS = 101;
ModelGridComponent.COLS = 11;
ModelGridComponent.ROWS = 11;
ModelGridComponent.meta = {
  selector: '[model-grid]',
  hosts: {
    host: WorldComponent
  },
  outputs: ['move', 'nav'],
  inputs: ['view']
};class MenuButton extends InteractiveMesh {
  static getGrid(total) {
    const cols = Math.ceil(total / MenuButton.ROWS);
    const rows = Math.ceil(total / cols);
    return [rows, cols];
  }
  static getX(index, total) {
    const cols = Math.ceil(total / MenuButton.ROWS);
    const c = index % cols;
    const w = 1 / MenuButton.W * (MenuButton.W + MenuButton.G);
    return w / 2 - cols * w / 2 + c * w;
  }
  static getY(index, total) {
    const cols = Math.ceil(total / MenuButton.ROWS);
    const rows = Math.ceil(total / cols);
    const r = Math.floor(index / cols);
    const h = 1 / MenuButton.W * (MenuButton.H + MenuButton.G);
    return rows * h / 2 - h / 2 + r * -h; // y flipped
  }

  static get geometry() {
    if (this.geometry_) {
      return this.geometry_;
    }
    const geometry = new THREE.PlaneBufferGeometry(1, 1 / MenuButton.W * MenuButton.H, 2, 2);
    this.geometry_ = geometry;
    return geometry;
  }
  static get material() {
    const material = new THREE.ShaderMaterial({
      depthTest: false,
      transparent: true,
      toneMapped: false,
      vertexShader: ModelMenuComponent.VERTEX_SHADER,
      fragmentShader: ModelMenuComponent.FRAGMENT_SHADER,
      uniforms: {
        textureA: {
          type: 't',
          value: null
        },
        textureB: {
          type: 't',
          value: null
        },
        resolutionA: {
          value: new THREE.Vector2()
        },
        resolutionB: {
          value: new THREE.Vector2()
        },
        tween: {
          value: 0
        },
        opacity: {
          value: 0
        }
      },
      extensions: {
        fragDepth: true
      }
    });
    /*
    const material = new THREE.MeshBasicMaterial({
    	// depthTest: false,
    	transparent: true,
    	opacity: 0.8,
    	// side: THREE.DoubleSide,
    });
    */
    return material;
  }
  constructor(item, index, total) {
    const geometry = MenuButton.geometry;
    const material = MenuButton.material;
    super(geometry, material);
    // this.userData.item = item;
    // this.userData.index = index;
    this.renderOrder = environment.renderOrder.menu;
    this.name = item.name;
    this.item = item;
    this.index = index;
    this.total = total;
    this.tween = 0;
    this.opacity = 0;
    const textureA = this.textureA = this.getTextureA(item.name);
    // material.map = textureA;
    material.uniforms.textureA.value = textureA;
    material.uniforms.resolutionA.value = new THREE.Vector2(textureA.width, textureA.height);
    const textureB = this.textureB = this.getTextureB(item.name);
    // material.map = textureB;
    material.uniforms.textureB.value = textureB;
    material.uniforms.resolutionA.value = new THREE.Vector2(textureB.width, textureB.height);
    material.uniforms.tween.value = this.tween;
    material.uniforms.opacity.value = this.opacity;
    material.needsUpdate = true;
    this.position.set(MenuButton.getX(index, total), MenuButton.getY(index, total), 0);
    this.onOver = this.onOver.bind(this);
    this.onOut = this.onOut.bind(this);
  }
  getTextureA(text) {
    const w = MenuButton.W;
    const h = MenuButton.H;
    const canvas = document.createElement('canvas');
    canvas.width = w;
    canvas.height = h;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = environment.colors.menuBackground;
    ctx.fillRect(0, 0, w, h);
    ctx.fillStyle = environment.colors.menuForeground;
    this.writeText(ctx, text, w, h);
    const texture = new THREE.CanvasTexture(canvas);
    texture.minFilter = THREE.LinearFilter;
    texture.magFilter = THREE.LinearFilter;
    texture.mapping = THREE.UVMapping;
    // texture.encoding = THREE.sRGBEncoding;
    texture.needsUpdate = true;
    return texture;
  }
  getTextureB(text) {
    const w = MenuButton.W;
    const h = MenuButton.H;
    const canvas = document.createElement('canvas');
    canvas.width = w;
    canvas.height = h;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = environment.colors.menuOverBackground;
    ctx.fillRect(0, 0, w, h);
    ctx.fillStyle = environment.colors.menuOverForeground;
    this.writeText(ctx, text, w, h);
    const texture = new THREE.CanvasTexture(canvas);
    // texture.encoding = THREE.sRGBEncoding;
    texture.magFilter = THREE.LinearFilter;
    texture.needsUpdate = true;
    return texture;
  }
  writeText(ctx, text, w, h) {
    this.setFont(ctx);
    const lineHeight = MenuButton.FONT_SIZE * MenuButton.LINE_HEIGHT;
    const lines = this.getLines(ctx, text, w);
    const lineCount = lines.length;
    this.setFont(ctx, lineCount - 1);
    lines.forEach((line, i) => {
      ctx.fillText(line, 10, (h - lineCount * lineHeight) * 0.5 + (0.5 + i) * lineHeight, w - 20);
    });
  }
  setFont(ctx, diff) {
    if (diff === void 0) {
      diff = 0;
    }
    ctx.textBaseline = 'middle';
    ctx.font = `${MenuButton.FONT_SIZE - diff * 2}px ${environment.fontFamily}`;
  }
  getLines(ctx, text, maxWidth) {
    const words = text.split(' ');
    const lines = [];
    let currentLine = words[0];
    for (let i = 1; i < words.length; i++) {
      const word = words[i];
      const width = ctx.measureText(currentLine + ' ' + word).width;
      if (width < maxWidth) {
        currentLine += ' ' + word;
      } else {
        lines.push(currentLine);
        currentLine = word;
      }
    }
    lines.push(currentLine);
    return lines;
  }
  onOver() {
    // DebugService.getService().setMessage('over ' + this.name);
    gsap.to(this, {
      duration: 0.4,
      tween: 1,
      ease: Power2.easeOut,
      onUpdate: () => {
        this.position.z = 0.1 * this.tween;
        this.material.uniforms.tween.value = this.tween;
        this.material.needsUpdate = true;
      }
    });
  }
  onOut() {
    gsap.to(this, {
      duration: 0.4,
      tween: 0,
      ease: Power2.easeOut,
      onUpdate: () => {
        this.position.z = 0.1 * this.tween;
        this.material.uniforms.tween.value = this.tween;
        this.material.needsUpdate = true;
      }
    });
  }
  dispose() {
    Interactive.dispose(this);
    this.textureA.dispose();
    this.textureB.dispose();
    this.material.dispose();
    this.geometry.dispose();
  }
}
MenuButton.FONT_SIZE = 19; // 20
MenuButton.LINE_HEIGHT = 0.9;
MenuButton.W = 256;
MenuButton.H = 64;
MenuButton.G = 2;
MenuButton.ROWS = 6;
class BackButton extends MenuButton {
  constructor(item, index, total) {
    super(item, index, total);
  }
  getTextureA(text) {
    const w = MenuButton.W;
    const h = MenuButton.H;
    const canvas = document.createElement('canvas');
    canvas.width = w;
    canvas.height = h;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = environment.colors.menuBackBackground;
    ctx.fillRect(0, 0, w, h);
    ctx.fillStyle = environment.colors.menuBackForeground;
    ctx.font = `${MenuButton.FONT_SIZE}px ${environment.fontFamily}`;
    ctx.fillText(text, 10, 50, w - 20);
    const texture = new THREE.CanvasTexture(canvas);
    texture.minFilter = THREE.LinearFilter;
    texture.magFilter = THREE.LinearFilter;
    texture.mapping = THREE.UVMapping;
    texture.needsUpdate = true;
    return texture;
  }
  getTextureB(text) {
    const w = MenuButton.W;
    const h = MenuButton.H;
    const canvas = document.createElement('canvas');
    canvas.width = w;
    canvas.height = h;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = environment.colors.menuBackOverBackground;
    ctx.fillRect(0, 0, w, h);
    ctx.fillStyle = environment.colors.menuBackOverForeground;
    ctx.font = `${MenuButton.FONT_SIZE}px ${environment.fontFamily}`;
    ctx.fillText(text, 10, 50, w - 20);
    const texture = new THREE.CanvasTexture(canvas);
    // texture.encoding = THREE.sRGBEncoding;
    texture.magFilter = THREE.LinearFilter;
    texture.needsUpdate = true;
    return texture;
  }
}
class ModelMenuComponent extends ModelComponent {
  get controlled() {
    return StateService.state.controlling && StateService.state.controlling !== StateService.state.uid;
  }
  get controlling() {
    return StateService.state.controlling && StateService.state.controlling === StateService.state.uid;
  }
  get silencing() {
    return StateService.state.silencing;
  }
  get silenced() {
    return StateService.state.silencing && StateService.state.role === RoleType.Streamer;
  }
  get spyed() {
    return StateService.state.spying && StateService.state.spying === StateService.state.uid;
  }
  get spying() {
    return StateService.state.spying && StateService.state.spying !== StateService.state.uid;
  }
  get locked() {
    return this.controlled || this.spying;
  }
  get loading() {
    return this.loading_;
  }
  set loading(loading) {
    // console.log('loading', loading);
    if (this.loading_ !== loading) {
      this.loading_ = loading;
      const {
        node
      } = rxcomp.getContext(this);
      const btn = node.querySelector('.btn--menu');
      btn.classList.toggle('loading', loading);
    }
  }
  onInit() {
    super.onInit();
    this.onDown = this.onDown.bind(this);
    this.onToggle = this.onToggle.bind(this);
    // console.log('ModelMenuComponent.onInit');
    /*
    const vrService = this.vrService = VRService.getService();
    vrService.session$.pipe(
    	takeUntil(this.unsubscribe$),
    ).subscribe((session) => {
    	if (session) {
    		this.addToggler();
    	} else {
    		this.removeMenu();
    	}
    });
    */
    const {
      node
    } = rxcomp.getContext(this);
    this.progressIndicator = node.querySelector('.progress circle');
    LoaderService.progress$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(progress => {
      this.loading = progress.count > 0;
      let strokeDashoffset = 144.51;
      if (progress.count) {
        strokeDashoffset = 144.51 * (1 - progress.value);
      }
      gsap.set(this.progressIndicator, {
        'strokeDashoffset': strokeDashoffset
      });
    });
    MessageService.in$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(message => {
      // DebugService.getService().setMessage('ModelMenuComponent.MessageService ' + message.type);
      switch (message.type) {
        case MessageType.MenuToggle:
          this.onToggle();
          break;
      }
    });
  }

  /*
  buildMenu() {
  	if (!this.views) {
  		return;
  	}
  	MenuService.getModelMenu$(this.views, this.host.editor).pipe(
  		first(),
  	).subscribe(menu => this.groups = menu);
  }
  */

  onDestroy() {
    if (this.buttons) {
      this.buttons.forEach(x => Interactive.dispose(x));
    }
    super.onDestroy();
  }
  getContainer() {
    return this.host.cameraGroup;
  }
  onCreate(mount, dismount) {
    // this.renderOrder = environment.renderOrder.menu;
    const menuGroup = this.menuGroup = new THREE.Group();
    if (typeof mount === 'function') {
      mount(menuGroup);
    }
  }
  render(time, tick) {
    const group = this.group;
    this.host.cameraGroup;
    let camera = this.host.camera;
    const position = this.position;
    if (this.host.renderer.xr.isPresenting) {
      camera = this.host.renderer.xr.getCamera(camera);
      camera.getWorldDirection(position);
      position.y += 0.5;
      position.multiplyScalar(3);
      this.host.cameraGroup.worldToLocal(position);
      position.y += this.host.cameraGroup.position.y;
      group.position.copy(position);
      group.scale.set(1, 1, 1);
      group.lookAt(Host.origin);
    } else {
      camera.getWorldDirection(position);
      if (OrbitService.mode === OrbitMode.Model) {
        position.multiplyScalar(0.01);
      } else {
        position.multiplyScalar(3);
      }
      group.position.copy(position);
      const s = 1 / camera.zoom;
      group.scale.set(s, s, s);
      group.lookAt(Host.origin);
    }
  }
  items$(item) {
    if (item === void 0) {
      item = null;
    }
    if (item) {
      return rxjs.of(item.items);
    } else if (this.rootItems) {
      return rxjs.of(this.rootItems);
    } else {
      return MenuService.getModelMenu$(this.views, this.host.editor).pipe(operators.first(), operators.tap(items => {
        if (!this.host.editor) {
          this.rootItems = items;
        }
      }));
    }
  }
  addMenu(item) {
    if (item === void 0) {
      item = null;
    }
    this.removeMenu();
    // nav to view
    if (item && item.type.name !== 'menu-group') {
      /*
      if (this.host.renderer.xr.isPresenting) {
      	this.addToggler();
      }
      */
      this.nav.next(item);
      return;
    }
    MenuService.active = true;
    this.items$(item).pipe(operators.first()).subscribe(items => {
      if (items) {
        items = items.slice();
        const back = {
          type: {
            name: 'back'
          },
          name: item ? 'Back' : 'Close',
          backItem: item
        };
        items.push(back);
        const buttons = this.buttons = items.map((x, i, a) => {
          x.backItem = item;
          return x.type.name === 'back' ? new BackButton(x, i, a.length) : new MenuButton(x, i, a.length);
        });
        buttons.forEach(button => {
          button.depthTest = false;
          button.on('over', button.onOver);
          button.on('out', button.onOut);
          button.on('down', this.onDown);
          this.menuGroup.add(button);
          /*
          var box = new THREE.BoxHelper(button, 0xffff00);
          this.host.scene.add(box);
          */
        });

        gsap.to(buttons, {
          duration: 0.3,
          opacity: 0.8,
          ease: Power2.easeOut,
          stagger: {
            grid: MenuButton.getGrid(buttons.length),
            from: 0,
            // index
            amount: 0.02 * buttons.length
          },
          onUpdate: () => {
            buttons.forEach(button => {
              button.material.uniforms.opacity.value = button.opacity * (button.item.hidden ? 0.5 : 1);
              // button.material.needsUpdate = true;
            });
          }
        });
      }
    });
  }

  removeMenu() {
    MenuService.active = false;
    this.removeButtons();
    this.removeToggler();
  }
  removeButtons() {
    const buttons = this.buttons;
    if (buttons) {
      buttons.forEach(button => {
        this.menuGroup.remove(button);
        button.off('over', button.onOver);
        button.off('out', button.onOut);
        button.off('down', this.onDown);
        button.dispose();
      });
    }
    this.buttons = null;
  }
  addToggler() {
    this.removeMenu();
    const toggler = this.toggler = new MenuButton({
      type: {
        name: 'menu'
      },
      name: 'Menu'
    }, 0, 1);
    // toggler.position.y = -0.5;
    toggler.opacity = 0.8;
    toggler.material.uniforms.opacity.value = toggler.opacity;
    toggler.material.needsUpdate = true;
    toggler.on('over', toggler.onOver);
    toggler.on('out', toggler.onOut);
    toggler.on('down', this.onToggle);
    this.menuGroup.add(toggler);
  }
  removeToggler() {
    const toggler = this.toggler;
    if (toggler) {
      this.menuGroup.remove(toggler);
      toggler.off('over', toggler.onOver);
      toggler.off('out', toggler.onOut);
      toggler.off('down', this.onToggle);
      toggler.dispose();
    }
    this.toggler = null;
  }
  onDown(button) {
    // this.down.next(this.item);
    if (button.item && button.item.type.name === 'back') {
      this.removeMenu();
      if (button.item.backItem) {
        this.addMenu(button.item.backItem.backItem);
      } else {
        /*
        if (this.host.renderer.xr.isPresenting) {
        	this.addToggler();
        }
        */
        this.toggle.next();
      }
    } else {
      this.addMenu(button.item);
    }
  }
  onToggle(event) {
    if (event) {
      event.preventDefault();
      event.stopImmediatePropagation();
    }
    if (this.locked) {
      return;
    }
    if (MenuService.active) {
      this.removeMenu();
      this.toggle.next();
    } else {
      this.addMenu();
      this.toggle.next(this);
    }
  }
}
ModelMenuComponent.VERTEX_SHADER = `
varying vec2 vUv;
void main() {
	vUv = uv;
	gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}
`;
ModelMenuComponent.FRAGMENT_SHADER = `
varying vec2 vUv;
uniform float opacity;
uniform float tween;
uniform sampler2D textureA;
uniform sampler2D textureB;
uniform vec2 resolutionA;
uniform vec2 resolutionB;

void main() {
	vec4 colorA = texture2D(textureA, vUv);
	vec4 colorB = texture2D(textureB, vUv);
	vec4 color = vec4(mix(colorA.rgb, colorB.rgb, tween), opacity);
	gl_FragColor = color;
}
`;
ModelMenuComponent.meta = {
  selector: '[model-menu]',
  hosts: {
    host: WorldComponent
  },
  // outputs: ['over', 'out', 'down', 'nav'],
  outputs: ['nav', 'toggle'],
  inputs: ['views'],
  template: /* html */`
	<div class="btn--menu" (mousedown)="onToggle($event)">
		<svg class="menu-light" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#menu-light"></use></svg>
		<div class="btn--menu__spinner"></div>
		<svg class="bullets" width="24" height="24" viewBox="0 0 24 24"><use xlink:href="#menu"></use></svg>
		<svg class="progress" width="50" height="50" viewBox="0 0 50 50">
			<circle id="circle" r="23" cx="25" cy="25" fill="transparent"></circle>
		</svg>
	</div>
	`
};const _taskCache = new WeakMap();

class DRACOLoader extends three.Loader {

	constructor( manager ) {

		super( manager );

		this.decoderPath = '';
		this.decoderConfig = {};
		this.decoderBinary = null;
		this.decoderPending = null;

		this.workerLimit = 4;
		this.workerPool = [];
		this.workerNextTaskID = 1;
		this.workerSourceURL = '';

		this.defaultAttributeIDs = {
			position: 'POSITION',
			normal: 'NORMAL',
			color: 'COLOR',
			uv: 'TEX_COORD'
		};
		this.defaultAttributeTypes = {
			position: 'Float32Array',
			normal: 'Float32Array',
			color: 'Float32Array',
			uv: 'Float32Array'
		};

	}

	setDecoderPath( path ) {

		this.decoderPath = path;

		return this;

	}

	setDecoderConfig( config ) {

		this.decoderConfig = config;

		return this;

	}

	setWorkerLimit( workerLimit ) {

		this.workerLimit = workerLimit;

		return this;

	}

	load( url, onLoad, onProgress, onError ) {

		const loader = new three.FileLoader( this.manager );

		loader.setPath( this.path );
		loader.setResponseType( 'arraybuffer' );
		loader.setRequestHeader( this.requestHeader );
		loader.setWithCredentials( this.withCredentials );

		loader.load( url, ( buffer ) => {

			const taskConfig = {
				attributeIDs: this.defaultAttributeIDs,
				attributeTypes: this.defaultAttributeTypes,
				useUniqueIDs: false
			};

			this.decodeGeometry( buffer, taskConfig )
				.then( onLoad )
				.catch( onError );

		}, onProgress, onError );

	}

	/** @deprecated Kept for backward-compatibility with previous DRACOLoader versions. */
	decodeDracoFile( buffer, callback, attributeIDs, attributeTypes ) {

		const taskConfig = {
			attributeIDs: attributeIDs || this.defaultAttributeIDs,
			attributeTypes: attributeTypes || this.defaultAttributeTypes,
			useUniqueIDs: !! attributeIDs
		};

		this.decodeGeometry( buffer, taskConfig ).then( callback );

	}

	decodeGeometry( buffer, taskConfig ) {

		// TODO: For backward-compatibility, support 'attributeTypes' objects containing
		// references (rather than names) to typed array constructors. These must be
		// serialized before sending them to the worker.
		for ( const attribute in taskConfig.attributeTypes ) {

			const type = taskConfig.attributeTypes[ attribute ];

			if ( type.BYTES_PER_ELEMENT !== undefined ) {

				taskConfig.attributeTypes[ attribute ] = type.name;

			}

		}

		//

		const taskKey = JSON.stringify( taskConfig );

		// Check for an existing task using this buffer. A transferred buffer cannot be transferred
		// again from this thread.
		if ( _taskCache.has( buffer ) ) {

			const cachedTask = _taskCache.get( buffer );

			if ( cachedTask.key === taskKey ) {

				return cachedTask.promise;

			} else if ( buffer.byteLength === 0 ) {

				// Technically, it would be possible to wait for the previous task to complete,
				// transfer the buffer back, and decode again with the second configuration. That
				// is complex, and I don't know of any reason to decode a Draco buffer twice in
				// different ways, so this is left unimplemented.
				throw new Error(

					'THREE.DRACOLoader: Unable to re-decode a buffer with different ' +
					'settings. Buffer has already been transferred.'

				);

			}

		}

		//

		let worker;
		const taskID = this.workerNextTaskID ++;
		const taskCost = buffer.byteLength;

		// Obtain a worker and assign a task, and construct a geometry instance
		// when the task completes.
		const geometryPending = this._getWorker( taskID, taskCost )
			.then( ( _worker ) => {

				worker = _worker;

				return new Promise( ( resolve, reject ) => {

					worker._callbacks[ taskID ] = { resolve, reject };

					worker.postMessage( { type: 'decode', id: taskID, taskConfig, buffer }, [ buffer ] );

					// this.debug();

				} );

			} )
			.then( ( message ) => this._createGeometry( message.geometry ) );

		// Remove task from the task list.
		// Note: replaced '.finally()' with '.catch().then()' block - iOS 11 support (#19416)
		geometryPending
			.catch( () => true )
			.then( () => {

				if ( worker && taskID ) {

					this._releaseTask( worker, taskID );

					// this.debug();

				}

			} );

		// Cache the task result.
		_taskCache.set( buffer, {

			key: taskKey,
			promise: geometryPending

		} );

		return geometryPending;

	}

	_createGeometry( geometryData ) {

		const geometry = new three.BufferGeometry();

		if ( geometryData.index ) {

			geometry.setIndex( new three.BufferAttribute( geometryData.index.array, 1 ) );

		}

		for ( let i = 0; i < geometryData.attributes.length; i ++ ) {

			const attribute = geometryData.attributes[ i ];
			const name = attribute.name;
			const array = attribute.array;
			const itemSize = attribute.itemSize;

			geometry.setAttribute( name, new three.BufferAttribute( array, itemSize ) );

		}

		return geometry;

	}

	_loadLibrary( url, responseType ) {

		const loader = new three.FileLoader( this.manager );
		loader.setPath( this.decoderPath );
		loader.setResponseType( responseType );
		loader.setWithCredentials( this.withCredentials );

		return new Promise( ( resolve, reject ) => {

			loader.load( url, resolve, undefined, reject );

		} );

	}

	preload() {

		this._initDecoder();

		return this;

	}

	_initDecoder() {

		if ( this.decoderPending ) return this.decoderPending;

		const useJS = typeof WebAssembly !== 'object' || this.decoderConfig.type === 'js';
		const librariesPending = [];

		if ( useJS ) {

			librariesPending.push( this._loadLibrary( 'draco_decoder.js', 'text' ) );

		} else {

			librariesPending.push( this._loadLibrary( 'draco_wasm_wrapper.js', 'text' ) );
			librariesPending.push( this._loadLibrary( 'draco_decoder.wasm', 'arraybuffer' ) );

		}

		this.decoderPending = Promise.all( librariesPending )
			.then( ( libraries ) => {

				const jsContent = libraries[ 0 ];

				if ( ! useJS ) {

					this.decoderConfig.wasmBinary = libraries[ 1 ];

				}

				const fn = DRACOWorker.toString();

				const body = [
					'/* draco decoder */',
					jsContent,
					'',
					'/* worker */',
					fn.substring( fn.indexOf( '{' ) + 1, fn.lastIndexOf( '}' ) )
				].join( '\n' );

				this.workerSourceURL = URL.createObjectURL( new Blob( [ body ] ) );

			} );

		return this.decoderPending;

	}

	_getWorker( taskID, taskCost ) {

		return this._initDecoder().then( () => {

			if ( this.workerPool.length < this.workerLimit ) {

				const worker = new Worker( this.workerSourceURL );

				worker._callbacks = {};
				worker._taskCosts = {};
				worker._taskLoad = 0;

				worker.postMessage( { type: 'init', decoderConfig: this.decoderConfig } );

				worker.onmessage = function ( e ) {

					const message = e.data;

					switch ( message.type ) {

						case 'decode':
							worker._callbacks[ message.id ].resolve( message );
							break;

						case 'error':
							worker._callbacks[ message.id ].reject( message );
							break;

						default:
							console.error( 'THREE.DRACOLoader: Unexpected message, "' + message.type + '"' );

					}

				};

				this.workerPool.push( worker );

			} else {

				this.workerPool.sort( function ( a, b ) {

					return a._taskLoad > b._taskLoad ? - 1 : 1;

				} );

			}

			const worker = this.workerPool[ this.workerPool.length - 1 ];
			worker._taskCosts[ taskID ] = taskCost;
			worker._taskLoad += taskCost;
			return worker;

		} );

	}

	_releaseTask( worker, taskID ) {

		worker._taskLoad -= worker._taskCosts[ taskID ];
		delete worker._callbacks[ taskID ];
		delete worker._taskCosts[ taskID ];

	}

	debug() {

		console.log( 'Task load: ', this.workerPool.map( ( worker ) => worker._taskLoad ) );

	}

	dispose() {

		for ( let i = 0; i < this.workerPool.length; ++ i ) {

			this.workerPool[ i ].terminate();

		}

		this.workerPool.length = 0;

		return this;

	}

}

/* WEB WORKER */

function DRACOWorker() {

	let decoderConfig;
	let decoderPending;

	onmessage = function ( e ) {

		const message = e.data;

		switch ( message.type ) {

			case 'init':
				decoderConfig = message.decoderConfig;
				decoderPending = new Promise( function ( resolve/*, reject*/ ) {

					decoderConfig.onModuleLoaded = function ( draco ) {

						// Module is Promise-like. Wrap before resolving to avoid loop.
						resolve( { draco: draco } );

					};

					DracoDecoderModule( decoderConfig ); // eslint-disable-line no-undef

				} );
				break;

			case 'decode':
				const buffer = message.buffer;
				const taskConfig = message.taskConfig;
				decoderPending.then( ( module ) => {

					const draco = module.draco;
					const decoder = new draco.Decoder();
					const decoderBuffer = new draco.DecoderBuffer();
					decoderBuffer.Init( new Int8Array( buffer ), buffer.byteLength );

					try {

						const geometry = decodeGeometry( draco, decoder, decoderBuffer, taskConfig );

						const buffers = geometry.attributes.map( ( attr ) => attr.array.buffer );

						if ( geometry.index ) buffers.push( geometry.index.array.buffer );

						self.postMessage( { type: 'decode', id: message.id, geometry }, buffers );

					} catch ( error ) {

						console.error( error );

						self.postMessage( { type: 'error', id: message.id, error: error.message } );

					} finally {

						draco.destroy( decoderBuffer );
						draco.destroy( decoder );

					}

				} );
				break;

		}

	};

	function decodeGeometry( draco, decoder, decoderBuffer, taskConfig ) {

		const attributeIDs = taskConfig.attributeIDs;
		const attributeTypes = taskConfig.attributeTypes;

		let dracoGeometry;
		let decodingStatus;

		const geometryType = decoder.GetEncodedGeometryType( decoderBuffer );

		if ( geometryType === draco.TRIANGULAR_MESH ) {

			dracoGeometry = new draco.Mesh();
			decodingStatus = decoder.DecodeBufferToMesh( decoderBuffer, dracoGeometry );

		} else if ( geometryType === draco.POINT_CLOUD ) {

			dracoGeometry = new draco.PointCloud();
			decodingStatus = decoder.DecodeBufferToPointCloud( decoderBuffer, dracoGeometry );

		} else {

			throw new Error( 'THREE.DRACOLoader: Unexpected geometry type.' );

		}

		if ( ! decodingStatus.ok() || dracoGeometry.ptr === 0 ) {

			throw new Error( 'THREE.DRACOLoader: Decoding failed: ' + decodingStatus.error_msg() );

		}

		const geometry = { index: null, attributes: [] };

		// Gather all vertex attributes.
		for ( const attributeName in attributeIDs ) {

			const attributeType = self[ attributeTypes[ attributeName ] ];

			let attribute;
			let attributeID;

			// A Draco file may be created with default vertex attributes, whose attribute IDs
			// are mapped 1:1 from their semantic name (POSITION, NORMAL, ...). Alternatively,
			// a Draco file may contain a custom set of attributes, identified by known unique
			// IDs. glTF files always do the latter, and `.drc` files typically do the former.
			if ( taskConfig.useUniqueIDs ) {

				attributeID = attributeIDs[ attributeName ];
				attribute = decoder.GetAttributeByUniqueId( dracoGeometry, attributeID );

			} else {

				attributeID = decoder.GetAttributeId( dracoGeometry, draco[ attributeIDs[ attributeName ] ] );

				if ( attributeID === - 1 ) continue;

				attribute = decoder.GetAttribute( dracoGeometry, attributeID );

			}

			geometry.attributes.push( decodeAttribute( draco, decoder, dracoGeometry, attributeName, attributeType, attribute ) );

		}

		// Add index.
		if ( geometryType === draco.TRIANGULAR_MESH ) {

			geometry.index = decodeIndex( draco, decoder, dracoGeometry );

		}

		draco.destroy( dracoGeometry );

		return geometry;

	}

	function decodeIndex( draco, decoder, dracoGeometry ) {

		const numFaces = dracoGeometry.num_faces();
		const numIndices = numFaces * 3;
		const byteLength = numIndices * 4;

		const ptr = draco._malloc( byteLength );
		decoder.GetTrianglesUInt32Array( dracoGeometry, byteLength, ptr );
		const index = new Uint32Array( draco.HEAPF32.buffer, ptr, numIndices ).slice();
		draco._free( ptr );

		return { array: index, itemSize: 1 };

	}

	function decodeAttribute( draco, decoder, dracoGeometry, attributeName, attributeType, attribute ) {

		const numComponents = attribute.num_components();
		const numPoints = dracoGeometry.num_points();
		const numValues = numPoints * numComponents;
		const byteLength = numValues * attributeType.BYTES_PER_ELEMENT;
		const dataType = getDracoDataType( draco, attributeType );

		const ptr = draco._malloc( byteLength );
		decoder.GetAttributeDataArrayForAllPoints( dracoGeometry, attribute, dataType, byteLength, ptr );
		const array = new attributeType( draco.HEAPF32.buffer, ptr, numValues ).slice();
		draco._free( ptr );

		return {
			name: attributeName,
			array: array,
			itemSize: numComponents
		};

	}

	function getDracoDataType( draco, attributeType ) {

		switch ( attributeType ) {

			case Float32Array: return draco.DT_FLOAT32;
			case Int8Array: return draco.DT_INT8;
			case Int16Array: return draco.DT_INT16;
			case Int32Array: return draco.DT_INT32;
			case Uint8Array: return draco.DT_UINT8;
			case Uint16Array: return draco.DT_UINT16;
			case Uint32Array: return draco.DT_UINT32;

		}

	}

}class ModelModelComponent extends ModelEditableComponent {
  get freezed() {
    return this.freezed_;
  }
  set freezed(freezed) {
    if (this.freezed_ !== freezed) {
      this.freezed_ = freezed;
      const mesh = this.mesh;
      if (mesh) {
        mesh.traverse(child => {
          if (child.isInteractiveMesh) {
            child.freezed = freezed;
          }
        });
      }
    }
  }
  onInit() {
    super.onInit();
    this.isPresenting = false;
    MenuService.active$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(active => this.freezed = active);
  }
  onChanges() {
    this.editing = this.item.selected;
  }
  onCreate(mount, dismount) {
    this.loadGlb(environment.getPath(this.item.asset.folder), this.item.asset.file, (mesh, animations) => {
      this.onGlbLoaded(mesh, animations, mount, dismount);
    });
  }
  loadGlb(path, file, callback) {
    this.host.renderer;
    // const roughnessMipmapper = new RoughnessMipmapper(renderer); // optional
    const progressRef = LoaderService.getRef();
    // console.log('progressRef');
    const loader = new GLTFLoader().setPath(path);
    // Optional: Provide a DRACOLoader instance to decode compressed mesh data
    const decoderPath = `${environment.dist}js/draco/`;
    // console.log(decoderPath);
    const dracoLoader = new DRACOLoader();
    dracoLoader.setDecoderPath(decoderPath);
    loader.setDRACOLoader(dracoLoader);
    loader.load(file, glb => {
      /*
      glb.scene.traverse((child) => {
      	if (child.isMesh) {
      		// roughnessMipmapper.generateMipmaps(child.material);
      	}
      });
      */
      if (typeof callback === 'function') {
        callback(glb.scene, glb.animations);
      }
      LoaderService.setProgress(progressRef, 1);
      // roughnessMipmapper.dispose();
    }, progressEvent => {
      LoaderService.setProgress(progressRef, progressEvent.loaded, progressEvent.total);
    });
  }
  onGlbLoaded(mesh, animations, mount, dismount) {
    // animations
    this.parseAnimations(mesh, animations);
    // scale
    const box = new THREE.Box3().setFromObject(mesh);
    const size = box.max.clone().sub(box.min);
    const max = Math.max(size.x, size.y, size.z);
    const scale = 1.7 / max;
    mesh.scale.set(scale, scale, scale);
    // repos
    let dummy;
    const view = this.view;
    const item = this.item;
    if (view.type.name === ViewType.Model.name) {
      // this.onUpdateVRSession(this.vrService.currentSession);
      dummy = new THREE.Group();
      dummy.add(mesh);
      box.setFromObject(dummy);
      const center = box.getCenter(new THREE.Vector3());
      dummy.position.set(mesh.position.x - center.x, mesh.position.y - center.y, mesh.position.z - center.z + (this.host.renderer.xr.isPresenting ? -2 : 0)
      // mesh.position.z - center.z,
      );

      const endY = dummy.position.y;
      const from = {
        tween: 1
      };
      const onUpdate = () => {
        dummy.position.y = endY + 3 * from.tween;
        dummy.rotation.y = 0 + Math.PI * from.tween;
      };
      onUpdate();
      this.makeInteractive(mesh);
      gsap.to(from, {
        duration: 1.5,
        tween: 0,
        delay: 0.1,
        ease: Power2.easeInOut,
        onUpdate: onUpdate,
        onComplete: () => {
          this.updateHelper();
        }
      });
    } else {
      box.setFromObject(mesh);
      const center = box.getCenter(new THREE.Vector3());
      mesh.position.set(-center.x, -center.y, -center.z);
      dummy = new THREE.Group();
      dummy.add(mesh);
      if (item.position) {
        dummy.position.fromArray(item.position);
      }
      if (item.rotation) {
        dummy.rotation.fromArray(item.rotation);
      }
      if (item.scale) {
        dummy.scale.fromArray(item.scale);
      }
      this.makeInteractive(mesh);
      /*
      const geometry = ModelModelComponent.getInteractiveGeometry();
      const sphere = new InteractiveMesh(geometry, new THREE.MeshBasicMaterial({
      	depthTest: false,
      	depthWrite: false,
      	transparent: true,
      	// wireframe: true,
      	// opacity: 1.0,
      	opacity: 0.0,
      	color: 0x00ffff,
      }));
      const radius = max * scale / 1.7;
      sphere.scale.set(radius, radius, radius);
      sphere.name = `[model] ${this.item.id}`;
      // sphere.depthTest = false;
      sphere.renderOrder = 0;
      dummy.add(sphere);
      sphere.on('down', () => {
      	// console.log('ModelModelComponent.down');
      	this.down.next(this);
      });
      */
      this.updateHelper();
    }
    if (typeof mount === 'function') {
      mount(dummy, this.item);
      this.freezed = MenuService.active;
    }
  }
  parseAnimations(mesh, animations) {
    // animations
    // console.log('ModelModelComponent.onGlbLoaded', 'animations', animations);
    this.actionIndex = -1;
    const actions = this.actions = [];
    if (animations && animations.length) {
      this.clock = new THREE.Clock();
      const mixer = this.mixer = new THREE.AnimationMixer(mesh);
      mixer.timeScale = 1;
      animations.forEach(animation => {
        const action = mixer.clipAction(animation);
        action.enabled = true;
        action.setEffectiveTimeScale(1);
        action.setEffectiveWeight(1);
        // action.setLoop(THREE.LoopPingPong);
        action.setLoop(THREE.LoopRepeat);
        // action.clampWhenFinished = true; // pause on last frame
        actions.push(action);
      });
    }
  }
  onClipToggle() {
    let actionIndex;
    const actions = this.actions;
    if (actions.length === 1) {
      actionIndex = this.actionIndex === -1 ? 0 : -1;
      this.setSingleAction(actionIndex);
    } else if (actions.length > 1) {
      actionIndex = this.actionIndex + 1;
      if (actionIndex === actions.length) {
        actionIndex = -1;
      }
      this.setMultiAction(actionIndex);
    }
    this.play.next({
      itemId: this.item.id,
      actionIndex
    });
  }
  setSingleAction(actionIndex) {
    if (this.actionIndex !== actionIndex) {
      this.actionIndex = actionIndex;
      const action = this.actions[0];
      if (actionIndex === 0) {
        if (action.paused || action.timeScale === 0) {
          action.paused = false;
        } else {
          action.play();
        }
      } else if (actionIndex === -1) {
        action.halt(0.3);
      }
    }
  }
  setMultiAction(actionIndex) {
    if (this.actionIndex !== actionIndex) {
      const actions = this.actions;
      const previousClip = this.actionIndex > -1 ? actions[this.actionIndex] : null;
      this.actionIndex = actionIndex;
      if (previousClip) {
        previousClip.halt(0.3);
      }
      // console.log('setMultiAction', actionIndex, actions.length);
      if (actionIndex > -1) {
        const action = actions[actionIndex];
        if (action.paused) {
          action.paused = false;
        }
        if (action.timeScale === 0) {
          action.timeScale = 1;
        }
        action.play();
      }
    }
  }
  onMessage(message) {
    switch (message.type) {
      case MessageType.PlayModel:
        {
          const actions = this.actions;
          if (actions.length === 1) {
            this.setSingleAction(message.actionIndex);
          } else if (actions.length > 1) {
            this.setMultiAction(message.actionIndex);
          }
          break;
        }
    }
  }
  render(time, tick) {
    const view = this.view;
    this.item;
    const mesh = this.mesh;
    const isPresenting = this.host.renderer.xr.isPresenting;
    this.group;
    if (mesh) {
      if (view.type.name === ViewType.Model.name) {
        if (this.isPresenting !== isPresenting) {
          this.isPresenting = isPresenting;
          if (isPresenting) {
            mesh.position.x = 0;
            mesh.position.y = 0;
            mesh.position.z = -2;
            mesh.rotation.y = 0;
          } else {
            mesh.position.x = 0;
            mesh.position.y = 0;
            mesh.position.z = 0;
            mesh.rotation.y = 0;
          }
        }
        if (isPresenting) {
          mesh.rotation.y -= Math.PI / 180 / 60 * 5;
        }
      } else {
        if (isPresenting) {
          mesh.rotation.y -= Math.PI / 180 / 60 * 5;
        }
      }
    }
    const mixer = this.mixer;
    const clock = this.clock;
    if (mixer) {
      const delta = clock.getDelta();
      mixer.update(delta);
    }
  }

  // called by UpdateViewItemComponent
  onUpdate(item, mesh) {
    // console.log('ModelModelComponent.onUpdate', item);
    const view = this.view;
    if (view.type.name !== ViewType.Model.name) {
      if (item.position) {
        mesh.position.fromArray(item.position);
      }
      if (item.rotation) {
        mesh.rotation.fromArray(item.rotation);
      }
      if (item.scale) {
        mesh.scale.fromArray(item.scale);
      }
    }
    this.updateHelper();
  }

  // called by UpdateViewItemComponent
  onUpdateAsset(item, mesh) {
    // console.log('ModelModelComponent.onUpdateAsset', item);
    this.loadGlb(environment.getPath(item.asset.folder), item.asset.file, (mesh, animations) => {
      this.onGlbLoaded(mesh, animations, (mesh, item) => this.onMount(mesh, item), (mesh, item) => this.onDismount(mesh, item));
    });
    /*
    this.mesh.updateByItem(item);
    this.mesh.load(() => {
    	// console.log('ModelModelComponent.mesh.load.complete');
    });
    */
  }

  // called by WorldComponent
  onDragMove(position, normal, spherical) {
    // console.log('ModelModelComponent.onDragMove', position, normal, spherical);
    if (spherical) {
      position.normalize().multiplyScalar(4);
    }
    this.editing = true;
    const view = this.view;
    if (view.type.name !== ViewType.Model.name) {
      this.mesh.position.set(position.x, position.y, position.z);
      // this.mesh.lookAt(Host.origin);
    }

    this.updateHelper();
  }

  // called by WorldComponent
  onDragEnd() {
    // console.log('ModelModelComponent.onDragEnd');
    const view = this.view;
    if (view.type.name !== ViewType.Model.name) {
      this.item.position = this.mesh.position.toArray();
      this.item.rotation = this.mesh.rotation.toArray();
      this.item.scale = this.mesh.scale.toArray();
    }
    this.editing = false;
  }
  static getInteractiveDescriptors() {
    let descriptors = ModelModelComponent.interactiveDescriptors;
    if (!descriptors) {
      const freezableDescriptors = Object.getOwnPropertyDescriptors(FreezableMesh.prototype);
      const emittableDescriptors = Object.getOwnPropertyDescriptors(EmittableMesh.prototype);
      const interactiveDescriptors = Object.getOwnPropertyDescriptors(InteractiveMesh.prototype);
      descriptors = Object.assign({}, freezableDescriptors, emittableDescriptors, interactiveDescriptors);
      ModelModelComponent.interactiveDescriptors = descriptors;
    }
    return descriptors;
  }
  makeInteractive(mesh) {
    const interactiveDescriptors = ModelModelComponent.getInteractiveDescriptors();
    mesh.traverse(child => {
      if (child.isMesh) {
        Object.keys(interactiveDescriptors).forEach(key => {
          if (key !== 'constructor') {
            Object.defineProperty(child, key, interactiveDescriptors[key]);
          }
        });
        child.freezed = false;
        child.events = {};
        child.depthTest = true;
        child.over_ = false;
        child.down_ = false;
        Interactive.items.push(child);
        child.on('down', () => {
          // console.log('ModelModelComponent.down', child);
          this.onClipToggle();
          this.down.next(this);
        });
      }
    });
  }
}
ModelModelComponent.meta = {
  selector: '[model-model]',
  hosts: {
    host: WorldComponent
  },
  outputs: ['down', 'play'],
  inputs: ['item', 'view']
};class FreezableSprite extends THREE.Sprite {
  get freezed() {
    return this.freezed_;
  }
  set freezed(freezed) {
    // !!! cycle through freezable and not freezable
    this.freezed_ = freezed;
    this.children.filter(x => x.__lookupGetter__('freezed')).forEach(x => x.freezed = freezed);
  }
  constructor(material) {
    material = material || new THREE.SpriteMaterial({
      color: 0xff00ff
      // opacity: 1,
      // transparent: true,
    });

    super(material);
    this.freezed = false;
  }
  freeze() {
    this.freezed = true;
  }
  unfreeze() {
    this.freezed = false;
  }
}class EmittableSprite extends FreezableSprite {
  constructor(material) {
    material = material || new THREE.SpriteMaterial({
      color: 0xff00ff
      // opacity: 1,
      // transparent: true,
    });

    super(material);
    this.events = {};
  }
  on(type, callback) {
    const event = this.events[type] = this.events[type] || [];
    event.push(callback);
    return () => {
      this.events[type] = event.filter(x => x !== callback);
    };
  }
  off(type, callback) {
    const event = this.events[type];
    if (event) {
      this.events[type] = event.filter(x => x !== callback);
    }
  }
  emit(type, data) {
    const event = this.events[type];
    if (event) {
      event.forEach(callback => {
        // callback.call(this, data);
        callback(data);
      });
    }
    const broadcast = this.events.broadcast;
    if (broadcast) {
      broadcast.forEach(callback => {
        callback(type, data);
      });
    }
  }
}class InteractiveSprite extends EmittableSprite {
  constructor(material) {
    super(material);
    this.depthTest = true;
    this.over_ = false;
    this.down_ = false;
    Interactive.items.push(this);
  }
  get isInteractiveSprite() {
    return true;
  }
  get over() {
    return this.over_;
  }
  set over(over) {
    if (this.over_ != over) {
      this.over_ = over;
      /*
      if (over) {
      	this.emit('hit', this);
      }
      */
      if (over) {
        this.emit('over', this);
      } else {
        this.emit('out', this);
      }
    }
  }
  get down() {
    return this.down_;
  }
  set down(down) {
    down = down && this.over;
    if (this.down_ != down) {
      this.down_ = down;
      if (down) {
        this.emit('down', this);
      } else {
        this.emit('up', this);
      }
    }
  }
}// import domtoimage from 'dom-to-image';

// const USE_DOM_TO_IMAGE = true;

class ModelPanelComponent extends ModelComponent {
  constructor() {
    super(...arguments);
    this.isMobile_ = void 0;
  }
  get isMobile() {
    return this.isMobile_;
  }
  set isMobile(isMobile) {
    if (this.isMobile_ !== isMobile) {
      this.isMobile_ = isMobile;
      this.setScale();
    }
  }
  render(time, tick) {
    // console.log('render', this.host.worldRect.width);
    this.isMobile = this.host.worldRect.width < 768;
  }
  setScale(pow) {
    if (pow === void 0) {
      pow = 0;
    }
    const textureWidth = this.textureWidth;
    const textureHeight = this.textureHeight;
    const item = this.item;
    const panel = this.panel;
    if (panel) {
      const scale = 0.2 * (item.asset ? 1.5 : 1.0) * (this.isMobile ? 1.6 : 1);
      const aspect = textureWidth / textureHeight;
      const width = ModelPanelComponent.PANEL_RADIUS * scale;
      const height = ModelPanelComponent.PANEL_RADIUS * scale / aspect;
      const dy = width * 0.25;
      const position = item.mesh.position.normalize().multiplyScalar(ModelPanelComponent.PANEL_RADIUS);
      panel.position.set(position.x, position.y + (height + dy * 2) - dy * (1 - pow), position.z);
      panel.scale.set(0.02 * width, 0.02 * height, 1);
    }
  }
  onInit() {
    super.onInit();
    this.textureWidth = 0;
    this.textureHeight = 0;
    // console.log('ModelPanelComponent.onInit', this.item);
  }

  onView() {
    if (this.viewed) {
      return;
    }
    this.viewed = true;
    const {
      node
    } = rxcomp.getContext(this);
    this.getCanvasTexture(node).then(texture => {
      this.textureWidth = texture.width;
      this.textureHeight = texture.height;
      if (this.mesh && this.item) {
        const material = new THREE.SpriteMaterial({
          depthTest: false,
          transparent: true,
          opacity: 0,
          map: texture.map,
          sizeAttenuation: false,
          toneMapped: false
        });
        const item = this.item;
        const panel = this.panel = new InteractiveSprite(material);
        panel.renderOrder = environment.renderOrder.panel;
        this.setScale(1);
        panel.on('down', event => {
          // console.log(event.intersection.uv.x, event.intersection.uv.y, node.offsetWidth, node.offsetHeight);
          const xy = {
            x: parseInt(event.intersection.uv.x * node.offsetWidth),
            y: parseInt((1 - event.intersection.uv.y) * node.offsetHeight)
          };
          // console.log('ModelPanelComponent.down.xy', xy);
          const linkNodes = Array.prototype.slice.call(node.querySelectorAll('.panel__link'));
          // console.log('linkNodes', linkNodes);
          const linkNode = linkNodes.find(link => {
            const inside = xy.x >= link.offsetLeft && xy.y >= link.offsetTop && xy.x <= link.offsetLeft + link.offsetWidth && xy.y <= link.offsetTop + link.offsetHeight;
            /*
            console.log(
            	(link.offsetLeft + link.offsetWidth), '>=', xy.x, '>=', link.offsetLeft,
            	(link.offsetTop + link.offsetHeight), '>=', xy.y, '>=', link.offsetTop,
            	inside,
            );
            */
            return inside;
          });
          // console.log('linkNode', linkNode);
          if (linkNode) {
            const linkIndex = linkNodes.indexOf(linkNode);
            const link = item.links[linkIndex];
            // console.log('ModelPanelComponent.down.link', link, linkNode, linkNodes);
            this.down.next({
              item,
              link,
              linkIndex
            });
            const rect = node.getBoundingClientRect();
            const mouseEvent = {
              button: 0,
              buttons: 0,
              clientX: xy.x + rect.left,
              clientY: xy.y + rect.top,
              movementX: 0,
              movementY: 0,
              relatedTarget: linkNode,
              screenX: xy.x,
              screenY: xy.y
            };
            const event = new MouseEvent('mouseup', mouseEvent);
            linkNode.dispatchEvent(event);
            // console.log('ModelPanelComponent.dispatchEvent', mouseEvent);
            setTimeout(() => {
              DragService.dismissEvent(event, DragService.events$, DragService.dismiss$, DragService.downEvent);
            }, 1);
          }
        });
        this.mesh.add(panel);
        const from = {
          value: 0
        };
        gsap.to(from, {
          duration: 0.5,
          value: 1,
          delay: 0.0,
          ease: Power2.easeInOut,
          onUpdate: () => {
            this.setScale(1 - from.value);
            panel.lookAt(Host.origin);
            panel.material.opacity = from.value;
            panel.material.needsUpdate = true;
          }
        });
      }
    }, error => {
      console.log('ModelPanelComponent.getCanvasTexture.error', error);
    });
  }
  onCreate(mount, dismount) {
    const mesh = new THREE.Group();
    if (typeof mount === 'function') {
      mount(mesh);
    }
  }
  onDestroy() {
    // console.log('ModelPanelComponent.onDestroy');
    super.onDestroy();
  }
  imagesLoaded() {
    const {
      node
    } = rxcomp.getContext(this);
    if (node) {
      const images = Array.prototype.slice.call(node.querySelectorAll('img'));
      const promises = images.map(x => new Promise(function (resolve, reject) {
        const cors = x.src && x.src.indexOf(location.origin) === -1;
        if (x.complete) {
          return setTimeout(() => {
            resolve(cors);
          }, 10);
        }
        function onLoad() {
          removeListeners();
          setTimeout(() => {
            resolve(cors);
          }, 10);
        }
        function onError() {
          removeListeners();
          resolve(false);
        }
        function removeListeners() {
          x.removeEventListener('load', onLoad);
          x.removeEventListener('error', onError);
        }
        function addListeners() {
          x.addEventListener('load', onLoad);
          x.addEventListener('error', onError);
        }
        addListeners();
      }));
      if (promises.length) {
        return Promise.all(promises);
      } else {
        return Promise.resolve();
      }
    }
  }
  getCanvasTexture(node) {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        if (this.item.panelTexture) {
          resolve(this.item.panelTexture);
        } else {
          this.imagesLoaded().then(results => {
            const context = rxcomp.getContext(this);
            if (context && context.node) {
              node = context.node;
              const useCORS = results && results.find(x => x === true) != null; // !!! keep loose equality
              // console.log('ModelPanelComponent.getCanvasTexture.useCORS', useCORS);
              /*
              if (USE_DOM_TO_IMAGE) {
              	domtoimage.toBlob(node, { cacheBust: true }).then(function(blob) {
              		createImageBitmap(blob).then(function(imageBitmap) {
              			const map = new THREE.Texture();
              			map.image = imageBitmap;
              			map.needsUpdate = true;
              			this.item.panelTexture = {
              				map: map,
              				width: imageBitmap.width,
              				height: imageBitmap.height,
              			};
              			resolve(this.item.panelTexture);
              				}, error => {
              			reject(error);
              		});
              	}, error => {
              		reject(error);
              	});
              } else {
              */
              /*
              htmlToImage.toCanvas(node).then((canvas) => {
              	// !!!
              	// document.body.appendChild(canvas);
              	// const alpha = this.getAlphaFromCanvas(canvas);
              	// document.body.appendChild(alpha);
              	const map = new THREE.CanvasTexture(canvas);
              	// const alphaMap = new THREE.CanvasTexture(alpha);
              	// console.log(canvas.width, canvas.height);
              	this.item.panelTexture = {
              		map: map,
              		width: canvas.width,
              		height: canvas.height,
              	};
              	resolve(this.item.panelTexture);
              }).catch(error => {
              	console.log('htmlToImage', error);
              	reject(error);
              });
              */
              html2canvas__default["default"](node, {
                backgroundColor: '#ffffff00',
                scale: 1,
                useCORS
                // logging: true,
              }).then(canvas => {
                // !!!
                // document.body.appendChild(canvas);
                // const alpha = this.getAlphaFromCanvas(canvas);
                // document.body.appendChild(alpha);
                const map = new THREE.CanvasTexture(canvas);
                // const alphaMap = new THREE.CanvasTexture(alpha);
                // console.log(canvas.width, canvas.height);
                this.item.panelTexture = {
                  map: map,
                  width: canvas.width,
                  height: canvas.height
                };
                resolve(this.item.panelTexture);
              }, error => {
                reject(error);
              });
              // }
            }
          });
        }
      }, 1); // keep it for childnode images to be compiled
    });
  }
}

ModelPanelComponent.PANEL_RADIUS = 99;
ModelPanelComponent.meta = {
  selector: '[model-panel]',
  hosts: {
    host: WorldComponent
  },
  outputs: ['over', 'out', 'down'],
  inputs: ['item'],
  template: /* html */`
		<div class="panel__title"><span [innerHTML]="item.title"></span></div>
		<div class="panel__abstract"><span [innerHTML]="item.abstract"></span></div>
		<img class="panel__picture" [src]="item.asset | asset" *if="item.asset">
		<a class="panel__link" [href]="link.href" target="_blank" rel="noopener" *for="let link of item.links">
			<span [innerHTML]="link.title"></span>
		</a>
	`
};class ModelPictureComponent extends ModelComponent {
  onInit() {
    super.onInit();
    // console.log('ModelPictureComponent.onInit');
  }

  onCreate(mount, dismount) {
    const mesh = new THREE.Group();
    if (typeof mount === 'function') {
      mount(mesh);
    }
  }

  // onView() { const context = getContext(this); }

  // onChanges() {}
}

ModelPictureComponent.meta = {
  selector: '[model-picture]',
  hosts: {
    host: WorldComponent
  },
  inputs: ['item']
};class ModelPlaneComponent extends ModelEditableComponent {
  onInit() {
    super.onInit();
    // console.log('ModelPlaneComponent.onInit');
  }

  onChanges() {
    const selected = this.item.selected;
    this.editing = selected;
    if (this.mesh) {
      this.mesh.editing = selected;
    }
  }
  onCreate(mount, dismount) {
    const item = this.item;
    const view = this.view;
    view.items;
    const geometry = Geometry.planeGeometry;
    this.onMeshDown = this.onMeshDown.bind(this);
    this.onMeshPlaying = this.onMeshPlaying.bind(this);
    this.onMeshZoomed = this.onMeshZoomed.bind(this);
    this.onMeshCurrentTime = this.onMeshCurrentTime.bind(this);
    let mesh;
    let subscription;
    MediaMesh.getStreamId$(item).pipe(operators.takeUntil(this.unsubscribe$)).subscribe(streamId => {
      // console.log('ModelPlaneComponent.onCreate.streamId', streamId);
      if (this.streamId !== streamId) {
        this.streamId = streamId;
        // !!! called by ModelComponent
        /*
        if (mesh) {
        	dismount(mesh, item);
        }
        */
        if (subscription) {
          subscription.unsubscribe();
          subscription = null;
        }
        if (streamId || !item.asset) {
          item.streamId = streamId;
          mesh = this.disposableMesh = new MediaMesh(item, view, geometry, this.host);
          mesh.updateFromItem(item);
          mesh.name = 'plane';
          mesh.load(() => {
            this.disposableMesh = null;
            if (typeof mount === 'function') {
              mount(mesh, item);
            }
            subscription = mesh.events$().pipe(operators.takeUntil(this.unsubscribe$)).subscribe(() => {});
          });
          this.addMeshListeners(mesh);
        } else if (this.mesh) {
          dismount(this.mesh, item);
        }
        // console.log('streamId', streamId, mesh);
      }
    });
  }

  addMeshListeners(mesh) {
    mesh.on('down', this.onMeshDown);
    mesh.on('playing', this.onMeshPlaying);
    mesh.on('zoomed', this.onMeshZoomed);
    mesh.on('currentTime', this.onMeshCurrentTime);
  }
  removeMeshListeners(mesh) {
    mesh.off('down', this.onMeshDown);
    mesh.off('playing', this.onMeshPlaying);
    mesh.off('zoomed', this.onMeshZoomed);
    mesh.off('currentTime', this.onMeshCurrentTime);
  }
  onMeshDown() {
    // console.log('ModelPanelComponent.onMeshDown');
    this.down.next(this);
  }
  onMeshPlaying(playing) {
    // console.log('ModelPanelComponent.playing', playing);
    this.play.next({
      itemId: this.item.id,
      playing
    });
  }
  onMeshZoomed(zoomed) {
    // console.log('ModelPanelComponent.zoomed', zoomed);
    this.zoom.next({
      itemId: this.item.id,
      zoomed
    });
  }
  onMeshCurrentTime(currentTime) {
    // console.log('ModelPanelComponent.playing', playing);
    this.currentTime.next({
      itemId: this.item.id,
      currentTime
    });
  }
  onDestroy() {
    // console.log('ModelPlaneComponent.onDestroy');
    super.onDestroy();
    if (this.disposableMesh) {
      this.removeMeshListeners(this.disposableMesh);
      this.disposableMesh.dispose();
    }
    if (this.mesh) {
      this.removeMeshListeners(this.mesh);
      this.mesh.dispose();
    }
  }

  // called by UpdateViewItemComponent
  onUpdate(item, mesh) {
    // console.log('ModelPlaneComponent.onUpdate', item);
    mesh.updateFromItem(item);
    this.updateHelper();
  }

  // called by UpdateViewItemComponent
  onUpdateAsset(item, mesh) {
    // console.log('ModelPlaneComponent.onUpdateAsset', item);
    mesh.updateByItem(item);
    MediaMesh.getStreamId$(item).pipe(operators.filter(streamId => streamId !== null), operators.take(1)).subscribe(streamId => {
      item.streamId = streamId;
      mesh.load(() => {
        // console.log('ModelPlaneComponent.mesh.load.complete');
      });
    });
  }

  // called by WorldComponent
  onDragMove(position, normal, spherical) {
    // console.log('ModelPlaneComponent.onDragMove', position, normal, spherical);
    const item = this.item;
    const mesh = this.mesh;
    item.showPanel = false;
    this.editing = true;
    if (spherical) {
      position.normalize().multiplyScalar(20);
      mesh.position.set(position.x, position.y, position.z);
      mesh.lookAt(Host.origin);
    } else {
      mesh.position.set(0, 0, 0);
      mesh.lookAt(normal);
      mesh.position.set(position.x, position.y, position.z);
      mesh.position.add(normal.multiplyScalar(0.01));
    }
    this.updateHelper();
  }

  // called by WorldComponent
  onDragEnd() {
    // console.log('ModelPlaneComponent.onDragEnd');
    const item = this.item;
    const mesh = this.mesh;
    item.position = mesh.position.toArray();
    item.rotation = mesh.rotation.toArray();
    item.scale = mesh.scale.toArray();
    mesh.updateFromItem(item);
    this.editing = false;
  }
}
ModelPlaneComponent.textures = {};
ModelPlaneComponent.meta = {
  selector: '[model-plane]',
  hosts: {
    host: WorldComponent
  },
  outputs: ['down', 'play', 'zoom', 'currentTime'],
  inputs: ['item', 'view']
};// export const LOADING_BANNER = { title: LabelPipe.transform('loading') };
// export const WAITING_BANNER = { title: LabelPipe.transform('waiting_host') };

const PANEL_RADIUS = PANORAMA_RADIUS - 0.01;
class ModelProgressComponent extends ModelComponent {
  get title() {
    return this.title_;
  }
  set title(title) {
    if (this.title_ !== title) {
      this.title_ = title;
      if (title === LabelPipe.transform('waiting_host') || title !== '' && this.visible_) {
        this.updateProgress();
        this.show();
      } else {
        this.hide();
      }
    }
  }
  get visible() {
    return this.visible_;
  }
  set visible(visible) {
    if (this.visible_ !== visible) {
      this.visible_ = visible;
      if (visible && this.title_ !== '') {
        this.updateProgress();
        this.show();
      } else {
        this.hide();
      }
    }
  }
  onInit() {
    this.title_ = '';
    this.visible_ = this.host.renderer.xr.isPresenting;
    super.onInit();
    const vrService = this.vrService = VRService.getService();
    vrService.session$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(session => this.visible = session != null); // loose
    // this.progress = LoaderService.progress;
    /*
    const { node } = getContext(this);
    const inner = node.querySelector('.inner');
    LoaderService.progress$.pipe(
    	takeUntil(this.unsubscribe$)
    ).subscribe(progress => {
    	progress.count > 0 ? node.classList.add('active') : node.classList.remove('active');
    	inner.style.width = `${progress.count}%`;
    });
    */
  }

  onCreate(mount, dismount) {
    // console.log('ModelProgressComponent.onCreate');
    const {
      node
    } = rxcomp.getContext(this);
    const inner = node.querySelector('.inner');
    this.getCanvasTexture().then(result => {
      const mesh = this.createMesh(result);
      if (typeof mount === 'function') {
        mount(mesh);
      }
      LoaderService.progress$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(progress => {
        progress.count > 0 ? node.classList.add('active') : node.classList.remove('active');
        inner.style.width = `${progress.value * 100}%`;
        if (progress.count) {
          this.title = progress.value === 0 ? LabelPipe.transform('loading') : progress.title;
        } else {
          this.title = this.getTitle();
        }
      });
    });
  }
  getTitle() {
    if (this.view && this.view.type.name === ViewType.WaitingRoom.name) {
      return LabelPipe.transform('waiting_host');
    } else {
      return '';
    }
  }
  show() {
    this.mesh.add(this.banner);
    this.material.opacity = 1;
    this.material.needsUpdate = true;
    /*
    const material = this.material;
    const from = { value: material.opacity };
    gsap.to(from, {
    	duration: 0.5,
    	value: 1,
    	delay: 0.0,
    	ease: Power2.easeInOut,
    	overwrite: 'all',
    	onUpdate: () => {
    		material.opacity = from.value;
    		material.needsUpdate = true;
    	}
    });
    */
  }

  hide() {
    this.mesh.remove(this.banner);
    this.material.opacity = 0;
    this.material.needsUpdate = true;
    /*
    const from = { value: material.opacity };
    gsap.to(from, {
    	duration: 0.5,
    	value: 0,
    	delay: 0.0,
    	ease: Power2.easeInOut,
    	overwrite: 'all',
    	onUpdate: () => {
    		material.opacity = from.value;
    		material.needsUpdate = true;
    	},
    	onComplete: () => {
    		this.mesh.remove(this.banner);
    	}
    });
    */
  }

  createMesh(result) {
    const mesh = new THREE.Group();
    // const repeat = 24;
    // const aspect = (result.width * repeat) / result.height;
    const arc = Math.PI / 180 * 360;
    const width = PANEL_RADIUS * arc;
    const height = width / 360 * 2.4;
    const w = result.width * height / result.height;
    const repeat = width / w;
    const geometry = new THREE.CylinderBufferGeometry(PANEL_RADIUS, PANEL_RADIUS, height, 80, 2, true, 0, arc);
    geometry.scale(-1, 1, 1);
    const texture = result.texture;
    texture.wrapS = texture.wrapY = THREE.RepeatWrapping;
    texture.repeat.x = repeat;
    texture.encoding = THREE.sRGBEncoding;
    const material = this.material = new THREE.MeshBasicMaterial({
      map: texture,
      transparent: true,
      opacity: 0,
      toneMapped: false
      // side: THREE.DoubleSide,
    });

    this.banner = new THREE.Mesh(geometry, material);
    mesh.userData = {
      render: () => {
        mesh.rotation.y += Math.PI / 180 * 0.02;
        // texture.offset.x = (texture.offset.x - 0.01) % 1;
        // material.needsUpdate = true;
      }
    };

    return mesh;
  }
  updateProgress() {
    this.getCanvasTexture().then(result => {
      // console.log('ModelProgressComponent.updateProgress', result);
      const arc = Math.PI / 180 * 360;
      const width = PANEL_RADIUS * arc;
      const height = width / 360 * 2.4;
      const w = result.width * height / result.height;
      const repeat = width / w;
      this.texture.repeat.x = repeat;
    });
  }
  getCanvasTexture() {
    return new Promise((resolve, reject) => {
      const MIN_W = 512;
      let W = MIN_W;
      let H = 64;
      const F = Math.floor(H * 0.75);
      const L = Math.floor(H * 0.05);
      let canvas;
      if (this.canvas) {
        canvas = this.canvas;
      } else {
        canvas = this.canvas = document.createElement('canvas');
        // canvas.classList.add('canvas--debug');
        // document.querySelector('body').appendChild(canvas);
      }

      canvas.width = W;
      canvas.height = H;
      const text = this.title_;
      // console.log('ModelProgressComponent.getCanvasTexture', text);
      const ctx = canvas.getContext('2d');
      // const ctx = text.material.map.image.getContext('2d');
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = 'high';
      ctx.font = `300 ${F}px ${environment.fontFamily}`;
      const metrics = ctx.measureText(text);
      W = metrics.width + 8;
      W = Math.max(MIN_W, Math.pow(2, Math.ceil(Math.log(W) / Math.log(2))));
      // const x = W / 2;
      // const y = 16;
      canvas.width = W;
      ctx.clearRect(0, 0, W, H);
      ctx.fillStyle = '#0000005A'; // 35% // '#000000C0'; // 75%
      ctx.fillRect(0, 0, W, H);
      ctx.font = `300 ${F}px ${environment.fontFamily}`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.strokeStyle = 'rgba(0, 0, 0, 0.35)';
      ctx.lineWidth = L;
      ctx.lineJoin = 'round'; // Experiment with 'bevel' & 'round' for the effect you want!
      ctx.miterLimit = 2;
      ctx.strokeText(text, W / 2, H / 2);
      ctx.fillStyle = 'white';
      ctx.fillText(text, W / 2, H / 2, W);
      // text.material.map.needsUpdate = true;
      let texture;
      if (this.texture) {
        texture = this.texture;
        texture.needsUpdate = true;
      } else {
        texture = this.texture = new THREE.CanvasTexture(canvas);
      }
      // console.log(F, L, W, H);
      resolve({
        texture: texture,
        width: W,
        height: H
      });
    });
  }
}
ModelProgressComponent.meta = {
  selector: '[model-progress]',
  hosts: {
    host: WorldComponent
  },
  inputs: ['view']
};class ModelRoomComponent extends ModelComponent {
  static get transparentMaterial() {
    if (!this.transparentMaterial_) {
      this.transparentMaterial_ = new THREE.MeshBasicMaterial({
        color: 0xff0000,
        transparent: true,
        opacity: 0
        // side: THREE.DoubleSide
      });
    }

    return this.transparentMaterial_;
  }
  get freezed() {
    return this.freezed_;
  }
  set freezed(freezed) {
    if (this.freezed_ !== freezed) {
      this.freezed_ = freezed;
      const mesh = this.mesh;
      if (mesh) {
        mesh.traverse(child => {
          if (child.isInteractiveMesh) {
            child.freezed = freezed;
          }
        });
      }
    }
  }
  onInit() {
    // console.log('ModelRoomComponent.onInit');
    super.onInit();
    this.isPresenting = false;
    MenuService.active$.pipe(operators.takeUntil(this.unsubscribe$)).subscribe(active => this.freezed = active);
  }
  onChanges() {
    this.editing = this.view.selected;
  }
  onCreate(mount, dismount) {
    // this.renderOrder = environment.renderOrder.room;
    this.loadGlb(environment.getPath(this.view.asset.folder), this.view.asset.file, (mesh, animations) => {
      this.onGlbLoaded(mesh, animations, mount, dismount);
    });
  }

  // onView() { const context = getContext(this); }

  // onChanges() {}

  loadGlb(path, file, callback) {
    this.host.renderer;
    // const roughnessMipmapper = new RoughnessMipmapper(renderer); // optional
    const progressRef = LoaderService.getRef();
    // console.log('progressRef');
    const loader = new GLTFLoader().setPath(path);
    // Optional: Provide a DRACOLoader instance to decode compressed mesh data
    const decoderPath = `${environment.dist}js/draco/`;
    // console.log(decoderPath);
    const dracoLoader = new DRACOLoader();
    dracoLoader.setDecoderPath(decoderPath);
    loader.setDRACOLoader(dracoLoader);
    loader.load(file, glb => {
      /*
      glb.scene.traverse((child) => {
      	if (child.isMesh) {
      		// roughnessMipmapper.generateMipmaps(child.material);
      	}
      });
      */
      if (typeof callback === 'function') {
        callback(glb.scene, glb.animations);
      }
      // console.log('ModelRoomComponent.loadGlb');
      LoaderService.setProgress(progressRef, 1);
      // roughnessMipmapper.dispose();
    }, progressEvent => {
      LoaderService.setProgress(progressRef, progressEvent.loaded, progressEvent.total);
    });
  }
  onGlbLoaded(mesh, animations, mount, dismount) {
    const view = this.view;
    mesh.position.set(0, -1.76, 0);
    // nav
    const intersectObjects = [];
    mesh.traverse(child => {
      if (child.isMesh) {
        intersectObjects.push(child);
      }
      if (child.name === 'nav') {
        // child.parent.remove(child);
        view.navIntersectObjects = [child];
        this.makeTransparent(child);
      }
    });
    view.intersectObjects = intersectObjects;
    // animations
    let dummy;
    dummy = new THREE.Group();
    dummy.add(mesh);
    if (typeof mount === 'function') {
      mount(dummy, this.view);
    }
  }
  makeTransparent(object) {
    if (object.isMesh) {
      object.material = ModelRoomComponent.transparentMaterial;
    }
    object.traverse(child => {
      if (child.isMesh) {
        child.material = ModelRoomComponent.transparentMaterial;
      }
    });
  }

  // called by UpdateViewItemComponent
  onUpdateAsset(view, mesh) {
    // console.log('ModelRoomComponent.onUpdateAsset', view);
    this.loadGlb(environment.getPath(view.asset.folder), view.asset.file, (mesh, animations) => {
      this.onGlbLoaded(mesh, animations, (mesh, view) => this.onMount(mesh, view), (mesh, view) => this.onDismount(mesh, view));
    });
  }
}
ModelRoomComponent.meta = {
  selector: '[model-room]',
  hosts: {
    host: WorldComponent
  },
  inputs: ['view']
};class ModelTextComponent extends ModelComponent {
  onInit() {
    super.onInit();
    // console.log('ModelTextComponent.onInit');
  }

  onCreate(mount, dismount) {
    const mesh = new THREE.Group();
    if (typeof mount === 'function') {
      mount(mesh);
    }
  }

  // onView() { const context = getContext(this); }

  // onChanges() {}
}

ModelTextComponent.meta = {
  selector: '[model-text]',
  hosts: {
    host: WorldComponent
  },
  inputs: ['item']
};// AgoraService.fixLegacy();

class AppModule extends rxcomp.Module {}
AppModule.meta = {
  imports: [rxcomp.CoreModule, rxcompForm.FormModule, EditorModule],
  declarations: [AccessCodeComponent, AccessComponent, AgoraChatComponent, AgoraChatEmojiComponent, AgoraCheckComponent, AgoraChecklistComponent, AgoraComponent, AgoraConfigureFirewallModalComponent, AgoraDeviceComponent, AgoraDevicePreviewComponent, AgoraLinkComponent, AgoraLoginComponent, AgoraNameComponent, AgoraStreamComponent, AssetPipe, ControlAssetComponent, ControlAssetsComponent, ControlCheckboxComponent, ControlCustomSelectComponent, ControlLinkComponent, ControlLocalizedAssetComponent, ControlMenuComponent, ControlModelComponent, ControlNumberComponent, ControlPasswordComponent, ControlRequestModalComponent, ControlsComponent, ControlSelectComponent, ControlTextareaComponent, ControlTextComponent, ControlVectorComponent, DisabledDirective, DropDirective, DropdownDirective, DropdownItemDirective, EnvPipe, ErrorsComponent, FlagPipe, GenericComponent, GenericModalComponent, HlsDirective, HtmlPipe, IframeModalComponent, IdDirective, InputValueComponent, LabelPipe, LanguageComponent, LayoutComponent, LazyDirective, MediaPlayerComponent, MessagePipe, ModalComponent, ModalOutletComponent, ModelBannerComponent, ModelComponent, ModelCurvedPlaneComponent, ModelDebugComponent, ModelGridComponent, ModelMenuComponent, ModelModelComponent, ModelNavComponent, ModelPanelComponent, ModelPictureComponent, ModelPlaneComponent, ModelProgressComponent, ModelRoomComponent, ModelTextComponent, RoutePipe, SupportRequestModalComponent, SvgIconStructure, TestComponent, TitleDirective, TryInARComponent, TryInARModalComponent, UploadItemComponent, ValueDirective, VirtualStructure, WorldComponent, RouterOutletStructure, RouterLinkDirective],
  bootstrap: AppComponent
};rxcomp.Browser.bootstrap(AppModule);}));